{"buggy_code": ["\n/*\n * Local APIC virtualization\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2007 Novell\n * Copyright (C) 2007 Intel\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Dor Laor <dor.laor@qumranet.com>\n *   Gregory Haskins <ghaskins@novell.com>\n *   Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *\n * Based on Xen 3.1 code, Copyright (c) 2004, Intel Corporation.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <asm/apicdef.h>\n#include <linux/atomic.h>\n#include <linux/jump_label.h>\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"trace.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define PRId64 \"d\"\n#define PRIx64 \"llx\"\n#define PRIu64 \"u\"\n#define PRIo64 \"o\"\n\n#define APIC_BUS_CYCLE_NS 1\n\n/* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */\n#define apic_debug(fmt, arg...)\n\n#define APIC_LVT_NUM\t\t\t6\n/* 14 is the version for Xeon and Pentium 8.4.8*/\n#define APIC_VERSION\t\t\t(0x14UL | ((APIC_LVT_NUM - 1) << 16))\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n/* followed define is not in apicdef.h */\n#define APIC_SHORT_MASK\t\t\t0xc0000\n#define APIC_DEST_NOSHORT\t\t0x0\n#define APIC_DEST_MASK\t\t\t0x800\n#define MAX_APIC_VECTOR\t\t\t256\n#define APIC_VECTORS_PER_REG\t\t32\n\n#define VEC_POS(v) ((v) & (32 - 1))\n#define REG_POS(v) (((v) >> 5) << 4)\n\nstatic unsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}\n\nstatic inline void apic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstruct static_key_deferred apic_hw_disabled __read_mostly;\nstruct static_key_deferred apic_sw_disabled __read_mostly;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\n\t\tif (val & APIC_SPIV_APIC_ENABLED)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n\tapic_set_reg(apic, APIC_SPIV, val);\n}\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}\n\n#define LVT_MASK\t\\\n\t(APIC_LVT_MASKED | APIC_SEND_PENDING | APIC_VECTOR_MASK)\n\n#define LINT_MASK\t\\\n\t(LVT_MASK | APIC_MODE_MASK | APIC_INPUT_POLARITY | \\\n\t APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER)\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}\n\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_ONESHOT);\n}\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_PERIODIC);\n}\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) ==\n\t\t\tAPIC_LVT_TIMER_TSCDEADLINE);\n}\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tapic_set_reg(apic, APIC_LVR, v);\n}\n\nstatic const unsigned int apic_lvt_mask[APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}\n\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tu32 i, pir_val;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(apic->regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_apic_update_irr);\n\nstatic inline void apic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = true;\n\tapic_set_vector(vec, apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = false;\n\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\tif (apic_search_irr(apic) != -1)\n\t\tapic->irr_pending = true;\n}\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\t++apic->isr_count;\n\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t/*\n\t * ISR (in service register) bit is set when injecting an interrupt.\n\t * The highest vector is injected. Thus the latest bit set matches\n\t * the highest bit in ISR.\n\t */\n\tapic->highest_isr_cache = vec;\n}\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\t--apic->isr_count;\n\tBUG_ON(apic->isr_count < 0);\n\tapic->highest_isr_cache = -1;\n}\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\tint highest_irr;\n\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\thighest_irr = apic_find_highest_irr(vcpu->arch.apic);\n\n\treturn highest_irr;\n}\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/* Note that isr_count is always 1 with vid enabled */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, tmr[i]);\n}\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}\n\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\n{\n\treturn dest == 0xff || kvm_apic_id(apic) == dest;\n}\n\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\n{\n\tint result = 0;\n\tu32 logical_id;\n\n\tif (apic_x2apic_mode(apic)) {\n\t\tlogical_id = kvm_apic_get_reg(apic, APIC_LDR);\n\t\treturn logical_id & mda;\n\t}\n\n\tlogical_id = GET_APIC_LOGICAL_ID(kvm_apic_get_reg(apic, APIC_LDR));\n\n\tswitch (kvm_apic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\tif (logical_id & mda)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DFR_CLUSTER:\n\t\tif (((logical_id >> 4) == (mda >> 0x4))\n\t\t    && (logical_id & mda & 0xf))\n\t\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_apic_get_reg(apic, APIC_DFR));\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, int dest, int dest_mode)\n{\n\tint result = 0;\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == 0)\n\t\t\t/* Physical mode. */\n\t\t\tresult = kvm_apic_match_physical_addr(target, dest);\n\t\telse\n\t\t\t/* Logical mode. */\n\t\t\tresult = kvm_apic_match_logical_addr(target, dest);\n\t\tbreak;\n\tcase APIC_DEST_SELF:\n\t\tresult = (target == source);\n\t\tbreak;\n\tcase APIC_DEST_ALLINC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DEST_ALLBUT:\n\t\tresult = (target != source);\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret = false;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == 0) { /* physical mode */\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\t\tirq->dest_id == 0xff)\n\t\t\tgoto out;\n\t\tdst = &map->phys_map[irq->dest_id & 0xff];\n\t} else {\n\t\tu32 mda = irq->dest_id << (32 - map->ldr_bits);\n\n\t\tdst = map->logical_map[apic_cluster_id(map, mda)];\n\n\t\tbitmap = apic_logical_id(map, mda);\n\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/*\n * Add a pending IRQ into lapic.\n * Return 1 if successfully added and 0 if discarded.\n */\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map)\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map);\n\n\t\tif (kvm_x86_ops->deliver_posted_interrupt)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t  trig_mode, vector, false);\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tapic_debug(\"Ignoring guest SMI\\n\");\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\n\t    kvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\n\t\tint trigger_mode;\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\t\telse\n\t\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\t\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n\t}\n}\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}\n\n/*\n * this interface assumes a trap-like exit, which has already finished\n * desired side effect including vISR and vPPR update.\n */\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_set_eoi_accelerated);\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = icr_low & APIC_INT_ASSERT;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}\n\nstatic int apic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}\n\nstatic int apic_mmio_read(struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_apic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_apic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_apic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_x86_ops->read_l1_tsc(vcpu, native_read_tsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t}\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\tktime_add_ns(now, ns), HRTIMER_MODE_ABS);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tint nmi_wd_enabled = apic_lvt_nmi_mode(kvm_apic_get_reg(apic, APIC_LVT0));\n\n\tif (apic_lvt_nmi_mode(lvt0_val)) {\n\t\tif (!nmi_wd_enabled) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode++;\n\t\t}\n\t} else if (nmi_wd_enabled)\n\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode--;\n}\n\nstatic int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_apic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_apic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\t    apic->lapic_timer.timer_mode_mask) !=\n\t\t   (val & apic->lapic_timer.timer_mode_mask))\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tapic_set_reg(apic, APIC_LVTT, val);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}\n\nstatic int apic_mmio_write(struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_has_lapic(vcpu))\n\t\tapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);\n\n/* emulate APIC access in a trap manner */\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tapic_reg_write(vcpu->arch.apic, offset, val);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_write_nodecode);\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED))\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}\n\n/*\n *----------------------------------------------------------------------\n * LAPIC interface\n *----------------------------------------------------------------------\n */\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_apic_get_reg(apic, APIC_TASKPRI) & 4));\n}\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\n\ttpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\t/* update jump label if enable bit changes */\n\tif ((vcpu->arch.apic_base ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif (!kvm_vcpu_is_bsp(apic->vcpu))\n\t\tvalue &= ~MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tu32 id = kvm_apic_id(apic);\n\t\t\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\t\t\tkvm_apic_set_ldr(apic, ldr);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < APIC_LVT_NUM; i++)\n\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_set_reg(apic, APIC_LVT0,\n\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\n\tapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tapic_set_reg(apic, APIC_TASKPRI, 0);\n\tkvm_apic_set_ldr(apic, 0);\n\tapic_set_reg(apic, APIC_ESR, 0);\n\tapic_set_reg(apic, APIC_ICR, 0);\n\tapic_set_reg(apic, APIC_ICR2, 0);\n\tapic_set_reg(apic, APIC_TDCR, 0);\n\tapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(KERN_INFO \"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}\n\n/*\n *----------------------------------------------------------------------\n * timer interface\n *----------------------------------------------------------------------\n */\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (kvm_vcpu_has_lapic(vcpu) && apic_enabled(apic) &&\n\t\t\tapic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_apic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}\n\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\twait_queue_head_t *q = &vcpu->wq;\n\n\t/*\n\t * There is a race window between reading and incrementing, but we do\n\t * not care about potentially losing timer events in the !reinject\n\t * case anyway. Note: KVM_REQ_PENDING_TIMER is implicitly checked\n\t * in vcpu_enter_guest.\n\t */\n\tif (!atomic_read(&ktimer->pending)) {\n\t\tatomic_inc(&ktimer->pending);\n\t\t/* FIXME: this code should not know anything about vcpus */\n\t\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\t}\n\n\tif (waitqueue_active(q))\n\t\twake_up_interruptible(q);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_apic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_apic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\treturn vector;\n}\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tkvm_x86_ops->hwapic_isr_update(vcpu->kvm, apic_find_highest_isr(apic));\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n}\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\n/*\n * apic_sync_pv_eoi_from_guest - called on vmexit or cancel interrupt\n *\n * Detect whether guest triggered PV EOI since the\n * last entry. If yes, set EOI on guests's behalf.\n * Clear PV EOI in guest memory in any case.\n */\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}\n\n/*\n * apic_sync_pv_eoi_to_guest - called before vmentry\n *\n * Detect whether it's safe to enable PV EOI and\n * if yes do so.\n */\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(vcpu->kvm, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (msr == 0x830)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (msr == 0x830)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunsigned int sipi_vector;\n\tunsigned long pe;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\tpe = xchg(&apic->pending_events, 0);\n\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu);\n\t\tkvm_vcpu_reset(vcpu);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tpr_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}\n"], "fixing_code": ["\n/*\n * Local APIC virtualization\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2007 Novell\n * Copyright (C) 2007 Intel\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Dor Laor <dor.laor@qumranet.com>\n *   Gregory Haskins <ghaskins@novell.com>\n *   Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *\n * Based on Xen 3.1 code, Copyright (c) 2004, Intel Corporation.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <asm/apicdef.h>\n#include <linux/atomic.h>\n#include <linux/jump_label.h>\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"trace.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define PRId64 \"d\"\n#define PRIx64 \"llx\"\n#define PRIu64 \"u\"\n#define PRIo64 \"o\"\n\n#define APIC_BUS_CYCLE_NS 1\n\n/* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */\n#define apic_debug(fmt, arg...)\n\n#define APIC_LVT_NUM\t\t\t6\n/* 14 is the version for Xeon and Pentium 8.4.8*/\n#define APIC_VERSION\t\t\t(0x14UL | ((APIC_LVT_NUM - 1) << 16))\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n/* followed define is not in apicdef.h */\n#define APIC_SHORT_MASK\t\t\t0xc0000\n#define APIC_DEST_NOSHORT\t\t0x0\n#define APIC_DEST_MASK\t\t\t0x800\n#define MAX_APIC_VECTOR\t\t\t256\n#define APIC_VECTORS_PER_REG\t\t32\n\n#define VEC_POS(v) ((v) & (32 - 1))\n#define REG_POS(v) (((v) >> 5) << 4)\n\nstatic unsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}\n\nstatic inline void apic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstruct static_key_deferred apic_hw_disabled __read_mostly;\nstruct static_key_deferred apic_sw_disabled __read_mostly;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\n\t\tif (val & APIC_SPIV_APIC_ENABLED)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n\tapic_set_reg(apic, APIC_SPIV, val);\n}\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}\n\n#define LVT_MASK\t\\\n\t(APIC_LVT_MASKED | APIC_SEND_PENDING | APIC_VECTOR_MASK)\n\n#define LINT_MASK\t\\\n\t(LVT_MASK | APIC_MODE_MASK | APIC_INPUT_POLARITY | \\\n\t APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER)\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}\n\n#define KVM_X2APIC_CID_BITS 0\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n\t\t\tnew->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}\n\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_ONESHOT);\n}\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_PERIODIC);\n}\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) ==\n\t\t\tAPIC_LVT_TIMER_TSCDEADLINE);\n}\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tapic_set_reg(apic, APIC_LVR, v);\n}\n\nstatic const unsigned int apic_lvt_mask[APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}\n\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tu32 i, pir_val;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(apic->regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_apic_update_irr);\n\nstatic inline void apic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = true;\n\tapic_set_vector(vec, apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = false;\n\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\tif (apic_search_irr(apic) != -1)\n\t\tapic->irr_pending = true;\n}\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\t++apic->isr_count;\n\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t/*\n\t * ISR (in service register) bit is set when injecting an interrupt.\n\t * The highest vector is injected. Thus the latest bit set matches\n\t * the highest bit in ISR.\n\t */\n\tapic->highest_isr_cache = vec;\n}\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\t--apic->isr_count;\n\tBUG_ON(apic->isr_count < 0);\n\tapic->highest_isr_cache = -1;\n}\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\tint highest_irr;\n\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\thighest_irr = apic_find_highest_irr(vcpu->arch.apic);\n\n\treturn highest_irr;\n}\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/* Note that isr_count is always 1 with vid enabled */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, tmr[i]);\n}\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}\n\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\n{\n\treturn dest == 0xff || kvm_apic_id(apic) == dest;\n}\n\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\n{\n\tint result = 0;\n\tu32 logical_id;\n\n\tif (apic_x2apic_mode(apic)) {\n\t\tlogical_id = kvm_apic_get_reg(apic, APIC_LDR);\n\t\treturn logical_id & mda;\n\t}\n\n\tlogical_id = GET_APIC_LOGICAL_ID(kvm_apic_get_reg(apic, APIC_LDR));\n\n\tswitch (kvm_apic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\tif (logical_id & mda)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DFR_CLUSTER:\n\t\tif (((logical_id >> 4) == (mda >> 0x4))\n\t\t    && (logical_id & mda & 0xf))\n\t\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_apic_get_reg(apic, APIC_DFR));\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, int dest, int dest_mode)\n{\n\tint result = 0;\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == 0)\n\t\t\t/* Physical mode. */\n\t\t\tresult = kvm_apic_match_physical_addr(target, dest);\n\t\telse\n\t\t\t/* Logical mode. */\n\t\t\tresult = kvm_apic_match_logical_addr(target, dest);\n\t\tbreak;\n\tcase APIC_DEST_SELF:\n\t\tresult = (target == source);\n\t\tbreak;\n\tcase APIC_DEST_ALLINC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DEST_ALLBUT:\n\t\tresult = (target != source);\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret = false;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == 0) { /* physical mode */\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\t\tirq->dest_id == 0xff)\n\t\t\tgoto out;\n\t\tdst = &map->phys_map[irq->dest_id & 0xff];\n\t} else {\n\t\tu32 mda = irq->dest_id << (32 - map->ldr_bits);\n\n\t\tdst = map->logical_map[apic_cluster_id(map, mda)];\n\n\t\tbitmap = apic_logical_id(map, mda);\n\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/*\n * Add a pending IRQ into lapic.\n * Return 1 if successfully added and 0 if discarded.\n */\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map)\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map);\n\n\t\tif (kvm_x86_ops->deliver_posted_interrupt)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t  trig_mode, vector, false);\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tapic_debug(\"Ignoring guest SMI\\n\");\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\n\t    kvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\n\t\tint trigger_mode;\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\t\telse\n\t\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\t\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n\t}\n}\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}\n\n/*\n * this interface assumes a trap-like exit, which has already finished\n * desired side effect including vISR and vPPR update.\n */\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_set_eoi_accelerated);\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = icr_low & APIC_INT_ASSERT;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}\n\nstatic int apic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}\n\nstatic int apic_mmio_read(struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_apic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_apic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_apic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_x86_ops->read_l1_tsc(vcpu, native_read_tsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t}\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\tktime_add_ns(now, ns), HRTIMER_MODE_ABS);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tint nmi_wd_enabled = apic_lvt_nmi_mode(kvm_apic_get_reg(apic, APIC_LVT0));\n\n\tif (apic_lvt_nmi_mode(lvt0_val)) {\n\t\tif (!nmi_wd_enabled) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode++;\n\t\t}\n\t} else if (nmi_wd_enabled)\n\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode--;\n}\n\nstatic int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_apic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_apic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\t    apic->lapic_timer.timer_mode_mask) !=\n\t\t   (val & apic->lapic_timer.timer_mode_mask))\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tapic_set_reg(apic, APIC_LVTT, val);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}\n\nstatic int apic_mmio_write(struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_has_lapic(vcpu))\n\t\tapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);\n\n/* emulate APIC access in a trap manner */\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tapic_reg_write(vcpu->arch.apic, offset, val);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_write_nodecode);\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED))\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}\n\n/*\n *----------------------------------------------------------------------\n * LAPIC interface\n *----------------------------------------------------------------------\n */\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_apic_get_reg(apic, APIC_TASKPRI) & 4));\n}\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\n\ttpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\t/* update jump label if enable bit changes */\n\tif ((vcpu->arch.apic_base ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif (!kvm_vcpu_is_bsp(apic->vcpu))\n\t\tvalue &= ~MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tu32 id = kvm_apic_id(apic);\n\t\t\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\t\t\tkvm_apic_set_ldr(apic, ldr);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < APIC_LVT_NUM; i++)\n\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_set_reg(apic, APIC_LVT0,\n\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\n\tapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tapic_set_reg(apic, APIC_TASKPRI, 0);\n\tkvm_apic_set_ldr(apic, 0);\n\tapic_set_reg(apic, APIC_ESR, 0);\n\tapic_set_reg(apic, APIC_ICR, 0);\n\tapic_set_reg(apic, APIC_ICR2, 0);\n\tapic_set_reg(apic, APIC_TDCR, 0);\n\tapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(KERN_INFO \"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}\n\n/*\n *----------------------------------------------------------------------\n * timer interface\n *----------------------------------------------------------------------\n */\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (kvm_vcpu_has_lapic(vcpu) && apic_enabled(apic) &&\n\t\t\tapic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_apic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}\n\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\twait_queue_head_t *q = &vcpu->wq;\n\n\t/*\n\t * There is a race window between reading and incrementing, but we do\n\t * not care about potentially losing timer events in the !reinject\n\t * case anyway. Note: KVM_REQ_PENDING_TIMER is implicitly checked\n\t * in vcpu_enter_guest.\n\t */\n\tif (!atomic_read(&ktimer->pending)) {\n\t\tatomic_inc(&ktimer->pending);\n\t\t/* FIXME: this code should not know anything about vcpus */\n\t\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\t}\n\n\tif (waitqueue_active(q))\n\t\twake_up_interruptible(q);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_apic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_apic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\treturn vector;\n}\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tkvm_x86_ops->hwapic_isr_update(vcpu->kvm, apic_find_highest_isr(apic));\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n}\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\n/*\n * apic_sync_pv_eoi_from_guest - called on vmexit or cancel interrupt\n *\n * Detect whether guest triggered PV EOI since the\n * last entry. If yes, set EOI on guests's behalf.\n * Clear PV EOI in guest memory in any case.\n */\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}\n\n/*\n * apic_sync_pv_eoi_to_guest - called before vmentry\n *\n * Detect whether it's safe to enable PV EOI and\n * if yes do so.\n */\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(vcpu->kvm, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (msr == 0x830)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (msr == 0x830)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunsigned int sipi_vector;\n\tunsigned long pe;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\tpe = xchg(&apic->pending_events, 0);\n\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu);\n\t\tkvm_vcpu_reset(vcpu);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tpr_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}\n"], "filenames": ["arch/x86/kvm/lapic.c"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [184], "fixing_code_start_loc": [146], "fixing_code_end_loc": [187], "type": "CWE-189", "message": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.", "other": {"cve": {"id": "CVE-2013-6376", "sourceIdentifier": "secalert@redhat.com", "published": "2013-12-14T18:08:45.700", "lastModified": "2023-02-13T00:29:02.273", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode."}, {"lang": "es", "value": "La funci\u00f3n recalculate_apic_map en arch/x86/kvm/lapic.c en el subsistema de KVM en el kernel de Linux hasta 3.12.5 permite a los usuarios del sistema operativo virtualizado provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema operativo host) a trav\u00e9s de una operaci\u00f3n de escritura  ICR manipulada en modo x2apic."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.5", "matchCriteriaId": "AEE329D0-23A3-4E91-9A33-E14415E60BA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.7:*:*:*:*:*:*:*", "matchCriteriaId": "2422AC23-8410-4524-A733-25E4ABC7515D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "D835FBA1-49DE-4184-BEC8-7ED2B3F7B0BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "080BD3C9-0606-4D9A-B7AE-3DF9F75B8FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "CCDF0F11-3DB4-41F6-B6D3-383857884258"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.4:*:*:*:*:*:*:*", "matchCriteriaId": "2FB1772A-F4AA-4AB8-9FC9-10993A6A5B46"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=17d68b763f09a9ce824ae23eb62c9efc57b69271", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/12/12/12", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/64319", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2113-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2117-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2136-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1033106", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271"}}