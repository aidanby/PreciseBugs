{"buggy_code": ["/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport dotenv = require(\"dotenv\")\nimport { intersection, sortBy } from \"lodash\"\nimport { resolve, join } from \"path\"\nimport chalk from \"chalk\"\nimport { pathExists } from \"fs-extra\"\nimport { getBuiltinCommands } from \"../commands/commands\"\nimport {\n  shutdown,\n  sleep,\n  getPackageVersion,\n  uuidv4,\n  registerCleanupFunction,\n  getCloudDistributionName,\n} from \"../util/util\"\nimport { Command, CommandResult, CommandGroup, BuiltinArgs } from \"../commands/base\"\nimport { PluginError, toGardenError, GardenBaseError } from \"../exceptions\"\nimport { Garden, GardenOpts, DummyGarden } from \"../garden\"\nimport { getLogger, Logger, LoggerType, LogLevel, parseLogLevel } from \"../logger/logger\"\nimport { FileWriter, FileWriterConfig } from \"../logger/writers/file-writer\"\n\nimport {\n  checkForUpdates,\n  checkForStaticDir,\n  renderCommands,\n  processCliArgs,\n  pickCommand,\n  parseCliArgs,\n  optionsWithAliasValues,\n  getCliStyles,\n} from \"./helpers\"\nimport { Parameters, globalOptions, OUTPUT_RENDERERS, GlobalOptions, ParameterValues } from \"./params\"\nimport {\n  defaultEnvironments,\n  ProjectConfig,\n  defaultNamespace,\n  parseEnvironment,\n  ProjectResource,\n} from \"../config/project\"\nimport { ERROR_LOG_FILENAME, DEFAULT_API_VERSION, DEFAULT_GARDEN_DIR_NAME, LOGS_DIR_NAME } from \"../constants\"\nimport { generateBasicDebugInfoReport } from \"../commands/get/get-debug-info\"\nimport { AnalyticsHandler } from \"../analytics/analytics\"\nimport { BufferedEventStream, ConnectBufferedEventStreamParams } from \"../cloud/buffered-event-stream\"\nimport { defaultDotIgnoreFiles } from \"../util/fs\"\nimport type { GardenProcess } from \"../db/entities/garden-process\"\nimport { DashboardEventStream } from \"../server/dashboard-event-stream\"\nimport { GardenPluginReference } from \"../types/plugin/plugin\"\nimport { renderError } from \"../logger/renderers\"\nimport { CloudApi } from \"../cloud/api\"\nimport { findProjectConfig } from \"../config/base\"\nimport { pMemoizeDecorator } from \"../lib/p-memoize\"\nimport { getCustomCommands } from \"../commands/custom\"\nimport { Profile } from \"../util/profiling\"\nimport { prepareDebugLogfiles } from \"./debug-logs\"\nimport { LogEntry } from \"../logger/log-entry\"\nimport { JsonFileWriter } from \"../logger/writers/json-file-writer\"\nimport { dedent } from \"../util/string\"\nimport { renderDivider } from \"../logger/util\"\nimport { emoji as nodeEmoji } from \"node-emoji\"\n\nexport async function makeDummyGarden(root: string, gardenOpts: GardenOpts) {\n  const environments = gardenOpts.environmentName\n    ? [{ name: parseEnvironment(gardenOpts.environmentName).environment, defaultNamespace, variables: {} }]\n    : defaultEnvironments\n\n  const config: ProjectConfig = {\n    path: root,\n    apiVersion: DEFAULT_API_VERSION,\n    kind: \"Project\",\n    name: \"no-project\",\n    defaultEnvironment: \"\",\n    dotIgnoreFiles: defaultDotIgnoreFiles,\n    environments,\n    providers: [],\n    variables: {},\n  }\n  gardenOpts.config = config\n\n  return DummyGarden.factory(root, { noEnterprise: true, ...gardenOpts })\n}\n\nfunction renderHeader({\n  environmentName,\n  namespaceName,\n  namespaceUrl,\n  distroName,\n}: {\n  environmentName: string\n  namespaceName: string\n  namespaceUrl?: string\n  distroName?: string\n}) {\n  const divider = chalk.gray(renderDivider())\n  let msg = `${nodeEmoji.earth_africa}  Running in namespace ${chalk.cyan(namespaceName + \".\" + environmentName)}`\n\n  if (namespaceUrl) {\n    msg += dedent`\n      \\n\n      ${nodeEmoji.lightning}   Connected to ${distroName}\n      ${nodeEmoji.link}  ${chalk.blueBright.underline(namespaceUrl)}\n    `\n  }\n\n  return dedent`\n    ${divider}\n    ${msg}\n    ${divider}\\n\n  `\n}\n\nexport interface RunOutput {\n  argv: any\n  code: number\n  errors: (GardenBaseError | Error)[]\n  result: any\n  // Mainly used for testing\n  consoleOutput?: string\n}\n\n@Profile()\nexport class GardenCli {\n  private commands: { [key: string]: Command } = {}\n  private fileWritersInitialized: boolean = false\n  private plugins: GardenPluginReference[]\n  private bufferedEventStream: BufferedEventStream | undefined\n  private sessionFinished = false\n  public processRecord: GardenProcess\n\n  constructor({ plugins }: { plugins?: GardenPluginReference[] } = {}) {\n    this.plugins = plugins || []\n\n    const commands = sortBy(getBuiltinCommands(), (c) => c.name)\n    commands.forEach((command) => this.addCommand(command))\n  }\n\n  async renderHelp(workingDir: string) {\n    const cliStyles = getCliStyles()\n\n    const commands = Object.values(this.commands)\n      .sort()\n      .filter((cmd) => cmd.getPath().length === 1)\n\n    let msg = `\n${cliStyles.heading(\"USAGE\")}\n  garden ${cliStyles.commandPlaceholder()} ${cliStyles.optionsPlaceholder()}\n\n${cliStyles.heading(\"COMMANDS\")}\n${renderCommands(commands)}\n    `\n\n    const customCommands = await this.getCustomCommands(workingDir)\n\n    if (customCommands.length > 0) {\n      msg += `\\n${cliStyles.heading(\"CUSTOM COMMANDS\")}\\n${renderCommands(customCommands)}`\n    }\n\n    return msg\n  }\n\n  private async initFileWriters({\n    logger,\n    log,\n    gardenDirPath,\n    commandFullName,\n  }: {\n    logger: Logger\n    log: LogEntry\n    gardenDirPath: string\n    commandFullName: string\n  }) {\n    if (this.fileWritersInitialized) {\n      return\n    }\n    const { debugLogfileName, jsonLogfileName } = await prepareDebugLogfiles(\n      log,\n      join(gardenDirPath, LOGS_DIR_NAME),\n      commandFullName\n    )\n    const logConfigs: FileWriterConfig[] = [\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, debugLogfileName),\n        truncatePrevious: true,\n        level: LogLevel.debug,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, jsonLogfileName),\n        truncatePrevious: true,\n        level: LogLevel.silly,\n        json: true,\n      },\n      {\n        logFilePath: join(gardenDirPath, ERROR_LOG_FILENAME),\n        truncatePrevious: true,\n        level: LogLevel.error,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, ERROR_LOG_FILENAME),\n        level: LogLevel.error,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, \"development.log\"),\n        level: logger.level,\n      },\n    ]\n    for (const config of logConfigs) {\n      logger.addWriter(await (config.json ? JsonFileWriter : FileWriter).factory(config))\n    }\n    this.fileWritersInitialized = true\n  }\n\n  addCommand(command: Command): void {\n    const fullName = command.getFullName()\n\n    if (this.commands[fullName]) {\n      // For now we don't allow multiple definitions of the same command. We may want to revisit this later.\n      throw new PluginError(`Multiple definitions of command \"${fullName}\"`, {})\n    }\n\n    this.commands[fullName] = command\n\n    const { options = {} } = command\n\n    const optKeys = Object.keys(options)\n    const globalKeys = Object.keys(globalOptions)\n    const dupKeys: string[] = intersection(optKeys, globalKeys)\n\n    if (dupKeys.length > 0) {\n      throw new PluginError(`Global option(s) ${dupKeys.join(\" \")} cannot be redefined`, {})\n    }\n  }\n\n  async getGarden(workingDir: string, opts: GardenOpts) {\n    return Garden.factory(workingDir, opts)\n  }\n\n  async runCommand<A extends Parameters, O extends Parameters>({\n    command,\n    parsedArgs,\n    parsedOpts,\n    processRecord,\n    workingDir,\n  }: {\n    command: Command<A, O>\n    parsedArgs: BuiltinArgs & ParameterValues<A>\n    parsedOpts: ParameterValues<GlobalOptions & O>\n    processRecord?: GardenProcess\n    workingDir: string\n  }) {\n    const {\n      \"logger-type\": loggerTypeOpt,\n      \"log-level\": logLevel,\n      \"show-timestamps\": showTimestamps,\n      emoji,\n      \"env\": environmentName,\n      silent,\n      output,\n      \"force-refresh\": forceRefresh,\n      \"var\": cliVars,\n      \"disable-port-forwards\": disablePortForwards,\n    } = parsedOpts\n\n    // Parse command line --var input\n    const parsedCliVars = cliVars ? dotenv.parse(cliVars.join(\"\\n\")) : {}\n\n    // Init logger\n    const level = parseLogLevel(logLevel)\n    let loggerType = <LoggerType>loggerTypeOpt || command.getLoggerType({ opts: parsedOpts, args: parsedArgs })\n\n    if (silent || output) {\n      loggerType = \"quiet\"\n    }\n\n    const logger = Logger.initialize({ level, type: loggerType, useEmoji: emoji, showTimestamps })\n\n    // Currently we initialise empty placeholder entries and pass those to the\n    // framework as opposed to the logger itself. This is to give better control over where on\n    // the screen the logs are printed.\n    const headerLog = logger.placeholder()\n    const log = logger.placeholder()\n    const footerLog = logger.placeholder()\n\n    command.printHeader({ headerLog, args: parsedArgs, opts: parsedOpts })\n\n    // Init enterprise API\n    let cloudApi: CloudApi | null = null\n    if (!command.noProject) {\n      cloudApi = await CloudApi.factory({ log, currentDirectory: workingDir })\n    }\n\n    // Init event & log streaming.\n    const sessionId = uuidv4()\n    this.bufferedEventStream = new BufferedEventStream({\n      log,\n      cloudApi: cloudApi || undefined,\n      sessionId,\n    })\n\n    registerCleanupFunction(\"stream-session-cancelled-event\", () => {\n      if (!this.sessionFinished) {\n        this.bufferedEventStream?.streamEvent(\"sessionCancelled\", {})\n        this.bufferedEventStream?.flushAll()\n      }\n    })\n\n    const dashboardEventStream = new DashboardEventStream({ log, sessionId })\n\n    const commandInfo = {\n      name: command.getFullName(),\n      args: parsedArgs,\n      opts: optionsWithAliasValues(command, parsedOpts),\n    }\n\n    const contextOpts: GardenOpts = {\n      commandInfo,\n      disablePortForwards,\n      environmentName,\n      log,\n      sessionId,\n      forceRefresh,\n      variables: parsedCliVars,\n      plugins: this.plugins,\n      cloudApi: cloudApi || undefined,\n    }\n\n    let garden: Garden\n    let result: CommandResult<any> = {}\n    let analytics: AnalyticsHandler\n\n    const prepareParams = {\n      log,\n      headerLog,\n      footerLog,\n      args: parsedArgs,\n      opts: parsedOpts,\n    }\n\n    const persistent = command.isPersistent(prepareParams)\n\n    await command.prepare(prepareParams)\n\n    contextOpts.persistent = persistent\n    const { streamEvents, streamLogEntries } = command\n    // Print header log before we know the namespace to prevent content from\n    // jumping.\n    // TODO: Link to Cloud namespace page here.\n    const nsLog = headerLog.info(\"\")\n\n    do {\n      try {\n        if (command.noProject) {\n          garden = await makeDummyGarden(workingDir, contextOpts)\n        } else {\n          garden = await this.getGarden(workingDir, contextOpts)\n\n          nsLog.setState(renderHeader({ namespaceName: garden.namespace, environmentName: garden.environmentName }))\n\n          if (processRecord) {\n            // Update the db record for the process\n            await processRecord.setCommand({\n              command: command.name,\n              sessionId: garden.sessionId,\n              persistent,\n              serverHost: command.server?.port ? `http://localhost:${command.server.port}` : null,\n              serverAuthKey: command.server?.authKey || null,\n              projectRoot: garden.projectRoot,\n              projectName: garden.projectName,\n              environmentName: garden.environmentName,\n              namespace: garden.namespace,\n            })\n          }\n\n          // Connect the dashboard event streamer (making sure it doesn't stream to the local server)\n          const commandServerUrl = command.server?.getUrl() || undefined\n          dashboardEventStream.connect({ garden, ignoreHost: commandServerUrl, streamEvents, streamLogEntries })\n          const runningServers = await dashboardEventStream.updateTargets()\n\n          if (cloudApi && !cloudApi.sessionRegistered && command.streamEvents) {\n            // Note: If a config change during a watch-mode command's execution results in the resolved environment\n            // and/or namespace name changing, we don't change the session ID, environment ID or namespace ID used when\n            // streaming events.\n            await cloudApi.registerSession({\n              sessionId,\n              commandInfo,\n              localServerPort: command.server?.port,\n              environment: garden.environmentName,\n              namespace: garden.namespace,\n            })\n          }\n\n          let namespaceUrl: string | undefined\n          if (cloudApi && cloudApi.environmentId && cloudApi.namespaceId) {\n            const project = await cloudApi.getProject()\n            const path = `/projects/${project.id}/environments/${cloudApi.environmentId}/namespaces/${cloudApi.namespaceId}/stack`\n            const url = new URL(path, cloudApi.domain)\n            namespaceUrl = url.href\n          }\n\n          // Print a different header and footer when persistent and connected to Garden Cloud.\n          if (persistent && namespaceUrl) {\n            const distroName = getCloudDistributionName(cloudApi?.domain || \"\")\n            nsLog.setState(\n              renderHeader({\n                namespaceName: garden.namespace,\n                environmentName: garden.environmentName,\n                namespaceUrl,\n                distroName,\n              })\n            )\n            const msg = dedent`\n              ${chalk.cyan(`Connected to ${distroName}! Visit your namespace to streams logs and more.`)}\n              ${nodeEmoji.link}  ${chalk.blueBright.underline(namespaceUrl)}\n            `\n            footerLog.info({\n              emoji: \"sunflower\",\n              msg,\n            })\n          } else if (persistent && command.server) {\n            // If there is an explicit `garden dashboard` process running for the current project+env, and a server\n            // is started in this Command, we show the URL to the external dashboard. Otherwise the built-in one.\n\n            // Note: Lazy-loading for startup performance\n            const { GardenProcess: GP } = require(\"../db/entities/garden-process\")\n\n            const dashboardProcess = GP.getDashboardProcess(runningServers, {\n              projectRoot: garden.projectRoot,\n              projectName: garden.projectName,\n              environmentName: garden.environmentName,\n              namespace: garden.namespace,\n            })\n\n            command.server.showUrl(dashboardProcess?.serverHost || undefined)\n          }\n        }\n\n        if (cloudApi) {\n          log.silly(`Connecting Garden instance to GE BufferedEventStream`)\n          const connectParams: ConnectBufferedEventStreamParams = {\n            garden,\n            streamEvents,\n            streamLogEntries,\n            targets: [\n              {\n                enterprise: true,\n              },\n            ],\n          }\n          this.bufferedEventStream.connect(connectParams)\n          if (streamEvents) {\n            this.bufferedEventStream.streamEvent(\"commandInfo\", commandInfo)\n          }\n        }\n\n        // Register log file writers. We need to do this after the Garden class is initialised because\n        // the file writers depend on the project root.\n        await this.initFileWriters({\n          logger,\n          log,\n          gardenDirPath: garden.gardenDirPath,\n          commandFullName: command.getFullName(),\n        })\n        analytics = await AnalyticsHandler.init(garden, log)\n        analytics.trackCommand(command.getFullName())\n\n        // Note: No reason to await the check\n        checkForUpdates(garden.globalConfigStore, headerLog).catch((err) => {\n          headerLog.verbose(\"Something went wrong while checking for the latest Garden version.\")\n          headerLog.verbose(err)\n        })\n\n        await checkForStaticDir()\n\n        // Check if the command is protected and ask for confirmation to proceed if production flag is \"true\".\n        if (await command.isAllowedToRun(garden, log, parsedOpts)) {\n          // TODO: enforce that commands always output DeepPrimitiveMap\n\n          result = await command.action({\n            garden,\n            cli: this,\n            log,\n            footerLog,\n            headerLog,\n            args: parsedArgs,\n            opts: parsedOpts,\n          })\n        } else {\n          // The command is protected and the user decided to not continue with the exectution.\n          log.setState(\"\\nCommand aborted.\")\n          result = {}\n        }\n        await garden.close()\n      } catch (err) {\n        // Generate a basic report in case Garden.factory(...) fails and command is \"get debug-info\".\n        // Other exceptions are handled within the implementation of \"get debug-info\".\n        if (command.name === \"debug-info\") {\n          // Use default Garden dir name as fallback since Garden class hasn't been initialised\n          await generateBasicDebugInfoReport(\n            workingDir,\n            join(workingDir, DEFAULT_GARDEN_DIR_NAME),\n            log,\n            parsedOpts.format\n          )\n        }\n        throw err\n      } finally {\n        if (!result.restartRequired) {\n          await dashboardEventStream.close()\n          await command.server?.close()\n          cloudApi?.close()\n        }\n      }\n    } while (result.restartRequired)\n\n    return { result, analytics }\n  }\n\n  async run({\n    args,\n    exitOnError,\n    processRecord,\n    cwd,\n  }: {\n    args: string[]\n    exitOnError: boolean\n    processRecord?: GardenProcess\n    cwd?: string\n  }): Promise<RunOutput> {\n    let argv = parseCliArgs({ stringArgs: args, cli: true })\n\n    let logger: Logger\n    const errors: (GardenBaseError | Error)[] = []\n\n    // Note: Circumvents an issue where the process exits before the output is fully flushed.\n    // Needed for output renderers and Winston (see: https://github.com/winstonjs/winston/issues/228)\n    const waitForOutputFlush = () => sleep(100)\n\n    async function done(abortCode: number, consoleOutput: string, result: any = {}) {\n      if (exitOnError) {\n        logger && logger.stop()\n        // tslint:disable-next-line: no-console\n        console.log(consoleOutput)\n        await waitForOutputFlush()\n        await shutdown(abortCode)\n      } else {\n        await waitForOutputFlush()\n      }\n\n      return { argv, code: abortCode, errors, result, consoleOutput }\n    }\n\n    if (argv.v || argv.version || argv._[0] === \"version\") {\n      return done(0, getPackageVersion())\n    }\n\n    const workingDir = resolve(cwd || process.cwd(), argv.root || \"\")\n\n    if (!(await pathExists(workingDir))) {\n      return done(1, chalk.red(`Could not find specified root path (${argv.root})`))\n    }\n\n    if (argv._.length === 0 || argv._[0] === \"help\") {\n      return done(0, await this.renderHelp(workingDir))\n    }\n\n    let projectConfig: ProjectResource | undefined\n\n    // First look for native Garden commands\n    let { command, matchedPath } = pickCommand(Object.values(this.commands), argv._)\n\n    // Load custom commands from current project (if applicable) and see if any match the arguments\n    if (!command) {\n      projectConfig = await this.getProjectConfig(workingDir)\n\n      if (projectConfig) {\n        const customCommands = await this.getCustomCommands(workingDir)\n        const picked = pickCommand(customCommands, argv._)\n        command = picked.command\n        matchedPath = picked.matchedPath\n      }\n    }\n\n    if (!command) {\n      const exitCode = argv.h || argv.help ? 0 : 1\n      return done(exitCode, await this.renderHelp(workingDir))\n    }\n\n    if (command instanceof CommandGroup) {\n      return done(0, command.renderHelp())\n    }\n\n    // Parse the arguments again with the Command set, to fully validate, and to ensure boolean options are\n    // handled correctly\n    argv = parseCliArgs({ stringArgs: args, command, cli: true })\n\n    // Slice command name from the positional args\n    argv._ = argv._.slice(command.getPath().length)\n\n    // handle -h/--help\n    if (argv.h || argv.help) {\n      if (command) {\n        // Show help for command\n        return done(0, command.renderHelp())\n      } else {\n        // Show general help text\n        return done(0, await this.renderHelp(workingDir))\n      }\n    }\n\n    let parsedArgs: BuiltinArgs & ParameterValues<any>\n    let parsedOpts: ParameterValues<any>\n\n    try {\n      const parseResults = processCliArgs({ rawArgs: args, parsedArgs: argv, command, matchedPath, cli: true })\n      parsedArgs = parseResults.args\n      parsedOpts = parseResults.opts\n    } catch (err) {\n      errors.push(...(err.detail?.errors || []).map(toGardenError))\n      return done(1, err.message + \"\\n\" + command.renderHelp())\n    }\n\n    let commandResult: CommandResult<any> | undefined = undefined\n    let analytics: AnalyticsHandler | undefined = undefined\n\n    if (!processRecord) {\n      processRecord = this.processRecord\n    }\n\n    if (!processRecord) {\n      // Note: Lazy-loading for startup performance\n      const { ensureConnected } = require(\"../db/connection\")\n      await ensureConnected()\n      const { GardenProcess: GP } = require(\"../db/entities/garden-process\")\n      processRecord = await GP.register(args)\n    }\n\n    this.processRecord = processRecord!\n\n    try {\n      const runResults = await this.runCommand({ command, parsedArgs, parsedOpts, processRecord, workingDir })\n      commandResult = runResults.result\n      analytics = runResults.analytics\n    } catch (err) {\n      commandResult = { errors: [err] }\n    }\n\n    errors.push(...(commandResult.errors || []))\n\n    // Flushes the Analytics events queue in case there are some remaining events.\n    if (analytics) {\n      await analytics.flush()\n    }\n\n    const gardenErrors: GardenBaseError[] = errors.map(toGardenError)\n\n    // --output option set\n    if (argv.output) {\n      const renderer = OUTPUT_RENDERERS[argv.output]!\n\n      if (gardenErrors.length > 0 || (commandResult.exitCode && commandResult.exitCode !== 0)) {\n        return done(\n          commandResult.exitCode || 1,\n          renderer({ success: false, errors: gardenErrors }),\n          commandResult?.result\n        )\n      } else {\n        return done(0, renderer({ success: true, ...commandResult }), commandResult?.result)\n      }\n    }\n\n    // Logger might not have been initialised if process exits early\n    try {\n      logger = getLogger()\n    } catch (_) {\n      logger = Logger.initialize({\n        level: LogLevel.info,\n        type: \"basic\",\n      })\n    }\n\n    let code = 0\n    if (gardenErrors.length > 0) {\n      if (!command.skipCliErrorSummary) {\n        for (const error of gardenErrors) {\n          const entry = logger.error({\n            msg: error.message,\n            error,\n          })\n          // Output error details to console when log level is silly\n          logger.silly({\n            msg: renderError(entry),\n          })\n        }\n      }\n\n      if (logger.getWriters().find((w) => w instanceof FileWriter)) {\n        logger.info(`\\nSee .garden/${ERROR_LOG_FILENAME} for detailed error message`)\n        await waitForOutputFlush()\n      }\n\n      code = commandResult.exitCode || 1\n    }\n    if (exitOnError) {\n      logger.stop()\n      logger.cleanup()\n    }\n\n    if (this.bufferedEventStream) {\n      if (code === 0) {\n        this.bufferedEventStream.streamEvent(\"sessionCompleted\", {})\n      } else {\n        this.bufferedEventStream.streamEvent(\"sessionFailed\", {})\n      }\n      await this.bufferedEventStream.close()\n      this.sessionFinished = true\n    }\n\n    return { argv, code, errors, result: commandResult?.result }\n  }\n\n  @pMemoizeDecorator()\n  private async getProjectConfig(workingDir: string): Promise<ProjectResource | undefined> {\n    return findProjectConfig(workingDir)\n  }\n\n  @pMemoizeDecorator()\n  private async getCustomCommands(workingDir: string): Promise<Command[]> {\n    const projectConfig = await this.getProjectConfig(workingDir)\n    const projectRoot = projectConfig?.path\n\n    if (!projectRoot) {\n      return []\n    }\n\n    return await getCustomCommands(Object.values(this.commands), projectRoot)\n  }\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport env from \"env-var\"\nimport { resolve, join } from \"path\"\nimport { homedir } from \"os\"\n\nexport const isPkg = !!(<any>process).pkg\n\nexport const LOCAL_CONFIG_FILENAME = \"local-config.yml\"\nexport const GLOBAL_CONFIG_FILENAME = \"global-config.yml\"\nexport const GARDEN_CORE_ROOT = isPkg ? resolve(process.execPath, \"..\") : resolve(__dirname, \"..\", \"..\")\nexport const GARDEN_CLI_ROOT = isPkg ? resolve(process.execPath, \"..\") : resolve(GARDEN_CORE_ROOT, \"..\", \"cli\")\nexport const STATIC_DIR = isPkg ? resolve(process.execPath, \"..\", \"static\") : resolve(GARDEN_CORE_ROOT, \"..\", \"static\")\n// We symlink to it the built dashboard to the core static directory during dev, and copy it there for dist builds\nexport const DASHBOARD_STATIC_DIR = join(STATIC_DIR, \"dashboard\")\nexport const DEFAULT_GARDEN_DIR_NAME = \".garden\"\nexport const LOGS_DIR_NAME = \"logs\"\nexport const GARDEN_GLOBAL_PATH = join(homedir(), DEFAULT_GARDEN_DIR_NAME)\nexport const LOGS_DIR = join(DEFAULT_GARDEN_DIR_NAME, LOGS_DIR_NAME)\nexport const ERROR_LOG_FILENAME = \"error.log\"\nexport const PROJECT_SOURCES_DIR_NAME = join(\"sources\", \"project\")\nexport const MODULE_SOURCES_DIR_NAME = join(\"sources\", \"module\")\nexport const GARDEN_BUILD_VERSION_FILENAME = \"garden-build-version\"\nexport const GARDEN_VERSIONFILE_NAME = \".garden-version\"\nexport const DEFAULT_PORT_PROTOCOL = \"TCP\"\n\nexport const DEFAULT_API_VERSION = \"garden.io/v0\"\n\nexport const DEFAULT_TEST_TIMEOUT = 60 * 1000\nexport const DEFAULT_TASK_TIMEOUT = 60 * 1000\n\nexport type SupportedPlatform = \"linux\" | \"darwin\" | \"win32\"\nexport const SUPPORTED_PLATFORMS: SupportedPlatform[] = [\"linux\", \"darwin\", \"win32\"]\n\nexport type SupportedArchitecture = \"x64\" | \"arm64\"\nexport const SUPPORTED_ARCHITECTURES: SupportedArchitecture[] = [\"x64\", \"arm64\"]\n\n// These keys aren't sensitive, so we ask GitGuardian to ignore them.\nexport const SEGMENT_DEV_API_KEY = \"D3DUZ3lBSDO3krnuIO7eYDdtlDAjooKW\" // ggignore\nexport const SEGMENT_PROD_API_KEY = \"b6ovUD9A0YjQqT3ZWetWUbuZ9OmGxKMa\" // ggignore\n\nexport const DOCS_BASE_URL = \"https://docs.garden.io\"\nexport const VERSION_CHECK_URL = \"https://get.garden.io/version\"\n\n/**\n * Environment variables, with defaults where appropriate.\n *\n * We set this up as a map to facilitate overriding values in tests.\n */\nexport const gardenEnv = {\n  ANALYTICS_DEV: env.get(\"ANALYTICS_DEV\").required(false).asBool(),\n  GARDEN_AUTH_TOKEN: env.get(\"GARDEN_AUTH_TOKEN\").required(false).asString(),\n  GARDEN_CACHE_TTL: env.get(\"GARDEN_CACHE_TTL\").required(false).asInt(),\n  GARDEN_DB_DIR: env.get(\"GARDEN_DB_DIR\").required(false).default(GARDEN_GLOBAL_PATH).asString(),\n  GARDEN_DISABLE_ANALYTICS: env.get(\"GARDEN_DISABLE_ANALYTICS\").required(false).asBool(),\n  GARDEN_DISABLE_PORT_FORWARDS: env.get(\"GARDEN_DISABLE_PORT_FORWARDS\").required(false).asBool(),\n  GARDEN_DISABLE_VERSION_CHECK: env.get(\"GARDEN_DISABLE_VERSION_CHECK\").required(false).asBool(),\n  GARDEN_ENABLE_PROFILING: env.get(\"GARDEN_ENABLE_PROFILING\").required(false).asBool(),\n  GARDEN_ENVIRONMENT: env.get(\"GARDEN_ENVIRONMENT\").required(false).asString(),\n  GARDEN_EXPERIMENTAL_BUILD_STAGE: env.get(\"GARDEN_EXPERIMENTAL_BUILD_STAGE\").required(false).asBool(),\n  GARDEN_GE_SCHEDULED: env.get(\"GARDEN_GE_SCHEDULED\").required(false).asBool(),\n  GARDEN_K8S_BUILD_SYNC_MODE: env.get(\"GARDEN_K8S_BUILD_SYNC_MODE\").required(false).default(\"rsync\").asString(),\n  GARDEN_LEGACY_BUILD_STAGE: env.get(\"GARDEN_LEGACY_BUILD_STAGE\").required(false).asBool(),\n  GARDEN_LOG_LEVEL: env.get(\"GARDEN_LOG_LEVEL\").required(false).asString(),\n  GARDEN_LOGGER_TYPE: env.get(\"GARDEN_LOGGER_TYPE\").required(false).asString(),\n  GARDEN_PROXY_DEFAULT_ADDRESS: env.get(\"GARDEN_PROXY_DEFAULT_ADDRESS\").required(false).asString(),\n  GARDEN_SERVER_PORT: env.get(\"GARDEN_SERVER_PORT\").required(false).asPortNumber(),\n  GARDEN_SKIP_TESTS: env.get(\"GARDEN_SKIP_TESTS\").required(false).default(\"\").asString(),\n  GARDEN_HARD_CONCURRENCY_LIMIT: env.get(\"GARDEN_HARD_CONCURRENCY_LIMIT\").required(false).default(50).asInt(),\n  GARDEN_TASK_CONCURRENCY_LIMIT: env.get(\"GARDEN_TASK_CONCURRENCY_LIMIT\").required(false).default(6).asInt(),\n  GARDEN_WORKFLOW_RUN_UID: env.get(\"GARDEN_WORKFLOW_RUN_UID\").required(false).asString(),\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { omit } from \"lodash\"\nimport { EventEmitter2 } from \"eventemitter2\"\nimport { GraphResult } from \"./task-graph\"\nimport { LogEntryEventPayload } from \"./cloud/buffered-event-stream\"\nimport { ServiceStatus } from \"./types/service\"\nimport { NamespaceStatus, RunStatus } from \"./types/plugin/base\"\nimport { Omit } from \"./util/util\"\nimport { AuthTokenResponse } from \"./cloud/api\"\nimport { RenderedActionGraph } from \"./config-graph\"\nimport { BuildState } from \"./types/plugin/module/build\"\nimport { CommandInfo } from \"./plugin-context\"\nimport { sanitizeObject } from \"./logger/util\"\n\nexport type GardenEventListener<T extends EventName> = (payload: Events[T]) => void\n\n/**\n * This simple class serves as the central event bus for a Garden instance. Its function\n * is mainly to consolidate all events for the instance, to ensure type-safety.\n *\n * See below for the event interfaces.\n */\nexport class EventBus extends EventEmitter2 {\n  constructor() {\n    super({\n      wildcard: false,\n      newListener: false,\n      maxListeners: 100, // we may need to adjust this\n    })\n  }\n\n  emit<T extends EventName>(name: T, payload: Events[T]) {\n    return super.emit(name, payload)\n  }\n\n  on<T extends EventName>(name: T, listener: (payload: Events[T]) => void) {\n    return super.on(name, listener)\n  }\n\n  onAny(listener: <T extends EventName>(name: T, payload: Events[T]) => void) {\n    return super.onAny(<any>listener)\n  }\n\n  once<T extends EventName>(name: T, listener: (payload: Events[T]) => void) {\n    return super.once(name, listener)\n  }\n\n  // TODO: wrap more methods to make them type-safe\n}\n\n/**\n * Supported logger events and their interfaces.\n */\nexport interface LoggerEvents {\n  _test: any\n  logEntry: LogEntryEventPayload\n}\n\nexport type LoggerEventName = keyof LoggerEvents\n\nexport type GraphResultEventPayload = Omit<GraphResult, \"dependencyResults\">\n\nexport interface ServiceStatusPayload extends Omit<ServiceStatus, \"detail\"> {\n  deployStartedAt?: Date\n  deployCompletedAt?: Date\n}\n\nexport function toGraphResultEventPayload(result: GraphResult): GraphResultEventPayload {\n  const payload = sanitizeObject(omit(result, \"dependencyResults\"))\n  if (result.output) {\n    // TODO: Use a combined blacklist of fields from all task types instead of hardcoding here.\n    payload.output = omit(result.output, \"dependencyResults\", \"log\", \"buildLog\", \"detail\")\n    if (result.output.version) {\n      payload.output.version = result.output.version.versionString || null\n    }\n  }\n  return payload\n}\n\n/**\n * Supported Garden events and their interfaces.\n */\nexport interface Events extends LoggerEvents {\n  // Internal test/control events\n  _exit: {}\n  _restart: {}\n  _test: any\n  _workflowRunRegistered: {\n    workflowRunUid: string\n  }\n\n  // Process events\n  serversUpdated: {\n    servers: { host: string; command: string }[]\n  }\n  receivedToken: AuthTokenResponse\n\n  // Session events - one of these is emitted when the command process ends\n  sessionCompleted: {} // Command exited with a 0 status\n  sessionFailed: {} // Command exited with a nonzero status\n  sessionCancelled: {} // Command exited because of an interrupt signal (e.g. CTRL-C)\n\n  // Watcher events\n  configAdded: {\n    path: string\n  }\n  configRemoved: {\n    path: string\n  }\n  internalError: {\n    timestamp: Date\n    error: Error\n  }\n  projectConfigChanged: {}\n  moduleConfigChanged: {\n    names: string[]\n    path: string\n  }\n  moduleSourcesChanged: {\n    names: string[]\n    pathsChanged: string[]\n  }\n  moduleRemoved: {}\n\n  // Command/project metadata events\n  commandInfo: CommandInfo\n\n  // Stack Graph events\n  stackGraph: RenderedActionGraph\n\n  // TaskGraph events\n  taskPending: {\n    addedAt: Date\n    batchId: string\n    key: string\n    type: string\n    name: string\n  }\n  taskProcessing: {\n    startedAt: Date\n    batchId: string\n    key: string\n    type: string\n    name: string\n    versionString: string\n  }\n  taskComplete: GraphResultEventPayload\n  taskError: GraphResultEventPayload\n  taskCancelled: {\n    cancelledAt: Date\n    batchId: string\n    type: string\n    key: string\n    name: string\n  }\n  taskGraphProcessing: {\n    startedAt: Date\n  }\n  taskGraphComplete: {\n    completedAt: Date\n  }\n  watchingForChanges: {}\n  log: {\n    timestamp: number\n    actionUid: string\n    entity: {\n      moduleName: string\n      type: string\n      key: string\n    }\n    data: string\n  }\n\n  // Status events\n\n  /**\n   * In the `buildStatus`, `taskStatus`, `testStatus` and `serviceStatus` events, the optional `actionUid` field\n   * identifies a single build/deploy/run.\n   *\n   * The `build`/`testModule`/`runTask`/`deployService` actions emit two events: One before the plugin handler is\n   * called (a \"building\"/\"running\"/\"deploying\" event), and another one after the handler finishes successfully or\n   * throws an error.\n   *\n   * When logged in, the `actionUid` is used by the Garden Cloud backend to group these two events for each of these\n   * action invocations.\n   *\n   * No `actionUid` is set for the corresponding \"get status\" actions (e.g. `getBuildStatus` or `getServiceStatus`),\n   * since those actions don't result in a build/deploy/run (so there are no associated logs or timestamps to track).\n   */\n\n  buildStatus: {\n    moduleName: string\n    moduleVersion: string\n    /**\n     * `actionUid` should only be defined if `state = \"building\" | \"built\" | \"failed\"` (and not if `state = \"fetched\",\n     * since in that case, no build took place and there are no logs/timestamps to view).\n     */\n    actionUid?: string\n    status: {\n      state: BuildState\n      startedAt?: Date\n      completedAt?: Date\n    }\n  }\n  taskStatus: {\n    taskName: string\n    moduleName: string\n    moduleVersion: string\n    taskVersion: string\n    /**\n     * `actionUid` should only be defined if the task was run , i.e. if `state = \"running\" | \"succeeded\" | \"failed\"`\n     * (and not if `state = \"outdated\" | \"not-implemented, since in that case, no run took place and there are no\n     * logs/timestamps to view).\n     */\n    actionUid?: string\n    status: RunStatus\n  }\n  testStatus: {\n    testName: string\n    moduleName: string\n    moduleVersion: string\n    testVersion: string\n    /**\n     * `actionUid` should only be defined if the test was run, i.e. if `state = \"running\" | \"succeeded\" | \"failed\"`\n     * (and not if `state = \"outdated\" | \"not-implemented, since in that case, no run took place and there are no\n     * logs/timestamps to view).\n     */\n    actionUid?: string\n    status: RunStatus\n  }\n  serviceStatus: {\n    serviceName: string\n    moduleName: string\n    moduleVersion: string\n    serviceVersion: string\n    /**\n     * `actionUid` should only be defined if a deploy took place (i.e. when emitted from the `deployService` action).\n     */\n    actionUid?: string\n    status: ServiceStatusPayload\n  }\n  namespaceStatus: NamespaceStatus\n\n  // Workflow events\n  workflowRunning: {}\n  workflowComplete: {}\n  workflowError: {}\n  workflowStepProcessing: {\n    index: number\n  }\n  workflowStepSkipped: {\n    index: number\n  }\n  workflowStepComplete: {\n    index: number\n    durationMsec: number\n  }\n  workflowStepError: {\n    index: number\n    durationMsec: number\n  }\n}\n\nexport type EventName = keyof Events\n\n// Note: Does not include logger events.\nexport const pipedEventNames: EventName[] = [\n  \"_exit\",\n  \"_restart\",\n  \"_test\",\n  \"_workflowRunRegistered\",\n  \"sessionCompleted\",\n  \"sessionFailed\",\n  \"sessionCancelled\",\n  \"configAdded\",\n  \"configRemoved\",\n  \"internalError\",\n  \"log\",\n  \"moduleConfigChanged\",\n  \"moduleRemoved\",\n  \"commandInfo\",\n  \"moduleSourcesChanged\",\n  \"namespaceStatus\",\n  \"projectConfigChanged\",\n  \"serviceStatus\",\n  \"stackGraph\",\n  \"taskCancelled\",\n  \"taskComplete\",\n  \"taskError\",\n  \"taskGraphComplete\",\n  \"taskGraphProcessing\",\n  \"taskPending\",\n  \"taskProcessing\",\n  \"buildStatus\",\n  \"taskStatus\",\n  \"testStatus\",\n  \"watchingForChanges\",\n  \"workflowComplete\",\n  \"workflowError\",\n  \"workflowRunning\",\n  \"workflowStepComplete\",\n  \"workflowStepError\",\n  \"workflowStepProcessing\",\n  \"workflowStepSkipped\",\n]\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { BufferedEventStream, ConnectBufferedEventStreamParams } from \"../cloud/buffered-event-stream\"\nimport { Profile } from \"../util/profiling\"\nimport { isEqual } from \"lodash\"\n\nconst targetUpdateIntervalMsec = 1000\n\n@Profile()\nexport class DashboardEventStream extends BufferedEventStream {\n  protected intervalMsec = 250\n\n  private targetPollIntervalId?: NodeJS.Timeout\n  private ignoreHost: string | undefined\n\n  connect(params: ConnectBufferedEventStreamParams & { ignoreHost?: string }) {\n    // Need this so the dashboard command doesn't try to send events to itself.\n    // We can't ignore by PID because we wouldn't be able to unit test easily.\n    this.ignoreHost = params.ignoreHost\n    super.connect(params)\n  }\n\n  /**\n   * Updates the list of active dashboard servers to stream events to.\n   * Returns the list of Garden processes matching the current project/env that are active servers.\n   */\n  async updateTargets() {\n    if (!this.garden) {\n      return []\n    }\n\n    // Note: lazy-loading for performance\n    const { GardenProcess } = await import(\"../db/entities/garden-process\")\n\n    const running = await GardenProcess.getActiveProcesses()\n    const servers = running.filter(\n      (p) =>\n        !!p.persistent &&\n        !!p.serverHost &&\n        !!p.serverAuthKey &&\n        !!p.command &&\n        p.projectName === this.garden.projectName &&\n        p.projectRoot === this.garden.projectRoot &&\n        p.environmentName === this.garden.environmentName &&\n        p.namespace === this.garden.namespace &&\n        !(this.ignoreHost && p.serverHost === this.ignoreHost)\n    )\n\n    const currentHosts = this.targets.map((p) => p.host).sort()\n    const newHosts = servers.map((p) => p.serverHost!).sort()\n\n    this.targets = servers.map((p) => ({ host: p.serverHost!, clientAuthToken: p.serverAuthKey!, enterprise: false }))\n\n    // Notify of updates\n    if (this.garden && !isEqual(currentHosts, newHosts)) {\n      this.log.debug(`Updated list of running dashboard servers: ${servers.map((p) => p.serverHost).join(\", \")}`)\n\n      this.garden.events.emit(\"serversUpdated\", {\n        servers: servers.map((p) => ({ command: p.command!, host: p.serverHost! })),\n      })\n    }\n\n    return servers\n  }\n\n  /**\n   * Poll for running dashboard servers\n   */\n  startInterval() {\n    super.startInterval()\n\n    this.targetPollIntervalId = setInterval(() => {\n      this.updateTargets().catch((err) => {\n        this.log.error(err)\n      })\n    }, targetUpdateIntervalMsec)\n  }\n\n  async close() {\n    if (this.targetPollIntervalId) {\n      clearInterval(this.targetPollIntervalId)\n      delete this.targetPollIntervalId\n    }\n    await super.close()\n  }\n\n  streamLogEntry() {\n    // Not streaming log events for now\n    return\n  }\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { Server } from \"http\"\n\nimport chalk from \"chalk\"\nimport Koa from \"koa\"\nimport mount = require(\"koa-mount\")\nimport serve = require(\"koa-static\")\nimport Router = require(\"koa-router\")\nimport websockify from \"koa-websocket\"\nimport bodyParser = require(\"koa-bodyparser\")\nimport getPort = require(\"get-port\")\nimport { omit } from \"lodash\"\n\nimport { Garden } from \"../garden\"\nimport { prepareCommands, parseRequest } from \"./commands\"\nimport { DASHBOARD_STATIC_DIR, gardenEnv } from \"../constants\"\nimport { LogEntry } from \"../logger/log-entry\"\nimport { Command, CommandResult } from \"../commands/base\"\nimport { toGardenError, GardenError } from \"../exceptions\"\nimport { EventName, Events, EventBus, GardenEventListener } from \"../events\"\nimport { uuidv4, ValueOf } from \"../util/util\"\nimport { AnalyticsHandler } from \"../analytics/analytics\"\nimport { joi } from \"../config/common\"\nimport { randomString } from \"../util/string\"\nimport { authTokenHeader } from \"../cloud/api\"\nimport { ApiEventBatch } from \"../cloud/buffered-event-stream\"\nimport { LogLevel } from \"../logger/logger\"\n\n// Note: This is different from the `garden dashboard` default port.\n// We may no longer embed servers in watch processes from 0.13 onwards.\nexport const defaultWatchServerPort = 9777\nconst notReadyMessage = \"Waiting for Garden instance to initialize\"\n\n/**\n * Start an HTTP server that exposes commands and events for the given Garden instance.\n *\n * Please look at the tests for usage examples.\n *\n * NOTES:\n * If `port` is not specified, the default is used or a random free port is chosen if default is not available.\n * This is done so that a process can always create its own server, but we won't need that functionality once we\n * run a shared service across commands.\n */\nexport async function startServer({ log, port }: { log: LogEntry; port?: number }) {\n  // Start HTTP API and dashboard server.\n  // allow overriding automatic port picking\n  if (!port) {\n    port = gardenEnv.GARDEN_SERVER_PORT || undefined\n  }\n  const server = new GardenServer({ log, port })\n  await server.start()\n  return server\n}\n\nexport class GardenServer {\n  private log: LogEntry\n  private debugLog: LogEntry\n  private server: Server\n  private garden: Garden | undefined\n  private app: websockify.App\n  private analytics: AnalyticsHandler\n  private incomingEvents: EventBus\n  private statusLog: LogEntry\n  private serversUpdatedListener: GardenEventListener<\"serversUpdated\">\n  private activePersistentRequests: { [requestId: string]: { command: Command; connId: string } }\n\n  public port: number | undefined\n  public readonly authKey: string\n\n  constructor({ log, port }: { log: LogEntry; port?: number }) {\n    this.log = log\n    this.debugLog = this.log.placeholder({ level: LogLevel.debug, childEntriesInheritLevel: true })\n    this.garden = undefined\n    this.port = port\n    this.authKey = randomString(64)\n    this.incomingEvents = new EventBus()\n    this.activePersistentRequests = {}\n\n    this.serversUpdatedListener = ({ servers }) => {\n      // Update status log line with new `garden dashboard` server, if any\n      for (const { host, command } of servers) {\n        if (command === \"dashboard\") {\n          this.showUrl(host)\n          return\n        }\n      }\n\n      // No active explicit dashboard processes, show own URL instead\n      this.showUrl(this.getUrl())\n    }\n  }\n\n  async start() {\n    if (this.server) {\n      return\n    }\n\n    this.app = await this.createApp()\n\n    if (this.port) {\n      this.server = this.app.listen(this.port)\n    } else {\n      do {\n        try {\n          this.port = await getPort({ port: defaultWatchServerPort })\n          this.server = this.app.listen(this.port)\n        } catch {}\n      } while (!this.server)\n    }\n\n    this.log.info(\"\")\n    this.statusLog = this.log.placeholder()\n  }\n\n  getUrl() {\n    return `http://localhost:${this.port}`\n  }\n\n  showUrl(url?: string) {\n    this.statusLog.setState({\n      emoji: \"sunflower\",\n      msg: chalk.cyan(\"Garden dashboard running at \") + (url || this.getUrl()),\n    })\n  }\n\n  async close() {\n    return this.server.close()\n  }\n\n  setGarden(garden: Garden) {\n    if (this.garden) {\n      this.garden.events.removeListener(\"serversUpdated\", this.serversUpdatedListener)\n    }\n\n    this.garden = garden\n    this.garden.log = this.debugLog\n\n    // Serve artifacts as static assets\n    this.app.use(mount(\"/artifacts\", serve(garden.artifactsPath)))\n\n    // Listen for new dashboard servers\n    garden.events.on(\"serversUpdated\", this.serversUpdatedListener)\n  }\n\n  private async createApp() {\n    // prepare request-command map\n    const commands = prepareCommands()\n\n    const app = websockify(new Koa())\n    const http = new Router()\n\n    /**\n     * HTTP API endpoint (POST /api)\n     *\n     * We don't expose a different route per command, but rather accept a JSON object via POST on /api\n     * with a `command` key. The API wouldn't be RESTful in any meaningful sense anyway, and this\n     * means we can keep a consistent format across mechanisms.\n     */\n    http.post(\"/api\", async (ctx) => {\n      // TODO: require auth key here from 0.13.0 onwards\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      if (!this.analytics) {\n        try {\n          this.analytics = await AnalyticsHandler.init(this.garden, this.debugLog)\n        } catch (err) {\n          throw err\n        }\n      }\n\n      this.analytics.trackApi(\"POST\", ctx.originalUrl, { ...ctx.request.body })\n\n      const { command, log, args, opts } = parseRequest(ctx, this.debugLog, commands, ctx.request.body)\n\n      const prepareParams = {\n        log,\n        headerLog: log,\n        footerLog: log,\n        args,\n        opts,\n      }\n\n      const persistent = command.isPersistent(prepareParams)\n\n      if (persistent) {\n        ctx.throw(400, \"Attempted to run persistent command (e.g. a watch/follow command). Aborting.\")\n      }\n\n      await command.prepare(prepareParams)\n\n      const result = await command.action({\n        garden: this.garden,\n        log,\n        headerLog: log,\n        footerLog: log,\n        args,\n        opts,\n      })\n\n      ctx.status = 200\n      ctx.response.body = result\n    })\n\n    /**\n     * Resolves the URL for the given provider dashboard page, and redirects to it.\n     */\n    http.get(\"/dashboardPages/:pluginName/:pageName\", async (ctx) => {\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      const { pluginName, pageName } = ctx.params\n\n      const actions = await this.garden.getActionRouter()\n      const plugin = await this.garden.getPlugin(pluginName)\n      const page = plugin.dashboardPages.find((p) => p.name === pageName)\n\n      if (!page) {\n        return ctx.throw(400, `Could not find page ${pageName} from provider ${pluginName}`)\n      }\n\n      const { url } = await actions.getDashboardPage({ log: this.log, page, pluginName })\n      ctx.redirect(url)\n    })\n\n    /**\n     * Events endpoint, for ingesting events from other Garden processes, and piping to any open websocket connections.\n     * Requires a valid auth token header, matching `this.authKey`.\n     *\n     * The API matches that of the Garden Cloud /events endpoint.\n     */\n    http.post(\"/events\", async (ctx) => {\n      const authHeader = ctx.header[authTokenHeader]\n\n      if (authHeader !== this.authKey) {\n        ctx.status = 401\n        return\n      }\n\n      // TODO: validate the input\n\n      const batch = ctx.request.body as ApiEventBatch\n      this.debugLog.debug(`Received ${batch.events.length} events from session ${batch.sessionId}`)\n\n      // Pipe the events to the incoming stream, which websocket listeners will then receive\n      batch.events.forEach((e) => this.incomingEvents.emit(e.name, e.payload))\n\n      ctx.status = 200\n    })\n\n    app.use(bodyParser())\n    app.use(http.routes())\n    app.use(http.allowedMethods())\n\n    app.on(\"error\", (err, ctx) => {\n      this.debugLog.info(`API server request failed with status ${ctx.status}: ${err.message}`)\n    })\n\n    // This enables navigating straight to a nested route, e.g. \"localhost:<PORT>/graph\".\n    // FIXME: We need to be able to do this for any route, instead of hard coding the routes like this.\n    const routes = [\"/\", \"/graph\", \"/logs\"]\n    for (const route of routes) {\n      app.use(mount(route, serve(DASHBOARD_STATIC_DIR)))\n    }\n\n    this.addWebsocketEndpoint(app)\n\n    return app\n  }\n\n  private notReady(ctx: Router.IRouterContext) {\n    ctx.status = 503\n    ctx.response.body = notReadyMessage\n  }\n\n  /**\n   * Add the /ws endpoint to the Koa app. Every event emitted to the event bus is forwarded to open\n   * Websocket connections, and clients can send commands over the socket and receive results on the\n   * same connection.\n   */\n  private addWebsocketEndpoint(app: websockify.App) {\n    const wsRouter = new Router()\n\n    wsRouter.get(\"/ws\", async (ctx) => {\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      const connId = uuidv4()\n\n      // TODO: require auth key on connections here, from 0.13.0 onwards\n\n      // The typing for koa-websocket isn't working currently\n      const websocket: Koa.Context[\"ws\"] = ctx[\"websocket\"]\n\n      // Helper to make JSON messages, make them type-safe, and to log errors.\n      const send = <T extends ServerWebsocketMessageType>(type: T, payload: ServerWebsocketMessages[T]) => {\n        const event = { type, ...(<object>payload) }\n        this.log.debug(`Send event: ${JSON.stringify(event)}`)\n        websocket.send(JSON.stringify(event), (err) => {\n          if (err) {\n            this.debugLog.debug({ error: toGardenError(err) })\n          }\n        })\n      }\n\n      const error = (message: string, requestId?: string) => {\n        this.log.debug(message)\n        return send(\"error\", { message, requestId })\n      }\n\n      // Set up heartbeat to detect dead connections\n      let isAlive = true\n\n      let heartbeatInterval = setInterval(() => {\n        if (!isAlive) {\n          this.log.debug(`Connection ${connId} timed out.`)\n          websocket.terminate()\n        }\n\n        isAlive = false\n        this.log.debug(`Connection ${connId} ping.`)\n        websocket.ping(() => {})\n      }, 1000)\n\n      websocket.on(\"pong\", () => {\n        this.log.debug(`Connection ${connId} pong.`)\n        isAlive = true\n      })\n\n      // Pipe everything from the event bus to the socket, as well as from the /events endpoint\n      const eventListener = (name: EventName, payload: any) => send(\"event\", { name, payload })\n      this.garden.events.onAny(eventListener)\n      this.incomingEvents.onAny(eventListener)\n\n      const cleanup = () => {\n        this.log.debug(`Connection ${connId} terminated, cleaning up.`)\n        clearInterval(heartbeatInterval)\n\n        this.garden && this.garden.events.offAny(eventListener)\n        this.incomingEvents.offAny(eventListener)\n\n        for (const [id, req] of Object.entries(this.activePersistentRequests)) {\n          if (connId === req.connId) {\n            req.command.terminate()\n            delete this.activePersistentRequests[id]\n          }\n        }\n      }\n\n      // Make sure we clean up listeners when connections end.\n      websocket.on(\"close\", cleanup)\n\n      // Respond to commands.\n      websocket.on(\"message\", (msg) => {\n        let request: any\n\n        this.log.debug(\"Got request: \" + msg)\n\n        try {\n          request = JSON.parse(msg.toString())\n        } catch {\n          return error(\"Could not parse message as JSON\")\n        }\n\n        const requestId = request.id\n\n        try {\n          joi.attempt(requestId, joi.string().uuid().required())\n        } catch {\n          return error(\"Message should contain an `id` field with a UUID value\", requestId)\n        }\n\n        try {\n          joi.attempt(request.type, joi.string().required())\n        } catch {\n          return error(\"Message should contain a type field\")\n        }\n\n        if (request.type === \"command\") {\n          // Start a command\n          const garden = this.garden\n\n          if (!garden) {\n            return send(\"error\", { requestId, message: notReadyMessage })\n          }\n\n          try {\n            const commands = prepareCommands()\n            const { command, log, args, opts } = parseRequest(\n              ctx,\n              this.debugLog,\n              commands,\n              omit(request, [\"id\", \"type\"])\n            )\n\n            const prepareParams = {\n              log,\n              headerLog: log,\n              footerLog: log,\n              args,\n              opts,\n            }\n\n            const persistent = command.isPersistent(prepareParams)\n\n            command\n              .prepare(prepareParams)\n              .then(() => {\n                if (persistent) {\n                  send(\"commandStart\", {\n                    requestId,\n                    args,\n                    opts,\n                  })\n                  this.activePersistentRequests[requestId] = { command, connId }\n\n                  command.subscribe((data: any) => {\n                    send(\"commandOutput\", {\n                      requestId,\n                      command: command.getFullName(),\n                      data,\n                    })\n                  })\n                }\n\n                // TODO: validate result schema\n                return command.action({\n                  garden,\n                  log,\n                  headerLog: log,\n                  footerLog: log,\n                  args,\n                  opts,\n                })\n              })\n              .then((result) => {\n                send(\"commandResult\", {\n                  requestId,\n                  result: result.result,\n                  errors: result.errors,\n                })\n              })\n              .catch((err) => {\n                error(err.message, requestId)\n              })\n          } catch (err) {\n            return error(err.message, requestId)\n          }\n        } else if (request.type === \"commandStatus\") {\n          const r = this.activePersistentRequests[requestId]\n          const status = r ? \"active\" : \"not found\"\n          send(\"commandStatus\", {\n            requestId,\n            status,\n          })\n        } else if (request.type === \"abortCommand\") {\n          const req = this.activePersistentRequests[requestId]\n          req.command.terminate()\n          delete this.activePersistentRequests[requestId]\n        } else {\n          return send(\"error\", {\n            requestId,\n            message: `Unsupported request type: ${request.type}`,\n          })\n        }\n      })\n    })\n\n    app.ws.use(<Koa.Middleware<any>>wsRouter.routes())\n    app.ws.use(<Koa.Middleware<any>>wsRouter.allowedMethods())\n  }\n}\n\ninterface ServerWebsocketMessages {\n  commandOutput: {\n    requestId: string\n    command: string\n    data: string\n  }\n  commandResult: {\n    requestId: string\n    result: CommandResult<any>\n    errors?: GardenError[]\n  }\n  commandStatus: {\n    requestId: string\n    status: \"active\" | \"not found\"\n  }\n  commandStart: {\n    requestId: string\n    args: object\n    opts: object\n  }\n  error: {\n    requestId?: string\n    message: string\n  }\n  event: {\n    name: EventName\n    payload: ValueOf<Events>\n  }\n}\n\ntype ServerWebsocketMessageType = keyof ServerWebsocketMessages\n\nexport type ServerWebsocketMessage = ServerWebsocketMessages[ServerWebsocketMessageType] & {\n  type: ServerWebsocketMessageType\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { expect } from \"chai\"\nimport nock from \"nock\"\nimport { isEqual } from \"lodash\"\n\nimport { makeDummyGarden, GardenCli } from \"../../../../src/cli/cli\"\nimport {\n  getDataDir,\n  TestGarden,\n  makeTestGardenA,\n  enableAnalytics,\n  projectRootA,\n  TestEventBus,\n  initTestLogger,\n} from \"../../../helpers\"\nimport { gardenEnv, GARDEN_CORE_ROOT } from \"../../../../src/constants\"\nimport { join, resolve } from \"path\"\nimport { Command, CommandGroup, CommandParams, PrepareParams } from \"../../../../src/commands/base\"\nimport { getPackageVersion } from \"../../../../src/util/util\"\nimport { UtilCommand } from \"../../../../src/commands/util/util\"\nimport { StringParameter } from \"../../../../src/cli/params\"\nimport stripAnsi from \"strip-ansi\"\nimport { ToolsCommand } from \"../../../../src/commands/tools\"\nimport { Logger, getLogger } from \"../../../../src/logger/logger\"\nimport { safeLoad } from \"js-yaml\"\nimport { GardenProcess } from \"../../../../src/db/entities/garden-process\"\nimport { ensureConnected } from \"../../../../src/db/connection\"\nimport { startServer, GardenServer } from \"../../../../src/server/server\"\nimport { FancyTerminalWriter } from \"../../../../src/logger/writers/fancy-terminal-writer\"\nimport { BasicTerminalWriter } from \"../../../../src/logger/writers/basic-terminal-writer\"\nimport { envSupportsEmoji } from \"../../../../src/logger/util\"\nimport { expectError } from \"../../../../src/util/testing\"\n\ndescribe(\"cli\", () => {\n  let cli: GardenCli\n\n  before(async () => {\n    await ensureConnected()\n  })\n\n  beforeEach(() => {\n    cli = new GardenCli()\n  })\n\n  afterEach(async () => {\n    if (cli.processRecord && cli.processRecord._id) {\n      await cli.processRecord.remove()\n    }\n  })\n\n  describe(\"run\", () => {\n    it(\"aborts with help text if no positional argument is provided\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with default help text if -h option is set and no command\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-h\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with default help text if --help option is set and no command\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-h\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with command help text if --help option is set and command is specified\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, consoleOutput } = await cli.run({ args: [\"test-command\", \"--help\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(cmd.renderHelp())\n    })\n\n    it(\"aborts with version text if -v is set\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-v\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"aborts with version text if --version is set\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"--version\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"aborts with version text if version is first argument\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"version\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"throws if --root is set, pointing to a non-existent path\", async () => {\n      const path = \"/tmp/hauweighaeighuawek\"\n      const { code, consoleOutput } = await cli.run({ args: [\"--root\", path], exitOnError: false })\n\n      expect(code).to.equal(1)\n      expect(stripAnsi(consoleOutput!)).to.equal(`Could not find specified root path (${path})`)\n    })\n\n    context(\"custom commands\", () => {\n      const root = getDataDir(\"test-projects\", \"custom-commands\")\n\n      it(\"picks up all commands in project root\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        expect(commands.map((c) => c.name).sort()).to.eql([\"combo\", \"echo\", \"run-task\", \"script\"])\n      })\n\n      it(\"runs a custom command\", async () => {\n        const res = await cli.run({ args: [\"echo\", \"foo\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(0)\n      })\n\n      it(\"warns and ignores custom command with same name as built-in command\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The plugin(s) commands are defined in nope.garden.yml\n        expect(commands.map((c) => c.name)).to.not.include(\"plugins\")\n      })\n\n      it(\"warns if a custom command is provided with same name as alias for built-in command\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The plugin(s) commands are defined in nope.garden.yml\n        expect(commands.map((c) => c.name)).to.not.include(\"plugin\")\n      })\n\n      it(\"doesn't pick up commands outside of project root\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The nope command is defined in the `nope` directory in the test project.\n        expect(commands.map((c) => c.name)).to.not.include(\"nope\")\n      })\n\n      it(\"prints custom commands in help text\", async () => {\n        const helpText = stripAnsi(await cli.renderHelp(root))\n\n        expect(helpText).to.include(\"CUSTOM COMMANDS\")\n        expect(helpText).to.include(\"combo     A complete example using most available features\")\n        expect(helpText).to.include(\"echo      Just echo a string\")\n        expect(helpText).to.include(\"run-task  Run the specified task\")\n      })\n\n      it(\"prints help text for a custom command\", async () => {\n        const res = await cli.run({ args: [\"combo\", \"--help\"], exitOnError: false, cwd: root })\n\n        const commands = await cli[\"getCustomCommands\"](root)\n        const command = commands.find((c) => c.name === \"combo\")!\n        const helpText = command.renderHelp()\n\n        expect(res.code).to.equal(0)\n        expect(res.consoleOutput).to.equal(helpText)\n      })\n\n      it(\"errors if a Command resource is invalid\", async () => {\n        return expectError(\n          () =>\n            cli.run({\n              args: [\"echo\", \"foo\"],\n              exitOnError: false,\n              cwd: getDataDir(\"test-projects\", \"custom-commands-invalid\"),\n            }),\n          (err) => expect(err.message).to.include(\"Error validating custom Command 'invalid'\")\n        )\n      })\n\n      it(\"exits with code from exec command if it fails\", async () => {\n        const res = await cli.run({ args: [\"script\", \"exit 2\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(2)\n      })\n\n      it(\"exits with code 1 if Garden command fails\", async () => {\n        const res = await cli.run({ args: [\"run-task\", \"fail\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(1)\n      })\n    })\n\n    context(\"test logger initialization\", () => {\n      const envLoggerType = process.env.GARDEN_LOGGER_TYPE\n\n      // Logger is a singleton and we need to reset it between these tests as we're testing\n      // that it's initialised correctly in this block.\n      beforeEach(() => {\n        delete process.env.GARDEN_LOGGER_TYPE\n        Logger.clearInstance()\n      })\n      // Re-initialise the test logger\n      after(() => {\n        process.env.GARDEN_LOGGER_TYPE = envLoggerType\n        Logger.clearInstance()\n        initTestLogger()\n      })\n\n      it(\"uses the fancy logger by default\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(FancyTerminalWriter)\n      })\n\n      it(\"uses the basic logger if log level > info\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({\n          args: [\"--logger-type=fancy\", \"--log-level=3\", \"test-command\"],\n          exitOnError: false,\n        })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(BasicTerminalWriter)\n      })\n\n      it(\"uses the basic logger if --show-timestamps flag is set to true\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({ args: [\"--logger-type=fancy\", \"--show-timestamps\", \"test-command\"], exitOnError: false })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(BasicTerminalWriter)\n      })\n    })\n\n    it(\"shows group help text if specified command is a group\", async () => {\n      const cmd = new UtilCommand()\n      const { code, consoleOutput } = await cli.run({ args: [\"util\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(cmd.renderHelp())\n    })\n\n    it(\"picks and runs a command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"handles params specified before the command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({ args: [\"--logger-type=basic\", \"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"updates the GardenProcess entry if given with command info before running (no server)\", async () => {\n      const args = [\"test-command\", \"--root\", projectRootA]\n      const record = await GardenProcess.register(args)\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          expect(record.command).to.equal(this.name)\n          expect(record.sessionId).to.equal(garden.sessionId)\n          expect(record.persistent).to.equal(false)\n          expect(record.serverHost).to.equal(null)\n          expect(record.serverAuthKey).to.equal(null)\n          expect(record.projectRoot).to.equal(garden.projectRoot)\n          expect(record.projectName).to.equal(garden.projectName)\n          expect(record.environmentName).to.equal(garden.environmentName)\n          expect(record.namespace).to.equal(garden.namespace)\n\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      try {\n        await cli.run({ args, exitOnError: false, processRecord: record })\n      } finally {\n        await record.remove()\n      }\n    })\n\n    it(\"updates the GardenProcess entry if given with command info before running (with server)\", async () => {\n      const args = [\"test-command\", \"--root\", projectRootA]\n      const record = await GardenProcess.register(args)\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          expect(record.command).to.equal(this.name)\n          expect(record.sessionId).to.equal(garden.sessionId)\n          expect(record.persistent).to.equal(true)\n          expect(record.serverHost).to.equal(this.server!.getUrl())\n          expect(record.serverAuthKey).to.equal(this.server!.authKey)\n          expect(record.projectRoot).to.equal(garden.projectRoot)\n          expect(record.projectName).to.equal(garden.projectName)\n          expect(record.environmentName).to.equal(garden.environmentName)\n          expect(record.namespace).to.equal(garden.namespace)\n\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      try {\n        await cli.run({ args, exitOnError: false, processRecord: record })\n      } finally {\n        await record.remove()\n      }\n    })\n\n    it(\"connects the process to an external dashboard instance if available\", async () => {\n      // Spin up test server and register.\n      // Note: We're using test-project-a and the default env+namespace both here and in the CLI run\n      const serverGarden = await makeTestGardenA()\n      const serverEventBus = new TestEventBus()\n      const server = new GardenServer({ log: serverGarden.log })\n      server[\"incomingEvents\"] = serverEventBus\n      await server.start()\n      server.setGarden(serverGarden)\n\n      const record = await GardenProcess.register([\"dashboard\"])\n      await record.setCommand({\n        command: \"dashboard\",\n        sessionId: serverGarden.sessionId,\n        persistent: true,\n        serverHost: server.getUrl(),\n        serverAuthKey: server.authKey,\n        projectRoot: serverGarden.projectRoot,\n        projectName: serverGarden.projectName,\n        environmentName: serverGarden.environmentName,\n        namespace: serverGarden.namespace,\n      })\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        streamEvents = true\n        streamLogEntries = true\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          garden.events.emit(\"_test\", \"funky functional test\")\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", serverGarden.projectRoot]\n\n      try {\n        await cli.run({ args, exitOnError: false })\n      } finally {\n        await record.remove()\n        await server.close()\n      }\n\n      serverEventBus.expectEvent(\"_test\", \"funky functional test\")\n    })\n\n    it(\"tells the DashboardEventStream to ignore the local server URL\", async () => {\n      const testEventBus = new TestEventBus()\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n          this.server[\"incomingEvents\"] = testEventBus\n        }\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          garden.events.emit(\"_test\", \"nope\")\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", projectRootA]\n\n      await cli.run({ args, exitOnError: false })\n\n      expect(testEventBus.eventLog).to.eql([])\n    })\n\n    it(\"shows the URL of local server if no external dashboard is found\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        isPersistent() {\n          return true\n        }\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action() {\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", projectRootA]\n\n      await cli.run({ args, exitOnError: false })\n\n      const serverStatus = cmd.server![\"statusLog\"].getLatestMessage().msg!\n      expect(stripAnsi(serverStatus)).to.equal(`Garden dashboard running at ${cmd.server!.getUrl()}`)\n    })\n\n    it(\"shows the URL of an external dashboard if applicable, instead of the built-in server URL\", async () => {\n      // Spin up test server and register.\n      // Note: We're using test-project-a and the default env+namespace both here and in the CLI run\n      const serverGarden = await makeTestGardenA()\n      const serverEventBus = new TestEventBus()\n      const server = new GardenServer({ log: serverGarden.log })\n      server[\"incomingEvents\"] = serverEventBus\n      await server.start()\n      server.setGarden(serverGarden)\n\n      const record = await GardenProcess.register([\"dashboard\"])\n      await record.setCommand({\n        command: \"dashboard\",\n        sessionId: serverGarden.sessionId,\n        persistent: true,\n        serverHost: server.getUrl(),\n        serverAuthKey: server.authKey,\n        projectRoot: serverGarden.projectRoot,\n        projectName: serverGarden.projectName,\n        environmentName: serverGarden.environmentName,\n        namespace: serverGarden.namespace,\n      })\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        isPersistent() {\n          return true\n        }\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action({}: CommandParams) {\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", serverGarden.projectRoot]\n\n      try {\n        await cli.run({ args, exitOnError: false })\n      } finally {\n        await record.remove()\n        await server.close()\n      }\n\n      const serverStatus = cmd.server![\"statusLog\"].getLatestMessage().msg!\n      expect(stripAnsi(serverStatus)).to.equal(`Garden dashboard running at ${server.getUrl()}`)\n    })\n\n    it(\"picks and runs a subcommand in a group\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      class TestGroup extends CommandGroup {\n        name = \"test-group\"\n        help = \"\"\n\n        subCommands = [TestCommand]\n      }\n      const group = new TestGroup()\n\n      for (const cmd of group.getSubCommands()) {\n        cli.addCommand(cmd)\n      }\n\n      const { code, result } = await cli.run({ args: [\"test-group\", \"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"correctly parses and passes global options\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const _args = [\n        \"test-command\",\n        \"--root\",\n        \"..\",\n        \"--silent\",\n        \"--env=default\",\n        \"--logger-type\",\n        \"basic\",\n        \"-l=4\",\n        \"--output\",\n        \"json\",\n        \"--yes\",\n        \"--emoji=false\",\n        \"--show-timestamps=false\",\n        \"--force-refresh\",\n        \"--var\",\n        \"my=value,other=something\",\n        \"--disable-port-forwards\",\n      ]\n\n      const { code, result } = await cli.run({\n        args: _args,\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: { \"$all\": _args.slice(1), \"--\": [] },\n        opts: {\n          \"root\": resolve(process.cwd(), \"..\"),\n          \"silent\": true,\n          \"env\": \"default\",\n          \"logger-type\": \"basic\",\n          \"log-level\": \"4\",\n          \"output\": \"json\",\n          \"emoji\": false,\n          \"show-timestamps\": false,\n          \"yes\": true,\n          \"force-refresh\": true,\n          \"var\": [\"my=value\", \"other=something\"],\n          \"version\": false,\n          \"help\": false,\n          \"disable-port-forwards\": true,\n        },\n      })\n    })\n\n    it(\"allows setting env through GARDEN_ENVIRONMENT env variable\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const saveEnv = gardenEnv.GARDEN_ENVIRONMENT\n\n      try {\n        gardenEnv.GARDEN_ENVIRONMENT = \"foo\"\n\n        const { code, result } = await cli.run({\n          args: [\"test-command\"],\n          exitOnError: false,\n        })\n\n        expect(code).to.equal(0)\n        expect(result.opts.env).to.equal(\"foo\")\n      } finally {\n        gardenEnv.GARDEN_ENVIRONMENT = saveEnv\n      }\n    })\n\n    it(\"prefers --env over GARDEN_ENVIRONMENT env variable\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const saveEnv = gardenEnv.GARDEN_ENVIRONMENT\n\n      try {\n        gardenEnv.GARDEN_ENVIRONMENT = \"bar\"\n\n        const { code, result } = await cli.run({\n          args: [\"test-command\", \"--env\", \"foo\"],\n          exitOnError: false,\n        })\n\n        expect(code).to.equal(0)\n        expect(result.opts.env).to.equal(\"foo\")\n      } finally {\n        gardenEnv.GARDEN_ENVIRONMENT = saveEnv\n      }\n    })\n\n    it(\"correctly parses and passes arguments and options for a command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n          bar: new StringParameter({\n            help: \"Another help text.\",\n          }),\n        }\n\n        options = {\n          floop: new StringParameter({\n            help: \"Option help text.\",\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({\n        args: [\"test-command\", \"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\", \"--\", \"extra\"],\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: {\n          \"$all\": [\"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\", \"--\", \"extra\"],\n          \"--\": [\"extra\"],\n          \"foo\": \"foo-arg\",\n          \"bar\": \"bar-arg\",\n        },\n        opts: {\n          \"silent\": false,\n          \"log-level\": \"info\",\n          \"emoji\": envSupportsEmoji(),\n          \"show-timestamps\": false,\n          \"yes\": false,\n          \"force-refresh\": false,\n          \"version\": false,\n          \"help\": false,\n          \"floop\": \"floop-opt\",\n          \"disable-port-forwards\": false,\n        },\n      })\n    })\n\n    it(\"correctly parses and passes arguments and options for a subcommand\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n          bar: new StringParameter({\n            help: \"Another help text.\",\n          }),\n        }\n\n        options = {\n          floop: new StringParameter({\n            help: \"Option help text.\",\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n\n      class TestGroup extends CommandGroup {\n        name = \"test-group\"\n        help = \"\"\n\n        subCommands = [TestCommand]\n      }\n      const group = new TestGroup()\n\n      for (const cmd of group.getSubCommands()) {\n        cli.addCommand(cmd)\n      }\n\n      const { code, result } = await cli.run({\n        args: [\"test-group\", \"test-command\", \"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\"],\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: {\n          \"$all\": [\"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\"],\n          \"--\": [],\n          \"foo\": \"foo-arg\",\n          \"bar\": \"bar-arg\",\n        },\n        opts: {\n          \"silent\": false,\n          \"log-level\": \"info\",\n          \"emoji\": envSupportsEmoji(),\n          \"show-timestamps\": false,\n          \"yes\": false,\n          \"force-refresh\": false,\n          \"version\": false,\n          \"help\": false,\n          \"floop\": \"floop-opt\",\n          \"disable-port-forwards\": false,\n        },\n      })\n    })\n\n    it(\"aborts with usage information on invalid global options\", async () => {\n      const cmd = new ToolsCommand()\n      const { code, consoleOutput } = await cli.run({ args: [\"tools\", \"--logger-type\", \"bla\"], exitOnError: false })\n\n      const stripped = stripAnsi(consoleOutput!).trim()\n\n      expect(code).to.equal(1)\n      expect(\n        stripped.startsWith(\n          'Invalid value for option --logger-type: \"bla\" is not a valid argument (should be any of \"quiet\", \"basic\", \"fancy\", \"json\")'\n        )\n      ).to.be.true\n      expect(consoleOutput).to.include(cmd.renderHelp())\n    })\n\n    it(\"aborts with usage information on missing/invalid command arguments and options\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, consoleOutput } = await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n      const stripped = stripAnsi(consoleOutput!).trim()\n\n      expect(code).to.equal(1)\n      expect(stripped.startsWith(\"Missing required argument foo\")).to.be.true\n      expect(consoleOutput).to.include(cmd.renderHelp())\n    })\n\n    it(\"should pass array of all arguments to commands as $all\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--\", \"-v\", \"--flag\", \"arg\"], exitOnError: false })\n      expect(result.args.$all).to.eql([\"--\", \"-v\", \"--flag\", \"arg\"])\n    })\n\n    it(\"should not parse args after -- and instead pass directly to commands\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--\", \"-v\", \"--flag\", \"arg\"], exitOnError: false })\n      expect(result.args[\"--\"]).to.eql([\"-v\", \"--flag\", \"arg\"])\n    })\n\n    it(\"should correctly parse --var flag\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command-var\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { variables: garden.variables } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({\n        args: [\"test-command-var\", \"--var\", 'key-a=value-a,key-b=\"value with quotes\"'],\n        exitOnError: false,\n      })\n      expect(result).to.eql({ variables: { \"key-a\": \"value-a\", \"key-b\": \"value with quotes\" } })\n    })\n\n    it(\"should output JSON if --output=json\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action() {\n          return { result: { some: \"output\" } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { consoleOutput } = await cli.run({ args: [\"test-command\", \"--output=json\"], exitOnError: false })\n      expect(JSON.parse(consoleOutput!)).to.eql({ result: { some: \"output\" }, success: true })\n    })\n\n    it(\"should output YAML if --output=json\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action() {\n          return { result: { some: \"output\" } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { consoleOutput } = await cli.run({ args: [\"test-command\", \"--output=yaml\"], exitOnError: false })\n      expect(safeLoad(consoleOutput!)).to.eql({ result: { some: \"output\" }, success: true })\n    })\n\n    it(\"should disable port forwards if --disable-port-forwards is set\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n\n        async action({ garden }: CommandParams) {\n          return { result: { garden } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--disable-port-forwards\"], exitOnError: false })\n      expect(result.garden.disablePortForwards).to.be.true\n    })\n\n    it(`should configure a dummy environment when command has noProject=true and --env is specified`, async () => {\n      class TestCommand2 extends Command {\n        name = \"test-command-2\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { environmentName: garden.environmentName } }\n        }\n      }\n\n      const command = new TestCommand2()\n      cli.addCommand(command)\n\n      const { result, errors } = await cli.run({ args: [\"test-command-2\", \"--env\", \"missing-env\"], exitOnError: false })\n      expect(errors).to.eql([])\n      expect(result).to.eql({ environmentName: \"missing-env\" })\n    })\n\n    it(\"should error if an invalid --env parameter is passed\", async () => {\n      class TestCommand3 extends Command {\n        name = \"test-command-3\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { environmentName: garden.environmentName } }\n        }\n      }\n\n      const command = new TestCommand3()\n      cli.addCommand(command)\n\n      const { errors } = await cli.run({ args: [\"test-command-3\", \"--env\", \"$.%\"], exitOnError: false })\n\n      expect(errors.length).to.equal(1)\n      expect(stripAnsi(errors[0].message)).to.equal(\n        \"Invalid value for option --env: Invalid environment specified ($.%): must be a valid environment name or <namespace>.<environment>\"\n      )\n    })\n\n    context(\"test analytics\", () => {\n      const host = \"https://api.segment.io\"\n      const scope = nock(host)\n      let garden: TestGarden\n      let resetAnalyticsConfig: Function\n\n      before(async () => {\n        garden = await makeTestGardenA()\n        resetAnalyticsConfig = await enableAnalytics(garden)\n      })\n\n      after(async () => {\n        await resetAnalyticsConfig()\n        nock.cleanAll()\n      })\n\n      it(\"should wait for queued analytic events to flush\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"hilfe!\"\n          noProject = true\n\n          printHeader() {}\n          async action({ args }) {\n            return { result: { args } }\n          }\n        }\n\n        const command = new TestCommand()\n        cli.addCommand(command)\n\n        scope\n          .post(`/v1/batch`, (body) => {\n            const events = body.batch.map((event: any) => ({\n              event: event.event,\n              type: event.type,\n              name: event.properties.name,\n            }))\n            return isEqual(events, [\n              {\n                event: \"Run Command\",\n                type: \"track\",\n                name: \"test-command\",\n              },\n            ])\n          })\n          .reply(200)\n        await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n        expect(scope.done()).to.not.throw\n      })\n    })\n  })\n\n  describe(\"makeDummyGarden\", () => {\n    it(\"should initialise and resolve config graph in a directory with no project\", async () => {\n      const garden = await makeDummyGarden(join(GARDEN_CORE_ROOT, \"tmp\", \"foobarbas\"), {\n        commandInfo: { name: \"foo\", args: {}, opts: {} },\n      })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n\n    it(\"should correctly configure a dummy environment when a namespace is set\", async () => {\n      const garden = await makeDummyGarden(join(GARDEN_CORE_ROOT, \"tmp\", \"foobarbas\"), {\n        environmentName: \"test.foo\",\n        commandInfo: { name: \"foo\", args: {}, opts: {} },\n      })\n      expect(garden).to.be.ok\n      expect(garden.environmentName).to.equal(\"foo\")\n    })\n\n    it(\"should initialise and resolve config graph in a project with invalid config\", async () => {\n      const root = getDataDir(\"test-project-invalid-config\")\n      const garden = await makeDummyGarden(root, { commandInfo: { name: \"foo\", args: {}, opts: {} } })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n\n    it(\"should initialise and resolve config graph in a project with template strings\", async () => {\n      const root = getDataDir(\"test-project-templated\")\n      const garden = await makeDummyGarden(root, { commandInfo: { name: \"foo\", args: {}, opts: {} } })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { expect } from \"chai\"\nimport { makeTestGardenA, TestEventBus, TestGarden } from \"../../../helpers\"\nimport { GardenServer } from \"../../../../src/server/server\"\nimport { DashboardEventStream } from \"../../../../src/server/dashboard-event-stream\"\nimport { GardenProcess } from \"../../../../src/db/entities/garden-process\"\nimport { randomString } from \"../../../../src/util/string\"\nimport { ensureConnected, getConnection } from \"../../../../src/db/connection\"\nimport pEvent from \"p-event\"\n\ndescribe(\"DashboardEventStream\", () => {\n  let streamer: DashboardEventStream\n  let garden: TestGarden\n\n  const testArg = \"test-\" + randomString(10)\n\n  before(async () => {\n    await ensureConnected()\n  })\n\n  beforeEach(async () => {\n    garden = await makeTestGardenA()\n  })\n\n  afterEach(async () => {\n    // Clean up test records\n    await getConnection()\n      .getRepository(GardenProcess)\n      .createQueryBuilder()\n      .delete()\n      .where(`arguments = :arg`, { arg: testArg })\n      .execute()\n\n    await streamer?.close()\n  })\n\n  after(async () => {\n    await garden?.close()\n  })\n\n  it(\"posts events to the configured target hosts\", async () => {\n    const serverEventBusA = new TestEventBus()\n    const serverEventBusB = new TestEventBus()\n\n    const serverA = new GardenServer({ log: garden.log })\n    const serverB = new GardenServer({ log: garden.log })\n\n    serverA[\"incomingEvents\"] = serverEventBusA\n    serverB[\"incomingEvents\"] = serverEventBusB\n\n    await serverA.start()\n    await serverB.start()\n\n    serverA.setGarden(garden)\n    serverB.setGarden(garden)\n\n    streamer = new DashboardEventStream({\n      log: garden.log,\n      sessionId: garden.sessionId!,\n    })\n    streamer.connect({\n      garden,\n      streamEvents: true,\n      streamLogEntries: true,\n      targets: [\n        { host: serverA.getUrl(), clientAuthToken: serverA.authKey, enterprise: false },\n        { host: serverB.getUrl(), clientAuthToken: serverB.authKey, enterprise: false },\n      ],\n    })\n\n    garden.events.emit(\"_test\", \"foo\")\n\n    // Make sure events are flushed\n    await streamer.close()\n\n    expect(serverEventBusA.eventLog).to.eql([{ name: \"_test\", payload: \"foo\" }])\n    expect(serverEventBusB.eventLog).to.eql([{ name: \"_test\", payload: \"foo\" }])\n  })\n\n  describe(\"updateTargets\", () => {\n    it(\"updates and returns the current list of active servers\", async () => {\n      // Correctly matched\n      const recordA = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n      await recordA.setCommand(values)\n\n      // Inactive\n      const recordB = await GardenProcess.register([testArg])\n      recordB.pid = 9999999\n      await recordB.setCommand(values)\n\n      // Different namespace\n      const recordC = await GardenProcess.register([testArg])\n      await recordC.setCommand({\n        ...values,\n        namespace: \"foo\",\n      })\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      const processes = await streamer.updateTargets()\n\n      expect(processes.length).to.equal(1)\n      expect(processes[0]._id).to.equal(recordA._id)\n    })\n\n    it(\"emits a serversUpdated event when a server is removed\", async () => {\n      // Correctly matched\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n      await record.setCommand(values)\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      await streamer.updateTargets()\n      await record.remove()\n      await streamer.updateTargets()\n\n      garden.events.expectEvent(\"serversUpdated\", { servers: [] })\n    })\n\n    it(\"emits a serversUpdated event when a server is added\", async () => {\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      await streamer.updateTargets()\n      await record.setCommand(values)\n      await streamer.updateTargets()\n\n      garden.events.expectEvent(\"serversUpdated\", { servers: [{ host: values.serverHost, command: \"dashboard\" }] })\n    })\n\n    it(\"ignores servers matching ignoreHost\", async () => {\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        targets: [],\n        streamEvents: true,\n        streamLogEntries: true,\n        ignoreHost: values.serverHost,\n      })\n\n      await record.setCommand(values)\n      const processes = await streamer.updateTargets()\n\n      expect(processes.length).to.equal(0)\n    })\n\n    it(\"returns an empty list when no Garden instance is connected\", async () => {\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      const processes = await streamer.updateTargets()\n      expect(processes).to.eql([])\n    })\n  })\n\n  it(\"polls to update the list of target hosts\", async () => {\n    // Start with no targets and initiate polling\n    streamer = new DashboardEventStream({\n      log: garden.log,\n      sessionId: garden.sessionId!,\n    })\n    streamer.connect({\n      garden,\n      streamEvents: true,\n      streamLogEntries: true,\n      targets: [],\n    })\n\n    // Create a new process record\n    const record = await GardenProcess.register([testArg])\n    await record.setCommand({\n      command: \"dashboard\",\n      sessionId: garden.sessionId,\n      persistent: true,\n      serverHost: \"http://localhost:123456\",\n      serverAuthKey: \"foo\",\n      projectRoot: garden.projectRoot,\n      projectName: garden.projectName,\n      environmentName: garden.environmentName,\n      namespace: garden.namespace,\n    })\n\n    // Wait for it to come up\n    await pEvent(garden.events, \"serversUpdated\", { timeout: 5000 })\n  })\n\n  it.skip(\"removes target hosts that are unreachable\", async () => {\n    // TODO: let's see if we need this on top of the polling\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { makeTestGardenA, taskResultOutputs } from \"../../../helpers\"\nimport { Server } from \"http\"\nimport { startServer, GardenServer } from \"../../../../src/server/server\"\nimport { Garden } from \"../../../../src/garden\"\nimport { expect } from \"chai\"\nimport { deepOmitUndefined, uuidv4, sleep } from \"../../../../src/util/util\"\nimport request = require(\"supertest\")\nimport getPort = require(\"get-port\")\nimport WebSocket = require(\"ws\")\nimport stripAnsi = require(\"strip-ansi\")\nimport { authTokenHeader } from \"../../../../src/cloud/api\"\n\ndescribe(\"GardenServer\", () => {\n  let garden: Garden\n  let gardenServer: GardenServer\n  let server: Server\n  let port: number\n\n  before(async () => {\n    port = await getPort()\n    garden = await makeTestGardenA()\n    gardenServer = await startServer({ log: garden.log, port })\n    server = (<any>gardenServer).server\n  })\n\n  after(async () => {\n    server.close()\n  })\n\n  beforeEach(() => {\n    gardenServer.setGarden(garden)\n  })\n\n  it(\"should show no URL on startup\", async () => {\n    const line = gardenServer[\"statusLog\"]\n    expect(line.getLatestMessage().msg).to.be.undefined\n  })\n\n  it(\"should update dashboard URL with own if the external dashboard goes down\", async () => {\n    gardenServer.showUrl(\"http://foo\")\n    garden.events.emit(\"serversUpdated\", {\n      servers: [],\n    })\n    const line = gardenServer[\"statusLog\"]\n    await sleep(1) // This is enough to let go of the control loop\n    const status = stripAnsi(line.getLatestMessage().msg || \"\")\n    expect(status).to.equal(`Garden dashboard running at ${gardenServer.getUrl()}`)\n  })\n\n  it(\"should update dashboard URL with new one if another is started\", async () => {\n    gardenServer.showUrl(\"http://foo\")\n    garden.events.emit(\"serversUpdated\", {\n      servers: [{ host: \"http://localhost:9800\", command: \"dashboard\" }],\n    })\n    const line = gardenServer[\"statusLog\"]\n    await sleep(1) // This is enough to let go of the control loop\n    const status = stripAnsi(line.getLatestMessage().msg || \"\")\n    expect(status).to.equal(`Garden dashboard running at http://localhost:9800`)\n  })\n\n  describe(\"GET /\", () => {\n    it(\"should return the dashboard index page\", async () => {\n      await request(server).get(\"/\").expect(200)\n    })\n  })\n\n  describe(\"POST /api\", () => {\n    it(\"should 400 on non-JSON body\", async () => {\n      await request(server).post(\"/api\").send(\"foo\").expect(400)\n    })\n\n    it(\"should 400 on invalid payload\", async () => {\n      await request(server).post(\"/api\").send({ foo: \"bar\" }).expect(400)\n    })\n\n    it(\"should 404 on invalid command\", async () => {\n      await request(server).post(\"/api\").send({ command: \"foo\" }).expect(404)\n    })\n\n    it(\"should 503 when Garden instance is not set\", async () => {\n      gardenServer[\"garden\"] = undefined\n      await request(server).post(\"/api\").send({ command: \"get.config\" }).expect(503)\n    })\n\n    it(\"should execute a command and return its results\", async () => {\n      const res = await request(server).post(\"/api\").send({ command: \"get.config\" }).expect(200)\n      const config = await garden.dumpConfig({ log: garden.log })\n      expect(res.body.result).to.eql(deepOmitUndefined(config))\n    })\n\n    it(\"should correctly map arguments and options to commands\", async () => {\n      const res = await request(server)\n        .post(\"/api\")\n        .send({\n          command: \"build\",\n          parameters: {\n            modules: [\"module-a\"],\n            force: true,\n          },\n        })\n        .expect(200)\n\n      expect(taskResultOutputs(res.body.result)).to.eql({\n        \"build.module-a\": {\n          buildLog: \"A\",\n          fresh: true,\n        },\n        \"stage-build.module-a\": {},\n      })\n    })\n  })\n\n  describe(\"/dashboardPages\", () => {\n    it(\"should resolve the URL for the given dashboard page and redirect\", async () => {\n      const res = await request(server).get(\"/dashboardPages/test-plugin/test\").expect(302)\n\n      expect(res.header.location).to.equal(\"http://localhost:12345/test\")\n    })\n  })\n\n  describe(\"/events\", () => {\n    it(\"returns 401 if missing auth header\", async () => {\n      await request(server).post(\"/events\").send({}).expect(401)\n    })\n\n    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n      await request(server)\n        .post(\"/events\")\n        .set({ [authTokenHeader]: \"foo\" })\n        .send({})\n        .expect(401)\n    })\n\n    it(\"posts events on the incoming event bus\", (done) => {\n      let passed = false\n\n      gardenServer[\"incomingEvents\"].on(\"_test\", () => {\n        !passed && done()\n        passed = true\n      })\n\n      request(server)\n        .post(\"/events\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({\n          events: [{ name: \"_test\", payload: { some: \"value\" } }],\n        })\n        .expect(200)\n        .catch(done)\n    })\n  })\n\n  describe(\"/ws\", () => {\n    let ws: WebSocket\n\n    beforeEach((done) => {\n      ws = new WebSocket(`ws://localhost:${port}/ws`)\n      ws.on(\"open\", () => {\n        done()\n      })\n      ws.on(\"error\", done)\n    })\n\n    afterEach(() => {\n      ws.close()\n    })\n\n    const onMessage = (cb: (req: object) => void) => {\n      ws.on(\"message\", (msg) => cb(JSON.parse(msg.toString())))\n    }\n\n    it(\"should emit events from the Garden event bus\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({ type: \"event\", name: \"_test\", payload: \"foo\" })\n        done()\n      })\n      garden.events.emit(\"_test\", \"foo\")\n    })\n\n    it(\"should emit events from the incoming event bus\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({ type: \"event\", name: \"_test\", payload: \"foo\" })\n        done()\n      })\n      gardenServer[\"incomingEvents\"].emit(\"_test\", \"foo\")\n    })\n\n    it(\"should send error when a request is not valid JSON\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Could not parse message as JSON\",\n        })\n        done()\n      })\n      ws.send(\"ijdgkasdghlasdkghals\")\n    })\n\n    it(\"should send error when Garden instance is not set\", (done) => {\n      const id = uuidv4()\n\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Waiting for Garden instance to initialize\",\n          requestId: id,\n        })\n        done()\n      })\n\n      gardenServer[\"garden\"] = undefined\n\n      ws.send(\n        JSON.stringify({\n          type: \"command\",\n          id,\n          command: \"get.config\",\n        })\n      )\n    })\n\n    it(\"should error when a request is missing an ID\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Message should contain an `id` field with a UUID value\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"command\" }))\n    })\n\n    it(\"should error when a request has an invalid ID\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          requestId: \"ksdhgalsdkjghalsjkg\",\n          message: \"Message should contain an `id` field with a UUID value\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"command\", id: \"ksdhgalsdkjghalsjkg\" }))\n    })\n\n    it(\"should error when a request has an invalid type\", (done) => {\n      const id = uuidv4()\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          requestId: id,\n          message: \"Unsupported request type: foo\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"foo\", id }))\n    })\n\n    it(\"should execute a command and return its results\", (done) => {\n      const id = uuidv4()\n\n      garden\n        .dumpConfig({ log: garden.log })\n        .then((config) => {\n          onMessage((req: any) => {\n            if (req.type !== \"commandResult\") {\n              return\n            }\n\n            expect(req).to.eql({\n              type: \"commandResult\",\n              requestId: id,\n              result: deepOmitUndefined(config),\n            })\n            done()\n          })\n          ws.send(\n            JSON.stringify({\n              type: \"command\",\n              id,\n              command: \"get.config\",\n            })\n          )\n        })\n        .catch(done)\n    })\n\n    it(\"should correctly map arguments and options to commands\", (done) => {\n      const id = uuidv4()\n      onMessage((req) => {\n        // Ignore other events such as taskPending and taskProcessing and wait for the command result\n        if ((<any>req).type !== \"commandResult\") {\n          return\n        }\n        const taskResult = taskResultOutputs((<any>req).result)\n        const result = {\n          ...req,\n          result: taskResult,\n        }\n        expect(result).to.eql({\n          type: \"commandResult\",\n          requestId: id,\n          result: {\n            \"build.module-a\": {\n              buildLog: \"A\",\n              fresh: true,\n            },\n            \"stage-build.module-a\": {},\n          },\n        })\n        done()\n      })\n      ws.send(\n        JSON.stringify({\n          type: \"command\",\n          id,\n          command: \"build\",\n          parameters: {\n            modules: [\"module-a\"],\n            force: true,\n          },\n        })\n      )\n    })\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport produce from \"immer\"\nimport { groupBy, keyBy } from \"lodash\"\n\nimport { ServiceLogEntry } from \"@garden-io/core/build/src/types/plugin/service/getServiceLogs\"\nimport { StatusCommandResult } from \"@garden-io/core/build/src/commands/get/get-status\"\nimport { GetTaskResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-task-result\"\nimport { ConfigDump } from \"@garden-io/core/build/src/garden\"\nimport { GetTestResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-test-result\"\nimport { GraphOutput } from \"@garden-io/core/build/src/commands/get/get-graph\"\nimport {\n  Entities,\n  ModuleEntity,\n  ServiceEntity,\n  TaskEntity,\n  TestEntity,\n  ApiDispatch,\n  defaultTaskState,\n  defaultServiceStatus,\n  defaultRunStatus,\n} from \"../contexts/api\"\nimport {\n  fetchLogs,\n  fetchStatus,\n  fetchTaskResult,\n  fetchConfig,\n  fetchTestResult,\n  fetchGraph,\n  FetchTaskResultParams,\n  FetchTestResultParams,\n} from \"./api\"\nimport { getTestKey } from \"../util/helpers\"\nimport { ProviderMap } from \"@garden-io/core/build/src/config/provider\"\nimport { DashboardPage } from \"@garden-io/core/build/src/types/plugin/provider/getDashboardPage\"\n\n// This file contains the API action functions.\n// The actions are responsible for dispatching the appropriate action types and normalising the\n// API response.\n\n// Section: Helpers\n\n/**\n * Returns service status if set, otherwise default service status.\n */\nfunction getServiceStatus(service?: ServiceEntity) {\n  return service ? service.status : defaultServiceStatus || defaultServiceStatus\n}\n\n/**\n * Returns task state if set, otherwise default task state.\n */\nfunction getTaskState(entity?: ServiceEntity | ModuleEntity | TestEntity | TaskEntity) {\n  return entity ? entity.taskState : defaultTaskState || defaultTaskState\n}\n\n/**\n * Returns run status if set, otherwise default run status.\n */\nfunction getRunStatus(entity?: TaskEntity | TestEntity) {\n  return entity ? entity.status : defaultRunStatus || defaultRunStatus\n}\n\n// Section: Init actions and process handlers\n\n/**\n * Fetch the init data for the API store.\n *\n * This action is called first and hydrates the initial app state.\n */\nexport async function initApiStore(dispatch: ApiDispatch) {\n  await Promise.all([loadConfig(dispatch), loadStatus(dispatch)])\n}\n\nasync function loadConfig(dispatch: ApiDispatch) {\n  const requestKey = \"config\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n  let res: ConfigDump\n\n  try {\n    res = await fetchConfig()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processConfigInitResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\n/**\n * Invariant: The fetchConfig and fetchStatus calls fire concurrently on app initialisation\n * so that we get a faster initial render. Therefore the process functions need to account for\n * the store not having been initialised.\n *\n * Other process handlers can assume that the store has been initialised.\n */\nfunction processConfigInitResult(entities: Entities, config: ConfigDump) {\n  return produce(entities, (draft) => {\n    draft.providers = keyBy(config.providers, \"name\") as ProviderMap\n    draft.providerPages = config.providers.flatMap((provider) => {\n      return (provider.dashboardPages || []).map((page: DashboardPage) => ({\n        ...page,\n        providerName: provider.name,\n        path: `/provider/${provider.name}/${page.name}`,\n        description: page.description + ` (from provider ${provider.name})`,\n        // Use static URL if provided, otherwise we'll request a redirect from this API endpoint\n        url: page.url || `/dashboardPages/${provider.name}/${page.name}`,\n      }))\n    })\n\n    for (const cfg of config.moduleConfigs) {\n      const module: ModuleEntity = {\n        name: cfg.name,\n        type: cfg.type,\n        path: cfg.path,\n        disabled: cfg.disabled,\n        repositoryUrl: cfg.repositoryUrl,\n        description: cfg.description,\n        services: cfg.serviceConfigs.map((service) => service.name),\n        tests: cfg.testConfigs.map((test) => `${cfg.name}.${test.name}`),\n        tasks: cfg.taskConfigs.map((task) => task.name),\n        taskState: \"taskComplete\",\n      }\n      draft.modules[cfg.name] = module\n\n      const moduleDisabled = module.disabled\n      for (const serviceConfig of cfg.serviceConfigs) {\n        const service = entities.services[serviceConfig.name]\n        draft.services[serviceConfig.name] = {\n          taskState: getTaskState(service),\n          status: getServiceStatus(service),\n          config: {\n            ...serviceConfig,\n            moduleDisabled,\n          },\n        }\n      }\n      for (const testConfig of cfg.testConfigs) {\n        const testKey = getTestKey({ testName: testConfig.name, moduleName: cfg.name })\n        const test = entities.tests[testKey]\n        draft.tests[testKey] = {\n          taskState: getTaskState(test),\n          status: getRunStatus(test),\n          result: null,\n          config: {\n            ...testConfig,\n            moduleDisabled,\n          },\n        }\n      }\n      for (const taskConfig of cfg.taskConfigs) {\n        const task = entities.tasks[taskConfig.name]\n        draft.tasks[taskConfig.name] = {\n          taskState: getTaskState(task),\n          status: getRunStatus(task),\n          result: null,\n          config: {\n            ...taskConfig,\n            moduleDisabled,\n          },\n        }\n      }\n    }\n  })\n}\n\nexport async function loadStatus(dispatch: ApiDispatch) {\n  const requestKey = \"status\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: StatusCommandResult\n  try {\n    res = await fetchStatus()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processStatusInitResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\n/**\n * Invariant: The fetchConfig and fetchStatus calls fire concurrently on app initialisation\n * so that we get a faster initial render. Therefore the process functions need to account for\n * the store not having been initialised.\n *\n * Other process handlers can assume that the store has been initialised.\n */\nfunction processStatusInitResult(entities: Entities, status: StatusCommandResult) {\n  return produce(entities, (draft) => {\n    for (const serviceName of Object.keys(status.services)) {\n      draft.services[serviceName] = entities.services[serviceName] || {}\n      draft.services[serviceName].status = status.services[serviceName]\n    }\n    for (const [taskName, taskStatus] of Object.entries(status.tasks || {})) {\n      draft.tasks[taskName] = entities.tasks[taskName] || {}\n      draft.tasks[taskName].status = taskStatus\n    }\n    for (const [testName, testStatus] of Object.entries(status.tests || {})) {\n      draft.tests[testName] = entities.tests[testName] || {}\n      draft.tests[testName].status = testStatus\n    }\n    draft.environmentStatuses = status.providers\n  })\n}\n\n// Section: Actions and process handlers\n\nexport async function loadLogs(dispatch: ApiDispatch, serviceNames: string[]) {\n  const requestKey = \"logs\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: ServiceLogEntry[]\n  try {\n    res = await fetchLogs({ serviceNames })\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processLogs(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processLogs(entities: Entities, logs: ServiceLogEntry[]) {\n  return produce(entities, (draft) => {\n    draft.logs = groupBy(logs, \"serviceName\")\n  })\n}\n\ninterface LoadTaskResultParams extends FetchTaskResultParams {\n  dispatch: ApiDispatch\n}\n\nexport async function loadTaskResult({ dispatch, ...fetchParams }: LoadTaskResultParams) {\n  const requestKey = \"taskResult\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GetTaskResultCommandResult\n  try {\n    res = await fetchTaskResult(fetchParams)\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processTaskResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processTaskResult(entities: Entities, result: GetTaskResultCommandResult) {\n  return produce(entities, (draft) => {\n    if (result) {\n      draft.tasks[result.taskName].result = result\n    }\n  })\n}\n\ninterface LoadTestResultParams extends FetchTestResultParams {\n  dispatch: ApiDispatch\n}\n\nexport async function loadTestResult({ dispatch, ...fetchParams }: LoadTestResultParams) {\n  const requestKey = \"testResult\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GetTestResultCommandResult\n  try {\n    res = await fetchTestResult(fetchParams)\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processTestResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processTestResult(entities: Entities, result: GetTestResultCommandResult) {\n  return produce(entities, (draft) => {\n    if (result) {\n      // Test names are not unique so we store the data under a unique test key\n      const testKey = getTestKey({ testName: result.testName, moduleName: result.moduleName })\n      draft.tests[testKey].result = result\n    }\n  })\n}\n\nexport async function loadGraph(dispatch: ApiDispatch) {\n  const requestKey = \"graph\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GraphOutput\n  try {\n    res = await fetchGraph()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processGraph(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processGraph(entities: Entities, graph: GraphOutput) {\n  return produce(entities, (draft) => {\n    draft.graph = graph\n  })\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport axios from \"axios\"\n\nimport { GraphOutput } from \"@garden-io/core/build/src/commands/get/get-graph\"\nimport { GetTaskResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-task-result\"\nimport { GetTestResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-test-result\"\nimport { ServiceLogEntry } from \"@garden-io/core/build/src/types/plugin/service/getServiceLogs\"\nimport { CommandResult } from \"@garden-io/core/build/src/commands/base\"\nimport { ConfigDump } from \"@garden-io/core/build/src/garden\"\nimport { StatusCommandResult } from \"@garden-io/core/build/src/commands/get/get-status\"\n\nexport interface ApiRequest {\n  command: string\n  parameters: {}\n}\n\nconst MAX_LOG_LINES = 5000\n\nexport async function fetchConfig() {\n  return apiCommand<ConfigDump>(\"get.config\")\n}\n\nexport async function fetchGraph() {\n  return apiCommand<GraphOutput>(\"get.graph\")\n}\n\nexport async function fetchStatus() {\n  return apiCommand<StatusCommandResult>(\"get.status\", { output: \"json\" })\n}\n\nexport interface FetchLogsParams {\n  serviceNames: string[]\n}\n\nexport async function fetchLogs({ serviceNames }: FetchLogsParams) {\n  const tail = Math.floor(MAX_LOG_LINES / serviceNames.length)\n  return apiCommand<ServiceLogEntry[]>(\"logs\", { services: serviceNames, tail })\n}\n\nexport interface FetchTaskResultParams {\n  name: string\n}\n\nexport async function fetchTaskResult(params: FetchTaskResultParams) {\n  return apiCommand<GetTaskResultCommandResult>(\"get.task-result\", params)\n}\n\nexport interface FetchTestResultParams {\n  name: string\n  moduleName: string\n}\n\nexport async function fetchTestResult({ name, moduleName }: FetchTestResultParams) {\n  return apiCommand<GetTestResultCommandResult>(\"get.test-result\", { name, module: moduleName })\n}\n\nasync function apiCommand<T>(command: string, parameters: {} = {}): Promise<T> {\n  const url = \"/api\"\n  const method = \"POST\"\n  const headers = { \"Content-Type\": \"application/json\" }\n  const data: ApiRequest = { command, parameters }\n\n  const res = await axios.request<CommandResult<T>>({ url, method, headers, data })\n\n  if (res.data.errors) {\n    throw res.data.errors\n  }\n\n  if (res.data.result === undefined) {\n    throw new Error(\"Empty response from server\")\n  }\n\n  return res.data.result\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { css } from \"emotion\"\nimport styled from \"@emotion/styled\"\nimport React from \"react\"\nimport { NavLink as ReactRouterNavLink } from \"react-router-dom\"\n\nimport logo from \"../assets/logo.png\"\n\nimport { colors } from \"../styles/variables\"\nimport { useUiState } from \"../hooks\"\nimport { Page } from \"../contexts/api\"\n\ninterface Props {\n  pages: Page[]\n}\n\nconst Button = styled.div`\n  font-size: 0.84rem;\n  font-weight: 800;\n  text-transform: uppercase;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin-bottom: -12px;\n  &:hover {\n    color: ${colors.gardenGreenDarker};\n  }\n`\n\nconst linkStyle = `\n  margin-left: 1rem;\n  padding: 0.5em 0.5em 0.5em 0;\n`\n\nconst Nav = styled.nav`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n`\n\nconst NavLink = (props: any) => <ReactRouterNavLink {...props} activeStyle={{ color: colors.gardenGreenDark }} />\n\nconst A = styled.a(linkStyle)\nconst Link = styled(NavLink)(linkStyle)\n\n// Style and align properly\nconst Logo = styled.img`\n  display: inline-block;\n  height: 42px;\n  margin-right: 18px;\n  max-width: 9rem;\n`\n\ntype MenuContainerProps = {\n  visible: boolean\n}\nconst MenuContainer = styled.div<MenuContainerProps>`\n  padding-left: 15px;\n  display: ${(props) => (props.visible ? `block` : \"none\")};\n  height: ${(props) => (props.visible ? `100%` : \"0\")};\n`\n\nconst Menu: React.FC<Props> = ({ pages }) => {\n  const {\n    state: { isMenuOpen },\n  } = useUiState()\n\n  return (\n    <>\n      <MenuContainer visible={isMenuOpen}>\n        <Nav>\n          <NavLink to=\"/\">\n            <Logo src={logo} alt=\"Home\" />\n          </NavLink>\n          {pages.map((page) => (\n            <MenuButton key={page.path} page={page} />\n          ))}\n        </Nav>\n      </MenuContainer>\n    </>\n  )\n}\n\ninterface MenuButtonProps {\n  page: Page\n}\n\nconst MenuButton: React.FC<MenuButtonProps> = ({ page }) => {\n  let link: React.ReactNode\n  if (page.newWindow && page.url) {\n    link = (\n      <A href={page.url} target=\"_blank\" title={page.description}>\n        {page.title}\n        <i className={`${css(\"color: #ccc; margin-left: 0.5em;\")} fas fa-external-link-alt`} />\n      </A>\n    )\n  } else {\n    link = (\n      <Link exact to={{ pathname: page.path, state: page }} title={page.description}>\n        {page.title}\n      </Link>\n    )\n  }\n  return <Button key={page.title}>{link}</Button>\n}\n\nexport default Menu\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { useState, useEffect, useCallback, useRef, useContext } from \"react\"\n\nimport getApiUrl from \"./api/get-api-url\"\nimport { ApiContext } from \"./contexts/api\"\nimport { UiContext } from \"./contexts/ui\"\n\nconst wsRetryInterval = 2000\n\ntype WsConnectionState = \"open\" | \"closed\"\n\nexport const useWebsocket = (\n  handleWsMsg: (msg: MessageEvent) => void,\n  handleWsOpened: () => void,\n  handleWsClosed: () => void\n) => {\n  const wsStateRef = useRef<WsConnectionState>()\n  const wsRef = useRef<WebSocket>()\n  const windowFocused = useWindowFocus()\n  const [wsState, setWsState] = useState<WsConnectionState>()\n  const [retries, setRetries] = useState(0)\n\n  const onConnectionLost = () => {\n    if (wsStateRef.current === \"open\") {\n      handleWsClosed()\n    }\n    setWsState(\"closed\")\n  }\n\n  const initWs = () => {\n    const url = getApiUrl()\n    const ws = new WebSocket(`ws://${url}/ws`)\n    ws.onopen = (_event) => {\n      if (wsStateRef.current === \"closed\") {\n        handleWsOpened()\n      }\n      setWsState(\"open\")\n    }\n    ws.onclose = onConnectionLost\n    ws.onerror = onConnectionLost\n    ws.onmessage = (msg) => {\n      handleWsMsg(msg)\n    }\n    return ws\n  }\n\n  const initWsCb = useCallback(initWs, [])\n\n  useEffect(() => {\n    wsStateRef.current = wsState\n  }, [wsState])\n\n  // Init connection\n  useEffect(() => {\n    wsRef.current = initWsCb()\n  }, [initWsCb])\n\n  // Reconnect after delay if connection lost\n  useEffect(() => {\n    if (wsState === \"closed\" && windowFocused) {\n      const timeout = setTimeout(() => {\n        setRetries((prevCount) => prevCount + 1)\n        wsRef.current = initWsCb()\n      }, wsRetryInterval)\n      return () => {\n        clearTimeout(timeout)\n      }\n    }\n    return\n  }, [initWsCb, wsState, retries, windowFocused])\n\n  // Close connection on unmount\n  useEffect(() => {\n    return () => {\n      wsRef.current?.close()\n    }\n  }, [])\n}\n\n/**\n * Sets the window focus state to true or false\n */\nexport const useWindowFocus = () => {\n  const [focused, setFocused] = useState(document.hasFocus())\n\n  useEffect(() => {\n    const onFocus = () => {\n      setFocused(true)\n    }\n\n    const onBlur = () => {\n      setFocused(false)\n    }\n\n    window.addEventListener(\"focus\", onFocus)\n    window.addEventListener(\"blur\", onBlur)\n\n    return () => {\n      window.removeEventListener(\"focus\", onFocus)\n      window.removeEventListener(\"blur\", onBlur)\n    }\n  }, [])\n\n  return focused\n}\n\n/**\n * Returns the store and load actions via the Context\n */\nexport const useApi = () => useContext(ApiContext)\n\n/**\n * Returns the state and UI actions via the Context\n */\nexport const useUiState = () => useContext(UiContext)\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport normalizeUrl from \"normalize-url\"\nimport { format } from \"url\"\nimport { flatten } from \"lodash\"\nimport { ModuleConfig } from \"@garden-io/core/build/src/config/module\"\nimport { ServiceIngress } from \"@garden-io/core/build/src/types/service\"\n\nexport function getServiceNames(moduleConfigs: ModuleConfig[]) {\n  return flatten(moduleConfigs.map((m) => m.serviceConfigs.map((s) => s.name)))\n}\n\nexport function timeConversion(millisec) {\n  const seconds = +(millisec / 1000).toFixed(1)\n  const minutes = +(millisec / (1000 * 60)).toFixed(1)\n  const hours = +(millisec / (1000 * 60 * 60)).toFixed(1)\n  const days = +(millisec / (1000 * 60 * 60 * 24)).toFixed(1)\n  let formatTime = (num, prefix) => `${num} ${prefix}`\n  let timeFormatted: string | null = null\n  if (seconds < 60) {\n    timeFormatted = formatTime(seconds, \"Sec\")\n  } else if (minutes < 60) {\n    timeFormatted = formatTime(minutes, \"Min\")\n  } else if (hours < 24) {\n    timeFormatted = formatTime(hours, \"Hrs\")\n  } else {\n    timeFormatted = formatTime(days, \"Days\")\n  }\n\n  return timeFormatted\n}\n\n// function expects either a string in the form of \"2019-05-18T08:30:08.601Z\" or a Date\nexport function getDuration(start: string | Date, end: string | Date): string {\n  const startValue = new Date(start).valueOf()\n  const endValue = new Date(end).valueOf()\n  const duration = timeConversion(endValue - startValue)\n  return duration\n}\n\nexport const truncateMiddle = (str: string, resLength: number = 35) => {\n  if (str.length > resLength) {\n    const middle = Math.ceil(resLength / 2)\n    return str.substr(0, middle) + \"...\" + str.substr(str.length - middle, str.length)\n  }\n\n  return str\n}\n\n/**\n * Returns the link URL or falls back to constructing the URL from the ingress spec\n */\nexport function getLinkUrl(ingress: ServiceIngress) {\n  if (ingress.linkUrl) {\n    return ingress.linkUrl\n  }\n\n  return normalizeUrl(\n    format({\n      protocol: ingress.protocol,\n      hostname: ingress.hostname,\n      port: ingress.port,\n      pathname: ingress.path,\n    })\n  )\n}\n\n/**\n * Test names are not unique so we construct a unique key from the module name and the test name.\n */\nexport function getTestKey({ testName, moduleName }: { testName: string; moduleName: string }) {\n  return `${moduleName}.${testName}`\n}\n\nlet _canvas: HTMLCanvasElement\n\n/**\n * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n *\n * @param {String} text The text to be rendered.\n * @param {String} font The css font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n *\n * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n */\nexport function getTextWidth(text: string, font: string) {\n  // re-use canvas object for better performance\n  const canvas = _canvas || (_canvas = document.createElement(\"canvas\"))\n  const context = canvas.getContext(\"2d\")!\n  context.font = font\n  const metrics = context.measureText(text)\n  return metrics.width\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport dotenv = require(\"dotenv\")\nimport { intersection, sortBy } from \"lodash\"\nimport { resolve, join } from \"path\"\nimport chalk from \"chalk\"\nimport { pathExists } from \"fs-extra\"\nimport { getBuiltinCommands } from \"../commands/commands\"\nimport {\n  shutdown,\n  sleep,\n  getPackageVersion,\n  uuidv4,\n  registerCleanupFunction,\n  getCloudDistributionName,\n} from \"../util/util\"\nimport { Command, CommandResult, CommandGroup, BuiltinArgs } from \"../commands/base\"\nimport { PluginError, toGardenError, GardenBaseError } from \"../exceptions\"\nimport { Garden, GardenOpts, DummyGarden } from \"../garden\"\nimport { getLogger, Logger, LoggerType, LogLevel, parseLogLevel } from \"../logger/logger\"\nimport { FileWriter, FileWriterConfig } from \"../logger/writers/file-writer\"\n\nimport {\n  checkForUpdates,\n  checkForStaticDir,\n  renderCommands,\n  processCliArgs,\n  pickCommand,\n  parseCliArgs,\n  optionsWithAliasValues,\n  getCliStyles,\n} from \"./helpers\"\nimport { Parameters, globalOptions, OUTPUT_RENDERERS, GlobalOptions, ParameterValues } from \"./params\"\nimport {\n  defaultEnvironments,\n  ProjectConfig,\n  defaultNamespace,\n  parseEnvironment,\n  ProjectResource,\n} from \"../config/project\"\nimport { ERROR_LOG_FILENAME, DEFAULT_API_VERSION, DEFAULT_GARDEN_DIR_NAME, LOGS_DIR_NAME } from \"../constants\"\nimport { generateBasicDebugInfoReport } from \"../commands/get/get-debug-info\"\nimport { AnalyticsHandler } from \"../analytics/analytics\"\nimport { BufferedEventStream, ConnectBufferedEventStreamParams } from \"../cloud/buffered-event-stream\"\nimport { defaultDotIgnoreFiles } from \"../util/fs\"\nimport type { GardenProcess } from \"../db/entities/garden-process\"\nimport { DashboardEventStream } from \"../server/dashboard-event-stream\"\nimport { GardenPluginReference } from \"../types/plugin/plugin\"\nimport { renderError } from \"../logger/renderers\"\nimport { CloudApi } from \"../cloud/api\"\nimport { findProjectConfig } from \"../config/base\"\nimport { pMemoizeDecorator } from \"../lib/p-memoize\"\nimport { getCustomCommands } from \"../commands/custom\"\nimport { Profile } from \"../util/profiling\"\nimport { prepareDebugLogfiles } from \"./debug-logs\"\nimport { LogEntry } from \"../logger/log-entry\"\nimport { JsonFileWriter } from \"../logger/writers/json-file-writer\"\nimport { dedent } from \"../util/string\"\nimport { renderDivider } from \"../logger/util\"\nimport { emoji as nodeEmoji } from \"node-emoji\"\n\nexport async function makeDummyGarden(root: string, gardenOpts: GardenOpts) {\n  const environments = gardenOpts.environmentName\n    ? [{ name: parseEnvironment(gardenOpts.environmentName).environment, defaultNamespace, variables: {} }]\n    : defaultEnvironments\n\n  const config: ProjectConfig = {\n    path: root,\n    apiVersion: DEFAULT_API_VERSION,\n    kind: \"Project\",\n    name: \"no-project\",\n    defaultEnvironment: \"\",\n    dotIgnoreFiles: defaultDotIgnoreFiles,\n    environments,\n    providers: [],\n    variables: {},\n  }\n  gardenOpts.config = config\n\n  return DummyGarden.factory(root, { noEnterprise: true, ...gardenOpts })\n}\n\nfunction renderHeader({\n  environmentName,\n  namespaceName,\n  namespaceUrl,\n  distroName,\n}: {\n  environmentName: string\n  namespaceName: string\n  namespaceUrl?: string\n  distroName?: string\n}) {\n  const divider = chalk.gray(renderDivider())\n  let msg = `${nodeEmoji.earth_africa}  Running in namespace ${chalk.cyan(namespaceName + \".\" + environmentName)}`\n\n  if (namespaceUrl) {\n    msg += dedent`\n      \\n\n      ${nodeEmoji.lightning}   Connected to ${distroName}\n      ${nodeEmoji.link}  ${chalk.blueBright.underline(namespaceUrl)}\n    `\n  }\n\n  return dedent`\n    ${divider}\n    ${msg}\n    ${divider}\\n\n  `\n}\n\nexport interface RunOutput {\n  argv: any\n  code: number\n  errors: (GardenBaseError | Error)[]\n  result: any\n  // Mainly used for testing\n  consoleOutput?: string\n}\n\n@Profile()\nexport class GardenCli {\n  private commands: { [key: string]: Command } = {}\n  private fileWritersInitialized: boolean = false\n  private plugins: GardenPluginReference[]\n  private bufferedEventStream: BufferedEventStream | undefined\n  private sessionFinished = false\n  public processRecord: GardenProcess\n\n  constructor({ plugins }: { plugins?: GardenPluginReference[] } = {}) {\n    this.plugins = plugins || []\n\n    const commands = sortBy(getBuiltinCommands(), (c) => c.name)\n    commands.forEach((command) => this.addCommand(command))\n  }\n\n  async renderHelp(workingDir: string) {\n    const cliStyles = getCliStyles()\n\n    const commands = Object.values(this.commands)\n      .sort()\n      .filter((cmd) => cmd.getPath().length === 1)\n\n    let msg = `\n${cliStyles.heading(\"USAGE\")}\n  garden ${cliStyles.commandPlaceholder()} ${cliStyles.optionsPlaceholder()}\n\n${cliStyles.heading(\"COMMANDS\")}\n${renderCommands(commands)}\n    `\n\n    const customCommands = await this.getCustomCommands(workingDir)\n\n    if (customCommands.length > 0) {\n      msg += `\\n${cliStyles.heading(\"CUSTOM COMMANDS\")}\\n${renderCommands(customCommands)}`\n    }\n\n    return msg\n  }\n\n  private async initFileWriters({\n    logger,\n    log,\n    gardenDirPath,\n    commandFullName,\n  }: {\n    logger: Logger\n    log: LogEntry\n    gardenDirPath: string\n    commandFullName: string\n  }) {\n    if (this.fileWritersInitialized) {\n      return\n    }\n    const { debugLogfileName, jsonLogfileName } = await prepareDebugLogfiles(\n      log,\n      join(gardenDirPath, LOGS_DIR_NAME),\n      commandFullName\n    )\n    const logConfigs: FileWriterConfig[] = [\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, debugLogfileName),\n        truncatePrevious: true,\n        level: LogLevel.debug,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, jsonLogfileName),\n        truncatePrevious: true,\n        level: LogLevel.silly,\n        json: true,\n      },\n      {\n        logFilePath: join(gardenDirPath, ERROR_LOG_FILENAME),\n        truncatePrevious: true,\n        level: LogLevel.error,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, ERROR_LOG_FILENAME),\n        level: LogLevel.error,\n      },\n      {\n        logFilePath: join(gardenDirPath, LOGS_DIR_NAME, \"development.log\"),\n        level: logger.level,\n      },\n    ]\n    for (const config of logConfigs) {\n      logger.addWriter(await (config.json ? JsonFileWriter : FileWriter).factory(config))\n    }\n    this.fileWritersInitialized = true\n  }\n\n  addCommand(command: Command): void {\n    const fullName = command.getFullName()\n\n    if (this.commands[fullName]) {\n      // For now we don't allow multiple definitions of the same command. We may want to revisit this later.\n      throw new PluginError(`Multiple definitions of command \"${fullName}\"`, {})\n    }\n\n    this.commands[fullName] = command\n\n    const { options = {} } = command\n\n    const optKeys = Object.keys(options)\n    const globalKeys = Object.keys(globalOptions)\n    const dupKeys: string[] = intersection(optKeys, globalKeys)\n\n    if (dupKeys.length > 0) {\n      throw new PluginError(`Global option(s) ${dupKeys.join(\" \")} cannot be redefined`, {})\n    }\n  }\n\n  async getGarden(workingDir: string, opts: GardenOpts) {\n    return Garden.factory(workingDir, opts)\n  }\n\n  async runCommand<A extends Parameters, O extends Parameters>({\n    command,\n    parsedArgs,\n    parsedOpts,\n    processRecord,\n    workingDir,\n  }: {\n    command: Command<A, O>\n    parsedArgs: BuiltinArgs & ParameterValues<A>\n    parsedOpts: ParameterValues<GlobalOptions & O>\n    processRecord?: GardenProcess\n    workingDir: string\n  }) {\n    const {\n      \"logger-type\": loggerTypeOpt,\n      \"log-level\": logLevel,\n      \"show-timestamps\": showTimestamps,\n      emoji,\n      \"env\": environmentName,\n      silent,\n      output,\n      \"force-refresh\": forceRefresh,\n      \"var\": cliVars,\n      \"disable-port-forwards\": disablePortForwards,\n    } = parsedOpts\n\n    // Parse command line --var input\n    const parsedCliVars = cliVars ? dotenv.parse(cliVars.join(\"\\n\")) : {}\n\n    // Init logger\n    const level = parseLogLevel(logLevel)\n    let loggerType = <LoggerType>loggerTypeOpt || command.getLoggerType({ opts: parsedOpts, args: parsedArgs })\n\n    if (silent || output) {\n      loggerType = \"quiet\"\n    }\n\n    const logger = Logger.initialize({ level, type: loggerType, useEmoji: emoji, showTimestamps })\n\n    // Currently we initialise empty placeholder entries and pass those to the\n    // framework as opposed to the logger itself. This is to give better control over where on\n    // the screen the logs are printed.\n    const headerLog = logger.placeholder()\n    const log = logger.placeholder()\n    const footerLog = logger.placeholder()\n\n    command.printHeader({ headerLog, args: parsedArgs, opts: parsedOpts })\n\n    // Init enterprise API\n    let cloudApi: CloudApi | null = null\n    if (!command.noProject) {\n      cloudApi = await CloudApi.factory({ log, currentDirectory: workingDir })\n    }\n\n    // Init event & log streaming.\n    const sessionId = uuidv4()\n    this.bufferedEventStream = new BufferedEventStream({\n      log,\n      cloudApi: cloudApi || undefined,\n      sessionId,\n    })\n\n    registerCleanupFunction(\"stream-session-cancelled-event\", () => {\n      if (!this.sessionFinished) {\n        this.bufferedEventStream?.streamEvent(\"sessionCancelled\", {})\n        this.bufferedEventStream?.flushAll()\n      }\n    })\n\n    const dashboardEventStream = new DashboardEventStream({ log, sessionId })\n\n    const commandInfo = {\n      name: command.getFullName(),\n      args: parsedArgs,\n      opts: optionsWithAliasValues(command, parsedOpts),\n    }\n\n    const contextOpts: GardenOpts = {\n      commandInfo,\n      disablePortForwards,\n      environmentName,\n      log,\n      sessionId,\n      forceRefresh,\n      variables: parsedCliVars,\n      plugins: this.plugins,\n      cloudApi: cloudApi || undefined,\n    }\n\n    let garden: Garden\n    let result: CommandResult<any> = {}\n    let analytics: AnalyticsHandler\n\n    const prepareParams = {\n      log,\n      headerLog,\n      footerLog,\n      args: parsedArgs,\n      opts: parsedOpts,\n    }\n\n    const persistent = command.isPersistent(prepareParams)\n\n    await command.prepare(prepareParams)\n\n    contextOpts.persistent = persistent\n    const { streamEvents, streamLogEntries } = command\n    // Print header log before we know the namespace to prevent content from\n    // jumping.\n    // TODO: Link to Cloud namespace page here.\n    const nsLog = headerLog.info(\"\")\n\n    do {\n      try {\n        if (command.noProject) {\n          garden = await makeDummyGarden(workingDir, contextOpts)\n        } else {\n          garden = await this.getGarden(workingDir, contextOpts)\n\n          nsLog.setState(renderHeader({ namespaceName: garden.namespace, environmentName: garden.environmentName }))\n\n          if (processRecord) {\n            // Update the db record for the process\n            await processRecord.setCommand({\n              command: command.name,\n              sessionId: garden.sessionId,\n              persistent,\n              serverHost: command.server?.port ? `http://localhost:${command.server.port}` : null,\n              serverAuthKey: command.server?.authKey || null,\n              projectRoot: garden.projectRoot,\n              projectName: garden.projectName,\n              environmentName: garden.environmentName,\n              namespace: garden.namespace,\n            })\n          }\n\n          // Connect the dashboard event streamer (making sure it doesn't stream to the local server)\n          const commandServerUrl = command.server?.getUrl() || undefined\n          dashboardEventStream.connect({ garden, ignoreHost: commandServerUrl, streamEvents, streamLogEntries })\n          const runningServers = await dashboardEventStream.updateTargets()\n\n          if (cloudApi && !cloudApi.sessionRegistered && command.streamEvents) {\n            // Note: If a config change during a watch-mode command's execution results in the resolved environment\n            // and/or namespace name changing, we don't change the session ID, environment ID or namespace ID used when\n            // streaming events.\n            await cloudApi.registerSession({\n              sessionId,\n              commandInfo,\n              localServerPort: command.server?.port,\n              environment: garden.environmentName,\n              namespace: garden.namespace,\n            })\n          }\n\n          let namespaceUrl: string | undefined\n          if (cloudApi && cloudApi.environmentId && cloudApi.namespaceId) {\n            const project = await cloudApi.getProject()\n            const path = `/projects/${project.id}/environments/${cloudApi.environmentId}/namespaces/${cloudApi.namespaceId}/stack`\n            const url = new URL(path, cloudApi.domain)\n            namespaceUrl = url.href\n          }\n\n          // Print a different header and footer when persistent and connected to Garden Cloud.\n          if (persistent && namespaceUrl) {\n            const distroName = getCloudDistributionName(cloudApi?.domain || \"\")\n            nsLog.setState(\n              renderHeader({\n                namespaceName: garden.namespace,\n                environmentName: garden.environmentName,\n                namespaceUrl,\n                distroName,\n              })\n            )\n            const msg = dedent`\n              ${chalk.cyan(`Connected to ${distroName}! Visit your namespace to streams logs and more.`)}\n              ${nodeEmoji.link}  ${chalk.blueBright.underline(namespaceUrl)}\n            `\n            footerLog.info({\n              emoji: \"sunflower\",\n              msg,\n            })\n          } else if (persistent && command.server) {\n            // If there is an explicit `garden dashboard` process running for the current project+env, and a server\n            // is started in this Command, we show the URL to the external dashboard. Otherwise the built-in one.\n\n            // Note: Lazy-loading for startup performance\n            const { GardenProcess: GP } = require(\"../db/entities/garden-process\")\n\n            const dashboardProcess = GP.getDashboardProcess(runningServers, {\n              projectRoot: garden.projectRoot,\n              projectName: garden.projectName,\n              environmentName: garden.environmentName,\n              namespace: garden.namespace,\n            })\n\n            let url: string | undefined\n            if (dashboardProcess) {\n              url = `${dashboardProcess.serverHost}?key=${dashboardProcess.serverAuthKey}`\n            }\n            command.server.showUrl(url)\n          }\n        }\n\n        if (cloudApi) {\n          log.silly(`Connecting Garden instance to GE BufferedEventStream`)\n          const connectParams: ConnectBufferedEventStreamParams = {\n            garden,\n            streamEvents,\n            streamLogEntries,\n            targets: [\n              {\n                enterprise: true,\n              },\n            ],\n          }\n          this.bufferedEventStream.connect(connectParams)\n          if (streamEvents) {\n            this.bufferedEventStream.streamEvent(\"commandInfo\", commandInfo)\n          }\n        }\n\n        // Register log file writers. We need to do this after the Garden class is initialised because\n        // the file writers depend on the project root.\n        await this.initFileWriters({\n          logger,\n          log,\n          gardenDirPath: garden.gardenDirPath,\n          commandFullName: command.getFullName(),\n        })\n        analytics = await AnalyticsHandler.init(garden, log)\n        analytics.trackCommand(command.getFullName())\n\n        // Note: No reason to await the check\n        checkForUpdates(garden.globalConfigStore, headerLog).catch((err) => {\n          headerLog.verbose(\"Something went wrong while checking for the latest Garden version.\")\n          headerLog.verbose(err)\n        })\n\n        await checkForStaticDir()\n\n        // Check if the command is protected and ask for confirmation to proceed if production flag is \"true\".\n        if (await command.isAllowedToRun(garden, log, parsedOpts)) {\n          // TODO: enforce that commands always output DeepPrimitiveMap\n\n          result = await command.action({\n            garden,\n            cli: this,\n            log,\n            footerLog,\n            headerLog,\n            args: parsedArgs,\n            opts: parsedOpts,\n          })\n        } else {\n          // The command is protected and the user decided to not continue with the exectution.\n          log.setState(\"\\nCommand aborted.\")\n          result = {}\n        }\n        await garden.close()\n      } catch (err) {\n        // Generate a basic report in case Garden.factory(...) fails and command is \"get debug-info\".\n        // Other exceptions are handled within the implementation of \"get debug-info\".\n        if (command.name === \"debug-info\") {\n          // Use default Garden dir name as fallback since Garden class hasn't been initialised\n          await generateBasicDebugInfoReport(\n            workingDir,\n            join(workingDir, DEFAULT_GARDEN_DIR_NAME),\n            log,\n            parsedOpts.format\n          )\n        }\n        throw err\n      } finally {\n        if (!result.restartRequired) {\n          await dashboardEventStream.close()\n          await command.server?.close()\n          cloudApi?.close()\n        }\n      }\n    } while (result.restartRequired)\n\n    return { result, analytics }\n  }\n\n  async run({\n    args,\n    exitOnError,\n    processRecord,\n    cwd,\n  }: {\n    args: string[]\n    exitOnError: boolean\n    processRecord?: GardenProcess\n    cwd?: string\n  }): Promise<RunOutput> {\n    let argv = parseCliArgs({ stringArgs: args, cli: true })\n\n    let logger: Logger\n    const errors: (GardenBaseError | Error)[] = []\n\n    // Note: Circumvents an issue where the process exits before the output is fully flushed.\n    // Needed for output renderers and Winston (see: https://github.com/winstonjs/winston/issues/228)\n    const waitForOutputFlush = () => sleep(100)\n\n    async function done(abortCode: number, consoleOutput: string, result: any = {}) {\n      if (exitOnError) {\n        logger && logger.stop()\n        // tslint:disable-next-line: no-console\n        console.log(consoleOutput)\n        await waitForOutputFlush()\n        await shutdown(abortCode)\n      } else {\n        await waitForOutputFlush()\n      }\n\n      return { argv, code: abortCode, errors, result, consoleOutput }\n    }\n\n    if (argv.v || argv.version || argv._[0] === \"version\") {\n      return done(0, getPackageVersion())\n    }\n\n    const workingDir = resolve(cwd || process.cwd(), argv.root || \"\")\n\n    if (!(await pathExists(workingDir))) {\n      return done(1, chalk.red(`Could not find specified root path (${argv.root})`))\n    }\n\n    if (argv._.length === 0 || argv._[0] === \"help\") {\n      return done(0, await this.renderHelp(workingDir))\n    }\n\n    let projectConfig: ProjectResource | undefined\n\n    // First look for native Garden commands\n    let { command, matchedPath } = pickCommand(Object.values(this.commands), argv._)\n\n    // Load custom commands from current project (if applicable) and see if any match the arguments\n    if (!command) {\n      projectConfig = await this.getProjectConfig(workingDir)\n\n      if (projectConfig) {\n        const customCommands = await this.getCustomCommands(workingDir)\n        const picked = pickCommand(customCommands, argv._)\n        command = picked.command\n        matchedPath = picked.matchedPath\n      }\n    }\n\n    if (!command) {\n      const exitCode = argv.h || argv.help ? 0 : 1\n      return done(exitCode, await this.renderHelp(workingDir))\n    }\n\n    if (command instanceof CommandGroup) {\n      return done(0, command.renderHelp())\n    }\n\n    // Parse the arguments again with the Command set, to fully validate, and to ensure boolean options are\n    // handled correctly\n    argv = parseCliArgs({ stringArgs: args, command, cli: true })\n\n    // Slice command name from the positional args\n    argv._ = argv._.slice(command.getPath().length)\n\n    // handle -h/--help\n    if (argv.h || argv.help) {\n      if (command) {\n        // Show help for command\n        return done(0, command.renderHelp())\n      } else {\n        // Show general help text\n        return done(0, await this.renderHelp(workingDir))\n      }\n    }\n\n    let parsedArgs: BuiltinArgs & ParameterValues<any>\n    let parsedOpts: ParameterValues<any>\n\n    try {\n      const parseResults = processCliArgs({ rawArgs: args, parsedArgs: argv, command, matchedPath, cli: true })\n      parsedArgs = parseResults.args\n      parsedOpts = parseResults.opts\n    } catch (err) {\n      errors.push(...(err.detail?.errors || []).map(toGardenError))\n      return done(1, err.message + \"\\n\" + command.renderHelp())\n    }\n\n    let commandResult: CommandResult<any> | undefined = undefined\n    let analytics: AnalyticsHandler | undefined = undefined\n\n    if (!processRecord) {\n      processRecord = this.processRecord\n    }\n\n    if (!processRecord) {\n      // Note: Lazy-loading for startup performance\n      const { ensureConnected } = require(\"../db/connection\")\n      await ensureConnected()\n      const { GardenProcess: GP } = require(\"../db/entities/garden-process\")\n      processRecord = await GP.register(args)\n    }\n\n    this.processRecord = processRecord!\n\n    try {\n      const runResults = await this.runCommand({ command, parsedArgs, parsedOpts, processRecord, workingDir })\n      commandResult = runResults.result\n      analytics = runResults.analytics\n    } catch (err) {\n      commandResult = { errors: [err] }\n    }\n\n    errors.push(...(commandResult.errors || []))\n\n    // Flushes the Analytics events queue in case there are some remaining events.\n    if (analytics) {\n      await analytics.flush()\n    }\n\n    const gardenErrors: GardenBaseError[] = errors.map(toGardenError)\n\n    // --output option set\n    if (argv.output) {\n      const renderer = OUTPUT_RENDERERS[argv.output]!\n\n      if (gardenErrors.length > 0 || (commandResult.exitCode && commandResult.exitCode !== 0)) {\n        return done(\n          commandResult.exitCode || 1,\n          renderer({ success: false, errors: gardenErrors }),\n          commandResult?.result\n        )\n      } else {\n        return done(0, renderer({ success: true, ...commandResult }), commandResult?.result)\n      }\n    }\n\n    // Logger might not have been initialised if process exits early\n    try {\n      logger = getLogger()\n    } catch (_) {\n      logger = Logger.initialize({\n        level: LogLevel.info,\n        type: \"basic\",\n      })\n    }\n\n    let code = 0\n    if (gardenErrors.length > 0) {\n      if (!command.skipCliErrorSummary) {\n        for (const error of gardenErrors) {\n          const entry = logger.error({\n            msg: error.message,\n            error,\n          })\n          // Output error details to console when log level is silly\n          logger.silly({\n            msg: renderError(entry),\n          })\n        }\n      }\n\n      if (logger.getWriters().find((w) => w instanceof FileWriter)) {\n        logger.info(`\\nSee .garden/${ERROR_LOG_FILENAME} for detailed error message`)\n        await waitForOutputFlush()\n      }\n\n      code = commandResult.exitCode || 1\n    }\n    if (exitOnError) {\n      logger.stop()\n      logger.cleanup()\n    }\n\n    if (this.bufferedEventStream) {\n      if (code === 0) {\n        this.bufferedEventStream.streamEvent(\"sessionCompleted\", {})\n      } else {\n        this.bufferedEventStream.streamEvent(\"sessionFailed\", {})\n      }\n      await this.bufferedEventStream.close()\n      this.sessionFinished = true\n    }\n\n    return { argv, code, errors, result: commandResult?.result }\n  }\n\n  @pMemoizeDecorator()\n  private async getProjectConfig(workingDir: string): Promise<ProjectResource | undefined> {\n    return findProjectConfig(workingDir)\n  }\n\n  @pMemoizeDecorator()\n  private async getCustomCommands(workingDir: string): Promise<Command[]> {\n    const projectConfig = await this.getProjectConfig(workingDir)\n    const projectRoot = projectConfig?.path\n\n    if (!projectRoot) {\n      return []\n    }\n\n    return await getCustomCommands(Object.values(this.commands), projectRoot)\n  }\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport env from \"env-var\"\nimport { resolve, join } from \"path\"\nimport { homedir } from \"os\"\n\nexport const isPkg = !!(<any>process).pkg\n\nexport const LOCAL_CONFIG_FILENAME = \"local-config.yml\"\nexport const GLOBAL_CONFIG_FILENAME = \"global-config.yml\"\nexport const GARDEN_CORE_ROOT = isPkg ? resolve(process.execPath, \"..\") : resolve(__dirname, \"..\", \"..\")\nexport const GARDEN_CLI_ROOT = isPkg ? resolve(process.execPath, \"..\") : resolve(GARDEN_CORE_ROOT, \"..\", \"cli\")\nexport const STATIC_DIR = isPkg ? resolve(process.execPath, \"..\", \"static\") : resolve(GARDEN_CORE_ROOT, \"..\", \"static\")\n// We symlink to it the built dashboard to the core static directory during dev, and copy it there for dist builds\nexport const DASHBOARD_STATIC_DIR = join(STATIC_DIR, \"dashboard\")\nexport const DEFAULT_GARDEN_DIR_NAME = \".garden\"\nexport const LOGS_DIR_NAME = \"logs\"\nexport const GARDEN_GLOBAL_PATH = join(homedir(), DEFAULT_GARDEN_DIR_NAME)\nexport const LOGS_DIR = join(DEFAULT_GARDEN_DIR_NAME, LOGS_DIR_NAME)\nexport const ERROR_LOG_FILENAME = \"error.log\"\nexport const PROJECT_SOURCES_DIR_NAME = join(\"sources\", \"project\")\nexport const MODULE_SOURCES_DIR_NAME = join(\"sources\", \"module\")\nexport const GARDEN_BUILD_VERSION_FILENAME = \"garden-build-version\"\nexport const GARDEN_VERSIONFILE_NAME = \".garden-version\"\nexport const DEFAULT_PORT_PROTOCOL = \"TCP\"\n\nexport const DEFAULT_API_VERSION = \"garden.io/v0\"\n\nexport const DEFAULT_TEST_TIMEOUT = 60 * 1000\nexport const DEFAULT_TASK_TIMEOUT = 60 * 1000\n\nexport type SupportedPlatform = \"linux\" | \"darwin\" | \"win32\"\nexport const SUPPORTED_PLATFORMS: SupportedPlatform[] = [\"linux\", \"darwin\", \"win32\"]\n\nexport type SupportedArchitecture = \"x64\" | \"arm64\"\nexport const SUPPORTED_ARCHITECTURES: SupportedArchitecture[] = [\"x64\", \"arm64\"]\n\n// These keys aren't sensitive, so we ask GitGuardian to ignore them.\nexport const SEGMENT_DEV_API_KEY = \"D3DUZ3lBSDO3krnuIO7eYDdtlDAjooKW\" // ggignore\nexport const SEGMENT_PROD_API_KEY = \"b6ovUD9A0YjQqT3ZWetWUbuZ9OmGxKMa\" // ggignore\n\nexport const DOCS_BASE_URL = \"https://docs.garden.io\"\nexport const VERSION_CHECK_URL = \"https://get.garden.io/version\"\n\n/**\n * Environment variables, with defaults where appropriate.\n *\n * We set this up as a map to facilitate overriding values in tests.\n */\nexport const gardenEnv = {\n  ANALYTICS_DEV: env.get(\"ANALYTICS_DEV\").required(false).asBool(),\n  GARDEN_AUTH_TOKEN: env.get(\"GARDEN_AUTH_TOKEN\").required(false).asString(),\n  GARDEN_CACHE_TTL: env.get(\"GARDEN_CACHE_TTL\").required(false).asInt(),\n  GARDEN_DB_DIR: env.get(\"GARDEN_DB_DIR\").required(false).default(GARDEN_GLOBAL_PATH).asString(),\n  GARDEN_DISABLE_ANALYTICS: env.get(\"GARDEN_DISABLE_ANALYTICS\").required(false).asBool(),\n  GARDEN_DISABLE_PORT_FORWARDS: env.get(\"GARDEN_DISABLE_PORT_FORWARDS\").required(false).asBool(),\n  GARDEN_DISABLE_VERSION_CHECK: env.get(\"GARDEN_DISABLE_VERSION_CHECK\").required(false).asBool(),\n  GARDEN_ENABLE_PROFILING: env.get(\"GARDEN_ENABLE_PROFILING\").required(false).asBool(),\n  GARDEN_ENVIRONMENT: env.get(\"GARDEN_ENVIRONMENT\").required(false).asString(),\n  GARDEN_EXPERIMENTAL_BUILD_STAGE: env.get(\"GARDEN_EXPERIMENTAL_BUILD_STAGE\").required(false).asBool(),\n  GARDEN_GE_SCHEDULED: env.get(\"GARDEN_GE_SCHEDULED\").required(false).asBool(),\n  GARDEN_K8S_BUILD_SYNC_MODE: env.get(\"GARDEN_K8S_BUILD_SYNC_MODE\").required(false).default(\"rsync\").asString(),\n  GARDEN_LEGACY_BUILD_STAGE: env.get(\"GARDEN_LEGACY_BUILD_STAGE\").required(false).asBool(),\n  GARDEN_LOG_LEVEL: env.get(\"GARDEN_LOG_LEVEL\").required(false).asString(),\n  GARDEN_LOGGER_TYPE: env.get(\"GARDEN_LOGGER_TYPE\").required(false).asString(),\n  GARDEN_PROXY_DEFAULT_ADDRESS: env.get(\"GARDEN_PROXY_DEFAULT_ADDRESS\").required(false).asString(),\n  GARDEN_SERVER_PORT: env.get(\"GARDEN_SERVER_PORT\").required(false).asPortNumber(),\n  GARDEN_SERVER_HOSTNAME: env.get(\"GARDEN_SERVER_HOSTNAME\").required(false).asUrlString(),\n  GARDEN_SKIP_TESTS: env.get(\"GARDEN_SKIP_TESTS\").required(false).default(\"\").asString(),\n  GARDEN_HARD_CONCURRENCY_LIMIT: env.get(\"GARDEN_HARD_CONCURRENCY_LIMIT\").required(false).default(50).asInt(),\n  GARDEN_TASK_CONCURRENCY_LIMIT: env.get(\"GARDEN_TASK_CONCURRENCY_LIMIT\").required(false).default(6).asInt(),\n  GARDEN_WORKFLOW_RUN_UID: env.get(\"GARDEN_WORKFLOW_RUN_UID\").required(false).asString(),\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { omit } from \"lodash\"\nimport { EventEmitter2 } from \"eventemitter2\"\nimport { GraphResult } from \"./task-graph\"\nimport { LogEntryEventPayload } from \"./cloud/buffered-event-stream\"\nimport { ServiceStatus } from \"./types/service\"\nimport { NamespaceStatus, RunStatus } from \"./types/plugin/base\"\nimport { Omit } from \"./util/util\"\nimport { AuthTokenResponse } from \"./cloud/api\"\nimport { RenderedActionGraph } from \"./config-graph\"\nimport { BuildState } from \"./types/plugin/module/build\"\nimport { CommandInfo } from \"./plugin-context\"\nimport { sanitizeObject } from \"./logger/util\"\n\nexport type GardenEventListener<T extends EventName> = (payload: Events[T]) => void\n\n/**\n * This simple class serves as the central event bus for a Garden instance. Its function\n * is mainly to consolidate all events for the instance, to ensure type-safety.\n *\n * See below for the event interfaces.\n */\nexport class EventBus extends EventEmitter2 {\n  constructor() {\n    super({\n      wildcard: false,\n      newListener: false,\n      maxListeners: 100, // we may need to adjust this\n    })\n  }\n\n  emit<T extends EventName>(name: T, payload: Events[T]) {\n    return super.emit(name, payload)\n  }\n\n  on<T extends EventName>(name: T, listener: (payload: Events[T]) => void) {\n    return super.on(name, listener)\n  }\n\n  onAny(listener: <T extends EventName>(name: T, payload: Events[T]) => void) {\n    return super.onAny(<any>listener)\n  }\n\n  once<T extends EventName>(name: T, listener: (payload: Events[T]) => void) {\n    return super.once(name, listener)\n  }\n\n  // TODO: wrap more methods to make them type-safe\n}\n\n/**\n * Supported logger events and their interfaces.\n */\nexport interface LoggerEvents {\n  _test: any\n  logEntry: LogEntryEventPayload\n}\n\nexport type LoggerEventName = keyof LoggerEvents\n\nexport type GraphResultEventPayload = Omit<GraphResult, \"dependencyResults\">\n\nexport interface ServiceStatusPayload extends Omit<ServiceStatus, \"detail\"> {\n  deployStartedAt?: Date\n  deployCompletedAt?: Date\n}\n\nexport function toGraphResultEventPayload(result: GraphResult): GraphResultEventPayload {\n  const payload = sanitizeObject(omit(result, \"dependencyResults\"))\n  if (result.output) {\n    // TODO: Use a combined blacklist of fields from all task types instead of hardcoding here.\n    payload.output = omit(result.output, \"dependencyResults\", \"log\", \"buildLog\", \"detail\")\n    if (result.output.version) {\n      payload.output.version = result.output.version.versionString || null\n    }\n  }\n  return payload\n}\n\n/**\n * Supported Garden events and their interfaces.\n */\nexport interface Events extends LoggerEvents {\n  // Internal test/control events\n  _exit: {}\n  _restart: {}\n  _test: any\n  _workflowRunRegistered: {\n    workflowRunUid: string\n  }\n\n  // Process events\n  serversUpdated: {\n    servers: { host: string; command: string; serverAuthKey: string }[]\n  }\n  receivedToken: AuthTokenResponse\n\n  // Session events - one of these is emitted when the command process ends\n  sessionCompleted: {} // Command exited with a 0 status\n  sessionFailed: {} // Command exited with a nonzero status\n  sessionCancelled: {} // Command exited because of an interrupt signal (e.g. CTRL-C)\n\n  // Watcher events\n  configAdded: {\n    path: string\n  }\n  configRemoved: {\n    path: string\n  }\n  internalError: {\n    timestamp: Date\n    error: Error\n  }\n  projectConfigChanged: {}\n  moduleConfigChanged: {\n    names: string[]\n    path: string\n  }\n  moduleSourcesChanged: {\n    names: string[]\n    pathsChanged: string[]\n  }\n  moduleRemoved: {}\n\n  // Command/project metadata events\n  commandInfo: CommandInfo\n\n  // Stack Graph events\n  stackGraph: RenderedActionGraph\n\n  // TaskGraph events\n  taskPending: {\n    addedAt: Date\n    batchId: string\n    key: string\n    type: string\n    name: string\n  }\n  taskProcessing: {\n    startedAt: Date\n    batchId: string\n    key: string\n    type: string\n    name: string\n    versionString: string\n  }\n  taskComplete: GraphResultEventPayload\n  taskError: GraphResultEventPayload\n  taskCancelled: {\n    cancelledAt: Date\n    batchId: string\n    type: string\n    key: string\n    name: string\n  }\n  taskGraphProcessing: {\n    startedAt: Date\n  }\n  taskGraphComplete: {\n    completedAt: Date\n  }\n  watchingForChanges: {}\n  log: {\n    timestamp: number\n    actionUid: string\n    entity: {\n      moduleName: string\n      type: string\n      key: string\n    }\n    data: string\n  }\n\n  // Status events\n\n  /**\n   * In the `buildStatus`, `taskStatus`, `testStatus` and `serviceStatus` events, the optional `actionUid` field\n   * identifies a single build/deploy/run.\n   *\n   * The `build`/`testModule`/`runTask`/`deployService` actions emit two events: One before the plugin handler is\n   * called (a \"building\"/\"running\"/\"deploying\" event), and another one after the handler finishes successfully or\n   * throws an error.\n   *\n   * When logged in, the `actionUid` is used by the Garden Cloud backend to group these two events for each of these\n   * action invocations.\n   *\n   * No `actionUid` is set for the corresponding \"get status\" actions (e.g. `getBuildStatus` or `getServiceStatus`),\n   * since those actions don't result in a build/deploy/run (so there are no associated logs or timestamps to track).\n   */\n\n  buildStatus: {\n    moduleName: string\n    moduleVersion: string\n    /**\n     * `actionUid` should only be defined if `state = \"building\" | \"built\" | \"failed\"` (and not if `state = \"fetched\",\n     * since in that case, no build took place and there are no logs/timestamps to view).\n     */\n    actionUid?: string\n    status: {\n      state: BuildState\n      startedAt?: Date\n      completedAt?: Date\n    }\n  }\n  taskStatus: {\n    taskName: string\n    moduleName: string\n    moduleVersion: string\n    taskVersion: string\n    /**\n     * `actionUid` should only be defined if the task was run , i.e. if `state = \"running\" | \"succeeded\" | \"failed\"`\n     * (and not if `state = \"outdated\" | \"not-implemented, since in that case, no run took place and there are no\n     * logs/timestamps to view).\n     */\n    actionUid?: string\n    status: RunStatus\n  }\n  testStatus: {\n    testName: string\n    moduleName: string\n    moduleVersion: string\n    testVersion: string\n    /**\n     * `actionUid` should only be defined if the test was run, i.e. if `state = \"running\" | \"succeeded\" | \"failed\"`\n     * (and not if `state = \"outdated\" | \"not-implemented, since in that case, no run took place and there are no\n     * logs/timestamps to view).\n     */\n    actionUid?: string\n    status: RunStatus\n  }\n  serviceStatus: {\n    serviceName: string\n    moduleName: string\n    moduleVersion: string\n    serviceVersion: string\n    /**\n     * `actionUid` should only be defined if a deploy took place (i.e. when emitted from the `deployService` action).\n     */\n    actionUid?: string\n    status: ServiceStatusPayload\n  }\n  namespaceStatus: NamespaceStatus\n\n  // Workflow events\n  workflowRunning: {}\n  workflowComplete: {}\n  workflowError: {}\n  workflowStepProcessing: {\n    index: number\n  }\n  workflowStepSkipped: {\n    index: number\n  }\n  workflowStepComplete: {\n    index: number\n    durationMsec: number\n  }\n  workflowStepError: {\n    index: number\n    durationMsec: number\n  }\n}\n\nexport type EventName = keyof Events\n\n// Note: Does not include logger events.\nexport const pipedEventNames: EventName[] = [\n  \"_exit\",\n  \"_restart\",\n  \"_test\",\n  \"_workflowRunRegistered\",\n  \"sessionCompleted\",\n  \"sessionFailed\",\n  \"sessionCancelled\",\n  \"configAdded\",\n  \"configRemoved\",\n  \"internalError\",\n  \"log\",\n  \"moduleConfigChanged\",\n  \"moduleRemoved\",\n  \"commandInfo\",\n  \"moduleSourcesChanged\",\n  \"namespaceStatus\",\n  \"projectConfigChanged\",\n  \"serviceStatus\",\n  \"stackGraph\",\n  \"taskCancelled\",\n  \"taskComplete\",\n  \"taskError\",\n  \"taskGraphComplete\",\n  \"taskGraphProcessing\",\n  \"taskPending\",\n  \"taskProcessing\",\n  \"buildStatus\",\n  \"taskStatus\",\n  \"testStatus\",\n  \"watchingForChanges\",\n  \"workflowComplete\",\n  \"workflowError\",\n  \"workflowRunning\",\n  \"workflowStepComplete\",\n  \"workflowStepError\",\n  \"workflowStepProcessing\",\n  \"workflowStepSkipped\",\n]\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { BufferedEventStream, ConnectBufferedEventStreamParams } from \"../cloud/buffered-event-stream\"\nimport { Profile } from \"../util/profiling\"\nimport { isEqual } from \"lodash\"\n\nconst targetUpdateIntervalMsec = 1000\n\n@Profile()\nexport class DashboardEventStream extends BufferedEventStream {\n  protected intervalMsec = 250\n\n  private targetPollIntervalId?: NodeJS.Timeout\n  private ignoreHost: string | undefined\n\n  connect(params: ConnectBufferedEventStreamParams & { ignoreHost?: string }) {\n    // Need this so the dashboard command doesn't try to send events to itself.\n    // We can't ignore by PID because we wouldn't be able to unit test easily.\n    this.ignoreHost = params.ignoreHost\n    super.connect(params)\n  }\n\n  /**\n   * Updates the list of active dashboard servers to stream events to.\n   * Returns the list of Garden processes matching the current project/env that are active servers.\n   */\n  async updateTargets() {\n    if (!this.garden) {\n      return []\n    }\n\n    // Note: lazy-loading for performance\n    const { GardenProcess } = await import(\"../db/entities/garden-process\")\n\n    const running = await GardenProcess.getActiveProcesses()\n    const servers = running.filter(\n      (p) =>\n        !!p.persistent &&\n        !!p.serverHost &&\n        !!p.serverAuthKey &&\n        !!p.command &&\n        p.projectName === this.garden.projectName &&\n        p.projectRoot === this.garden.projectRoot &&\n        p.environmentName === this.garden.environmentName &&\n        p.namespace === this.garden.namespace &&\n        !(this.ignoreHost && p.serverHost === this.ignoreHost)\n    )\n\n    const currentHosts = this.targets.map((p) => p.host).sort()\n    const newHosts = servers.map((p) => p.serverHost!).sort()\n\n    this.targets = servers.map((p) => ({ host: p.serverHost!, clientAuthToken: p.serverAuthKey!, enterprise: false }))\n\n    // Notify of updates\n    if (this.garden && !isEqual(currentHosts, newHosts)) {\n      this.log.debug(`Updated list of running dashboard servers: ${servers.map((p) => p.serverHost).join(\", \")}`)\n\n      this.garden.events.emit(\"serversUpdated\", {\n        servers: servers.map((p) => ({\n          command: p.command!,\n          host: p.serverHost!,\n          serverAuthKey: p.serverAuthKey || \"\",\n        })),\n      })\n    }\n\n    return servers\n  }\n\n  /**\n   * Poll for running dashboard servers\n   */\n  startInterval() {\n    super.startInterval()\n\n    this.targetPollIntervalId = setInterval(() => {\n      this.updateTargets().catch((err) => {\n        this.log.error(err)\n      })\n    }, targetUpdateIntervalMsec)\n  }\n\n  async close() {\n    if (this.targetPollIntervalId) {\n      clearInterval(this.targetPollIntervalId)\n      delete this.targetPollIntervalId\n    }\n    await super.close()\n  }\n\n  streamLogEntry() {\n    // Not streaming log events for now\n    return\n  }\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { Server } from \"http\"\n\nimport chalk from \"chalk\"\nimport Koa from \"koa\"\nimport mount = require(\"koa-mount\")\nimport serve = require(\"koa-static\")\nimport Router = require(\"koa-router\")\nimport websockify from \"koa-websocket\"\nimport bodyParser = require(\"koa-bodyparser\")\nimport getPort = require(\"get-port\")\nimport { omit } from \"lodash\"\n\nimport { Garden } from \"../garden\"\nimport { prepareCommands, parseRequest } from \"./commands\"\nimport { DASHBOARD_STATIC_DIR, gardenEnv } from \"../constants\"\nimport { LogEntry } from \"../logger/log-entry\"\nimport { Command, CommandResult } from \"../commands/base\"\nimport { toGardenError, GardenError } from \"../exceptions\"\nimport { EventName, Events, EventBus, GardenEventListener } from \"../events\"\nimport { uuidv4, ValueOf } from \"../util/util\"\nimport { AnalyticsHandler } from \"../analytics/analytics\"\nimport { joi } from \"../config/common\"\nimport { randomString } from \"../util/string\"\nimport { authTokenHeader } from \"../cloud/api\"\nimport { ApiEventBatch } from \"../cloud/buffered-event-stream\"\nimport { LogLevel } from \"../logger/logger\"\n\n// Note: This is different from the `garden dashboard` default port.\n// We may no longer embed servers in watch processes from 0.13 onwards.\nexport const defaultWatchServerPort = 9777\nconst notReadyMessage = \"Waiting for Garden instance to initialize\"\n\n/**\n * Start an HTTP server that exposes commands and events for the given Garden instance.\n *\n * Please look at the tests for usage examples.\n *\n * NOTES:\n * If `port` is not specified, the default is used or a random free port is chosen if default is not available.\n * This is done so that a process can always create its own server, but we won't need that functionality once we\n * run a shared service across commands.\n */\nexport async function startServer({ log, port }: { log: LogEntry; port?: number }) {\n  // Start HTTP API and dashboard server.\n  // allow overriding automatic port picking\n  if (!port) {\n    port = gardenEnv.GARDEN_SERVER_PORT || undefined\n  }\n  const server = new GardenServer({ log, port })\n  await server.start()\n  return server\n}\n\nexport class GardenServer {\n  private log: LogEntry\n  private debugLog: LogEntry\n  private server: Server\n  private garden: Garden | undefined\n  private app: websockify.App\n  private analytics: AnalyticsHandler\n  private incomingEvents: EventBus\n  private statusLog: LogEntry\n  private serversUpdatedListener: GardenEventListener<\"serversUpdated\">\n  private activePersistentRequests: { [requestId: string]: { command: Command; connId: string } }\n\n  public port: number | undefined\n  public readonly authKey: string\n\n  constructor({ log, port }: { log: LogEntry; port?: number }) {\n    this.log = log\n    this.debugLog = this.log.placeholder({ level: LogLevel.debug, childEntriesInheritLevel: true })\n    this.garden = undefined\n    this.port = port\n    this.authKey = randomString(24)\n    this.incomingEvents = new EventBus()\n    this.activePersistentRequests = {}\n\n    this.serversUpdatedListener = ({ servers }) => {\n      // Update status log line with new `garden dashboard` server, if any\n      for (const { host, command, serverAuthKey } of servers) {\n        if (command === \"dashboard\") {\n          this.showUrl(`${host}?key=${serverAuthKey}`)\n          return\n        }\n      }\n\n      // No active explicit dashboard processes, show own URL instead\n      this.showUrl(this.getUrl())\n    }\n  }\n\n  async start() {\n    if (this.server) {\n      return\n    }\n\n    this.app = await this.createApp()\n\n    const hostname = gardenEnv.GARDEN_SERVER_HOSTNAME || \"localhost\"\n\n    if (this.port) {\n      this.server = this.app.listen(this.port, hostname)\n    } else {\n      do {\n        try {\n          this.port = await getPort({ port: defaultWatchServerPort })\n          this.server = this.app.listen(this.port, hostname)\n        } catch {}\n      } while (!this.server)\n    }\n\n    this.log.info(\"\")\n    this.statusLog = this.log.placeholder()\n  }\n\n  getBaseUrl() {\n    return `http://localhost:${this.port}`\n  }\n\n  getUrl() {\n    return `${this.getBaseUrl()}?key=${this.authKey}`\n  }\n\n  showUrl(url?: string) {\n    this.statusLog.setState({\n      emoji: \"sunflower\",\n      msg: chalk.cyan(\"Garden dashboard running at \") + (url || this.getUrl()),\n    })\n  }\n\n  async close() {\n    return this.server.close()\n  }\n\n  setGarden(garden: Garden) {\n    if (this.garden) {\n      this.garden.events.removeListener(\"serversUpdated\", this.serversUpdatedListener)\n    }\n\n    this.garden = garden\n    this.garden.log = this.debugLog\n\n    // Serve artifacts as static assets\n    this.app.use(mount(\"/artifacts\", serve(garden.artifactsPath)))\n\n    // Listen for new dashboard servers\n    garden.events.on(\"serversUpdated\", this.serversUpdatedListener)\n  }\n\n  private async createApp() {\n    // prepare request-command map\n    const commands = prepareCommands()\n\n    const app = websockify(new Koa())\n    const http = new Router()\n\n    http.use((ctx, next) => {\n      const authToken = ctx.header[authTokenHeader] || ctx.query.key\n\n      if (authToken !== this.authKey) {\n        ctx.throw(401, `Unauthorized request`)\n        return\n      }\n      return next()\n    })\n\n    /**\n     * HTTP API endpoint (POST /api)\n     *\n     * We don't expose a different route per command, but rather accept a JSON object via POST on /api\n     * with a `command` key. The API wouldn't be RESTful in any meaningful sense anyway, and this\n     * means we can keep a consistent format across mechanisms.\n     */\n    http.post(\"/api\", async (ctx) => {\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      if (!this.analytics) {\n        try {\n          this.analytics = await AnalyticsHandler.init(this.garden, this.debugLog)\n        } catch (err) {\n          throw err\n        }\n      }\n\n      this.analytics.trackApi(\"POST\", ctx.originalUrl, { ...ctx.request.body })\n\n      const { command, log, args, opts } = parseRequest(ctx, this.debugLog, commands, ctx.request.body)\n\n      const prepareParams = {\n        log,\n        headerLog: log,\n        footerLog: log,\n        args,\n        opts,\n      }\n\n      const persistent = command.isPersistent(prepareParams)\n\n      if (persistent) {\n        ctx.throw(400, \"Attempted to run persistent command (e.g. a watch/follow command). Aborting.\")\n      }\n\n      await command.prepare(prepareParams)\n\n      const result = await command.action({\n        garden: this.garden,\n        log,\n        headerLog: log,\n        footerLog: log,\n        args,\n        opts,\n      })\n\n      ctx.status = 200\n      ctx.response.body = result\n    })\n\n    /**\n     * Resolves the URL for the given provider dashboard page, and redirects to it.\n     */\n    http.get(\"/dashboardPages/:pluginName/:pageName\", async (ctx) => {\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      const { pluginName, pageName } = ctx.params\n\n      const actions = await this.garden.getActionRouter()\n      const plugin = await this.garden.getPlugin(pluginName)\n      const page = plugin.dashboardPages.find((p) => p.name === pageName)\n\n      if (!page) {\n        return ctx.throw(400, `Could not find page ${pageName} from provider ${pluginName}`)\n      }\n\n      const { url } = await actions.getDashboardPage({ log: this.log, page, pluginName })\n      ctx.redirect(url)\n    })\n\n    /**\n     * Events endpoint, for ingesting events from other Garden processes, and piping to any open websocket connections.\n     * Requires a valid auth token header, matching `this.authKey`.\n     *\n     * The API matches that of the Garden Cloud /events endpoint.\n     */\n    http.post(\"/events\", async (ctx) => {\n      // TODO: validate the input\n      const batch = ctx.request.body as ApiEventBatch\n      this.debugLog.debug(`Received ${batch.events.length} events from session ${batch.sessionId}`)\n\n      // Pipe the events to the incoming stream, which websocket listeners will then receive\n      batch.events.forEach((e) => this.incomingEvents.emit(e.name, e.payload))\n\n      ctx.status = 200\n    })\n\n    app.use(bodyParser())\n\n    app.use(http.routes())\n    app.use(http.allowedMethods())\n\n    app.on(\"error\", (err, ctx) => {\n      this.debugLog.info(`API server request failed with status ${ctx.status}: ${err.message}`)\n    })\n\n    // This enables navigating straight to a nested route, e.g. \"localhost:<PORT>/graph\".\n    // FIXME: We need to be able to do this for any route, instead of hard coding the routes like this.\n    const routes = [\"/\", \"/graph\", \"/logs\"]\n    for (const route of routes) {\n      app.use(mount(route, serve(DASHBOARD_STATIC_DIR)))\n    }\n\n    this.addWebsocketEndpoint(app)\n\n    return app\n  }\n\n  private notReady(ctx: Router.IRouterContext | Koa.ParameterizedContext) {\n    ctx.status = 503\n    ctx.response.body = notReadyMessage\n  }\n\n  /**\n   * Add the /ws endpoint to the Koa app. Every event emitted to the event bus is forwarded to open\n   * Websocket connections, and clients can send commands over the socket and receive results on the\n   * same connection.\n   */\n  private addWebsocketEndpoint(app: websockify.App) {\n    const wsRouter = new Router()\n\n    wsRouter.get(\"/ws\", async (ctx) => {\n      if (!this.garden) {\n        return this.notReady(ctx)\n      }\n\n      const connId = uuidv4()\n\n      // The typing for koa-websocket isn't working currently\n      const websocket: Koa.Context[\"ws\"] = ctx[\"websocket\"]\n\n      // Helper to make JSON messages, make them type-safe, and to log errors.\n      const send = <T extends ServerWebsocketMessageType>(type: T, payload: ServerWebsocketMessages[T]) => {\n        const event = { type, ...(<object>payload) }\n        this.log.debug(`Send event: ${JSON.stringify(event)}`)\n        websocket.send(JSON.stringify(event), (err) => {\n          if (err) {\n            this.debugLog.debug({ error: toGardenError(err) })\n          }\n        })\n      }\n\n      const error = (message: string, requestId?: string) => {\n        this.log.debug(message)\n        return send(\"error\", { message, requestId })\n      }\n\n      // TODO: Only allow auth key authentication\n      if (ctx.query.sessionId !== `${this.garden.sessionId}` && ctx.query.key !== `${this.authKey}`) {\n        error(`401 Unauthorized`)\n        websocket.terminate()\n        return\n      }\n\n      // Set up heartbeat to detect dead connections\n      let isAlive = true\n\n      let heartbeatInterval = setInterval(() => {\n        if (!isAlive) {\n          this.log.debug(`Connection ${connId} timed out.`)\n          websocket.terminate()\n        }\n\n        isAlive = false\n        this.log.debug(`Connection ${connId} ping.`)\n        websocket.ping(() => {})\n      }, 1000)\n\n      websocket.on(\"pong\", () => {\n        this.log.debug(`Connection ${connId} pong.`)\n        isAlive = true\n      })\n\n      // Pipe everything from the event bus to the socket, as well as from the /events endpoint\n      const eventListener = (name: EventName, payload: any) => send(\"event\", { name, payload })\n      this.garden.events.onAny(eventListener)\n      this.incomingEvents.onAny(eventListener)\n\n      const cleanup = () => {\n        this.log.debug(`Connection ${connId} terminated, cleaning up.`)\n        clearInterval(heartbeatInterval)\n\n        this.garden && this.garden.events.offAny(eventListener)\n        this.incomingEvents.offAny(eventListener)\n\n        for (const [id, req] of Object.entries(this.activePersistentRequests)) {\n          if (connId === req.connId) {\n            req.command.terminate()\n            delete this.activePersistentRequests[id]\n          }\n        }\n      }\n\n      // Make sure we clean up listeners when connections end.\n      websocket.on(\"close\", cleanup)\n\n      // Respond to commands.\n      websocket.on(\"message\", (msg) => {\n        let request: any\n\n        this.log.debug(\"Got request: \" + msg)\n\n        try {\n          request = JSON.parse(msg.toString())\n        } catch {\n          return error(\"Could not parse message as JSON\")\n        }\n\n        const requestId = request.id\n\n        try {\n          joi.attempt(requestId, joi.string().uuid().required())\n        } catch {\n          return error(\"Message should contain an `id` field with a UUID value\", requestId)\n        }\n\n        try {\n          joi.attempt(request.type, joi.string().required())\n        } catch {\n          return error(\"Message should contain a type field\")\n        }\n\n        if (request.type === \"command\") {\n          // Start a command\n          const garden = this.garden\n\n          if (!garden) {\n            return send(\"error\", { requestId, message: notReadyMessage })\n          }\n\n          try {\n            const commands = prepareCommands()\n            const { command, log, args, opts } = parseRequest(\n              ctx,\n              this.debugLog,\n              commands,\n              omit(request, [\"id\", \"type\"])\n            )\n\n            const prepareParams = {\n              log,\n              headerLog: log,\n              footerLog: log,\n              args,\n              opts,\n            }\n\n            const persistent = command.isPersistent(prepareParams)\n\n            command\n              .prepare(prepareParams)\n              .then(() => {\n                if (persistent) {\n                  send(\"commandStart\", {\n                    requestId,\n                    args,\n                    opts,\n                  })\n                  this.activePersistentRequests[requestId] = { command, connId }\n\n                  command.subscribe((data: any) => {\n                    send(\"commandOutput\", {\n                      requestId,\n                      command: command.getFullName(),\n                      data,\n                    })\n                  })\n                }\n\n                // TODO: validate result schema\n                return command.action({\n                  garden,\n                  log,\n                  headerLog: log,\n                  footerLog: log,\n                  args,\n                  opts,\n                })\n              })\n              .then((result) => {\n                send(\"commandResult\", {\n                  requestId,\n                  result: result.result,\n                  errors: result.errors,\n                })\n              })\n              .catch((err) => {\n                error(err.message, requestId)\n              })\n          } catch (err) {\n            return error(err.message, requestId)\n          }\n        } else if (request.type === \"commandStatus\") {\n          const r = this.activePersistentRequests[requestId]\n          const status = r ? \"active\" : \"not found\"\n          send(\"commandStatus\", {\n            requestId,\n            status,\n          })\n        } else if (request.type === \"abortCommand\") {\n          const req = this.activePersistentRequests[requestId]\n          req.command.terminate()\n          delete this.activePersistentRequests[requestId]\n        } else {\n          return send(\"error\", {\n            requestId,\n            message: `Unsupported request type: ${request.type}`,\n          })\n        }\n      })\n    })\n\n    app.ws.use(<Koa.Middleware<any>>wsRouter.routes())\n    app.ws.use(<Koa.Middleware<any>>wsRouter.allowedMethods())\n  }\n}\n\ninterface ServerWebsocketMessages {\n  commandOutput: {\n    requestId: string\n    command: string\n    data: string\n  }\n  commandResult: {\n    requestId: string\n    result: CommandResult<any>\n    errors?: GardenError[]\n  }\n  commandStatus: {\n    requestId: string\n    status: \"active\" | \"not found\"\n  }\n  commandStart: {\n    requestId: string\n    args: object\n    opts: object\n  }\n  error: {\n    requestId?: string\n    message: string\n  }\n  event: {\n    name: EventName\n    payload: ValueOf<Events>\n  }\n}\n\ntype ServerWebsocketMessageType = keyof ServerWebsocketMessages\n\nexport type ServerWebsocketMessage = ServerWebsocketMessages[ServerWebsocketMessageType] & {\n  type: ServerWebsocketMessageType\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { expect } from \"chai\"\nimport nock from \"nock\"\nimport { isEqual } from \"lodash\"\n\nimport { makeDummyGarden, GardenCli } from \"../../../../src/cli/cli\"\nimport {\n  getDataDir,\n  TestGarden,\n  makeTestGardenA,\n  enableAnalytics,\n  projectRootA,\n  TestEventBus,\n  initTestLogger,\n} from \"../../../helpers\"\nimport { gardenEnv, GARDEN_CORE_ROOT } from \"../../../../src/constants\"\nimport { join, resolve } from \"path\"\nimport { Command, CommandGroup, CommandParams, PrepareParams } from \"../../../../src/commands/base\"\nimport { getPackageVersion } from \"../../../../src/util/util\"\nimport { UtilCommand } from \"../../../../src/commands/util/util\"\nimport { StringParameter } from \"../../../../src/cli/params\"\nimport stripAnsi from \"strip-ansi\"\nimport { ToolsCommand } from \"../../../../src/commands/tools\"\nimport { Logger, getLogger } from \"../../../../src/logger/logger\"\nimport { safeLoad } from \"js-yaml\"\nimport { GardenProcess } from \"../../../../src/db/entities/garden-process\"\nimport { ensureConnected } from \"../../../../src/db/connection\"\nimport { startServer, GardenServer } from \"../../../../src/server/server\"\nimport { FancyTerminalWriter } from \"../../../../src/logger/writers/fancy-terminal-writer\"\nimport { BasicTerminalWriter } from \"../../../../src/logger/writers/basic-terminal-writer\"\nimport { envSupportsEmoji } from \"../../../../src/logger/util\"\nimport { expectError } from \"../../../../src/util/testing\"\n\ndescribe(\"cli\", () => {\n  let cli: GardenCli\n\n  before(async () => {\n    await ensureConnected()\n  })\n\n  beforeEach(() => {\n    cli = new GardenCli()\n  })\n\n  afterEach(async () => {\n    if (cli.processRecord && cli.processRecord._id) {\n      await cli.processRecord.remove()\n    }\n  })\n\n  describe(\"run\", () => {\n    it(\"aborts with help text if no positional argument is provided\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with default help text if -h option is set and no command\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-h\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with default help text if --help option is set and no command\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-h\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(await cli.renderHelp(\"/\"))\n    })\n\n    it(\"aborts with command help text if --help option is set and command is specified\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, consoleOutput } = await cli.run({ args: [\"test-command\", \"--help\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(cmd.renderHelp())\n    })\n\n    it(\"aborts with version text if -v is set\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"-v\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"aborts with version text if --version is set\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"--version\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"aborts with version text if version is first argument\", async () => {\n      const { code, consoleOutput } = await cli.run({ args: [\"version\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(getPackageVersion())\n    })\n\n    it(\"throws if --root is set, pointing to a non-existent path\", async () => {\n      const path = \"/tmp/hauweighaeighuawek\"\n      const { code, consoleOutput } = await cli.run({ args: [\"--root\", path], exitOnError: false })\n\n      expect(code).to.equal(1)\n      expect(stripAnsi(consoleOutput!)).to.equal(`Could not find specified root path (${path})`)\n    })\n\n    context(\"custom commands\", () => {\n      const root = getDataDir(\"test-projects\", \"custom-commands\")\n\n      it(\"picks up all commands in project root\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        expect(commands.map((c) => c.name).sort()).to.eql([\"combo\", \"echo\", \"run-task\", \"script\"])\n      })\n\n      it(\"runs a custom command\", async () => {\n        const res = await cli.run({ args: [\"echo\", \"foo\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(0)\n      })\n\n      it(\"warns and ignores custom command with same name as built-in command\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The plugin(s) commands are defined in nope.garden.yml\n        expect(commands.map((c) => c.name)).to.not.include(\"plugins\")\n      })\n\n      it(\"warns if a custom command is provided with same name as alias for built-in command\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The plugin(s) commands are defined in nope.garden.yml\n        expect(commands.map((c) => c.name)).to.not.include(\"plugin\")\n      })\n\n      it(\"doesn't pick up commands outside of project root\", async () => {\n        const commands = await cli[\"getCustomCommands\"](root)\n\n        // The nope command is defined in the `nope` directory in the test project.\n        expect(commands.map((c) => c.name)).to.not.include(\"nope\")\n      })\n\n      it(\"prints custom commands in help text\", async () => {\n        const helpText = stripAnsi(await cli.renderHelp(root))\n\n        expect(helpText).to.include(\"CUSTOM COMMANDS\")\n        expect(helpText).to.include(\"combo     A complete example using most available features\")\n        expect(helpText).to.include(\"echo      Just echo a string\")\n        expect(helpText).to.include(\"run-task  Run the specified task\")\n      })\n\n      it(\"prints help text for a custom command\", async () => {\n        const res = await cli.run({ args: [\"combo\", \"--help\"], exitOnError: false, cwd: root })\n\n        const commands = await cli[\"getCustomCommands\"](root)\n        const command = commands.find((c) => c.name === \"combo\")!\n        const helpText = command.renderHelp()\n\n        expect(res.code).to.equal(0)\n        expect(res.consoleOutput).to.equal(helpText)\n      })\n\n      it(\"errors if a Command resource is invalid\", async () => {\n        return expectError(\n          () =>\n            cli.run({\n              args: [\"echo\", \"foo\"],\n              exitOnError: false,\n              cwd: getDataDir(\"test-projects\", \"custom-commands-invalid\"),\n            }),\n          (err) => expect(err.message).to.include(\"Error validating custom Command 'invalid'\")\n        )\n      })\n\n      it(\"exits with code from exec command if it fails\", async () => {\n        const res = await cli.run({ args: [\"script\", \"exit 2\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(2)\n      })\n\n      it(\"exits with code 1 if Garden command fails\", async () => {\n        const res = await cli.run({ args: [\"run-task\", \"fail\"], exitOnError: false, cwd: root })\n\n        expect(res.code).to.equal(1)\n      })\n    })\n\n    context(\"test logger initialization\", () => {\n      const envLoggerType = process.env.GARDEN_LOGGER_TYPE\n\n      // Logger is a singleton and we need to reset it between these tests as we're testing\n      // that it's initialised correctly in this block.\n      beforeEach(() => {\n        delete process.env.GARDEN_LOGGER_TYPE\n        Logger.clearInstance()\n      })\n      // Re-initialise the test logger\n      after(() => {\n        process.env.GARDEN_LOGGER_TYPE = envLoggerType\n        Logger.clearInstance()\n        initTestLogger()\n      })\n\n      it(\"uses the fancy logger by default\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(FancyTerminalWriter)\n      })\n\n      it(\"uses the basic logger if log level > info\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({\n          args: [\"--logger-type=fancy\", \"--log-level=3\", \"test-command\"],\n          exitOnError: false,\n        })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(BasicTerminalWriter)\n      })\n\n      it(\"uses the basic logger if --show-timestamps flag is set to true\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"halp!\"\n          noProject = true\n\n          printHeader() {}\n          async action({}) {\n            return { result: { something: \"important\" } }\n          }\n        }\n        const cmd = new TestCommand()\n        cli.addCommand(cmd)\n\n        await cli.run({ args: [\"--logger-type=fancy\", \"--show-timestamps\", \"test-command\"], exitOnError: false })\n\n        const logger = getLogger()\n        expect(logger.getWriters()[0]).to.be.instanceOf(BasicTerminalWriter)\n      })\n    })\n\n    it(\"shows group help text if specified command is a group\", async () => {\n      const cmd = new UtilCommand()\n      const { code, consoleOutput } = await cli.run({ args: [\"util\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(consoleOutput).to.equal(cmd.renderHelp())\n    })\n\n    it(\"picks and runs a command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"handles params specified before the command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({ args: [\"--logger-type=basic\", \"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"updates the GardenProcess entry if given with command info before running (no server)\", async () => {\n      const args = [\"test-command\", \"--root\", projectRootA]\n      const record = await GardenProcess.register(args)\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          expect(record.command).to.equal(this.name)\n          expect(record.sessionId).to.equal(garden.sessionId)\n          expect(record.persistent).to.equal(false)\n          expect(record.serverHost).to.equal(null)\n          expect(record.serverAuthKey).to.equal(null)\n          expect(record.projectRoot).to.equal(garden.projectRoot)\n          expect(record.projectName).to.equal(garden.projectName)\n          expect(record.environmentName).to.equal(garden.environmentName)\n          expect(record.namespace).to.equal(garden.namespace)\n\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      try {\n        await cli.run({ args, exitOnError: false, processRecord: record })\n      } finally {\n        await record.remove()\n      }\n    })\n\n    it(\"updates the GardenProcess entry if given with command info before running (with server)\", async () => {\n      const args = [\"test-command\", \"--root\", projectRootA]\n      const record = await GardenProcess.register(args)\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          expect(record.command).to.equal(this.name)\n          expect(record.sessionId).to.equal(garden.sessionId)\n          expect(record.persistent).to.equal(true)\n          expect(record.serverHost).to.equal(this.server!.getUrl())\n          expect(record.serverAuthKey).to.equal(this.server!.authKey)\n          expect(record.projectRoot).to.equal(garden.projectRoot)\n          expect(record.projectName).to.equal(garden.projectName)\n          expect(record.environmentName).to.equal(garden.environmentName)\n          expect(record.namespace).to.equal(garden.namespace)\n\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      try {\n        await cli.run({ args, exitOnError: false, processRecord: record })\n      } finally {\n        await record.remove()\n      }\n    })\n\n    it(\"connects the process to an external dashboard instance if available\", async () => {\n      // Spin up test server and register.\n      // Note: We're using test-project-a and the default env+namespace both here and in the CLI run\n      const serverGarden = await makeTestGardenA()\n      const serverEventBus = new TestEventBus()\n      const server = new GardenServer({ log: serverGarden.log })\n      server[\"incomingEvents\"] = serverEventBus\n      await server.start()\n      server.setGarden(serverGarden)\n\n      const record = await GardenProcess.register([\"dashboard\"])\n      await record.setCommand({\n        command: \"dashboard\",\n        sessionId: serverGarden.sessionId,\n        persistent: true,\n        serverHost: server.getBaseUrl(),\n        serverAuthKey: server.authKey,\n        projectRoot: serverGarden.projectRoot,\n        projectName: serverGarden.projectName,\n        environmentName: serverGarden.environmentName,\n        namespace: serverGarden.namespace,\n      })\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        streamEvents = true\n        streamLogEntries = true\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          garden.events.emit(\"_test\", \"funky functional test\")\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", serverGarden.projectRoot]\n\n      try {\n        await cli.run({ args, exitOnError: false })\n      } finally {\n        await record.remove()\n        await server.close()\n      }\n\n      serverEventBus.expectEvent(\"_test\", \"funky functional test\")\n    })\n\n    it(\"tells the DashboardEventStream to ignore the local server URL\", async () => {\n      const testEventBus = new TestEventBus()\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n          this.server[\"incomingEvents\"] = testEventBus\n        }\n\n        printHeader() {}\n        async action({ garden }: CommandParams) {\n          garden.events.emit(\"_test\", \"nope\")\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", projectRootA]\n\n      await cli.run({ args, exitOnError: false })\n\n      expect(testEventBus.eventLog).to.eql([])\n    })\n\n    it(\"shows the URL of local server if no external dashboard is found\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        isPersistent() {\n          return true\n        }\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action() {\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", projectRootA]\n\n      await cli.run({ args, exitOnError: false })\n\n      const serverStatus = cmd.server![\"statusLog\"].getLatestMessage().msg!\n      expect(stripAnsi(serverStatus)).to.equal(`Garden dashboard running at ${cmd.server!.getUrl()}`)\n    })\n\n    it(\"shows the URL of an external dashboard if applicable, instead of the built-in server URL\", async () => {\n      // Spin up test server and register.\n      // Note: We're using test-project-a and the default env+namespace both here and in the CLI run\n      const serverGarden = await makeTestGardenA()\n      const serverEventBus = new TestEventBus()\n      const server = new GardenServer({ log: serverGarden.log })\n      server[\"incomingEvents\"] = serverEventBus\n      await server.start()\n      server.setGarden(serverGarden)\n\n      const record = await GardenProcess.register([\"dashboard\"])\n      await record.setCommand({\n        command: \"dashboard\",\n        sessionId: serverGarden.sessionId,\n        persistent: true,\n        serverHost: server.getBaseUrl(),\n        serverAuthKey: server.authKey,\n        projectRoot: serverGarden.projectRoot,\n        projectName: serverGarden.projectName,\n        environmentName: serverGarden.environmentName,\n        namespace: serverGarden.namespace,\n      })\n\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n\n        isPersistent() {\n          return true\n        }\n\n        async prepare({ footerLog }: PrepareParams) {\n          this.server = await startServer({ log: footerLog })\n        }\n\n        printHeader() {}\n        async action({}: CommandParams) {\n          return { result: {} }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const args = [\"test-command\", \"--root\", serverGarden.projectRoot]\n\n      try {\n        await cli.run({ args, exitOnError: false })\n      } finally {\n        await record.remove()\n        await server.close()\n      }\n\n      const serverStatus = cmd.server![\"statusLog\"].getLatestMessage().msg!\n      expect(stripAnsi(serverStatus)).to.equal(`Garden dashboard running at ${server.getUrl()}`)\n    })\n\n    it(\"picks and runs a subcommand in a group\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({}) {\n          return { result: { something: \"important\" } }\n        }\n      }\n      class TestGroup extends CommandGroup {\n        name = \"test-group\"\n        help = \"\"\n\n        subCommands = [TestCommand]\n      }\n      const group = new TestGroup()\n\n      for (const cmd of group.getSubCommands()) {\n        cli.addCommand(cmd)\n      }\n\n      const { code, result } = await cli.run({ args: [\"test-group\", \"test-command\"], exitOnError: false })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({ something: \"important\" })\n    })\n\n    it(\"correctly parses and passes global options\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const _args = [\n        \"test-command\",\n        \"--root\",\n        \"..\",\n        \"--silent\",\n        \"--env=default\",\n        \"--logger-type\",\n        \"basic\",\n        \"-l=4\",\n        \"--output\",\n        \"json\",\n        \"--yes\",\n        \"--emoji=false\",\n        \"--show-timestamps=false\",\n        \"--force-refresh\",\n        \"--var\",\n        \"my=value,other=something\",\n        \"--disable-port-forwards\",\n      ]\n\n      const { code, result } = await cli.run({\n        args: _args,\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: { \"$all\": _args.slice(1), \"--\": [] },\n        opts: {\n          \"root\": resolve(process.cwd(), \"..\"),\n          \"silent\": true,\n          \"env\": \"default\",\n          \"logger-type\": \"basic\",\n          \"log-level\": \"4\",\n          \"output\": \"json\",\n          \"emoji\": false,\n          \"show-timestamps\": false,\n          \"yes\": true,\n          \"force-refresh\": true,\n          \"var\": [\"my=value\", \"other=something\"],\n          \"version\": false,\n          \"help\": false,\n          \"disable-port-forwards\": true,\n        },\n      })\n    })\n\n    it(\"allows setting env through GARDEN_ENVIRONMENT env variable\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const saveEnv = gardenEnv.GARDEN_ENVIRONMENT\n\n      try {\n        gardenEnv.GARDEN_ENVIRONMENT = \"foo\"\n\n        const { code, result } = await cli.run({\n          args: [\"test-command\"],\n          exitOnError: false,\n        })\n\n        expect(code).to.equal(0)\n        expect(result.opts.env).to.equal(\"foo\")\n      } finally {\n        gardenEnv.GARDEN_ENVIRONMENT = saveEnv\n      }\n    })\n\n    it(\"prefers --env over GARDEN_ENVIRONMENT env variable\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const saveEnv = gardenEnv.GARDEN_ENVIRONMENT\n\n      try {\n        gardenEnv.GARDEN_ENVIRONMENT = \"bar\"\n\n        const { code, result } = await cli.run({\n          args: [\"test-command\", \"--env\", \"foo\"],\n          exitOnError: false,\n        })\n\n        expect(code).to.equal(0)\n        expect(result.opts.env).to.equal(\"foo\")\n      } finally {\n        gardenEnv.GARDEN_ENVIRONMENT = saveEnv\n      }\n    })\n\n    it(\"correctly parses and passes arguments and options for a command\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n          bar: new StringParameter({\n            help: \"Another help text.\",\n          }),\n        }\n\n        options = {\n          floop: new StringParameter({\n            help: \"Option help text.\",\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, result } = await cli.run({\n        args: [\"test-command\", \"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\", \"--\", \"extra\"],\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: {\n          \"$all\": [\"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\", \"--\", \"extra\"],\n          \"--\": [\"extra\"],\n          \"foo\": \"foo-arg\",\n          \"bar\": \"bar-arg\",\n        },\n        opts: {\n          \"silent\": false,\n          \"log-level\": \"info\",\n          \"emoji\": envSupportsEmoji(),\n          \"show-timestamps\": false,\n          \"yes\": false,\n          \"force-refresh\": false,\n          \"version\": false,\n          \"help\": false,\n          \"floop\": \"floop-opt\",\n          \"disable-port-forwards\": false,\n        },\n      })\n    })\n\n    it(\"correctly parses and passes arguments and options for a subcommand\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n          bar: new StringParameter({\n            help: \"Another help text.\",\n          }),\n        }\n\n        options = {\n          floop: new StringParameter({\n            help: \"Option help text.\",\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n\n      class TestGroup extends CommandGroup {\n        name = \"test-group\"\n        help = \"\"\n\n        subCommands = [TestCommand]\n      }\n      const group = new TestGroup()\n\n      for (const cmd of group.getSubCommands()) {\n        cli.addCommand(cmd)\n      }\n\n      const { code, result } = await cli.run({\n        args: [\"test-group\", \"test-command\", \"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\"],\n        exitOnError: false,\n      })\n\n      expect(code).to.equal(0)\n      expect(result).to.eql({\n        args: {\n          \"$all\": [\"foo-arg\", \"bar-arg\", \"--floop\", \"floop-opt\"],\n          \"--\": [],\n          \"foo\": \"foo-arg\",\n          \"bar\": \"bar-arg\",\n        },\n        opts: {\n          \"silent\": false,\n          \"log-level\": \"info\",\n          \"emoji\": envSupportsEmoji(),\n          \"show-timestamps\": false,\n          \"yes\": false,\n          \"force-refresh\": false,\n          \"version\": false,\n          \"help\": false,\n          \"floop\": \"floop-opt\",\n          \"disable-port-forwards\": false,\n        },\n      })\n    })\n\n    it(\"aborts with usage information on invalid global options\", async () => {\n      const cmd = new ToolsCommand()\n      const { code, consoleOutput } = await cli.run({ args: [\"tools\", \"--logger-type\", \"bla\"], exitOnError: false })\n\n      const stripped = stripAnsi(consoleOutput!).trim()\n\n      expect(code).to.equal(1)\n      expect(\n        stripped.startsWith(\n          'Invalid value for option --logger-type: \"bla\" is not a valid argument (should be any of \"quiet\", \"basic\", \"fancy\", \"json\")'\n        )\n      ).to.be.true\n      expect(consoleOutput).to.include(cmd.renderHelp())\n    })\n\n    it(\"aborts with usage information on missing/invalid command arguments and options\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        alias = \"some-alias\"\n        help = \"\"\n        noProject = true\n\n        arguments = {\n          foo: new StringParameter({\n            help: \"Some help text.\",\n            required: true,\n          }),\n        }\n\n        printHeader() {}\n        async action({ args, opts }) {\n          return { result: { args, opts } }\n        }\n      }\n      const cmd = new TestCommand()\n      cli.addCommand(cmd)\n\n      const { code, consoleOutput } = await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n      const stripped = stripAnsi(consoleOutput!).trim()\n\n      expect(code).to.equal(1)\n      expect(stripped.startsWith(\"Missing required argument foo\")).to.be.true\n      expect(consoleOutput).to.include(cmd.renderHelp())\n    })\n\n    it(\"should pass array of all arguments to commands as $all\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--\", \"-v\", \"--flag\", \"arg\"], exitOnError: false })\n      expect(result.args.$all).to.eql([\"--\", \"-v\", \"--flag\", \"arg\"])\n    })\n\n    it(\"should not parse args after -- and instead pass directly to commands\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ args }) {\n          return { result: { args } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--\", \"-v\", \"--flag\", \"arg\"], exitOnError: false })\n      expect(result.args[\"--\"]).to.eql([\"-v\", \"--flag\", \"arg\"])\n    })\n\n    it(\"should correctly parse --var flag\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command-var\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { variables: garden.variables } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({\n        args: [\"test-command-var\", \"--var\", 'key-a=value-a,key-b=\"value with quotes\"'],\n        exitOnError: false,\n      })\n      expect(result).to.eql({ variables: { \"key-a\": \"value-a\", \"key-b\": \"value with quotes\" } })\n    })\n\n    it(\"should output JSON if --output=json\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action() {\n          return { result: { some: \"output\" } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { consoleOutput } = await cli.run({ args: [\"test-command\", \"--output=json\"], exitOnError: false })\n      expect(JSON.parse(consoleOutput!)).to.eql({ result: { some: \"output\" }, success: true })\n    })\n\n    it(\"should output YAML if --output=json\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action() {\n          return { result: { some: \"output\" } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { consoleOutput } = await cli.run({ args: [\"test-command\", \"--output=yaml\"], exitOnError: false })\n      expect(safeLoad(consoleOutput!)).to.eql({ result: { some: \"output\" }, success: true })\n    })\n\n    it(\"should disable port forwards if --disable-port-forwards is set\", async () => {\n      class TestCommand extends Command {\n        name = \"test-command\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n\n        async action({ garden }: CommandParams) {\n          return { result: { garden } }\n        }\n      }\n\n      const command = new TestCommand()\n      cli.addCommand(command)\n\n      const { result } = await cli.run({ args: [\"test-command\", \"--disable-port-forwards\"], exitOnError: false })\n      expect(result.garden.disablePortForwards).to.be.true\n    })\n\n    it(`should configure a dummy environment when command has noProject=true and --env is specified`, async () => {\n      class TestCommand2 extends Command {\n        name = \"test-command-2\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { environmentName: garden.environmentName } }\n        }\n      }\n\n      const command = new TestCommand2()\n      cli.addCommand(command)\n\n      const { result, errors } = await cli.run({ args: [\"test-command-2\", \"--env\", \"missing-env\"], exitOnError: false })\n      expect(errors).to.eql([])\n      expect(result).to.eql({ environmentName: \"missing-env\" })\n    })\n\n    it(\"should error if an invalid --env parameter is passed\", async () => {\n      class TestCommand3 extends Command {\n        name = \"test-command-3\"\n        help = \"halp!\"\n        noProject = true\n\n        printHeader() {}\n        async action({ garden }) {\n          return { result: { environmentName: garden.environmentName } }\n        }\n      }\n\n      const command = new TestCommand3()\n      cli.addCommand(command)\n\n      const { errors } = await cli.run({ args: [\"test-command-3\", \"--env\", \"$.%\"], exitOnError: false })\n\n      expect(errors.length).to.equal(1)\n      expect(stripAnsi(errors[0].message)).to.equal(\n        \"Invalid value for option --env: Invalid environment specified ($.%): must be a valid environment name or <namespace>.<environment>\"\n      )\n    })\n\n    context(\"test analytics\", () => {\n      const host = \"https://api.segment.io\"\n      const scope = nock(host)\n      let garden: TestGarden\n      let resetAnalyticsConfig: Function\n\n      before(async () => {\n        garden = await makeTestGardenA()\n        resetAnalyticsConfig = await enableAnalytics(garden)\n      })\n\n      after(async () => {\n        await resetAnalyticsConfig()\n        nock.cleanAll()\n      })\n\n      it(\"should wait for queued analytic events to flush\", async () => {\n        class TestCommand extends Command {\n          name = \"test-command\"\n          help = \"hilfe!\"\n          noProject = true\n\n          printHeader() {}\n          async action({ args }) {\n            return { result: { args } }\n          }\n        }\n\n        const command = new TestCommand()\n        cli.addCommand(command)\n\n        scope\n          .post(`/v1/batch`, (body) => {\n            const events = body.batch.map((event: any) => ({\n              event: event.event,\n              type: event.type,\n              name: event.properties.name,\n            }))\n            return isEqual(events, [\n              {\n                event: \"Run Command\",\n                type: \"track\",\n                name: \"test-command\",\n              },\n            ])\n          })\n          .reply(200)\n        await cli.run({ args: [\"test-command\"], exitOnError: false })\n\n        expect(scope.done()).to.not.throw\n      })\n    })\n  })\n\n  describe(\"makeDummyGarden\", () => {\n    it(\"should initialise and resolve config graph in a directory with no project\", async () => {\n      const garden = await makeDummyGarden(join(GARDEN_CORE_ROOT, \"tmp\", \"foobarbas\"), {\n        commandInfo: { name: \"foo\", args: {}, opts: {} },\n      })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n\n    it(\"should correctly configure a dummy environment when a namespace is set\", async () => {\n      const garden = await makeDummyGarden(join(GARDEN_CORE_ROOT, \"tmp\", \"foobarbas\"), {\n        environmentName: \"test.foo\",\n        commandInfo: { name: \"foo\", args: {}, opts: {} },\n      })\n      expect(garden).to.be.ok\n      expect(garden.environmentName).to.equal(\"foo\")\n    })\n\n    it(\"should initialise and resolve config graph in a project with invalid config\", async () => {\n      const root = getDataDir(\"test-project-invalid-config\")\n      const garden = await makeDummyGarden(root, { commandInfo: { name: \"foo\", args: {}, opts: {} } })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n\n    it(\"should initialise and resolve config graph in a project with template strings\", async () => {\n      const root = getDataDir(\"test-project-templated\")\n      const garden = await makeDummyGarden(root, { commandInfo: { name: \"foo\", args: {}, opts: {} } })\n      const dg = await garden.getConfigGraph({ log: garden.log, emit: false })\n      expect(garden).to.be.ok\n      expect(dg.getModules()).to.not.throw\n    })\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { expect } from \"chai\"\nimport { makeTestGardenA, TestEventBus, TestGarden } from \"../../../helpers\"\nimport { GardenServer } from \"../../../../src/server/server\"\nimport { DashboardEventStream } from \"../../../../src/server/dashboard-event-stream\"\nimport { GardenProcess } from \"../../../../src/db/entities/garden-process\"\nimport { randomString } from \"../../../../src/util/string\"\nimport { ensureConnected, getConnection } from \"../../../../src/db/connection\"\nimport pEvent from \"p-event\"\n\ndescribe(\"DashboardEventStream\", () => {\n  let streamer: DashboardEventStream\n  let garden: TestGarden\n\n  const testArg = \"test-\" + randomString(10)\n\n  before(async () => {\n    await ensureConnected()\n  })\n\n  beforeEach(async () => {\n    garden = await makeTestGardenA()\n  })\n\n  afterEach(async () => {\n    // Clean up test records\n    await getConnection()\n      .getRepository(GardenProcess)\n      .createQueryBuilder()\n      .delete()\n      .where(`arguments = :arg`, { arg: testArg })\n      .execute()\n\n    await streamer?.close()\n  })\n\n  after(async () => {\n    await garden?.close()\n  })\n\n  it(\"posts events to the configured target hosts\", async () => {\n    const serverEventBusA = new TestEventBus()\n    const serverEventBusB = new TestEventBus()\n\n    const serverA = new GardenServer({ log: garden.log })\n    const serverB = new GardenServer({ log: garden.log })\n\n    serverA[\"incomingEvents\"] = serverEventBusA\n    serverB[\"incomingEvents\"] = serverEventBusB\n\n    await serverA.start()\n    await serverB.start()\n\n    serverA.setGarden(garden)\n    serverB.setGarden(garden)\n\n    streamer = new DashboardEventStream({\n      log: garden.log,\n      sessionId: garden.sessionId!,\n    })\n    streamer.connect({\n      garden,\n      streamEvents: true,\n      streamLogEntries: true,\n      targets: [\n        { host: serverA.getBaseUrl(), clientAuthToken: serverA.authKey, enterprise: false },\n        { host: serverB.getBaseUrl(), clientAuthToken: serverB.authKey, enterprise: false },\n      ],\n    })\n\n    garden.events.emit(\"_test\", \"foo\")\n\n    // Make sure events are flushed\n    await streamer.close()\n\n    expect(serverEventBusA.eventLog).to.eql([{ name: \"_test\", payload: \"foo\" }])\n    expect(serverEventBusB.eventLog).to.eql([{ name: \"_test\", payload: \"foo\" }])\n  })\n\n  describe(\"updateTargets\", () => {\n    it(\"updates and returns the current list of active servers\", async () => {\n      // Correctly matched\n      const recordA = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n      await recordA.setCommand(values)\n\n      // Inactive\n      const recordB = await GardenProcess.register([testArg])\n      recordB.pid = 9999999\n      await recordB.setCommand(values)\n\n      // Different namespace\n      const recordC = await GardenProcess.register([testArg])\n      await recordC.setCommand({\n        ...values,\n        namespace: \"foo\",\n      })\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      const processes = await streamer.updateTargets()\n\n      expect(processes.length).to.equal(1)\n      expect(processes[0]._id).to.equal(recordA._id)\n    })\n\n    it(\"emits a serversUpdated event when a server is removed\", async () => {\n      // Correctly matched\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n      await record.setCommand(values)\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      await streamer.updateTargets()\n      await record.remove()\n      await streamer.updateTargets()\n\n      garden.events.expectEvent(\"serversUpdated\", { servers: [] })\n    })\n\n    it(\"emits a serversUpdated event when a server is added\", async () => {\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        streamEvents: true,\n        streamLogEntries: true,\n        targets: [],\n      })\n\n      await streamer.updateTargets()\n      await record.setCommand(values)\n      await streamer.updateTargets()\n\n      garden.events.expectEvent(\"serversUpdated\", {\n        servers: [{ host: values.serverHost, command: \"dashboard\", serverAuthKey: \"foo\" }],\n      })\n    })\n\n    it(\"ignores servers matching ignoreHost\", async () => {\n      const record = await GardenProcess.register([testArg])\n      const values = {\n        command: \"dashboard\",\n        sessionId: garden.sessionId,\n        persistent: true,\n        serverHost: \"http://localhost:123456\",\n        serverAuthKey: \"foo\",\n        projectRoot: garden.projectRoot,\n        projectName: garden.projectName,\n        environmentName: garden.environmentName,\n        namespace: garden.namespace,\n      }\n\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      streamer.connect({\n        garden,\n        targets: [],\n        streamEvents: true,\n        streamLogEntries: true,\n        ignoreHost: values.serverHost,\n      })\n\n      await record.setCommand(values)\n      const processes = await streamer.updateTargets()\n\n      expect(processes.length).to.equal(0)\n    })\n\n    it(\"returns an empty list when no Garden instance is connected\", async () => {\n      streamer = new DashboardEventStream({\n        log: garden.log,\n        sessionId: garden.sessionId!,\n      })\n      const processes = await streamer.updateTargets()\n      expect(processes).to.eql([])\n    })\n  })\n\n  it(\"polls to update the list of target hosts\", async () => {\n    // Start with no targets and initiate polling\n    streamer = new DashboardEventStream({\n      log: garden.log,\n      sessionId: garden.sessionId!,\n    })\n    streamer.connect({\n      garden,\n      streamEvents: true,\n      streamLogEntries: true,\n      targets: [],\n    })\n\n    // Create a new process record\n    const record = await GardenProcess.register([testArg])\n    await record.setCommand({\n      command: \"dashboard\",\n      sessionId: garden.sessionId,\n      persistent: true,\n      serverHost: \"http://localhost:123456\",\n      serverAuthKey: \"foo\",\n      projectRoot: garden.projectRoot,\n      projectName: garden.projectName,\n      environmentName: garden.environmentName,\n      namespace: garden.namespace,\n    })\n\n    // Wait for it to come up\n    await pEvent(garden.events, \"serversUpdated\", { timeout: 5000 })\n  })\n\n  it.skip(\"removes target hosts that are unreachable\", async () => {\n    // TODO: let's see if we need this on top of the polling\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { makeTestGardenA, taskResultOutputs } from \"../../../helpers\"\nimport { Server } from \"http\"\nimport { startServer, GardenServer } from \"../../../../src/server/server\"\nimport { Garden } from \"../../../../src/garden\"\nimport { expect } from \"chai\"\nimport { deepOmitUndefined, uuidv4, sleep } from \"../../../../src/util/util\"\nimport request = require(\"supertest\")\nimport getPort = require(\"get-port\")\nimport WebSocket = require(\"ws\")\nimport stripAnsi = require(\"strip-ansi\")\nimport { authTokenHeader } from \"../../../../src/cloud/api\"\n\ndescribe(\"GardenServer\", () => {\n  let garden: Garden\n  let gardenServer: GardenServer\n  let server: Server\n  let port: number\n\n  before(async () => {\n    port = await getPort()\n    garden = await makeTestGardenA()\n    gardenServer = await startServer({ log: garden.log, port })\n    server = (<any>gardenServer).server\n  })\n\n  after(async () => {\n    server.close()\n  })\n\n  beforeEach(() => {\n    gardenServer.setGarden(garden)\n  })\n\n  it(\"should show no URL on startup\", async () => {\n    const line = gardenServer[\"statusLog\"]\n    expect(line.getLatestMessage().msg).to.be.undefined\n  })\n\n  it(\"should update dashboard URL with own if the external dashboard goes down\", async () => {\n    gardenServer.showUrl(\"http://foo\")\n    garden.events.emit(\"serversUpdated\", {\n      servers: [],\n    })\n    const line = gardenServer[\"statusLog\"]\n    await sleep(1) // This is enough to let go of the control loop\n    const status = stripAnsi(line.getLatestMessage().msg || \"\")\n    expect(status).to.equal(`Garden dashboard running at ${gardenServer.getUrl()}`)\n  })\n\n  it(\"should update dashboard URL with new one if another is started\", async () => {\n    gardenServer.showUrl(\"http://foo\")\n    garden.events.emit(\"serversUpdated\", {\n      servers: [{ host: \"http://localhost:9800\", command: \"dashboard\", serverAuthKey: \"foo\" }],\n    })\n    const line = gardenServer[\"statusLog\"]\n    await sleep(1) // This is enough to let go of the control loop\n    const status = stripAnsi(line.getLatestMessage().msg || \"\")\n    expect(status).to.equal(`Garden dashboard running at http://localhost:9800?key=foo`)\n  })\n\n  describe(\"GET /\", () => {\n    it(\"should return the dashboard index page\", async () => {\n      await request(server)\n        .get(\"/\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .expect(200)\n    })\n  })\n\n  describe(\"POST /api\", () => {\n    it(\"returns 401 if missing auth header\", async () => {\n      await request(server).post(\"/api\").send({}).expect(401)\n    })\n\n    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n      await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: \"foo\" })\n        .send({})\n        .expect(401)\n    })\n\n    it(\"should 400 on non-JSON body\", async () => {\n      await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send(\"foo\")\n        .expect(400)\n    })\n\n    it(\"should 400 on invalid payload\", async () => {\n      await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({ foo: \"bar\" })\n        .expect(400)\n    })\n\n    it(\"should 404 on invalid command\", async () => {\n      await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({ command: \"foo\" })\n        .expect(404)\n    })\n\n    it(\"should 503 when Garden instance is not set\", async () => {\n      gardenServer[\"garden\"] = undefined\n      await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({ command: \"get.config\" })\n        .expect(503)\n    })\n\n    it(\"should execute a command and return its results\", async () => {\n      const res = await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({ command: \"get.config\" })\n        .expect(200)\n      const config = await garden.dumpConfig({ log: garden.log })\n      expect(res.body.result).to.eql(deepOmitUndefined(config))\n    })\n\n    it(\"should correctly map arguments and options to commands\", async () => {\n      const res = await request(server)\n        .post(\"/api\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({\n          command: \"build\",\n          parameters: {\n            modules: [\"module-a\"],\n            force: true,\n          },\n        })\n        .expect(200)\n\n      expect(taskResultOutputs(res.body.result)).to.eql({\n        \"build.module-a\": {\n          buildLog: \"A\",\n          fresh: true,\n        },\n        \"stage-build.module-a\": {},\n      })\n    })\n  })\n\n  describe(\"/dashboardPages\", () => {\n    it(\"returns 401 if missing auth header\", async () => {\n      await request(server).get(\"/dashboardPages/test-plugin/test\").expect(401)\n    })\n\n    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n      await request(server)\n        .get(\"/dashboardPages/test-plugin/test\")\n        .set({ [authTokenHeader]: \"foo\" })\n        .send({})\n        .expect(401)\n    })\n\n    it(\"should resolve the URL for the given dashboard page and redirect\", async () => {\n      const res = await request(server)\n        .get(\"/dashboardPages/test-plugin/test\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .expect(302)\n\n      expect(res.header.location).to.equal(\"http://localhost:12345/test\")\n    })\n  })\n\n  describe(\"/events\", () => {\n    it(\"returns 401 if missing auth header\", async () => {\n      await request(server).post(\"/events\").send({}).expect(401)\n    })\n\n    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n      await request(server)\n        .post(\"/events\")\n        .set({ [authTokenHeader]: \"foo\" })\n        .send({})\n        .expect(401)\n    })\n\n    it(\"posts events on the incoming event bus\", (done) => {\n      let passed = false\n\n      gardenServer[\"incomingEvents\"].on(\"_test\", () => {\n        !passed && done()\n        passed = true\n      })\n\n      request(server)\n        .post(\"/events\")\n        .set({ [authTokenHeader]: gardenServer.authKey })\n        .send({\n          events: [{ name: \"_test\", payload: { some: \"value\" } }],\n        })\n        .expect(200)\n        .catch(done)\n    })\n  })\n\n  describe(\"/ws\", () => {\n    let ws: WebSocket\n\n    beforeEach((done) => {\n      ws = new WebSocket(`ws://localhost:${port}/ws?sessionId=${garden.sessionId}`)\n      ws.on(\"open\", () => {\n        done()\n      })\n      ws.on(\"error\", done)\n    })\n\n    afterEach(() => {\n      ws.close()\n    })\n\n    const onMessage = (cb: (req: object) => void) => {\n      ws.on(\"message\", (msg) => cb(JSON.parse(msg.toString())))\n    }\n\n    it(\"terminates the connection if auth query params are missing\", (done) => {\n      const badWs = new WebSocket(`ws://localhost:${port}/ws`)\n      badWs.on(\"close\", () => {\n        done()\n      })\n    })\n\n    it(\"terminates the connection if key doesn't match and sessionId is missing\", (done) => {\n      const badWs = new WebSocket(`ws://localhost:${port}/ws?key=foo`)\n      badWs.on(\"close\", () => {\n        done()\n      })\n    })\n\n    it(\"terminates the connection if sessionId doesn't match and key is missing\", (done) => {\n      const badWs = new WebSocket(`ws://localhost:${port}/ws?sessionId=foo`)\n      badWs.on(\"close\", () => {\n        done()\n      })\n    })\n\n    it(\"terminates the connection if both sessionId and key are bad\", (done) => {\n      const badWs = new WebSocket(`ws://localhost:${port}/ws?sessionId=foo&key=bar`)\n      badWs.on(\"close\", () => {\n        done()\n      })\n    })\n\n    it(\"should emit events from the Garden event bus\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({ type: \"event\", name: \"_test\", payload: \"foo\" })\n        done()\n      })\n      garden.events.emit(\"_test\", \"foo\")\n    })\n\n    it(\"should emit events from the incoming event bus\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({ type: \"event\", name: \"_test\", payload: \"foo\" })\n        done()\n      })\n      gardenServer[\"incomingEvents\"].emit(\"_test\", \"foo\")\n    })\n\n    it(\"should send error when a request is not valid JSON\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Could not parse message as JSON\",\n        })\n        done()\n      })\n      ws.send(\"ijdgkasdghlasdkghals\")\n    })\n\n    it(\"should send error when Garden instance is not set\", (done) => {\n      const id = uuidv4()\n\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Waiting for Garden instance to initialize\",\n          requestId: id,\n        })\n        done()\n      })\n\n      gardenServer[\"garden\"] = undefined\n\n      ws.send(\n        JSON.stringify({\n          type: \"command\",\n          id,\n          command: \"get.config\",\n        })\n      )\n    })\n\n    it(\"should error when a request is missing an ID\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          message: \"Message should contain an `id` field with a UUID value\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"command\" }))\n    })\n\n    it(\"should error when a request has an invalid ID\", (done) => {\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          requestId: \"ksdhgalsdkjghalsjkg\",\n          message: \"Message should contain an `id` field with a UUID value\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"command\", id: \"ksdhgalsdkjghalsjkg\" }))\n    })\n\n    it(\"should error when a request has an invalid type\", (done) => {\n      const id = uuidv4()\n      onMessage((req) => {\n        expect(req).to.eql({\n          type: \"error\",\n          requestId: id,\n          message: \"Unsupported request type: foo\",\n        })\n        done()\n      })\n      ws.send(JSON.stringify({ type: \"foo\", id }))\n    })\n\n    it(\"should execute a command and return its results\", (done) => {\n      const id = uuidv4()\n\n      garden\n        .dumpConfig({ log: garden.log })\n        .then((config) => {\n          onMessage((req: any) => {\n            if (req.type !== \"commandResult\") {\n              return\n            }\n\n            expect(req).to.eql({\n              type: \"commandResult\",\n              requestId: id,\n              result: deepOmitUndefined(config),\n            })\n            done()\n          })\n          ws.send(\n            JSON.stringify({\n              type: \"command\",\n              id,\n              command: \"get.config\",\n            })\n          )\n        })\n        .catch(done)\n    })\n\n    it(\"should correctly map arguments and options to commands\", (done) => {\n      const id = uuidv4()\n      onMessage((req) => {\n        // Ignore other events such as taskPending and taskProcessing and wait for the command result\n        if ((<any>req).type !== \"commandResult\") {\n          return\n        }\n        const taskResult = taskResultOutputs((<any>req).result)\n        const result = {\n          ...req,\n          result: taskResult,\n        }\n        expect(result).to.eql({\n          type: \"commandResult\",\n          requestId: id,\n          result: {\n            \"build.module-a\": {\n              buildLog: \"A\",\n              fresh: true,\n            },\n            \"stage-build.module-a\": {},\n          },\n        })\n        done()\n      })\n      ws.send(\n        JSON.stringify({\n          type: \"command\",\n          id,\n          command: \"build\",\n          parameters: {\n            modules: [\"module-a\"],\n            force: true,\n          },\n        })\n      )\n    })\n  })\n})\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport produce from \"immer\"\nimport { groupBy, keyBy } from \"lodash\"\n\nimport { ServiceLogEntry } from \"@garden-io/core/build/src/types/plugin/service/getServiceLogs\"\nimport { StatusCommandResult } from \"@garden-io/core/build/src/commands/get/get-status\"\nimport { GetTaskResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-task-result\"\nimport { ConfigDump } from \"@garden-io/core/build/src/garden\"\nimport { GetTestResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-test-result\"\nimport { GraphOutput } from \"@garden-io/core/build/src/commands/get/get-graph\"\nimport {\n  Entities,\n  ModuleEntity,\n  ServiceEntity,\n  TaskEntity,\n  TestEntity,\n  ApiDispatch,\n  defaultTaskState,\n  defaultServiceStatus,\n  defaultRunStatus,\n} from \"../contexts/api\"\nimport {\n  fetchLogs,\n  fetchStatus,\n  fetchTaskResult,\n  fetchConfig,\n  fetchTestResult,\n  fetchGraph,\n  FetchTaskResultParams,\n  FetchTestResultParams,\n} from \"./api\"\nimport { getAuthKey, getTestKey } from \"../util/helpers\"\nimport { ProviderMap } from \"@garden-io/core/build/src/config/provider\"\nimport { DashboardPage } from \"@garden-io/core/build/src/types/plugin/provider/getDashboardPage\"\n\n// This file contains the API action functions.\n// The actions are responsible for dispatching the appropriate action types and normalising the\n// API response.\n\n// Section: Helpers\n\n/**\n * Returns service status if set, otherwise default service status.\n */\nfunction getServiceStatus(service?: ServiceEntity) {\n  return service ? service.status : defaultServiceStatus || defaultServiceStatus\n}\n\n/**\n * Returns task state if set, otherwise default task state.\n */\nfunction getTaskState(entity?: ServiceEntity | ModuleEntity | TestEntity | TaskEntity) {\n  return entity ? entity.taskState : defaultTaskState || defaultTaskState\n}\n\n/**\n * Returns run status if set, otherwise default run status.\n */\nfunction getRunStatus(entity?: TaskEntity | TestEntity) {\n  return entity ? entity.status : defaultRunStatus || defaultRunStatus\n}\n\n// Section: Init actions and process handlers\n\n/**\n * Fetch the init data for the API store.\n *\n * This action is called first and hydrates the initial app state.\n */\nexport async function initApiStore(dispatch: ApiDispatch) {\n  await Promise.all([loadConfig(dispatch), loadStatus(dispatch)])\n}\n\nasync function loadConfig(dispatch: ApiDispatch) {\n  const requestKey = \"config\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n  let res: ConfigDump\n\n  try {\n    res = await fetchConfig()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processConfigInitResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\n/**\n * Invariant: The fetchConfig and fetchStatus calls fire concurrently on app initialisation\n * so that we get a faster initial render. Therefore the process functions need to account for\n * the store not having been initialised.\n *\n * Other process handlers can assume that the store has been initialised.\n */\nfunction processConfigInitResult(entities: Entities, config: ConfigDump) {\n  return produce(entities, (draft) => {\n    draft.providers = keyBy(config.providers, \"name\") as ProviderMap\n    draft.providerPages = config.providers.flatMap((provider) => {\n      return (provider.dashboardPages || []).map((page: DashboardPage) => ({\n        ...page,\n        providerName: provider.name,\n        path: `/provider/${provider.name}/${page.name}`,\n        description: page.description + ` (from provider ${provider.name})`,\n        // Use static URL if provided, otherwise we'll request a redirect from this API endpoint\n        url: page.url || `/dashboardPages/${provider.name}/${page.name}?key=${getAuthKey()}`,\n      }))\n    })\n\n    for (const cfg of config.moduleConfigs) {\n      const module: ModuleEntity = {\n        name: cfg.name,\n        type: cfg.type,\n        path: cfg.path,\n        disabled: cfg.disabled,\n        repositoryUrl: cfg.repositoryUrl,\n        description: cfg.description,\n        services: cfg.serviceConfigs.map((service) => service.name),\n        tests: cfg.testConfigs.map((test) => `${cfg.name}.${test.name}`),\n        tasks: cfg.taskConfigs.map((task) => task.name),\n        taskState: \"taskComplete\",\n      }\n      draft.modules[cfg.name] = module\n\n      const moduleDisabled = module.disabled\n      for (const serviceConfig of cfg.serviceConfigs) {\n        const service = entities.services[serviceConfig.name]\n        draft.services[serviceConfig.name] = {\n          taskState: getTaskState(service),\n          status: getServiceStatus(service),\n          config: {\n            ...serviceConfig,\n            moduleDisabled,\n          },\n        }\n      }\n      for (const testConfig of cfg.testConfigs) {\n        const testKey = getTestKey({ testName: testConfig.name, moduleName: cfg.name })\n        const test = entities.tests[testKey]\n        draft.tests[testKey] = {\n          taskState: getTaskState(test),\n          status: getRunStatus(test),\n          result: null,\n          config: {\n            ...testConfig,\n            moduleDisabled,\n          },\n        }\n      }\n      for (const taskConfig of cfg.taskConfigs) {\n        const task = entities.tasks[taskConfig.name]\n        draft.tasks[taskConfig.name] = {\n          taskState: getTaskState(task),\n          status: getRunStatus(task),\n          result: null,\n          config: {\n            ...taskConfig,\n            moduleDisabled,\n          },\n        }\n      }\n    }\n  })\n}\n\nexport async function loadStatus(dispatch: ApiDispatch) {\n  const requestKey = \"status\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: StatusCommandResult\n  try {\n    res = await fetchStatus()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processStatusInitResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\n/**\n * Invariant: The fetchConfig and fetchStatus calls fire concurrently on app initialisation\n * so that we get a faster initial render. Therefore the process functions need to account for\n * the store not having been initialised.\n *\n * Other process handlers can assume that the store has been initialised.\n */\nfunction processStatusInitResult(entities: Entities, status: StatusCommandResult) {\n  return produce(entities, (draft) => {\n    for (const serviceName of Object.keys(status.services)) {\n      draft.services[serviceName] = entities.services[serviceName] || {}\n      draft.services[serviceName].status = status.services[serviceName]\n    }\n    for (const [taskName, taskStatus] of Object.entries(status.tasks || {})) {\n      draft.tasks[taskName] = entities.tasks[taskName] || {}\n      draft.tasks[taskName].status = taskStatus\n    }\n    for (const [testName, testStatus] of Object.entries(status.tests || {})) {\n      draft.tests[testName] = entities.tests[testName] || {}\n      draft.tests[testName].status = testStatus\n    }\n    draft.environmentStatuses = status.providers\n  })\n}\n\n// Section: Actions and process handlers\n\nexport async function loadLogs(dispatch: ApiDispatch, serviceNames: string[]) {\n  const requestKey = \"logs\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: ServiceLogEntry[]\n  try {\n    res = await fetchLogs({ serviceNames })\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processLogs(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processLogs(entities: Entities, logs: ServiceLogEntry[]) {\n  return produce(entities, (draft) => {\n    draft.logs = groupBy(logs, \"serviceName\")\n  })\n}\n\ninterface LoadTaskResultParams extends FetchTaskResultParams {\n  dispatch: ApiDispatch\n}\n\nexport async function loadTaskResult({ dispatch, ...fetchParams }: LoadTaskResultParams) {\n  const requestKey = \"taskResult\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GetTaskResultCommandResult\n  try {\n    res = await fetchTaskResult(fetchParams)\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processTaskResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processTaskResult(entities: Entities, result: GetTaskResultCommandResult) {\n  return produce(entities, (draft) => {\n    if (result) {\n      draft.tasks[result.taskName].result = result\n    }\n  })\n}\n\ninterface LoadTestResultParams extends FetchTestResultParams {\n  dispatch: ApiDispatch\n}\n\nexport async function loadTestResult({ dispatch, ...fetchParams }: LoadTestResultParams) {\n  const requestKey = \"testResult\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GetTestResultCommandResult\n  try {\n    res = await fetchTestResult(fetchParams)\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processTestResult(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processTestResult(entities: Entities, result: GetTestResultCommandResult) {\n  return produce(entities, (draft) => {\n    if (result) {\n      // Test names are not unique so we store the data under a unique test key\n      const testKey = getTestKey({ testName: result.testName, moduleName: result.moduleName })\n      draft.tests[testKey].result = result\n    }\n  })\n}\n\nexport async function loadGraph(dispatch: ApiDispatch) {\n  const requestKey = \"graph\"\n\n  dispatch({ requestKey, type: \"fetchStart\" })\n\n  let res: GraphOutput\n  try {\n    res = await fetchGraph()\n  } catch (error) {\n    dispatch({ requestKey, type: \"fetchFailure\", error })\n    return\n  }\n\n  const processResults = (entities: Entities) => processGraph(entities, res)\n\n  dispatch({ type: \"fetchSuccess\", requestKey, processResults })\n}\n\nfunction processGraph(entities: Entities, graph: GraphOutput) {\n  return produce(entities, (draft) => {\n    draft.graph = graph\n  })\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport axios from \"axios\"\n\nimport { GraphOutput } from \"@garden-io/core/build/src/commands/get/get-graph\"\nimport { GetTaskResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-task-result\"\nimport { GetTestResultCommandResult } from \"@garden-io/core/build/src/commands/get/get-test-result\"\nimport { ServiceLogEntry } from \"@garden-io/core/build/src/types/plugin/service/getServiceLogs\"\nimport { CommandResult } from \"@garden-io/core/build/src/commands/base\"\nimport { ConfigDump } from \"@garden-io/core/build/src/garden\"\nimport { StatusCommandResult } from \"@garden-io/core/build/src/commands/get/get-status\"\nimport { getAuthKey } from \"../util/helpers\"\n\nexport interface ApiRequest {\n  command: string\n  parameters: {}\n}\n\nconst MAX_LOG_LINES = 5000\n\nexport async function fetchConfig() {\n  return apiCommand<ConfigDump>(\"get.config\")\n}\n\nexport async function fetchGraph() {\n  return apiCommand<GraphOutput>(\"get.graph\")\n}\n\nexport async function fetchStatus() {\n  return apiCommand<StatusCommandResult>(\"get.status\", { output: \"json\" })\n}\n\nexport interface FetchLogsParams {\n  serviceNames: string[]\n}\n\nexport async function fetchLogs({ serviceNames }: FetchLogsParams) {\n  const tail = Math.floor(MAX_LOG_LINES / serviceNames.length)\n  return apiCommand<ServiceLogEntry[]>(\"logs\", { services: serviceNames, tail })\n}\n\nexport interface FetchTaskResultParams {\n  name: string\n}\n\nexport async function fetchTaskResult(params: FetchTaskResultParams) {\n  return apiCommand<GetTaskResultCommandResult>(\"get.task-result\", params)\n}\n\nexport interface FetchTestResultParams {\n  name: string\n  moduleName: string\n}\n\nexport async function fetchTestResult({ name, moduleName }: FetchTestResultParams) {\n  return apiCommand<GetTestResultCommandResult>(\"get.test-result\", { name, module: moduleName })\n}\n\nasync function apiCommand<T>(command: string, parameters: {} = {}): Promise<T> {\n  const url = \"/api\"\n  const method = \"POST\"\n  const headers = { \"Content-Type\": \"application/json\", \"x-access-auth-token\": getAuthKey() }\n\n  const data: ApiRequest = { command, parameters }\n\n  const res = await axios.request<CommandResult<T>>({ url, method, headers, data })\n\n  if (res.data.errors) {\n    throw res.data.errors\n  }\n\n  if (res.data.result === undefined) {\n    throw new Error(\"Empty response from server\")\n  }\n\n  return res.data.result\n}\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { css } from \"emotion\"\nimport styled from \"@emotion/styled\"\nimport React from \"react\"\nimport { NavLink as ReactRouterNavLink, NavLinkProps as ReactRouterNavLinkProps } from \"react-router-dom\"\n\nimport logo from \"../assets/logo.png\"\n\nimport { colors } from \"../styles/variables\"\nimport { useUiState } from \"../hooks\"\nimport { Page } from \"../contexts/api\"\nimport { getAuthKey } from \"../util/helpers\"\n\ninterface Props {\n  pages: Page[]\n}\n\nconst Button = styled.div`\n  font-size: 0.84rem;\n  font-weight: 800;\n  text-transform: uppercase;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin-bottom: -12px;\n  &:hover {\n    color: ${colors.gardenGreenDarker};\n  }\n`\n\nconst linkStyle = `\n  margin-left: 1rem;\n  padding: 0.5em 0.5em 0.5em 0;\n`\n\nconst Nav = styled.nav`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n`\n\ntype NavLinkProps = Omit<ReactRouterNavLinkProps, \"to\"> & {\n  to: {\n    pathname: string\n    search?: string\n    hash?: string\n    state?: any\n  }\n}\n\n/**\n * Helper class for ensuring that the auth key param is set on routes.\n */\nconst NavLink = (props: NavLinkProps) => {\n  const urlParams = new URLSearchParams(props.to.search)\n  urlParams.set(\"key\", getAuthKey() || \"\")\n  const to = {\n    ...props.to,\n    search: urlParams.toString(),\n  }\n\n  return <ReactRouterNavLink {...props} to={to} activeStyle={{ color: colors.gardenGreenDark }} />\n}\n\nconst A = styled.a(linkStyle)\nconst Link = styled(NavLink)(linkStyle)\n\n// Style and align properly\nconst Logo = styled.img`\n  display: inline-block;\n  height: 42px;\n  margin-right: 18px;\n  max-width: 9rem;\n`\n\ntype MenuContainerProps = {\n  visible: boolean\n}\nconst MenuContainer = styled.div<MenuContainerProps>`\n  padding-left: 15px;\n  display: ${(props) => (props.visible ? `block` : \"none\")};\n  height: ${(props) => (props.visible ? `100%` : \"0\")};\n`\n\nconst Menu: React.FC<Props> = ({ pages }) => {\n  const {\n    state: { isMenuOpen },\n  } = useUiState()\n\n  return (\n    <>\n      <MenuContainer visible={isMenuOpen}>\n        <Nav>\n          <NavLink to={{ pathname: \"/\" }}>\n            <Logo src={logo} alt=\"Home\" />\n          </NavLink>\n          {pages.map((page) => (\n            <MenuButton key={page.path} page={page} />\n          ))}\n        </Nav>\n      </MenuContainer>\n    </>\n  )\n}\n\ninterface MenuButtonProps {\n  page: Page\n}\n\nconst MenuButton: React.FC<MenuButtonProps> = ({ page }) => {\n  let link: React.ReactNode\n  if (page.newWindow && page.url) {\n    link = (\n      <A href={page.url} target=\"_blank\" title={page.description}>\n        {page.title}\n        <i className={`${css(\"color: #ccc; margin-left: 0.5em;\")} fas fa-external-link-alt`} />\n      </A>\n    )\n  } else {\n    link = (\n      <Link exact to={{ pathname: page.path, state: page }} title={page.description}>\n        {page.title}\n      </Link>\n    )\n  }\n  return <Button key={page.title}>{link}</Button>\n}\n\nexport default Menu\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport { useState, useEffect, useCallback, useRef, useContext } from \"react\"\n\nimport getApiUrl from \"./api/get-api-url\"\nimport { ApiContext } from \"./contexts/api\"\nimport { UiContext } from \"./contexts/ui\"\nimport { getAuthKey } from \"./util/helpers\"\n\nconst wsRetryInterval = 2000\n\ntype WsConnectionState = \"open\" | \"closed\"\n\nexport const useWebsocket = (\n  handleWsMsg: (msg: MessageEvent) => void,\n  handleWsOpened: () => void,\n  handleWsClosed: () => void\n) => {\n  const wsStateRef = useRef<WsConnectionState>()\n  const wsRef = useRef<WebSocket>()\n  const windowFocused = useWindowFocus()\n  const [wsState, setWsState] = useState<WsConnectionState>()\n  const [retries, setRetries] = useState(0)\n\n  const onConnectionLost = () => {\n    if (wsStateRef.current === \"open\") {\n      handleWsClosed()\n    }\n    setWsState(\"closed\")\n  }\n\n  const initWs = () => {\n    const url = getApiUrl()\n    const ws = new WebSocket(`ws://${url}/ws?key=${getAuthKey()}`)\n    ws.onopen = (_event) => {\n      if (wsStateRef.current === \"closed\") {\n        handleWsOpened()\n      }\n      setWsState(\"open\")\n    }\n    ws.onclose = onConnectionLost\n    ws.onerror = onConnectionLost\n    ws.onmessage = (msg) => {\n      handleWsMsg(msg)\n    }\n    return ws\n  }\n\n  const initWsCb = useCallback(initWs, [])\n\n  useEffect(() => {\n    wsStateRef.current = wsState\n  }, [wsState])\n\n  // Init connection\n  useEffect(() => {\n    wsRef.current = initWsCb()\n  }, [initWsCb])\n\n  // Reconnect after delay if connection lost\n  useEffect(() => {\n    if (wsState === \"closed\" && windowFocused) {\n      const timeout = setTimeout(() => {\n        setRetries((prevCount) => prevCount + 1)\n        wsRef.current = initWsCb()\n      }, wsRetryInterval)\n      return () => {\n        clearTimeout(timeout)\n      }\n    }\n    return\n  }, [initWsCb, wsState, retries, windowFocused])\n\n  // Close connection on unmount\n  useEffect(() => {\n    return () => {\n      wsRef.current?.close()\n    }\n  }, [])\n}\n\n/**\n * Sets the window focus state to true or false\n */\nexport const useWindowFocus = () => {\n  const [focused, setFocused] = useState(document.hasFocus())\n\n  useEffect(() => {\n    const onFocus = () => {\n      setFocused(true)\n    }\n\n    const onBlur = () => {\n      setFocused(false)\n    }\n\n    window.addEventListener(\"focus\", onFocus)\n    window.addEventListener(\"blur\", onBlur)\n\n    return () => {\n      window.removeEventListener(\"focus\", onFocus)\n      window.removeEventListener(\"blur\", onBlur)\n    }\n  }, [])\n\n  return focused\n}\n\n/**\n * Returns the store and load actions via the Context\n */\nexport const useApi = () => useContext(ApiContext)\n\n/**\n * Returns the state and UI actions via the Context\n */\nexport const useUiState = () => useContext(UiContext)\n", "/*\n * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport normalizeUrl from \"normalize-url\"\nimport { format } from \"url\"\nimport { flatten } from \"lodash\"\nimport { ModuleConfig } from \"@garden-io/core/build/src/config/module\"\nimport { ServiceIngress } from \"@garden-io/core/build/src/types/service\"\n\nexport function getServiceNames(moduleConfigs: ModuleConfig[]) {\n  return flatten(moduleConfigs.map((m) => m.serviceConfigs.map((s) => s.name)))\n}\n\nexport function timeConversion(millisec) {\n  const seconds = +(millisec / 1000).toFixed(1)\n  const minutes = +(millisec / (1000 * 60)).toFixed(1)\n  const hours = +(millisec / (1000 * 60 * 60)).toFixed(1)\n  const days = +(millisec / (1000 * 60 * 60 * 24)).toFixed(1)\n  let formatTime = (num, prefix) => `${num} ${prefix}`\n  let timeFormatted: string | null = null\n  if (seconds < 60) {\n    timeFormatted = formatTime(seconds, \"Sec\")\n  } else if (minutes < 60) {\n    timeFormatted = formatTime(minutes, \"Min\")\n  } else if (hours < 24) {\n    timeFormatted = formatTime(hours, \"Hrs\")\n  } else {\n    timeFormatted = formatTime(days, \"Days\")\n  }\n\n  return timeFormatted\n}\n\n// function expects either a string in the form of \"2019-05-18T08:30:08.601Z\" or a Date\nexport function getDuration(start: string | Date, end: string | Date): string {\n  const startValue = new Date(start).valueOf()\n  const endValue = new Date(end).valueOf()\n  const duration = timeConversion(endValue - startValue)\n  return duration\n}\n\nexport const truncateMiddle = (str: string, resLength: number = 35) => {\n  if (str.length > resLength) {\n    const middle = Math.ceil(resLength / 2)\n    return str.substr(0, middle) + \"...\" + str.substr(str.length - middle, str.length)\n  }\n\n  return str\n}\n\n/**\n * Returns the link URL or falls back to constructing the URL from the ingress spec\n */\nexport function getLinkUrl(ingress: ServiceIngress) {\n  if (ingress.linkUrl) {\n    return ingress.linkUrl\n  }\n\n  return normalizeUrl(\n    format({\n      protocol: ingress.protocol,\n      hostname: ingress.hostname,\n      port: ingress.port,\n      pathname: ingress.path,\n    })\n  )\n}\n\n/**\n * Test names are not unique so we construct a unique key from the module name and the test name.\n */\nexport function getTestKey({ testName, moduleName }: { testName: string; moduleName: string }) {\n  return `${moduleName}.${testName}`\n}\n\nlet _canvas: HTMLCanvasElement\n\n/**\n * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n *\n * @param {String} text The text to be rendered.\n * @param {String} font The css font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n *\n * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n */\nexport function getTextWidth(text: string, font: string) {\n  // re-use canvas object for better performance\n  const canvas = _canvas || (_canvas = document.createElement(\"canvas\"))\n  const context = canvas.getContext(\"2d\")!\n  context.font = font\n  const metrics = context.measureText(text)\n  return metrics.width\n}\n\n/**\n * Returns the auth key from the current page's URL params.\n */\nexport function getAuthKey() {\n  const urlParams = new URLSearchParams(window.location.search)\n  return urlParams.get(\"key\")\n}\n"], "filenames": ["core/src/cli/cli.ts", "core/src/constants.ts", "core/src/events.ts", "core/src/server/dashboard-event-stream.ts", "core/src/server/server.ts", "core/test/unit/src/cli/cli.ts", "core/test/unit/src/server/dashboard-event-stream.ts", "core/test/unit/src/server/server.ts", "dashboard/src/api/actions.ts", "dashboard/src/api/api.ts", "dashboard/src/components/menu.tsx", "dashboard/src/hooks.ts", "dashboard/src/util/helpers.ts"], "buggy_code_start_loc": [438, 73, 101, 65, 82, 423, 73, 61, 39, 17, 12, 13, 98], "buggy_code_end_loc": [439, 73, 102, 66, 318, 531, 197, 178, 117, 68, 81, 40, 98], "fixing_code_start_loc": [438, 74, 101, 65, 82, 423, 73, 61, 39, 18, 12, 14, 99], "fixing_code_end_loc": [443, 75, 102, 70, 332, 531, 199, 258, 117, 70, 103, 41, 107], "type": "CWE-306", "message": "Garden is an automation platform for Kubernetes development and testing. In versions prior to 0.12.39 multiple endpoints did not require authentication. In some operating modes this allows for an attacker to gain access to the application erroneously. The configuration is leaked through the /api endpoint on the local server that is responsible for serving the Garden dashboard. At the moment, this server is accessible to 0.0.0.0 which makes it accessible to anyone on the same network (or anyone on the internet if they are on a public, static IP). This may lead to the ability to compromise credentials, secrets or environment variables. Users are advised to upgrade to version 0.12.39 as soon as possible. Users unable to upgrade should use a firewall blocking access to port 9777 from all untrusted network machines.", "other": {"cve": {"id": "CVE-2022-24829", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-11T20:15:20.277", "lastModified": "2022-04-19T15:20:51.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Garden is an automation platform for Kubernetes development and testing. In versions prior to 0.12.39 multiple endpoints did not require authentication. In some operating modes this allows for an attacker to gain access to the application erroneously. The configuration is leaked through the /api endpoint on the local server that is responsible for serving the Garden dashboard. At the moment, this server is accessible to 0.0.0.0 which makes it accessible to anyone on the same network (or anyone on the internet if they are on a public, static IP). This may lead to the ability to compromise credentials, secrets or environment variables. Users are advised to upgrade to version 0.12.39 as soon as possible. Users unable to upgrade should use a firewall blocking access to port 9777 from all untrusted network machines."}, {"lang": "es", "value": "Garden es una plataforma de automatizaci\u00f3n para el desarrollo y las pruebas de Kubernetes. En las versiones anteriores a la 0.12.39 los endpoints m\u00faltiples no requer\u00edan autenticaci\u00f3n. En algunos modos de funcionamiento esto permite a un atacante conseguir acceso a la aplicaci\u00f3n de forma err\u00f3nea. La configuraci\u00f3n es filtrada mediante el endpoint /api en el servidor local que es encargado de servir el dashboard de Garden. En este momento, este servidor es accesible a 0.0.0.0 lo que lo hace accesible a cualquier persona en la misma red (o cualquier persona en Internet si est\u00e1 en una IP p\u00fablica y est\u00e1tica). Esto puede conllevar a una posibilidad de comprometer credenciales, secretos o variables de entorno. Es recomendado a usuarios actualizar a versi\u00f3n 0.12.39 lo antes posible. Los usuarios que no puedan actualizar deber\u00e1n usar un firewall que bloquee el acceso al puerto 9777 desde todas las m\u00e1quinas de la red que no sean confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:garden:garden:*:*:*:*:*:kubernetes:*:*", "versionEndExcluding": "0.12.39", "matchCriteriaId": "B5680A49-A4F0-4890-B29A-DE9DE140541A"}]}]}], "references": [{"url": "https://github.com/garden-io/garden/commit/56051a5b50409227bc420910da88ed156a6e432b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/garden-io/garden/security/advisories/GHSA-f5f3-qrqw-2vqf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/garden-io/garden/commit/56051a5b50409227bc420910da88ed156a6e432b"}}