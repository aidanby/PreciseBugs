{"buggy_code": ["/*\n * event.c\tServer event handling\n *\n * Version:\t$Id$\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2007  The FreeRADIUS server project\n * Copyright 2007  Alan DeKok <aland@deployingradius.com>\n */\n\n#include <freeradius-devel/ident.h>\nRCSID(\"$Id$\")\n\n#include <freeradius-devel/radiusd.h>\n#include <freeradius-devel/modules.h>\n#include <freeradius-devel/event.h>\n#include <freeradius-devel/detail.h>\n\n#include <freeradius-devel/rad_assert.h>\n\n#include <signal.h>\n#include <fcntl.h>\n\n#ifdef HAVE_SYS_WAIT_H\n#\tinclude <sys/wait.h>\n#endif\n\n#define USEC (1000000)\n\nextern pid_t radius_pid;\nextern int dont_fork;\nextern int check_config;\nextern char *debug_condition;\n\n/*\n *\tRidiculous amounts of local state.\n */\nstatic fr_event_list_t\t*el = NULL;\nstatic fr_packet_list_t\t*pl = NULL;\nstatic int\t\t\trequest_num_counter = 0;\nstatic struct timeval\t\tnow;\ntime_t\t\t\t\tfr_start_time;\nstatic int\t\t\thave_children;\nstatic int\t\t\tjust_started = TRUE;\n\n#ifndef __MINGW32__\n#ifdef HAVE_PTHREAD_H\n#define WITH_SELF_PIPE (1)\n#endif\n#endif\n\n#ifdef WITH_SELF_PIPE\nstatic int self_pipe[2];\n#endif\n\n#ifdef HAVE_PTHREAD_H\n#ifdef WITH_PROXY\nstatic pthread_mutex_t\tproxy_mutex;\n#endif\n\n#define PTHREAD_MUTEX_LOCK if (have_children) pthread_mutex_lock\n#define PTHREAD_MUTEX_UNLOCK if (have_children) pthread_mutex_unlock\n\nstatic pthread_t NO_SUCH_CHILD_PID;\n#else\n/*\n *\tThis is easier than ifdef's throughout the code.\n */\n#define PTHREAD_MUTEX_LOCK(_x)\n#define PTHREAD_MUTEX_UNLOCK(_x)\nint thread_pool_addrequest(REQUEST *request, RAD_REQUEST_FUNP fun)\n{\n\tradius_handle_request(request, fun);\n\treturn 1;\n}\n#endif\n\n#define INSERT_EVENT(_function, _ctx) if (!fr_event_insert(el, _function, _ctx, &((_ctx)->when), &((_ctx)->ev))) { _rad_panic(__FILE__, __LINE__, \"Failed to insert event\"); }\n\n#ifdef WITH_PROXY\nstatic fr_packet_list_t *proxy_list = NULL;\n\n/*\n *\tWe keep the proxy FD's here.  The RADIUS Id's are marked\n *\t\"allocated\" per Id, via a bit per proxy FD.\n */\nstatic int\t\tproxy_all_used = FALSE;\nstatic int\t\tproxy_fds[32];\nstatic rad_listen_t\t*proxy_listeners[32];\nstatic void check_for_zombie_home_server(REQUEST *request);\nstatic void remove_from_proxy_hash(REQUEST *request);\n#else\n#define remove_from_proxy_hash(foo)\n#endif\n\nstatic void request_post_handler(REQUEST *request);\nstatic void wait_a_bit(void *ctx);\nstatic void event_socket_handler(fr_event_list_t *xel, UNUSED int fd, void *ctx);\n#ifdef WITH_DETAIL\nstatic void event_poll_detail(void *ctx);\n#endif\n\nstatic void NEVER_RETURNS _rad_panic(const char *file, unsigned int line,\n\t\t\t\t    const char *msg)\n{\n\tradlog(L_ERR, \"[%s:%d] %s\", file, line, msg);\n\t_exit(1);\n}\n\n#define rad_panic(x) _rad_panic(__FILE__, __LINE__, x)\n\n\nstatic void tv_add(struct timeval *tv, int usec_delay)\n{\n\tif (usec_delay > USEC) {\n\t\ttv->tv_sec += usec_delay / USEC;\n\t\tusec_delay %= USEC;\n\t}\n\ttv->tv_usec += usec_delay;\n\n\tif (tv->tv_usec > USEC) {\n\t\ttv->tv_sec += tv->tv_usec / USEC;\n\t\ttv->tv_usec %= USEC;\n\t}\n}\n\nstatic void remove_from_request_hash(REQUEST *request)\n{\n\tif (!request->in_request_hash) return;\n\n\tfr_packet_list_yank(pl, request->packet);\n\trequest->in_request_hash = FALSE;\n\n\trequest_stats_final(request);\n}\n\n\nstatic void ev_request_free(REQUEST **prequest)\n{\n\tREQUEST *request;\n\t\n\tif (!prequest || !*prequest) return;\n\n\trequest = *prequest;\n\n#ifdef WITH_COA\n\tif (request->coa) {\n\t\t/*\n\t\t *\tDivorce the child from the parent first,\n\t\t *\tthen clean up the child.\n\t\t */\n\t\trequest->coa->parent = NULL;\n\t\tev_request_free(&request->coa);\n\t}\n\n\t/*\n\t *\tDivorce the parent from the child, and leave the\n\t *\tparent still alive.\n\t */\n\tif (request->parent && (request->parent->coa == request)) {\n\t\trequest->parent->coa = NULL;\n\t}\n#endif\n\n\tif (request->ev) fr_event_delete(el, &request->ev);\n#ifdef WITH_PROXY\n\tif (request->in_proxy_hash) remove_from_proxy_hash(request);\n#endif\n\tif (request->in_request_hash) remove_from_request_hash(request);\n\n\trequest_free(prequest);\n}\n\n#ifdef WITH_PROXY\nstatic REQUEST *lookup_in_proxy_hash(RADIUS_PACKET *reply)\n{\n\tRADIUS_PACKET **proxy_p;\n\tREQUEST *request;\n\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\tproxy_p = fr_packet_list_find_byreply(proxy_list, reply);\n\n\tif (!proxy_p) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn NULL;\n\t}\n\n\trequest = fr_packet2myptr(REQUEST, proxy, proxy_p);\n\n\tif (!request) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn NULL;\n\t}\n\n\trequest->num_proxied_responses++;\n\n\t/*\n\t *\tCatch the most common case of everything working\n\t *\tcorrectly.\n\t */\n\tif (request->num_proxied_requests == request->num_proxied_responses) {\n\t\tfr_packet_list_yank(proxy_list, request->proxy);\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\trequest->in_proxy_hash = FALSE;\n\t}\n\n\t/*\n\t *\tOn the FIRST reply, decrement the count of outstanding\n\t *\trequests.  Note that this is NOT the count of sent\n\t *\tpackets, but whether or not the home server has\n\t *\tresponded at all.\n\t */\n\tif (!request->proxy_reply &&\n\t    request->home_server &&\n\t    request->home_server->currently_outstanding) {\n\t\trequest->home_server->currently_outstanding--;\n\t}\n\n\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\n\treturn request;\n}\n\n\nstatic void remove_from_proxy_hash(REQUEST *request)\n{\n\t/*\n\t *\tCheck this without grabbing the mutex because it's a\n\t *\tlot faster that way.\n\t */\n\tif (!request->in_proxy_hash) return;\n\n\t/*\n\t *\tThe \"not in hash\" flag is definitive.  However, if the\n\t *\tflag says that it IS in the hash, there might still be\n\t *\ta race condition where it isn't.\n\t */\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\n\tif (!request->in_proxy_hash) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn;\n\t}\n\n\tfr_packet_list_yank(proxy_list, request->proxy);\n\tfr_packet_list_id_free(proxy_list, request->proxy);\n\n\t/*\n\t *\tThe home server hasn't replied, but we've given up on\n\t *\tthis request.  Don't count this request against the\n\t *\thome server.\n\t */\n\tif (!request->proxy_reply &&\n\t    request->home_server &&\n\t    request->home_server->currently_outstanding) {\n\t\trequest->home_server->currently_outstanding--;\n\t}\n\n\t/*\n\t *\tGot from YES in hash, to NO, not in hash while we hold\n\t *\tthe mutex.  This guarantees that when another thread\n\t *\tgrans the mutex, the \"not in hash\" flag is correct.\n\t */\n\trequest->in_proxy_hash = FALSE;\n\n  \tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n}\n\nstatic int proxy_id_alloc(REQUEST *request, RADIUS_PACKET *packet)\n{\n\tint i, proxy, found;\n\trad_listen_t *proxy_listener;\n\n\tif (fr_packet_list_id_alloc(proxy_list, packet)) return 1;\n\n\tif (proxy_all_used) return 0;\n\n\t/*\n\t *\tAllocate a new proxy fd.  This function adds\n\t *\tit to the tail of the list of listeners.  With\n\t *\tsome care, this can be thread-safe.\n\t */\n\tproxy_listener = proxy_new_listener(&packet->src_ipaddr, FALSE);\n\tif (!proxy_listener) {\n\t\tradlog(L_PROXY, \"Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t *\tCache it locally.\n\t */\n\tfound = -1;\n\tproxy = proxy_listener->fd;\n\tfor (i = 0; i < 32; i++) {\n\t\t/*\n\t\t *\tFound a free entry.  Save the socket,\n\t\t *\tand remember where we saved it.\n\t\t */\n\t\tif (proxy_fds[(proxy + i) & 0x1f] == -1) {\n\t\t\tfound = (proxy + i) & 0x1f;\n\t\t\tproxy_fds[found] = proxy;\n\t\t\tproxy_listeners[found] = proxy_listener;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found < 0) {\n\t\tproxy_all_used = TRUE;\n\t\tlisten_free(&proxy_listener);\n\t\tradlog(L_ERR, \"Failed creating new proxy socket: server is too busy and home servers appear to be down\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (!fr_packet_list_socket_add(proxy_list, proxy_listener->fd)) {\n\t\t\tRDEBUG2(\"ERROR: Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t\t\n\t}\n\t\n\tif (!fr_packet_list_id_alloc(proxy_list, packet)) {\n\t\t\tRDEBUG2(\"ERROR: Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t *\tSignal the main thread to add the new FD to the list\n\t *\tof listening FD's.\n\t */\n\tradius_signal_self(RADIUS_SIGNAL_SELF_NEW_FD);\n\treturn 1;\n}\n\n\nstatic int insert_into_proxy_hash(REQUEST *request, int retransmit)\n{\n\tint i, proxy;\n\tchar buf[128];\n\n\trad_assert(request->proxy != NULL);\n\trad_assert(proxy_list != NULL);\n\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\n\t/*\n\t *\tKeep track of maximum outstanding requests to a\n\t *\tparticular home server.  'max_outstanding' is\n\t *\tenforced in home_server_ldb(), in realms.c.\n\t */\n\tif (request->home_server) {\n\t\trequest->home_server->currently_outstanding++;\n\t}\n\n\tif (retransmit) {\n\t\tRADIUS_PACKET packet;\n\n\t\tpacket = *request->proxy;\n\n\t\tif (!proxy_id_alloc(request, &packet)) {\n\t\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tYank the request, free the old Id, and\n\t\t *\tremember the new Id.\n\t\t */\n\t\tfr_packet_list_yank(proxy_list, request->proxy);\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\t*request->proxy = packet;\n\n\t} else if (!proxy_id_alloc(request, request->proxy)) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn 0;\n\t}\n\n\trad_assert(request->proxy->sockfd >= 0);\n\n\t/*\n\t *\tFIXME: Hack until we get rid of rad_listen_t, and put\n\t *\tthe information into the packet_list.\n\t */\n\tproxy = -1;\n\tfor (i = 0; i < 32; i++) {\n\t\tif (proxy_fds[i] == request->proxy->sockfd) {\n\t\t\tproxy = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (proxy < 0) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\tRDEBUG2(\"ERROR: All sockets are full.\");\n\t\treturn 0;\n\t}\n\n\trad_assert(proxy_fds[proxy] != -1);\n\trad_assert(proxy_listeners[proxy] != NULL);\n\trequest->proxy_listener = proxy_listeners[proxy];\n\n\tif (!fr_packet_list_insert(proxy_list, &request->proxy)) {\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\tRDEBUG2(\"ERROR: Failed to insert entry into proxy list\");\n\t\treturn 0;\n\t}\n\n\trequest->in_proxy_hash = TRUE;\n\n\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\n\tRDEBUG3(\" proxy: allocating destination %s port %d - Id %d\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr, buf, sizeof(buf)),\n\t       request->proxy->dst_port,\n\t       request->proxy->id);\n\n\treturn 1;\n}\n\n\n/*\n *\tCalled as BOTH an event, and in-line from other functions.\n */\nstatic void wait_for_proxy_id_to_expire(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->proxy != NULL);\n\n\tif (!fr_event_now(el, &now)) gettimeofday(&now, NULL);\n\trequest->when = request->proxy_when;\n\n#ifdef WITH_COA\n\tif (((request->proxy->code == PW_COA_REQUEST) ||\n\t     (request->proxy->code == PW_DISCONNECT_REQUEST)) &&\n\t    (request->packet->code != request->proxy->code)) {\n\t\trequest->when.tv_sec += request->home_server->coa_mrd;\n\t} else\n#endif\n\trequest->when.tv_sec += request->home_server->response_window;\n\n\tif ((request->num_proxied_requests == request->num_proxied_responses) ||\n\t    timercmp(&now, &request->when, >)) {\n\t\tif (request->packet) {\n\t\t\tRDEBUG2(\"Cleaning up request %u ID %d with timestamp +%d\",\n\t\t\t       request->number, request->packet->id,\n\t\t\t       (unsigned int) (request->timestamp - fr_start_time));\n\t\t} else {\n\t\t\tRDEBUG2(\"Cleaning up request %u with timestamp +%d\",\n\t\t\t       request->number,\n\t\t\t       (unsigned int) (request->timestamp - fr_start_time));\n\t\t}\n\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(wait_for_proxy_id_to_expire, request);\n}\n#endif\n\n#ifdef HAVE_PTHREAD_H\nstatic void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n\t/*\n\t *\tIf it's still queued (waiting for a thread to pick it\n\t *\tup) OR, it's running AND there's still a child thread\n\t *\thandling it, THEN delay some more.\n\t */\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\n\t\t/*\n\t\t *\tCap delay at five minutes.\n\t\t */\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\n\tev_request_free(&request);\n}\n#endif\n\nstatic void cleanup_delay(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert((request->child_state == REQUEST_CLEANUP_DELAY) ||\n\t\t   (request->child_state == REQUEST_DONE));\n\n\tremove_from_request_hash(request);\n\n#ifdef WITH_PROXY\n\tif (request->proxy && request->in_proxy_hash) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\n\tRDEBUG2(\"Cleaning up request %u ID %d with timestamp +%d\",\n\t       request->number, request->packet->id,\n\t       (unsigned int) (request->timestamp - fr_start_time));\n\n\tev_request_free(&request);\n}\n\n\n/*\n *\tIn daemon mode, AND this request has debug flags set.\n */\n#define DEBUG_PACKET if (!debug_flag && request->options && request->radlog) debug_packet\n\nstatic void debug_packet(REQUEST *request, RADIUS_PACKET *packet, int direction)\n{\n\tVALUE_PAIR *vp;\n\tchar buffer[1024];\n\tconst char *received, *from;\n\tconst fr_ipaddr_t *ip;\n\tint port;\n\n\tif (!packet) return;\n\n\trad_assert(request->radlog != NULL);\n\n\tif (direction == 0) {\n\t\treceived = \"Received\";\n\t\tfrom = \"from\";\t/* what else? */\n\t\tip = &packet->src_ipaddr;\n\t\tport = packet->src_port;\n\n\t} else {\n\t\treceived = \"Sending\";\n\t\tfrom = \"to\";\t/* hah! */\n\t\tip = &packet->dst_ipaddr;\n\t\tport = packet->dst_port;\n\t}\n\t\n\t/*\n\t *\tClient-specific debugging re-prints the input\n\t *\tpacket into the client log.\n\t *\n\t *\tThis really belongs in a utility library\n\t */\n\tif ((packet->code > 0) && (packet->code < FR_MAX_PACKET_CODE)) {\n\t\tRDEBUG(\"%s %s packet %s host %s port %d, id=%d, length=%d\",\n\t\t       received, fr_packet_codes[packet->code], from,\n\t\t       inet_ntop(ip->af, &ip->ipaddr, buffer, sizeof(buffer)),\n\t\t       port, packet->id, packet->data_len);\n\t} else {\n\t\tRDEBUG(\"%s packet %s host %s port %d code=%d, id=%d, length=%d\",\n\t\t       received, from,\n\t\t       inet_ntop(ip->af, &ip->ipaddr, buffer, sizeof(buffer)),\n\t\t       port,\n\t\t       packet->code, packet->id, packet->data_len);\n\t}\n\n\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\trequest->radlog(L_DBG, 0, request, \"\\t%s\", buffer);\n\t}\n}\n\nstatic void reject_delay(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_REJECT_DELAY);\n\n\tRDEBUG2(\"Sending delayed reject for request %u\", request->number);\n\n\tDEBUG_PACKET(request, request->reply, 1);\n\n\trequest->listener->send(request->listener, request);\n\n\trequest->when.tv_sec += request->root->cleanup_delay;\n\trequest->child_state = REQUEST_CLEANUP_DELAY;\n\n\tINSERT_EVENT(cleanup_delay, request);\n}\n\n\n#ifdef WITH_PROXY\nvoid revive_home_server(void *ctx)\n{\n\thome_server *home = ctx;\n\tchar buffer[128];\n\n\thome->state = HOME_STATE_ALIVE;\n\thome->currently_outstanding = 0;\n\thome->revive_time = now;\n\n\t/*\n\t *\tDelete any outstanding events.\n\t */\n\tif (home->ev) fr_event_delete(el, &home->ev);\n\n\tradlog(L_PROXY, \"Marking home server %s port %d alive again... we have no idea if it really is alive or not.\",\n\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       home->port);\n\n}\n\n\nstatic void no_response_to_ping(void *ctx)\n{\n\tREQUEST *request = ctx;\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->home_server != NULL);\n\n\thome = request->home_server;\n\thome->num_received_pings = 0;\n\n\tradlog(L_ERR, \"No response to status check %d for home server %s port %d\",\n\t       request->number,\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n\n\tcheck_for_zombie_home_server(request);\n\n\twait_for_proxy_id_to_expire(request);\n}\n\n\nstatic void received_response_to_ping(REQUEST *request)\n{\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->home_server != NULL);\n\n\thome = request->home_server;\n\thome->num_received_pings++;\n\n\tradlog(L_PROXY, \"Received response to status check %d (%d in current sequence)\",\n\t       request->number, home->num_received_pings);\n\n\t/*\n\t *\tRemove the request from any hashes\n\t */\n\tfr_event_delete(el, &request->ev);\n\tremove_from_proxy_hash(request);\n\trad_assert(request->in_request_hash == FALSE);\n\n\t/*\n\t *\tThe control socket may have marked the home server as\n\t *\talive.  OR, it may have suddenly started responding to\n\t *\trequests again.  If so, don't re-do the \"make alive\"\n\t *\twork.\n\t */\n\tif (home->state == HOME_STATE_ALIVE) return;\n\n\t/*\n\t *\tWe haven't received enough ping responses to mark it\n\t *\t\"alive\".  Wait a bit.\n\t */\n\tif (home->num_received_pings < home->num_pings_to_alive) {\n\t\treturn;\n\t}\n\n\thome->state = HOME_STATE_ALIVE;\n\thome->currently_outstanding = 0;\n\thome->revive_time = now;\n\n\tif (!fr_event_delete(el, &home->ev)) {\n\t\tRDEBUG2(\"Hmm... no event for home server.  Oh well.\");\n\t}\n\n\tradlog(L_PROXY, \"Marking home server %s port %d alive\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n}\n\n\n/*\n *\tCalled from start of zombie period, OR after control socket\n *\tmarks the home server dead.\n */\nstatic void ping_home_server(void *ctx)\n{\n\tuint32_t jitter;\n\thome_server *home = ctx;\n\tREQUEST *request;\n\tVALUE_PAIR *vp;\n\n\tif ((home->state == HOME_STATE_ALIVE) ||\n\t    (home->ping_check == HOME_PING_CHECK_NONE) ||\n\t    (home->ev != NULL)) {\n\t\treturn;\n\t}\n\n\trequest = request_alloc();\n\trequest->number = request_num_counter++;\n\n\trequest->proxy = rad_alloc(1);\n\trad_assert(request->proxy != NULL);\n\n\tfr_event_now(el, &request->when);\n\thome->when = request->when;\n\n\tif (home->ping_check == HOME_PING_CHECK_STATUS_SERVER) {\n\t\trequest->proxy->code = PW_STATUS_SERVER;\n\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Message-Authenticator\", \"0x00\", T_OP_SET);\n\n\t} else if (home->type == HOME_TYPE_AUTH) {\n\t\trequest->proxy->code = PW_AUTHENTICATION_REQUEST;\n\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Name\", home->ping_user_name, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Password\", home->ping_user_password, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Service-Type\", \"Authenticate-Only\", T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Message-Authenticator\", \"0x00\", T_OP_SET);\n\n\t} else {\n#ifdef WITH_ACCOUNTING\n\t\trequest->proxy->code = PW_ACCOUNTING_REQUEST;\n\t\t\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Name\", home->ping_user_name, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Acct-Status-Type\", \"Stop\", T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Acct-Session-Id\", \"00000000\", T_OP_SET);\n\t\tvp = radius_pairmake(request, &request->proxy->vps,\n\t\t\t\t     \"Event-Timestamp\", \"0\", T_OP_SET);\n\t\tvp->vp_date = now.tv_sec;\n#else\n\t\trad_assert(\"Internal sanity check failed\");\n#endif\n\t}\n\n\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\"NAS-Identifier\", \"Status Check. Are you alive?\",\n\t\t\tT_OP_SET);\n\n\trequest->proxy->dst_ipaddr = home->ipaddr;\n\trequest->proxy->dst_port = home->port;\n\trequest->home_server = home;\n\n\trad_assert(request->proxy_listener == NULL);\n\n\tif (!insert_into_proxy_hash(request, FALSE)) {\n\t\tRDEBUG2(\"ERROR: Failed inserting status check %d into proxy hash.  Discarding it.\",\n\t\t       request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\trad_assert(request->proxy_listener != NULL);\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\n\trequest->next_callback = NULL;\n\trequest->child_state = REQUEST_PROXIED;\n\tgettimeofday(&request->when, NULL);\n\thome->when = request->when;\n\trequest->when.tv_sec += home->ping_timeout;;\n\n\tINSERT_EVENT(no_response_to_ping, request);\n\n\t/*\n\t *\tAdd +/- 2s of jitter, as suggested in RFC 3539\n\t *\tand in the Issues and Fixes draft.\n\t */\n\thome->when.tv_sec += home->ping_interval - 2;\n\n\tjitter = fr_rand();\n\tjitter ^= (jitter >> 10);\n\tjitter &= ((1 << 23) - 1); /* 22 bits of 1 */\n\n\ttv_add(&home->when, jitter);\n\n\tINSERT_EVENT(ping_home_server, home);\n}\n\n\nvoid mark_home_server_dead(home_server *home, struct timeval *when)\n{\n\tint previous_state = home->state;\n\tchar buffer[128];\n\n\tradlog(L_PROXY, \"Marking home server %s port %d as dead.\",\n\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       home->port);\n\n\thome->state = HOME_STATE_IS_DEAD;\n\thome->num_received_pings = 0;\n\n\tif (home->ping_check != HOME_PING_CHECK_NONE) {\n\t\t/*\n\t\t *\tIf the control socket marks us dead, start\n\t\t *\tpinging.  Otherwise, we already started\n\t\t *\tpinging when it was marked \"zombie\".\n\t\t */\n\t\tif (previous_state == HOME_STATE_ALIVE) {\n\t\t\tping_home_server(home);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t *\tRevive it after a fixed period of time.  This\n\t\t *\tis very, very, bad.\n\t\t */\n\t\thome->when = *when;\n\t\thome->when.tv_sec += home->revive_interval;\n\n\t\tINSERT_EVENT(revive_home_server, home);\n\t}\n}\n\nstatic void check_for_zombie_home_server(REQUEST *request)\n{\n\thome_server *home;\n\tstruct timeval when;\n\n\thome = request->home_server;\n\n\tif (home->state != HOME_STATE_ZOMBIE) return;\n\n\twhen = home->zombie_period_start;\n\twhen.tv_sec += home->zombie_period;\n\n\tfr_event_now(el, &now);\n\tif (timercmp(&now, &when, <)) {\n\t\treturn;\n\t}\n\n\tmark_home_server_dead(home, &request->when);\n}\n\nstatic int proxy_to_virtual_server(REQUEST *request);\n\nstatic int virtual_server_handler(UNUSED REQUEST *request)\n{\n\tproxy_to_virtual_server(request);\n\treturn 0;\n}\n\nstatic void proxy_fallback_handler(REQUEST *request)\n{\n\t/*\n\t *\tA proper time is required for wait_a_bit.\n\t */\n\trequest->delay = USEC / 10;\n\tgettimeofday(&now, NULL);\n\trequest->next_when = now;\n\ttv_add(&request->next_when, request->delay);\n\trequest->next_callback = wait_a_bit;\n\n\t/*\n\t *\tRe-queue the request.\n\t */\n\trequest->child_state = REQUEST_QUEUED;\n\t\n\trad_assert(request->proxy != NULL);\n\tif (!thread_pool_addrequest(request, virtual_server_handler)) {\n\t\trequest->child_state = REQUEST_DONE;\n\t}\n\n#ifdef HAVE_PTHREAD_H\n\t/*\n\t *\tMAY free the request if we're over max_request_time,\n\t *\tAND we're not in threaded mode!\n\t *\n\t *\tNote that we call this ONLY if we're threaded, as\n\t *\tif we're NOT threaded, request_post_handler() calls\n\t *\twait_a_bit(), which means that \"request\" may not\n\t *\texist any more...\n\t */\n\tif (have_children) wait_a_bit(request);\n#endif\n}\n\n\nstatic int setup_post_proxy_fail(REQUEST *request)\n{\n\tDICT_VALUE *dval = NULL;\n\tVALUE_PAIR *vp;\n\n\trequest->child_state = REQUEST_RUNNING;\n\n\tif (request->packet->code == PW_AUTHENTICATION_REQUEST) {\n\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Authentication\");\n\n\t} else if (request->packet->code == PW_ACCOUNTING_REQUEST) {\n\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Accounting\");\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tSee no_response_to_coa_request\n\t\t */\n\t} else if (((request->packet->code >> 8) & 0xff) == PW_COA_REQUEST) {\n\t\trequest->packet->code &= 0xff; /* restore it */\n\n\t\tif (request->proxy->code == PW_COA_REQUEST) {\n\t\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-CoA\");\n\n\t\t} else if (request->proxy->code == PW_DISCONNECT_REQUEST) {\n\t\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Disconnect\");\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n#endif\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (!dval) dval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail\");\n\n\tif (!dval) {\n\t\tpairdelete(&request->config_items, PW_POST_PROXY_TYPE);\n\t\treturn 0;\n\t}\n\n\tvp = pairfind(request->config_items, PW_POST_PROXY_TYPE);\n\tif (!vp) vp = radius_paircreate(request, &request->config_items,\n\t\t\t\t\tPW_POST_PROXY_TYPE, PW_TYPE_INTEGER);\n\tvp->vp_integer = dval->value;\n\n\trad_assert(request->proxy_reply == NULL);\n\n\treturn 1;\n}\n\n\nstatic int null_handler(UNUSED REQUEST *request)\n{\n\treturn 0;\n}\n\nstatic void post_proxy_fail_handler(REQUEST *request)\n{\n\t/*\n\t *\tA proper time is required for wait_a_bit.\n\t */\n\trequest->delay = USEC / 10;\n\tgettimeofday(&now, NULL);\n\n\t/*\n\t *\tNot set up to run Post-Proxy-Type = Fail.\n\t *\n\t *\tMark the request as still running, and figure out what\n\t *\tto do next.\n\t */\n\tif (!setup_post_proxy_fail(request)) {\n\t\trequest_post_handler(request);\n\n\t} else {\n\t\t/*\n\t\t *\tRe-queue the request.\n\t\t */\n\t\trequest->child_state = REQUEST_QUEUED;\n\n\t\t/*\n\t\t *\tThere is a post-proxy-type of fail.  We run\n\t\t *\tthe request through the pre/post proxy\n\t\t *\thandlers, just like it was a real proxied\n\t\t *\trequest.  However, we set the per-request\n\t\t *\thandler to NULL, as we don't want to do\n\t\t *\tanything else.\n\t\t *\n\t\t *\tNote that when we're not threaded, this will\n\t\t *\tprocess the request even if it's greater than\n\t\t *\tmax_request_time.  That's not fatal.\n\t\t */\n\t\trequest->priority = 0;\n\t\trad_assert(request->proxy != NULL);\n\t\tthread_pool_addrequest(request, null_handler);\n\t}\n\n\t/*\n\t *\tMAY free the request if we're over max_request_time,\n\t *\tAND we're not in threaded mode!\n\t *\n\t *\tNote that we call this ONLY if we're threaded, as\n\t *\tif we're NOT threaded, request_post_handler() calls\n\t *\twait_a_bit(), which means that \"request\" may not\n\t *\texist any more...\n\t */\n\tif (have_children) wait_a_bit(request);\n}\n\n\n/* maybe check this against wait_for_proxy_id_to_expire? */\nstatic void no_response_to_proxied_request(void *ctx)\n{\n\tREQUEST *request = ctx;\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\n\t/*\n\t *\tIf we've failed over to an internal home server,\n\t *\treplace the callback with the correct one.  This\n\t *\tis due to locking issues with child threads...\n\t */\n\tif (request->home_server->server) {\n\t\twait_a_bit(request);\n\t\treturn;\n\t}\n\n\tcheck_for_zombie_home_server(request);\n\n\thome = request->home_server;\n\n\t/*\n\t *\tThe default as of 2.1.7 is to allow requests to\n\t *\tfail-over to a backup home server when this one does\n\t *\tnot respond.  The old behavior can be configured as\n\t *\twell.\n\t */\n\tif (home->no_response_fail) {\n\t\tradlog(L_ERR, \"Rejecting request %u (proxy Id %d) due to lack of any response from home server %s port %d\",\n\t\t       request->number, request->proxy->id,\n\t\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       request->proxy->dst_port);\n\n\t\tpost_proxy_fail_handler(request);\n\t} else {\n\t\trad_assert(request->ev == NULL);\n\t\trequest->child_state = REQUEST_RUNNING;\n\t\twait_a_bit(request);\n\t}\n\n\t/*\n\t *\tDon't touch request due to race conditions\n\t */\n\tif (home->state == HOME_STATE_IS_DEAD) {\n\t\trad_assert(home->ev != NULL); /* or it will never wake up */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tEnable the zombie period when we notice that the home\n\t *\tserver hasn't responded.  We do NOT back-date the start\n\t *\tof the zombie period.\n\t */\n\tif (home->state == HOME_STATE_ALIVE) {\n\t\thome->state = HOME_STATE_ZOMBIE;\n\t\thome->zombie_period_start = now;\t\n\t\tfr_event_delete(el, &home->ev);\n\t\thome->currently_outstanding = 0;\n\t\thome->num_received_pings = 0;\n\n\t\tradlog(L_PROXY, \"Marking home server %s port %d as zombie (it looks like it is dead).\",\n\t\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       home->port);\n\n\t\t/*\n\t\t *\tStart pinging the home server.\n\t\t */\n\t\tping_home_server(home);\n\t}\n}\n#endif\n\nstatic void wait_a_bit(void *ctx)\n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <) ||\n\t\t    ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t     (request->child_state == REQUEST_QUEUED))) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n#ifdef WITH_DETAIL\n\t\t\t/*\n\t\t\t *\tCap wait at some sane value for detail\n\t\t\t *\tfiles.\n\t\t\t */\n\t\t\tif ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t\t    (request->delay > (request->root->max_request_time * USEC))) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n#endif\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n#if defined(HAVE_PTHREAD_H)\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t\t\n\t\t\trequest->delay = USEC / 4;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_for_child_to_die;\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t\t/*\n\t\t *\tElse no child thread is processing the\n\t\t *\trequest.  We probably should have just marked\n\t\t *\tthe request as 'done' elsewhere, like in the\n\t\t *\tpost-proxy-fail handler.  But doing that would\n\t\t *\tinvolve checking for max_request_time in\n\t\t *\tmultiple places, so this may be simplest.\n\t\t */\n\t\trequest->child_state = REQUEST_DONE;\n\t\t/* FALL-THROUGH */\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}\n\n#ifdef WITH_COA\nstatic void no_response_to_coa_request(void *ctx)\n{\n\tREQUEST *request = ctx;\n\tchar buffer[128];\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\trad_assert(request->home_server != NULL);\n\trad_assert(!request->in_request_hash);\n\n\tradlog(L_ERR, \"No response to CoA request sent to %s\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)));\n\n\t/*\n\t *\tHack.\n\t */\n\trequest->packet->code |= (PW_COA_REQUEST << 8);\n\tpost_proxy_fail_handler(request);\n}\n\n\nstatic int update_event_timestamp(RADIUS_PACKET *packet, time_t when)\n{\n\tVALUE_PAIR *vp;\n\n\tvp = pairfind(packet->vps, PW_EVENT_TIMESTAMP);\n\tif (!vp) return 0;\n\n\tvp->vp_date = when;\n\n\tif (packet->data) {\n\t\tfree(packet->data);\n\t\tpacket->data = NULL;\n\t\tpacket->data_len = 0;\n\t}\n\n\treturn 1;\t\t/* time stamp updated */\n}\n\n\n/*\n *\tCalled when we haven't received a response to a CoA request.\n */\nstatic void retransmit_coa_request(void *ctx)\n{\n\tint delay, frac;\n\tstruct timeval mrd;\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\trad_assert(request->home_server != NULL);\n\trad_assert(!request->in_request_hash);\n\trad_assert(request->parent == NULL);\n\t\n\tfr_event_now(el, &now);\n\n\t/*\n\t *\tCap count at MRC, if it is non-zero.\n\t */\n\tif (request->home_server->coa_mrc &&\n\t    (request->num_coa_requests >= request->home_server->coa_mrc)) {\n\t\tno_response_to_coa_request(request);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tRFC 5080 Section 2.2.1\n\t *\n\t *\tRT = 2*RTprev + RAND*RTprev\n\t *\t   = 1.9 * RTprev + rand(0,.2) * RTprev\n\t *\t   = 1.9 * RTprev + rand(0,1) * (RTprev / 5)\n\t */\n\tdelay = fr_rand();\n\tdelay ^= (delay >> 16);\n\tdelay &= 0xffff;\n\tfrac = request->delay / 5;\n\tdelay = ((frac >> 16) * delay) + (((frac & 0xffff) * delay) >> 16);\n\n\tdelay += (2 * request->delay) - (request->delay / 10);\n\n\t/*\n\t *\tCap delay at MRT, if MRT is non-zero.\n\t */\n\tif (request->home_server->coa_mrt &&\n\t    (delay > (request->home_server->coa_mrt * USEC))) {\n\t\tint mrt_usec = request->home_server->coa_mrt * USEC;\n\n\t\t/*\n\t\t *\tdelay = MRT + RAND * MRT\n\t\t *\t      = 0.9 MRT + rand(0,.2)  * MRT\n\t\t */\n\t\tdelay = fr_rand();\n\t\tdelay ^= (delay >> 15);\n\t\tdelay &= 0x1ffff;\n\t\tdelay = ((mrt_usec >> 16) * delay) + (((mrt_usec & 0xffff) * delay) >> 16);\n\t\tdelay += mrt_usec - (mrt_usec / 10);\n\t}\n\n\trequest->delay = delay;\n\trequest->when = now;\n\ttv_add(&request->when, request->delay);\n\tmrd = request->proxy_when;\n\tmrd.tv_sec += request->home_server->coa_mrd;\n\n\t/*\n\t *\tCap duration at MRD.\n\t */\n\tif (timercmp(&mrd, &request->when, <)) {\n\t\trequest->when = mrd;\n\t\tINSERT_EVENT(no_response_to_coa_request, request);\n\n\t} else {\n\t\tINSERT_EVENT(retransmit_coa_request, request);\n\t}\n\t\n\tif (update_event_timestamp(request->proxy, now.tv_sec)) {\n\t\tif (!insert_into_proxy_hash(request, TRUE)) {\n\t\t\tDEBUG(\"ERROR: Failed re-inserting CoA request into proxy hash.\");\n\t\t\treturn;\n\t\t}\n\n\t\trequest->num_proxied_requests = 0;\n\t\trequest->num_proxied_responses = 0;\n\t}\n\n\trequest->num_proxied_requests++;\n\trequest->num_coa_requests++; /* is NOT reset by code 3 lines above! */\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n}\n\n\n/*\n *\tThe original request is either DONE, or in CLEANUP_DELAY.\n */\nstatic int originated_coa_request(REQUEST *request)\n{\n\tint delay, rcode, pre_proxy_type = 0;\n\tVALUE_PAIR *vp;\n\tREQUEST *coa;\n\tfr_ipaddr_t ipaddr;\n\tchar buffer[256];\n\n\trad_assert(request->proxy == NULL);\n\trad_assert(!request->in_proxy_hash);\n\trad_assert(request->proxy_reply == NULL);\n\n\t/*\n\t *\tCheck whether we want to originate one, or cancel one.\n\t */\n\tvp = pairfind(request->config_items, PW_SEND_COA_REQUEST);\n\tif (!vp && request->coa) {\n\t\tvp = pairfind(request->coa->proxy->vps, PW_SEND_COA_REQUEST);\n\t}\n\n\tif (vp) {\n\t\tif (vp->vp_integer == 0) {\n\t\t\tev_request_free(&request->coa);\n\t\t\treturn 1;\t/* success */\n\t\t}\n\t}\n\n\tif (!request->coa) request_alloc_coa(request);\n\tif (!request->coa) return 0;\n\n\tcoa = request->coa;\n\n\t/*\n\t *\tsrc_ipaddr will be set up in proxy_encode.\n\t */\n\tmemset(&ipaddr, 0, sizeof(ipaddr));\n\tvp = pairfind(coa->proxy->vps, PW_PACKET_DST_IP_ADDRESS);\n\tif (vp) {\n\t\tipaddr.af = AF_INET;\n\t\tipaddr.ipaddr.ip4addr.s_addr = vp->vp_ipaddr;\n\n\t} else if ((vp = pairfind(coa->proxy->vps,\n\t\t\t\t  PW_PACKET_DST_IPV6_ADDRESS)) != NULL) {\n\t\tipaddr.af = AF_INET6;\n\t\tipaddr.ipaddr.ip6addr = vp->vp_ipv6addr;\n\t\t\n\t} else if ((vp = pairfind(coa->proxy->vps,\n\t\t\t\t  PW_HOME_SERVER_POOL)) != NULL) {\n\t\tcoa->home_pool = home_pool_byname(vp->vp_strvalue,\n\t\t\t\t\t\t  HOME_TYPE_COA);\n\t\tif (!coa->home_pool) {\n\t\t\tRDEBUG2(\"WARNING: No such home_server_pool %s\",\n\t\t\t       vp->vp_strvalue);\n\tfail:\n\t\t\tev_request_free(&request->coa);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tPrefer\n\t\t */\n\t} else if (request->client->coa_pool) {\n\t\tcoa->home_pool = request->client->coa_pool;\n\n\t} else if (request->client->coa_server) {\n\t\tcoa->home_server = request->client->coa_server;\n\n\t} else {\n\t\t/*\n\t\t *\tIf all else fails, send it to the client that\n\t\t *\toriginated this request.\n\t\t */\n\t\tmemcpy(&ipaddr, &request->packet->src_ipaddr, sizeof(ipaddr));\n\t}\n\n\t/*\n\t *\tUse the pool, if it exists.\n\t */\n\tif (coa->home_pool) {\n\t\tcoa->home_server = home_server_ldb(NULL, coa->home_pool, coa);\n\t\tif (!coa->home_server) {\n\t\t\tRDEBUG(\"WARNING: No live home server for home_server_pool %s\", vp->vp_strvalue);\n\t\t\tgoto fail;\n\t\t}\n\n\t} else if (!coa->home_server) {\n\t\tint port = PW_COA_UDP_PORT;\n\n\t\tvp = pairfind(coa->proxy->vps, PW_PACKET_DST_PORT);\n\t\tif (vp) port = vp->vp_integer;\n\n\t\tcoa->home_server = home_server_find(&ipaddr, port);\n\t\tif (!coa->home_server) {\n\t\t\tRDEBUG2(\"WARNING: Unknown destination %s:%d for CoA request.\",\n\t\t\t       inet_ntop(ipaddr.af, &ipaddr.ipaddr,\n\t\t\t\t\t buffer, sizeof(buffer)), port);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvp = pairfind(coa->proxy->vps, PW_PACKET_TYPE);\n\tif (vp) {\n\t\tswitch (vp->vp_integer) {\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tcoa->proxy->code = vp->vp_integer;\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tDEBUG(\"Cannot set CoA Packet-Type to code %d\",\n\t\t\t      vp->vp_integer);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!coa->proxy->code) coa->proxy->code = PW_COA_REQUEST;\n\n\t/*\n\t *\tThe rest of the server code assumes that\n\t *\trequest->packet && request->reply exist.  Copy them\n\t *\tfrom the original request.\n\t */\n\trad_assert(coa->packet != NULL);\n\trad_assert(coa->packet->vps == NULL);\n\tmemcpy(coa->packet, request->packet, sizeof(*request->packet));\n\tcoa->packet->vps = paircopy(request->packet->vps);\n\tcoa->packet->data = NULL;\n\trad_assert(coa->reply != NULL);\n\trad_assert(coa->reply->vps == NULL);\n\tmemcpy(coa->reply, request->reply, sizeof(*request->reply));\n\tcoa->reply->vps = paircopy(request->reply->vps);\n\tcoa->reply->data = NULL;\n\tcoa->config_items = paircopy(request->config_items);\n\n\t/*\n\t *\tCall the pre-proxy routines.\n\t */\n\tvp = pairfind(request->config_items, PW_PRE_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Pre-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpre_proxy_type = vp->vp_integer;\n\t}\n\n\tif (coa->home_pool && coa->home_pool->virtual_server) {\n\t\tconst char *old_server = coa->server;\n\t\t\n\t\tcoa->server = coa->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", coa->server);\n\t\trcode = module_pre_proxy(pre_proxy_type, coa);\n\t\tRDEBUG2(\" }\");\n\t\tcoa->server = old_server;\n\t} else {\n\t\trcode = module_pre_proxy(pre_proxy_type, coa);\n\t}\n\tswitch (rcode) {\n\tdefault:\n\t\tgoto fail;\n\n\t/*\n\t *\tOnly send the CoA packet if the pre-proxy code succeeded.\n\t */\n\tcase RLM_MODULE_NOOP:\n\tcase RLM_MODULE_OK:\n\tcase RLM_MODULE_UPDATED:\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tSource IP / port is set when the proxy socket\n\t *\tis chosen.\n\t */\n\tcoa->proxy->dst_ipaddr = coa->home_server->ipaddr;\n\tcoa->proxy->dst_port = coa->home_server->port;\n\n\tif (!insert_into_proxy_hash(coa, FALSE)) {\n\t\tDEBUG(\"ERROR: Failed inserting CoA request into proxy hash.\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t *\tWe CANNOT divorce the CoA request from the parent\n\t *\trequest.  This function is running in a child thread,\n\t *\tand we need access to the main event loop in order to\n\t *\tto add the timers for the CoA packet.  See\n\t *\twait_a_bit().\n\t */\n\n\t/*\n\t *\tForget about the original request completely at this\n\t *\tpoint.\n\t */\n\trequest = coa;\n\n\tgettimeofday(&request->proxy_when, NULL);\t\n\trequest->received = request->next_when = request->proxy_when;\n\trad_assert(request->proxy_reply == NULL);\n\n\t/*\n\t *\tImplement re-transmit algorithm as per RFC 5080\n\t *\tSection 2.2.1.\n\t *\n\t *\tWe want IRT + RAND*IRT\n\t *\tor 0.9 IRT + rand(0,.2) IRT\n\t *\n\t *\t2^20 ~ USEC, and we want 2.\n\t *\trand(0,0.2) USEC ~ (rand(0,2^21) / 10)\n\t */\n\tdelay = (fr_rand() & ((1 << 22) - 1)) / 10;\n\trequest->delay = delay * request->home_server->coa_irt;\n\tdelay = request->home_server->coa_irt * USEC;\n\tdelay -= delay / 10;\n\tdelay += request->delay;\n     \n\trequest->delay = delay;\n\ttv_add(&request->next_when, delay);\n\trequest->next_callback = retransmit_coa_request;\n\t\n\t/*\n\t *\tNote that we set proxied BEFORE sending the packet.\n\t *\n\t *\tOnce we send it, the request is tainted, as\n\t *\tanother thread may have picked it up.  Don't\n\t *\ttouch it!\n\t */\n\trequest->num_proxied_requests = 1;\n\trequest->num_proxied_responses = 0;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n\tupdate_event_timestamp(request->proxy, request->proxy_when.tv_sec);\n\n\trequest->child_state = REQUEST_PROXIED;\n\n\tDEBUG_PACKET(request, request->proxy, 1);\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\treturn 1;\n}\n#endif\t/* WITH_COA */\n\n#ifdef WITH_PROXY\nstatic int process_proxy_reply(REQUEST *request)\n{\n\tint rcode;\n\tint post_proxy_type = 0;\n\tVALUE_PAIR *vp;\n\t\n\t/*\n\t *\tDelete any reply we had accumulated until now.\n\t */\n\tpairfree(&request->reply->vps);\n\t\n\t/*\n\t *\tRun the packet through the post-proxy stage,\n\t *\tBEFORE playing games with the attributes.\n\t */\n\tvp = pairfind(request->config_items, PW_POST_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Post-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpost_proxy_type = vp->vp_integer;\n\t}\n\t\n\tif (request->home_pool && request->home_pool->virtual_server) {\n\t\tconst char *old_server = request->server;\n\t\t\n\t\trequest->server = request->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", request->server);\n\t\trcode = module_post_proxy(post_proxy_type, request);\n\t\tRDEBUG2(\" }\");\n\t\trequest->server = old_server;\n\t} else {\n\t\trcode = module_post_proxy(post_proxy_type, request);\n\t}\n\n#ifdef WITH_COA\n\tif (request->packet->code == request->proxy->code)\n\t  /*\n\t   *\tDon't run the next bit if we originated a CoA\n\t   *\tpacket, after receiving an Access-Request or\n\t   *\tAccounting-Request.\n\t   */\n#endif\n\t\n\t/*\n\t *\tThere may NOT be a proxy reply, as we may be\n\t *\trunning Post-Proxy-Type = Fail.\n\t */\n\tif (request->proxy_reply) {\n\t\t/*\n\t\t *\tDelete the Proxy-State Attributes from\n\t\t *\tthe reply.  These include Proxy-State\n\t\t *\tattributes from us and remote server.\n\t\t */\n\t\tpairdelete(&request->proxy_reply->vps, PW_PROXY_STATE);\n\t\t\n\t\t/*\n\t\t *\tAdd the attributes left in the proxy\n\t\t *\treply to the reply list.\n\t\t */\n\t\tpairadd(&request->reply->vps, request->proxy_reply->vps);\n\t\trequest->proxy_reply->vps = NULL;\n\t\t\n\t\t/*\n\t\t *\tFree proxy request pairs.\n\t\t */\n\t\tpairfree(&request->proxy->vps);\n\t}\n\t\n\tswitch (rcode) {\n\tdefault:  /* Don't do anything */\n\t\tbreak;\n\tcase RLM_MODULE_FAIL:\n\t\t/* FIXME: debug print stuff */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t\t\n\tcase RLM_MODULE_HANDLED:\n\t\t/* FIXME: debug print stuff */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n#endif\n\nstatic int request_pre_handler(REQUEST *request)\n{\n\tint rcode;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->packet != NULL);\n\n\trequest->child_state = REQUEST_RUNNING;\n\n\t/*\n\t *\tDon't decode the packet if it's an internal \"fake\"\n\t *\trequest.  Instead, just return so that the caller can\n\t *\tprocess it.\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\trequest->username = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_NAME);\n\t\trequest->password = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_PASSWORD);\n\t\treturn 1;\n\t}\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tPut the decoded packet into it's proper place.\n\t */\n\tif (request->proxy_reply != NULL) {\n\t\trcode = request->proxy_listener->decode(request->proxy_listener,\n\t\t\t\t\t\t\trequest);\n\t\tDEBUG_PACKET(request, request->proxy_reply, 0);\n\t} else\n#endif\n\tif (request->packet->vps == NULL) {\n\t\trcode = request->listener->decode(request->listener, request);\n\t\t\n\t\tif (debug_condition) {\n\t\t\tint result = FALSE;\n\t\t\tconst char *my_debug = debug_condition;\n\n\t\t\t/*\n\t\t\t *\tIgnore parse errors.\n\t\t\t */\n\t\t\tradius_evaluate_condition(request, RLM_MODULE_OK, 0,\n\t\t\t\t\t\t  &my_debug, 1,\n\t\t\t\t\t\t  &result);\n\t\t\tif (result) {\n\t\t\t\trequest->options = 2;\n\t\t\t\trequest->radlog = radlog_request;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDEBUG_PACKET(request, request->packet, 0);\n\t} else {\n\t\trcode = 0;\n\t}\n\n\tif (rcode < 0) {\n\t\tRDEBUG(\"%s Dropping packet without response.\", fr_strerror());\n\t\trequest->reply->offset = -2; /* bad authenticator */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t}\n\n\tif (!request->username) {\n\t\trequest->username = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_NAME);\n\t}\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\treturn process_proxy_reply(request);\n\t}\n#endif\n\n\treturn 1;\n}\n\n\n#ifdef WITH_PROXY\n/*\n *\tDo state handling when we proxy a request.\n */\nstatic int proxy_request(REQUEST *request)\n{\n\tstruct timeval when;\n\tchar buffer[128];\n\n#ifdef WITH_COA\n\tif (request->coa) {\n\t\tRDEBUG(\"WARNING: Cannot proxy and originate CoA packets at the same time.  Cancelling CoA request\");\n\t\tev_request_free(&request->coa);\n\t}\n#endif\n\n\tif (request->home_server->server) {\n\t\tRDEBUG(\"ERROR: Cannot perform real proxying to a virtual server.\");\n\t\treturn 0;\n\t}\n\n\tif (!insert_into_proxy_hash(request, FALSE)) {\n\t\tRDEBUG(\"ERROR: Failed inserting request into proxy hash.\");\n\t\treturn 0;\n\t}\n\n\trequest->proxy_listener->encode(request->proxy_listener, request);\n\n\twhen = request->received;\n\twhen.tv_sec += request->root->max_request_time;\n\n\tgettimeofday(&request->proxy_when, NULL);\n\n\trequest->next_when = request->proxy_when;\n\trequest->next_when.tv_sec += request->home_server->response_window;\n\n\trad_assert(request->home_server->response_window > 0);\n\n\tif (timercmp(&when, &request->next_when, <)) {\n\t\trequest->next_when = when;\n\t}\n\trequest->next_callback = no_response_to_proxied_request;\n\n\tRDEBUG2(\"Proxying request %u to home server %s port %d\",\n\t       request->number,\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n\n\t/*\n\t *\tNote that we set proxied BEFORE sending the packet.\n\t *\n\t *\tOnce we send it, the request is tainted, as\n\t *\tanother thread may have picked it up.  Don't\n\t *\ttouch it!\n\t */\n\trequest->num_proxied_requests = 1;\n\trequest->num_proxied_responses = 0;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\trequest->child_state = REQUEST_PROXIED;\n\n\tDEBUG_PACKET(request, request->proxy, 1);\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\treturn 1;\n}\n\n\n/*\n *\t\"Proxy\" the request by sending it to a new virtual server.\n */\nstatic int proxy_to_virtual_server(REQUEST *request)\n{\n\tREQUEST *fake;\n\tRAD_REQUEST_FUNP fun;\n\n\tif (!request->home_server || !request->home_server->server) return 0;\n\n\tif (request->parent) {\n\t\tRDEBUG2(\"WARNING: Cancelling proxy request to virtual server %s as this request was itself proxied.\", request->home_server->server);\n\t\treturn 0;\n\t}\n\n\tfake = request_alloc_fake(request);\n\tif (!fake) {\n\t\tRDEBUG2(\"WARNING: Out of memory\");\n\t\treturn 0;\n\t}\n\n\tfake->packet->vps = paircopy(request->proxy->vps);\n\tfake->server = request->home_server->server;\n\n\tif (request->proxy->code == PW_AUTHENTICATION_REQUEST) {\n\t\tfun = rad_authenticate;\n\n#ifdef WITH_ACCOUNTING\n\t} else if (request->proxy->code == PW_ACCOUNTING_REQUEST) {\n\t\tfun = rad_accounting;\n#endif\n\n\t} else {\n\t\tRDEBUG2(\"Unknown packet type %d\", request->proxy->code);\n\t\tev_request_free(&fake);\n\t\treturn 0;\n\t}\n\n\tRDEBUG2(\">>> Sending proxied request internally to virtual server.\");\n\tradius_handle_request(fake, fun);\n\tRDEBUG2(\"<<< Received proxied response code %d from internal virtual server.\", fake->reply->code);\n\n\tif (fake->reply->code != 0) {\n\t\trequest->proxy_reply = fake->reply;\n\t\tfake->reply = NULL;\n\t} else {\n\t\t/*\n\t\t *\tThere was no response\n\t\t */\n\t\tsetup_post_proxy_fail(request);\n\t}\n\n\tev_request_free(&fake);\n\n\tprocess_proxy_reply(request);\n\n\t/*\n\t *\tProcess it through the normal section again, but ONLY\n\t *\tif we received a proxy reply..\n\t */\n\tif (request->proxy_reply) {\n\t\tif (request->server) RDEBUG(\"server %s {\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\"); \n\t\tfun(request);\n\t\t\n\t\tif (request->server) RDEBUG(\"} # server %s\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\");\n\t}\n\n\treturn 2;\t\t/* success, but NOT '1' !*/\n}\n\n/*\n *\tReturn 1 if we did proxy it, or the proxy attempt failed\n *\tcompletely.  Either way, the caller doesn't touch the request\n *\tany more if we return 1.\n */\nstatic int successfully_proxied_request(REQUEST *request)\n{\n\tint rcode;\n\tint pre_proxy_type = 0;\n\tVALUE_PAIR *realmpair;\n\tVALUE_PAIR *strippedname;\n\tVALUE_PAIR *vp;\n\tchar *realmname = NULL;\n\thome_server *home;\n\tREALM *realm = NULL;\n\thome_pool_t *pool;\n\n\t/*\n\t *\tIf it was already proxied, do nothing.\n\t *\n\t *\tFIXME: This should really be a serious error.\n\t */\n\tif (request->in_proxy_hash ||\n\t    (request->proxy_reply && (request->proxy_reply->code != 0))) {\n\t\treturn 0;\n\t}\n\n\trealmpair = pairfind(request->config_items, PW_PROXY_TO_REALM);\n\tif (!realmpair || (realmpair->length == 0)) {\n\t\tint pool_type;\n\n\t\tvp = pairfind(request->config_items, PW_HOME_SERVER_POOL);\n\t\tif (!vp) return 0;\n\n\t\tswitch (request->packet->code) {\n\t\tcase PW_AUTHENTICATION_REQUEST:\n\t\t\tpool_type = HOME_TYPE_AUTH;\n\t\t\tbreak;\n\n#ifdef WITH_ACCOUNTING\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tpool_type = HOME_TYPE_ACCT;\n\t\t\tbreak;\n#endif\n\n#ifdef WITH_COA\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tpool_type = HOME_TYPE_COA;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tpool = home_pool_byname(vp->vp_strvalue, pool_type);\n\t\tif (!pool) {\n\t\t\tRDEBUG2(\"ERROR: Cannot proxy to unknown pool %s\",\n\t\t\t\tvp->vp_strvalue);\n\t\t\treturn 0;\n\t\t}\n\n\t\trealmname = NULL; /* no realms */\n\t\trealm = NULL;\n\t\tgoto found_pool;\n\t}\n\n\trealmname = (char *) realmpair->vp_strvalue;\n\n\trealm = realm_find2(realmname);\n\tif (!realm) {\n\t\tRDEBUG2(\"ERROR: Cannot proxy to unknown realm %s\", realmname);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tFigure out which pool to use.\n\t */\n\tif (request->packet->code == PW_AUTHENTICATION_REQUEST) {\n\t\tpool = realm->auth_pool;\n\n#ifdef WITH_ACCOUNTING\n\t} else if (request->packet->code == PW_ACCOUNTING_REQUEST) {\n\t\tpool = realm->acct_pool;\n#endif\n\n#ifdef WITH_COA\n\t} else if ((request->packet->code == PW_COA_REQUEST) ||\n\t\t   (request->packet->code == PW_DISCONNECT_REQUEST)) {\n\t\tpool = realm->acct_pool;\n#endif\n\n\t} else {\n\t\trad_panic(\"Internal sanity check failed\");\n\t}\n\n\tif (!pool) {\n\t\tRDEBUG2(\" WARNING: Cancelling proxy to Realm %s, as the realm is local.\",\n\t\t       realmname);\n\t\treturn 0;\n\t}\n\nfound_pool:\n\thome = home_server_ldb(realmname, pool, request);\n\tif (!home) {\n\t\tRDEBUG2(\"ERROR: Failed to find live home server for realm %s\",\n\t\t       realmname);\n\t\treturn -1;\n\t}\n\trequest->home_pool = pool;\n\n#ifdef WITH_COA\n\t/*\n\t *\tOnce we've decided to proxy a request, we cannot send\n\t *\ta CoA packet.  So we free up any CoA packet here.\n\t */\n\tev_request_free(&request->coa);\n#endif\n\t/*\n\t *\tRemember that we sent the request to a Realm.\n\t */\n\tif (realmname) pairadd(&request->packet->vps,\n\t\t\t       pairmake(\"Realm\", realmname, T_OP_EQ));\n\n\t/*\n\t *\tStrip the name, if told to.\n\t *\n\t *\tDoing it here catches the case of proxied tunneled\n\t *\trequests.\n\t */\n\tif (realm && (realm->striprealm == TRUE) &&\n\t   (strippedname = pairfind(request->proxy->vps, PW_STRIPPED_USER_NAME)) != NULL) {\n\t\t/*\n\t\t *\tIf there's a Stripped-User-Name attribute in\n\t\t *\tthe request, then use THAT as the User-Name\n\t\t *\tfor the proxied request, instead of the\n\t\t *\toriginal name.\n\t\t *\n\t\t *\tThis is done by making a copy of the\n\t\t *\tStripped-User-Name attribute, turning it into\n\t\t *\ta User-Name attribute, deleting the\n\t\t *\tStripped-User-Name and User-Name attributes\n\t\t *\tfrom the vps list, and making the new\n\t\t *\tUser-Name the head of the vps list.\n\t\t */\n\t\tvp = pairfind(request->proxy->vps, PW_USER_NAME);\n\t\tif (!vp) {\n\t\t\tvp = radius_paircreate(request, NULL,\n\t\t\t\t\t       PW_USER_NAME, PW_TYPE_STRING);\n\t\t\trad_assert(vp != NULL);\t/* handled by above function */\n\t\t\t/* Insert at the START of the list */\n\t\t\tvp->next = request->proxy->vps;\n\t\t\trequest->proxy->vps = vp;\n\t\t}\n\t\tmemcpy(vp->vp_strvalue, strippedname->vp_strvalue,\n\t\t       sizeof(vp->vp_strvalue));\n\t\tvp->length = strippedname->length;\n\n\t\t/*\n\t\t *\tDo NOT delete Stripped-User-Name.\n\t\t */\n\t}\n\n\t/*\n\t *\tIf there is no PW_CHAP_CHALLENGE attribute but\n\t *\tthere is a PW_CHAP_PASSWORD we need to add it\n\t *\tsince we can't use the request authenticator\n\t *\tanymore - we changed it.\n\t */\n\tif ((request->packet->code == PW_AUTHENTICATION_REQUEST) &&\n\t    pairfind(request->proxy->vps, PW_CHAP_PASSWORD) &&\n\t    pairfind(request->proxy->vps, PW_CHAP_CHALLENGE) == NULL) {\n\t\tvp = radius_paircreate(request, &request->proxy->vps,\n\t\t\t\t       PW_CHAP_CHALLENGE, PW_TYPE_OCTETS);\n\t\tvp->length = AUTH_VECTOR_LEN;\n\t\tmemcpy(vp->vp_strvalue, request->packet->vector, AUTH_VECTOR_LEN);\n\t}\n\n\t/*\n\t *\tThe RFC's say we have to do this, but FreeRADIUS\n\t *\tdoesn't need it.\n\t */\n\tvp = radius_paircreate(request, &request->proxy->vps,\n\t\t\t       PW_PROXY_STATE, PW_TYPE_OCTETS);\n\tsnprintf(vp->vp_strvalue, sizeof(vp->vp_strvalue), \"%d\",\n\t\t request->packet->id);\n\tvp->length = strlen(vp->vp_strvalue);\n\n\t/*\n\t *\tShould be done BEFORE inserting into proxy hash, as\n\t *\tpre-proxy may use this information, or change it.\n\t */\n\trequest->proxy->code = request->packet->code;\n\n\t/*\n\t *\tCall the pre-proxy routines.\n\t */\n\tvp = pairfind(request->config_items, PW_PRE_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Pre-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpre_proxy_type = vp->vp_integer;\n\t}\n\n\trad_assert(request->home_pool != NULL);\n\n\tif (request->home_pool->virtual_server) {\n\t\tconst char *old_server = request->server;\n\t\t\n\t\trequest->server = request->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", request->server);\n\t\trcode = module_pre_proxy(pre_proxy_type, request);\n\t\tRDEBUG2(\" }\");\n\t\t\trequest->server = old_server;\n\t} else {\n\t\trcode = module_pre_proxy(pre_proxy_type, request);\n\t}\n\tswitch (rcode) {\n\tcase RLM_MODULE_FAIL:\n\tcase RLM_MODULE_INVALID:\n\tcase RLM_MODULE_NOTFOUND:\n\tcase RLM_MODULE_USERLOCK:\n\tdefault:\n\t\t/* FIXME: debug print failed stuff */\n\t\treturn -1;\n\n\tcase RLM_MODULE_REJECT:\n\tcase RLM_MODULE_HANDLED:\n\t\treturn 0;\n\n\t/*\n\t *\tOnly proxy the packet if the pre-proxy code succeeded.\n\t */\n\tcase RLM_MODULE_NOOP:\n\tcase RLM_MODULE_OK:\n\tcase RLM_MODULE_UPDATED:\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tIf it's a fake request, don't send the proxy\n\t *\tpacket.  The outer tunnel session will take\n\t *\tcare of doing that.\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\trequest->home_server = NULL;\n\t\treturn 1;\n\t}\n\n\tif (request->home_server->server) {\n\t\treturn proxy_to_virtual_server(request);\n\t}\n\n\tif (!proxy_request(request)) {\n\t\tRDEBUG(\"ERROR: Failed to proxy request %u\", request->number);\n\t\treturn -1;\n\t}\n\t\n\treturn 1;\n}\n#endif\n\nstatic void request_post_handler(REQUEST *request)\n{\n\tint child_state = -1;\n\tstruct timeval when;\n\tVALUE_PAIR *vp;\n\n\tif ((request->master_state == REQUEST_STOP_PROCESSING) ||\n\t    (request->parent &&\n\t     (request->parent->master_state == REQUEST_STOP_PROCESSING))) {\n\t\tRDEBUG2(\"request %u was cancelled.\", request->number);\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\tchild_state = REQUEST_DONE;\n\t\tgoto cleanup;\n\t}\n\n\tif (request->child_state != REQUEST_RUNNING) {\n\t\trad_panic(\"Internal sanity check failed\");\n\t}\n\n#ifdef WITH_COA\n\t/*\n\t *\tIf it's not in the request hash, it's a CoA request.\n\t *\tWe hope.\n\t */\n\tif (!request->in_request_hash &&\n\t    request->proxy &&\n\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tgoto cleanup;\n\t}\n#endif\n\n\t/*\n\t *\tCatch Auth-Type := Reject BEFORE proxying the packet.\n\t */\n\tif ((request->packet->code == PW_AUTHENTICATION_REQUEST) &&\n\t    (request->reply->code == 0) &&\n\t    ((vp = pairfind(request->config_items, PW_AUTH_TYPE)) != NULL) &&\n\t    (vp->vp_integer == PW_AUTHTYPE_REJECT)) {\n\t\trequest->reply->code = PW_AUTHENTICATION_REJECT;\n\t}\n\n#ifdef WITH_PROXY\n\tif (request->root->proxy_requests &&\n\t    !request->in_proxy_hash &&\n\t    (request->reply->code == 0) &&\n\t    (request->packet->dst_port != 0) &&\n\t    (request->packet->code != PW_STATUS_SERVER)) {\n\t\tint rcode = successfully_proxied_request(request);\n\n\t\tif (rcode == 1) return; /* request is invalid */\n\n\t\t/*\n\t\t *\tFailed proxying it (dead home servers, etc.)\n\t\t *\tRun it through Post-Proxy-Type = Fail, and\n\t\t *\trespond to the request.\n\t\t *\n\t\t *\tNote that we're in a child thread here, so we\n\t\t *\tdo NOT re-schedule the request.  Instead, we\n\t\t *\tdo what we would have done, which is run the\n\t\t *\tpre-handler, a NULL request handler, and then\n\t\t *\tthe post handler.\n\t\t */\n\t\tif ((rcode < 0) && setup_post_proxy_fail(request)) {\n\t\t\trequest_pre_handler(request);\n\t\t}\n\n\t\t/*\n\t\t *\tElse we weren't supposed to proxy it,\n\t\t *\tOR we proxied it internally to a virutal server.\n\t\t */\n\t}\n\n#ifdef WITH_COA\n\telse if (request->proxy && request->coa) {\n\t\tRDEBUG(\"WARNING: Cannot proxy and originate CoA packets at the same time.  Cancelling CoA request\");\n\t\tev_request_free(&request->coa);\n\t}\n#endif\n#endif\n\n\t/*\n\t *\tFake requests don't get encoded or signed.  The caller\n\t *\talso requires the reply VP's, so we don't free them\n\t *\there!\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\t/* FIXME: RDEBUG going to the next request */\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn;\n\t}\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tCopy Proxy-State from the request to the reply.\n\t */\n\tvp = paircopy2(request->packet->vps, PW_PROXY_STATE);\n\tif (vp) pairadd(&request->reply->vps, vp);\n#endif\n\n\t/*\n\t *\tAccess-Requests get delayed or cached.\n\t */\n\tswitch (request->packet->code) {\n\tcase PW_AUTHENTICATION_REQUEST:\n\t\tgettimeofday(&request->next_when, NULL);\n\n\t\tif (request->reply->code == 0) {\n\t\t\t/*\n\t\t\t *\tCheck if the lack of response is intentional.\n\t\t\t */\n\t\t\tvp = pairfind(request->config_items,\n\t\t\t\t      PW_RESPONSE_PACKET_TYPE);\n\t\t\tif (!vp) {\n\t\t\t\tRDEBUG2(\"There was no response configured: rejecting request %u\",\n\t\t\t\t       request->number);\n\t\t\t\trequest->reply->code = PW_AUTHENTICATION_REJECT;\n\n\t\t\t} else if (vp->vp_integer == 256) {\n\t\t\t\tRDEBUG2(\"Not responding to request %u\",\n\t\t\t\t       request->number);\n\n\t\t\t\t/*\n\t\t\t\t *\tForce cleanup after a long\n\t\t\t\t *\ttime, so that we don't\n\t\t\t\t *\tre-process the packet.\n\t\t\t\t */\n\t\t\t\trequest->next_when.tv_sec += request->root->max_request_time;\n\t\t\t\trequest->next_callback = cleanup_delay;\n\t\t\t\tchild_state = REQUEST_CLEANUP_DELAY;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trequest->reply->code = vp->vp_integer;\n\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tRun rejected packets through\n\t\t *\n\t\t *\tPost-Auth-Type = Reject\n\t\t */\n\t\tif (request->reply->code == PW_AUTHENTICATION_REJECT) {\n\t\t\tpairdelete(&request->config_items, PW_POST_AUTH_TYPE);\n\t\t\tvp = radius_pairmake(request, &request->config_items,\n\t\t\t\t\t     \"Post-Auth-Type\", \"Reject\",\n\t\t\t\t\t     T_OP_SET);\n\t\t\tif (vp) rad_postauth(request);\n\n\t\t\t/*\n\t\t\t *\tIf configured, delay Access-Reject packets.\n\t\t\t *\n\t\t\t *\tIf request->root->reject_delay = 0, we discover\n\t\t\t *\tthat we have to send the packet now.\n\t\t\t */\n\t\t\twhen = request->received;\n\t\t\twhen.tv_sec += request->root->reject_delay;\n\n\t\t\tif (timercmp(&when, &request->next_when, >)) {\n\t\t\t\tRDEBUG2(\"Delaying reject of request %u for %d seconds\",\n\t\t\t\t       request->number,\n\t\t\t\t       request->root->reject_delay);\n\t\t\t\trequest->next_when = when;\n\t\t\t\trequest->next_callback = reject_delay;\n#ifdef HAVE_PTHREAD_H\n\t\t\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\t\t\trequest->child_state = REQUEST_REJECT_DELAY;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n#ifdef WITH_COA\n\tcase PW_COA_REQUEST:\n\tcase PW_DISCONNECT_REQUEST:\n#endif\n\t\trequest->next_when.tv_sec += request->root->cleanup_delay;\n\t\trequest->next_callback = cleanup_delay;\n\t\tchild_state = REQUEST_CLEANUP_DELAY;\n\t\tbreak;\n\n\tcase PW_ACCOUNTING_REQUEST:\n\t\trequest->next_callback = NULL; /* just to be safe */\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\n\t\t/*\n\t\t *\tFIXME: Status-Server should probably not be\n\t\t *\thandled here...\n\t\t */\n\tcase PW_STATUS_SERVER:\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t *\tDHCP, VMPS, etc.\n\t\t */\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\t}\n\n\t/*\n\t *      Suppress \"no reply\" packets here, unless we're reading\n\t *      from the \"detail\" file.  In that case, we've got to\n\t *      tell the detail file handler that the request is dead,\n\t *      and it should re-send it.\n\t *\tIf configured, encode, sign, and send.\n\t */\n\tif ((request->reply->code != 0) ||\n\t    (request->listener->type == RAD_LISTEN_DETAIL)) {\n\t\tDEBUG_PACKET(request, request->reply, 1);\n\t\trequest->listener->send(request->listener, request);\n\t}\n\n#ifdef WITH_COA\n\t/*\n\t *\tNow that we've completely processed the request,\n\t *\tsee if we need to originate a CoA request.  But ONLY\n\t *\tif it wasn't proxied.\n\t */\n\tif (!request->proxy &&\n\t    (request->coa ||\n\t     (pairfind(request->config_items, PW_SEND_COA_REQUEST) != NULL))) {\n\t\tif (!originated_coa_request(request)) {\n\t\t\tRDEBUG2(\"Do CoA Fail handler here\");\n\t\t}\n\t\t/* request->coa is stil set, so we can update events */\n\t}\n#endif\n\n cleanup:\n\t/*\n\t *\tClean up.  These are no longer needed.\n\t */\n\tpairfree(&request->config_items);\n\n\tpairfree(&request->packet->vps);\n\trequest->username = NULL;\n\trequest->password = NULL;\n\n\tpairfree(&request->reply->vps);\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\tpairfree(&request->proxy->vps);\n\n\t\tif (request->proxy_reply) {\n\t\t\tpairfree(&request->proxy_reply->vps);\n\t\t}\n\n#if 0\n\t\t/*\n\t\t *\tWe're not tracking responses from the home\n\t\t *\tserver, we can therefore free this memory in\n\t\t *\tthe child thread.\n\t\t */\n\t\tif (!request->in_proxy_hash) {\n\t\t\trad_free(&request->proxy);\n\t\t\trad_free(&request->proxy_reply);\n\t\t\trequest->home_server = NULL;\n\t\t}\n#endif\n\t}\n#endif\n\n\tRDEBUG2(\"Finished request %u.\", request->number);\n\trad_assert(child_state >= 0);\n\trequest->child_state = child_state;\n\n\t/*\n\t *\tSingle threaded mode: update timers now.\n\t */\n\tif (!have_children) wait_a_bit(request);\n}\n\n\nstatic void received_retransmit(REQUEST *request, const RADCLIENT *client)\n{\n#ifdef WITH_PROXY\n\tchar buffer[128];\n#endif\n\n\tRAD_STATS_TYPE_INC(request->listener, total_dup_requests);\n\tRAD_STATS_CLIENT_INC(request->listener, client, total_dup_requests);\n\t\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n#ifdef WITH_PROXY\n\tdiscard:\n#endif\n\t\tradlog(L_ERR, \"Discarding duplicate request from \"\n\t\t       \"client %s port %d - ID: %d due to unfinished request %u\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port,request->packet->id,\n\t\t       request->number);\n\t\tbreak;\n\n#ifdef WITH_PROXY\n\tcase REQUEST_PROXIED:\n\t\t/*\n\t\t *\tWe're not supposed to have duplicate\n\t\t *\taccounting packets.  The other states handle\n\t\t *\tduplicates fine (discard, or send duplicate\n\t\t *\treply).  But we do NOT want to retransmit an\n\t\t *\taccounting request here, because that would\n\t\t *\tinvolve updating the Acct-Delay-Time, and\n\t\t *\ttherefore changing the packet Id, etc.\n\t\t *\n\t\t *\tInstead, we just discard the packet.  We may\n\t\t *\teventually respond, or the client will send a\n\t\t *\tnew accounting packet.\t\t  \n\t\t *\n\t\t *\tThe same comments go for Status-Server, and\n\t\t *\tother packet types.\n\t\t *\n\t\t *\tFIXME: coa: when we proxy CoA && Disconnect\n\t\t *\tpackets, this logic has to be fixed.\n\t\t */\n\t\tif (request->packet->code != PW_AUTHENTICATION_REQUEST) {\n\t\t\tgoto discard;\n\t\t}\n\n\t\tcheck_for_zombie_home_server(request);\n\n\t\t/*\n\t\t *\tIf we've just discovered that the home server is\n\t\t *\tdead, send the packet to another one.\n\t\t */\n\t\tif ((request->packet->dst_port != 0) &&\n\t\t    (request->home_server->state == HOME_STATE_IS_DEAD)) {\n\t\t\thome_server *home;\n\n\t\t\tremove_from_proxy_hash(request);\n\n\t\t\thome = home_server_ldb(NULL, request->home_pool, request);\n\t\t\tif (!home) {\n\t\t\t\tRDEBUG2(\"Failed to find live home server for request %u\", request->number);\n\t\t\tno_home_servers:\n\t\t\t\t/*\n\t\t\t\t *\tDo post-request processing,\n\t\t\t\t *\tand any insertion of necessary\n\t\t\t\t *\tevents.\n\t\t\t\t */\n\t\t\t\tpost_proxy_fail_handler(request);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trequest->proxy->code = request->packet->code;\n\n\t\t\t/*\n\t\t\t *\tFree the old packet, to force re-encoding\n\t\t\t */\n\t\t\tfree(request->proxy->data);\n\t\t\trequest->proxy->data = NULL;\n\t\t\trequest->proxy->data_len = 0;\n\n\t\t\t/*\n\t\t\t *\tThis request failed over to a virtual\n\t\t\t *\tserver.  Push it back onto the queue\n\t\t\t *\tto be processed.\n\t\t\t */\n\t\t\tif (request->home_server->server) {\n\t\t\t\tproxy_fallback_handler(request);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tTry to proxy the request.\n\t\t\t */\n\t\t\tif (!proxy_request(request)) {\n\t\t\t\tRDEBUG(\"ERROR: Failed to re-proxy request %u\", request->number);\n\t\t\t\tgoto no_home_servers;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tThis code executes in the main server\n\t\t\t *\tthread, so there's no need for locking.\n\t\t\t */\n\t\t\trad_assert(request->next_callback != NULL);\n\t\t\tINSERT_EVENT(request->next_callback, request);\n\t\t\trequest->next_callback = NULL;\n\t\t\treturn;\n\t\t} /* else the home server is still alive */\n\n\t\tRDEBUG2(\"Sending duplicate proxied request to home server %s port %d - ID: %d\",\n\t\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       request->proxy->dst_port,\n\t\t       request->proxy->id);\n\t\trequest->num_proxied_requests++;\n\n\t\tDEBUG_PACKET(request, request->proxy, 1);\n\t\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t\t      request);\n\t\tbreak;\n#endif\n\n\tcase REQUEST_REJECT_DELAY:\n\t\tRDEBUG2(\"Waiting to send Access-Reject \"\n\t\t       \"to client %s port %d - ID: %d\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port, request->packet->id);\n\t\tbreak;\n\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tif (request->reply->code == 0) {\n\t\t\tRDEBUG2(\"Ignoring retransmit from client %s port %d \"\n\t\t\t\t\"- ID: %d, no reply was configured\",\n\t\t\t\tclient->shortname,\n\t\t\t\trequest->packet->src_port, request->packet->id);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t *\tFIXME: This sends duplicate replies to\n\t\t *\taccounting requests, even if Acct-Delay-Time\n\t\t *\tor Event-Timestamp is in the packet.  In those\n\t\t *\tcases, the Id should be changed, and the packet\n\t\t *\tre-calculated.\n\t\t */\n\t\tRDEBUG2(\"Sending duplicate reply \"\n\t\t       \"to client %s port %d - ID: %d\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port, request->packet->id);\n\t\tDEBUG_PACKET(request, request->reply, 1);\n\t\trequest->listener->send(request->listener, request);\n\t\tbreak;\n\t}\n}\n\n\nstatic void received_conflicting_request(REQUEST *request,\n\t\t\t\t\t const RADCLIENT *client)\n{\n\tradlog(L_ERR, \"Received conflicting packet from \"\n\t       \"client %s port %d - ID: %d due to unfinished request %u.  Giving up on old request.\",\n\t       client->shortname,\n\t       request->packet->src_port, request->packet->id,\n\t       request->number);\n\n\t/*\n\t *\tNuke it from the request hash, so we can receive new\n\t *\tpackets.\n\t */\n\tremove_from_request_hash(request);\n\n\tswitch (request->child_state) {\n#ifdef HAVE_PTHREAD_H\n\t\t/*\n\t\t *\tIt's queued or running.  Tell it to stop, and\n\t\t *\twait for it to do so.\n\t\t */\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\t\trequest->delay += request->delay >> 1;\n\n\t\ttv_add(&request->when, request->delay);\n\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n#endif\n\n\t\t/*\n\t\t *\tCatch race conditions.  It may have switched\n\t\t *\tfrom running to done while this code is being\n\t\t *\texecuted.\n\t\t */\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIt's in some other state, and therefore also\n\t\t *\tin the event queue.  At some point, the\n\t\t *\tchild will notice, and we can then delete it.\n\t\t */\n\tcase REQUEST_PROXIED:\n\tdefault:\n\t\trad_assert(request->ev != NULL);\n\t\tbreak;\n\t}\n}\n\n\nstatic int can_handle_new_request(RADIUS_PACKET *packet,\n\t\t\t\t  RADCLIENT *client,\n\t\t\t\t  struct main_config_t *root)\n{\n\t/*\n\t *\tCount the total number of requests, to see if\n\t *\tthere are too many.  If so, return with an\n\t *\terror.\n\t */\n\tif (root->max_requests) {\n\t\tint request_count = fr_packet_list_num_elements(pl);\n\n\t\t/*\n\t\t *\tThis is a new request.  Let's see if\n\t\t *\tit makes us go over our configured\n\t\t *\tbounds.\n\t\t */\n\t\tif (request_count > root->max_requests) {\n\t\t\tradlog(L_ERR, \"Dropping request (%d is too many): \"\n\t\t\t       \"from client %s port %d - ID: %d\", request_count,\n\t\t\t       client->shortname,\n\t\t\t       packet->src_port, packet->id);\n\t\t\tradlog(L_INFO, \"WARNING: Please check the configuration file.\\n\"\n\t\t\t       \"\\tThe value for 'max_requests' is probably set too low.\\n\");\n\t\t\treturn 0;\n\t\t} /* else there were a small number of requests */\n\t} /* else there was no configured limit for requests */\n\n\t/*\n\t *\tFIXME: Add per-client checks.  If one client is sending\n\t *\ttoo many packets, start discarding them.\n\t *\n\t *\tWe increment the counters here, and decrement them\n\t *\twhen the response is sent... somewhere in this file.\n\t */\n\n\t/*\n\t *\tFUTURE: Add checks for system load.  If the system is\n\t *\tbusy, start dropping requests...\n\t *\n\t *\tWe can probably keep some statistics ourselves...  if\n\t *\tthere are more requests coming in than we can handle,\n\t *\tstart dropping some.\n\t */\n\n\treturn 1;\n}\n\n\nint received_request(rad_listen_t *listener,\n\t\t     RADIUS_PACKET *packet, REQUEST **prequest,\n\t\t     RADCLIENT *client)\n{\n\tRADIUS_PACKET **packet_p;\n\tREQUEST *request = NULL;\n\tstruct main_config_t *root = &mainconfig;\n\n\tpacket_p = fr_packet_list_find(pl, packet);\n\tif (packet_p) {\n\t\trequest = fr_packet2myptr(REQUEST, packet, packet_p);\n\t\trad_assert(request->in_request_hash);\n\n\t\tif ((request->packet->data_len == packet->data_len) &&\n\t\t    (memcmp(request->packet->vector, packet->vector,\n\t\t\t    sizeof(packet->vector)) == 0)) {\n\t\t\treceived_retransmit(request, client);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tThe new request is different from the old one,\n\t\t *\tbut maybe the old is finished.  If so, delete\n\t\t *\tthe old one.\n\t\t */\n\t\tswitch (request->child_state) {\n\t\t\tstruct timeval when;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t *\tSpecial hacks for race conditions.\n\t\t\t *\tThe reply is encoded, and therefore\n\t\t\t *\tlikely sent.  We received a *new*\n\t\t\t *\tpacket from the client, likely before\n\t\t\t *\tthe next line or two of code which\n\t\t\t *\tupdated the child state.  In this\n\t\t\t *\tcase, just accept the new request.\n\t\t\t */\n\t\t\tif ((request->reply->code != 0) &&\n\t\t\t    request->reply->data) {\n\t\t\t\tradlog(L_INFO, \"WARNING: Allowing fast client %s port %d - ID: %d for recent request %u.\",\n\t\t\t\t       client->shortname,\n\t\t\t\t       packet->src_port, packet->id,\n\t\t\t\t       request->number);\n\t\t\t\tremove_from_request_hash(request);\n\t\t\t\trequest = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgettimeofday(&when, NULL);\n\t\t\twhen.tv_sec -= 1;\n\n\t\t\t/*\n\t\t\t *\tIf the cached request was received\n\t\t\t *\twithin the last second, then we\n\t\t\t *\tdiscard the NEW request instead of the\n\t\t\t *\told one.  This will happen ONLY when\n\t\t\t *\tthe client is severely broken, and is\n\t\t\t *\tsending conflicting packets very\n\t\t\t *\tquickly.\n\t\t\t */\n\t\t\tif (timercmp(&when, &request->received, <)) {\n\t\t\t\tradlog(L_ERR, \"Discarding conflicting packet from \"\n\t\t\t\t       \"client %s port %d - ID: %d due to recent request %u.\",\n\t\t\t\t       client->shortname,\n\t\t\t\t       packet->src_port, packet->id,\n\t\t\t\t       request->number);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treceived_conflicting_request(request, client);\n\t\t\trequest = NULL;\n\t\t\tbreak;\n\n\t\tcase REQUEST_REJECT_DELAY:\n\t\tcase REQUEST_CLEANUP_DELAY:\n\t\t\trequest->child_state = REQUEST_DONE;\n\t\tcase REQUEST_DONE:\n\t\t\tcleanup_delay(request);\n\t\t\trequest = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t *\tWe may want to quench the new request.\n\t */\n\tif ((listener->type != RAD_LISTEN_DETAIL) &&\n\t    !can_handle_new_request(packet, client, root)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tCreate and initialize the new request.\n\t */\n\trequest = request_alloc(); /* never fails */\n\n\tif ((request->reply = rad_alloc(0)) == NULL) {\n\t\tradlog(L_ERR, \"No memory\");\n\t\texit(1);\n\t}\n\n\trequest->listener = listener;\n\trequest->client = client;\n\trequest->packet = packet;\n\trequest->packet->timestamp = request->timestamp;\n\trequest->number = request_num_counter++;\n\trequest->priority = listener->type;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n\t/*\n\t *\tStatus-Server packets go to the head of the queue.\n\t */\n\tif (request->packet->code == PW_STATUS_SERVER) request->priority = 0;\n\n\t/*\n\t *\tSet virtual server identity\n\t */\n\tif (client->server) {\n\t\trequest->server = client->server;\n\t} else if (listener->server) {\n\t\trequest->server = listener->server;\n\t} else {\n\t\trequest->server = NULL;\n\t}\n\n\t/*\n\t *\tRemember the request in the list.\n\t */\n\tif (!fr_packet_list_insert(pl, &request->packet)) {\n\t\tradlog(L_ERR, \"Failed to insert request %u in the list of live requests: discarding\", request->number);\n\t\tev_request_free(&request);\n\t\treturn 0;\n\t}\n\n\trequest->in_request_hash = TRUE;\n\trequest->root = root;\n\troot->refcount++;\n\n\t/*\n\t *\tThe request passes many of our sanity checks.\n\t *\tFrom here on in, if anything goes wrong, we\n\t *\tsend a reject message, instead of dropping the\n\t *\tpacket.\n\t */\n\n\t/*\n\t *\tBuild the reply template from the request.\n\t */\n\n\trequest->reply->sockfd = request->packet->sockfd;\n\trequest->reply->dst_ipaddr = request->packet->src_ipaddr;\n\trequest->reply->src_ipaddr = request->packet->dst_ipaddr;\n\trequest->reply->dst_port = request->packet->src_port;\n\trequest->reply->src_port = request->packet->dst_port;\n\trequest->reply->id = request->packet->id;\n\trequest->reply->code = 0; /* UNKNOWN code */\n\tmemcpy(request->reply->vector, request->packet->vector,\n\t       sizeof(request->reply->vector));\n\trequest->reply->vps = NULL;\n\trequest->reply->data = NULL;\n\trequest->reply->data_len = 0;\n\n\trequest->master_state = REQUEST_ACTIVE;\n\trequest->child_state = REQUEST_QUEUED;\n\trequest->next_callback = NULL;\n\n\tgettimeofday(&request->received, NULL);\n\trequest->timestamp = request->received.tv_sec;\n\trequest->when = request->received;\n\n\trequest->delay = USEC;\n\n\ttv_add(&request->when, request->delay);\n\n\tINSERT_EVENT(wait_a_bit, request);\n\n\t*prequest = request;\n\treturn 1;\n}\n\n\n#ifdef WITH_PROXY\nREQUEST *received_proxy_response(RADIUS_PACKET *packet)\n{\n\tchar\t\tbuffer[128];\n\tREQUEST\t\t*request;\n\n\t/*\n\t *\tAlso removes from the proxy hash if responses == requests\n\t */\n\trequest = lookup_in_proxy_hash(packet);\n\n\tif (!request) {\n\t\tradlog(L_PROXY, \"No outstanding request was found for reply from host %s port %d - ID %d\",\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       packet->src_port, packet->id);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tWe haven't replied to the NAS, but we have seen an\n\t *\tearlier reply from the home server.  Ignore this packet,\n\t *\tas we're likely still processing the previous reply.\n\t */\n\tif (request->proxy_reply) {\n\t\tif (memcmp(request->proxy_reply->vector,\n\t\t\t   packet->vector,\n\t\t\t   sizeof(request->proxy_reply->vector)) == 0) {\n\t\t\tRDEBUG2(\"Discarding duplicate reply from host %s port %d  - ID: %d for request %u\",\n\t\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t\t buffer, sizeof(buffer)),\n\t\t\t       packet->src_port, packet->id,\n\t\t\t       request->number);\n\t\t} else {\n\t\t\t/*\n\t\t\t *\t? The home server gave us a new proxy\n\t\t\t *\treply which doesn't match the old\n\t\t\t *\tone.  Delete it.\n\t\t\t */\n\t\t\tRDEBUG2(\"Ignoring conflicting proxy reply\");\n\t\t}\n\t\t\n\t\t/* assert that there's an event queued for request? */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tVerify the packet before doing ANYTHING with it.  This\n\t *\tmeans we're doing more MD5 checks in the server core.\n\t *\tHowever, we can fix that by moving to multiple threads\n\t *\tlistening on sockets.\n\t *\n\t *\tWe do this AFTER looking the request up in the hash,\n\t *\tand AFTER vhecking if we saw a previous request.  This\n\t *\thelps minimize the DoS effect of people attacking us\n\t *\twith spoofed packets.\n\t */\n\tif (rad_verify(packet, request->proxy,\n\t\t       request->home_server->secret) != 0) {\n\t\tDEBUG(\"Ignoring spoofed proxy reply.  Signature is invalid\");\n\t\treturn NULL;\n\t}\n\n\tgettimeofday(&now, NULL);\n\n\t/*\n\t *\t\"ping\" packets have a different algorithm for marking\n\t *\ta home server alive.  They also skip all of the CoA,\n\t *\tetc. checks.\n\t */\n\tif (!request->packet) {\n\t\trequest->proxy_reply = packet;\n\t\treceived_response_to_ping(request);\n\t\trequest->proxy_reply = NULL; /* caller will free it */\n\t\tev_request_free(&request);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tMaybe move this earlier in the decision process?\n\t *\tHaving it here means that late or duplicate proxy\n\t *\treplies no longer get the home server marked as\n\t *\t\"alive\".  This might be good for stability, though.\n\t *\n\t *\tFIXME: Do we really want to do this whenever we\n\t *\treceive a packet?  Setting this here means that we\n\t *\tmark it alive on *any* packet, even if it's lost all\n\t *\tof the *other* packets in the last 10s.\n\t */\n\trequest->home_server->state = HOME_STATE_ALIVE;\n\t\n#ifdef WITH_COA\n\t/*\n\t *\tWhen originating CoA, the \"proxy\" reply is the reply\n\t *\tto the CoA request that we originated.  At this point,\n\t *\tthe original request is finished, and it has a reply.\n\t *\n\t *\tHowever, if we haven't separated the two requests, do\n\t *\tso now.  This is done so that cleaning up the original\n\t *\trequest won't cause the CoA request to be free'd.  See\n\t *\tutil.c, request_free()\n\t */\n\tif (request->parent && (request->parent->coa == request)) {\n\t\trequest->parent->coa = NULL;\n\t\trequest->parent = NULL;\n\n\t\t/*\n\t\t *\tThe proxied packet was different from the\n\t\t *\toriginal packet, AND the proxied packet was\n\t\t *\ta CoA: allow it.\n\t\t */\n\t} else if ((request->packet->code != request->proxy->code) &&\n\t\t   ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t    (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t  /*\n\t   *\tIt's already divorced: do nothing.\n\t   */\n\t  \n\t} else\n\t\t/*\n\t\t *\tSkip the next set of checks, as the original\n\t\t *\treply is cached.  We want to be able to still\n\t\t *\tprocess the CoA reply, AND to reference the\n\t\t *\toriginal request/reply.\n\t\t *\n\t\t *\tThis is getting to be really quite a bit of a\n\t\t *\thack.\n\t\t */\n#endif\n\n\t/*\n\t *\tIf there's a reply to the NAS, ignore everything\n\t *\trelated to proxy responses\n\t */\n\tif (request->reply && request->reply->code != 0) {\n\t\tRDEBUG2(\"Ignoring proxy reply that arrived after we sent a reply to the NAS\");\n\t\treturn NULL;\n\t}\n\n#ifdef WITH_STATS\n\t/*\n\t *\tThe average includes our time to receive packets and\n\t *\tlook them up in the hashes, which should be the same\n\t *\tfor all packets.\n\t *\n\t *\tWe update the response time only for the FIRST packet\n\t *\twe receive.\n\t */\n\tif (request->home_server->ema.window > 0) {\n\t\tradius_stats_ema(&request->home_server->ema,\n\t\t\t\t &now, &request->proxy_when);\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\tradlog(L_ERR, \"Internal sanity check failed for child state\");\n\t\t/* FALL-THROUGH */\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tradlog(L_ERR, \"Reply from home server %s port %d  - ID: %d arrived too late for request %u. Try increasing 'retry_delay' or 'max_request_time'\",\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       packet->src_port, packet->id,\n\t\t       request->number);\n\t\t/* assert that there's an event queued for request? */\n\t\treturn NULL;\n\n\tcase REQUEST_PROXIED:\n\t\tbreak;\n\t}\n\n\trequest->proxy_reply = packet;\n\n#if 0\n\t/*\n\t *\tPerform RTT calculations, as per RFC 2988 (for TCP).\n\t *\tNote that we only do so on the first response.\n\t */\n\tif ((request->num_proxied_responses == 1)\n\t\tint rtt;\n\t\thome_server *home = request->home_server;\n\n\t\trtt = now.tv_sec - request->proxy_when.tv_sec;\n\t\trtt *= USEC;\n\t\trtt += now.tv_usec;\n\t\trtt -= request->proxy_when.tv_usec;\n\n\t\tif (!home->has_rtt) {\n\t\t\thome->has_rtt = TRUE;\n\n\t\t\thome->srtt = rtt;\n\t\t\thome->rttvar = rtt / 2;\n\n\t\t} else {\n\t\t\thome->rttvar -= home->rttvar >> 2;\n\t\t\thome->rttvar += (home->srtt - rtt);\n\t\t\thome->srtt -= home->srtt >> 3;\n\t\t\thome->srtt += rtt >> 3;\n\t\t}\n\n\t\thome->rto = home->srtt;\n\t\tif (home->rttvar > (USEC / 4)) {\n\t\t\thome->rto += home->rttvar * 4;\n\t\t} else {\n\t\t\thome->rto += USEC;\n\t\t}\n\t}\n#endif\n\n\trequest->child_state = REQUEST_QUEUED;\n\trequest->when = now;\n\trequest->delay = USEC;\n\trequest->priority = RAD_LISTEN_PROXY;\n\ttv_add(&request->when, request->delay);\n\n\t/*\n\t *\tWait a bit will take care of max_request_time\n\t */\n\tINSERT_EVENT(wait_a_bit, request);\n\n\treturn request;\n}\n#endif\n\nvoid event_new_fd(rad_listen_t *this)\n{\n\tchar buffer[1024];\n\n\tif (this->status == RAD_LISTEN_STATUS_KNOWN) return;\n\t\n\tthis->print(this, buffer, sizeof(buffer));\n\t\n\tif (this->status == RAD_LISTEN_STATUS_INIT) {\n\t\tif (just_started) {\n\t\t\tDEBUG(\"Listening on %s\", buffer);\n\t\t} else {\n\t\t\tradlog(L_INFO, \" ... adding new socket %s\", buffer);\n\t\t}\n\t\tif (!fr_event_fd_insert(el, 0, this->fd,\n\t\t\t\t\tevent_socket_handler, this)) {\n\t\t\tradlog(L_ERR, \"Failed remembering handle for proxy socket!\");\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tthis->status = RAD_LISTEN_STATUS_KNOWN;\n\t\treturn;\n\t}\n\t\n\tif (this->status == RAD_LISTEN_STATUS_CLOSED) {\n\t\tradlog(L_INFO, \" ... closing socket %s\", buffer);\n\t\t\n\t\tfr_event_fd_delete(el, 0, this->fd);\n\t\tthis->status = RAD_LISTEN_STATUS_FINISH;\n\t\t\n\t\t/*\n\t\t *\tClose the fd AFTER fixing up the requests and\n\t\t *\tlisteners, so that they don't send/recv on the\n\t\t *\twrong socket (if someone manages to open\n\t\t *\tanother one).\n\t\t */\n\t\tclose(this->fd);\n\t\tthis->fd = -1;\n\t}\n}\n\nstatic void handle_signal_self(int flag)\n{\n\tif ((flag & (RADIUS_SIGNAL_SELF_EXIT | RADIUS_SIGNAL_SELF_TERM)) != 0) {\n\t\tif ((flag & RADIUS_SIGNAL_SELF_EXIT) != 0) {\n\t\t\tfr_event_loop_exit(el, 1);\n\t\t} else {\n\t\t\tfr_event_loop_exit(el, 2);\n\t\t}\n\n\t\treturn;\n\t} /* else exit/term flags weren't set */\n\n\t/*\n\t *\tTell the even loop to stop processing.\n\t */\n\tif ((flag & RADIUS_SIGNAL_SELF_HUP) != 0) {\n\t\ttime_t when;\n\t\tstatic time_t last_hup = 0;\n\n\t\twhen = time(NULL);\n\t\tif ((int) (when - last_hup) < 5) {\n\t\t\tradlog(L_INFO, \"Ignoring HUP (less than 5s since last one)\");\n\t\t\treturn;\n\t\t}\n\n\t\tradlog(L_INFO, \"Received HUP signal.\");\n\n\t\tlast_hup = when;\n\n\t\tfr_event_loop_exit(el, 0x80);\n\t}\n\n#ifdef WITH_DETAIL\n\tif ((flag & RADIUS_SIGNAL_SELF_DETAIL) != 0) {\n\t\trad_listen_t *this;\n\t\t\n\t\t/*\n\t\t *\tFIXME: O(N) loops suck.\n\t\t */\n\t\tfor (this = mainconfig.listen;\n\t\t     this != NULL;\n\t\t     this = this->next) {\n\t\t\tif (this->type != RAD_LISTEN_DETAIL) continue;\n\n\t\t\t/*\n\t\t\t *\tThis one didn't send the signal, skip\n\t\t\t *\tit.\n\t\t\t */\n\t\t\tif (!this->decode(this, NULL)) continue;\n\n\t\t\t/*\n\t\t\t *\tGo service the interrupt.\n\t\t\t */\n\t\t\tevent_poll_detail(this);\n\t\t}\n\t}\n#endif\n\n\tif ((flag & RADIUS_SIGNAL_SELF_NEW_FD) != 0) {\n\t\trad_listen_t *this;\n\t\t\n\t\tfor (this = mainconfig.listen;\n\t\t     this != NULL;\n\t\t     this = this->next) {\n\t\t\tevent_new_fd(this);\n\t\t}\n\t}\n}\n\n#ifndef WITH_SELF_PIPE\nvoid radius_signal_self(int flag)\n{\n\thandle_signal_self(flag);\n}\n#else\n/*\n *\tInform ourselves that we received a signal.\n */\nvoid radius_signal_self(int flag)\n{\n\tssize_t rcode;\n\tuint8_t buffer[16];\n\n\t/*\n\t *\tThe read MUST be non-blocking for this to work.\n\t */\n\trcode = read(self_pipe[0], buffer, sizeof(buffer));\n\tif (rcode > 0) {\n\t\tssize_t i;\n\n\t\tfor (i = 0; i < rcode; i++) {\n\t\t\tbuffer[0] |= buffer[i];\n\t\t}\n\t} else {\n\t\tbuffer[0] = 0;\n\t}\n\n\tbuffer[0] |= flag;\n\n\twrite(self_pipe[1], buffer, 1);\n}\n\n\nstatic void event_signal_handler(UNUSED fr_event_list_t *xel,\n\t\t\t\t UNUSED int fd, UNUSED void *ctx)\n{\n\tssize_t i, rcode;\n\tuint8_t buffer[32];\n\n\trcode = read(self_pipe[0], buffer, sizeof(buffer));\n\tif (rcode <= 0) return;\n\n\t/*\n\t *\tMerge pending signals.\n\t */\n\tfor (i = 0; i < rcode; i++) {\n\t\tbuffer[0] |= buffer[i];\n\t}\n\n\thandle_signal_self(buffer[0]);\n}\n#endif\n\n\nstatic void event_socket_handler(fr_event_list_t *xel, UNUSED int fd,\n\t\t\t\t void *ctx)\n{\n\trad_listen_t *listener = ctx;\n\tRAD_REQUEST_FUNP fun;\n\tREQUEST *request;\n\n\trad_assert(xel == el);\n\n\txel = xel;\n\n\tif (listener->fd < 0) rad_panic(\"Socket was closed on us!\");\n\t\n\tif (!listener->recv(listener, &fun, &request)) return;\n\n\tif (!thread_pool_addrequest(request, fun)) {\n\t\trequest->child_state = REQUEST_DONE;\n\t}\n}\n\n\n/*\n *\tThis function is called periodically to see if this detail\n *\tfile is available for reading.\n */\nstatic void event_poll_detail(void *ctx)\n{\n\tint rcode, delay;\n\tRAD_REQUEST_FUNP fun;\n\tREQUEST *request;\n\trad_listen_t *this = ctx;\n\tstruct timeval when;\n\tlisten_detail_t *detail = this->data;\n\n\trad_assert(this->type == RAD_LISTEN_DETAIL);\n\n\t/*\n\t *\tTry to read something.\n\t *\n\t *\tFIXME: This does poll AND receive.\n\t */\n\trcode = this->recv(this, &fun, &request);\n\tif (rcode != 0) {\n\t\trad_assert(fun != NULL);\n\t\trad_assert(request != NULL);\n\t\t\n\t\tif (!thread_pool_addrequest(request, fun)) {\n\t\t\trequest->child_state = REQUEST_DONE;\n\t\t}\n\t}\n\n\tif (!fr_event_now(el, &now)) gettimeofday(&now, NULL);\n\twhen = now;\n\n\t/*\n\t *\tBackdoor API to get the delay until the next poll\n\t *\ttime.\n\t */\n\tdelay = this->encode(this, NULL);\n\ttv_add(&when, delay);\n\n\tif (!fr_event_insert(el, event_poll_detail, this,\n\t\t\t     &when, &detail->ev)) {\n\t\tradlog(L_ERR, \"Failed creating handler\");\n\t\texit(1);\n\t}\n}\n\n\nstatic void event_status(struct timeval *wake)\n{\n#if !defined(HAVE_PTHREAD_H) && defined(WNOHANG)\n\tint argval;\n#endif\n\n\tif (debug_flag == 0) {\n\t\tif (just_started) {\n\t\t\tradlog(L_INFO, \"Ready to process requests.\");\n\t\t\tjust_started = FALSE;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!wake) {\n\t\tradlog(L_INFO, \"Ready to process requests.\");\n\n\t} else if ((wake->tv_sec != 0) ||\n\t\t   (wake->tv_usec >= 100000)) {\n\t\tDEBUG(\"Waking up in %d.%01u seconds.\",\n\t\t      (int) wake->tv_sec, (unsigned int) wake->tv_usec / 100000);\n\t}\n\n\n\t/*\n\t *\tFIXME: Put this somewhere else, where it isn't called\n\t *\tall of the time...\n\t */\n\n#if !defined(HAVE_PTHREAD_H) && defined(WNOHANG)\n\t/*\n\t *\tIf there are no child threads, then there may\n\t *\tbe child processes.  In that case, wait for\n\t *\ttheir exit status, and throw that exit status\n\t *\taway.  This helps get rid of zxombie children.\n\t */\n\twhile (waitpid(-1, &argval, WNOHANG) > 0) {\n\t\t/* do nothing */\n\t}\n#endif\n\n}\n\n/*\n *\tExternally-visibly functions.\n */\nint radius_event_init(CONF_SECTION *cs, int spawn_flag)\n{\n\trad_listen_t *this, *head = NULL;\n\n\tif (el) return 0;\n\n\ttime(&fr_start_time);\n\n\tel = fr_event_list_create(event_status);\n\tif (!el) return 0;\n\n\tpl = fr_packet_list_create(0);\n\tif (!pl) return 0;\t/* leak el */\n\n\trequest_num_counter = 0;\n\n#ifdef WITH_PROXY\n\tif (mainconfig.proxy_requests) {\n\t\t/*\n\t\t *\tCreate the tree for managing proxied requests and\n\t\t *\tresponses.\n\t\t */\n\t\tproxy_list = fr_packet_list_create(1);\n\t\tif (!proxy_list) return 0;\n\n#ifdef HAVE_PTHREAD_H\n\t\tif (pthread_mutex_init(&proxy_mutex, NULL) != 0) {\n\t\t\tradlog(L_ERR, \"FATAL: Failed to initialize proxy mutex: %s\",\n\t\t\t       strerror(errno));\n\t\t\texit(1);\n\t\t}\n#endif\n\t}\n#endif\n\n#ifdef HAVE_PTHREAD_H\n#ifndef __MINGW32__\n\tNO_SUCH_CHILD_PID = (pthread_t ) (0);\n#else\n\tNO_SUCH_CHILD_PID = pthread_self(); /* not a child thread */\n#endif\n\t/*\n\t *\tInitialize the threads ONLY if we're spawning, AND\n\t *\twe're running normally.\n\t */\n\tif (spawn_flag && !check_config &&\n\t    (thread_pool_init(cs, &spawn_flag) < 0)) {\n\t\texit(1);\n\t}\n#endif\n\n\t/*\n\t *\tMove all of the thread calls to this file?\n\t *\n\t *\tIt may be best for the mutexes to be in this file...\n\t */\n\thave_children = spawn_flag;\n\n\tif (check_config) {\n\t\tDEBUG(\"%s: #### Skipping IP addresses and Ports ####\",\n\t\t       mainconfig.name);\n\t\treturn 1;\n\t}\n\n#ifdef WITH_SELF_PIPE\n\t/*\n\t *\tChild threads need a pipe to signal us, as do the\n\t *\tsignal handlers.\n\t */\n\tif (pipe(self_pipe) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error opening internal pipe: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\tif (fcntl(self_pipe[0], F_SETFL, O_NONBLOCK | FD_CLOEXEC) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error setting internal flags: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\tif (fcntl(self_pipe[1], F_SETFL, O_NONBLOCK | FD_CLOEXEC) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error setting internal flags: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (!fr_event_fd_insert(el, 0, self_pipe[0],\n\t\t\t\t  event_signal_handler, el)) {\n\t\tradlog(L_ERR, \"Failed creating handler for signals\");\n\t\texit(1);\n\t}\n#endif\t/* WITH_SELF_PIPE */\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tMark the proxy Fd's as unused.\n\t */\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < 32; i++) proxy_fds[i] = -1;\n\t}\n#endif\n\n       DEBUG(\"%s: #### Opening IP addresses and Ports ####\",\n\t       mainconfig.name);\n\n       /*\n\t*\tThe server temporarily switches to an unprivileged\n\t*\tuser very early in the bootstrapping process.\n\t*\tHowever, some sockets MAY require privileged access\n\t*\t(bind to device, or to port < 1024, or to raw\n\t*\tsockets).  Those sockets need to call suid up/down\n\t*\tthemselves around the functions that need a privileged\n\t*\tuid.\n\t*/\n\tif (listen_init(cs, &head) < 0) {\n\t\t_exit(1);\n\t}\n\t\n\t/*\n\t *\tAt this point, no one has any business *ever* going\n\t *\tback to root uid.\n\t */\n\tfr_suid_down_permanent();\n\n\t/*\n\t *\tAdd all of the sockets to the event loop.\n\t */\n\tfor (this = head;\n\t     this != NULL;\n\t     this = this->next) {\n\t\tchar buffer[256];\n\n\t\tthis->print(this, buffer, sizeof(buffer));\n\n\t\tswitch (this->type) {\n#ifdef WITH_DETAIL\n\t\tcase RAD_LISTEN_DETAIL:\n\t\t\tDEBUG(\"Listening on %s\", buffer);\n\n\t\t\t/*\n\t\t\t *\tDetail files are always known, and aren't\n\t\t\t *\tput into the socket event loop.\n\t\t\t */\n\t\t\tthis->status = RAD_LISTEN_STATUS_KNOWN;\n\n\t\t\t/*\n\t\t\t *\tSet up the first poll interval.\n\t\t\t */\n\t\t\tevent_poll_detail(this);\n\t\t\tbreak;\n#endif\n\n#ifdef WITH_PROXY\n\t\tcase RAD_LISTEN_PROXY:\n\t\t\trad_assert(proxy_fds[this->fd & 0x1f] == -1);\n\t\t\trad_assert(proxy_listeners[this->fd & 0x1f] == NULL);\n\t\t\t\n\t\t\tproxy_fds[this->fd & 0x1f] = this->fd;\n\t\t\tproxy_listeners[this->fd & 0x1f] = this;\n\t\t\tif (!fr_packet_list_socket_add(proxy_list,\n\t\t\t\t\t\t\t this->fd)) {\n\t\t\t\trad_assert(0 == 1);\n\t\t\t}\n\t\t\t/* FALL-THROUGH */\n#endif\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tevent_new_fd(this);\n\t}\n\n\tmainconfig.listen = head;\n\n\treturn 1;\n}\n\n\nstatic int request_hash_cb(UNUSED void *ctx, void *data)\n{\n\tREQUEST *request = fr_packet2myptr(REQUEST, packet, data);\n\n#ifdef WITH_PROXY\n\trad_assert(request->in_proxy_hash == FALSE);\n#endif\n\n\tev_request_free(&request);\n\n\treturn 0;\n}\n\n\n#ifdef WITH_PROXY\nstatic int proxy_hash_cb(UNUSED void *ctx, void *data)\n{\n\tREQUEST *request = fr_packet2myptr(REQUEST, proxy, data);\n\n\tev_request_free(&request);\n\n\treturn 0;\n}\n#endif\n\nvoid radius_event_free(void)\n{\n\t/*\n\t *\tFIXME: Stop all threads, or at least check that\n\t *\tthey're all waiting on the semaphore, and the queues\n\t *\tare empty.\n\t */\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tThere are requests in the proxy hash that aren't\n\t *\treferenced from anywhere else.  Remove them first.\n\t */\n\tif (proxy_list) {\n\t\tfr_packet_list_walk(proxy_list, NULL, proxy_hash_cb);\n\t\tfr_packet_list_free(proxy_list);\n\t\tproxy_list = NULL;\n\t}\n#endif\n\n\tfr_packet_list_walk(pl, NULL, request_hash_cb);\n\n\tfr_packet_list_free(pl);\n\tpl = NULL;\n\n\tfr_event_list_free(el);\n}\n\nint radius_event_process(void)\n{\n\tif (!el) return 0;\n\n\treturn fr_event_loop(el);\n}\n\nvoid radius_handle_request(REQUEST *request, RAD_REQUEST_FUNP fun)\n{\n\trequest->options = RAD_REQUEST_OPTION_DEBUG2;\n\n\tif (request_pre_handler(request)) {\n\t\trad_assert(fun != NULL);\n\t\trad_assert(request != NULL);\n\t\t\n\t\tif (request->server) RDEBUG(\"server %s {\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\"); \n\t\tfun(request);\n\n\t\tif (request->server) RDEBUG(\"} # server %s\",\n\t\t\t\t\t     request->server != NULL ?\n\t\t\t\t\t    request->server : \"\");\n\n\t\trequest_post_handler(request);\n\t}\n\n\tDEBUG2(\"Going to the next request\");\n\treturn;\n}\n"], "fixing_code": ["/*\n * event.c\tServer event handling\n *\n * Version:\t$Id$\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2007  The FreeRADIUS server project\n * Copyright 2007  Alan DeKok <aland@deployingradius.com>\n */\n\n#include <freeradius-devel/ident.h>\nRCSID(\"$Id$\")\n\n#include <freeradius-devel/radiusd.h>\n#include <freeradius-devel/modules.h>\n#include <freeradius-devel/event.h>\n#include <freeradius-devel/detail.h>\n\n#include <freeradius-devel/rad_assert.h>\n\n#include <signal.h>\n#include <fcntl.h>\n\n#ifdef HAVE_SYS_WAIT_H\n#\tinclude <sys/wait.h>\n#endif\n\n#define USEC (1000000)\n\nextern pid_t radius_pid;\nextern int dont_fork;\nextern int check_config;\nextern char *debug_condition;\n\n/*\n *\tRidiculous amounts of local state.\n */\nstatic fr_event_list_t\t*el = NULL;\nstatic fr_packet_list_t\t*pl = NULL;\nstatic int\t\t\trequest_num_counter = 0;\nstatic struct timeval\t\tnow;\ntime_t\t\t\t\tfr_start_time;\nstatic int\t\t\thave_children;\nstatic int\t\t\tjust_started = TRUE;\n\n#ifndef __MINGW32__\n#ifdef HAVE_PTHREAD_H\n#define WITH_SELF_PIPE (1)\n#endif\n#endif\n\n#ifdef WITH_SELF_PIPE\nstatic int self_pipe[2];\n#endif\n\n#ifdef HAVE_PTHREAD_H\n#ifdef WITH_PROXY\nstatic pthread_mutex_t\tproxy_mutex;\n#endif\n\n#define PTHREAD_MUTEX_LOCK if (have_children) pthread_mutex_lock\n#define PTHREAD_MUTEX_UNLOCK if (have_children) pthread_mutex_unlock\n\nstatic pthread_t NO_SUCH_CHILD_PID;\n#else\n/*\n *\tThis is easier than ifdef's throughout the code.\n */\n#define PTHREAD_MUTEX_LOCK(_x)\n#define PTHREAD_MUTEX_UNLOCK(_x)\nint thread_pool_addrequest(REQUEST *request, RAD_REQUEST_FUNP fun)\n{\n\tradius_handle_request(request, fun);\n\treturn 1;\n}\n#endif\n\n#define INSERT_EVENT(_function, _ctx) if (!fr_event_insert(el, _function, _ctx, &((_ctx)->when), &((_ctx)->ev))) { _rad_panic(__FILE__, __LINE__, \"Failed to insert event\"); }\n\n#ifdef WITH_PROXY\nstatic fr_packet_list_t *proxy_list = NULL;\n\n/*\n *\tWe keep the proxy FD's here.  The RADIUS Id's are marked\n *\t\"allocated\" per Id, via a bit per proxy FD.\n */\nstatic int\t\tproxy_all_used = FALSE;\nstatic int\t\tproxy_fds[32];\nstatic rad_listen_t\t*proxy_listeners[32];\nstatic void check_for_zombie_home_server(REQUEST *request);\nstatic void remove_from_proxy_hash(REQUEST *request);\n#else\n#define remove_from_proxy_hash(foo)\n#endif\n\nstatic void request_post_handler(REQUEST *request);\nstatic void wait_a_bit(void *ctx);\nstatic void event_socket_handler(fr_event_list_t *xel, UNUSED int fd, void *ctx);\n#ifdef WITH_DETAIL\nstatic void event_poll_detail(void *ctx);\n#endif\n\nstatic void NEVER_RETURNS _rad_panic(const char *file, unsigned int line,\n\t\t\t\t    const char *msg)\n{\n\tradlog(L_ERR, \"[%s:%d] %s\", file, line, msg);\n\t_exit(1);\n}\n\n#define rad_panic(x) _rad_panic(__FILE__, __LINE__, x)\n\n\nstatic void tv_add(struct timeval *tv, int usec_delay)\n{\n\tif (usec_delay > USEC) {\n\t\ttv->tv_sec += usec_delay / USEC;\n\t\tusec_delay %= USEC;\n\t}\n\ttv->tv_usec += usec_delay;\n\n\tif (tv->tv_usec > USEC) {\n\t\ttv->tv_sec += tv->tv_usec / USEC;\n\t\ttv->tv_usec %= USEC;\n\t}\n}\n\nstatic void remove_from_request_hash(REQUEST *request)\n{\n\tif (!request->in_request_hash) return;\n\n\tfr_packet_list_yank(pl, request->packet);\n\trequest->in_request_hash = FALSE;\n\n\trequest_stats_final(request);\n}\n\n\nstatic void ev_request_free(REQUEST **prequest)\n{\n\tREQUEST *request;\n\t\n\tif (!prequest || !*prequest) return;\n\n\trequest = *prequest;\n\n#ifdef WITH_COA\n\tif (request->coa) {\n\t\t/*\n\t\t *\tDivorce the child from the parent first,\n\t\t *\tthen clean up the child.\n\t\t */\n\t\trequest->coa->parent = NULL;\n\t\tev_request_free(&request->coa);\n\t}\n\n\t/*\n\t *\tDivorce the parent from the child, and leave the\n\t *\tparent still alive.\n\t */\n\tif (request->parent && (request->parent->coa == request)) {\n\t\trequest->parent->coa = NULL;\n\t}\n#endif\n\n\tif (request->ev) fr_event_delete(el, &request->ev);\n#ifdef WITH_PROXY\n\tif (request->in_proxy_hash) remove_from_proxy_hash(request);\n#endif\n\tif (request->in_request_hash) remove_from_request_hash(request);\n\n\trequest_free(prequest);\n}\n\n#ifdef WITH_PROXY\nstatic REQUEST *lookup_in_proxy_hash(RADIUS_PACKET *reply)\n{\n\tRADIUS_PACKET **proxy_p;\n\tREQUEST *request;\n\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\tproxy_p = fr_packet_list_find_byreply(proxy_list, reply);\n\n\tif (!proxy_p) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn NULL;\n\t}\n\n\trequest = fr_packet2myptr(REQUEST, proxy, proxy_p);\n\n\tif (!request) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn NULL;\n\t}\n\n\trequest->num_proxied_responses++;\n\n\t/*\n\t *\tCatch the most common case of everything working\n\t *\tcorrectly.\n\t */\n\tif (request->num_proxied_requests == request->num_proxied_responses) {\n\t\tfr_packet_list_yank(proxy_list, request->proxy);\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\trequest->in_proxy_hash = FALSE;\n\t}\n\n\t/*\n\t *\tOn the FIRST reply, decrement the count of outstanding\n\t *\trequests.  Note that this is NOT the count of sent\n\t *\tpackets, but whether or not the home server has\n\t *\tresponded at all.\n\t */\n\tif (!request->proxy_reply &&\n\t    request->home_server &&\n\t    request->home_server->currently_outstanding) {\n\t\trequest->home_server->currently_outstanding--;\n\t}\n\n\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\n\treturn request;\n}\n\n\nstatic void remove_from_proxy_hash(REQUEST *request)\n{\n\t/*\n\t *\tCheck this without grabbing the mutex because it's a\n\t *\tlot faster that way.\n\t */\n\tif (!request->in_proxy_hash) return;\n\n\t/*\n\t *\tThe \"not in hash\" flag is definitive.  However, if the\n\t *\tflag says that it IS in the hash, there might still be\n\t *\ta race condition where it isn't.\n\t */\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\n\tif (!request->in_proxy_hash) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn;\n\t}\n\n\tfr_packet_list_yank(proxy_list, request->proxy);\n\tfr_packet_list_id_free(proxy_list, request->proxy);\n\n\t/*\n\t *\tThe home server hasn't replied, but we've given up on\n\t *\tthis request.  Don't count this request against the\n\t *\thome server.\n\t */\n\tif (!request->proxy_reply &&\n\t    request->home_server &&\n\t    request->home_server->currently_outstanding) {\n\t\trequest->home_server->currently_outstanding--;\n\t}\n\n\t/*\n\t *\tGot from YES in hash, to NO, not in hash while we hold\n\t *\tthe mutex.  This guarantees that when another thread\n\t *\tgrans the mutex, the \"not in hash\" flag is correct.\n\t */\n\trequest->in_proxy_hash = FALSE;\n\n  \tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n}\n\nstatic int proxy_id_alloc(REQUEST *request, RADIUS_PACKET *packet)\n{\n\tint i, proxy, found;\n\trad_listen_t *proxy_listener;\n\n\tif (fr_packet_list_id_alloc(proxy_list, packet)) return 1;\n\n\tif (proxy_all_used) return 0;\n\n\t/*\n\t *\tAllocate a new proxy fd.  This function adds\n\t *\tit to the tail of the list of listeners.  With\n\t *\tsome care, this can be thread-safe.\n\t */\n\tproxy_listener = proxy_new_listener(&packet->src_ipaddr, FALSE);\n\tif (!proxy_listener) {\n\t\tradlog(L_PROXY, \"Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t *\tCache it locally.\n\t */\n\tfound = -1;\n\tproxy = proxy_listener->fd;\n\tfor (i = 0; i < 32; i++) {\n\t\t/*\n\t\t *\tFound a free entry.  Save the socket,\n\t\t *\tand remember where we saved it.\n\t\t */\n\t\tif (proxy_fds[(proxy + i) & 0x1f] == -1) {\n\t\t\tfound = (proxy + i) & 0x1f;\n\t\t\tproxy_fds[found] = proxy;\n\t\t\tproxy_listeners[found] = proxy_listener;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found < 0) {\n\t\tproxy_all_used = TRUE;\n\t\tlisten_free(&proxy_listener);\n\t\tradlog(L_ERR, \"Failed creating new proxy socket: server is too busy and home servers appear to be down\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (!fr_packet_list_socket_add(proxy_list, proxy_listener->fd)) {\n\t\t\tRDEBUG2(\"ERROR: Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t\t\n\t}\n\t\n\tif (!fr_packet_list_id_alloc(proxy_list, packet)) {\n\t\t\tRDEBUG2(\"ERROR: Failed to create a new socket for proxying requests.\");\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t *\tSignal the main thread to add the new FD to the list\n\t *\tof listening FD's.\n\t */\n\tradius_signal_self(RADIUS_SIGNAL_SELF_NEW_FD);\n\treturn 1;\n}\n\n\nstatic int insert_into_proxy_hash(REQUEST *request, int retransmit)\n{\n\tint i, proxy;\n\tchar buf[128];\n\n\trad_assert(request->proxy != NULL);\n\trad_assert(proxy_list != NULL);\n\n\tPTHREAD_MUTEX_LOCK(&proxy_mutex);\n\n\t/*\n\t *\tKeep track of maximum outstanding requests to a\n\t *\tparticular home server.  'max_outstanding' is\n\t *\tenforced in home_server_ldb(), in realms.c.\n\t */\n\tif (request->home_server) {\n\t\trequest->home_server->currently_outstanding++;\n\t}\n\n\tif (retransmit) {\n\t\tRADIUS_PACKET packet;\n\n\t\tpacket = *request->proxy;\n\n\t\tif (!proxy_id_alloc(request, &packet)) {\n\t\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tYank the request, free the old Id, and\n\t\t *\tremember the new Id.\n\t\t */\n\t\tfr_packet_list_yank(proxy_list, request->proxy);\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\t*request->proxy = packet;\n\n\t} else if (!proxy_id_alloc(request, request->proxy)) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\treturn 0;\n\t}\n\n\trad_assert(request->proxy->sockfd >= 0);\n\n\t/*\n\t *\tFIXME: Hack until we get rid of rad_listen_t, and put\n\t *\tthe information into the packet_list.\n\t */\n\tproxy = -1;\n\tfor (i = 0; i < 32; i++) {\n\t\tif (proxy_fds[i] == request->proxy->sockfd) {\n\t\t\tproxy = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (proxy < 0) {\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\tRDEBUG2(\"ERROR: All sockets are full.\");\n\t\treturn 0;\n\t}\n\n\trad_assert(proxy_fds[proxy] != -1);\n\trad_assert(proxy_listeners[proxy] != NULL);\n\trequest->proxy_listener = proxy_listeners[proxy];\n\n\tif (!fr_packet_list_insert(proxy_list, &request->proxy)) {\n\t\tfr_packet_list_id_free(proxy_list, request->proxy);\n\t\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\t\tRDEBUG2(\"ERROR: Failed to insert entry into proxy list\");\n\t\treturn 0;\n\t}\n\n\trequest->in_proxy_hash = TRUE;\n\n\tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);\n\n\tRDEBUG3(\" proxy: allocating destination %s port %d - Id %d\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr, buf, sizeof(buf)),\n\t       request->proxy->dst_port,\n\t       request->proxy->id);\n\n\treturn 1;\n}\n\n\n/*\n *\tCalled as BOTH an event, and in-line from other functions.\n */\nstatic void wait_for_proxy_id_to_expire(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->proxy != NULL);\n\n\tif (!fr_event_now(el, &now)) gettimeofday(&now, NULL);\n\trequest->when = request->proxy_when;\n\n#ifdef WITH_COA\n\tif (((request->proxy->code == PW_COA_REQUEST) ||\n\t     (request->proxy->code == PW_DISCONNECT_REQUEST)) &&\n\t    (request->packet->code != request->proxy->code)) {\n\t\trequest->when.tv_sec += request->home_server->coa_mrd;\n\t} else\n#endif\n\trequest->when.tv_sec += request->home_server->response_window;\n\n\tif ((request->num_proxied_requests == request->num_proxied_responses) ||\n\t    timercmp(&now, &request->when, >)) {\n\t\tif (request->packet) {\n\t\t\tRDEBUG2(\"Cleaning up request %u ID %d with timestamp +%d\",\n\t\t\t       request->number, request->packet->id,\n\t\t\t       (unsigned int) (request->timestamp - fr_start_time));\n\t\t} else {\n\t\t\tRDEBUG2(\"Cleaning up request %u with timestamp +%d\",\n\t\t\t       request->number,\n\t\t\t       (unsigned int) (request->timestamp - fr_start_time));\n\t\t}\n\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(wait_for_proxy_id_to_expire, request);\n}\n#endif\n\n#ifdef HAVE_PTHREAD_H\nstatic void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tremove_from_request_hash(request);\n\n\t/*\n\t *\tIf it's still queued (waiting for a thread to pick it\n\t *\tup) OR, it's running AND there's still a child thread\n\t *\thandling it, THEN delay some more.\n\t */\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\n\t\t/*\n\t\t *\tCap delay at max_request_time\n\t\t */\n\t\tif (request->delay < (USEC * request->root->max_request_time)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\trequest->delay = USEC * request->root->max_request_time;\n\t\t\tRDEBUG2(\"WARNING: Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\n\tev_request_free(&request);\n}\n#endif\n\nstatic void cleanup_delay(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert((request->child_state == REQUEST_CLEANUP_DELAY) ||\n\t\t   (request->child_state == REQUEST_DONE));\n\n\tremove_from_request_hash(request);\n\n#ifdef WITH_PROXY\n\tif (request->proxy && request->in_proxy_hash) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\n\tRDEBUG2(\"Cleaning up request %u ID %d with timestamp +%d\",\n\t       request->number, request->packet->id,\n\t       (unsigned int) (request->timestamp - fr_start_time));\n\n\tev_request_free(&request);\n}\n\n\n/*\n *\tIn daemon mode, AND this request has debug flags set.\n */\n#define DEBUG_PACKET if (!debug_flag && request->options && request->radlog) debug_packet\n\nstatic void debug_packet(REQUEST *request, RADIUS_PACKET *packet, int direction)\n{\n\tVALUE_PAIR *vp;\n\tchar buffer[1024];\n\tconst char *received, *from;\n\tconst fr_ipaddr_t *ip;\n\tint port;\n\n\tif (!packet) return;\n\n\trad_assert(request->radlog != NULL);\n\n\tif (direction == 0) {\n\t\treceived = \"Received\";\n\t\tfrom = \"from\";\t/* what else? */\n\t\tip = &packet->src_ipaddr;\n\t\tport = packet->src_port;\n\n\t} else {\n\t\treceived = \"Sending\";\n\t\tfrom = \"to\";\t/* hah! */\n\t\tip = &packet->dst_ipaddr;\n\t\tport = packet->dst_port;\n\t}\n\t\n\t/*\n\t *\tClient-specific debugging re-prints the input\n\t *\tpacket into the client log.\n\t *\n\t *\tThis really belongs in a utility library\n\t */\n\tif ((packet->code > 0) && (packet->code < FR_MAX_PACKET_CODE)) {\n\t\tRDEBUG(\"%s %s packet %s host %s port %d, id=%d, length=%d\",\n\t\t       received, fr_packet_codes[packet->code], from,\n\t\t       inet_ntop(ip->af, &ip->ipaddr, buffer, sizeof(buffer)),\n\t\t       port, packet->id, packet->data_len);\n\t} else {\n\t\tRDEBUG(\"%s packet %s host %s port %d code=%d, id=%d, length=%d\",\n\t\t       received, from,\n\t\t       inet_ntop(ip->af, &ip->ipaddr, buffer, sizeof(buffer)),\n\t\t       port,\n\t\t       packet->code, packet->id, packet->data_len);\n\t}\n\n\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\trequest->radlog(L_DBG, 0, request, \"\\t%s\", buffer);\n\t}\n}\n\nstatic void reject_delay(void *ctx)\n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_REJECT_DELAY);\n\n\tRDEBUG2(\"Sending delayed reject for request %u\", request->number);\n\n\tDEBUG_PACKET(request, request->reply, 1);\n\n\trequest->listener->send(request->listener, request);\n\n\trequest->when.tv_sec += request->root->cleanup_delay;\n\trequest->child_state = REQUEST_CLEANUP_DELAY;\n\n\tINSERT_EVENT(cleanup_delay, request);\n}\n\n\n#ifdef WITH_PROXY\nvoid revive_home_server(void *ctx)\n{\n\thome_server *home = ctx;\n\tchar buffer[128];\n\n\thome->state = HOME_STATE_ALIVE;\n\thome->currently_outstanding = 0;\n\thome->revive_time = now;\n\n\t/*\n\t *\tDelete any outstanding events.\n\t */\n\tif (home->ev) fr_event_delete(el, &home->ev);\n\n\tradlog(L_PROXY, \"Marking home server %s port %d alive again... we have no idea if it really is alive or not.\",\n\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       home->port);\n\n}\n\n\nstatic void no_response_to_ping(void *ctx)\n{\n\tREQUEST *request = ctx;\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->home_server != NULL);\n\n\thome = request->home_server;\n\thome->num_received_pings = 0;\n\n\tradlog(L_ERR, \"No response to status check %d for home server %s port %d\",\n\t       request->number,\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n\n\tcheck_for_zombie_home_server(request);\n\n\twait_for_proxy_id_to_expire(request);\n}\n\n\nstatic void received_response_to_ping(REQUEST *request)\n{\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->home_server != NULL);\n\n\thome = request->home_server;\n\thome->num_received_pings++;\n\n\tradlog(L_PROXY, \"Received response to status check %d (%d in current sequence)\",\n\t       request->number, home->num_received_pings);\n\n\t/*\n\t *\tRemove the request from any hashes\n\t */\n\tfr_event_delete(el, &request->ev);\n\tremove_from_proxy_hash(request);\n\trad_assert(request->in_request_hash == FALSE);\n\n\t/*\n\t *\tThe control socket may have marked the home server as\n\t *\talive.  OR, it may have suddenly started responding to\n\t *\trequests again.  If so, don't re-do the \"make alive\"\n\t *\twork.\n\t */\n\tif (home->state == HOME_STATE_ALIVE) return;\n\n\t/*\n\t *\tWe haven't received enough ping responses to mark it\n\t *\t\"alive\".  Wait a bit.\n\t */\n\tif (home->num_received_pings < home->num_pings_to_alive) {\n\t\treturn;\n\t}\n\n\thome->state = HOME_STATE_ALIVE;\n\thome->currently_outstanding = 0;\n\thome->revive_time = now;\n\n\tif (!fr_event_delete(el, &home->ev)) {\n\t\tRDEBUG2(\"Hmm... no event for home server.  Oh well.\");\n\t}\n\n\tradlog(L_PROXY, \"Marking home server %s port %d alive\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n}\n\n\n/*\n *\tCalled from start of zombie period, OR after control socket\n *\tmarks the home server dead.\n */\nstatic void ping_home_server(void *ctx)\n{\n\tuint32_t jitter;\n\thome_server *home = ctx;\n\tREQUEST *request;\n\tVALUE_PAIR *vp;\n\n\tif ((home->state == HOME_STATE_ALIVE) ||\n\t    (home->ping_check == HOME_PING_CHECK_NONE) ||\n\t    (home->ev != NULL)) {\n\t\treturn;\n\t}\n\n\trequest = request_alloc();\n\trequest->number = request_num_counter++;\n\n\trequest->proxy = rad_alloc(1);\n\trad_assert(request->proxy != NULL);\n\n\tfr_event_now(el, &request->when);\n\thome->when = request->when;\n\n\tif (home->ping_check == HOME_PING_CHECK_STATUS_SERVER) {\n\t\trequest->proxy->code = PW_STATUS_SERVER;\n\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Message-Authenticator\", \"0x00\", T_OP_SET);\n\n\t} else if (home->type == HOME_TYPE_AUTH) {\n\t\trequest->proxy->code = PW_AUTHENTICATION_REQUEST;\n\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Name\", home->ping_user_name, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Password\", home->ping_user_password, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Service-Type\", \"Authenticate-Only\", T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Message-Authenticator\", \"0x00\", T_OP_SET);\n\n\t} else {\n#ifdef WITH_ACCOUNTING\n\t\trequest->proxy->code = PW_ACCOUNTING_REQUEST;\n\t\t\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"User-Name\", home->ping_user_name, T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Acct-Status-Type\", \"Stop\", T_OP_SET);\n\t\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\t\"Acct-Session-Id\", \"00000000\", T_OP_SET);\n\t\tvp = radius_pairmake(request, &request->proxy->vps,\n\t\t\t\t     \"Event-Timestamp\", \"0\", T_OP_SET);\n\t\tvp->vp_date = now.tv_sec;\n#else\n\t\trad_assert(\"Internal sanity check failed\");\n#endif\n\t}\n\n\tradius_pairmake(request, &request->proxy->vps,\n\t\t\t\"NAS-Identifier\", \"Status Check. Are you alive?\",\n\t\t\tT_OP_SET);\n\n\trequest->proxy->dst_ipaddr = home->ipaddr;\n\trequest->proxy->dst_port = home->port;\n\trequest->home_server = home;\n\n\trad_assert(request->proxy_listener == NULL);\n\n\tif (!insert_into_proxy_hash(request, FALSE)) {\n\t\tRDEBUG2(\"ERROR: Failed inserting status check %d into proxy hash.  Discarding it.\",\n\t\t       request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\trad_assert(request->proxy_listener != NULL);\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\n\trequest->next_callback = NULL;\n\trequest->child_state = REQUEST_PROXIED;\n\tgettimeofday(&request->when, NULL);\n\thome->when = request->when;\n\trequest->when.tv_sec += home->ping_timeout;;\n\n\tINSERT_EVENT(no_response_to_ping, request);\n\n\t/*\n\t *\tAdd +/- 2s of jitter, as suggested in RFC 3539\n\t *\tand in the Issues and Fixes draft.\n\t */\n\thome->when.tv_sec += home->ping_interval - 2;\n\n\tjitter = fr_rand();\n\tjitter ^= (jitter >> 10);\n\tjitter &= ((1 << 23) - 1); /* 22 bits of 1 */\n\n\ttv_add(&home->when, jitter);\n\n\tINSERT_EVENT(ping_home_server, home);\n}\n\n\nvoid mark_home_server_dead(home_server *home, struct timeval *when)\n{\n\tint previous_state = home->state;\n\tchar buffer[128];\n\n\tradlog(L_PROXY, \"Marking home server %s port %d as dead.\",\n\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       home->port);\n\n\thome->state = HOME_STATE_IS_DEAD;\n\thome->num_received_pings = 0;\n\n\tif (home->ping_check != HOME_PING_CHECK_NONE) {\n\t\t/*\n\t\t *\tIf the control socket marks us dead, start\n\t\t *\tpinging.  Otherwise, we already started\n\t\t *\tpinging when it was marked \"zombie\".\n\t\t */\n\t\tif (previous_state == HOME_STATE_ALIVE) {\n\t\t\tping_home_server(home);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t *\tRevive it after a fixed period of time.  This\n\t\t *\tis very, very, bad.\n\t\t */\n\t\thome->when = *when;\n\t\thome->when.tv_sec += home->revive_interval;\n\n\t\tINSERT_EVENT(revive_home_server, home);\n\t}\n}\n\nstatic void check_for_zombie_home_server(REQUEST *request)\n{\n\thome_server *home;\n\tstruct timeval when;\n\n\thome = request->home_server;\n\n\tif (home->state != HOME_STATE_ZOMBIE) return;\n\n\twhen = home->zombie_period_start;\n\twhen.tv_sec += home->zombie_period;\n\n\tfr_event_now(el, &now);\n\tif (timercmp(&now, &when, <)) {\n\t\treturn;\n\t}\n\n\tmark_home_server_dead(home, &request->when);\n}\n\nstatic int proxy_to_virtual_server(REQUEST *request);\n\nstatic int virtual_server_handler(UNUSED REQUEST *request)\n{\n\tproxy_to_virtual_server(request);\n\treturn 0;\n}\n\nstatic void proxy_fallback_handler(REQUEST *request)\n{\n\t/*\n\t *\tA proper time is required for wait_a_bit.\n\t */\n\trequest->delay = USEC / 10;\n\tgettimeofday(&now, NULL);\n\trequest->next_when = now;\n\ttv_add(&request->next_when, request->delay);\n\trequest->next_callback = wait_a_bit;\n\n\t/*\n\t *\tRe-queue the request.\n\t */\n\trequest->child_state = REQUEST_QUEUED;\n\t\n\trad_assert(request->proxy != NULL);\n\tif (!thread_pool_addrequest(request, virtual_server_handler)) {\n\t\trequest->child_state = REQUEST_DONE;\n\t}\n\n#ifdef HAVE_PTHREAD_H\n\t/*\n\t *\tMAY free the request if we're over max_request_time,\n\t *\tAND we're not in threaded mode!\n\t *\n\t *\tNote that we call this ONLY if we're threaded, as\n\t *\tif we're NOT threaded, request_post_handler() calls\n\t *\twait_a_bit(), which means that \"request\" may not\n\t *\texist any more...\n\t */\n\tif (have_children) wait_a_bit(request);\n#endif\n}\n\n\nstatic int setup_post_proxy_fail(REQUEST *request)\n{\n\tDICT_VALUE *dval = NULL;\n\tVALUE_PAIR *vp;\n\n\trequest->child_state = REQUEST_RUNNING;\n\n\tif (request->packet->code == PW_AUTHENTICATION_REQUEST) {\n\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Authentication\");\n\n\t} else if (request->packet->code == PW_ACCOUNTING_REQUEST) {\n\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Accounting\");\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tSee no_response_to_coa_request\n\t\t */\n\t} else if (((request->packet->code >> 8) & 0xff) == PW_COA_REQUEST) {\n\t\trequest->packet->code &= 0xff; /* restore it */\n\n\t\tif (request->proxy->code == PW_COA_REQUEST) {\n\t\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-CoA\");\n\n\t\t} else if (request->proxy->code == PW_DISCONNECT_REQUEST) {\n\t\t\tdval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail-Disconnect\");\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n#endif\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (!dval) dval = dict_valbyname(PW_POST_PROXY_TYPE, \"Fail\");\n\n\tif (!dval) {\n\t\tpairdelete(&request->config_items, PW_POST_PROXY_TYPE);\n\t\treturn 0;\n\t}\n\n\tvp = pairfind(request->config_items, PW_POST_PROXY_TYPE);\n\tif (!vp) vp = radius_paircreate(request, &request->config_items,\n\t\t\t\t\tPW_POST_PROXY_TYPE, PW_TYPE_INTEGER);\n\tvp->vp_integer = dval->value;\n\n\trad_assert(request->proxy_reply == NULL);\n\n\treturn 1;\n}\n\n\nstatic int null_handler(UNUSED REQUEST *request)\n{\n\treturn 0;\n}\n\nstatic void post_proxy_fail_handler(REQUEST *request)\n{\n\t/*\n\t *\tA proper time is required for wait_a_bit.\n\t */\n\trequest->delay = USEC / 10;\n\tgettimeofday(&now, NULL);\n\n\t/*\n\t *\tNot set up to run Post-Proxy-Type = Fail.\n\t *\n\t *\tMark the request as still running, and figure out what\n\t *\tto do next.\n\t */\n\tif (!setup_post_proxy_fail(request)) {\n\t\trequest_post_handler(request);\n\n\t} else {\n\t\t/*\n\t\t *\tRe-queue the request.\n\t\t */\n\t\trequest->child_state = REQUEST_QUEUED;\n\n\t\t/*\n\t\t *\tThere is a post-proxy-type of fail.  We run\n\t\t *\tthe request through the pre/post proxy\n\t\t *\thandlers, just like it was a real proxied\n\t\t *\trequest.  However, we set the per-request\n\t\t *\thandler to NULL, as we don't want to do\n\t\t *\tanything else.\n\t\t *\n\t\t *\tNote that when we're not threaded, this will\n\t\t *\tprocess the request even if it's greater than\n\t\t *\tmax_request_time.  That's not fatal.\n\t\t */\n\t\trequest->priority = 0;\n\t\trad_assert(request->proxy != NULL);\n\t\tthread_pool_addrequest(request, null_handler);\n\t}\n\n\t/*\n\t *\tMAY free the request if we're over max_request_time,\n\t *\tAND we're not in threaded mode!\n\t *\n\t *\tNote that we call this ONLY if we're threaded, as\n\t *\tif we're NOT threaded, request_post_handler() calls\n\t *\twait_a_bit(), which means that \"request\" may not\n\t *\texist any more...\n\t */\n\tif (have_children) wait_a_bit(request);\n}\n\n\n/* maybe check this against wait_for_proxy_id_to_expire? */\nstatic void no_response_to_proxied_request(void *ctx)\n{\n\tREQUEST *request = ctx;\n\thome_server *home;\n\tchar buffer[128];\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\n\t/*\n\t *\tIf we've failed over to an internal home server,\n\t *\treplace the callback with the correct one.  This\n\t *\tis due to locking issues with child threads...\n\t */\n\tif (request->home_server->server) {\n\t\twait_a_bit(request);\n\t\treturn;\n\t}\n\n\tcheck_for_zombie_home_server(request);\n\n\thome = request->home_server;\n\n\t/*\n\t *\tThe default as of 2.1.7 is to allow requests to\n\t *\tfail-over to a backup home server when this one does\n\t *\tnot respond.  The old behavior can be configured as\n\t *\twell.\n\t */\n\tif (home->no_response_fail) {\n\t\tradlog(L_ERR, \"Rejecting request %u (proxy Id %d) due to lack of any response from home server %s port %d\",\n\t\t       request->number, request->proxy->id,\n\t\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       request->proxy->dst_port);\n\n\t\tpost_proxy_fail_handler(request);\n\t} else {\n\t\trad_assert(request->ev == NULL);\n\t\trequest->child_state = REQUEST_RUNNING;\n\t\twait_a_bit(request);\n\t}\n\n\t/*\n\t *\tDon't touch request due to race conditions\n\t */\n\tif (home->state == HOME_STATE_IS_DEAD) {\n\t\trad_assert(home->ev != NULL); /* or it will never wake up */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tEnable the zombie period when we notice that the home\n\t *\tserver hasn't responded.  We do NOT back-date the start\n\t *\tof the zombie period.\n\t */\n\tif (home->state == HOME_STATE_ALIVE) {\n\t\thome->state = HOME_STATE_ZOMBIE;\n\t\thome->zombie_period_start = now;\t\n\t\tfr_event_delete(el, &home->ev);\n\t\thome->currently_outstanding = 0;\n\t\thome->num_received_pings = 0;\n\n\t\tradlog(L_PROXY, \"Marking home server %s port %d as zombie (it looks like it is dead).\",\n\t\t       inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       home->port);\n\n\t\t/*\n\t\t *\tStart pinging the home server.\n\t\t */\n\t\tping_home_server(home);\n\t}\n}\n#endif\n\nstatic void wait_a_bit(void *ctx)\n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\t/*\n\t\t *\tIf we're not thread-capable, OR we're capable,\n\t\t *\tbut have been told to run without threads,\n\t\t *\tcomplain when the requests is queued for a\n\t\t *\tthread, or running in a child thread.\n\t\t */\n#ifdef HAVE_PTHREAD_H\n\t\tif (!have_children)\n#endif\n\t\t{\n\t\t\trad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);\n\t\t\tbreak;\n\t\t}\n\n#ifdef HAVE_PTHREAD_H\n\t\t/*\n\t\t *\tIf we have threads, wait for the child thread\n\t\t *\tto stop.\n\t\t */\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <)) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n\t\t\t/*\n\t\t\t *\tCap delays at something reasonable.\n\t\t\t */\n\t\t\tif (request->delay > (request->root->max_request_time * USEC)) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t}\n\t\t\t\n\t\trequest->delay = USEC;\n\t\ttv_add(&request->when, request->delay);\n\t\tcallback = wait_for_child_to_die;\n\t\tbreak;\n#endif\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}\n\n#ifdef WITH_COA\nstatic void no_response_to_coa_request(void *ctx)\n{\n\tREQUEST *request = ctx;\n\tchar buffer[128];\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\trad_assert(request->home_server != NULL);\n\trad_assert(!request->in_request_hash);\n\n\tradlog(L_ERR, \"No response to CoA request sent to %s\",\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)));\n\n\t/*\n\t *\tHack.\n\t */\n\trequest->packet->code |= (PW_COA_REQUEST << 8);\n\tpost_proxy_fail_handler(request);\n}\n\n\nstatic int update_event_timestamp(RADIUS_PACKET *packet, time_t when)\n{\n\tVALUE_PAIR *vp;\n\n\tvp = pairfind(packet->vps, PW_EVENT_TIMESTAMP);\n\tif (!vp) return 0;\n\n\tvp->vp_date = when;\n\n\tif (packet->data) {\n\t\tfree(packet->data);\n\t\tpacket->data = NULL;\n\t\tpacket->data_len = 0;\n\t}\n\n\treturn 1;\t\t/* time stamp updated */\n}\n\n\n/*\n *\tCalled when we haven't received a response to a CoA request.\n */\nstatic void retransmit_coa_request(void *ctx)\n{\n\tint delay, frac;\n\tstruct timeval mrd;\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->child_state == REQUEST_PROXIED);\n\trad_assert(request->home_server != NULL);\n\trad_assert(!request->in_request_hash);\n\trad_assert(request->parent == NULL);\n\t\n\tfr_event_now(el, &now);\n\n\t/*\n\t *\tCap count at MRC, if it is non-zero.\n\t */\n\tif (request->home_server->coa_mrc &&\n\t    (request->num_coa_requests >= request->home_server->coa_mrc)) {\n\t\tno_response_to_coa_request(request);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tRFC 5080 Section 2.2.1\n\t *\n\t *\tRT = 2*RTprev + RAND*RTprev\n\t *\t   = 1.9 * RTprev + rand(0,.2) * RTprev\n\t *\t   = 1.9 * RTprev + rand(0,1) * (RTprev / 5)\n\t */\n\tdelay = fr_rand();\n\tdelay ^= (delay >> 16);\n\tdelay &= 0xffff;\n\tfrac = request->delay / 5;\n\tdelay = ((frac >> 16) * delay) + (((frac & 0xffff) * delay) >> 16);\n\n\tdelay += (2 * request->delay) - (request->delay / 10);\n\n\t/*\n\t *\tCap delay at MRT, if MRT is non-zero.\n\t */\n\tif (request->home_server->coa_mrt &&\n\t    (delay > (request->home_server->coa_mrt * USEC))) {\n\t\tint mrt_usec = request->home_server->coa_mrt * USEC;\n\n\t\t/*\n\t\t *\tdelay = MRT + RAND * MRT\n\t\t *\t      = 0.9 MRT + rand(0,.2)  * MRT\n\t\t */\n\t\tdelay = fr_rand();\n\t\tdelay ^= (delay >> 15);\n\t\tdelay &= 0x1ffff;\n\t\tdelay = ((mrt_usec >> 16) * delay) + (((mrt_usec & 0xffff) * delay) >> 16);\n\t\tdelay += mrt_usec - (mrt_usec / 10);\n\t}\n\n\trequest->delay = delay;\n\trequest->when = now;\n\ttv_add(&request->when, request->delay);\n\tmrd = request->proxy_when;\n\tmrd.tv_sec += request->home_server->coa_mrd;\n\n\t/*\n\t *\tCap duration at MRD.\n\t */\n\tif (timercmp(&mrd, &request->when, <)) {\n\t\trequest->when = mrd;\n\t\tINSERT_EVENT(no_response_to_coa_request, request);\n\n\t} else {\n\t\tINSERT_EVENT(retransmit_coa_request, request);\n\t}\n\t\n\tif (update_event_timestamp(request->proxy, now.tv_sec)) {\n\t\tif (!insert_into_proxy_hash(request, TRUE)) {\n\t\t\tDEBUG(\"ERROR: Failed re-inserting CoA request into proxy hash.\");\n\t\t\treturn;\n\t\t}\n\n\t\trequest->num_proxied_requests = 0;\n\t\trequest->num_proxied_responses = 0;\n\t}\n\n\trequest->num_proxied_requests++;\n\trequest->num_coa_requests++; /* is NOT reset by code 3 lines above! */\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n}\n\n\n/*\n *\tThe original request is either DONE, or in CLEANUP_DELAY.\n */\nstatic int originated_coa_request(REQUEST *request)\n{\n\tint delay, rcode, pre_proxy_type = 0;\n\tVALUE_PAIR *vp;\n\tREQUEST *coa;\n\tfr_ipaddr_t ipaddr;\n\tchar buffer[256];\n\n\trad_assert(request->proxy == NULL);\n\trad_assert(!request->in_proxy_hash);\n\trad_assert(request->proxy_reply == NULL);\n\n\t/*\n\t *\tCheck whether we want to originate one, or cancel one.\n\t */\n\tvp = pairfind(request->config_items, PW_SEND_COA_REQUEST);\n\tif (!vp && request->coa) {\n\t\tvp = pairfind(request->coa->proxy->vps, PW_SEND_COA_REQUEST);\n\t}\n\n\tif (vp) {\n\t\tif (vp->vp_integer == 0) {\n\t\t\tev_request_free(&request->coa);\n\t\t\treturn 1;\t/* success */\n\t\t}\n\t}\n\n\tif (!request->coa) request_alloc_coa(request);\n\tif (!request->coa) return 0;\n\n\tcoa = request->coa;\n\n\t/*\n\t *\tsrc_ipaddr will be set up in proxy_encode.\n\t */\n\tmemset(&ipaddr, 0, sizeof(ipaddr));\n\tvp = pairfind(coa->proxy->vps, PW_PACKET_DST_IP_ADDRESS);\n\tif (vp) {\n\t\tipaddr.af = AF_INET;\n\t\tipaddr.ipaddr.ip4addr.s_addr = vp->vp_ipaddr;\n\n\t} else if ((vp = pairfind(coa->proxy->vps,\n\t\t\t\t  PW_PACKET_DST_IPV6_ADDRESS)) != NULL) {\n\t\tipaddr.af = AF_INET6;\n\t\tipaddr.ipaddr.ip6addr = vp->vp_ipv6addr;\n\t\t\n\t} else if ((vp = pairfind(coa->proxy->vps,\n\t\t\t\t  PW_HOME_SERVER_POOL)) != NULL) {\n\t\tcoa->home_pool = home_pool_byname(vp->vp_strvalue,\n\t\t\t\t\t\t  HOME_TYPE_COA);\n\t\tif (!coa->home_pool) {\n\t\t\tRDEBUG2(\"WARNING: No such home_server_pool %s\",\n\t\t\t       vp->vp_strvalue);\n\tfail:\n\t\t\tev_request_free(&request->coa);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tPrefer\n\t\t */\n\t} else if (request->client->coa_pool) {\n\t\tcoa->home_pool = request->client->coa_pool;\n\n\t} else if (request->client->coa_server) {\n\t\tcoa->home_server = request->client->coa_server;\n\n\t} else {\n\t\t/*\n\t\t *\tIf all else fails, send it to the client that\n\t\t *\toriginated this request.\n\t\t */\n\t\tmemcpy(&ipaddr, &request->packet->src_ipaddr, sizeof(ipaddr));\n\t}\n\n\t/*\n\t *\tUse the pool, if it exists.\n\t */\n\tif (coa->home_pool) {\n\t\tcoa->home_server = home_server_ldb(NULL, coa->home_pool, coa);\n\t\tif (!coa->home_server) {\n\t\t\tRDEBUG(\"WARNING: No live home server for home_server_pool %s\", vp->vp_strvalue);\n\t\t\tgoto fail;\n\t\t}\n\n\t} else if (!coa->home_server) {\n\t\tint port = PW_COA_UDP_PORT;\n\n\t\tvp = pairfind(coa->proxy->vps, PW_PACKET_DST_PORT);\n\t\tif (vp) port = vp->vp_integer;\n\n\t\tcoa->home_server = home_server_find(&ipaddr, port);\n\t\tif (!coa->home_server) {\n\t\t\tRDEBUG2(\"WARNING: Unknown destination %s:%d for CoA request.\",\n\t\t\t       inet_ntop(ipaddr.af, &ipaddr.ipaddr,\n\t\t\t\t\t buffer, sizeof(buffer)), port);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvp = pairfind(coa->proxy->vps, PW_PACKET_TYPE);\n\tif (vp) {\n\t\tswitch (vp->vp_integer) {\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tcoa->proxy->code = vp->vp_integer;\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tDEBUG(\"Cannot set CoA Packet-Type to code %d\",\n\t\t\t      vp->vp_integer);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!coa->proxy->code) coa->proxy->code = PW_COA_REQUEST;\n\n\t/*\n\t *\tThe rest of the server code assumes that\n\t *\trequest->packet && request->reply exist.  Copy them\n\t *\tfrom the original request.\n\t */\n\trad_assert(coa->packet != NULL);\n\trad_assert(coa->packet->vps == NULL);\n\tmemcpy(coa->packet, request->packet, sizeof(*request->packet));\n\tcoa->packet->vps = paircopy(request->packet->vps);\n\tcoa->packet->data = NULL;\n\trad_assert(coa->reply != NULL);\n\trad_assert(coa->reply->vps == NULL);\n\tmemcpy(coa->reply, request->reply, sizeof(*request->reply));\n\tcoa->reply->vps = paircopy(request->reply->vps);\n\tcoa->reply->data = NULL;\n\tcoa->config_items = paircopy(request->config_items);\n\n\t/*\n\t *\tCall the pre-proxy routines.\n\t */\n\tvp = pairfind(request->config_items, PW_PRE_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Pre-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpre_proxy_type = vp->vp_integer;\n\t}\n\n\tif (coa->home_pool && coa->home_pool->virtual_server) {\n\t\tconst char *old_server = coa->server;\n\t\t\n\t\tcoa->server = coa->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", coa->server);\n\t\trcode = module_pre_proxy(pre_proxy_type, coa);\n\t\tRDEBUG2(\" }\");\n\t\tcoa->server = old_server;\n\t} else {\n\t\trcode = module_pre_proxy(pre_proxy_type, coa);\n\t}\n\tswitch (rcode) {\n\tdefault:\n\t\tgoto fail;\n\n\t/*\n\t *\tOnly send the CoA packet if the pre-proxy code succeeded.\n\t */\n\tcase RLM_MODULE_NOOP:\n\tcase RLM_MODULE_OK:\n\tcase RLM_MODULE_UPDATED:\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tSource IP / port is set when the proxy socket\n\t *\tis chosen.\n\t */\n\tcoa->proxy->dst_ipaddr = coa->home_server->ipaddr;\n\tcoa->proxy->dst_port = coa->home_server->port;\n\n\tif (!insert_into_proxy_hash(coa, FALSE)) {\n\t\tDEBUG(\"ERROR: Failed inserting CoA request into proxy hash.\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t *\tWe CANNOT divorce the CoA request from the parent\n\t *\trequest.  This function is running in a child thread,\n\t *\tand we need access to the main event loop in order to\n\t *\tto add the timers for the CoA packet.  See\n\t *\twait_a_bit().\n\t */\n\n\t/*\n\t *\tForget about the original request completely at this\n\t *\tpoint.\n\t */\n\trequest = coa;\n\n\tgettimeofday(&request->proxy_when, NULL);\t\n\trequest->received = request->next_when = request->proxy_when;\n\trad_assert(request->proxy_reply == NULL);\n\n\t/*\n\t *\tImplement re-transmit algorithm as per RFC 5080\n\t *\tSection 2.2.1.\n\t *\n\t *\tWe want IRT + RAND*IRT\n\t *\tor 0.9 IRT + rand(0,.2) IRT\n\t *\n\t *\t2^20 ~ USEC, and we want 2.\n\t *\trand(0,0.2) USEC ~ (rand(0,2^21) / 10)\n\t */\n\tdelay = (fr_rand() & ((1 << 22) - 1)) / 10;\n\trequest->delay = delay * request->home_server->coa_irt;\n\tdelay = request->home_server->coa_irt * USEC;\n\tdelay -= delay / 10;\n\tdelay += request->delay;\n     \n\trequest->delay = delay;\n\ttv_add(&request->next_when, delay);\n\trequest->next_callback = retransmit_coa_request;\n\t\n\t/*\n\t *\tNote that we set proxied BEFORE sending the packet.\n\t *\n\t *\tOnce we send it, the request is tainted, as\n\t *\tanother thread may have picked it up.  Don't\n\t *\ttouch it!\n\t */\n\trequest->num_proxied_requests = 1;\n\trequest->num_proxied_responses = 0;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n\tupdate_event_timestamp(request->proxy, request->proxy_when.tv_sec);\n\n\trequest->child_state = REQUEST_PROXIED;\n\n\tDEBUG_PACKET(request, request->proxy, 1);\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\treturn 1;\n}\n#endif\t/* WITH_COA */\n\n#ifdef WITH_PROXY\nstatic int process_proxy_reply(REQUEST *request)\n{\n\tint rcode;\n\tint post_proxy_type = 0;\n\tVALUE_PAIR *vp;\n\t\n\t/*\n\t *\tDelete any reply we had accumulated until now.\n\t */\n\tpairfree(&request->reply->vps);\n\t\n\t/*\n\t *\tRun the packet through the post-proxy stage,\n\t *\tBEFORE playing games with the attributes.\n\t */\n\tvp = pairfind(request->config_items, PW_POST_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Post-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpost_proxy_type = vp->vp_integer;\n\t}\n\t\n\tif (request->home_pool && request->home_pool->virtual_server) {\n\t\tconst char *old_server = request->server;\n\t\t\n\t\trequest->server = request->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", request->server);\n\t\trcode = module_post_proxy(post_proxy_type, request);\n\t\tRDEBUG2(\" }\");\n\t\trequest->server = old_server;\n\t} else {\n\t\trcode = module_post_proxy(post_proxy_type, request);\n\t}\n\n#ifdef WITH_COA\n\tif (request->packet->code == request->proxy->code)\n\t  /*\n\t   *\tDon't run the next bit if we originated a CoA\n\t   *\tpacket, after receiving an Access-Request or\n\t   *\tAccounting-Request.\n\t   */\n#endif\n\t\n\t/*\n\t *\tThere may NOT be a proxy reply, as we may be\n\t *\trunning Post-Proxy-Type = Fail.\n\t */\n\tif (request->proxy_reply) {\n\t\t/*\n\t\t *\tDelete the Proxy-State Attributes from\n\t\t *\tthe reply.  These include Proxy-State\n\t\t *\tattributes from us and remote server.\n\t\t */\n\t\tpairdelete(&request->proxy_reply->vps, PW_PROXY_STATE);\n\t\t\n\t\t/*\n\t\t *\tAdd the attributes left in the proxy\n\t\t *\treply to the reply list.\n\t\t */\n\t\tpairadd(&request->reply->vps, request->proxy_reply->vps);\n\t\trequest->proxy_reply->vps = NULL;\n\t\t\n\t\t/*\n\t\t *\tFree proxy request pairs.\n\t\t */\n\t\tpairfree(&request->proxy->vps);\n\t}\n\t\n\tswitch (rcode) {\n\tdefault:  /* Don't do anything */\n\t\tbreak;\n\tcase RLM_MODULE_FAIL:\n\t\t/* FIXME: debug print stuff */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t\t\n\tcase RLM_MODULE_HANDLED:\n\t\t/* FIXME: debug print stuff */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n#endif\n\nstatic int request_pre_handler(REQUEST *request)\n{\n\tint rcode;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert(request->packet != NULL);\n\n\trequest->child_state = REQUEST_RUNNING;\n\n\t/*\n\t *\tDon't decode the packet if it's an internal \"fake\"\n\t *\trequest.  Instead, just return so that the caller can\n\t *\tprocess it.\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\trequest->username = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_NAME);\n\t\trequest->password = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_PASSWORD);\n\t\treturn 1;\n\t}\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tPut the decoded packet into it's proper place.\n\t */\n\tif (request->proxy_reply != NULL) {\n\t\trcode = request->proxy_listener->decode(request->proxy_listener,\n\t\t\t\t\t\t\trequest);\n\t\tDEBUG_PACKET(request, request->proxy_reply, 0);\n\t} else\n#endif\n\tif (request->packet->vps == NULL) {\n\t\trcode = request->listener->decode(request->listener, request);\n\t\t\n\t\tif (debug_condition) {\n\t\t\tint result = FALSE;\n\t\t\tconst char *my_debug = debug_condition;\n\n\t\t\t/*\n\t\t\t *\tIgnore parse errors.\n\t\t\t */\n\t\t\tradius_evaluate_condition(request, RLM_MODULE_OK, 0,\n\t\t\t\t\t\t  &my_debug, 1,\n\t\t\t\t\t\t  &result);\n\t\t\tif (result) {\n\t\t\t\trequest->options = 2;\n\t\t\t\trequest->radlog = radlog_request;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDEBUG_PACKET(request, request->packet, 0);\n\t} else {\n\t\trcode = 0;\n\t}\n\n\tif (rcode < 0) {\n\t\tRDEBUG(\"%s Dropping packet without response.\", fr_strerror());\n\t\trequest->reply->offset = -2; /* bad authenticator */\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn 0;\n\t}\n\n\tif (!request->username) {\n\t\trequest->username = pairfind(request->packet->vps,\n\t\t\t\t\t     PW_USER_NAME);\n\t}\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\treturn process_proxy_reply(request);\n\t}\n#endif\n\n\treturn 1;\n}\n\n\n#ifdef WITH_PROXY\n/*\n *\tDo state handling when we proxy a request.\n */\nstatic int proxy_request(REQUEST *request)\n{\n\tstruct timeval when;\n\tchar buffer[128];\n\n#ifdef WITH_COA\n\tif (request->coa) {\n\t\tRDEBUG(\"WARNING: Cannot proxy and originate CoA packets at the same time.  Cancelling CoA request\");\n\t\tev_request_free(&request->coa);\n\t}\n#endif\n\n\tif (request->home_server->server) {\n\t\tRDEBUG(\"ERROR: Cannot perform real proxying to a virtual server.\");\n\t\treturn 0;\n\t}\n\n\tif (!insert_into_proxy_hash(request, FALSE)) {\n\t\tRDEBUG(\"ERROR: Failed inserting request into proxy hash.\");\n\t\treturn 0;\n\t}\n\n\trequest->proxy_listener->encode(request->proxy_listener, request);\n\n\twhen = request->received;\n\twhen.tv_sec += request->root->max_request_time;\n\n\tgettimeofday(&request->proxy_when, NULL);\n\n\trequest->next_when = request->proxy_when;\n\trequest->next_when.tv_sec += request->home_server->response_window;\n\n\trad_assert(request->home_server->response_window > 0);\n\n\tif (timercmp(&when, &request->next_when, <)) {\n\t\trequest->next_when = when;\n\t}\n\trequest->next_callback = no_response_to_proxied_request;\n\n\tRDEBUG2(\"Proxying request %u to home server %s port %d\",\n\t       request->number,\n\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t buffer, sizeof(buffer)),\n\t       request->proxy->dst_port);\n\n\t/*\n\t *\tNote that we set proxied BEFORE sending the packet.\n\t *\n\t *\tOnce we send it, the request is tainted, as\n\t *\tanother thread may have picked it up.  Don't\n\t *\ttouch it!\n\t */\n\trequest->num_proxied_requests = 1;\n\trequest->num_proxied_responses = 0;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\trequest->child_state = REQUEST_PROXIED;\n\n\tDEBUG_PACKET(request, request->proxy, 1);\n\n\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t      request);\n\treturn 1;\n}\n\n\n/*\n *\t\"Proxy\" the request by sending it to a new virtual server.\n */\nstatic int proxy_to_virtual_server(REQUEST *request)\n{\n\tREQUEST *fake;\n\tRAD_REQUEST_FUNP fun;\n\n\tif (!request->home_server || !request->home_server->server) return 0;\n\n\tif (request->parent) {\n\t\tRDEBUG2(\"WARNING: Cancelling proxy request to virtual server %s as this request was itself proxied.\", request->home_server->server);\n\t\treturn 0;\n\t}\n\n\tfake = request_alloc_fake(request);\n\tif (!fake) {\n\t\tRDEBUG2(\"WARNING: Out of memory\");\n\t\treturn 0;\n\t}\n\n\tfake->packet->vps = paircopy(request->proxy->vps);\n\tfake->server = request->home_server->server;\n\n\tif (request->proxy->code == PW_AUTHENTICATION_REQUEST) {\n\t\tfun = rad_authenticate;\n\n#ifdef WITH_ACCOUNTING\n\t} else if (request->proxy->code == PW_ACCOUNTING_REQUEST) {\n\t\tfun = rad_accounting;\n#endif\n\n\t} else {\n\t\tRDEBUG2(\"Unknown packet type %d\", request->proxy->code);\n\t\tev_request_free(&fake);\n\t\treturn 0;\n\t}\n\n\tRDEBUG2(\">>> Sending proxied request internally to virtual server.\");\n\tradius_handle_request(fake, fun);\n\tRDEBUG2(\"<<< Received proxied response code %d from internal virtual server.\", fake->reply->code);\n\n\tif (fake->reply->code != 0) {\n\t\trequest->proxy_reply = fake->reply;\n\t\tfake->reply = NULL;\n\t} else {\n\t\t/*\n\t\t *\tThere was no response\n\t\t */\n\t\tsetup_post_proxy_fail(request);\n\t}\n\n\tev_request_free(&fake);\n\n\tprocess_proxy_reply(request);\n\n\t/*\n\t *\tProcess it through the normal section again, but ONLY\n\t *\tif we received a proxy reply..\n\t */\n\tif (request->proxy_reply) {\n\t\tif (request->server) RDEBUG(\"server %s {\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\"); \n\t\tfun(request);\n\t\t\n\t\tif (request->server) RDEBUG(\"} # server %s\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\");\n\t}\n\n\treturn 2;\t\t/* success, but NOT '1' !*/\n}\n\n/*\n *\tReturn 1 if we did proxy it, or the proxy attempt failed\n *\tcompletely.  Either way, the caller doesn't touch the request\n *\tany more if we return 1.\n */\nstatic int successfully_proxied_request(REQUEST *request)\n{\n\tint rcode;\n\tint pre_proxy_type = 0;\n\tVALUE_PAIR *realmpair;\n\tVALUE_PAIR *strippedname;\n\tVALUE_PAIR *vp;\n\tchar *realmname = NULL;\n\thome_server *home;\n\tREALM *realm = NULL;\n\thome_pool_t *pool;\n\n\t/*\n\t *\tIf it was already proxied, do nothing.\n\t *\n\t *\tFIXME: This should really be a serious error.\n\t */\n\tif (request->in_proxy_hash ||\n\t    (request->proxy_reply && (request->proxy_reply->code != 0))) {\n\t\treturn 0;\n\t}\n\n\trealmpair = pairfind(request->config_items, PW_PROXY_TO_REALM);\n\tif (!realmpair || (realmpair->length == 0)) {\n\t\tint pool_type;\n\n\t\tvp = pairfind(request->config_items, PW_HOME_SERVER_POOL);\n\t\tif (!vp) return 0;\n\n\t\tswitch (request->packet->code) {\n\t\tcase PW_AUTHENTICATION_REQUEST:\n\t\t\tpool_type = HOME_TYPE_AUTH;\n\t\t\tbreak;\n\n#ifdef WITH_ACCOUNTING\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tpool_type = HOME_TYPE_ACCT;\n\t\t\tbreak;\n#endif\n\n#ifdef WITH_COA\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tpool_type = HOME_TYPE_COA;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tpool = home_pool_byname(vp->vp_strvalue, pool_type);\n\t\tif (!pool) {\n\t\t\tRDEBUG2(\"ERROR: Cannot proxy to unknown pool %s\",\n\t\t\t\tvp->vp_strvalue);\n\t\t\treturn 0;\n\t\t}\n\n\t\trealmname = NULL; /* no realms */\n\t\trealm = NULL;\n\t\tgoto found_pool;\n\t}\n\n\trealmname = (char *) realmpair->vp_strvalue;\n\n\trealm = realm_find2(realmname);\n\tif (!realm) {\n\t\tRDEBUG2(\"ERROR: Cannot proxy to unknown realm %s\", realmname);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tFigure out which pool to use.\n\t */\n\tif (request->packet->code == PW_AUTHENTICATION_REQUEST) {\n\t\tpool = realm->auth_pool;\n\n#ifdef WITH_ACCOUNTING\n\t} else if (request->packet->code == PW_ACCOUNTING_REQUEST) {\n\t\tpool = realm->acct_pool;\n#endif\n\n#ifdef WITH_COA\n\t} else if ((request->packet->code == PW_COA_REQUEST) ||\n\t\t   (request->packet->code == PW_DISCONNECT_REQUEST)) {\n\t\tpool = realm->acct_pool;\n#endif\n\n\t} else {\n\t\trad_panic(\"Internal sanity check failed\");\n\t}\n\n\tif (!pool) {\n\t\tRDEBUG2(\" WARNING: Cancelling proxy to Realm %s, as the realm is local.\",\n\t\t       realmname);\n\t\treturn 0;\n\t}\n\nfound_pool:\n\thome = home_server_ldb(realmname, pool, request);\n\tif (!home) {\n\t\tRDEBUG2(\"ERROR: Failed to find live home server for realm %s\",\n\t\t       realmname);\n\t\treturn -1;\n\t}\n\trequest->home_pool = pool;\n\n#ifdef WITH_COA\n\t/*\n\t *\tOnce we've decided to proxy a request, we cannot send\n\t *\ta CoA packet.  So we free up any CoA packet here.\n\t */\n\tev_request_free(&request->coa);\n#endif\n\t/*\n\t *\tRemember that we sent the request to a Realm.\n\t */\n\tif (realmname) pairadd(&request->packet->vps,\n\t\t\t       pairmake(\"Realm\", realmname, T_OP_EQ));\n\n\t/*\n\t *\tStrip the name, if told to.\n\t *\n\t *\tDoing it here catches the case of proxied tunneled\n\t *\trequests.\n\t */\n\tif (realm && (realm->striprealm == TRUE) &&\n\t   (strippedname = pairfind(request->proxy->vps, PW_STRIPPED_USER_NAME)) != NULL) {\n\t\t/*\n\t\t *\tIf there's a Stripped-User-Name attribute in\n\t\t *\tthe request, then use THAT as the User-Name\n\t\t *\tfor the proxied request, instead of the\n\t\t *\toriginal name.\n\t\t *\n\t\t *\tThis is done by making a copy of the\n\t\t *\tStripped-User-Name attribute, turning it into\n\t\t *\ta User-Name attribute, deleting the\n\t\t *\tStripped-User-Name and User-Name attributes\n\t\t *\tfrom the vps list, and making the new\n\t\t *\tUser-Name the head of the vps list.\n\t\t */\n\t\tvp = pairfind(request->proxy->vps, PW_USER_NAME);\n\t\tif (!vp) {\n\t\t\tvp = radius_paircreate(request, NULL,\n\t\t\t\t\t       PW_USER_NAME, PW_TYPE_STRING);\n\t\t\trad_assert(vp != NULL);\t/* handled by above function */\n\t\t\t/* Insert at the START of the list */\n\t\t\tvp->next = request->proxy->vps;\n\t\t\trequest->proxy->vps = vp;\n\t\t}\n\t\tmemcpy(vp->vp_strvalue, strippedname->vp_strvalue,\n\t\t       sizeof(vp->vp_strvalue));\n\t\tvp->length = strippedname->length;\n\n\t\t/*\n\t\t *\tDo NOT delete Stripped-User-Name.\n\t\t */\n\t}\n\n\t/*\n\t *\tIf there is no PW_CHAP_CHALLENGE attribute but\n\t *\tthere is a PW_CHAP_PASSWORD we need to add it\n\t *\tsince we can't use the request authenticator\n\t *\tanymore - we changed it.\n\t */\n\tif ((request->packet->code == PW_AUTHENTICATION_REQUEST) &&\n\t    pairfind(request->proxy->vps, PW_CHAP_PASSWORD) &&\n\t    pairfind(request->proxy->vps, PW_CHAP_CHALLENGE) == NULL) {\n\t\tvp = radius_paircreate(request, &request->proxy->vps,\n\t\t\t\t       PW_CHAP_CHALLENGE, PW_TYPE_OCTETS);\n\t\tvp->length = AUTH_VECTOR_LEN;\n\t\tmemcpy(vp->vp_strvalue, request->packet->vector, AUTH_VECTOR_LEN);\n\t}\n\n\t/*\n\t *\tThe RFC's say we have to do this, but FreeRADIUS\n\t *\tdoesn't need it.\n\t */\n\tvp = radius_paircreate(request, &request->proxy->vps,\n\t\t\t       PW_PROXY_STATE, PW_TYPE_OCTETS);\n\tsnprintf(vp->vp_strvalue, sizeof(vp->vp_strvalue), \"%d\",\n\t\t request->packet->id);\n\tvp->length = strlen(vp->vp_strvalue);\n\n\t/*\n\t *\tShould be done BEFORE inserting into proxy hash, as\n\t *\tpre-proxy may use this information, or change it.\n\t */\n\trequest->proxy->code = request->packet->code;\n\n\t/*\n\t *\tCall the pre-proxy routines.\n\t */\n\tvp = pairfind(request->config_items, PW_PRE_PROXY_TYPE);\n\tif (vp) {\n\t\tRDEBUG2(\"  Found Pre-Proxy-Type %s\", vp->vp_strvalue);\n\t\tpre_proxy_type = vp->vp_integer;\n\t}\n\n\trad_assert(request->home_pool != NULL);\n\n\tif (request->home_pool->virtual_server) {\n\t\tconst char *old_server = request->server;\n\t\t\n\t\trequest->server = request->home_pool->virtual_server;\n\t\tRDEBUG2(\" server %s {\", request->server);\n\t\trcode = module_pre_proxy(pre_proxy_type, request);\n\t\tRDEBUG2(\" }\");\n\t\t\trequest->server = old_server;\n\t} else {\n\t\trcode = module_pre_proxy(pre_proxy_type, request);\n\t}\n\tswitch (rcode) {\n\tcase RLM_MODULE_FAIL:\n\tcase RLM_MODULE_INVALID:\n\tcase RLM_MODULE_NOTFOUND:\n\tcase RLM_MODULE_USERLOCK:\n\tdefault:\n\t\t/* FIXME: debug print failed stuff */\n\t\treturn -1;\n\n\tcase RLM_MODULE_REJECT:\n\tcase RLM_MODULE_HANDLED:\n\t\treturn 0;\n\n\t/*\n\t *\tOnly proxy the packet if the pre-proxy code succeeded.\n\t */\n\tcase RLM_MODULE_NOOP:\n\tcase RLM_MODULE_OK:\n\tcase RLM_MODULE_UPDATED:\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tIf it's a fake request, don't send the proxy\n\t *\tpacket.  The outer tunnel session will take\n\t *\tcare of doing that.\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\trequest->home_server = NULL;\n\t\treturn 1;\n\t}\n\n\tif (request->home_server->server) {\n\t\treturn proxy_to_virtual_server(request);\n\t}\n\n\tif (!proxy_request(request)) {\n\t\tRDEBUG(\"ERROR: Failed to proxy request %u\", request->number);\n\t\treturn -1;\n\t}\n\t\n\treturn 1;\n}\n#endif\n\nstatic void request_post_handler(REQUEST *request)\n{\n\tint child_state = -1;\n\tstruct timeval when;\n\tVALUE_PAIR *vp;\n\n\tif ((request->master_state == REQUEST_STOP_PROCESSING) ||\n\t    (request->parent &&\n\t     (request->parent->master_state == REQUEST_STOP_PROCESSING))) {\n\t\tRDEBUG2(\"request %u was cancelled.\", request->number);\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\tchild_state = REQUEST_DONE;\n\t\tgoto cleanup;\n\t}\n\n\tif (request->child_state != REQUEST_RUNNING) {\n\t\trad_panic(\"Internal sanity check failed\");\n\t}\n\n#ifdef WITH_COA\n\t/*\n\t *\tIf it's not in the request hash, it's a CoA request.\n\t *\tWe hope.\n\t */\n\tif (!request->in_request_hash &&\n\t    request->proxy &&\n\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tgoto cleanup;\n\t}\n#endif\n\n\t/*\n\t *\tCatch Auth-Type := Reject BEFORE proxying the packet.\n\t */\n\tif ((request->packet->code == PW_AUTHENTICATION_REQUEST) &&\n\t    (request->reply->code == 0) &&\n\t    ((vp = pairfind(request->config_items, PW_AUTH_TYPE)) != NULL) &&\n\t    (vp->vp_integer == PW_AUTHTYPE_REJECT)) {\n\t\trequest->reply->code = PW_AUTHENTICATION_REJECT;\n\t}\n\n#ifdef WITH_PROXY\n\tif (request->root->proxy_requests &&\n\t    !request->in_proxy_hash &&\n\t    (request->reply->code == 0) &&\n\t    (request->packet->dst_port != 0) &&\n\t    (request->packet->code != PW_STATUS_SERVER)) {\n\t\tint rcode = successfully_proxied_request(request);\n\n\t\tif (rcode == 1) return; /* request is invalid */\n\n\t\t/*\n\t\t *\tFailed proxying it (dead home servers, etc.)\n\t\t *\tRun it through Post-Proxy-Type = Fail, and\n\t\t *\trespond to the request.\n\t\t *\n\t\t *\tNote that we're in a child thread here, so we\n\t\t *\tdo NOT re-schedule the request.  Instead, we\n\t\t *\tdo what we would have done, which is run the\n\t\t *\tpre-handler, a NULL request handler, and then\n\t\t *\tthe post handler.\n\t\t */\n\t\tif ((rcode < 0) && setup_post_proxy_fail(request)) {\n\t\t\trequest_pre_handler(request);\n\t\t}\n\n\t\t/*\n\t\t *\tElse we weren't supposed to proxy it,\n\t\t *\tOR we proxied it internally to a virutal server.\n\t\t */\n\t}\n\n#ifdef WITH_COA\n\telse if (request->proxy && request->coa) {\n\t\tRDEBUG(\"WARNING: Cannot proxy and originate CoA packets at the same time.  Cancelling CoA request\");\n\t\tev_request_free(&request->coa);\n\t}\n#endif\n#endif\n\n\t/*\n\t *\tFake requests don't get encoded or signed.  The caller\n\t *\talso requires the reply VP's, so we don't free them\n\t *\there!\n\t */\n\tif (request->packet->dst_port == 0) {\n\t\t/* FIXME: RDEBUG going to the next request */\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest->child_state = REQUEST_DONE;\n\t\treturn;\n\t}\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tCopy Proxy-State from the request to the reply.\n\t */\n\tvp = paircopy2(request->packet->vps, PW_PROXY_STATE);\n\tif (vp) pairadd(&request->reply->vps, vp);\n#endif\n\n\t/*\n\t *\tAccess-Requests get delayed or cached.\n\t */\n\tswitch (request->packet->code) {\n\tcase PW_AUTHENTICATION_REQUEST:\n\t\tgettimeofday(&request->next_when, NULL);\n\n\t\tif (request->reply->code == 0) {\n\t\t\t/*\n\t\t\t *\tCheck if the lack of response is intentional.\n\t\t\t */\n\t\t\tvp = pairfind(request->config_items,\n\t\t\t\t      PW_RESPONSE_PACKET_TYPE);\n\t\t\tif (!vp) {\n\t\t\t\tRDEBUG2(\"There was no response configured: rejecting request %u\",\n\t\t\t\t       request->number);\n\t\t\t\trequest->reply->code = PW_AUTHENTICATION_REJECT;\n\n\t\t\t} else if (vp->vp_integer == 256) {\n\t\t\t\tRDEBUG2(\"Not responding to request %u\",\n\t\t\t\t       request->number);\n\n\t\t\t\t/*\n\t\t\t\t *\tForce cleanup after a long\n\t\t\t\t *\ttime, so that we don't\n\t\t\t\t *\tre-process the packet.\n\t\t\t\t */\n\t\t\t\trequest->next_when.tv_sec += request->root->max_request_time;\n\t\t\t\trequest->next_callback = cleanup_delay;\n\t\t\t\tchild_state = REQUEST_CLEANUP_DELAY;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trequest->reply->code = vp->vp_integer;\n\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tRun rejected packets through\n\t\t *\n\t\t *\tPost-Auth-Type = Reject\n\t\t */\n\t\tif (request->reply->code == PW_AUTHENTICATION_REJECT) {\n\t\t\tpairdelete(&request->config_items, PW_POST_AUTH_TYPE);\n\t\t\tvp = radius_pairmake(request, &request->config_items,\n\t\t\t\t\t     \"Post-Auth-Type\", \"Reject\",\n\t\t\t\t\t     T_OP_SET);\n\t\t\tif (vp) rad_postauth(request);\n\n\t\t\t/*\n\t\t\t *\tIf configured, delay Access-Reject packets.\n\t\t\t *\n\t\t\t *\tIf request->root->reject_delay = 0, we discover\n\t\t\t *\tthat we have to send the packet now.\n\t\t\t */\n\t\t\twhen = request->received;\n\t\t\twhen.tv_sec += request->root->reject_delay;\n\n\t\t\tif (timercmp(&when, &request->next_when, >)) {\n\t\t\t\tRDEBUG2(\"Delaying reject of request %u for %d seconds\",\n\t\t\t\t       request->number,\n\t\t\t\t       request->root->reject_delay);\n\t\t\t\trequest->next_when = when;\n\t\t\t\trequest->next_callback = reject_delay;\n#ifdef HAVE_PTHREAD_H\n\t\t\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\t\t\trequest->child_state = REQUEST_REJECT_DELAY;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n#ifdef WITH_COA\n\tcase PW_COA_REQUEST:\n\tcase PW_DISCONNECT_REQUEST:\n#endif\n\t\trequest->next_when.tv_sec += request->root->cleanup_delay;\n\t\trequest->next_callback = cleanup_delay;\n\t\tchild_state = REQUEST_CLEANUP_DELAY;\n\t\tbreak;\n\n\tcase PW_ACCOUNTING_REQUEST:\n\t\trequest->next_callback = NULL; /* just to be safe */\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\n\t\t/*\n\t\t *\tFIXME: Status-Server should probably not be\n\t\t *\thandled here...\n\t\t */\n\tcase PW_STATUS_SERVER:\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t *\tDHCP, VMPS, etc.\n\t\t */\n\t\trequest->next_callback = NULL;\n\t\tchild_state = REQUEST_DONE;\n\t\tbreak;\n\t}\n\n\t/*\n\t *      Suppress \"no reply\" packets here, unless we're reading\n\t *      from the \"detail\" file.  In that case, we've got to\n\t *      tell the detail file handler that the request is dead,\n\t *      and it should re-send it.\n\t *\tIf configured, encode, sign, and send.\n\t */\n\tif ((request->reply->code != 0) ||\n\t    (request->listener->type == RAD_LISTEN_DETAIL)) {\n\t\tDEBUG_PACKET(request, request->reply, 1);\n\t\trequest->listener->send(request->listener, request);\n\t}\n\n#ifdef WITH_COA\n\t/*\n\t *\tNow that we've completely processed the request,\n\t *\tsee if we need to originate a CoA request.  But ONLY\n\t *\tif it wasn't proxied.\n\t */\n\tif (!request->proxy &&\n\t    (request->coa ||\n\t     (pairfind(request->config_items, PW_SEND_COA_REQUEST) != NULL))) {\n\t\tif (!originated_coa_request(request)) {\n\t\t\tRDEBUG2(\"Do CoA Fail handler here\");\n\t\t}\n\t\t/* request->coa is stil set, so we can update events */\n\t}\n#endif\n\n cleanup:\n\t/*\n\t *\tClean up.  These are no longer needed.\n\t */\n\tpairfree(&request->config_items);\n\n\tpairfree(&request->packet->vps);\n\trequest->username = NULL;\n\trequest->password = NULL;\n\n\tpairfree(&request->reply->vps);\n\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\tpairfree(&request->proxy->vps);\n\n\t\tif (request->proxy_reply) {\n\t\t\tpairfree(&request->proxy_reply->vps);\n\t\t}\n\n#if 0\n\t\t/*\n\t\t *\tWe're not tracking responses from the home\n\t\t *\tserver, we can therefore free this memory in\n\t\t *\tthe child thread.\n\t\t */\n\t\tif (!request->in_proxy_hash) {\n\t\t\trad_free(&request->proxy);\n\t\t\trad_free(&request->proxy_reply);\n\t\t\trequest->home_server = NULL;\n\t\t}\n#endif\n\t}\n#endif\n\n\tRDEBUG2(\"Finished request %u.\", request->number);\n\trad_assert(child_state >= 0);\n\trequest->child_state = child_state;\n\n\t/*\n\t *\tSingle threaded mode: update timers now.\n\t */\n\tif (!have_children) wait_a_bit(request);\n}\n\n\nstatic void received_retransmit(REQUEST *request, const RADCLIENT *client)\n{\n#ifdef WITH_PROXY\n\tchar buffer[128];\n#endif\n\n\tRAD_STATS_TYPE_INC(request->listener, total_dup_requests);\n\tRAD_STATS_CLIENT_INC(request->listener, client, total_dup_requests);\n\t\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n#ifdef WITH_PROXY\n\tdiscard:\n#endif\n\t\tradlog(L_ERR, \"Discarding duplicate request from \"\n\t\t       \"client %s port %d - ID: %d due to unfinished request %u\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port,request->packet->id,\n\t\t       request->number);\n\t\tbreak;\n\n#ifdef WITH_PROXY\n\tcase REQUEST_PROXIED:\n\t\t/*\n\t\t *\tWe're not supposed to have duplicate\n\t\t *\taccounting packets.  The other states handle\n\t\t *\tduplicates fine (discard, or send duplicate\n\t\t *\treply).  But we do NOT want to retransmit an\n\t\t *\taccounting request here, because that would\n\t\t *\tinvolve updating the Acct-Delay-Time, and\n\t\t *\ttherefore changing the packet Id, etc.\n\t\t *\n\t\t *\tInstead, we just discard the packet.  We may\n\t\t *\teventually respond, or the client will send a\n\t\t *\tnew accounting packet.\t\t  \n\t\t *\n\t\t *\tThe same comments go for Status-Server, and\n\t\t *\tother packet types.\n\t\t *\n\t\t *\tFIXME: coa: when we proxy CoA && Disconnect\n\t\t *\tpackets, this logic has to be fixed.\n\t\t */\n\t\tif (request->packet->code != PW_AUTHENTICATION_REQUEST) {\n\t\t\tgoto discard;\n\t\t}\n\n\t\tcheck_for_zombie_home_server(request);\n\n\t\t/*\n\t\t *\tIf we've just discovered that the home server is\n\t\t *\tdead, send the packet to another one.\n\t\t */\n\t\tif ((request->packet->dst_port != 0) &&\n\t\t    (request->home_server->state == HOME_STATE_IS_DEAD)) {\n\t\t\thome_server *home;\n\n\t\t\tremove_from_proxy_hash(request);\n\n\t\t\thome = home_server_ldb(NULL, request->home_pool, request);\n\t\t\tif (!home) {\n\t\t\t\tRDEBUG2(\"Failed to find live home server for request %u\", request->number);\n\t\t\tno_home_servers:\n\t\t\t\t/*\n\t\t\t\t *\tDo post-request processing,\n\t\t\t\t *\tand any insertion of necessary\n\t\t\t\t *\tevents.\n\t\t\t\t */\n\t\t\t\tpost_proxy_fail_handler(request);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trequest->proxy->code = request->packet->code;\n\n\t\t\t/*\n\t\t\t *\tFree the old packet, to force re-encoding\n\t\t\t */\n\t\t\tfree(request->proxy->data);\n\t\t\trequest->proxy->data = NULL;\n\t\t\trequest->proxy->data_len = 0;\n\n\t\t\t/*\n\t\t\t *\tThis request failed over to a virtual\n\t\t\t *\tserver.  Push it back onto the queue\n\t\t\t *\tto be processed.\n\t\t\t */\n\t\t\tif (request->home_server->server) {\n\t\t\t\tproxy_fallback_handler(request);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tTry to proxy the request.\n\t\t\t */\n\t\t\tif (!proxy_request(request)) {\n\t\t\t\tRDEBUG(\"ERROR: Failed to re-proxy request %u\", request->number);\n\t\t\t\tgoto no_home_servers;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tThis code executes in the main server\n\t\t\t *\tthread, so there's no need for locking.\n\t\t\t */\n\t\t\trad_assert(request->next_callback != NULL);\n\t\t\tINSERT_EVENT(request->next_callback, request);\n\t\t\trequest->next_callback = NULL;\n\t\t\treturn;\n\t\t} /* else the home server is still alive */\n\n\t\tRDEBUG2(\"Sending duplicate proxied request to home server %s port %d - ID: %d\",\n\t\t       inet_ntop(request->proxy->dst_ipaddr.af,\n\t\t\t\t &request->proxy->dst_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       request->proxy->dst_port,\n\t\t       request->proxy->id);\n\t\trequest->num_proxied_requests++;\n\n\t\tDEBUG_PACKET(request, request->proxy, 1);\n\t\trequest->proxy_listener->send(request->proxy_listener,\n\t\t\t\t\t      request);\n\t\tbreak;\n#endif\n\n\tcase REQUEST_REJECT_DELAY:\n\t\tRDEBUG2(\"Waiting to send Access-Reject \"\n\t\t       \"to client %s port %d - ID: %d\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port, request->packet->id);\n\t\tbreak;\n\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tif (request->reply->code == 0) {\n\t\t\tRDEBUG2(\"Ignoring retransmit from client %s port %d \"\n\t\t\t\t\"- ID: %d, no reply was configured\",\n\t\t\t\tclient->shortname,\n\t\t\t\trequest->packet->src_port, request->packet->id);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t *\tFIXME: This sends duplicate replies to\n\t\t *\taccounting requests, even if Acct-Delay-Time\n\t\t *\tor Event-Timestamp is in the packet.  In those\n\t\t *\tcases, the Id should be changed, and the packet\n\t\t *\tre-calculated.\n\t\t */\n\t\tRDEBUG2(\"Sending duplicate reply \"\n\t\t       \"to client %s port %d - ID: %d\",\n\t\t       client->shortname,\n\t\t       request->packet->src_port, request->packet->id);\n\t\tDEBUG_PACKET(request, request->reply, 1);\n\t\trequest->listener->send(request->listener, request);\n\t\tbreak;\n\t}\n}\n\n\nstatic void received_conflicting_request(REQUEST *request,\n\t\t\t\t\t const RADCLIENT *client)\n{\n\tradlog(L_ERR, \"Received conflicting packet from \"\n\t       \"client %s port %d - ID: %d due to unfinished request %u.  Giving up on old request.\",\n\t       client->shortname,\n\t       request->packet->src_port, request->packet->id,\n\t       request->number);\n\n\t/*\n\t *\tNuke it from the request hash, so we can receive new\n\t *\tpackets.\n\t */\n\tremove_from_request_hash(request);\n\n\tswitch (request->child_state) {\n#ifdef HAVE_PTHREAD_H\n\t\t/*\n\t\t *\tIt's queued or running.  Tell it to stop, and\n\t\t *\twait for it to do so.\n\t\t */\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\t\trequest->delay += request->delay >> 1;\n\n\t\ttv_add(&request->when, request->delay);\n\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n#endif\n\n\t\t/*\n\t\t *\tCatch race conditions.  It may have switched\n\t\t *\tfrom running to done while this code is being\n\t\t *\texecuted.\n\t\t */\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIt's in some other state, and therefore also\n\t\t *\tin the event queue.  At some point, the\n\t\t *\tchild will notice, and we can then delete it.\n\t\t */\n\tcase REQUEST_PROXIED:\n\tdefault:\n\t\trad_assert(request->ev != NULL);\n\t\tbreak;\n\t}\n}\n\n\nstatic int can_handle_new_request(RADIUS_PACKET *packet,\n\t\t\t\t  RADCLIENT *client,\n\t\t\t\t  struct main_config_t *root)\n{\n\t/*\n\t *\tCount the total number of requests, to see if\n\t *\tthere are too many.  If so, return with an\n\t *\terror.\n\t */\n\tif (root->max_requests) {\n\t\tint request_count = fr_packet_list_num_elements(pl);\n\n\t\t/*\n\t\t *\tThis is a new request.  Let's see if\n\t\t *\tit makes us go over our configured\n\t\t *\tbounds.\n\t\t */\n\t\tif (request_count > root->max_requests) {\n\t\t\tradlog(L_ERR, \"Dropping request (%d is too many): \"\n\t\t\t       \"from client %s port %d - ID: %d\", request_count,\n\t\t\t       client->shortname,\n\t\t\t       packet->src_port, packet->id);\n\t\t\tradlog(L_INFO, \"WARNING: Please check the configuration file.\\n\"\n\t\t\t       \"\\tThe value for 'max_requests' is probably set too low.\\n\");\n\t\t\treturn 0;\n\t\t} /* else there were a small number of requests */\n\t} /* else there was no configured limit for requests */\n\n\t/*\n\t *\tFIXME: Add per-client checks.  If one client is sending\n\t *\ttoo many packets, start discarding them.\n\t *\n\t *\tWe increment the counters here, and decrement them\n\t *\twhen the response is sent... somewhere in this file.\n\t */\n\n\t/*\n\t *\tFUTURE: Add checks for system load.  If the system is\n\t *\tbusy, start dropping requests...\n\t *\n\t *\tWe can probably keep some statistics ourselves...  if\n\t *\tthere are more requests coming in than we can handle,\n\t *\tstart dropping some.\n\t */\n\n\treturn 1;\n}\n\n\nint received_request(rad_listen_t *listener,\n\t\t     RADIUS_PACKET *packet, REQUEST **prequest,\n\t\t     RADCLIENT *client)\n{\n\tRADIUS_PACKET **packet_p;\n\tREQUEST *request = NULL;\n\tstruct main_config_t *root = &mainconfig;\n\n\tpacket_p = fr_packet_list_find(pl, packet);\n\tif (packet_p) {\n\t\trequest = fr_packet2myptr(REQUEST, packet, packet_p);\n\t\trad_assert(request->in_request_hash);\n\n\t\tif ((request->packet->data_len == packet->data_len) &&\n\t\t    (memcmp(request->packet->vector, packet->vector,\n\t\t\t    sizeof(packet->vector)) == 0)) {\n\t\t\treceived_retransmit(request, client);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tThe new request is different from the old one,\n\t\t *\tbut maybe the old is finished.  If so, delete\n\t\t *\tthe old one.\n\t\t */\n\t\tswitch (request->child_state) {\n\t\t\tstruct timeval when;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t *\tSpecial hacks for race conditions.\n\t\t\t *\tThe reply is encoded, and therefore\n\t\t\t *\tlikely sent.  We received a *new*\n\t\t\t *\tpacket from the client, likely before\n\t\t\t *\tthe next line or two of code which\n\t\t\t *\tupdated the child state.  In this\n\t\t\t *\tcase, just accept the new request.\n\t\t\t */\n\t\t\tif ((request->reply->code != 0) &&\n\t\t\t    request->reply->data) {\n\t\t\t\tradlog(L_INFO, \"WARNING: Allowing fast client %s port %d - ID: %d for recent request %u.\",\n\t\t\t\t       client->shortname,\n\t\t\t\t       packet->src_port, packet->id,\n\t\t\t\t       request->number);\n\t\t\t\tremove_from_request_hash(request);\n\t\t\t\trequest = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgettimeofday(&when, NULL);\n\t\t\twhen.tv_sec -= 1;\n\n\t\t\t/*\n\t\t\t *\tIf the cached request was received\n\t\t\t *\twithin the last second, then we\n\t\t\t *\tdiscard the NEW request instead of the\n\t\t\t *\told one.  This will happen ONLY when\n\t\t\t *\tthe client is severely broken, and is\n\t\t\t *\tsending conflicting packets very\n\t\t\t *\tquickly.\n\t\t\t */\n\t\t\tif (timercmp(&when, &request->received, <)) {\n\t\t\t\tradlog(L_ERR, \"Discarding conflicting packet from \"\n\t\t\t\t       \"client %s port %d - ID: %d due to recent request %u.\",\n\t\t\t\t       client->shortname,\n\t\t\t\t       packet->src_port, packet->id,\n\t\t\t\t       request->number);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treceived_conflicting_request(request, client);\n\t\t\trequest = NULL;\n\t\t\tbreak;\n\n\t\tcase REQUEST_REJECT_DELAY:\n\t\tcase REQUEST_CLEANUP_DELAY:\n\t\t\trequest->child_state = REQUEST_DONE;\n\t\tcase REQUEST_DONE:\n\t\t\tcleanup_delay(request);\n\t\t\trequest = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t *\tWe may want to quench the new request.\n\t */\n\tif ((listener->type != RAD_LISTEN_DETAIL) &&\n\t    !can_handle_new_request(packet, client, root)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tCreate and initialize the new request.\n\t */\n\trequest = request_alloc(); /* never fails */\n\n\tif ((request->reply = rad_alloc(0)) == NULL) {\n\t\tradlog(L_ERR, \"No memory\");\n\t\texit(1);\n\t}\n\n\trequest->listener = listener;\n\trequest->client = client;\n\trequest->packet = packet;\n\trequest->packet->timestamp = request->timestamp;\n\trequest->number = request_num_counter++;\n\trequest->priority = listener->type;\n#ifdef HAVE_PTHREAD_H\n\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n\t/*\n\t *\tStatus-Server packets go to the head of the queue.\n\t */\n\tif (request->packet->code == PW_STATUS_SERVER) request->priority = 0;\n\n\t/*\n\t *\tSet virtual server identity\n\t */\n\tif (client->server) {\n\t\trequest->server = client->server;\n\t} else if (listener->server) {\n\t\trequest->server = listener->server;\n\t} else {\n\t\trequest->server = NULL;\n\t}\n\n\t/*\n\t *\tRemember the request in the list.\n\t */\n\tif (!fr_packet_list_insert(pl, &request->packet)) {\n\t\tradlog(L_ERR, \"Failed to insert request %u in the list of live requests: discarding\", request->number);\n\t\tev_request_free(&request);\n\t\treturn 0;\n\t}\n\n\trequest->in_request_hash = TRUE;\n\trequest->root = root;\n\troot->refcount++;\n\n\t/*\n\t *\tThe request passes many of our sanity checks.\n\t *\tFrom here on in, if anything goes wrong, we\n\t *\tsend a reject message, instead of dropping the\n\t *\tpacket.\n\t */\n\n\t/*\n\t *\tBuild the reply template from the request.\n\t */\n\n\trequest->reply->sockfd = request->packet->sockfd;\n\trequest->reply->dst_ipaddr = request->packet->src_ipaddr;\n\trequest->reply->src_ipaddr = request->packet->dst_ipaddr;\n\trequest->reply->dst_port = request->packet->src_port;\n\trequest->reply->src_port = request->packet->dst_port;\n\trequest->reply->id = request->packet->id;\n\trequest->reply->code = 0; /* UNKNOWN code */\n\tmemcpy(request->reply->vector, request->packet->vector,\n\t       sizeof(request->reply->vector));\n\trequest->reply->vps = NULL;\n\trequest->reply->data = NULL;\n\trequest->reply->data_len = 0;\n\n\trequest->master_state = REQUEST_ACTIVE;\n\trequest->child_state = REQUEST_QUEUED;\n\trequest->next_callback = NULL;\n\n\tgettimeofday(&request->received, NULL);\n\trequest->timestamp = request->received.tv_sec;\n\trequest->when = request->received;\n\n\trequest->delay = USEC;\n\n\ttv_add(&request->when, request->delay);\n\n\tINSERT_EVENT(wait_a_bit, request);\n\n\t*prequest = request;\n\treturn 1;\n}\n\n\n#ifdef WITH_PROXY\nREQUEST *received_proxy_response(RADIUS_PACKET *packet)\n{\n\tchar\t\tbuffer[128];\n\tREQUEST\t\t*request;\n\n\t/*\n\t *\tAlso removes from the proxy hash if responses == requests\n\t */\n\trequest = lookup_in_proxy_hash(packet);\n\n\tif (!request) {\n\t\tradlog(L_PROXY, \"No outstanding request was found for reply from host %s port %d - ID %d\",\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       packet->src_port, packet->id);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tWe haven't replied to the NAS, but we have seen an\n\t *\tearlier reply from the home server.  Ignore this packet,\n\t *\tas we're likely still processing the previous reply.\n\t */\n\tif (request->proxy_reply) {\n\t\tif (memcmp(request->proxy_reply->vector,\n\t\t\t   packet->vector,\n\t\t\t   sizeof(request->proxy_reply->vector)) == 0) {\n\t\t\tRDEBUG2(\"Discarding duplicate reply from host %s port %d  - ID: %d for request %u\",\n\t\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t\t buffer, sizeof(buffer)),\n\t\t\t       packet->src_port, packet->id,\n\t\t\t       request->number);\n\t\t} else {\n\t\t\t/*\n\t\t\t *\t? The home server gave us a new proxy\n\t\t\t *\treply which doesn't match the old\n\t\t\t *\tone.  Delete it.\n\t\t\t */\n\t\t\tRDEBUG2(\"Ignoring conflicting proxy reply\");\n\t\t}\n\t\t\n\t\t/* assert that there's an event queued for request? */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tVerify the packet before doing ANYTHING with it.  This\n\t *\tmeans we're doing more MD5 checks in the server core.\n\t *\tHowever, we can fix that by moving to multiple threads\n\t *\tlistening on sockets.\n\t *\n\t *\tWe do this AFTER looking the request up in the hash,\n\t *\tand AFTER vhecking if we saw a previous request.  This\n\t *\thelps minimize the DoS effect of people attacking us\n\t *\twith spoofed packets.\n\t */\n\tif (rad_verify(packet, request->proxy,\n\t\t       request->home_server->secret) != 0) {\n\t\tDEBUG(\"Ignoring spoofed proxy reply.  Signature is invalid\");\n\t\treturn NULL;\n\t}\n\n\tgettimeofday(&now, NULL);\n\n\t/*\n\t *\t\"ping\" packets have a different algorithm for marking\n\t *\ta home server alive.  They also skip all of the CoA,\n\t *\tetc. checks.\n\t */\n\tif (!request->packet) {\n\t\trequest->proxy_reply = packet;\n\t\treceived_response_to_ping(request);\n\t\trequest->proxy_reply = NULL; /* caller will free it */\n\t\tev_request_free(&request);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tMaybe move this earlier in the decision process?\n\t *\tHaving it here means that late or duplicate proxy\n\t *\treplies no longer get the home server marked as\n\t *\t\"alive\".  This might be good for stability, though.\n\t *\n\t *\tFIXME: Do we really want to do this whenever we\n\t *\treceive a packet?  Setting this here means that we\n\t *\tmark it alive on *any* packet, even if it's lost all\n\t *\tof the *other* packets in the last 10s.\n\t */\n\trequest->home_server->state = HOME_STATE_ALIVE;\n\t\n#ifdef WITH_COA\n\t/*\n\t *\tWhen originating CoA, the \"proxy\" reply is the reply\n\t *\tto the CoA request that we originated.  At this point,\n\t *\tthe original request is finished, and it has a reply.\n\t *\n\t *\tHowever, if we haven't separated the two requests, do\n\t *\tso now.  This is done so that cleaning up the original\n\t *\trequest won't cause the CoA request to be free'd.  See\n\t *\tutil.c, request_free()\n\t */\n\tif (request->parent && (request->parent->coa == request)) {\n\t\trequest->parent->coa = NULL;\n\t\trequest->parent = NULL;\n\n\t\t/*\n\t\t *\tThe proxied packet was different from the\n\t\t *\toriginal packet, AND the proxied packet was\n\t\t *\ta CoA: allow it.\n\t\t */\n\t} else if ((request->packet->code != request->proxy->code) &&\n\t\t   ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t    (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t  /*\n\t   *\tIt's already divorced: do nothing.\n\t   */\n\t  \n\t} else\n\t\t/*\n\t\t *\tSkip the next set of checks, as the original\n\t\t *\treply is cached.  We want to be able to still\n\t\t *\tprocess the CoA reply, AND to reference the\n\t\t *\toriginal request/reply.\n\t\t *\n\t\t *\tThis is getting to be really quite a bit of a\n\t\t *\thack.\n\t\t */\n#endif\n\n\t/*\n\t *\tIf there's a reply to the NAS, ignore everything\n\t *\trelated to proxy responses\n\t */\n\tif (request->reply && request->reply->code != 0) {\n\t\tRDEBUG2(\"Ignoring proxy reply that arrived after we sent a reply to the NAS\");\n\t\treturn NULL;\n\t}\n\n#ifdef WITH_STATS\n\t/*\n\t *\tThe average includes our time to receive packets and\n\t *\tlook them up in the hashes, which should be the same\n\t *\tfor all packets.\n\t *\n\t *\tWe update the response time only for the FIRST packet\n\t *\twe receive.\n\t */\n\tif (request->home_server->ema.window > 0) {\n\t\tradius_stats_ema(&request->home_server->ema,\n\t\t\t\t &now, &request->proxy_when);\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\tradlog(L_ERR, \"Internal sanity check failed for child state\");\n\t\t/* FALL-THROUGH */\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n\tcase REQUEST_DONE:\n\t\tradlog(L_ERR, \"Reply from home server %s port %d  - ID: %d arrived too late for request %u. Try increasing 'retry_delay' or 'max_request_time'\",\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t buffer, sizeof(buffer)),\n\t\t       packet->src_port, packet->id,\n\t\t       request->number);\n\t\t/* assert that there's an event queued for request? */\n\t\treturn NULL;\n\n\tcase REQUEST_PROXIED:\n\t\tbreak;\n\t}\n\n\trequest->proxy_reply = packet;\n\n#if 0\n\t/*\n\t *\tPerform RTT calculations, as per RFC 2988 (for TCP).\n\t *\tNote that we only do so on the first response.\n\t */\n\tif ((request->num_proxied_responses == 1)\n\t\tint rtt;\n\t\thome_server *home = request->home_server;\n\n\t\trtt = now.tv_sec - request->proxy_when.tv_sec;\n\t\trtt *= USEC;\n\t\trtt += now.tv_usec;\n\t\trtt -= request->proxy_when.tv_usec;\n\n\t\tif (!home->has_rtt) {\n\t\t\thome->has_rtt = TRUE;\n\n\t\t\thome->srtt = rtt;\n\t\t\thome->rttvar = rtt / 2;\n\n\t\t} else {\n\t\t\thome->rttvar -= home->rttvar >> 2;\n\t\t\thome->rttvar += (home->srtt - rtt);\n\t\t\thome->srtt -= home->srtt >> 3;\n\t\t\thome->srtt += rtt >> 3;\n\t\t}\n\n\t\thome->rto = home->srtt;\n\t\tif (home->rttvar > (USEC / 4)) {\n\t\t\thome->rto += home->rttvar * 4;\n\t\t} else {\n\t\t\thome->rto += USEC;\n\t\t}\n\t}\n#endif\n\n\trequest->child_state = REQUEST_QUEUED;\n\trequest->when = now;\n\trequest->delay = USEC;\n\trequest->priority = RAD_LISTEN_PROXY;\n\ttv_add(&request->when, request->delay);\n\n\t/*\n\t *\tWait a bit will take care of max_request_time\n\t */\n\tINSERT_EVENT(wait_a_bit, request);\n\n\treturn request;\n}\n#endif\n\nvoid event_new_fd(rad_listen_t *this)\n{\n\tchar buffer[1024];\n\n\tif (this->status == RAD_LISTEN_STATUS_KNOWN) return;\n\t\n\tthis->print(this, buffer, sizeof(buffer));\n\t\n\tif (this->status == RAD_LISTEN_STATUS_INIT) {\n\t\tif (just_started) {\n\t\t\tDEBUG(\"Listening on %s\", buffer);\n\t\t} else {\n\t\t\tradlog(L_INFO, \" ... adding new socket %s\", buffer);\n\t\t}\n\t\tif (!fr_event_fd_insert(el, 0, this->fd,\n\t\t\t\t\tevent_socket_handler, this)) {\n\t\t\tradlog(L_ERR, \"Failed remembering handle for proxy socket!\");\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tthis->status = RAD_LISTEN_STATUS_KNOWN;\n\t\treturn;\n\t}\n\t\n\tif (this->status == RAD_LISTEN_STATUS_CLOSED) {\n\t\tradlog(L_INFO, \" ... closing socket %s\", buffer);\n\t\t\n\t\tfr_event_fd_delete(el, 0, this->fd);\n\t\tthis->status = RAD_LISTEN_STATUS_FINISH;\n\t\t\n\t\t/*\n\t\t *\tClose the fd AFTER fixing up the requests and\n\t\t *\tlisteners, so that they don't send/recv on the\n\t\t *\twrong socket (if someone manages to open\n\t\t *\tanother one).\n\t\t */\n\t\tclose(this->fd);\n\t\tthis->fd = -1;\n\t}\n}\n\nstatic void handle_signal_self(int flag)\n{\n\tif ((flag & (RADIUS_SIGNAL_SELF_EXIT | RADIUS_SIGNAL_SELF_TERM)) != 0) {\n\t\tif ((flag & RADIUS_SIGNAL_SELF_EXIT) != 0) {\n\t\t\tfr_event_loop_exit(el, 1);\n\t\t} else {\n\t\t\tfr_event_loop_exit(el, 2);\n\t\t}\n\n\t\treturn;\n\t} /* else exit/term flags weren't set */\n\n\t/*\n\t *\tTell the even loop to stop processing.\n\t */\n\tif ((flag & RADIUS_SIGNAL_SELF_HUP) != 0) {\n\t\ttime_t when;\n\t\tstatic time_t last_hup = 0;\n\n\t\twhen = time(NULL);\n\t\tif ((int) (when - last_hup) < 5) {\n\t\t\tradlog(L_INFO, \"Ignoring HUP (less than 5s since last one)\");\n\t\t\treturn;\n\t\t}\n\n\t\tradlog(L_INFO, \"Received HUP signal.\");\n\n\t\tlast_hup = when;\n\n\t\tfr_event_loop_exit(el, 0x80);\n\t}\n\n#ifdef WITH_DETAIL\n\tif ((flag & RADIUS_SIGNAL_SELF_DETAIL) != 0) {\n\t\trad_listen_t *this;\n\t\t\n\t\t/*\n\t\t *\tFIXME: O(N) loops suck.\n\t\t */\n\t\tfor (this = mainconfig.listen;\n\t\t     this != NULL;\n\t\t     this = this->next) {\n\t\t\tif (this->type != RAD_LISTEN_DETAIL) continue;\n\n\t\t\t/*\n\t\t\t *\tThis one didn't send the signal, skip\n\t\t\t *\tit.\n\t\t\t */\n\t\t\tif (!this->decode(this, NULL)) continue;\n\n\t\t\t/*\n\t\t\t *\tGo service the interrupt.\n\t\t\t */\n\t\t\tevent_poll_detail(this);\n\t\t}\n\t}\n#endif\n\n\tif ((flag & RADIUS_SIGNAL_SELF_NEW_FD) != 0) {\n\t\trad_listen_t *this;\n\t\t\n\t\tfor (this = mainconfig.listen;\n\t\t     this != NULL;\n\t\t     this = this->next) {\n\t\t\tevent_new_fd(this);\n\t\t}\n\t}\n}\n\n#ifndef WITH_SELF_PIPE\nvoid radius_signal_self(int flag)\n{\n\thandle_signal_self(flag);\n}\n#else\n/*\n *\tInform ourselves that we received a signal.\n */\nvoid radius_signal_self(int flag)\n{\n\tssize_t rcode;\n\tuint8_t buffer[16];\n\n\t/*\n\t *\tThe read MUST be non-blocking for this to work.\n\t */\n\trcode = read(self_pipe[0], buffer, sizeof(buffer));\n\tif (rcode > 0) {\n\t\tssize_t i;\n\n\t\tfor (i = 0; i < rcode; i++) {\n\t\t\tbuffer[0] |= buffer[i];\n\t\t}\n\t} else {\n\t\tbuffer[0] = 0;\n\t}\n\n\tbuffer[0] |= flag;\n\n\twrite(self_pipe[1], buffer, 1);\n}\n\n\nstatic void event_signal_handler(UNUSED fr_event_list_t *xel,\n\t\t\t\t UNUSED int fd, UNUSED void *ctx)\n{\n\tssize_t i, rcode;\n\tuint8_t buffer[32];\n\n\trcode = read(self_pipe[0], buffer, sizeof(buffer));\n\tif (rcode <= 0) return;\n\n\t/*\n\t *\tMerge pending signals.\n\t */\n\tfor (i = 0; i < rcode; i++) {\n\t\tbuffer[0] |= buffer[i];\n\t}\n\n\thandle_signal_self(buffer[0]);\n}\n#endif\n\n\nstatic void event_socket_handler(fr_event_list_t *xel, UNUSED int fd,\n\t\t\t\t void *ctx)\n{\n\trad_listen_t *listener = ctx;\n\tRAD_REQUEST_FUNP fun;\n\tREQUEST *request;\n\n\trad_assert(xel == el);\n\n\txel = xel;\n\n\tif (listener->fd < 0) rad_panic(\"Socket was closed on us!\");\n\t\n\tif (!listener->recv(listener, &fun, &request)) return;\n\n\tif (!thread_pool_addrequest(request, fun)) {\n\t\trequest->child_state = REQUEST_DONE;\n\t}\n}\n\n\n/*\n *\tThis function is called periodically to see if this detail\n *\tfile is available for reading.\n */\nstatic void event_poll_detail(void *ctx)\n{\n\tint rcode, delay;\n\tRAD_REQUEST_FUNP fun;\n\tREQUEST *request;\n\trad_listen_t *this = ctx;\n\tstruct timeval when;\n\tlisten_detail_t *detail = this->data;\n\n\trad_assert(this->type == RAD_LISTEN_DETAIL);\n\n\t/*\n\t *\tTry to read something.\n\t *\n\t *\tFIXME: This does poll AND receive.\n\t */\n\trcode = this->recv(this, &fun, &request);\n\tif (rcode != 0) {\n\t\trad_assert(fun != NULL);\n\t\trad_assert(request != NULL);\n\t\t\n\t\tif (!thread_pool_addrequest(request, fun)) {\n\t\t\trequest->child_state = REQUEST_DONE;\n\t\t}\n\t}\n\n\tif (!fr_event_now(el, &now)) gettimeofday(&now, NULL);\n\twhen = now;\n\n\t/*\n\t *\tBackdoor API to get the delay until the next poll\n\t *\ttime.\n\t */\n\tdelay = this->encode(this, NULL);\n\ttv_add(&when, delay);\n\n\tif (!fr_event_insert(el, event_poll_detail, this,\n\t\t\t     &when, &detail->ev)) {\n\t\tradlog(L_ERR, \"Failed creating handler\");\n\t\texit(1);\n\t}\n}\n\n\nstatic void event_status(struct timeval *wake)\n{\n#if !defined(HAVE_PTHREAD_H) && defined(WNOHANG)\n\tint argval;\n#endif\n\n\tif (debug_flag == 0) {\n\t\tif (just_started) {\n\t\t\tradlog(L_INFO, \"Ready to process requests.\");\n\t\t\tjust_started = FALSE;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!wake) {\n\t\tradlog(L_INFO, \"Ready to process requests.\");\n\n\t} else if ((wake->tv_sec != 0) ||\n\t\t   (wake->tv_usec >= 100000)) {\n\t\tDEBUG(\"Waking up in %d.%01u seconds.\",\n\t\t      (int) wake->tv_sec, (unsigned int) wake->tv_usec / 100000);\n\t}\n\n\n\t/*\n\t *\tFIXME: Put this somewhere else, where it isn't called\n\t *\tall of the time...\n\t */\n\n#if !defined(HAVE_PTHREAD_H) && defined(WNOHANG)\n\t/*\n\t *\tIf there are no child threads, then there may\n\t *\tbe child processes.  In that case, wait for\n\t *\ttheir exit status, and throw that exit status\n\t *\taway.  This helps get rid of zxombie children.\n\t */\n\twhile (waitpid(-1, &argval, WNOHANG) > 0) {\n\t\t/* do nothing */\n\t}\n#endif\n\n}\n\n/*\n *\tExternally-visibly functions.\n */\nint radius_event_init(CONF_SECTION *cs, int spawn_flag)\n{\n\trad_listen_t *this, *head = NULL;\n\n\tif (el) return 0;\n\n\ttime(&fr_start_time);\n\n\tel = fr_event_list_create(event_status);\n\tif (!el) return 0;\n\n\tpl = fr_packet_list_create(0);\n\tif (!pl) return 0;\t/* leak el */\n\n\trequest_num_counter = 0;\n\n#ifdef WITH_PROXY\n\tif (mainconfig.proxy_requests) {\n\t\t/*\n\t\t *\tCreate the tree for managing proxied requests and\n\t\t *\tresponses.\n\t\t */\n\t\tproxy_list = fr_packet_list_create(1);\n\t\tif (!proxy_list) return 0;\n\n#ifdef HAVE_PTHREAD_H\n\t\tif (pthread_mutex_init(&proxy_mutex, NULL) != 0) {\n\t\t\tradlog(L_ERR, \"FATAL: Failed to initialize proxy mutex: %s\",\n\t\t\t       strerror(errno));\n\t\t\texit(1);\n\t\t}\n#endif\n\t}\n#endif\n\n#ifdef HAVE_PTHREAD_H\n#ifndef __MINGW32__\n\tNO_SUCH_CHILD_PID = (pthread_t ) (0);\n#else\n\tNO_SUCH_CHILD_PID = pthread_self(); /* not a child thread */\n#endif\n\t/*\n\t *\tInitialize the threads ONLY if we're spawning, AND\n\t *\twe're running normally.\n\t */\n\tif (spawn_flag && !check_config &&\n\t    (thread_pool_init(cs, &spawn_flag) < 0)) {\n\t\texit(1);\n\t}\n#endif\n\n\t/*\n\t *\tMove all of the thread calls to this file?\n\t *\n\t *\tIt may be best for the mutexes to be in this file...\n\t */\n\thave_children = spawn_flag;\n\n\tif (check_config) {\n\t\tDEBUG(\"%s: #### Skipping IP addresses and Ports ####\",\n\t\t       mainconfig.name);\n\t\treturn 1;\n\t}\n\n#ifdef WITH_SELF_PIPE\n\t/*\n\t *\tChild threads need a pipe to signal us, as do the\n\t *\tsignal handlers.\n\t */\n\tif (pipe(self_pipe) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error opening internal pipe: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\tif (fcntl(self_pipe[0], F_SETFL, O_NONBLOCK | FD_CLOEXEC) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error setting internal flags: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\tif (fcntl(self_pipe[1], F_SETFL, O_NONBLOCK | FD_CLOEXEC) < 0) {\n\t\tradlog(L_ERR, \"radiusd: Error setting internal flags: %s\",\n\t\t       strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (!fr_event_fd_insert(el, 0, self_pipe[0],\n\t\t\t\t  event_signal_handler, el)) {\n\t\tradlog(L_ERR, \"Failed creating handler for signals\");\n\t\texit(1);\n\t}\n#endif\t/* WITH_SELF_PIPE */\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tMark the proxy Fd's as unused.\n\t */\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < 32; i++) proxy_fds[i] = -1;\n\t}\n#endif\n\n       DEBUG(\"%s: #### Opening IP addresses and Ports ####\",\n\t       mainconfig.name);\n\n       /*\n\t*\tThe server temporarily switches to an unprivileged\n\t*\tuser very early in the bootstrapping process.\n\t*\tHowever, some sockets MAY require privileged access\n\t*\t(bind to device, or to port < 1024, or to raw\n\t*\tsockets).  Those sockets need to call suid up/down\n\t*\tthemselves around the functions that need a privileged\n\t*\tuid.\n\t*/\n\tif (listen_init(cs, &head) < 0) {\n\t\t_exit(1);\n\t}\n\t\n\t/*\n\t *\tAt this point, no one has any business *ever* going\n\t *\tback to root uid.\n\t */\n\tfr_suid_down_permanent();\n\n\t/*\n\t *\tAdd all of the sockets to the event loop.\n\t */\n\tfor (this = head;\n\t     this != NULL;\n\t     this = this->next) {\n\t\tchar buffer[256];\n\n\t\tthis->print(this, buffer, sizeof(buffer));\n\n\t\tswitch (this->type) {\n#ifdef WITH_DETAIL\n\t\tcase RAD_LISTEN_DETAIL:\n\t\t\tDEBUG(\"Listening on %s\", buffer);\n\n\t\t\t/*\n\t\t\t *\tDetail files are always known, and aren't\n\t\t\t *\tput into the socket event loop.\n\t\t\t */\n\t\t\tthis->status = RAD_LISTEN_STATUS_KNOWN;\n\n\t\t\t/*\n\t\t\t *\tSet up the first poll interval.\n\t\t\t */\n\t\t\tevent_poll_detail(this);\n\t\t\tbreak;\n#endif\n\n#ifdef WITH_PROXY\n\t\tcase RAD_LISTEN_PROXY:\n\t\t\trad_assert(proxy_fds[this->fd & 0x1f] == -1);\n\t\t\trad_assert(proxy_listeners[this->fd & 0x1f] == NULL);\n\t\t\t\n\t\t\tproxy_fds[this->fd & 0x1f] = this->fd;\n\t\t\tproxy_listeners[this->fd & 0x1f] = this;\n\t\t\tif (!fr_packet_list_socket_add(proxy_list,\n\t\t\t\t\t\t\t this->fd)) {\n\t\t\t\trad_assert(0 == 1);\n\t\t\t}\n\t\t\t/* FALL-THROUGH */\n#endif\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tevent_new_fd(this);\n\t}\n\n\tmainconfig.listen = head;\n\n\treturn 1;\n}\n\n\nstatic int request_hash_cb(UNUSED void *ctx, void *data)\n{\n\tREQUEST *request = fr_packet2myptr(REQUEST, packet, data);\n\n#ifdef WITH_PROXY\n\trad_assert(request->in_proxy_hash == FALSE);\n#endif\n\n\tev_request_free(&request);\n\n\treturn 0;\n}\n\n\n#ifdef WITH_PROXY\nstatic int proxy_hash_cb(UNUSED void *ctx, void *data)\n{\n\tREQUEST *request = fr_packet2myptr(REQUEST, proxy, data);\n\n\tev_request_free(&request);\n\n\treturn 0;\n}\n#endif\n\nvoid radius_event_free(void)\n{\n\t/*\n\t *\tFIXME: Stop all threads, or at least check that\n\t *\tthey're all waiting on the semaphore, and the queues\n\t *\tare empty.\n\t */\n\n#ifdef WITH_PROXY\n\t/*\n\t *\tThere are requests in the proxy hash that aren't\n\t *\treferenced from anywhere else.  Remove them first.\n\t */\n\tif (proxy_list) {\n\t\tfr_packet_list_walk(proxy_list, NULL, proxy_hash_cb);\n\t\tfr_packet_list_free(proxy_list);\n\t\tproxy_list = NULL;\n\t}\n#endif\n\n\tfr_packet_list_walk(pl, NULL, request_hash_cb);\n\n\tfr_packet_list_free(pl);\n\tpl = NULL;\n\n\tfr_event_list_free(el);\n}\n\nint radius_event_process(void)\n{\n\tif (!el) return 0;\n\n\treturn fr_event_loop(el);\n}\n\nvoid radius_handle_request(REQUEST *request, RAD_REQUEST_FUNP fun)\n{\n\trequest->options = RAD_REQUEST_OPTION_DEBUG2;\n\n\tif (request_pre_handler(request)) {\n\t\trad_assert(fun != NULL);\n\t\trad_assert(request != NULL);\n\t\t\n\t\tif (request->server) RDEBUG(\"server %s {\",\n\t\t\t\t\t    request->server != NULL ?\n\t\t\t\t\t    request->server : \"\"); \n\t\tfun(request);\n\n\t\tif (request->server) RDEBUG(\"} # server %s\",\n\t\t\t\t\t     request->server != NULL ?\n\t\t\t\t\t    request->server : \"\");\n\n\t\trequest_post_handler(request);\n\t}\n\n\tDEBUG2(\"Going to the next request\");\n\treturn;\n}\n"], "filenames": ["src/main/event.c"], "buggy_code_start_loc": [481], "buggy_code_end_loc": [1216], "fixing_code_start_loc": [482], "fixing_code_end_loc": [1218], "type": "CWE-399", "message": "The wait_for_child_to_die function in main/event.c in FreeRADIUS 2.1.x before 2.1.10, in certain circumstances involving long-term database outages, does not properly handle long queue times for requests, which allows remote attackers to cause a denial of service (daemon crash) by sending many requests.", "other": {"cve": {"id": "CVE-2010-3697", "sourceIdentifier": "secalert@redhat.com", "published": "2010-10-07T21:00:03.500", "lastModified": "2010-10-08T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The wait_for_child_to_die function in main/event.c in FreeRADIUS 2.1.x before 2.1.10, in certain circumstances involving long-term database outages, does not properly handle long queue times for requests, which allows remote attackers to cause a denial of service (daemon crash) by sending many requests."}, {"lang": "es", "value": "La funci\u00f3n wait_for_child_to_die en main/event.c en FreeRADIUS v2.1.x anterior a v2.1.10, en determinadas ocaciones genera cortes en la base de datos al no controlar correctamente los tiempos largos de la cola de peticiones, permitiendo de esta forma a atacantes remotos provocar una denegaci\u00f3n de servicio ( ca\u00edda del servicio) mediante el env\u00edo de muchas peticiones."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5B92B1F7-8139-4D5A-9461-0C7314BCCBC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "C5CAEB64-0676-4C18-8255-DACDA612188E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "17F7A434-49DC-4005-9161-F2B49559621F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "7A54D59A-B832-4EE3-A8D6-A85EC17C268A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "D494932F-F639-44BE-B15C-7F07A67B0502"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2D45784-C53B-4A11-B1B3-BC68B514002D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "E969979B-2852-453D-AF48-A462448D4C62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "0E56E3E2-9142-47F5-B53E-61ACE4FA9A90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "CE0CFEA6-1AC0-41AA-BEF0-16FE1A933758"}]}]}], "references": [{"url": "http://freeradius.org/press/index.html#2.1.10", "source": "secalert@redhat.com"}, {"url": "http://github.com/alandekok/freeradius-server/commit/ff94dd35673bba1476594299d31ce8293b8bd223", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2010/10/01/3", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2010/10/01/8", "source": "secalert@redhat.com"}, {"url": "https://bugs.freeradius.org/bugzilla/show_bug.cgi?id=35", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=639397", "source": "secalert@redhat.com"}]}, "github_commit_url": "http://github.com/alandekok/freeradius-server/commit/ff94dd35673bba1476594299d31ce8293b8bd223"}}