{"buggy_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/* mk_request.c */\n#include \"mk_header.h\"\n#include \"mk_file.h\"\n#include \"mk_memory.h\"\n#include \"mk_scheduler.h\"\n#include \"mk_limits.h\"\n\n#ifndef MK_REQUEST_H\n#define MK_REQUEST_H\n\n/* Request buffer chunks = 4KB */\n#define MK_REQUEST_CHUNK (int) 4096\n#define MK_REQUEST_DEFAULT_PAGE  \"<HTML><HEAD><STYLE type=\\\"text/css\\\"> body {font-size: 12px;} </STYLE></HEAD><BODY><H1>%s</H1>%s<BR><HR><ADDRESS>Powered by %s</ADDRESS></BODY></HTML>\"\n\n#define MK_CRLF \"\\r\\n\"\n#define MK_ENDBLOCK \"\\r\\n\\r\\n\"\n\nextern const mk_ptr_t mk_crlf;\nextern const mk_ptr_t mk_endblock;\n\n/* Headers */\n#define RH_ACCEPT \"Accept:\"\n#define RH_ACCEPT_CHARSET \"Accept-Charset:\"\n#define RH_ACCEPT_ENCODING \"Accept-Encoding:\"\n#define RH_ACCEPT_LANGUAGE \"Accept-Language:\"\n#define RH_CONNECTION \"Connection:\"\n#define RH_COOKIE \"Cookie:\"\n#define RH_CONTENT_LENGTH \"Content-Length:\"\n#define RH_CONTENT_RANGE \"Content-Range:\"\n#define RH_CONTENT_TYPE\t\"Content-Type:\"\n#define RH_IF_MODIFIED_SINCE \"If-Modified-Since:\"\n#define RH_HOST\t\"Host:\"\n#define RH_LAST_MODIFIED \"Last-Modified:\"\n#define RH_LAST_MODIFIED_SINCE \"Last-Modified-Since:\"\n#define RH_REFERER \"Referer:\"\n#define RH_RANGE \"Range:\"\n#define RH_USER_AGENT \"User-Agent:\"\n\nextern const mk_ptr_t mk_rh_accept;\nextern const mk_ptr_t mk_rh_accept_charset;\nextern const mk_ptr_t mk_rh_accept_encoding;\nextern const mk_ptr_t mk_rh_accept_language;\nextern const mk_ptr_t mk_rh_connection;\nextern const mk_ptr_t mk_rh_cookie;\nextern const mk_ptr_t mk_rh_content_length;\nextern const mk_ptr_t mk_rh_content_range;\nextern const mk_ptr_t mk_rh_content_type;\nextern const mk_ptr_t mk_rh_if_modified_since;\nextern const mk_ptr_t mk_rh_host;\nextern const mk_ptr_t mk_rh_last_modified;\nextern const mk_ptr_t mk_rh_last_modified_since;\nextern const mk_ptr_t mk_rh_referer;\nextern const mk_ptr_t mk_rh_range;\nextern const mk_ptr_t mk_rh_user_agent;\n\n/* String limits */\n#define MAX_REQUEST_METHOD 10\n#define MAX_REQUEST_URI 1025\n#define MAX_REQUEST_PROTOCOL 10\n#define MAX_SCRIPTALIAS 3\n\n#define MK_REQUEST_STATUS_INCOMPLETE -1\n#define MK_REQUEST_STATUS_COMPLETED 0\n\n#define EXIT_NORMAL 0\n#define EXIT_ERROR -1\n#define EXIT_ABORT -2\n#define EXIT_PCONNECTION 24\n\n#define MK_HEADERS_TOC_LEN 32\n\nstruct response_headers\n{\n    int status;\n\n    /* Connection flag, if equal -1, the connection header is ommited */\n    int connection;\n\n    /*\n     * If some plugins wants to set a customized HTTP status, here\n     * is the 'how and where'\n     */\n    mk_ptr_t custom_status;\n\n    /* Length of the content to send */\n    long content_length;\n\n    /* Private value, real length of the file requested */\n    long real_length;\n\n    int cgi;\n    int pconnections_left;\n    int breakline;\n\n    int transfer_encoding;\n\n    int ranges[2];\n\n    time_t last_modified;\n    mk_ptr_t allow_methods;\n    mk_ptr_t content_type;\n    mk_ptr_t content_encoding;\n    char *location;\n\n    /*\n     * This field allow plugins to add their own response\n     * headers\n     */\n    struct mk_iov *_extra_rows;\n\n    /* Flag to track if the response headers were sent */\n    int sent;\n\n};\n\nstruct header_toc_row\n{\n    char *init;\n    char *end;\n    int status;                 /* 0: not found, 1: found = skip! */\n};\n\nstruct headers_toc\n{\n    struct header_toc_row rows[MK_HEADERS_TOC_LEN];\n    int length;\n};\n\nstruct session_request\n{\n    int status;\n    int protocol;\n    /* is keep-alive request ? */\n    int keep_alive;\n\n    /* is it serving a user's home directory ? */\n    int user_home;\n\n    /*-Connection-*/\n    long port;\n    /*------------*/\n\n    /* file descriptors */\n    int fd_file;\n\n    int headers_len;\n\n    /*----First header of client request--*/\n    int method;\n    mk_ptr_t method_p;\n    mk_ptr_t uri;                  /* original request */\n    mk_ptr_t uri_processed;        /* processed request (decoded) */\n\n    mk_ptr_t protocol_p;\n\n    mk_ptr_t body;\n\n\n\n\n\n    /* If request specify Connection: close, Monkey will\n     * close the connection after send the response, by\n     * default this var is set to VAR_OFF;\n     */\n    int close_now;\n\n    /*---Request headers--*/\n    int content_length;\n\n    mk_ptr_t content_type;\n    mk_ptr_t connection;\n\n    mk_ptr_t host;\n    mk_ptr_t host_port;\n    mk_ptr_t if_modified_since;\n    mk_ptr_t last_modified_since;\n    mk_ptr_t range;\n\n    /*---------------------*/\n\n    /* POST/PUT data */\n    mk_ptr_t data;\n    /*-----------------*/\n\n    /*-Internal-*/\n    mk_ptr_t real_path;        /* Absolute real path */\n\n    /*\n     * If a full URL length is less than MAX_PATH_BASE (defined in limits.h),\n     * it will be stored here and real_path will point this buffer\n     */\n    char real_path_static[MK_PATH_BASE];\n\n    /* Query string: ?.... */\n    mk_ptr_t query_string;\n\n\n    /* STAGE_30 block flag: in mk_http_init() when the file is not found, it\n     * triggers the plugin STAGE_30 to look for a plugin handler. In some\n     * cases the plugin would overwrite the real path of the requested file\n     * and make Monkey handle the new path for the static file. At this point\n     * we need to block STAGE_30 calls from mk_http_init().\n     *\n     * For short.. if a plugin overwrites the real_path, let Monkey handle that\n     * and do not trigger more STAGE_30's.\n     */\n    int stage30_blocked;\n\n    /* Static file information */\n    long loop;\n    long bytes_to_send;\n    off_t bytes_offset;\n    struct file_info file_info;\n\n    /* Vhost */\n    int vhost_fdt_id;\n    unsigned int vhost_fdt_hash;\n\n    struct host       *host_conf;     /* root vhost config */\n    struct host_alias *host_alias;    /* specific vhost matched */\n\n    /* Response headers */\n    struct response_headers headers;\n\n    struct mk_list _head;\n    /* HTTP Headers Table of Content */\n    struct headers_toc headers_toc;\n\n};\n\nstruct client_session\n{\n    int pipelined;              /* Pipelined request */\n    int socket;\n    int counter_connections;    /* Count persistent connections */\n    int status;                 /* Request status */\n\n    unsigned int body_size;\n    unsigned int body_length;\n\n    int body_pos_end;\n    int first_method;\n\n    /* red-black tree head */\n    struct rb_node _rb_head;\n    struct mk_list request_list;\n    struct mk_list request_incomplete;\n\n    time_t init_time;\n\n    /* request body buffer */\n    char *body;\n\n    /* Initial fixed size buffer for small requests */\n    char body_fixed[MK_REQUEST_CHUNK];\n    struct session_request sr_fixed;\n};\n\nextern pthread_key_t request_list;\n\n/* Request plugin Handler, each request can be handled by\n * several plugins, we handle list in a simple list */\nstruct handler\n{\n    struct plugin *p;\n    struct handler *next;\n};\n\nvoid mk_request_free(struct session_request *sr);\nint mk_request_header_toc_parse(struct headers_toc *toc, const char *data, int len);\nmk_ptr_t mk_request_index(char *pathfile, char *file_aux, const unsigned int flen);\nmk_ptr_t mk_request_header_get(struct headers_toc *toc,\n                                 const char *key_name, int key_len);\n\nint mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr);\n\nvoid mk_request_free_list(struct client_session *cs);\n\nstruct client_session *mk_session_create(int socket, struct sched_list_node *sched);\nstruct client_session *mk_session_get(int socket);\nvoid mk_session_remove(int socket);\n\nvoid mk_request_init_error_msgs(void);\n\nint mk_handler_read(int socket, struct client_session *cs);\nint mk_handler_write(int socket, struct client_session *cs);\n\nvoid mk_request_ka_next(struct client_session *cs);\n#endif\n", "/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <time.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <fcntl.h>\n\n#include <monkey/monkey.h>\n#include <monkey/mk_request.h>\n#include <monkey/mk_http.h>\n#include <monkey/mk_http_status.h>\n#include <monkey/mk_string.h>\n#include <monkey/mk_config.h>\n#include <monkey/mk_scheduler.h>\n#include <monkey/mk_epoll.h>\n#include <monkey/mk_utils.h>\n#include <monkey/mk_header.h>\n#include <monkey/mk_user.h>\n#include <monkey/mk_method.h>\n#include <monkey/mk_memory.h>\n#include <monkey/mk_socket.h>\n#include <monkey/mk_cache.h>\n#include <monkey/mk_clock.h>\n#include <monkey/mk_plugin.h>\n#include <monkey/mk_macros.h>\n#include <monkey/mk_vhost.h>\n#include <monkey/mk_server.h>\n\nconst mk_ptr_t mk_crlf = mk_ptr_init(MK_CRLF);\nconst mk_ptr_t mk_endblock = mk_ptr_init(MK_ENDBLOCK);\n\nconst mk_ptr_t mk_rh_accept = mk_ptr_init(RH_ACCEPT);\nconst mk_ptr_t mk_rh_accept_charset = mk_ptr_init(RH_ACCEPT_CHARSET);\nconst mk_ptr_t mk_rh_accept_encoding = mk_ptr_init(RH_ACCEPT_ENCODING);\nconst mk_ptr_t mk_rh_accept_language = mk_ptr_init(RH_ACCEPT_LANGUAGE);\nconst mk_ptr_t mk_rh_connection = mk_ptr_init(RH_CONNECTION);\nconst mk_ptr_t mk_rh_cookie = mk_ptr_init(RH_COOKIE);\nconst mk_ptr_t mk_rh_content_length = mk_ptr_init(RH_CONTENT_LENGTH);\nconst mk_ptr_t mk_rh_content_range = mk_ptr_init(RH_CONTENT_RANGE);\nconst mk_ptr_t mk_rh_content_type = mk_ptr_init(RH_CONTENT_TYPE);\nconst mk_ptr_t mk_rh_if_modified_since = mk_ptr_init(RH_IF_MODIFIED_SINCE);\nconst mk_ptr_t mk_rh_host = mk_ptr_init(RH_HOST);\nconst mk_ptr_t mk_rh_last_modified = mk_ptr_init(RH_LAST_MODIFIED);\nconst mk_ptr_t mk_rh_last_modified_since = mk_ptr_init(RH_LAST_MODIFIED_SINCE);\nconst mk_ptr_t mk_rh_referer = mk_ptr_init(RH_REFERER);\nconst mk_ptr_t mk_rh_range = mk_ptr_init(RH_RANGE);\nconst mk_ptr_t mk_rh_user_agent = mk_ptr_init(RH_USER_AGENT);\n\npthread_key_t request_list;\n\n/* Create a memory allocation in order to handle the request data */\nstatic inline void mk_request_init(struct session_request *request)\n{\n    request->status = MK_TRUE;\n    request->method = MK_HTTP_METHOD_UNKNOWN;\n\n    request->file_info.size = -1;\n\n    request->bytes_to_send = -1;\n    request->fd_file = -1;\n\n    /* Response Headers */\n    mk_header_response_reset(&request->headers);\n}\n\nvoid mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}\n\nint mk_request_header_toc_parse(struct headers_toc *toc, const char *data, int len)\n{\n    int i = 0;\n    int header_len;\n    int colon;\n    char *q;\n    char *p = (char *) data;\n    char *l = p;\n\n    toc->length = 0;\n\n    for (i = 0; l < (data + len) && p && i < MK_HEADERS_TOC_LEN; i++) {\n        if (*p == '\\r') goto out;\n\n        /* Locate the colon character and the end of the line by CRLF */\n        colon = -1;\n        for (q = p; *q != 0x0D; ++q) {\n            if (*q == ':' && colon == -1) {\n                colon = (q - p);\n            }\n        }\n\n        /* it must be a LF after CR */\n        if (*(q + 1) != 0x0A) {\n            return -1;\n        }\n\n        /*\n         * Check if we reach the last header, take in count the first one can\n         * be also the last.\n         */\n        if (data + len == (q - 1) && colon == -1) {\n            break;\n        }\n\n        /*\n         * By this version we force that after the colon must exists a white\n         * space before the value field\n         */\n        if (*(p + colon + 1) != 0x20) {\n            return -1;\n        }\n\n\n        /* Each header key must have a value */\n        header_len = q - p - colon - 2;\n        if (header_len == 0) {\n            return -1;\n        }\n\n        /* Register the entry */\n        toc->rows[i].init = p;\n        toc->rows[i].end = q;\n        toc->rows[i].status = 0;\n        p = (q + mk_crlf.len);\n        l = p;\n        toc->length++;\n    }\n\n out:\n    return toc->length;\n}\n\n/* Return a struct with method, URI , protocol version\nand all static headers defined here sent in request */\nstatic int mk_request_header_process(struct session_request *sr)\n{\n    int uri_init = 0, uri_end = 0;\n    int query_init = 0;\n    int prot_init = 0, prot_end = 0, pos_sep = 0;\n    int fh_limit;\n    char *headers;\n    char *temp = 0;\n    mk_ptr_t host;\n\n    /* Method */\n    sr->method_p = mk_http_method_check_str(sr->method);\n\n    /* Request URI */\n    temp = index(sr->body.data, ' ');\n    if (mk_unlikely(!temp)) {\n        MK_TRACE(\"Error, invalid first header\");\n        return -1;\n    }\n    uri_init = (temp - sr->body.data) + 1;\n\n    temp = index(sr->body.data, '\\n');\n    if (mk_unlikely(!temp)) {\n        MK_TRACE(\"Error, invalid header CRLF\");\n        return -1;\n    }\n    fh_limit = (temp - sr->body.data);\n\n    uri_end = mk_string_char_search_r(sr->body.data, ' ', fh_limit) - 1;\n    if (mk_unlikely(uri_end <= 0)) {\n        MK_TRACE(\"Error, first header bad formed\");\n        return -1;\n    }\n\n    prot_init = uri_end + 2;\n\n    if (mk_unlikely(uri_end < uri_init)) {\n        return -1;\n    }\n\n    /* Query String */\n    query_init = mk_string_char_search(sr->body.data + uri_init, '?', prot_init - uri_init);\n    if (query_init > 0) {\n        int init, end;\n\n        init = query_init + uri_init;\n        if (init <= uri_end) {\n            end = uri_end;\n            uri_end = init - 1;\n\n            sr->query_string = mk_ptr_create(sr->body.data,\n                                                 init + 1, end + 1);\n        }\n    }\n\n    /* Request URI Part 2 */\n    sr->uri = mk_ptr_create(sr->body.data, uri_init, uri_end + 1);\n    if (mk_unlikely(sr->uri.len < 1)) {\n        return -1;\n    }\n\n    /* HTTP Version */\n    prot_end = fh_limit - 1;\n    if (mk_unlikely(prot_init == prot_end)) {\n        return  -1;\n    }\n\n    if (prot_end != prot_init && prot_end > 0) {\n        sr->protocol = mk_http_protocol_check(sr->body.data + prot_init,\n                                              prot_end - prot_init);\n        sr->protocol_p = mk_http_protocol_check_str(sr->protocol);\n    }\n\n    headers = sr->body.data + prot_end + mk_crlf.len;\n\n    /*\n     * Process URI, if it contains ASCII encoded strings like '%20',\n     * it will return a new memory buffer with the decoded string, otherwise\n     * it returns NULL\n     */\n    temp = mk_utils_url_decode(sr->uri);\n    if (temp) {\n        sr->uri_processed.data = temp;\n        sr->uri_processed.len  = strlen(temp);\n    }\n    else {\n        sr->uri_processed.data = sr->uri.data;\n        sr->uri_processed.len  = sr->uri.len;\n    }\n\n    /* Creating Table of Content (index) for HTTP headers */\n    sr->headers_len = sr->body.len - (prot_end + mk_crlf.len);\n    if (mk_request_header_toc_parse(&sr->headers_toc, headers, sr->headers_len) < 0) {\n        MK_TRACE(\"Invalid headers\");\n        return -1;\n    }\n\n    /* Host */\n    host = mk_request_header_get(&sr->headers_toc,\n                                 mk_rh_host.data,\n                                 mk_rh_host.len);\n    if (host.data) {\n        if ((pos_sep = mk_string_char_search_r(host.data, ':', host.len)) >= 0) {\n            /* TCP port should not be higher than 65535 */\n            char *p;\n            short int port_len, port_size = 6;\n            char port[port_size];\n\n            /* just the host */\n            sr->host.data = host.data;\n            sr->host.len = pos_sep;\n\n            /* including the port */\n            sr->host_port = host;\n\n            /* Port string length */\n            port_len = (host.len - pos_sep - 1);\n            if (port_len >= port_size) {\n                return -1;\n            }\n\n            /* Copy to buffer */\n            memcpy(port, host.data + pos_sep + 1, port_len);\n            port[port_len] = '\\0';\n\n            /* Validate that the input port is numeric */\n            p = port;\n            while (*p) {\n                if (!isdigit(*p)) return -1;\n                p++;\n            }\n\n            /* Convert to base 10 */\n            errno = 0;\n            sr->port = strtol(port, (char **) NULL, 10);\n            if ((errno == ERANGE && (sr->port == LONG_MAX || sr->port == LONG_MIN))\n                || sr->port == 0) {\n                return -1;\n            }\n        }\n        else {\n            sr->host = host;    /* maybe null */\n            sr->port = config->standard_port;\n        }\n    }\n    else {\n        sr->host.data = NULL;\n    }\n\n    /* Looking for headers that ONLY Monkey uses */\n    sr->connection = mk_request_header_get(&sr->headers_toc,\n                                           mk_rh_connection.data,\n                                           mk_rh_connection.len);\n\n    sr->range = mk_request_header_get(&sr->headers_toc,\n                                      mk_rh_range.data,\n                                      mk_rh_range.len);\n\n    sr->if_modified_since = mk_request_header_get(&sr->headers_toc,\n                                                  mk_rh_if_modified_since.data,\n                                                  mk_rh_if_modified_since.len);\n\n    /* Default Keepalive is off */\n    if (sr->protocol == MK_HTTP_PROTOCOL_10) {\n        sr->keep_alive = MK_FALSE;\n        sr->close_now = MK_TRUE;\n    }\n    else if(sr->protocol == MK_HTTP_PROTOCOL_11) {\n        sr->keep_alive = MK_TRUE;\n        sr->close_now = MK_FALSE;\n    }\n    if (sr->connection.data) {\n        if (mk_string_search_n(sr->connection.data, \"Keep-Alive\",\n                               MK_STR_INSENSITIVE, sr->connection.len) >= 0) {\n            sr->keep_alive = MK_TRUE;\n            sr->close_now = MK_FALSE;\n        }\n        else if (mk_string_search_n(sr->connection.data, \"Close\",\n                                    MK_STR_INSENSITIVE, sr->connection.len) >= 0) {\n            sr->keep_alive = MK_FALSE;\n            sr->close_now = MK_TRUE;\n        }\n        else {\n            /* Set as a non-valid connection header value */\n            sr->connection.len = 0;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mk_request_parse(struct client_session *cs)\n{\n    int i, end;\n    int blocks = 0;\n    struct session_request *sr_node;\n    struct mk_list *sr_list, *sr_head;\n\n    for (i = 0; i <= cs->body_pos_end; i++) {\n        /*\n         * Pipelining can just exists in a persistent connection or\n         * well known as KeepAlive, so if we are in keepalive mode\n         * we should check if we have multiple request in our body buffer\n         */\n        end = mk_string_search(cs->body + i, mk_endblock.data, MK_STR_SENSITIVE) + i;\n        if (end <  0) {\n            return -1;\n        }\n\n        /* Allocating request block */\n        if (blocks == 0) {\n            sr_node = &cs->sr_fixed;\n            memset(sr_node, '\\0', sizeof(struct session_request));\n        }\n        else {\n            sr_node = mk_mem_malloc_z(sizeof(struct session_request));\n        }\n        mk_request_init(sr_node);\n\n        /* We point the block with a mk_ptr_t */\n        sr_node->body.data = cs->body + i;\n        sr_node->body.len = end - i;\n\n        /* Method, previous catch in mk_http_pending_request */\n        if (i == 0) {\n            sr_node->method = cs->first_method;\n        }\n        else {\n            sr_node->method = mk_http_method_get(sr_node->body.data);\n        }\n\n        /* Looking for POST data */\n        if (sr_node->method == MK_HTTP_METHOD_POST) {\n            int offset;\n            offset = end + mk_endblock.len;\n            sr_node->data = mk_method_get_data(cs->body + offset,\n                                               cs->body_length - offset);\n        }\n\n        /* Increase index to the end of the current block */\n        i = (end + mk_endblock.len) - 1;\n\n        /* Link block */\n        mk_list_add(&sr_node->_head, &cs->request_list);\n\n        /* Update counter */\n        blocks++;\n    }\n\n    /* DEBUG BLOCKS\n    struct mk_list *head;\n    struct session_request *entry;\n\n    printf(\"\\n*******************\\n\");\n    mk_list_foreach(head, &cs->request_list) {\n        entry = mk_list_entry(head, struct session_request, _head);\n        mk_ptr_print(entry->body);\n        fflush(stdout);\n    }\n    */\n\n    /* Checking pipelining connection */\n    if (blocks > 1) {\n        sr_list = &cs->request_list;\n        mk_list_foreach(sr_head, sr_list) {\n            sr_node = mk_list_entry(sr_head, struct session_request, _head);\n            /* Pipelining request must use GET or HEAD methods */\n            if (sr_node->method != MK_HTTP_METHOD_GET &&\n                sr_node->method != MK_HTTP_METHOD_HEAD) {\n                return -1;\n            }\n        }\n        cs->pipelined = MK_TRUE;\n    }\n\n#ifdef TRACE\n    int b = 0;\n    if (cs->pipelined == MK_TRUE) {\n        MK_TRACE(\"[FD %i] Pipeline Requests: %i blocks\", cs->socket, blocks);\n        sr_list = &cs->request_list;\n        mk_list_foreach(sr_head, sr_list) {\n            sr_node = mk_list_entry(sr_head, struct session_request, _head);\n            MK_TRACE(\"[FD %i] Pipeline Block #%i: %p\", cs->socket, b, sr_node);\n            b++;\n        }\n    }\n#endif\n\n    return 0;\n}\n\n/* This function allow the core to invoke the closing connection process\n * when some connection was not proceesed due to a premature close or similar\n * exception, it also take care of invoke the STAGE_40 and STAGE_50 plugins events\n */\nstatic void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}\n\nstatic int mk_request_process(struct client_session *cs, struct session_request *sr)\n{\n    int status = 0;\n    int socket = cs->socket;\n    struct mk_list *hosts = &config->hosts;\n    struct mk_list *alias;\n\n    /* Always assign the first node 'default vhost' */\n    sr->host_conf = mk_list_entry_first(hosts, struct host, _head);\n\n    /* Parse request */\n    status = mk_request_header_process(sr);\n    if (status < 0) {\n        mk_header_set_http_status(sr, MK_CLIENT_BAD_REQUEST);\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_ABORT;\n    }\n\n    sr->user_home = MK_FALSE;\n\n    /* Valid request URI? */\n    if (sr->uri_processed.data[0] != '/') {\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_NORMAL;\n    }\n\n    /* HTTP/1.1 needs Host header */\n    if (!sr->host.data && sr->protocol == MK_HTTP_PROTOCOL_11) {\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_NORMAL;\n    }\n\n    /* Validating protocol version */\n    if (sr->protocol == MK_HTTP_PROTOCOL_UNKNOWN) {\n        mk_request_error(MK_SERVER_HTTP_VERSION_UNSUP, cs, sr);\n        return EXIT_ABORT;\n    }\n\n    /* Assign the first node alias */\n    alias = &sr->host_conf->server_names;\n    sr->host_alias = mk_list_entry_first(alias,\n                                         struct host_alias, _head);\n\n    if (sr->host.data) {\n        /* Match the virtual host */\n        mk_vhost_get(sr->host, &sr->host_conf, &sr->host_alias);\n\n        /* Check if this virtual host have some redirection */\n        if (sr->host_conf->header_redirect.data) {\n            mk_header_set_http_status(sr, MK_REDIR_MOVED);\n            sr->headers.location = mk_string_dup(sr->host_conf->header_redirect.data);\n            sr->headers.content_length = 0;\n            mk_header_send(cs->socket, cs, sr);\n            sr->headers.location = NULL;\n            mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n            return 0;\n        }\n    }\n\n    /* Is requesting an user home directory ? */\n    if (config->user_dir &&\n        sr->uri_processed.len > 2 &&\n        sr->uri_processed.data[1] == MK_USER_HOME) {\n\n        if (mk_user_init(cs, sr) != 0) {\n            mk_request_error(MK_CLIENT_NOT_FOUND, cs, sr);\n            return EXIT_ABORT;\n        }\n    }\n\n    /* Handling method requested */\n    if (sr->method == MK_HTTP_METHOD_POST || sr->method == MK_HTTP_METHOD_PUT) {\n        if ((status = mk_method_parse_data(cs, sr)) != 0) {\n            return status;\n        }\n    }\n\n    /* Plugins Stage 20 */\n    int ret;\n    ret = mk_plugin_stage_run(MK_PLUGIN_STAGE_20, socket, NULL, cs, sr);\n    if (ret == MK_PLUGIN_RET_CLOSE_CONX) {\n        MK_TRACE(\"STAGE 20 requested close conexion\");\n        return EXIT_ABORT;\n    }\n\n    /* Normal HTTP process */\n    status = mk_http_init(cs, sr);\n\n    MK_TRACE(\"[FD %i] HTTP Init returning %i\", socket, status);\n\n    return status;\n}\n\n/* Build error page */\nstatic mk_ptr_t *mk_request_set_default_page(char *title, mk_ptr_t message,\n                                        char *signature)\n{\n    char *temp;\n    mk_ptr_t *p;\n\n    p = mk_mem_malloc(sizeof(mk_ptr_t));\n    p->data = NULL;\n\n    temp = mk_ptr_to_buf(message);\n    mk_string_build(&p->data, &p->len,\n                    MK_REQUEST_DEFAULT_PAGE, title, temp, signature);\n\n    mk_mem_free(temp);\n\n    return p;\n}\n\nint mk_handler_read(int socket, struct client_session *cs)\n{\n    int bytes;\n    int max_read;\n    int available = 0;\n    int new_size;\n    int total_bytes = 0;\n    char *tmp = 0;\n\n    MK_TRACE(\"MAX REQUEST SIZE: %i\", config->max_request_size);\n\n try_pending:\n\n    available = cs->body_size - cs->body_length;\n    if (available <= 0) {\n        /* Reallocate buffer size if pending data does not have space */\n        new_size = cs->body_size + config->transport_buffer_size;\n        if (new_size > config->max_request_size) {\n            MK_TRACE(\"Requested size is > config->max_request_size\");\n            mk_request_premature_close(MK_CLIENT_REQUEST_ENTITY_TOO_LARGE, cs);\n            return -1;\n        }\n\n        /*\n         * Check if the body field still points to the initial body_fixed, if so,\n         * allow the new space required in body, otherwise perform a realloc over\n         * body.\n         */\n        if (cs->body == cs->body_fixed) {\n            cs->body = mk_mem_malloc(new_size + 1);\n            cs->body_size = new_size;\n            memcpy(cs->body, cs->body_fixed, cs->body_length);\n            MK_TRACE(\"[FD %i] New size: %i, length: %i\",\n                     cs->socket, new_size, cs->body_length);\n        }\n        else {\n            MK_TRACE(\"[FD %i] Realloc from %i to %i\",\n                     cs->socket, cs->body_size, new_size);\n            tmp = mk_mem_realloc(cs->body, new_size + 1);\n            if (tmp) {\n                cs->body = tmp;\n                cs->body_size = new_size;\n            }\n            else {\n                mk_request_premature_close(MK_SERVER_INTERNAL_ERROR, cs);\n                return -1;\n            }\n        }\n    }\n\n    /* Read content */\n    max_read = (cs->body_size - cs->body_length);\n    bytes = mk_socket_read(socket, cs->body + cs->body_length, max_read);\n\n    MK_TRACE(\"[FD %i] read %i\", socket, bytes);\n\n    if (bytes < 0) {\n        if (errno == EAGAIN) {\n            return 1;\n        }\n        else {\n            mk_session_remove(socket);\n            return -1;\n        }\n    }\n    if (bytes == 0) {\n        mk_session_remove(socket);\n        return -1;\n    }\n\n    if (bytes > 0) {\n        if (bytes > max_read) {\n            MK_TRACE(\"[FD %i] Buffer still have data: %i\",\n                     cs->socket, bytes - max_read);\n\n            cs->body_length += max_read;\n            cs->body[cs->body_length] = '\\0';\n            total_bytes += max_read;\n\n            goto try_pending;\n        }\n        else {\n            cs->body_length += bytes;\n            cs->body[cs->body_length] = '\\0';\n\n            total_bytes += bytes;\n        }\n\n        MK_TRACE(\"[FD %i] Retry total bytes: %i\",\n                 cs->socket, total_bytes);\n        return total_bytes;\n    }\n\n    return bytes;\n}\n\nint mk_handler_write(int socket, struct client_session *cs)\n{\n    int final_status = 0;\n    struct session_request *sr_node;\n    struct mk_list *sr_list;\n\n    if (mk_list_is_empty(&cs->request_list) == 0) {\n        if (mk_request_parse(cs) != 0) {\n            return -1;\n        }\n    }\n\n    sr_list = &cs->request_list;\n\n    sr_node = mk_list_entry_first(sr_list, struct session_request, _head);\n\n    if (sr_node->bytes_to_send > 0) {\n        /* Request with data to send by static file sender */\n        final_status = mk_http_send_file(cs, sr_node);\n    }\n    else if (sr_node->bytes_to_send < 0) {\n        final_status = mk_request_process(cs, sr_node);\n    }\n\n    /*\n     * If we got an error, we don't want to parse\n     * and send information for another pipelined request\n     */\n    if (final_status > 0) {\n        return final_status;\n    }\n    else {\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, socket,\n                            NULL, cs, sr_node);\n        switch (final_status) {\n        case EXIT_NORMAL:\n        case EXIT_ERROR:\n            if (sr_node->close_now == MK_TRUE) {\n                return -1;\n            }\n            break;\n        case EXIT_ABORT:\n            return -1;\n        }\n    }\n\n    /*\n     * If we are here, is because all pipelined request were\n     * processed successfully, let's return 0\n     */\n    return 0;\n}\n\n/* Look for some  index.xxx in pathfile */\nmk_ptr_t mk_request_index(char *pathfile, char *file_aux, const unsigned int flen)\n{\n    unsigned long len;\n    mk_ptr_t f;\n    struct mk_string_line *entry;\n    struct mk_list *head;\n\n    mk_ptr_reset(&f);\n    if (!config->index_files) return f;\n\n    mk_list_foreach(head, config->index_files) {\n        entry = mk_list_entry(head, struct mk_string_line, _head);\n        len = snprintf(file_aux, flen, \"%s%s\", pathfile, entry->val);\n        if (mk_unlikely(len > flen)) {\n            len = flen - 1;\n            mk_warn(\"Path too long, truncated! '%s'\", file_aux);\n        }\n\n        if (access(file_aux, F_OK) == 0) {\n            f.data = file_aux;\n            f.len = len;\n            return f;\n        }\n    }\n\n    return f;\n}\n\n/* Send error responses */\nint mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr) {\n    int ret, fd;\n    mk_ptr_t message, *page = 0;\n    struct error_page *entry;\n    struct mk_list *head;\n    struct file_info finfo;\n\n    mk_header_set_http_status(sr, http_status);\n\n    /*\n     * We are nice sending error pages for clients who at least respect\n     * the especification\n     */\n    if (http_status != MK_CLIENT_LENGTH_REQUIRED &&\n        http_status != MK_CLIENT_BAD_REQUEST &&\n        http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {\n\n        /* Lookup a customized error page */\n        mk_list_foreach(head, &sr->host_conf->error_pages) {\n            entry = mk_list_entry(head, struct error_page, _head);\n            if (entry->status != http_status) {\n                continue;\n            }\n\n            /* validate error file */\n            ret = mk_file_get_info(entry->real_path, &finfo);\n            if (ret == -1) {\n                break;\n            }\n\n            /* open file */\n            fd = open(entry->real_path, config->open_flags);\n            if (fd == -1) {\n                break;\n            }\n\n            sr->fd_file = fd;\n            sr->bytes_to_send = finfo.size;\n            sr->headers.content_length = finfo.size;\n            sr->headers.real_length    = finfo.size;\n\n            memcpy(&sr->file_info, &finfo, sizeof(struct file_info));\n\n            mk_header_send(cs->socket, cs, sr);\n            return mk_http_send_file(cs, sr);\n        }\n    }\n\n    mk_ptr_reset(&message);\n\n    switch (http_status) {\n    case MK_CLIENT_BAD_REQUEST:\n        page = mk_request_set_default_page(\"Bad Request\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_FORBIDDEN:\n        page = mk_request_set_default_page(\"Forbidden\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_NOT_FOUND:\n        mk_string_build(&message.data, &message.len,\n                        \"The requested URL was not found on this server.\");\n        page = mk_request_set_default_page(\"Not Found\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:\n        mk_string_build(&message.data, &message.len,\n                        \"The request entity is too large.\");\n        page = mk_request_set_default_page(\"Entity too large\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_METHOD_NOT_ALLOWED:\n        page = mk_request_set_default_page(\"Method Not Allowed\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_REQUEST_TIMEOUT:\n    case MK_CLIENT_LENGTH_REQUIRED:\n        break;\n\n    case MK_SERVER_NOT_IMPLEMENTED:\n        page = mk_request_set_default_page(\"Method Not Implemented\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_INTERNAL_ERROR:\n        page = mk_request_set_default_page(\"Internal Server Error\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_HTTP_VERSION_UNSUP:\n        mk_ptr_reset(&message);\n        page = mk_request_set_default_page(\"HTTP Version Not Supported\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        break;\n    }\n\n    if (page) {\n        sr->headers.content_length = page->len;\n    }\n\n    sr->headers.location = NULL;\n    sr->headers.cgi = SH_NOCGI;\n    sr->headers.pconnections_left = 0;\n    sr->headers.last_modified = -1;\n\n    if (!page) {\n        mk_ptr_reset(&sr->headers.content_type);\n    }\n    else {\n        mk_ptr_set(&sr->headers.content_type, \"text/html\\r\\n\");\n    }\n\n    mk_header_send(cs->socket, cs, sr);\n\n    if (page) {\n        if (sr->method != MK_HTTP_METHOD_HEAD)\n            mk_socket_send(cs->socket, page->data, page->len);\n\n        mk_ptr_free(page);\n        mk_mem_free(page);\n    }\n\n    /* Turn off TCP_CORK */\n    mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n    return EXIT_ERROR;\n}\n\nvoid mk_request_free_list(struct client_session *cs)\n{\n    struct session_request *sr_node;\n    struct mk_list *sr_head, *temp;\n\n    /* sr = last node */\n    MK_TRACE(\"[FD %i] Free struct client_session\", cs->socket);\n\n    mk_list_foreach_safe(sr_head, temp, &cs->request_list) {\n        sr_node = mk_list_entry(sr_head, struct session_request, _head);\n        mk_list_del(sr_head);\n\n        mk_request_free(sr_node);\n        if (sr_node != &cs->sr_fixed) {\n            mk_mem_free(sr_node);\n        }\n    }\n}\n\n/* Create a client request struct and put it on the\n * main list\n */\nstruct client_session *mk_session_create(int socket, struct sched_list_node *sched)\n{\n    struct client_session *cs;\n    struct sched_connection *sc;\n\n    sc = mk_sched_get_connection(sched, socket);\n    if (!sc) {\n        MK_TRACE(\"[FD %i] No sched node, could not create session\", socket);\n        return NULL;\n    }\n\n    /* Alloc memory for node */\n    cs = mk_mem_malloc(sizeof(struct client_session));\n\n    cs->pipelined = MK_FALSE;\n    cs->counter_connections = 0;\n    cs->socket = socket;\n    cs->status = MK_REQUEST_STATUS_INCOMPLETE;\n    mk_list_add(&cs->request_incomplete, cs_incomplete);\n\n    /* creation time in unix time */\n    cs->init_time = sc->arrive_time;\n\n    /* alloc space for body content */\n    if (config->transport_buffer_size > MK_REQUEST_CHUNK) {\n        cs->body = mk_mem_malloc(config->transport_buffer_size);\n        cs->body_size = config->transport_buffer_size;\n    }\n    else {\n        /* Buffer size based in Chunk bytes */\n        cs->body = cs->body_fixed;\n        cs->body_size = MK_REQUEST_CHUNK;\n    }\n\n    /* Current data length */\n    cs->body_length = 0;\n\n    cs->body_pos_end = -1;\n    cs->first_method = MK_HTTP_METHOD_UNKNOWN;\n\n    /* Init session request list */\n    mk_list_init(&cs->request_list);\n\n    /* Add this SESSION to the thread list */\n\n    /* Add node to list */\n    /* Red-Black tree insert routine */\n    struct rb_node **new = &(cs_list->rb_node);\n    struct rb_node *parent = NULL;\n\n    /* Figure out where to put new node */\n    while (*new) {\n        struct client_session *this = container_of(*new, struct client_session, _rb_head);\n\n        parent = *new;\n        if (cs->socket < this->socket)\n            new = &((*new)->rb_left);\n        else if (cs->socket > this->socket)\n            new = &((*new)->rb_right);\n        else {\n            break;\n        }\n    }\n    /* Add new node and rebalance tree. */\n    rb_link_node(&cs->_rb_head, parent, new);\n    rb_insert_color(&cs->_rb_head, cs_list);\n\n    return cs;\n}\n\nstruct client_session *mk_session_get(int socket)\n{\n    struct client_session *cs;\n    struct rb_node *node;\n\n    node = cs_list->rb_node;\n  \twhile (node) {\n  \t\tcs = container_of(node, struct client_session, _rb_head);\n\t\tif (socket < cs->socket)\n  \t\t\tnode = node->rb_left;\n\t\telse if (socket > cs->socket)\n  \t\t\tnode = node->rb_right;\n\t\telse {\n  \t\t\treturn cs;\n        }\n\t}\n\treturn NULL;\n}\n\n/*\n * From thread sched_list_node \"list\", remove the client_session\n * struct information\n */\nvoid mk_session_remove(int socket)\n{\n    struct client_session *cs_node;\n\n    cs_node = mk_session_get(socket);\n    if (cs_node) {\n        rb_erase(&cs_node->_rb_head, cs_list);\n        if (cs_node->body != cs_node->body_fixed) {\n            mk_mem_free(cs_node->body);\n        }\n        if (mk_list_entry_orphan(&cs_node->request_incomplete) == 0) {\n            mk_list_del(&cs_node->request_incomplete);\n        }\n        mk_list_del(&cs_node->request_list);\n        mk_mem_free(cs_node);\n    }\n}\n\n/* Return value of some variable sent in request */\nmk_ptr_t mk_request_header_get(struct headers_toc *toc, const char *key_name, int key_len)\n{\n    int i;\n    struct header_toc_row *row;\n    mk_ptr_t var;\n\n    var.data = NULL;\n    var.len = 0;\n\n    row = toc->rows;\n    for (i = 0; i < toc->length; i++) {\n\n        /*\n         * status = 1 means that the toc entry was already\n         * checked by Monkey\n         */\n        if (row[i].status == 1) {\n            continue;\n        }\n\n        if (strncasecmp(row[i].init, key_name, key_len) == 0) {\n            var.data = row[i].init + key_len + 1;\n            var.len = row[i].end - var.data;\n            row[i].status = 1;\n            break;\n        }\n    }\n\n    return var;\n}\n\nvoid mk_request_ka_next(struct client_session *cs)\n{\n    cs->first_method = -1;\n    cs->body_pos_end = -1;\n    cs->body_length = 0;\n    cs->counter_connections++;\n\n    /* Update data for scheduler */\n    cs->init_time = log_current_utime;\n    cs->status = MK_REQUEST_STATUS_INCOMPLETE;\n    mk_list_add(&cs->request_incomplete, cs_incomplete);\n}\n", "/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n\n#include <monkey/mk_list.h>\n#include <monkey/mk_vhost.h>\n#include <monkey/mk_utils.h>\n#include <monkey/mk_macros.h>\n#include <monkey/mk_config.h>\n#include <monkey/mk_string.h>\n#include <monkey/mk_http_status.h>\n#include <monkey/mk_memory.h>\n#include <monkey/mk_request.h>\n#include <monkey/mk_info.h>\n#include <monkey/mk_file.h>\n\n/* Initialize Virtual Host FDT mutex */\npthread_mutex_t mk_vhost_fdt_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic __thread struct mk_list *mk_vhost_fdt_key;\n\n/*\n * This function is triggered upon thread creation (inside the thread\n * context), here we configure per-thread data.\n */\nint mk_vhost_fdt_worker_init()\n{\n    int i;\n    int j;\n    struct host *h;\n    struct mk_list *list;\n    struct mk_list *head;\n    struct vhost_fdt_host *fdt;\n    struct vhost_fdt_hash_table *ht;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return -1;\n    }\n\n    /*\n     * We are under a thread context and the main configuration is\n     * already in place. Now for every existent virtual host we are\n     * going to create the File Descriptor Table (FDT) which aims to\n     * hold references of 'open and shared' file descriptors under\n     * the Virtual Host context.\n     */\n\n    /*\n     * Under an initialization context we need to protect this critical\n     * section\n     */\n    pthread_mutex_lock(&mk_vhost_fdt_mutex);\n\n    /*\n     * Initialize the thread FDT/Hosts list and create an entry per\n     * existent virtual host\n     */\n    list = mk_mem_malloc_z(sizeof(struct mk_list));\n    mk_list_init(list);\n\n    mk_list_foreach(head, &config->hosts) {\n        h = mk_list_entry(head, struct host, _head);\n\n        fdt = mk_mem_malloc(sizeof(struct vhost_fdt_host));\n        fdt->host = h;\n\n        /* Initialize hash table */\n        for (i = 0; i < VHOST_FDT_HASHTABLE_SIZE; i++) {\n            ht = &fdt->hash_table[i];\n            ht->av_slots = VHOST_FDT_HASHTABLE_CHAINS;\n\n            /* for each chain under the hash table, set the fd */\n            for (j = 0; j < VHOST_FDT_HASHTABLE_CHAINS; j++) {\n                hc = &ht->chain[j];\n                hc->fd      = -1;\n                hc->hash    =  0;\n                hc->readers =  0;\n            }\n        }\n        mk_list_add(&fdt->_head, list);\n    }\n\n    mk_vhost_fdt_key = list;\n    pthread_mutex_unlock(&mk_vhost_fdt_mutex);\n\n    return 0;\n}\n\nint mk_vhost_fdt_worker_exit()\n{\n    struct mk_list *head;\n    struct mk_list *tmp;\n    struct vhost_fdt_host *fdt;\n\n    if (config->fdt == MK_FALSE) {\n        return -1;\n    }\n\n    mk_list_foreach_safe(head, tmp, mk_vhost_fdt_key) {\n        fdt = mk_list_entry(head, struct vhost_fdt_host, _head);\n        mk_list_del(&fdt->_head);\n        mk_mem_free(fdt);\n    }\n\n    mk_mem_free(mk_vhost_fdt_key);\n    return 0;\n}\n\n\nstatic inline\nstruct vhost_fdt_hash_table *mk_vhost_fdt_table_lookup(int id, struct host *host)\n{\n    struct mk_list *head;\n    struct mk_list *vhost_list;\n    struct vhost_fdt_host *fdt_host;\n    struct vhost_fdt_hash_table *ht = NULL;\n\n    vhost_list = mk_vhost_fdt_key;\n    mk_list_foreach(head, vhost_list) {\n        fdt_host = mk_list_entry(head, struct vhost_fdt_host, _head);\n        if (fdt_host->host == host) {\n            ht = &fdt_host->hash_table[id];\n            return ht;\n        }\n    }\n\n    return ht;\n}\n\nstatic inline\nstruct vhost_fdt_hash_chain\n*mk_vhost_fdt_chain_lookup(unsigned int hash, struct vhost_fdt_hash_table *ht)\n{\n    int i;\n    struct vhost_fdt_hash_chain *hc = NULL;\n\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->hash == hash) {\n            return hc;\n        }\n    }\n\n    return NULL;\n}\n\n\nstatic inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and return the shared FD */\n        hc->readers++;\n        return hc->fd;\n    }\n\n    /*\n     * Get here means that no entry exists in the hash table for the\n     * requested file descriptor and hash, we must try to open the file\n     * and register the entry in the table.\n     */\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n\n    /* If chains are full, just return the new FD, bad luck... */\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n\n    /* Register the new entry in an available slot */\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n\n            return fd;\n        }\n    }\n\n    return -1;\n}\n\nstatic inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    return close(sr->fd_file);\n}\n\n\nint mk_vhost_open(struct session_request *sr)\n{\n    int id;\n    int off;\n    unsigned int hash;\n\n    off = sr->host_conf->documentroot.len;\n    hash = mk_utils_gen_hash(sr->real_path.data + off,\n                             sr->real_path.len - off);\n    id   = (hash % VHOST_FDT_HASHTABLE_SIZE);\n\n    return mk_vhost_fdt_open(id, hash, sr);\n}\n\nint mk_vhost_close(struct session_request *sr)\n{\n    return mk_vhost_fdt_close(sr);\n}\n\n/*\n * Open a virtual host configuration file and return a structure with\n * definitions.\n */\nstruct host *mk_vhost_read(char *path)\n{\n    unsigned long len = 0;\n    char *tmp;\n    char *host_low;\n    struct stat checkdir;\n    struct host *host;\n    struct host_alias *new_alias;\n    struct error_page *err_page;\n    struct mk_config *cnf;\n    struct mk_config_section *section_host;\n    struct mk_config_section *section_ep;\n    struct mk_config_entry *entry_ep;\n    struct mk_string_line *entry;\n    struct mk_list *head, *list;\n\n    /* Read configuration file */\n    cnf = mk_config_create(path);\n    if (!cnf) {\n        mk_err(\"Configuration error, aborting.\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Read tag 'HOST' */\n    section_host = mk_config_section_get(cnf, \"HOST\");\n    if (!section_host) {\n        mk_err(\"Invalid config file %s\", path);\n        return NULL;\n    }\n\n    /* Alloc configuration node */\n    host = mk_mem_malloc_z(sizeof(struct host));\n    host->config = cnf;\n    host->file = mk_string_dup(path);\n\n    /* Init list for custom error pages */\n    mk_list_init(&host->error_pages);\n\n    /* Init list for host name aliases */\n    mk_list_init(&host->server_names);\n\n    /* Lookup Servername */\n    list = mk_config_section_getval(section_host, \"Servername\", MK_CONFIG_VAL_LIST);\n    if (!list) {\n        mk_err(\"Hostname does not contain a Servername\");\n        exit(EXIT_FAILURE);\n    }\n\n    mk_list_foreach(head, list) {\n        entry = mk_list_entry(head, struct mk_string_line, _head);\n        if (entry->len > MK_HOSTNAME_LEN - 1) {\n            continue;\n        }\n\n        /* Hostname to lowercase */\n        host_low = mk_string_tolower(entry->val);\n\n        /* Alloc node */\n        new_alias = mk_mem_malloc_z(sizeof(struct host_alias));\n        new_alias->name = mk_mem_malloc_z(entry->len + 1);\n        strncpy(new_alias->name, host_low, entry->len);\n        mk_mem_free(host_low);\n\n        new_alias->len = entry->len;\n\n        mk_list_add(&new_alias->_head, &host->server_names);\n    }\n    mk_string_split_free(list);\n\n    /* Lookup document root handled by a mk_ptr_t */\n    host->documentroot.data = mk_config_section_getval(section_host,\n                                                       \"DocumentRoot\",\n                                                       MK_CONFIG_VAL_STR);\n    if (!host->documentroot.data) {\n        mk_err(\"Missing DocumentRoot entry on %s file\", path);\n        mk_config_free(cnf);\n        return NULL;\n    }\n\n    host->documentroot.len = strlen(host->documentroot.data);\n\n    /* Validate document root configured */\n    if (stat(host->documentroot.data, &checkdir) == -1) {\n        mk_err(\"Invalid path to DocumentRoot in %s\", path);\n    }\n    else if (!(checkdir.st_mode & S_IFDIR)) {\n        mk_err(\"DocumentRoot variable in %s has an invalid directory path\", path);\n    }\n\n    if (mk_list_is_empty(&host->server_names) == 0) {\n        mk_config_free(cnf);\n        return NULL;\n    }\n\n    /* Check Virtual Host redirection */\n    host->header_redirect.data = NULL;\n    host->header_redirect.len  = 0;\n\n    tmp = mk_config_section_getval(section_host,\n                                   \"Redirect\",\n                                   MK_CONFIG_VAL_STR);\n    if (tmp) {\n        host->header_redirect.data = mk_string_dup(tmp);\n        host->header_redirect.len  = strlen(tmp);\n        mk_mem_free(tmp);\n    }\n\n    /* Error Pages */\n    section_ep = mk_config_section_get(cnf, \"ERROR_PAGES\");\n    if (section_ep) {\n        mk_list_foreach(head, &section_ep->entries) {\n            entry_ep = mk_list_entry(head, struct mk_config_entry, _head);\n\n            int ep_status = -1;\n            char *ep_file = NULL;\n            unsigned long len;\n\n            ep_status = atoi(entry_ep->key);\n            ep_file   = entry_ep->val;\n\n            /* Validate input values */\n            if (ep_status < MK_CLIENT_BAD_REQUEST ||\n                ep_status > MK_SERVER_HTTP_VERSION_UNSUP ||\n                ep_file == NULL) {\n                continue;\n            }\n\n            /* Alloc error page node */\n            err_page = mk_mem_malloc_z(sizeof(struct error_page));\n            err_page->status = ep_status;\n            err_page->file   = mk_string_dup(ep_file);\n            err_page->real_path = NULL;\n            mk_string_build(&err_page->real_path, &len, \"%s/%s\",\n                            host->documentroot.data, err_page->file);\n\n            MK_TRACE(\"Map error page: status %i -> %s\", err_page->status, err_page->file);\n\n            /* Link page to the error page list */\n            mk_list_add(&err_page->_head, &host->error_pages);\n        }\n    }\n\n    /* Server Signature */\n    if (config->hideversion == MK_FALSE) {\n        mk_string_build(&host->host_signature, &len,\n                        \"Monkey/%s\", VERSION);\n    }\n    else {\n        mk_string_build(&host->host_signature, &len, \"Monkey\");\n    }\n    mk_string_build(&host->header_host_signature.data,\n                    &host->header_host_signature.len,\n                    \"Server: %s\", host->host_signature);\n\n    return host;\n}\n\nvoid mk_vhost_set_single(char *path)\n{\n    struct host *host;\n    struct host_alias *halias;\n    struct stat checkdir;\n    unsigned long len = 0;\n\n    /* Set the default host */\n    host = mk_mem_malloc_z(sizeof(struct host));\n    mk_list_init(&host->error_pages);\n    mk_list_init(&host->server_names);\n\n    /* Prepare the unique alias */\n    halias = mk_mem_malloc_z(sizeof(struct host_alias));\n    halias->name = mk_string_dup(\"127.0.0.1\");\n    mk_list_add(&halias->_head, &host->server_names);\n\n    host->documentroot.data = mk_string_dup(path);\n    host->documentroot.len = strlen(path);\n    host->header_redirect.data = NULL;\n\n    /* Validate document root configured */\n    if (stat(host->documentroot.data, &checkdir) == -1) {\n        mk_err(\"Invalid path to DocumentRoot in %s\", path);\n        exit(EXIT_FAILURE);\n    }\n    else if (!(checkdir.st_mode & S_IFDIR)) {\n        mk_err(\"DocumentRoot variable in %s has an invalid directory path\", path);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Server Signature */\n    if (config->hideversion == MK_FALSE) {\n        mk_string_build(&host->host_signature, &len,\n                        \"Monkey/%s\", VERSION);\n    }\n    else {\n        mk_string_build(&host->host_signature, &len, \"Monkey\");\n    }\n\n    mk_string_build(&host->header_host_signature.data,\n                    &host->header_host_signature.len,\n                    \"Server: %s\", host->host_signature);\n\n    mk_list_add(&host->_head, &config->hosts);\n}\n\n/* Given a configuration directory, start reading the virtual host entries */\nvoid mk_vhost_init(char *path)\n{\n    DIR *dir;\n    unsigned long len;\n    char *buf = 0;\n    char *sites = 0;\n    char *file;\n    struct host *p_host;     /* debug */\n    struct dirent *ent;\n    struct file_info f_info;\n    int ret;\n\n    /* Read default virtual host file */\n    mk_string_build(&sites, &len, \"%s/%s/\", path, config->sites_conf_dir);\n    ret = mk_file_get_info(sites, &f_info);\n    if (ret == -1 || f_info.is_directory == MK_FALSE) {\n        mk_mem_free(sites);\n        sites = config->sites_conf_dir;\n    }\n\n    mk_string_build(&buf, &len, \"%s/default\", sites);\n\n    p_host = mk_vhost_read(buf);\n    if (!p_host) {\n        mk_err(\"Error parsing main configuration file 'default'\");\n    }\n    mk_list_add(&p_host->_head, &config->hosts);\n    config->nhosts++;\n    mk_mem_free(buf);\n    buf = NULL;\n\n\n    /* Read all virtual hosts defined in sites/ */\n    if (!(dir = opendir(sites))) {\n        mk_mem_free(sites);\n        mk_err(\"Could not open %s\", sites);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Reading content */\n    while ((ent = readdir(dir)) != NULL) {\n        if (ent->d_name[0] == '.') {\n            continue;\n        }\n        if (strcmp((char *) ent->d_name, \"..\") == 0) {\n            continue;\n        }\n        if (ent->d_name[strlen(ent->d_name) - 1] ==  '~') {\n            continue;\n        }\n        if (strcasecmp((char *) ent->d_name, \"default\") == 0) {\n            continue;\n        }\n        file = NULL;\n        mk_string_build(&file, &len, \"%s/%s\", sites, ent->d_name);\n\n        p_host = mk_vhost_read(file);\n        mk_mem_free(file);\n        if (!p_host) {\n            continue;\n        }\n        else {\n            mk_list_add(&p_host->_head, &config->hosts);\n            config->nhosts++;\n        }\n    }\n    closedir(dir);\n    mk_mem_free(sites);\n}\n\n\n/* Lookup a registered virtual host based on the given 'host' input */\nint mk_vhost_get(mk_ptr_t host, struct host **vhost, struct host_alias **alias)\n{\n    struct host *entry_host;\n    struct host_alias *entry_alias;\n    struct mk_list *head_vhost, *head_alias;\n\n    mk_list_foreach(head_vhost, &config->hosts) {\n        entry_host = mk_list_entry(head_vhost, struct host, _head);\n        mk_list_foreach(head_alias, &entry_host->server_names) {\n            entry_alias = mk_list_entry(head_alias, struct host_alias, _head);\n            if (entry_alias->len == host.len &&\n                strncmp(entry_alias->name, host.data, host.len) == 0) {\n                *vhost = entry_host;\n                *alias = entry_alias;\n                return 0;\n            }\n        }\n    }\n\n    return -1;\n}\n\nvoid mk_vhost_free_all()\n{\n    struct host *host;\n    struct host_alias *host_alias;\n    struct error_page *ep;\n    struct mk_list *head_host;\n    struct mk_list *head_alias;\n    struct mk_list *head_error;\n    struct mk_list *tmp1, *tmp2;\n\n    mk_list_foreach_safe(head_host, tmp1, &config->hosts) {\n        host = mk_list_entry(head_host, struct host, _head);\n        mk_list_del(&host->_head);\n\n        mk_mem_free(host->file);\n\n        /* Free aliases or servernames */\n        mk_list_foreach_safe(head_alias, tmp2, &host->server_names) {\n            host_alias = mk_list_entry(head_alias, struct host_alias, _head);\n            mk_list_del(&host_alias->_head);\n            mk_mem_free(host_alias->name);\n            mk_mem_free(host_alias);\n        }\n\n        /* Free error pages */\n        mk_list_foreach_safe(head_error, tmp2, &host->error_pages) {\n            ep = mk_list_entry(head_error, struct error_page, _head);\n            mk_list_del(&ep->_head);\n            mk_mem_free(ep->file);\n            mk_mem_free(ep->real_path);\n            mk_mem_free(ep);\n        }\n\n        mk_ptr_free(&host->documentroot);\n        mk_mem_free(host->host_signature);\n        mk_ptr_free(&host->header_host_signature);\n\n        /* Free source configuration */\n        if (host->config) mk_config_free(host->config);\n        mk_mem_free(host);\n    }\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/* mk_request.c */\n#include \"mk_header.h\"\n#include \"mk_file.h\"\n#include \"mk_memory.h\"\n#include \"mk_scheduler.h\"\n#include \"mk_limits.h\"\n\n#ifndef MK_REQUEST_H\n#define MK_REQUEST_H\n\n/* Request buffer chunks = 4KB */\n#define MK_REQUEST_CHUNK (int) 4096\n#define MK_REQUEST_DEFAULT_PAGE  \"<HTML><HEAD><STYLE type=\\\"text/css\\\"> body {font-size: 12px;} </STYLE></HEAD><BODY><H1>%s</H1>%s<BR><HR><ADDRESS>Powered by %s</ADDRESS></BODY></HTML>\"\n\n#define MK_CRLF \"\\r\\n\"\n#define MK_ENDBLOCK \"\\r\\n\\r\\n\"\n\nextern const mk_ptr_t mk_crlf;\nextern const mk_ptr_t mk_endblock;\n\n/* Headers */\n#define RH_ACCEPT \"Accept:\"\n#define RH_ACCEPT_CHARSET \"Accept-Charset:\"\n#define RH_ACCEPT_ENCODING \"Accept-Encoding:\"\n#define RH_ACCEPT_LANGUAGE \"Accept-Language:\"\n#define RH_CONNECTION \"Connection:\"\n#define RH_COOKIE \"Cookie:\"\n#define RH_CONTENT_LENGTH \"Content-Length:\"\n#define RH_CONTENT_RANGE \"Content-Range:\"\n#define RH_CONTENT_TYPE\t\"Content-Type:\"\n#define RH_IF_MODIFIED_SINCE \"If-Modified-Since:\"\n#define RH_HOST\t\"Host:\"\n#define RH_LAST_MODIFIED \"Last-Modified:\"\n#define RH_LAST_MODIFIED_SINCE \"Last-Modified-Since:\"\n#define RH_REFERER \"Referer:\"\n#define RH_RANGE \"Range:\"\n#define RH_USER_AGENT \"User-Agent:\"\n\nextern const mk_ptr_t mk_rh_accept;\nextern const mk_ptr_t mk_rh_accept_charset;\nextern const mk_ptr_t mk_rh_accept_encoding;\nextern const mk_ptr_t mk_rh_accept_language;\nextern const mk_ptr_t mk_rh_connection;\nextern const mk_ptr_t mk_rh_cookie;\nextern const mk_ptr_t mk_rh_content_length;\nextern const mk_ptr_t mk_rh_content_range;\nextern const mk_ptr_t mk_rh_content_type;\nextern const mk_ptr_t mk_rh_if_modified_since;\nextern const mk_ptr_t mk_rh_host;\nextern const mk_ptr_t mk_rh_last_modified;\nextern const mk_ptr_t mk_rh_last_modified_since;\nextern const mk_ptr_t mk_rh_referer;\nextern const mk_ptr_t mk_rh_range;\nextern const mk_ptr_t mk_rh_user_agent;\n\n/* String limits */\n#define MAX_REQUEST_METHOD 10\n#define MAX_REQUEST_URI 1025\n#define MAX_REQUEST_PROTOCOL 10\n#define MAX_SCRIPTALIAS 3\n\n#define MK_REQUEST_STATUS_INCOMPLETE -1\n#define MK_REQUEST_STATUS_COMPLETED 0\n\n#define EXIT_NORMAL 0\n#define EXIT_ERROR -1\n#define EXIT_ABORT -2\n#define EXIT_PCONNECTION 24\n\n#define MK_HEADERS_TOC_LEN 32\n\nstruct response_headers\n{\n    int status;\n\n    /* Connection flag, if equal -1, the connection header is ommited */\n    int connection;\n\n    /*\n     * If some plugins wants to set a customized HTTP status, here\n     * is the 'how and where'\n     */\n    mk_ptr_t custom_status;\n\n    /* Length of the content to send */\n    long content_length;\n\n    /* Private value, real length of the file requested */\n    long real_length;\n\n    int cgi;\n    int pconnections_left;\n    int breakline;\n\n    int transfer_encoding;\n\n    int ranges[2];\n\n    time_t last_modified;\n    mk_ptr_t allow_methods;\n    mk_ptr_t content_type;\n    mk_ptr_t content_encoding;\n    char *location;\n\n    /*\n     * This field allow plugins to add their own response\n     * headers\n     */\n    struct mk_iov *_extra_rows;\n\n    /* Flag to track if the response headers were sent */\n    int sent;\n\n};\n\nstruct header_toc_row\n{\n    char *init;\n    char *end;\n    int status;                 /* 0: not found, 1: found = skip! */\n};\n\nstruct headers_toc\n{\n    struct header_toc_row rows[MK_HEADERS_TOC_LEN];\n    int length;\n};\n\nstruct session_request\n{\n    int status;\n    int protocol;\n    /* is keep-alive request ? */\n    int keep_alive;\n\n    /* is it serving a user's home directory ? */\n    int user_home;\n\n    /*-Connection-*/\n    long port;\n    /*------------*/\n\n    /*\n     * Static file file descriptor: the following twp fields represents an\n     * opened file in the file system and a flag saying which mechanism\n     * was used to open it.\n     *\n     *  - fd_file  : common file descriptor\n     *  - fd_is_fdt: set to MK_TRUE if fd_file was opened using Vhost FDT, or\n     *               MK_FALSE for the opposite case.\n     */\n    int fd_file;\n    int fd_is_fdt;\n\n\n    int headers_len;\n\n    /*----First header of client request--*/\n    int method;\n    mk_ptr_t method_p;\n    mk_ptr_t uri;                  /* original request */\n    mk_ptr_t uri_processed;        /* processed request (decoded) */\n\n    mk_ptr_t protocol_p;\n\n    mk_ptr_t body;\n\n\n\n\n\n    /* If request specify Connection: close, Monkey will\n     * close the connection after send the response, by\n     * default this var is set to VAR_OFF;\n     */\n    int close_now;\n\n    /*---Request headers--*/\n    int content_length;\n\n    mk_ptr_t content_type;\n    mk_ptr_t connection;\n\n    mk_ptr_t host;\n    mk_ptr_t host_port;\n    mk_ptr_t if_modified_since;\n    mk_ptr_t last_modified_since;\n    mk_ptr_t range;\n\n    /*---------------------*/\n\n    /* POST/PUT data */\n    mk_ptr_t data;\n    /*-----------------*/\n\n    /*-Internal-*/\n    mk_ptr_t real_path;        /* Absolute real path */\n\n    /*\n     * If a full URL length is less than MAX_PATH_BASE (defined in limits.h),\n     * it will be stored here and real_path will point this buffer\n     */\n    char real_path_static[MK_PATH_BASE];\n\n    /* Query string: ?.... */\n    mk_ptr_t query_string;\n\n\n    /* STAGE_30 block flag: in mk_http_init() when the file is not found, it\n     * triggers the plugin STAGE_30 to look for a plugin handler. In some\n     * cases the plugin would overwrite the real path of the requested file\n     * and make Monkey handle the new path for the static file. At this point\n     * we need to block STAGE_30 calls from mk_http_init().\n     *\n     * For short.. if a plugin overwrites the real_path, let Monkey handle that\n     * and do not trigger more STAGE_30's.\n     */\n    int stage30_blocked;\n\n    /* Static file information */\n    long loop;\n    long bytes_to_send;\n    off_t bytes_offset;\n    struct file_info file_info;\n\n    /* Vhost */\n    int vhost_fdt_id;\n    unsigned int vhost_fdt_hash;\n\n    struct host       *host_conf;     /* root vhost config */\n    struct host_alias *host_alias;    /* specific vhost matched */\n\n    /* Response headers */\n    struct response_headers headers;\n\n    struct mk_list _head;\n    /* HTTP Headers Table of Content */\n    struct headers_toc headers_toc;\n\n};\n\nstruct client_session\n{\n    int pipelined;              /* Pipelined request */\n    int socket;\n    int counter_connections;    /* Count persistent connections */\n    int status;                 /* Request status */\n\n    unsigned int body_size;\n    unsigned int body_length;\n\n    int body_pos_end;\n    int first_method;\n\n    /* red-black tree head */\n    struct rb_node _rb_head;\n    struct mk_list request_list;\n    struct mk_list request_incomplete;\n\n    time_t init_time;\n\n    /* request body buffer */\n    char *body;\n\n    /* Initial fixed size buffer for small requests */\n    char body_fixed[MK_REQUEST_CHUNK];\n    struct session_request sr_fixed;\n};\n\nextern pthread_key_t request_list;\n\n/* Request plugin Handler, each request can be handled by\n * several plugins, we handle list in a simple list */\nstruct handler\n{\n    struct plugin *p;\n    struct handler *next;\n};\n\nvoid mk_request_free(struct session_request *sr);\nint mk_request_header_toc_parse(struct headers_toc *toc, const char *data, int len);\nmk_ptr_t mk_request_index(char *pathfile, char *file_aux, const unsigned int flen);\nmk_ptr_t mk_request_header_get(struct headers_toc *toc,\n                                 const char *key_name, int key_len);\n\nint mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr);\n\nvoid mk_request_free_list(struct client_session *cs);\n\nstruct client_session *mk_session_create(int socket, struct sched_list_node *sched);\nstruct client_session *mk_session_get(int socket);\nvoid mk_session_remove(int socket);\n\nvoid mk_request_init_error_msgs(void);\n\nint mk_handler_read(int socket, struct client_session *cs);\nint mk_handler_write(int socket, struct client_session *cs);\n\nvoid mk_request_ka_next(struct client_session *cs);\n#endif\n", "/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <time.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <fcntl.h>\n\n#include <monkey/monkey.h>\n#include <monkey/mk_request.h>\n#include <monkey/mk_http.h>\n#include <monkey/mk_http_status.h>\n#include <monkey/mk_string.h>\n#include <monkey/mk_config.h>\n#include <monkey/mk_scheduler.h>\n#include <monkey/mk_epoll.h>\n#include <monkey/mk_utils.h>\n#include <monkey/mk_header.h>\n#include <monkey/mk_user.h>\n#include <monkey/mk_method.h>\n#include <monkey/mk_memory.h>\n#include <monkey/mk_socket.h>\n#include <monkey/mk_cache.h>\n#include <monkey/mk_clock.h>\n#include <monkey/mk_plugin.h>\n#include <monkey/mk_macros.h>\n#include <monkey/mk_vhost.h>\n#include <monkey/mk_server.h>\n\nconst mk_ptr_t mk_crlf = mk_ptr_init(MK_CRLF);\nconst mk_ptr_t mk_endblock = mk_ptr_init(MK_ENDBLOCK);\n\nconst mk_ptr_t mk_rh_accept = mk_ptr_init(RH_ACCEPT);\nconst mk_ptr_t mk_rh_accept_charset = mk_ptr_init(RH_ACCEPT_CHARSET);\nconst mk_ptr_t mk_rh_accept_encoding = mk_ptr_init(RH_ACCEPT_ENCODING);\nconst mk_ptr_t mk_rh_accept_language = mk_ptr_init(RH_ACCEPT_LANGUAGE);\nconst mk_ptr_t mk_rh_connection = mk_ptr_init(RH_CONNECTION);\nconst mk_ptr_t mk_rh_cookie = mk_ptr_init(RH_COOKIE);\nconst mk_ptr_t mk_rh_content_length = mk_ptr_init(RH_CONTENT_LENGTH);\nconst mk_ptr_t mk_rh_content_range = mk_ptr_init(RH_CONTENT_RANGE);\nconst mk_ptr_t mk_rh_content_type = mk_ptr_init(RH_CONTENT_TYPE);\nconst mk_ptr_t mk_rh_if_modified_since = mk_ptr_init(RH_IF_MODIFIED_SINCE);\nconst mk_ptr_t mk_rh_host = mk_ptr_init(RH_HOST);\nconst mk_ptr_t mk_rh_last_modified = mk_ptr_init(RH_LAST_MODIFIED);\nconst mk_ptr_t mk_rh_last_modified_since = mk_ptr_init(RH_LAST_MODIFIED_SINCE);\nconst mk_ptr_t mk_rh_referer = mk_ptr_init(RH_REFERER);\nconst mk_ptr_t mk_rh_range = mk_ptr_init(RH_RANGE);\nconst mk_ptr_t mk_rh_user_agent = mk_ptr_init(RH_USER_AGENT);\n\npthread_key_t request_list;\n\n/* Create a memory allocation in order to handle the request data */\nstatic inline void mk_request_init(struct session_request *request)\n{\n    request->status = MK_TRUE;\n    request->method = MK_HTTP_METHOD_UNKNOWN;\n\n    request->file_info.size = -1;\n\n    request->bytes_to_send = -1;\n    request->fd_file = -1;\n\n    /* Response Headers */\n    mk_header_response_reset(&request->headers);\n}\n\nvoid mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        if (sr->fd_is_fdt == MK_TRUE) {\n            mk_vhost_close(sr);\n        }\n        else {\n            close(sr->fd_file);\n        }\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}\n\nint mk_request_header_toc_parse(struct headers_toc *toc, const char *data, int len)\n{\n    int i = 0;\n    int header_len;\n    int colon;\n    char *q;\n    char *p = (char *) data;\n    char *l = p;\n\n    toc->length = 0;\n\n    for (i = 0; l < (data + len) && p && i < MK_HEADERS_TOC_LEN; i++) {\n        if (*p == '\\r') goto out;\n\n        /* Locate the colon character and the end of the line by CRLF */\n        colon = -1;\n        for (q = p; *q != 0x0D; ++q) {\n            if (*q == ':' && colon == -1) {\n                colon = (q - p);\n            }\n        }\n\n        /* it must be a LF after CR */\n        if (*(q + 1) != 0x0A) {\n            return -1;\n        }\n\n        /*\n         * Check if we reach the last header, take in count the first one can\n         * be also the last.\n         */\n        if (data + len == (q - 1) && colon == -1) {\n            break;\n        }\n\n        /*\n         * By this version we force that after the colon must exists a white\n         * space before the value field\n         */\n        if (*(p + colon + 1) != 0x20) {\n            return -1;\n        }\n\n\n        /* Each header key must have a value */\n        header_len = q - p - colon - 2;\n        if (header_len == 0) {\n            return -1;\n        }\n\n        /* Register the entry */\n        toc->rows[i].init = p;\n        toc->rows[i].end = q;\n        toc->rows[i].status = 0;\n        p = (q + mk_crlf.len);\n        l = p;\n        toc->length++;\n    }\n\n out:\n    return toc->length;\n}\n\n/* Return a struct with method, URI , protocol version\nand all static headers defined here sent in request */\nstatic int mk_request_header_process(struct session_request *sr)\n{\n    int uri_init = 0, uri_end = 0;\n    int query_init = 0;\n    int prot_init = 0, prot_end = 0, pos_sep = 0;\n    int fh_limit;\n    char *headers;\n    char *temp = 0;\n    mk_ptr_t host;\n\n    /* Method */\n    sr->method_p = mk_http_method_check_str(sr->method);\n\n    /* Request URI */\n    temp = index(sr->body.data, ' ');\n    if (mk_unlikely(!temp)) {\n        MK_TRACE(\"Error, invalid first header\");\n        return -1;\n    }\n    uri_init = (temp - sr->body.data) + 1;\n\n    temp = index(sr->body.data, '\\n');\n    if (mk_unlikely(!temp)) {\n        MK_TRACE(\"Error, invalid header CRLF\");\n        return -1;\n    }\n    fh_limit = (temp - sr->body.data);\n\n    uri_end = mk_string_char_search_r(sr->body.data, ' ', fh_limit) - 1;\n    if (mk_unlikely(uri_end <= 0)) {\n        MK_TRACE(\"Error, first header bad formed\");\n        return -1;\n    }\n\n    prot_init = uri_end + 2;\n\n    if (mk_unlikely(uri_end < uri_init)) {\n        return -1;\n    }\n\n    /* Query String */\n    query_init = mk_string_char_search(sr->body.data + uri_init, '?', prot_init - uri_init);\n    if (query_init > 0) {\n        int init, end;\n\n        init = query_init + uri_init;\n        if (init <= uri_end) {\n            end = uri_end;\n            uri_end = init - 1;\n\n            sr->query_string = mk_ptr_create(sr->body.data,\n                                                 init + 1, end + 1);\n        }\n    }\n\n    /* Request URI Part 2 */\n    sr->uri = mk_ptr_create(sr->body.data, uri_init, uri_end + 1);\n    if (mk_unlikely(sr->uri.len < 1)) {\n        return -1;\n    }\n\n    /* HTTP Version */\n    prot_end = fh_limit - 1;\n    if (mk_unlikely(prot_init == prot_end)) {\n        return  -1;\n    }\n\n    if (prot_end != prot_init && prot_end > 0) {\n        sr->protocol = mk_http_protocol_check(sr->body.data + prot_init,\n                                              prot_end - prot_init);\n        sr->protocol_p = mk_http_protocol_check_str(sr->protocol);\n    }\n\n    headers = sr->body.data + prot_end + mk_crlf.len;\n\n    /*\n     * Process URI, if it contains ASCII encoded strings like '%20',\n     * it will return a new memory buffer with the decoded string, otherwise\n     * it returns NULL\n     */\n    temp = mk_utils_url_decode(sr->uri);\n    if (temp) {\n        sr->uri_processed.data = temp;\n        sr->uri_processed.len  = strlen(temp);\n    }\n    else {\n        sr->uri_processed.data = sr->uri.data;\n        sr->uri_processed.len  = sr->uri.len;\n    }\n\n    /* Creating Table of Content (index) for HTTP headers */\n    sr->headers_len = sr->body.len - (prot_end + mk_crlf.len);\n    if (mk_request_header_toc_parse(&sr->headers_toc, headers, sr->headers_len) < 0) {\n        MK_TRACE(\"Invalid headers\");\n        return -1;\n    }\n\n    /* Host */\n    host = mk_request_header_get(&sr->headers_toc,\n                                 mk_rh_host.data,\n                                 mk_rh_host.len);\n    if (host.data) {\n        if ((pos_sep = mk_string_char_search_r(host.data, ':', host.len)) >= 0) {\n            /* TCP port should not be higher than 65535 */\n            char *p;\n            short int port_len, port_size = 6;\n            char port[port_size];\n\n            /* just the host */\n            sr->host.data = host.data;\n            sr->host.len = pos_sep;\n\n            /* including the port */\n            sr->host_port = host;\n\n            /* Port string length */\n            port_len = (host.len - pos_sep - 1);\n            if (port_len >= port_size) {\n                return -1;\n            }\n\n            /* Copy to buffer */\n            memcpy(port, host.data + pos_sep + 1, port_len);\n            port[port_len] = '\\0';\n\n            /* Validate that the input port is numeric */\n            p = port;\n            while (*p) {\n                if (!isdigit(*p)) return -1;\n                p++;\n            }\n\n            /* Convert to base 10 */\n            errno = 0;\n            sr->port = strtol(port, (char **) NULL, 10);\n            if ((errno == ERANGE && (sr->port == LONG_MAX || sr->port == LONG_MIN))\n                || sr->port == 0) {\n                return -1;\n            }\n        }\n        else {\n            sr->host = host;    /* maybe null */\n            sr->port = config->standard_port;\n        }\n    }\n    else {\n        sr->host.data = NULL;\n    }\n\n    /* Looking for headers that ONLY Monkey uses */\n    sr->connection = mk_request_header_get(&sr->headers_toc,\n                                           mk_rh_connection.data,\n                                           mk_rh_connection.len);\n\n    sr->range = mk_request_header_get(&sr->headers_toc,\n                                      mk_rh_range.data,\n                                      mk_rh_range.len);\n\n    sr->if_modified_since = mk_request_header_get(&sr->headers_toc,\n                                                  mk_rh_if_modified_since.data,\n                                                  mk_rh_if_modified_since.len);\n\n    /* Default Keepalive is off */\n    if (sr->protocol == MK_HTTP_PROTOCOL_10) {\n        sr->keep_alive = MK_FALSE;\n        sr->close_now = MK_TRUE;\n    }\n    else if(sr->protocol == MK_HTTP_PROTOCOL_11) {\n        sr->keep_alive = MK_TRUE;\n        sr->close_now = MK_FALSE;\n    }\n    if (sr->connection.data) {\n        if (mk_string_search_n(sr->connection.data, \"Keep-Alive\",\n                               MK_STR_INSENSITIVE, sr->connection.len) >= 0) {\n            sr->keep_alive = MK_TRUE;\n            sr->close_now = MK_FALSE;\n        }\n        else if (mk_string_search_n(sr->connection.data, \"Close\",\n                                    MK_STR_INSENSITIVE, sr->connection.len) >= 0) {\n            sr->keep_alive = MK_FALSE;\n            sr->close_now = MK_TRUE;\n        }\n        else {\n            /* Set as a non-valid connection header value */\n            sr->connection.len = 0;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mk_request_parse(struct client_session *cs)\n{\n    int i, end;\n    int blocks = 0;\n    struct session_request *sr_node;\n    struct mk_list *sr_list, *sr_head;\n\n    for (i = 0; i <= cs->body_pos_end; i++) {\n        /*\n         * Pipelining can just exists in a persistent connection or\n         * well known as KeepAlive, so if we are in keepalive mode\n         * we should check if we have multiple request in our body buffer\n         */\n        end = mk_string_search(cs->body + i, mk_endblock.data, MK_STR_SENSITIVE) + i;\n        if (end <  0) {\n            return -1;\n        }\n\n        /* Allocating request block */\n        if (blocks == 0) {\n            sr_node = &cs->sr_fixed;\n            memset(sr_node, '\\0', sizeof(struct session_request));\n        }\n        else {\n            sr_node = mk_mem_malloc_z(sizeof(struct session_request));\n        }\n        mk_request_init(sr_node);\n\n        /* We point the block with a mk_ptr_t */\n        sr_node->body.data = cs->body + i;\n        sr_node->body.len = end - i;\n\n        /* Method, previous catch in mk_http_pending_request */\n        if (i == 0) {\n            sr_node->method = cs->first_method;\n        }\n        else {\n            sr_node->method = mk_http_method_get(sr_node->body.data);\n        }\n\n        /* Looking for POST data */\n        if (sr_node->method == MK_HTTP_METHOD_POST) {\n            int offset;\n            offset = end + mk_endblock.len;\n            sr_node->data = mk_method_get_data(cs->body + offset,\n                                               cs->body_length - offset);\n        }\n\n        /* Increase index to the end of the current block */\n        i = (end + mk_endblock.len) - 1;\n\n        /* Link block */\n        mk_list_add(&sr_node->_head, &cs->request_list);\n\n        /* Update counter */\n        blocks++;\n    }\n\n    /* DEBUG BLOCKS\n    struct mk_list *head;\n    struct session_request *entry;\n\n    printf(\"\\n*******************\\n\");\n    mk_list_foreach(head, &cs->request_list) {\n        entry = mk_list_entry(head, struct session_request, _head);\n        mk_ptr_print(entry->body);\n        fflush(stdout);\n    }\n    */\n\n    /* Checking pipelining connection */\n    if (blocks > 1) {\n        sr_list = &cs->request_list;\n        mk_list_foreach(sr_head, sr_list) {\n            sr_node = mk_list_entry(sr_head, struct session_request, _head);\n            /* Pipelining request must use GET or HEAD methods */\n            if (sr_node->method != MK_HTTP_METHOD_GET &&\n                sr_node->method != MK_HTTP_METHOD_HEAD) {\n                return -1;\n            }\n        }\n        cs->pipelined = MK_TRUE;\n    }\n\n#ifdef TRACE\n    int b = 0;\n    if (cs->pipelined == MK_TRUE) {\n        MK_TRACE(\"[FD %i] Pipeline Requests: %i blocks\", cs->socket, blocks);\n        sr_list = &cs->request_list;\n        mk_list_foreach(sr_head, sr_list) {\n            sr_node = mk_list_entry(sr_head, struct session_request, _head);\n            MK_TRACE(\"[FD %i] Pipeline Block #%i: %p\", cs->socket, b, sr_node);\n            b++;\n        }\n    }\n#endif\n\n    return 0;\n}\n\n/* This function allow the core to invoke the closing connection process\n * when some connection was not proceesed due to a premature close or similar\n * exception, it also take care of invoke the STAGE_40 and STAGE_50 plugins events\n */\nstatic void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}\n\nstatic int mk_request_process(struct client_session *cs, struct session_request *sr)\n{\n    int status = 0;\n    int socket = cs->socket;\n    struct mk_list *hosts = &config->hosts;\n    struct mk_list *alias;\n\n    /* Always assign the first node 'default vhost' */\n    sr->host_conf = mk_list_entry_first(hosts, struct host, _head);\n\n    /* Parse request */\n    status = mk_request_header_process(sr);\n    if (status < 0) {\n        mk_header_set_http_status(sr, MK_CLIENT_BAD_REQUEST);\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_ABORT;\n    }\n\n    sr->user_home = MK_FALSE;\n\n    /* Valid request URI? */\n    if (sr->uri_processed.data[0] != '/') {\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_NORMAL;\n    }\n\n    /* HTTP/1.1 needs Host header */\n    if (!sr->host.data && sr->protocol == MK_HTTP_PROTOCOL_11) {\n        mk_request_error(MK_CLIENT_BAD_REQUEST, cs, sr);\n        return EXIT_NORMAL;\n    }\n\n    /* Validating protocol version */\n    if (sr->protocol == MK_HTTP_PROTOCOL_UNKNOWN) {\n        mk_request_error(MK_SERVER_HTTP_VERSION_UNSUP, cs, sr);\n        return EXIT_ABORT;\n    }\n\n    /* Assign the first node alias */\n    alias = &sr->host_conf->server_names;\n    sr->host_alias = mk_list_entry_first(alias,\n                                         struct host_alias, _head);\n\n    if (sr->host.data) {\n        /* Match the virtual host */\n        mk_vhost_get(sr->host, &sr->host_conf, &sr->host_alias);\n\n        /* Check if this virtual host have some redirection */\n        if (sr->host_conf->header_redirect.data) {\n            mk_header_set_http_status(sr, MK_REDIR_MOVED);\n            sr->headers.location = mk_string_dup(sr->host_conf->header_redirect.data);\n            sr->headers.content_length = 0;\n            mk_header_send(cs->socket, cs, sr);\n            sr->headers.location = NULL;\n            mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n            return 0;\n        }\n    }\n\n    /* Is requesting an user home directory ? */\n    if (config->user_dir &&\n        sr->uri_processed.len > 2 &&\n        sr->uri_processed.data[1] == MK_USER_HOME) {\n\n        if (mk_user_init(cs, sr) != 0) {\n            mk_request_error(MK_CLIENT_NOT_FOUND, cs, sr);\n            return EXIT_ABORT;\n        }\n    }\n\n    /* Handling method requested */\n    if (sr->method == MK_HTTP_METHOD_POST || sr->method == MK_HTTP_METHOD_PUT) {\n        if ((status = mk_method_parse_data(cs, sr)) != 0) {\n            return status;\n        }\n    }\n\n    /* Plugins Stage 20 */\n    int ret;\n    ret = mk_plugin_stage_run(MK_PLUGIN_STAGE_20, socket, NULL, cs, sr);\n    if (ret == MK_PLUGIN_RET_CLOSE_CONX) {\n        MK_TRACE(\"STAGE 20 requested close conexion\");\n        return EXIT_ABORT;\n    }\n\n    /* Normal HTTP process */\n    status = mk_http_init(cs, sr);\n\n    MK_TRACE(\"[FD %i] HTTP Init returning %i\", socket, status);\n\n    return status;\n}\n\n/* Build error page */\nstatic mk_ptr_t *mk_request_set_default_page(char *title, mk_ptr_t message,\n                                        char *signature)\n{\n    char *temp;\n    mk_ptr_t *p;\n\n    p = mk_mem_malloc(sizeof(mk_ptr_t));\n    p->data = NULL;\n\n    temp = mk_ptr_to_buf(message);\n    mk_string_build(&p->data, &p->len,\n                    MK_REQUEST_DEFAULT_PAGE, title, temp, signature);\n\n    mk_mem_free(temp);\n\n    return p;\n}\n\nint mk_handler_read(int socket, struct client_session *cs)\n{\n    int bytes;\n    int max_read;\n    int available = 0;\n    int new_size;\n    int total_bytes = 0;\n    char *tmp = 0;\n\n    MK_TRACE(\"MAX REQUEST SIZE: %i\", config->max_request_size);\n\n try_pending:\n\n    available = cs->body_size - cs->body_length;\n    if (available <= 0) {\n        /* Reallocate buffer size if pending data does not have space */\n        new_size = cs->body_size + config->transport_buffer_size;\n        if (new_size > config->max_request_size) {\n            MK_TRACE(\"Requested size is > config->max_request_size\");\n            mk_request_premature_close(MK_CLIENT_REQUEST_ENTITY_TOO_LARGE, cs);\n            return -1;\n        }\n\n        /*\n         * Check if the body field still points to the initial body_fixed, if so,\n         * allow the new space required in body, otherwise perform a realloc over\n         * body.\n         */\n        if (cs->body == cs->body_fixed) {\n            cs->body = mk_mem_malloc(new_size + 1);\n            cs->body_size = new_size;\n            memcpy(cs->body, cs->body_fixed, cs->body_length);\n            MK_TRACE(\"[FD %i] New size: %i, length: %i\",\n                     cs->socket, new_size, cs->body_length);\n        }\n        else {\n            MK_TRACE(\"[FD %i] Realloc from %i to %i\",\n                     cs->socket, cs->body_size, new_size);\n            tmp = mk_mem_realloc(cs->body, new_size + 1);\n            if (tmp) {\n                cs->body = tmp;\n                cs->body_size = new_size;\n            }\n            else {\n                mk_request_premature_close(MK_SERVER_INTERNAL_ERROR, cs);\n                return -1;\n            }\n        }\n    }\n\n    /* Read content */\n    max_read = (cs->body_size - cs->body_length);\n    bytes = mk_socket_read(socket, cs->body + cs->body_length, max_read);\n\n    MK_TRACE(\"[FD %i] read %i\", socket, bytes);\n\n    if (bytes < 0) {\n        if (errno == EAGAIN) {\n            return 1;\n        }\n        else {\n            mk_session_remove(socket);\n            return -1;\n        }\n    }\n    if (bytes == 0) {\n        mk_session_remove(socket);\n        return -1;\n    }\n\n    if (bytes > 0) {\n        if (bytes > max_read) {\n            MK_TRACE(\"[FD %i] Buffer still have data: %i\",\n                     cs->socket, bytes - max_read);\n\n            cs->body_length += max_read;\n            cs->body[cs->body_length] = '\\0';\n            total_bytes += max_read;\n\n            goto try_pending;\n        }\n        else {\n            cs->body_length += bytes;\n            cs->body[cs->body_length] = '\\0';\n\n            total_bytes += bytes;\n        }\n\n        MK_TRACE(\"[FD %i] Retry total bytes: %i\",\n                 cs->socket, total_bytes);\n        return total_bytes;\n    }\n\n    return bytes;\n}\n\nint mk_handler_write(int socket, struct client_session *cs)\n{\n    int final_status = 0;\n    struct session_request *sr_node;\n    struct mk_list *sr_list;\n\n    if (mk_list_is_empty(&cs->request_list) == 0) {\n        if (mk_request_parse(cs) != 0) {\n            return -1;\n        }\n    }\n\n    sr_list = &cs->request_list;\n\n    sr_node = mk_list_entry_first(sr_list, struct session_request, _head);\n\n    if (sr_node->bytes_to_send > 0) {\n        /* Request with data to send by static file sender */\n        final_status = mk_http_send_file(cs, sr_node);\n    }\n    else if (sr_node->bytes_to_send < 0) {\n        final_status = mk_request_process(cs, sr_node);\n    }\n\n    /*\n     * If we got an error, we don't want to parse\n     * and send information for another pipelined request\n     */\n    if (final_status > 0) {\n        return final_status;\n    }\n    else {\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, socket,\n                            NULL, cs, sr_node);\n        switch (final_status) {\n        case EXIT_NORMAL:\n        case EXIT_ERROR:\n            if (sr_node->close_now == MK_TRUE) {\n                return -1;\n            }\n            break;\n        case EXIT_ABORT:\n            return -1;\n        }\n    }\n\n    /*\n     * If we are here, is because all pipelined request were\n     * processed successfully, let's return 0\n     */\n    return 0;\n}\n\n/* Look for some  index.xxx in pathfile */\nmk_ptr_t mk_request_index(char *pathfile, char *file_aux, const unsigned int flen)\n{\n    unsigned long len;\n    mk_ptr_t f;\n    struct mk_string_line *entry;\n    struct mk_list *head;\n\n    mk_ptr_reset(&f);\n    if (!config->index_files) return f;\n\n    mk_list_foreach(head, config->index_files) {\n        entry = mk_list_entry(head, struct mk_string_line, _head);\n        len = snprintf(file_aux, flen, \"%s%s\", pathfile, entry->val);\n        if (mk_unlikely(len > flen)) {\n            len = flen - 1;\n            mk_warn(\"Path too long, truncated! '%s'\", file_aux);\n        }\n\n        if (access(file_aux, F_OK) == 0) {\n            f.data = file_aux;\n            f.len = len;\n            return f;\n        }\n    }\n\n    return f;\n}\n\n/* Send error responses */\nint mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr) {\n    int ret, fd;\n    mk_ptr_t message, *page = 0;\n    struct error_page *entry;\n    struct mk_list *head;\n    struct file_info finfo;\n\n    mk_header_set_http_status(sr, http_status);\n\n    /*\n     * We are nice sending error pages for clients who at least respect\n     * the especification\n     */\n    if (http_status != MK_CLIENT_LENGTH_REQUIRED &&\n        http_status != MK_CLIENT_BAD_REQUEST &&\n        http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {\n\n        /* Lookup a customized error page */\n        mk_list_foreach(head, &sr->host_conf->error_pages) {\n            entry = mk_list_entry(head, struct error_page, _head);\n            if (entry->status != http_status) {\n                continue;\n            }\n\n            /* validate error file */\n            ret = mk_file_get_info(entry->real_path, &finfo);\n            if (ret == -1) {\n                break;\n            }\n\n            /* open file */\n            fd = open(entry->real_path, config->open_flags);\n            if (fd == -1) {\n                break;\n            }\n\n            sr->fd_file   = fd;\n            sr->fd_is_fdt = MK_FALSE;\n            sr->bytes_to_send = finfo.size;\n            sr->headers.content_length = finfo.size;\n            sr->headers.real_length    = finfo.size;\n\n            memcpy(&sr->file_info, &finfo, sizeof(struct file_info));\n\n            mk_header_send(cs->socket, cs, sr);\n            return mk_http_send_file(cs, sr);\n        }\n    }\n\n    mk_ptr_reset(&message);\n\n    switch (http_status) {\n    case MK_CLIENT_BAD_REQUEST:\n        page = mk_request_set_default_page(\"Bad Request\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_FORBIDDEN:\n        page = mk_request_set_default_page(\"Forbidden\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_NOT_FOUND:\n        mk_string_build(&message.data, &message.len,\n                        \"The requested URL was not found on this server.\");\n        page = mk_request_set_default_page(\"Not Found\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:\n        mk_string_build(&message.data, &message.len,\n                        \"The request entity is too large.\");\n        page = mk_request_set_default_page(\"Entity too large\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_METHOD_NOT_ALLOWED:\n        page = mk_request_set_default_page(\"Method Not Allowed\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_REQUEST_TIMEOUT:\n    case MK_CLIENT_LENGTH_REQUIRED:\n        break;\n\n    case MK_SERVER_NOT_IMPLEMENTED:\n        page = mk_request_set_default_page(\"Method Not Implemented\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_INTERNAL_ERROR:\n        page = mk_request_set_default_page(\"Internal Server Error\",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_HTTP_VERSION_UNSUP:\n        mk_ptr_reset(&message);\n        page = mk_request_set_default_page(\"HTTP Version Not Supported\",\n                                           message,\n                                           sr->host_conf->host_signature);\n        break;\n    }\n\n    if (page) {\n        sr->headers.content_length = page->len;\n    }\n\n    sr->headers.location = NULL;\n    sr->headers.cgi = SH_NOCGI;\n    sr->headers.pconnections_left = 0;\n    sr->headers.last_modified = -1;\n\n    if (!page) {\n        mk_ptr_reset(&sr->headers.content_type);\n    }\n    else {\n        mk_ptr_set(&sr->headers.content_type, \"text/html\\r\\n\");\n    }\n\n    mk_header_send(cs->socket, cs, sr);\n\n    if (page) {\n        if (sr->method != MK_HTTP_METHOD_HEAD)\n            mk_socket_send(cs->socket, page->data, page->len);\n\n        mk_ptr_free(page);\n        mk_mem_free(page);\n    }\n\n    /* Turn off TCP_CORK */\n    mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n    return EXIT_ERROR;\n}\n\nvoid mk_request_free_list(struct client_session *cs)\n{\n    struct session_request *sr_node;\n    struct mk_list *sr_head, *temp;\n\n    /* sr = last node */\n    MK_TRACE(\"[FD %i] Free struct client_session\", cs->socket);\n\n    mk_list_foreach_safe(sr_head, temp, &cs->request_list) {\n        sr_node = mk_list_entry(sr_head, struct session_request, _head);\n        mk_list_del(sr_head);\n\n        mk_request_free(sr_node);\n        if (sr_node != &cs->sr_fixed) {\n            mk_mem_free(sr_node);\n        }\n    }\n}\n\n/* Create a client request struct and put it on the\n * main list\n */\nstruct client_session *mk_session_create(int socket, struct sched_list_node *sched)\n{\n    struct client_session *cs;\n    struct sched_connection *sc;\n\n    sc = mk_sched_get_connection(sched, socket);\n    if (!sc) {\n        MK_TRACE(\"[FD %i] No sched node, could not create session\", socket);\n        return NULL;\n    }\n\n    /* Alloc memory for node */\n    cs = mk_mem_malloc(sizeof(struct client_session));\n\n    cs->pipelined = MK_FALSE;\n    cs->counter_connections = 0;\n    cs->socket = socket;\n    cs->status = MK_REQUEST_STATUS_INCOMPLETE;\n    mk_list_add(&cs->request_incomplete, cs_incomplete);\n\n    /* creation time in unix time */\n    cs->init_time = sc->arrive_time;\n\n    /* alloc space for body content */\n    if (config->transport_buffer_size > MK_REQUEST_CHUNK) {\n        cs->body = mk_mem_malloc(config->transport_buffer_size);\n        cs->body_size = config->transport_buffer_size;\n    }\n    else {\n        /* Buffer size based in Chunk bytes */\n        cs->body = cs->body_fixed;\n        cs->body_size = MK_REQUEST_CHUNK;\n    }\n\n    /* Current data length */\n    cs->body_length = 0;\n\n    cs->body_pos_end = -1;\n    cs->first_method = MK_HTTP_METHOD_UNKNOWN;\n\n    /* Init session request list */\n    mk_list_init(&cs->request_list);\n\n    /* Add this SESSION to the thread list */\n\n    /* Add node to list */\n    /* Red-Black tree insert routine */\n    struct rb_node **new = &(cs_list->rb_node);\n    struct rb_node *parent = NULL;\n\n    /* Figure out where to put new node */\n    while (*new) {\n        struct client_session *this = container_of(*new, struct client_session, _rb_head);\n\n        parent = *new;\n        if (cs->socket < this->socket)\n            new = &((*new)->rb_left);\n        else if (cs->socket > this->socket)\n            new = &((*new)->rb_right);\n        else {\n            break;\n        }\n    }\n    /* Add new node and rebalance tree. */\n    rb_link_node(&cs->_rb_head, parent, new);\n    rb_insert_color(&cs->_rb_head, cs_list);\n\n    return cs;\n}\n\nstruct client_session *mk_session_get(int socket)\n{\n    struct client_session *cs;\n    struct rb_node *node;\n\n    node = cs_list->rb_node;\n  \twhile (node) {\n  \t\tcs = container_of(node, struct client_session, _rb_head);\n\t\tif (socket < cs->socket)\n  \t\t\tnode = node->rb_left;\n\t\telse if (socket > cs->socket)\n  \t\t\tnode = node->rb_right;\n\t\telse {\n  \t\t\treturn cs;\n        }\n\t}\n\treturn NULL;\n}\n\n/*\n * From thread sched_list_node \"list\", remove the client_session\n * struct information\n */\nvoid mk_session_remove(int socket)\n{\n    struct client_session *cs_node;\n\n    cs_node = mk_session_get(socket);\n    if (cs_node) {\n        rb_erase(&cs_node->_rb_head, cs_list);\n        if (cs_node->body != cs_node->body_fixed) {\n            mk_mem_free(cs_node->body);\n        }\n        if (mk_list_entry_orphan(&cs_node->request_incomplete) == 0) {\n            mk_list_del(&cs_node->request_incomplete);\n        }\n        mk_list_del(&cs_node->request_list);\n        mk_mem_free(cs_node);\n    }\n}\n\n/* Return value of some variable sent in request */\nmk_ptr_t mk_request_header_get(struct headers_toc *toc, const char *key_name, int key_len)\n{\n    int i;\n    struct header_toc_row *row;\n    mk_ptr_t var;\n\n    var.data = NULL;\n    var.len = 0;\n\n    row = toc->rows;\n    for (i = 0; i < toc->length; i++) {\n\n        /*\n         * status = 1 means that the toc entry was already\n         * checked by Monkey\n         */\n        if (row[i].status == 1) {\n            continue;\n        }\n\n        if (strncasecmp(row[i].init, key_name, key_len) == 0) {\n            var.data = row[i].init + key_len + 1;\n            var.len = row[i].end - var.data;\n            row[i].status = 1;\n            break;\n        }\n    }\n\n    return var;\n}\n\nvoid mk_request_ka_next(struct client_session *cs)\n{\n    cs->first_method = -1;\n    cs->body_pos_end = -1;\n    cs->body_length = 0;\n    cs->counter_connections++;\n\n    /* Update data for scheduler */\n    cs->init_time = log_current_utime;\n    cs->status = MK_REQUEST_STATUS_INCOMPLETE;\n    mk_list_add(&cs->request_incomplete, cs_incomplete);\n}\n", "/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n\n#include <monkey/mk_list.h>\n#include <monkey/mk_vhost.h>\n#include <monkey/mk_utils.h>\n#include <monkey/mk_macros.h>\n#include <monkey/mk_config.h>\n#include <monkey/mk_string.h>\n#include <monkey/mk_http_status.h>\n#include <monkey/mk_memory.h>\n#include <monkey/mk_request.h>\n#include <monkey/mk_info.h>\n#include <monkey/mk_file.h>\n\n/* Initialize Virtual Host FDT mutex */\npthread_mutex_t mk_vhost_fdt_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic __thread struct mk_list *mk_vhost_fdt_key;\n\n/*\n * This function is triggered upon thread creation (inside the thread\n * context), here we configure per-thread data.\n */\nint mk_vhost_fdt_worker_init()\n{\n    int i;\n    int j;\n    struct host *h;\n    struct mk_list *list;\n    struct mk_list *head;\n    struct vhost_fdt_host *fdt;\n    struct vhost_fdt_hash_table *ht;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return -1;\n    }\n\n    /*\n     * We are under a thread context and the main configuration is\n     * already in place. Now for every existent virtual host we are\n     * going to create the File Descriptor Table (FDT) which aims to\n     * hold references of 'open and shared' file descriptors under\n     * the Virtual Host context.\n     */\n\n    /*\n     * Under an initialization context we need to protect this critical\n     * section\n     */\n    pthread_mutex_lock(&mk_vhost_fdt_mutex);\n\n    /*\n     * Initialize the thread FDT/Hosts list and create an entry per\n     * existent virtual host\n     */\n    list = mk_mem_malloc_z(sizeof(struct mk_list));\n    mk_list_init(list);\n\n    mk_list_foreach(head, &config->hosts) {\n        h = mk_list_entry(head, struct host, _head);\n\n        fdt = mk_mem_malloc(sizeof(struct vhost_fdt_host));\n        fdt->host = h;\n\n        /* Initialize hash table */\n        for (i = 0; i < VHOST_FDT_HASHTABLE_SIZE; i++) {\n            ht = &fdt->hash_table[i];\n            ht->av_slots = VHOST_FDT_HASHTABLE_CHAINS;\n\n            /* for each chain under the hash table, set the fd */\n            for (j = 0; j < VHOST_FDT_HASHTABLE_CHAINS; j++) {\n                hc = &ht->chain[j];\n                hc->fd      = -1;\n                hc->hash    =  0;\n                hc->readers =  0;\n            }\n        }\n        mk_list_add(&fdt->_head, list);\n    }\n\n    mk_vhost_fdt_key = list;\n    pthread_mutex_unlock(&mk_vhost_fdt_mutex);\n\n    return 0;\n}\n\nint mk_vhost_fdt_worker_exit()\n{\n    struct mk_list *head;\n    struct mk_list *tmp;\n    struct vhost_fdt_host *fdt;\n\n    if (config->fdt == MK_FALSE) {\n        return -1;\n    }\n\n    mk_list_foreach_safe(head, tmp, mk_vhost_fdt_key) {\n        fdt = mk_list_entry(head, struct vhost_fdt_host, _head);\n        mk_list_del(&fdt->_head);\n        mk_mem_free(fdt);\n    }\n\n    mk_mem_free(mk_vhost_fdt_key);\n    return 0;\n}\n\n\nstatic inline\nstruct vhost_fdt_hash_table *mk_vhost_fdt_table_lookup(int id, struct host *host)\n{\n    struct mk_list *head;\n    struct mk_list *vhost_list;\n    struct vhost_fdt_host *fdt_host;\n    struct vhost_fdt_hash_table *ht = NULL;\n\n    vhost_list = mk_vhost_fdt_key;\n    mk_list_foreach(head, vhost_list) {\n        fdt_host = mk_list_entry(head, struct vhost_fdt_host, _head);\n        if (fdt_host->host == host) {\n            ht = &fdt_host->hash_table[id];\n            return ht;\n        }\n    }\n\n    return ht;\n}\n\nstatic inline\nstruct vhost_fdt_hash_chain\n*mk_vhost_fdt_chain_lookup(unsigned int hash, struct vhost_fdt_hash_table *ht)\n{\n    int i;\n    struct vhost_fdt_hash_chain *hc = NULL;\n\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->hash == hash) {\n            return hc;\n        }\n    }\n\n    return NULL;\n}\n\n\nstatic inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and return the shared FD */\n        hc->readers++;\n        return hc->fd;\n    }\n\n    /*\n     * Get here means that no entry exists in the hash table for the\n     * requested file descriptor and hash, we must try to open the file\n     * and register the entry in the table.\n     */\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n\n    /* If chains are full, just return the new FD, bad luck... */\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n\n    /* Register the new entry in an available slot */\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n\n            return fd;\n        }\n    }\n\n    return -1;\n}\n\nstatic inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}\n\n\nint mk_vhost_open(struct session_request *sr)\n{\n    int id;\n    int off;\n    unsigned int hash;\n\n    off = sr->host_conf->documentroot.len;\n    hash = mk_utils_gen_hash(sr->real_path.data + off,\n                             sr->real_path.len - off);\n    id   = (hash % VHOST_FDT_HASHTABLE_SIZE);\n\n    return mk_vhost_fdt_open(id, hash, sr);\n}\n\nint mk_vhost_close(struct session_request *sr)\n{\n    return mk_vhost_fdt_close(sr);\n}\n\n/*\n * Open a virtual host configuration file and return a structure with\n * definitions.\n */\nstruct host *mk_vhost_read(char *path)\n{\n    unsigned long len = 0;\n    char *tmp;\n    char *host_low;\n    struct stat checkdir;\n    struct host *host;\n    struct host_alias *new_alias;\n    struct error_page *err_page;\n    struct mk_config *cnf;\n    struct mk_config_section *section_host;\n    struct mk_config_section *section_ep;\n    struct mk_config_entry *entry_ep;\n    struct mk_string_line *entry;\n    struct mk_list *head, *list;\n\n    /* Read configuration file */\n    cnf = mk_config_create(path);\n    if (!cnf) {\n        mk_err(\"Configuration error, aborting.\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Read tag 'HOST' */\n    section_host = mk_config_section_get(cnf, \"HOST\");\n    if (!section_host) {\n        mk_err(\"Invalid config file %s\", path);\n        return NULL;\n    }\n\n    /* Alloc configuration node */\n    host = mk_mem_malloc_z(sizeof(struct host));\n    host->config = cnf;\n    host->file = mk_string_dup(path);\n\n    /* Init list for custom error pages */\n    mk_list_init(&host->error_pages);\n\n    /* Init list for host name aliases */\n    mk_list_init(&host->server_names);\n\n    /* Lookup Servername */\n    list = mk_config_section_getval(section_host, \"Servername\", MK_CONFIG_VAL_LIST);\n    if (!list) {\n        mk_err(\"Hostname does not contain a Servername\");\n        exit(EXIT_FAILURE);\n    }\n\n    mk_list_foreach(head, list) {\n        entry = mk_list_entry(head, struct mk_string_line, _head);\n        if (entry->len > MK_HOSTNAME_LEN - 1) {\n            continue;\n        }\n\n        /* Hostname to lowercase */\n        host_low = mk_string_tolower(entry->val);\n\n        /* Alloc node */\n        new_alias = mk_mem_malloc_z(sizeof(struct host_alias));\n        new_alias->name = mk_mem_malloc_z(entry->len + 1);\n        strncpy(new_alias->name, host_low, entry->len);\n        mk_mem_free(host_low);\n\n        new_alias->len = entry->len;\n\n        mk_list_add(&new_alias->_head, &host->server_names);\n    }\n    mk_string_split_free(list);\n\n    /* Lookup document root handled by a mk_ptr_t */\n    host->documentroot.data = mk_config_section_getval(section_host,\n                                                       \"DocumentRoot\",\n                                                       MK_CONFIG_VAL_STR);\n    if (!host->documentroot.data) {\n        mk_err(\"Missing DocumentRoot entry on %s file\", path);\n        mk_config_free(cnf);\n        return NULL;\n    }\n\n    host->documentroot.len = strlen(host->documentroot.data);\n\n    /* Validate document root configured */\n    if (stat(host->documentroot.data, &checkdir) == -1) {\n        mk_err(\"Invalid path to DocumentRoot in %s\", path);\n    }\n    else if (!(checkdir.st_mode & S_IFDIR)) {\n        mk_err(\"DocumentRoot variable in %s has an invalid directory path\", path);\n    }\n\n    if (mk_list_is_empty(&host->server_names) == 0) {\n        mk_config_free(cnf);\n        return NULL;\n    }\n\n    /* Check Virtual Host redirection */\n    host->header_redirect.data = NULL;\n    host->header_redirect.len  = 0;\n\n    tmp = mk_config_section_getval(section_host,\n                                   \"Redirect\",\n                                   MK_CONFIG_VAL_STR);\n    if (tmp) {\n        host->header_redirect.data = mk_string_dup(tmp);\n        host->header_redirect.len  = strlen(tmp);\n        mk_mem_free(tmp);\n    }\n\n    /* Error Pages */\n    section_ep = mk_config_section_get(cnf, \"ERROR_PAGES\");\n    if (section_ep) {\n        mk_list_foreach(head, &section_ep->entries) {\n            entry_ep = mk_list_entry(head, struct mk_config_entry, _head);\n\n            int ep_status = -1;\n            char *ep_file = NULL;\n            unsigned long len;\n\n            ep_status = atoi(entry_ep->key);\n            ep_file   = entry_ep->val;\n\n            /* Validate input values */\n            if (ep_status < MK_CLIENT_BAD_REQUEST ||\n                ep_status > MK_SERVER_HTTP_VERSION_UNSUP ||\n                ep_file == NULL) {\n                continue;\n            }\n\n            /* Alloc error page node */\n            err_page = mk_mem_malloc_z(sizeof(struct error_page));\n            err_page->status = ep_status;\n            err_page->file   = mk_string_dup(ep_file);\n            err_page->real_path = NULL;\n            mk_string_build(&err_page->real_path, &len, \"%s/%s\",\n                            host->documentroot.data, err_page->file);\n\n            MK_TRACE(\"Map error page: status %i -> %s\", err_page->status, err_page->file);\n\n            /* Link page to the error page list */\n            mk_list_add(&err_page->_head, &host->error_pages);\n        }\n    }\n\n    /* Server Signature */\n    if (config->hideversion == MK_FALSE) {\n        mk_string_build(&host->host_signature, &len,\n                        \"Monkey/%s\", VERSION);\n    }\n    else {\n        mk_string_build(&host->host_signature, &len, \"Monkey\");\n    }\n    mk_string_build(&host->header_host_signature.data,\n                    &host->header_host_signature.len,\n                    \"Server: %s\", host->host_signature);\n\n    return host;\n}\n\nvoid mk_vhost_set_single(char *path)\n{\n    struct host *host;\n    struct host_alias *halias;\n    struct stat checkdir;\n    unsigned long len = 0;\n\n    /* Set the default host */\n    host = mk_mem_malloc_z(sizeof(struct host));\n    mk_list_init(&host->error_pages);\n    mk_list_init(&host->server_names);\n\n    /* Prepare the unique alias */\n    halias = mk_mem_malloc_z(sizeof(struct host_alias));\n    halias->name = mk_string_dup(\"127.0.0.1\");\n    mk_list_add(&halias->_head, &host->server_names);\n\n    host->documentroot.data = mk_string_dup(path);\n    host->documentroot.len = strlen(path);\n    host->header_redirect.data = NULL;\n\n    /* Validate document root configured */\n    if (stat(host->documentroot.data, &checkdir) == -1) {\n        mk_err(\"Invalid path to DocumentRoot in %s\", path);\n        exit(EXIT_FAILURE);\n    }\n    else if (!(checkdir.st_mode & S_IFDIR)) {\n        mk_err(\"DocumentRoot variable in %s has an invalid directory path\", path);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Server Signature */\n    if (config->hideversion == MK_FALSE) {\n        mk_string_build(&host->host_signature, &len,\n                        \"Monkey/%s\", VERSION);\n    }\n    else {\n        mk_string_build(&host->host_signature, &len, \"Monkey\");\n    }\n\n    mk_string_build(&host->header_host_signature.data,\n                    &host->header_host_signature.len,\n                    \"Server: %s\", host->host_signature);\n\n    mk_list_add(&host->_head, &config->hosts);\n}\n\n/* Given a configuration directory, start reading the virtual host entries */\nvoid mk_vhost_init(char *path)\n{\n    DIR *dir;\n    unsigned long len;\n    char *buf = 0;\n    char *sites = 0;\n    char *file;\n    struct host *p_host;     /* debug */\n    struct dirent *ent;\n    struct file_info f_info;\n    int ret;\n\n    /* Read default virtual host file */\n    mk_string_build(&sites, &len, \"%s/%s/\", path, config->sites_conf_dir);\n    ret = mk_file_get_info(sites, &f_info);\n    if (ret == -1 || f_info.is_directory == MK_FALSE) {\n        mk_mem_free(sites);\n        sites = config->sites_conf_dir;\n    }\n\n    mk_string_build(&buf, &len, \"%s/default\", sites);\n\n    p_host = mk_vhost_read(buf);\n    if (!p_host) {\n        mk_err(\"Error parsing main configuration file 'default'\");\n    }\n    mk_list_add(&p_host->_head, &config->hosts);\n    config->nhosts++;\n    mk_mem_free(buf);\n    buf = NULL;\n\n\n    /* Read all virtual hosts defined in sites/ */\n    if (!(dir = opendir(sites))) {\n        mk_mem_free(sites);\n        mk_err(\"Could not open %s\", sites);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Reading content */\n    while ((ent = readdir(dir)) != NULL) {\n        if (ent->d_name[0] == '.') {\n            continue;\n        }\n        if (strcmp((char *) ent->d_name, \"..\") == 0) {\n            continue;\n        }\n        if (ent->d_name[strlen(ent->d_name) - 1] ==  '~') {\n            continue;\n        }\n        if (strcasecmp((char *) ent->d_name, \"default\") == 0) {\n            continue;\n        }\n        file = NULL;\n        mk_string_build(&file, &len, \"%s/%s\", sites, ent->d_name);\n\n        p_host = mk_vhost_read(file);\n        mk_mem_free(file);\n        if (!p_host) {\n            continue;\n        }\n        else {\n            mk_list_add(&p_host->_head, &config->hosts);\n            config->nhosts++;\n        }\n    }\n    closedir(dir);\n    mk_mem_free(sites);\n}\n\n\n/* Lookup a registered virtual host based on the given 'host' input */\nint mk_vhost_get(mk_ptr_t host, struct host **vhost, struct host_alias **alias)\n{\n    struct host *entry_host;\n    struct host_alias *entry_alias;\n    struct mk_list *head_vhost, *head_alias;\n\n    mk_list_foreach(head_vhost, &config->hosts) {\n        entry_host = mk_list_entry(head_vhost, struct host, _head);\n        mk_list_foreach(head_alias, &entry_host->server_names) {\n            entry_alias = mk_list_entry(head_alias, struct host_alias, _head);\n            if (entry_alias->len == host.len &&\n                strncmp(entry_alias->name, host.data, host.len) == 0) {\n                *vhost = entry_host;\n                *alias = entry_alias;\n                return 0;\n            }\n        }\n    }\n\n    return -1;\n}\n\nvoid mk_vhost_free_all()\n{\n    struct host *host;\n    struct host_alias *host_alias;\n    struct error_page *ep;\n    struct mk_list *head_host;\n    struct mk_list *head_alias;\n    struct mk_list *head_error;\n    struct mk_list *tmp1, *tmp2;\n\n    mk_list_foreach_safe(head_host, tmp1, &config->hosts) {\n        host = mk_list_entry(head_host, struct host, _head);\n        mk_list_del(&host->_head);\n\n        mk_mem_free(host->file);\n\n        /* Free aliases or servernames */\n        mk_list_foreach_safe(head_alias, tmp2, &host->server_names) {\n            host_alias = mk_list_entry(head_alias, struct host_alias, _head);\n            mk_list_del(&host_alias->_head);\n            mk_mem_free(host_alias->name);\n            mk_mem_free(host_alias);\n        }\n\n        /* Free error pages */\n        mk_list_foreach_safe(head_error, tmp2, &host->error_pages) {\n            ep = mk_list_entry(head_error, struct error_page, _head);\n            mk_list_del(&ep->_head);\n            mk_mem_free(ep->file);\n            mk_mem_free(ep->real_path);\n            mk_mem_free(ep);\n        }\n\n        mk_ptr_free(&host->documentroot);\n        mk_mem_free(host->host_signature);\n        mk_ptr_free(&host->header_host_signature);\n\n        /* Free source configuration */\n        if (host->config) mk_config_free(host->config);\n        mk_mem_free(host);\n    }\n}\n"], "filenames": ["include/monkey/mk_request.h", "src/mk_request.c", "src/mk_vhost.c"], "buggy_code_start_loc": [162, 102, 222], "buggy_code_end_loc": [163, 845, 266], "fixing_code_start_loc": [162, 102, 223], "fixing_code_end_loc": [174, 851, 265], "type": "CWE-20", "message": "Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message.", "other": {"cve": {"id": "CVE-2014-5336", "sourceIdentifier": "cve@mitre.org", "published": "2014-08-26T14:55:06.470", "lastModified": "2020-03-26T14:25:06.063", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message."}, {"lang": "es", "value": "Monkey HTTP Server anterior a 1.5.3, cuando File Descriptor Table (FDT) est\u00e1 habilitado y los mensajes de error personalizados est\u00e1n configurados, permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo del descriptor de ficheros) a trav\u00e9s de una solicitud HTTP que provoca un mensaje de error."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.2", "matchCriteriaId": "0CB08117-B499-432C-9A4A-A082DAE4DDD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "84373192-14CC-44E3-BEC5-60D10C15E286"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "499BCE12-50FC-44B9-9B84-65A74360E578"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "61108B01-9BE4-47EC-81E3-CD3A4FE3F6E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "0D9B045F-4566-4703-A92B-3370E21B74C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "9BF12CBB-9196-4E04-800A-1C00F23D122E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "52C164D0-C8E8-42A4-A32F-703DCFBE143C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "10D5B8BF-43EB-4D50-9791-B22B77651787"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C877910B-52A8-4B0F-9306-B7BED762B97F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "5CE29F0D-7E7C-4A02-98AC-673E2E96ED6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "F87631C2-ED8C-446E-B3C6-72A2DF672397"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "98FE8E88-383E-403C-9FE0-B303FD8DA937"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "E27D9B36-43BD-4573-9E1C-3D65D458BD88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "CAE9AD22-98BA-4780-904A-765A1E331B38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "88F19324-8BBE-4244-9AD2-99A8E537F867"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "D761DCC9-C21C-46A5-8CFF-66AE0AA9E858"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "9C51E11E-E608-4648-A137-934D60441463"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "CA4AE960-E143-4B73-BDB9-22C070A29E02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.4:2:*:*:*:*:*:*", "matchCriteriaId": "E5283F7B-5BC6-4213-B5D3-93B963024FD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "7A53C73D-4BBB-47C7-AF5B-D81FDA93C83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "FDAF1977-C2AD-4CD4-B13E-A73EA677AE8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "EB24DE82-F0C1-493B-9DD1-90008997F83E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "DD20E0E8-3BCE-48BA-9BD0-28B44DAF58CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "89D1A368-548D-4F6E-BD32-5192A7B43BA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB521134-0F93-464E-AF60-AA7BE9C63AD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "EAB9AD97-1496-4541-AF70-28C602F0E6B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "888A0493-A048-4957-9ACD-55C26972B52C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CB4E1FF0-AD93-4819-A2ED-C69368D28B19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "D3EDB7E6-9E81-4A42-B530-27D8C5EFDF7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "4A975846-735E-4614-8205-10F336BF2099"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "F10BF9C8-A9C3-40BE-B6E3-C0AB6B363148"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "AA6ED8E8-8733-4CA1-B4E9-7C167BFEC37D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "6BC58CA3-E411-41F5-AD4C-AD3466DDD124"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "D998323A-7313-4B5E-97EB-14236C5D6A1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "7C1CFF78-78D6-47E1-8DA2-3E71C98BEB03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.13.2:*:*:*:*:*:*:*", "matchCriteriaId": "14D13507-3C6D-4C5D-935C-2478DCA31390"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.20.0:*:*:*:*:*:*:*", "matchCriteriaId": "62FF67C0-4BDA-4D11-8061-5195DEB0BFB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "5829DC2C-E5AD-45D9-982A-0273E8EF5A4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "CD733909-383E-46DC-A817-751448E0F081"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.20.3:*:*:*:*:*:*:*", "matchCriteriaId": "E3D07562-E990-429A-BEEE-4CEBB2DDF0F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.21.0:*:*:*:*:*:*:*", "matchCriteriaId": "43BFA520-A51F-430B-8762-98D186826C50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.30.0:*:*:*:*:*:*:*", "matchCriteriaId": "BE528193-12D9-44A5-9778-58F3444280E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.31.0:*:*:*:*:*:*:*", "matchCriteriaId": "7460281A-A9AF-4448-ADAB-DAAA27449AC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.32.0:*:*:*:*:*:*:*", "matchCriteriaId": "941D5501-6AB5-4063-9501-30C6F7A2B3E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:0.33.0:*:*:*:*:*:*:*", "matchCriteriaId": "F753F787-9162-4E79-B743-7BA3E0658759"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "C199C75D-D093-47B6-A96D-18E46B7B7A4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "628C5F98-1CF7-49A7-B422-795A06B0439A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "7A445AB7-1691-4DDE-B40E-B50DC03FD9DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "83C1E803-06F4-4FE4-9D14-CF4D51F9ABBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1B0730F-DEC0-4014-B364-FAD12C1FB8E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "7A7EB3A3-3B43-41E1-A7B0-03A5C8034F96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "9CB4E5D3-C614-403D-9ACE-E8C96B8671AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "79F08A40-0CF7-4854-AF08-AEF3FE393F6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "05306A82-1FDF-4FD8-95FC-E178F42E50F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "24C8FF70-447C-4548-84CE-117206B7BA50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:1.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "A06F9E1F-9547-485C-8BD4-02189E9B0C84"}]}]}], "references": [{"url": "http://monkey-project.com/Announcements/v1.5.3", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q3/397", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q3/412", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/69279", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/95336", "source": "cve@mitre.org"}, {"url": "https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd"}}