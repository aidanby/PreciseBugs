{"buggy_code": ["/*\n * This file is part of NetSurf's LibNSGIF, http://www.netsurf-browser.org/\n * Licensed under the MIT License,\n *                http://www.opensource.org/licenses/mit-license.php\n *\n * Copyright 2017 Michael Drake <michael.drake@codethink.co.uk>\n */\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"lzw.h\"\n\n/**\n * \\file\n * \\brief LZW decompression (implementation)\n *\n * Decoder for GIF LZW data.\n */\n\n\n/**\n * Context for reading LZW data.\n *\n * LZW data is split over multiple sub-blocks.  Each sub-block has a\n * byte at the start, which says the sub-block size, and then the data.\n * Zero-size sub-blocks have no data, and the biggest sub-block size is\n * 255, which means there are 255 bytes of data following the sub-block\n * size entry.\n *\n * Note that an individual LZW code can be split over up to three sub-blocks.\n */\nstruct lzw_read_ctx {\n\tconst uint8_t *data;    /**< Pointer to start of input data */\n\tuint64_t data_len;      /**< Input data length */\n\tuint64_t data_sb_next;  /**< Offset to sub-block size */\n\n\tconst uint8_t *sb_data; /**< Pointer to current sub-block in data */\n\tuint64_t sb_bit;        /**< Current bit offset in sub-block */\n\tuint64_t sb_bit_count;  /**< Bit count in sub-block */\n};\n\n/**\n * LZW dictionary entry.\n *\n * Records in the dictionary are composed of 1 or more entries.\n * Entries point to previous entries which can be followed to compose\n * the complete record.  To compose the record in reverse order, take\n * the `last_value` from each entry, and move to the previous entry.\n * If the previous_entry's index is < the current clear_code, then it\n * is the last entry in the record.\n */\nstruct lzw_dictionary_entry {\n\tuint8_t last_value;      /**< Last value for record ending at entry. */\n\tuint8_t first_value;     /**< First value for entry's record. */\n\tuint16_t previous_entry; /**< Offset in dictionary to previous entry. */\n};\n\n/**\n * LZW decompression context.\n */\nstruct lzw_ctx {\n\t/** Input reading context */\n\tstruct lzw_read_ctx input;\n\n\tuint32_t previous_code;       /**< Code read from input previously. */\n\tuint32_t previous_code_first; /**< First value of previous code. */\n\n\tuint32_t initial_code_size;     /**< Starting LZW code size. */\n\tuint32_t current_code_size;     /**< Current LZW code size. */\n\tuint32_t current_code_size_max; /**< Max code value for current size. */\n\n\tuint32_t clear_code; /**< Special Clear code value */\n\tuint32_t eoi_code;   /**< Special End of Information code value */\n\n\tuint32_t current_entry; /**< Next position in table to fill. */\n\n\t/** Output value stack. */\n\tuint8_t stack_base[1 << LZW_CODE_MAX];\n\n\t/** LZW decode dictionary. Generated during decode. */\n\tstruct lzw_dictionary_entry table[1 << LZW_CODE_MAX];\n};\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_context_create(struct lzw_ctx **ctx)\n{\n\tstruct lzw_ctx *c = malloc(sizeof(*c));\n\tif (c == NULL) {\n\t\treturn LZW_NO_MEM;\n\t}\n\n\t*ctx = c;\n\treturn LZW_OK;\n}\n\n\n/* Exported function, documented in lzw.h */\nvoid lzw_context_destroy(struct lzw_ctx *ctx)\n{\n\tfree(ctx);\n}\n\n\n/**\n * Advance the context to the next sub-block in the input data.\n *\n * \\param[in] ctx  LZW reading context, updated on success.\n * \\return LZW_OK or LZW_OK_EOD on success, appropriate error otherwise.\n */\nstatic lzw_result lzw__block_advance(struct lzw_read_ctx *ctx)\n{\n\tuint64_t block_size;\n\tuint64_t next_block_pos = ctx->data_sb_next;\n\tconst uint8_t *data_next = ctx->data + next_block_pos;\n\n\tif (next_block_pos >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tblock_size = *data_next;\n\n\tif ((next_block_pos + block_size) >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tctx->sb_bit = 0;\n\tctx->sb_bit_count = block_size * 8;\n\n\tif (block_size == 0) {\n\t\tctx->data_sb_next += 1;\n\t\treturn LZW_OK_EOD;\n\t}\n\n\tctx->sb_data = data_next + 1;\n\tctx->data_sb_next += block_size + 1;\n\n\treturn LZW_OK;\n}\n\n\n/**\n * Get the next LZW code of given size from the raw input data.\n *\n * Reads codes from the input data stream coping with GIF data sub-blocks.\n *\n * \\param[in]  ctx        LZW reading context, updated.\n * \\param[in]  code_size  Size of LZW code to get from data.\n * \\param[out] code_out   Returns an LZW code on success.\n * \\return LZW_OK or LZW_OK_EOD on success, appropriate error otherwise.\n */\nstatic inline lzw_result lzw__next_code(\n\t\tstruct lzw_read_ctx *ctx,\n\t\tuint8_t code_size,\n\t\tuint32_t *code_out)\n{\n\tuint32_t code = 0;\n\tuint8_t current_bit = ctx->sb_bit & 0x7;\n\tuint8_t byte_advance = (current_bit + code_size) >> 3;\n\n\tassert(byte_advance <= 2);\n\n\tif (ctx->sb_bit + code_size <= ctx->sb_bit_count) {\n\t\t/* Fast path: code fully inside this sub-block */\n\t\tconst uint8_t *data = ctx->sb_data + (ctx->sb_bit >> 3);\n\t\tswitch (byte_advance) {\n\t\t\tcase 2: code |= data[2] << 16; /* Fall through */\n\t\t\tcase 1: code |= data[1] <<  8; /* Fall through */\n\t\t\tcase 0: code |= data[0] <<  0;\n\t\t}\n\t\tctx->sb_bit += code_size;\n\t} else {\n\t\t/* Slow path: code spans sub-blocks */\n\t\tuint8_t byte = 0;\n\t\tuint8_t bits_remaining_0 = (code_size < (8 - current_bit)) ?\n\t\t\t\tcode_size : (8 - current_bit);\n\t\tuint8_t bits_remaining_1 = code_size - bits_remaining_0;\n\t\tuint8_t bits_used[3] = {\n\t\t\t[0] = bits_remaining_0,\n\t\t\t[1] = bits_remaining_1 < 8 ? bits_remaining_1 : 8,\n\t\t\t[2] = bits_remaining_1 - 8,\n\t\t};\n\n\t\twhile (true) {\n\t\t\tconst uint8_t *data = ctx->sb_data;\n\t\t\tlzw_result res;\n\n\t\t\t/* Get any data from end of this sub-block */\n\t\t\twhile (byte <= byte_advance &&\n\t\t\t\t\tctx->sb_bit < ctx->sb_bit_count) {\n\t\t\t\tcode |= data[ctx->sb_bit >> 3] << (byte << 3);\n\t\t\t\tctx->sb_bit += bits_used[byte];\n\t\t\t\tbyte++;\n\t\t\t}\n\n\t\t\t/* Check if we have all we need */\n\t\t\tif (byte > byte_advance) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Move to next sub-block */\n\t\t\tres = lzw__block_advance(ctx);\n\t\t\tif (res != LZW_OK) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\n\t*code_out = (code >> current_bit) & ((1 << code_size) - 1);\n\treturn LZW_OK;\n}\n\n\n/**\n * Clear LZW code dictionary.\n *\n * \\param[in]  ctx            LZW reading context, updated.\n * \\param[out] stack_pos_out  Returns current stack position.\n * \\return LZW_OK or error code.\n */\nstatic lzw_result lzw__clear_codes(\n\t\tstruct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tuint32_t code;\n\tuint8_t *stack_pos;\n\n\t/* Reset dictionary building context */\n\tctx->current_code_size = ctx->initial_code_size + 1;\n\tctx->current_code_size_max = (1 << ctx->current_code_size) - 1;;\n\tctx->current_entry = (1 << ctx->initial_code_size) + 2;\n\n\t/* There might be a sequence of clear codes, so process them all */\n\tdo {\n\t\tlzw_result res = lzw__next_code(&ctx->input,\n\t\t\t\tctx->current_code_size, &code);\n\t\tif (res != LZW_OK) {\n\t\t\treturn res;\n\t\t}\n\t} while (code == ctx->clear_code);\n\n\t/* The initial code must be from the initial dictionary. */\n\tif (code > ctx->clear_code) {\n\t\treturn LZW_BAD_ICODE;\n\t}\n\n\t/* Record this initial code as \"previous\" code, needed during decode. */\n\tctx->previous_code = code;\n\tctx->previous_code_first = code;\n\n\t/* Reset the stack, and add first non-clear code added as first item. */\n\tstack_pos = ctx->stack_base;\n\t*stack_pos++ = code;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_decode_init(\n\t\tstruct lzw_ctx *ctx,\n\t\tconst uint8_t *compressed_data,\n\t\tuint64_t compressed_data_len,\n\t\tuint64_t compressed_data_pos,\n\t\tuint8_t code_size,\n\t\tconst uint8_t ** const stack_base_out,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tstruct lzw_dictionary_entry *table = ctx->table;\n\n\t/* Initialise the input reading context */\n\tctx->input.data = compressed_data;\n\tctx->input.data_len = compressed_data_len;\n\tctx->input.data_sb_next = compressed_data_pos;\n\n\tctx->input.sb_bit = 0;\n\tctx->input.sb_bit_count = 0;\n\n\t/* Initialise the dictionary building context */\n\tctx->initial_code_size = code_size;\n\n\tctx->clear_code = (1 << code_size) + 0;\n\tctx->eoi_code   = (1 << code_size) + 1;\n\n\t/* Initialise the standard dictionary entries */\n\tfor (uint32_t i = 0; i < ctx->clear_code; ++i) {\n\t\ttable[i].first_value = i;\n\t\ttable[i].last_value  = i;\n\t}\n\n\t*stack_base_out = ctx->stack_base;\n\treturn lzw__clear_codes(ctx, stack_pos_out);\n}\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}\n"], "fixing_code": ["/*\n * This file is part of NetSurf's LibNSGIF, http://www.netsurf-browser.org/\n * Licensed under the MIT License,\n *                http://www.opensource.org/licenses/mit-license.php\n *\n * Copyright 2017 Michael Drake <michael.drake@codethink.co.uk>\n */\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"lzw.h\"\n\n/**\n * \\file\n * \\brief LZW decompression (implementation)\n *\n * Decoder for GIF LZW data.\n */\n\n\n/**\n * Context for reading LZW data.\n *\n * LZW data is split over multiple sub-blocks.  Each sub-block has a\n * byte at the start, which says the sub-block size, and then the data.\n * Zero-size sub-blocks have no data, and the biggest sub-block size is\n * 255, which means there are 255 bytes of data following the sub-block\n * size entry.\n *\n * Note that an individual LZW code can be split over up to three sub-blocks.\n */\nstruct lzw_read_ctx {\n\tconst uint8_t *data;    /**< Pointer to start of input data */\n\tuint64_t data_len;      /**< Input data length */\n\tuint64_t data_sb_next;  /**< Offset to sub-block size */\n\n\tconst uint8_t *sb_data; /**< Pointer to current sub-block in data */\n\tuint64_t sb_bit;        /**< Current bit offset in sub-block */\n\tuint64_t sb_bit_count;  /**< Bit count in sub-block */\n};\n\n/**\n * LZW dictionary entry.\n *\n * Records in the dictionary are composed of 1 or more entries.\n * Entries point to previous entries which can be followed to compose\n * the complete record.  To compose the record in reverse order, take\n * the `last_value` from each entry, and move to the previous entry.\n * If the previous_entry's index is < the current clear_code, then it\n * is the last entry in the record.\n */\nstruct lzw_dictionary_entry {\n\tuint8_t last_value;      /**< Last value for record ending at entry. */\n\tuint8_t first_value;     /**< First value for entry's record. */\n\tuint16_t previous_entry; /**< Offset in dictionary to previous entry. */\n};\n\n/**\n * LZW decompression context.\n */\nstruct lzw_ctx {\n\t/** Input reading context */\n\tstruct lzw_read_ctx input;\n\n\tuint32_t previous_code;       /**< Code read from input previously. */\n\tuint32_t previous_code_first; /**< First value of previous code. */\n\n\tuint32_t initial_code_size;     /**< Starting LZW code size. */\n\tuint32_t current_code_size;     /**< Current LZW code size. */\n\tuint32_t current_code_size_max; /**< Max code value for current size. */\n\n\tuint32_t clear_code; /**< Special Clear code value */\n\tuint32_t eoi_code;   /**< Special End of Information code value */\n\n\tuint32_t current_entry; /**< Next position in table to fill. */\n\n\t/** Output value stack. */\n\tuint8_t stack_base[1 << LZW_CODE_MAX];\n\n\t/** LZW decode dictionary. Generated during decode. */\n\tstruct lzw_dictionary_entry table[1 << LZW_CODE_MAX];\n};\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_context_create(struct lzw_ctx **ctx)\n{\n\tstruct lzw_ctx *c = malloc(sizeof(*c));\n\tif (c == NULL) {\n\t\treturn LZW_NO_MEM;\n\t}\n\n\t*ctx = c;\n\treturn LZW_OK;\n}\n\n\n/* Exported function, documented in lzw.h */\nvoid lzw_context_destroy(struct lzw_ctx *ctx)\n{\n\tfree(ctx);\n}\n\n\n/**\n * Advance the context to the next sub-block in the input data.\n *\n * \\param[in] ctx  LZW reading context, updated on success.\n * \\return LZW_OK or LZW_OK_EOD on success, appropriate error otherwise.\n */\nstatic lzw_result lzw__block_advance(struct lzw_read_ctx *ctx)\n{\n\tuint64_t block_size;\n\tuint64_t next_block_pos = ctx->data_sb_next;\n\tconst uint8_t *data_next = ctx->data + next_block_pos;\n\n\tif (next_block_pos >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tblock_size = *data_next;\n\n\tif ((next_block_pos + block_size) >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tctx->sb_bit = 0;\n\tctx->sb_bit_count = block_size * 8;\n\n\tif (block_size == 0) {\n\t\tctx->data_sb_next += 1;\n\t\treturn LZW_OK_EOD;\n\t}\n\n\tctx->sb_data = data_next + 1;\n\tctx->data_sb_next += block_size + 1;\n\n\treturn LZW_OK;\n}\n\n\n/**\n * Get the next LZW code of given size from the raw input data.\n *\n * Reads codes from the input data stream coping with GIF data sub-blocks.\n *\n * \\param[in]  ctx        LZW reading context, updated.\n * \\param[in]  code_size  Size of LZW code to get from data.\n * \\param[out] code_out   Returns an LZW code on success.\n * \\return LZW_OK or LZW_OK_EOD on success, appropriate error otherwise.\n */\nstatic inline lzw_result lzw__next_code(\n\t\tstruct lzw_read_ctx *ctx,\n\t\tuint8_t code_size,\n\t\tuint32_t *code_out)\n{\n\tuint32_t code = 0;\n\tuint8_t current_bit = ctx->sb_bit & 0x7;\n\tuint8_t byte_advance = (current_bit + code_size) >> 3;\n\n\tassert(byte_advance <= 2);\n\n\tif (ctx->sb_bit + code_size <= ctx->sb_bit_count) {\n\t\t/* Fast path: code fully inside this sub-block */\n\t\tconst uint8_t *data = ctx->sb_data + (ctx->sb_bit >> 3);\n\t\tswitch (byte_advance) {\n\t\t\tcase 2: code |= data[2] << 16; /* Fall through */\n\t\t\tcase 1: code |= data[1] <<  8; /* Fall through */\n\t\t\tcase 0: code |= data[0] <<  0;\n\t\t}\n\t\tctx->sb_bit += code_size;\n\t} else {\n\t\t/* Slow path: code spans sub-blocks */\n\t\tuint8_t byte = 0;\n\t\tuint8_t bits_remaining_0 = (code_size < (8 - current_bit)) ?\n\t\t\t\tcode_size : (8 - current_bit);\n\t\tuint8_t bits_remaining_1 = code_size - bits_remaining_0;\n\t\tuint8_t bits_used[3] = {\n\t\t\t[0] = bits_remaining_0,\n\t\t\t[1] = bits_remaining_1 < 8 ? bits_remaining_1 : 8,\n\t\t\t[2] = bits_remaining_1 - 8,\n\t\t};\n\n\t\twhile (true) {\n\t\t\tconst uint8_t *data = ctx->sb_data;\n\t\t\tlzw_result res;\n\n\t\t\t/* Get any data from end of this sub-block */\n\t\t\twhile (byte <= byte_advance &&\n\t\t\t\t\tctx->sb_bit < ctx->sb_bit_count) {\n\t\t\t\tcode |= data[ctx->sb_bit >> 3] << (byte << 3);\n\t\t\t\tctx->sb_bit += bits_used[byte];\n\t\t\t\tbyte++;\n\t\t\t}\n\n\t\t\t/* Check if we have all we need */\n\t\t\tif (byte > byte_advance) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Move to next sub-block */\n\t\t\tres = lzw__block_advance(ctx);\n\t\t\tif (res != LZW_OK) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\n\t*code_out = (code >> current_bit) & ((1 << code_size) - 1);\n\treturn LZW_OK;\n}\n\n\n/**\n * Clear LZW code dictionary.\n *\n * \\param[in]  ctx            LZW reading context, updated.\n * \\param[out] stack_pos_out  Returns current stack position.\n * \\return LZW_OK or error code.\n */\nstatic lzw_result lzw__clear_codes(\n\t\tstruct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tuint32_t code;\n\tuint8_t *stack_pos;\n\n\t/* Reset dictionary building context */\n\tctx->current_code_size = ctx->initial_code_size + 1;\n\tctx->current_code_size_max = (1 << ctx->current_code_size) - 1;;\n\tctx->current_entry = (1 << ctx->initial_code_size) + 2;\n\n\t/* There might be a sequence of clear codes, so process them all */\n\tdo {\n\t\tlzw_result res = lzw__next_code(&ctx->input,\n\t\t\t\tctx->current_code_size, &code);\n\t\tif (res != LZW_OK) {\n\t\t\treturn res;\n\t\t}\n\t} while (code == ctx->clear_code);\n\n\t/* The initial code must be from the initial dictionary. */\n\tif (code > ctx->clear_code) {\n\t\treturn LZW_BAD_ICODE;\n\t}\n\n\t/* Record this initial code as \"previous\" code, needed during decode. */\n\tctx->previous_code = code;\n\tctx->previous_code_first = code;\n\n\t/* Reset the stack, and add first non-clear code added as first item. */\n\tstack_pos = ctx->stack_base;\n\t*stack_pos++ = code;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_decode_init(\n\t\tstruct lzw_ctx *ctx,\n\t\tconst uint8_t *compressed_data,\n\t\tuint64_t compressed_data_len,\n\t\tuint64_t compressed_data_pos,\n\t\tuint8_t code_size,\n\t\tconst uint8_t ** const stack_base_out,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tstruct lzw_dictionary_entry *table = ctx->table;\n\n\t/* Initialise the input reading context */\n\tctx->input.data = compressed_data;\n\tctx->input.data_len = compressed_data_len;\n\tctx->input.data_sb_next = compressed_data_pos;\n\n\tctx->input.sb_bit = 0;\n\tctx->input.sb_bit_count = 0;\n\n\t/* Initialise the dictionary building context */\n\tctx->initial_code_size = code_size;\n\n\tctx->clear_code = (1 << code_size) + 0;\n\tctx->eoi_code   = (1 << code_size) + 1;\n\n\t/* Initialise the standard dictionary entries */\n\tfor (uint32_t i = 0; i < ctx->clear_code; ++i) {\n\t\ttable[i].first_value = i;\n\t\ttable[i].last_value  = i;\n\t}\n\n\t*stack_base_out = ctx->stack_base;\n\treturn lzw__clear_codes(ctx, stack_pos_out);\n}\n\n\n/* Exported function, documented in lzw.h */\nlzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\t/* Don't access out of bound */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}\n"], "filenames": ["libnsgif/lzw.c"], "buggy_code_start_loc": [331], "buggy_code_end_loc": [331], "fixing_code_start_loc": [332], "fixing_code_end_loc": [336], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to 1.12.0.", "other": {"cve": {"id": "CVE-2022-2061", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-13T12:15:08.033", "lastModified": "2022-06-22T12:35:05.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to 1.12.0."}, {"lang": "es", "value": "Un Desbordamiento del b\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio de GitHub hpjansson/chafa versiones anteriores a 1.12.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chafa_project:chafa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.0", "matchCriteriaId": "1E5EB9CD-4B82-4055-AD3D-885D3AAEE21B"}]}]}], "references": [{"url": "https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/365ab61f-9a63-421c-97e6-21d4653021f0", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8"}}