{"buggy_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2\n# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and\n# conditions defined in the file COPYING, which is part of this source code package.\n\nfrom html import escape as html_escape\nimport re\nfrom typing import Union\n\nfrom six import ensure_str\n\nfrom cmk.gui.utils.html import HTML\n\n#.\n#   .--Escaper-------------------------------------------------------------.\n#   |                 _____                                                |\n#   |                | ____|___  ___ __ _ _ __   ___ _ __                  |\n#   |                |  _| / __|/ __/ _` | '_ \\ / _ \\ '__|                 |\n#   |                | |___\\__ \\ (_| (_| | |_) |  __/ |                    |\n#   |                |_____|___/\\___\\__,_| .__/ \\___|_|                    |\n#   |                                    |_|                               |\n#   +----------------------------------------------------------------------+\n#   |                                                                      |\n#   '----------------------------------------------------------------------\n\n# TODO: Figure out if this should actually be HTMLTagValue or HTMLContent or...\n# All the HTML-related types are slightly chaotic...\nEscapableEntity = Union[None, int, HTML, str]\n\n_UNESCAPER_TEXT = re.compile(\n    r'&lt;(/?)(h1|h2|b|tt|i|u|br(?: /)?|nobr(?: /)?|pre|a|sup|p|li|ul|ol)&gt;')\n_QUOTE = re.compile(r\"(?:&quot;|&#x27;)\")\n_A_HREF = re.compile(r'&lt;a href=((?:&quot;|&#x27;).*?(?:&quot;|&#x27;))&gt;')\n\n\n# TODO: Cleanup the accepted types!\ndef escape_attribute(value: EscapableEntity) -> str:\n    \"\"\"Escape HTML attributes.\n\n    For example: replace '\"' with '&quot;', '<' with '&lt;'.\n    This code is slow. Works on str and unicode without changing\n    the type. Also works on things that can be converted with '%s'.\n\n    Args:\n        value:\n\n    Examples:\n\n        >>> escape_attribute(\"Hello this is <b>dog</b>!\")\n        'Hello this is &lt;b&gt;dog&lt;/b&gt;!'\n\n        >>> escape_attribute(\"Hello this is <foo>dog</foo>!\")\n        'Hello this is &lt;foo&gt;dog&lt;/foo&gt;!'\n\n\n    Returns:\n\n    \"\"\"\n    attr_type = type(value)\n    if value is None:\n        return u''\n    if attr_type == int:\n        return str(value)\n    if isinstance(value, HTML):\n        return value.__html__()  # This is HTML code which must not be escaped\n    if isinstance(attr_type, str):\n        return html_escape(value, quote=True)\n    if isinstance(attr_type, bytes):  # TODO: Not in the signature!\n        return html_escape(ensure_str(value), quote=True)\n    # TODO: What is this case for? Exception?\n    return html_escape(u\"%s\" % value, quote=True)  # TODO: Not in the signature!\n\n\ndef unescape_attributes(value: str) -> str:\n    # In python3 use html.unescape\n    return ensure_str(value  #\n                      .replace(\"&amp;\", \"&\")  #\n                      .replace(\"&quot;\", \"\\\"\")  #\n                      .replace(\"&lt;\", \"<\")  #\n                      .replace(\"&gt;\", \">\"))\n\n\ndef escape_text(text: EscapableEntity) -> str:\n    \"\"\"Escape HTML text\n\n    We only strip some tags and allow some simple tags\n    such as <h1>, <b> or <i> to be part of the string.\n    This is useful for messages where we want to keep formatting\n    options. (Formerly known as 'permissive_attrencode')\n\n    Args:\n        text:\n\n    Examples:\n\n        >>> escape_text(\"Hello this is dog!\")\n        'Hello this is dog!'\n\n        This is lame.\n\n        >>> escape_text(\"Hello this <a href=\\\"\\\">is dog</a>!\")\n        'Hello this &lt;a href=&gt;is dog</a>!'\n\n    Returns:\n\n    \"\"\"\n    if isinstance(text, HTML):\n        return text.__html__()\n\n    text = escape_attribute(text)\n    text = _UNESCAPER_TEXT.sub(r'<\\1\\2>', text)\n    for a_href in _A_HREF.finditer(text):\n        text = text.replace(a_href.group(0), u\"<a href=%s>\" % _QUOTE.sub(u\"\\\"\", a_href.group(1)))\n    return text.replace(u\"&amp;nbsp;\", u\"&nbsp;\")\n\n\ndef strip_scripts(ht: str) -> str:\n    \"\"\"Strip script tags from text.\n\n    This function does not handle all the possible edge cases. Beware.\n\n    Args:\n        ht: A text with possible html in it.\n\n    Examples:\n        >>> strip_scripts('')\n        ''\n\n        >>> strip_scripts('foo <script>baz</script> bar')\n        'foo  bar'\n\n        Edge cases.\n\n        >>> strip_scripts('foo <scr<script></script>ipt>alert()</SCRIPT> bar')\n        'foo  bar'\n\n    Returns:\n        A text without html in it.\n\n    \"\"\"\n    prev = None\n    while prev != ht:\n        prev = ht\n        x = ht.lower().find('<script')\n        if x == -1:\n            break\n        y = ht.lower().find('</script')\n        if y == -1:\n            break\n        ht = ht[0:x] + ht[y + 9:]\n\n    return ht\n\n\ndef strip_tags(ht: EscapableEntity) -> str:\n    \"\"\"Strip all HTML tags from a text.\n\n    Args:\n        ht: A text with possible HTML tags in it.\n\n    Examples:\n        >>> strip_tags(\"<b>foobar</b> blah\")\n        'foobar blah'\n\n        Edge cases.\n\n        >>> strip_tags(\"<p<b<>re>foobar</</b>b> blah\")\n        're>foobarb> blah'\n\n    Returns:\n        A string without working HTML tags.\n\n    \"\"\"\n    if isinstance(ht, HTML):\n        ht = ht.__html__()\n\n    if not isinstance(ht, str):\n        return u\"%s\" % ht\n\n    ht = ensure_str(ht)\n\n    while True:\n        x = ht.find('<')\n        if x == -1:\n            break\n        y = ht.find('>', x)\n        if y == -1:\n            break\n        ht = ht[0:x] + ht[y + 1:]\n    return ht.replace(\"&nbsp;\", \" \")\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2\n# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and\n# conditions defined in the file COPYING, which is part of this source code package.\n\nimport pytest  # type: ignore[import]\n\nimport cmk.gui.htmllib as htmllib\nfrom cmk.gui import escaping\n\n\ndef test_htmllib_integration(register_builtin_html):\n    assert escaping.escape_attribute(\"\") == \"\"\n    assert escaping.escape_text(\"\") == \"\"\n\n\n@pytest.mark.parametrize(\"inp,out\", [\n    (\"\\\">alert(1)\", \"&quot;&gt;alert(1)\"),\n    (None, \"\"),\n    (1, \"1\"),\n    (htmllib.HTML(\"\\\">alert(1)\"), \"\\\">alert(1)\"),\n    (1.1, \"1.1\"),\n    (\"<\", \"&lt;\"),\n    (\"'\", \"&#x27;\"),\n])\ndef test_escape_attribute(inp, out):\n    assert escaping.escape_attribute(inp) == out\n\n\n@pytest.mark.parametrize(\"inp,out\", [\n    (\"&quot;&gt;alert(1)\", \"\\\">alert(1)\"),\n    (\"&lt;\", \"<\"),\n])\ndef test_unescape_attribute(inp, out):\n    assert escaping.unescape_attributes(inp) == out\n\n\n@pytest.mark.parametrize(\n    \"inp,out\",\n    [\n        (\"<script>alert(1)</script>\", \"&lt;script&gt;alert(1)&lt;/script&gt;\"),\n        (\"<h1>abc</h1>\", None),\n        (\"<h2>abc</h2>\", None),\n        (\"<b>abc</b>\", None),\n        (\"<tt>abc</tt>\", None),\n        (\"<i>abc</i>\", None),\n        (\"<u>abc</u>\", None),\n        (\"<br>\", None),\n        (\"<nobr></nobr>\", None),\n        (\"<pre></pre>\", None),\n        (\"<sup></sup>\", None),\n        (\"<p></p>\", None),\n        (\"<li></li>\", None),\n        (\"<ul></ul>\", None),\n        (\"<ol></ol>\", None),\n        (\"<a href=\\\"xyz\\\">abc</a>\", None),\n        (\"<a href=\\\"xyz\\\" target=\\\"123\\\">abc</a>\", None),\n        (\"blah<a href=\\\"link0\\\">aaa</a>blah<a href=\\\"link1\\\" target=\\\"ttt\\\">bbb</a>\", None),\n        (\"\\\"I am not a link\\\" target=\\\"still not a link\\\"\",\n         \"&quot;I am not a link&quot; target=&quot;still not a link&quot;\"),\n        # The next test is perverse: it contains the string `target=` inside of an\n        # <a> tag (which must be unescaped) as well as outside (which must not).\n        (\"<a href=\\\"aaa\\\">bbb</a>\\\"not a link\\\" target=\\\"really\\\"<a href=\\\"ccc\\\" target=\\\"ttt\\\">ddd</a>\",\n         \"<a href=\\\"aaa\\\">bbb</a>&quot;not a link&quot; target=&quot;really&quot;<a href=\\\"ccc\\\" target=\\\"ttt\\\">ddd</a>\"\n        ),\n        (\n            \"<a href=\\\"xyz\\\">abc</a><script>alert(1)</script><a href=\\\"xyz\\\">abc</a>\",\n            \"<a href=\\\"xyz\\\">abc</a>&lt;script&gt;alert(1)&lt;/script&gt;<a href=\\\"xyz\\\">abc</a>\",\n        ),\n        (\"&nbsp;\", None),\n    ])\ndef test_escape_text(inp, out):\n    if out is None:\n        out = inp\n    assert escaping.escape_text(inp) == out\n"], "fixing_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2\n# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and\n# conditions defined in the file COPYING, which is part of this source code package.\n\nfrom html import escape as html_escape\nimport re\nfrom typing import Union\n\nfrom six import ensure_str\n\nfrom cmk.gui.utils.html import HTML\n\n#.\n#   .--Escaper-------------------------------------------------------------.\n#   |                 _____                                                |\n#   |                | ____|___  ___ __ _ _ __   ___ _ __                  |\n#   |                |  _| / __|/ __/ _` | '_ \\ / _ \\ '__|                 |\n#   |                | |___\\__ \\ (_| (_| | |_) |  __/ |                    |\n#   |                |_____|___/\\___\\__,_| .__/ \\___|_|                    |\n#   |                                    |_|                               |\n#   +----------------------------------------------------------------------+\n#   |                                                                      |\n#   '----------------------------------------------------------------------\n\n# TODO: Figure out if this should actually be HTMLTagValue or HTMLContent or...\n# All the HTML-related types are slightly chaotic...\nEscapableEntity = Union[None, int, HTML, str]\n\n_UNESCAPER_TEXT = re.compile(\n    r'&lt;(/?)(h1|h2|b|tt|i|u|br(?: /)?|nobr(?: /)?|pre|a|sup|p|li|ul|ol)&gt;')\n_A_HREF = re.compile(\n    r'&lt;a href=(?:(?:&quot;|&#x27;)(.*?)(?:&quot;|&#x27;))(?: target=(?:(?:&quot;|&#x27;)(.*?)(?:&quot;|&#x27;)))?&gt;'\n)\n\n\n# TODO: Cleanup the accepted types!\ndef escape_attribute(value: EscapableEntity) -> str:\n    \"\"\"Escape HTML attributes.\n\n    For example: replace '\"' with '&quot;', '<' with '&lt;'.\n    This code is slow. Works on str and unicode without changing\n    the type. Also works on things that can be converted with '%s'.\n\n    Args:\n        value:\n\n    Examples:\n\n        >>> escape_attribute(\"Hello this is <b>dog</b>!\")\n        'Hello this is &lt;b&gt;dog&lt;/b&gt;!'\n\n        >>> escape_attribute(\"Hello this is <foo>dog</foo>!\")\n        'Hello this is &lt;foo&gt;dog&lt;/foo&gt;!'\n\n\n    Returns:\n\n    \"\"\"\n    attr_type = type(value)\n    if value is None:\n        return u''\n    if attr_type == int:\n        return str(value)\n    if isinstance(value, HTML):\n        return value.__html__()  # This is HTML code which must not be escaped\n    if isinstance(attr_type, str):\n        return html_escape(value, quote=True)\n    if isinstance(attr_type, bytes):  # TODO: Not in the signature!\n        return html_escape(ensure_str(value), quote=True)\n    # TODO: What is this case for? Exception?\n    return html_escape(u\"%s\" % value, quote=True)  # TODO: Not in the signature!\n\n\ndef unescape_attributes(value: str) -> str:\n    # In python3 use html.unescape\n    return ensure_str(value  #\n                      .replace(\"&amp;\", \"&\")  #\n                      .replace(\"&quot;\", \"\\\"\")  #\n                      .replace(\"&lt;\", \"<\")  #\n                      .replace(\"&gt;\", \">\"))\n\n\ndef escape_text(text: EscapableEntity) -> str:\n    \"\"\"Escape HTML text\n\n    We only strip some tags and allow some simple tags\n    such as <h1>, <b> or <i> to be part of the string.\n    This is useful for messages where we want to keep formatting\n    options. (Formerly known as 'permissive_attrencode')\n\n    Args:\n        text:\n\n    Examples:\n\n        >>> escape_text(\"Hello this is dog!\")\n        'Hello this is dog!'\n\n        This is lame.\n\n        >>> escape_text(\"Hello this <a href=\\\"\\\">is dog</a>!\")\n        'Hello this &lt;a href=&gt;is dog</a>!'\n\n    Returns:\n\n    \"\"\"\n    if isinstance(text, HTML):\n        return text.__html__()\n\n    text = escape_attribute(text)\n    text = _UNESCAPER_TEXT.sub(r'<\\1\\2>', text)\n    for a_href in _A_HREF.finditer(text):\n        href = a_href.group(1)\n        target = a_href.group(2)\n\n        if target:\n            unescaped_tag = \"<a href=\\\"%s\\\" target=\\\"%s\\\">\" % (href, target)\n        else:\n            unescaped_tag = \"<a href=\\\"%s\\\">\" % href\n\n        text = text.replace(a_href.group(0), unescaped_tag)\n    return text.replace(\"&amp;nbsp;\", u\"&nbsp;\")\n\n\ndef strip_scripts(ht: str) -> str:\n    \"\"\"Strip script tags from text.\n\n    This function does not handle all the possible edge cases. Beware.\n\n    Args:\n        ht: A text with possible html in it.\n\n    Examples:\n        >>> strip_scripts('')\n        ''\n\n        >>> strip_scripts('foo <script>baz</script> bar')\n        'foo  bar'\n\n        Edge cases.\n\n        >>> strip_scripts('foo <scr<script></script>ipt>alert()</SCRIPT> bar')\n        'foo  bar'\n\n    Returns:\n        A text without html in it.\n\n    \"\"\"\n    prev = None\n    while prev != ht:\n        prev = ht\n        x = ht.lower().find('<script')\n        if x == -1:\n            break\n        y = ht.lower().find('</script')\n        if y == -1:\n            break\n        ht = ht[0:x] + ht[y + 9:]\n\n    return ht\n\n\ndef strip_tags(ht: EscapableEntity) -> str:\n    \"\"\"Strip all HTML tags from a text.\n\n    Args:\n        ht: A text with possible HTML tags in it.\n\n    Examples:\n        >>> strip_tags(\"<b>foobar</b> blah\")\n        'foobar blah'\n\n        Edge cases.\n\n        >>> strip_tags(\"<p<b<>re>foobar</</b>b> blah\")\n        're>foobarb> blah'\n\n    Returns:\n        A string without working HTML tags.\n\n    \"\"\"\n    if isinstance(ht, HTML):\n        ht = ht.__html__()\n\n    if not isinstance(ht, str):\n        return u\"%s\" % ht\n\n    ht = ensure_str(ht)\n\n    while True:\n        x = ht.find('<')\n        if x == -1:\n            break\n        y = ht.find('>', x)\n        if y == -1:\n            break\n        ht = ht[0:x] + ht[y + 1:]\n    return ht.replace(\"&nbsp;\", \" \")\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2\n# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and\n# conditions defined in the file COPYING, which is part of this source code package.\n\nimport pytest  # type: ignore[import]\n\nimport cmk.gui.htmllib as htmllib\nfrom cmk.gui import escaping\n\n\ndef test_htmllib_integration(register_builtin_html):\n    assert escaping.escape_attribute(\"\") == \"\"\n    assert escaping.escape_text(\"\") == \"\"\n\n\n@pytest.mark.parametrize(\"inp,out\", [\n    (\"\\\">alert(1)\", \"&quot;&gt;alert(1)\"),\n    (None, \"\"),\n    (1, \"1\"),\n    (htmllib.HTML(\"\\\">alert(1)\"), \"\\\">alert(1)\"),\n    (1.1, \"1.1\"),\n    (\"<\", \"&lt;\"),\n    (\"'\", \"&#x27;\"),\n])\ndef test_escape_attribute(inp, out):\n    assert escaping.escape_attribute(inp) == out\n\n\n@pytest.mark.parametrize(\"inp,out\", [\n    (\"&quot;&gt;alert(1)\", \"\\\">alert(1)\"),\n    (\"&lt;\", \"<\"),\n])\ndef test_unescape_attribute(inp, out):\n    assert escaping.unescape_attributes(inp) == out\n\n\n@pytest.mark.parametrize(\n    \"inp,out\",\n    [\n        (\"<script>alert(1)</script>\", \"&lt;script&gt;alert(1)&lt;/script&gt;\"),\n        (\"<h1>abc</h1>\", None),\n        (\"<h2>abc</h2>\", None),\n        (\"<b>abc</b>\", None),\n        (\"<tt>abc</tt>\", None),\n        (\"<i>abc</i>\", None),\n        (\"<u>abc</u>\", None),\n        (\"<br>\", None),\n        (\"<nobr></nobr>\", None),\n        (\"<pre></pre>\", None),\n        (\"<sup></sup>\", None),\n        (\"<p></p>\", None),\n        (\"<li></li>\", None),\n        (\"<ul></ul>\", None),\n        (\"<ol></ol>\", None),\n        (\"<a href=\\\"xyz\\\">abc</a>\", None),\n        (\"<a href=\\\"xyz\\\" target=\\\"123\\\">abc</a>\", None),\n        # Links with target 1st and href 2nd will not be unescaped\n        (\"<a target=\\\"123\\\" href=\\\"xyz\\\">abc</a>\",\n         \"&lt;a target=&quot;123&quot; href=&quot;xyz&quot;&gt;abc</a>\"),\n        (\"blah<a href=\\\"link0\\\">aaa</a>blah<a href=\\\"link1\\\" target=\\\"ttt\\\">bbb</a>\", None),\n        (\"\\\"I am not a link\\\" target=\\\"still not a link\\\"\",\n         \"&quot;I am not a link&quot; target=&quot;still not a link&quot;\"),\n        # The next test is perverse: it contains the string `target=` inside of an\n        # <a> tag (which must be unescaped) as well as outside (which must not).\n        (\"<a href=\\\"aaa\\\">bbb</a>\\\"not a link\\\" target=\\\"really\\\"<a href=\\\"ccc\\\" target=\\\"ttt\\\">ddd</a>\",\n         \"<a href=\\\"aaa\\\">bbb</a>&quot;not a link&quot; target=&quot;really&quot;<a href=\\\"ccc\\\" target=\\\"ttt\\\">ddd</a>\"\n        ),\n        (\n            \"<a href=\\\"xyz\\\">abc</a><script>alert(1)</script><a href=\\\"xyz\\\">abc</a>\",\n            \"<a href=\\\"xyz\\\">abc</a>&lt;script&gt;alert(1)&lt;/script&gt;<a href=\\\"xyz\\\">abc</a>\",\n        ),\n        (\"&nbsp;\", None),\n        # At the moment also javascript URLs are accepted. This will be refused in the next step\n        (\"<a href=\\\"javascript:alert(1)\\\">abc</a>\", None),\n    ])\ndef test_escape_text(inp, out):\n    if out is None:\n        out = inp\n    assert escaping.escape_text(inp) == out\n"], "filenames": ["cmk/gui/escaping.py", "tests/unit/cmk/gui/test_htmllib_Escaper.py"], "buggy_code_start_loc": [33, 58], "buggy_code_end_loc": [116, 71], "fixing_code_start_loc": [33, 59], "fixing_code_end_loc": [125, 77], "type": "CWE-79", "message": "A stored cross site scripting (XSS) vulnerability in Checkmk 1.6.0x prior to 1.6.0p19 allows an authenticated remote attacker to inject arbitrary JavaScript via a javascript: URL in a view title.", "other": {"cve": {"id": "CVE-2020-28919", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-15T17:15:08.283", "lastModified": "2022-01-21T20:58:09.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stored cross site scripting (XSS) vulnerability in Checkmk 1.6.0x prior to 1.6.0p19 allows an authenticated remote attacker to inject arbitrary JavaScript via a javascript: URL in a view title."}, {"lang": "es", "value": "Una vulnerabilidad de tipo cross site scripting (XSS) almacenada en Checkmk versiones 1.6.0x anteriores a 1.6.0p19, permite a un atacante remoto autenticado inyectar JavaScript arbitrario por medio de una URL en el t\u00edtulo de una vista"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:-:*:*:*:*:*:*", "matchCriteriaId": "E15C521C-CD7F-434A-9F43-6ED5C7645DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b1:*:*:*:*:*:*", "matchCriteriaId": "172724CA-44E1-4768-8BAF-611AE72C8510"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b10:*:*:*:*:*:*", "matchCriteriaId": "EE1C7D4B-55E2-4A0B-96AD-4D1645141B43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b12:*:*:*:*:*:*", "matchCriteriaId": "7B691D90-C811-43A1-8062-71F2BF0EF5E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b3:*:*:*:*:*:*", "matchCriteriaId": "99D39BA7-C78A-4667-95F1-55ACB9FD584F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b4:*:*:*:*:*:*", "matchCriteriaId": "5B467203-3B24-4CAE-BEB4-88FEFA2223EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b5:*:*:*:*:*:*", "matchCriteriaId": "FDEC890E-D96A-490D-988D-B06C6CD86A05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:b9:*:*:*:*:*:*", "matchCriteriaId": "DB52C0F4-B206-4F20-BDB7-3FF2E60185D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p1:*:*:*:*:*:*", "matchCriteriaId": "D80533C1-AA9F-481B-A4A4-26AA0695C666"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p10:*:*:*:*:*:*", "matchCriteriaId": "FA0AD652-2417-4C33-8299-0411FA002BAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p11:*:*:*:*:*:*", "matchCriteriaId": "29F70025-92A2-4618-A8DD-05098F45625F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p12:*:*:*:*:*:*", "matchCriteriaId": "9CAAB02A-CB2D-42F9-9720-520822F88402"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p13:*:*:*:*:*:*", "matchCriteriaId": "46C5993C-BEE1-4C9B-BCDB-09A36DA2485E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p14:*:*:*:*:*:*", "matchCriteriaId": "53E01ABC-75DA-4323-9E8C-F97321974583"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p15:*:*:*:*:*:*", "matchCriteriaId": "77427E05-C4A1-4C28-84B8-947E26CF7EA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p16:*:*:*:*:*:*", "matchCriteriaId": "6036F586-CA74-40DE-B76F-C76357A1E833"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p17:*:*:*:*:*:*", "matchCriteriaId": "8F9B59E4-0468-495E-96C8-F765AFED2D67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p18:*:*:*:*:*:*", "matchCriteriaId": "4BD62952-9A86-4FEF-B8FC-3A2F468BFF95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p2:*:*:*:*:*:*", "matchCriteriaId": "104EB827-02D7-4AB9-897D-16210E8934D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p3:*:*:*:*:*:*", "matchCriteriaId": "5703ADA0-75EF-49B5-A826-5E657B71D64F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p4:*:*:*:*:*:*", "matchCriteriaId": "2195D39D-5BA2-44F5-8DFB-80A60DBFC866"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p5:*:*:*:*:*:*", "matchCriteriaId": "19D8AD44-8893-4F2B-9626-D16C03A39FB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p6:*:*:*:*:*:*", "matchCriteriaId": "E5F07AAF-8E7D-4F9D-82C9-D75B5C3397B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p7:*:*:*:*:*:*", "matchCriteriaId": "5A90CBA3-4548-4C23-A368-04A385956720"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p8:*:*:*:*:*:*", "matchCriteriaId": "F42920C1-B772-4AA3-A944-6B7636BF5FD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tribe29:checkmk:1.6.0:p9:*:*:*:*:*:*", "matchCriteriaId": "B7DFA157-07AD-4A07-8E2F-7D803CD1F267"}]}]}], "references": [{"url": "https://checkmk.com/check_mk-werks.php?werk_id=11501", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://emacsninja.com/posts/cve-2020-28919-stored-xss-in-checkmk-160p18.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/tribe29/checkmk/commit/c00f450f884d8a229b7d8ab3f0452ed802a1ae04", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tribe29/checkmk/commit/e7fd8e4c90be490e4293ec91804d00ec01af5ca6", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/tribe29/checkmk/commit/c00f450f884d8a229b7d8ab3f0452ed802a1ae04"}}