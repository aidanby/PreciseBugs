{"buggy_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n- area: proxy protocol\n  change: |\n    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n    a PROXY protocol header with address type LOCAL (typically used for health checks).\n- area: url matching\n  change: |\n    Fixed excessive CPU utilization when using regex URL template matcher.\n- area: http\n  change: |\n    Fixed crash when HTTP request idle and per try timeouts occurs within backoff interval.\n- area: proxy_protocol\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in a proxy protocol header. Connections will instead be dropped/reset.\n- area: tls\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in an mTLS client cert IP SAN. These SANs will be ignored. This applies only when using formatter\n    ``%DOWNSTREAM_PEER_IP_SAN%``.\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv4) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv6) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv4) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n- area: proxy protocol\n  change: |\n    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n    a PROXY protocol header with address type LOCAL (typically used for health checks).\n- area: url matching\n  change: |\n    Fixed excessive CPU utilization when using regex URL template matcher.\n- area: http\n  change: |\n    Fixed crash when HTTP request idle and per try timeouts occurs within backoff interval.\n- area: proxy_protocol\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in a proxy protocol header. Connections will instead be dropped/reset.\n- area: proxy_protocol\n  change: |\n    Fixed a bug where TLVs with non utf8 characters were inserted as protobuf values into filter metadata circumventing\n    ext_authz checks when ``failure_mode_allow`` is set to ``true``.\n- area: tls\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in an mTLS client cert IP SAN. These SANs will be ignored. This applies only when using formatter\n    ``%DOWNSTREAM_PEER_IP_SAN%``.\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      // Sanitize any non utf8 characters.\n      auto sanitised_tlv_value = MessageUtil::sanitizeUtf8String(tlv_value);\n      metadata_value.set_string_value(sanitised_tlv_value.data(), sanitised_tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv4) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv6) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv4) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterestAndSanitiseNonUtf8) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // A TLV of type 0x00 with size of 4 (1 byte is value).\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // A TLV of type 0x02 with size of 10 bytes (7 bytes are value). Second and last bytes in the\n  // value are non utf8 characters.\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0xfe,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0xc1};\n  // A TLV of type 0x0f with size of 6 bytes (3 bytes are value).\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // A TLV of type 0xea with size of 25 bytes (22 bytes are value). 7th and 21st bytes are non utf8\n  // characters.\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0xc0, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0xf9, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  const char replacement = 0x21;\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  // Non utf8 characters have been replaced with `0x21` (`!` character).\n  ASSERT_THAT(value_type_authority,\n              ElementsAre(0x66, replacement, 0x6f, 0x2e, 0x63, 0x6f, replacement));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, replacement, 0x35, 0x74, 0x65, 0x73,\n                          0x74, 0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, replacement, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["changelogs/current.yaml", "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc", "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc"], "buggy_code_start_loc": [64, 26, 1602], "buggy_code_end_loc": [64, 444, 1602], "fixing_code_start_loc": [65, 27, 1603], "fixing_code_end_loc": [69, 447, 1667], "type": "NVD-CWE-noinfo", "message": "Envoy is a high-performance edge/middle/service proxy. External authentication can be bypassed by downstream connections. Downstream clients can force invalid gRPC requests to be sent to ext_authz, circumventing ext_authz checks when failure_mode_allow is set to true. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2024-23324", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-09T23:15:09.223", "lastModified": "2024-02-15T04:46:33.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a high-performance edge/middle/service proxy. External authentication can be bypassed by downstream connections. Downstream clients can force invalid gRPC requests to be sent to ext_authz, circumventing ext_authz checks when failure_mode_allow is set to true. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}, {"lang": "es", "value": "Envoy es un proxy de servicio/intermedio/perimetral de alto rendimiento. La autenticaci\u00f3n externa se puede omitir mediante conexiones descendentes. Los clientes intermedios pueden forzar el env\u00edo de solicitudes gRPC no v\u00e1lidas a ext_authz, eludiendo las comprobaciones de ext_authz cuando Failure_mode_allow se establece en verdadero. Este problema se solucion\u00f3 en las versiones 1.29.1, 1.28.1, 1.27.3 y 1.26.7. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.26.0", "versionEndExcluding": "1.26.7", "matchCriteriaId": "0324E095-98B4-4B78-9242-989EC45E011F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.27.0", "versionEndExcluding": "1.27.3", "matchCriteriaId": "2E838B16-C6DC-4701-B955-D96D4CAEF4F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.28.0", "versionEndExcluding": "1.28.1", "matchCriteriaId": "770D5713-48E3-4F9B-B05C-9CB9C6B272E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.29.0", "versionEndExcluding": "1.29.1", "matchCriteriaId": "638F3351-3ACD-47C8-9B8F-568A930FAECA"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-gq3v-vvhj-96j6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a"}}