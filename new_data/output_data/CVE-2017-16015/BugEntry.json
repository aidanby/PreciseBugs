{"buggy_code": ["{\n\t\"root\": true,\n\n\t\"extends\": \"@ljharb\",\n\n\t\"rules\": {\n\t\t\"callback-return\": [0],\n\t\t\"camelcase\": [0],\n\t\t\"complexity\": [2, 11],\n\t\t\"dot-notation\": [2, { \"allowKeywords\": false }],\n\t\t\"eqeqeq\": [2, \"allow-null\"],\n\t\t\"id-length\": [2, { \"min\": 1, \"max\": 30 }],\n\t\t\"indent\": [2, 4],\n\t\t\"max-lines\": 0,\n\t\t\"max-nested-callbacks\": [2, 5],\n\t\t\"max-params\": [2, 3],\n\t\t\"max-statements\": [2, 20],\n\t\t\"max-statements-per-line\": [2, { \"max\": 2 }],\n\t\t\"new-cap\": [2, { \"capIsNewExceptions\": [\"Template\"] }],\n\t\t\"no-extra-parens\": [0],\n\t\t\"no-magic-numbers\": [0],\n\t\t\"no-negated-condition\": [0],\n\t\t\"operator-linebreak\": [2, \"after\"],\n\t\t\"sort-keys\": 0\n\t}\n}\n", "'use strict';\n\nvar tag = require('./tag');\nvar wrapWith = function (tagName) {\n    return function (name, field, options) {\n        var opt = options || {};\n        var wrappedContent = [];\n        var errorHTML = opt.hideError ? '' : field.errorHTML();\n        if (field.widget.type === 'multipleCheckbox' || field.widget.type === 'multipleRadio') {\n            var fieldsetAttrs = { classes: [] };\n            if (opt.fieldsetClasses) {\n                fieldsetAttrs.classes = fieldsetAttrs.classes.concat(opt.fieldsetClasses);\n            }\n            var legendAttrs = { classes: [] };\n            if (opt.legendClasses) {\n                legendAttrs.classes = legendAttrs.classes.concat(opt.legendClasses);\n            }\n\n            var fieldset = tag('fieldset', fieldsetAttrs, [\n                tag('legend', legendAttrs, field.labelText(name)),\n                opt.errorAfterField ? '' : errorHTML,\n                field.widget.toHTML(name, field),\n                opt.errorAfterField ? errorHTML : ''\n            ].join(''));\n            wrappedContent.push(fieldset);\n        } else {\n            var fieldHTMLs = [field.labelHTML(name, field.id), field.widget.toHTML(name, field)];\n            if (opt.labelAfterField) {\n                fieldHTMLs.reverse();\n            }\n            if (opt.errorAfterField) {\n                fieldHTMLs.push(errorHTML);\n            } else {\n                fieldHTMLs.unshift(errorHTML);\n            }\n            wrappedContent = wrappedContent.concat(fieldHTMLs);\n        }\n        return tag(tagName, { classes: field.classes() }, wrappedContent.join(''));\n    };\n};\nexports.div = wrapWith('div');\nexports.p = wrapWith('p');\nexports.li = wrapWith('li');\n\nexports.table = function (name, field, options) {\n    var opt = options || {};\n\n    var th = tag('th', {}, field.labelHTML(name, field.id));\n\n    var tdContent = field.widget.toHTML(name, field);\n\n    if (!opt.hideError) {\n        var errorHTML = field.errorHTML();\n        if (opt.errorAfterField) {\n            tdContent += errorHTML;\n        } else {\n            tdContent = errorHTML + tdContent;\n        }\n    }\n\n    var td = tag('td', {}, tdContent);\n\n    return tag('tr', { classes: field.classes() }, th + td);\n};\n", "'use strict';\n\nvar htmlEscape = require('./htmlEscape');\nvar is = require('is');\nvar keys = require('object-keys');\n\n// generates a string for common HTML tag attributes\nvar attrs = function attrs(a) {\n    if (typeof a.id === 'boolean') {\n        a.id = a.id ? 'id_' + a.name : null;\n    }\n    if (is.array(a.classes) && a.classes.length > 0) {\n        a['class'] = htmlEscape(a.classes.join(' '));\n    }\n    a.classes = null;\n    var pairs = [];\n    keys(a).forEach(function (field) {\n        var value = a[field];\n        if (typeof value === 'boolean') {\n            value = value ? field : null;\n        } else if (typeof value === 'number' && isNaN(value)) {\n            value = null;\n        }\n        if (typeof value !== 'undefined' && value !== null) {\n            pairs.push(htmlEscape(field) + '=\"' + htmlEscape(value) + '\"');\n        }\n    });\n    return pairs.length > 0 ? ' ' + pairs.join(' ') : '';\n};\n\nvar selfClosingTags = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nvar isSelfClosing = function (tagName) {\n    return Object.prototype.hasOwnProperty.call(selfClosingTags, tagName);\n};\n\nvar tag = function tag(tagName, attrsMap, content) {\n    var safeTagName = htmlEscape(tagName);\n    var attrsHTML = !is.array(attrsMap) ? attrs(attrsMap) : attrsMap.reduce(function (html, map) {\n        return html + attrs(map);\n    }, '');\n    return '<' + safeTagName + attrsHTML + (isSelfClosing(safeTagName) ? ' />' : '>' + content + '</' + safeTagName + '>');\n};\n\ntag.attrs = attrs;\n\nmodule.exports = tag;\n", "'use strict';\n\nvar is = require('is');\nvar keys = require('object-keys');\nvar tag = require('./tag');\n\nvar dataRegExp = /^data-[a-z]+([-][a-z]+)*$/;\nvar ariaRegExp = /^aria-[a-z]+$/;\nvar legalAttrs = ['autocomplete', 'autocorrect', 'autofocus', 'autosuggest', 'checked', 'dirname', 'disabled', 'tabindex', 'list', 'max', 'maxlength', 'min', 'novalidate', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step'];\nvar ignoreAttrs = ['id', 'name', 'class', 'classes', 'type', 'value', 'multiple'];\nvar getUserAttrs = function (opt) {\n    return keys(opt).reduce(function (attrs, k) {\n        if ((ignoreAttrs.indexOf(k) === -1 && legalAttrs.indexOf(k) > -1) || dataRegExp.test(k) || ariaRegExp.test(k)) {\n            attrs[k] = opt[k];\n        }\n        return attrs;\n    }, {});\n};\n\n// used to generate different input elements varying only by type attribute\nvar input = function (type) {\n    return function (opts) {\n        var opt = opts || {};\n        var userAttrs = getUserAttrs(opt);\n        var w = {\n            classes: opt.classes,\n            type: type,\n            formatValue: function (value) {\n                return (value || value === 0) ? value : null;\n            }\n        };\n        w.toHTML = function (name, field) {\n            var f = field || {};\n            var attrs = {\n                type: type,\n                name: name,\n                id: f.id === false ? false : (f.id || true),\n                classes: w.classes,\n                value: w.formatValue(f.value)\n            };\n            return tag('input', [attrs, userAttrs, w.attrs || {}]);\n        };\n        return w;\n    };\n};\n\nvar choiceValueEquals = function (value1, value2) {\n    return !is.array(value1) && !is.array(value2) && String(value1) === String(value2);\n};\n\nvar isSelected = function (value, choice) {\n    return value && (is.array(value) ? value.some(choiceValueEquals.bind(null, choice)) : choiceValueEquals(value, choice));\n};\n\nvar renderChoices = function (choices, renderer) {\n    return choices.reduce(function (partialRendered, choice) {\n        var isNested = is.array(choice[1]);\n        var renderData = isNested ?\n            { isNested: true, label: choice[0], choices: choice[1] } :\n            { isNested: false, value: choice[0], label: choice[1] };\n        return partialRendered + renderer(renderData);\n    }, '');\n};\n\nvar isScalar = function (value) {\n    return !value || is.string(value) || is.number(value) || is.bool(value);\n};\n\nvar unifyChoices = function (choices, nestingLevel) {\n    if (nestingLevel < 0) {\n        throw new RangeError('choices nested too deep');\n    }\n\n    var unifyChoiceArray = function (arrayChoices, currentLevel) {\n        return arrayChoices.reduce(function (result, choice) {\n            if (!is.array(choice) || choice.length !== 2) {\n                throw new TypeError('choice must be array with two elements');\n            }\n            if (isScalar(choice[0]) && isScalar(choice[1])) {\n                result.push(choice);\n            } else if (isScalar(choice[0]) && (is.array(choice[1]) || is.object(choice[1]))) {\n                result.push([choice[0], unifyChoices(choice[1], currentLevel - 1)]);\n            } else {\n                throw new TypeError('expected primitive value as first and primitive value, object, or array as second element');\n            }\n            return result;\n        }, []);\n    };\n\n    var unifyChoiceObject = function (objectChoices, currentLevel) {\n        return keys(objectChoices).reduce(function (result, key) {\n            var label = objectChoices[key];\n            if (isScalar(label)) {\n                result.push([key, label]);\n            } else if (is.array(label) || is.object(label)) {\n                result.push([key, unifyChoices(label, currentLevel - 1)]);\n            } else {\n                throw new TypeError('expected primitive value, object, or array as object value');\n            }\n            return result;\n        }, []);\n    };\n\n    return is.array(choices) ? unifyChoiceArray(choices, nestingLevel) : unifyChoiceObject(choices, nestingLevel);\n};\n\nvar select = function (isMultiple) {\n    return function (options) {\n        var opt = options || {};\n        var w = {\n            classes: opt.classes,\n            type: isMultiple ? 'multipleSelect' : 'select'\n        };\n        var userAttrs = getUserAttrs(opt);\n        w.toHTML = function (name, field) {\n            var f = field || {};\n            var choices = unifyChoices(f.choices, 1);\n            var optionsHTML = renderChoices(choices, function render(choice) {\n                if (choice.isNested) {\n                    return tag('optgroup', { label: choice.label }, renderChoices(choice.choices, render));\n                } else {\n                    return tag('option', { value: choice.value, selected: !!isSelected(f.value, choice.value) }, choice.label);\n                }\n            });\n            var attrs = {\n                name: name,\n                id: f.id === false ? false : (f.id || true),\n                classes: w.classes\n            };\n            if (isMultiple) {\n                attrs.multiple = true;\n            }\n            return tag('select', [attrs, userAttrs, w.attrs || {}], optionsHTML);\n        };\n        return w;\n    };\n};\n\nexports.text = input('text');\nexports.email = input('email');\nexports.number = input('number');\nexports.hidden = input('hidden');\nexports.color = input('color');\nexports.tel = input('tel');\n\nvar passwordWidget = input('password');\nvar passwordFormatValue = function () { return null; };\nexports.password = function (opt) {\n    var w = passwordWidget(opt);\n    w.formatValue = passwordFormatValue;\n    return w;\n};\n\nvar dateWidget = input('date');\nexports.date = function (opt) {\n    var w = dateWidget(opt);\n    w.formatValue = function (value) {\n        if (!value) {\n            return null;\n        }\n\n        var date = is.date(value) ? value : new Date(value);\n\n        if (isNaN(date.getTime())) {\n            return null;\n        }\n\n        return date.toISOString().slice(0, 10);\n    };\n    return w;\n};\n\nexports.select = select(false);\nexports.multipleSelect = select(true);\n\nexports.checkbox = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        type: 'checkbox'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var attrs = {\n            type: 'checkbox',\n            name: name,\n            id: f.id === false ? false : (f.id || true),\n            classes: w.classes,\n            checked: !!f.value,\n            value: 'on'\n        };\n        return tag('input', [attrs, userAttrs, w.attrs || {}]);\n    };\n    return w;\n};\n\nexports.textarea = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        type: 'textarea'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var attrs = {\n            name: name,\n            id: f.id === false ? false : (f.id || true),\n            classes: w.classes,\n            rows: opt.rows || null,\n            cols: opt.cols || null\n        };\n        return tag('textarea', [attrs, userAttrs, w.attrs || {}], f.value || '');\n    };\n    return w;\n};\n\nexports.multipleCheckbox = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        labelClasses: opt.labelClasses,\n        type: 'multipleCheckbox'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var choices = unifyChoices(f.choices, 0);\n        return renderChoices(choices, function (choice) {\n            // input element\n            var id = f.id === false ? false : (f.id ? f.id + '_' + choice.value : 'id_' + name + '_' + choice.value);\n            var checked = isSelected(f.value, choice.value);\n\n            var attrs = {\n                type: 'checkbox',\n                name: name,\n                id: id,\n                classes: w.classes,\n                value: choice.value,\n                checked: !!checked\n            };\n            var inputHTML = tag('input', [attrs, userAttrs, w.attrs || {}]);\n\n            // label element\n            var labelHTML = tag('label', { 'for': id, classes: w.labelClasses }, choice.label);\n\n            return inputHTML + labelHTML;\n        });\n    };\n    return w;\n};\n\nexports.label = function (options) {\n    var opt = options || {};\n    var w = { classes: opt.classes || [] };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (forID) {\n        var attrs = {\n            'for': forID,\n            classes: w.classes\n        };\n        return tag('label', [attrs, userAttrs, w.attrs || {}], opt.content);\n    };\n    return w;\n};\n\nexports.multipleRadio = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        labelClasses: opt.labelClasses,\n        type: 'multipleRadio'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var choices = unifyChoices(f.choices, 0);\n        return renderChoices(choices, function (choice) {\n            // input element\n            var id = f.id === false ? false : (f.id ? f.id + '_' + choice.value : 'id_' + name + '_' + choice.value);\n            var checked = isSelected(f.value, choice.value);\n            var attrs = {\n                type: 'radio',\n                name: name,\n                id: id,\n                classes: w.classes,\n                value: choice.value,\n                checked: !!checked\n            };\n            var inputHTML = tag('input', [attrs, userAttrs, w.attrs || {}]);\n            // label element\n            var labelHTML = tag('label', { 'for': id, classes: w.labelClasses }, choice.label);\n\n            return inputHTML + labelHTML;\n        });\n    };\n    return w;\n};\n", "'use strict';\n\nvar forms = require('../lib/forms');\nvar test = require('tape');\nvar keys = require('object-keys');\n\nvar test_input = function (type) {\n    return function (t) {\n        t.equal(\n            forms.widgets[type]().toHTML('field1'),\n            '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" />'\n        );\n        var w = forms.widgets[type]({ classes: ['test1', 'test2', 'test3'] });\n        t.equal(\n            w.toHTML('field2', { id: 'form2_field2' }),\n            '<input type=\"' + type + '\" name=\"field2\" id=\"form2_field2\" class=\"test1 test2 test3\" />'\n        );\n\n        var expectedHTML = '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" value=\"some value\" />';\n        if (type === 'password') {\n            expectedHTML = '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" />';\n        }\n        t.equal(forms.widgets[type]().toHTML('field1', { value: 'some value' }), expectedHTML);\n        t.equal(forms.widgets[type]().type, type);\n\n        var expectedValues = { password: null };\n        var expectedValue = typeof expectedValues[type] !== 'undefined' ? expectedValues[type] : 'hello';\n        t.equal(forms.widgets[type]().formatValue('hello'), expectedValue);\n\n        t.strictEqual(forms.widgets[type]().formatValue(false), null);\n        t.end();\n    };\n};\n\ntest('text', test_input('text'));\ntest('email', test_input('email'));\ntest('number', test_input('number'));\ntest('password', test_input('password'));\ntest('hidden', test_input('hidden'));\ntest('color', test_input('color'));\ntest('tel', test_input('tel'));\n\ntest('date', function (t) {\n    var w = forms.widgets.date();\n    t.equal(w.formatValue(new Date(Date.UTC(2013, 2, 1))), '2013-03-01');\n    t.equal(w.formatValue('2013-03-02'), '2013-03-02');\n    t.strictEqual(w.formatValue('invalid'), null);\n\n    t.equal(w.type, 'date');\n\n    t.equal(\n        w.toHTML('field1'),\n        '<input type=\"date\" name=\"field1\" id=\"id_field1\" />'\n    );\n\n    t.equal(\n        w.toHTML('field1', { value: '2013-03-03' }),\n        '<input type=\"date\" name=\"field1\" id=\"id_field1\" value=\"2013-03-03\" />'\n    );\n\n    t.end();\n});\n\ntest('checkbox', function (t) {\n    t.equal(\n        forms.widgets.checkbox().toHTML('field1'),\n        '<input type=\"checkbox\" name=\"field1\" id=\"id_field1\" value=\"on\" />'\n    );\n    var w = forms.widgets.checkbox({ classes: ['test1', 'test2', 'test3'] });\n    t.equal(\n        w.toHTML('field2', { id: 'form2_field2' }),\n        '<input type=\"checkbox\" name=\"field2\" id=\"form2_field2\" value=\"on\" class=\"test1 test2 test3\" />'\n    );\n    t.equal(\n        forms.widgets.checkbox().toHTML('field', { value: true }),\n        '<input type=\"checkbox\" name=\"field\" id=\"id_field\" checked=\"checked\" value=\"on\" />'\n    );\n    t.equal(\n        forms.widgets.checkbox().toHTML('field', { value: false }),\n        '<input type=\"checkbox\" name=\"field\" id=\"id_field\" value=\"on\" />'\n    );\n    t.equal(forms.widgets.checkbox().type, 'checkbox');\n    t.end();\n});\n\ntest('select', function (t) {\n    t.equal(\n        forms.widgets.select().toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    var widget = forms.widgets.select({ classes: ['one', 'two'] });\n    t.equal(\n        widget.toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            },\n            id: 'someid',\n            value: 'val2'\n        }),\n        '<select name=\"name\" id=\"someid\" class=\"one two\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\" selected=\"selected\">text2</option>' +\n        '</select>'\n    );\n    t.equal(widget.type, 'select');\n\n    t.test('throws on invalid choices', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    [['invalid'], 'text1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', { choices: ['invalid'] });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    [{ invalid: 'invalid' }, 'text1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', function () { return 'invalid'; }]\n                ]\n            });\n        });\n\n        st.end();\n    });\n\n    t.test('supports array choices', function (st) {\n        st.equal(\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', 'text1'],\n                    ['val2', 'text2'],\n                    ['text3',\n                        [\n                            ['val3', 'text4'],\n                            ['val4', 'text5'],\n                            ['val5', 'text6']\n                        ]\n                    ],\n                    ['val6', 'text7']\n                ]\n            }),\n            '<select name=\"name\" id=\"id_name\">' +\n                '<option value=\"val1\">text1</option>' +\n                '<option value=\"val2\">text2</option>' +\n                '<optgroup label=\"text3\">' +\n                    '<option value=\"val3\">text4</option>' +\n                    '<option value=\"val4\">text5</option>' +\n                    '<option value=\"val5\">text6</option>' +\n                '</optgroup>' +\n                '<option value=\"val6\">text7</option>' +\n            '</select>'\n        );\n        st.end();\n    });\n\n    t.test('throws on deeply nested choices', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['text1',\n                        [\n                            ['text2',\n                                [\n                                    ['val1', 'text3']\n                                ]\n                            ]\n                        ]\n                    ]\n                ]\n            });\n        });\n        st.end();\n    });\n\n    t.test('throws on invalid array format', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    []\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', 'text1', 'invalid']\n                ]\n            });\n        });\n\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        var html = widget.toHTML('name', {\n            choices: {\n                1: 'one',\n                2: 'two'\n            },\n            id: 'someid',\n            value: 2\n        });\n        var expectedHTML = '<select name=\"name\" id=\"someid\" class=\"one two\">' +\n            '<option value=\"1\">one</option>' +\n            '<option value=\"2\" selected=\"selected\">two</option>' +\n        '</select>';\n        st.equal(html, expectedHTML);\n        st.end();\n    });\n    t.end();\n});\n\ntest('textarea', function (t) {\n    t.equal(\n        forms.widgets.textarea().toHTML('name', {}),\n        '<textarea name=\"name\" id=\"id_name\"></textarea>'\n    );\n    t.equal(\n        forms.widgets.textarea({\n            classes: ['one', 'two'],\n            cols: 80,\n            placeholder: 'hi!',\n            rows: 20\n        }).toHTML('name', { id: 'someid', value: 'value' }),\n        '<textarea name=\"name\" id=\"someid\" rows=\"20\" cols=\"80\" class=\"one two\" placeholder=\"hi!\">value</textarea>'\n    );\n    t.equal(forms.widgets.textarea().type, 'textarea');\n    t.end();\n});\n\ntest('multipleCheckbox', function (t) {\n    var w = forms.widgets.multipleCheckbox();\n    t.test('basic functionality', function (st) {\n        var field = {\n            choices: {\n                one: 'Item one',\n                two: 'Item two',\n                three: 'Item three'\n            },\n            value: 'two'\n        };\n        st.equal(\n            w.toHTML('name', field),\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n            '<label for=\"id_name_one\">Item one</label>' +\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n            '<label for=\"id_name_two\">Item two</label>' +\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n            '<label for=\"id_name_three\">Item three</label>'\n        );\n        st.equal(w.type, 'multipleCheckbox');\n\n        st.test('label classes', function (st2) {\n            var widget = forms.widgets.multipleCheckbox({ labelClasses: ['test1', 'test2', 'test3'] });\n            st2.equal(\n                widget.toHTML('name', field),\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n                '<label for=\"id_name_one\" class=\"test1 test2 test3\">Item one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n                '<label for=\"id_name_two\" class=\"test1 test2 test3\">Item two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n                '<label for=\"id_name_three\" class=\"test1 test2 test3\">Item three</label>'\n            );\n            st2.end();\n        });\n\n        st.end();\n    });\n\n    t.test('throws on nested choices', function (st) {\n        st['throws'](\n            function () {\n                w.toHTML('name', {\n                    choices: [\n                        ['val1', 'text1'],\n                        ['val2', 'text2'],\n                        ['text3',\n                            [\n                                ['val3', 'text4']\n                            ]\n                        ]\n                    ]\n                });\n            }\n        );\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        st.test('single bound value', function (t2) {\n            var field = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: 2\n            };\n            var html = w.toHTML('name', field);\n            var expectedHTML = '<input type=\"checkbox\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var field = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: [1, 2]\n            };\n            var html = w.toHTML('name', field);\n            var expectedHTML = '<input type=\"checkbox\" name=\"name\" id=\"id_name_1\" value=\"1\" checked=\"checked\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('multipleCheckbox multiple selected', function (t) {\n    var w = forms.widgets.multipleCheckbox(),\n        field = {\n            choices: {\n                one: 'Item one',\n                two: 'Item two',\n                three: 'Item three'\n            },\n            value: ['two', 'three']\n        };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" checked=\"checked\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleCheckbox().type, 'multipleCheckbox');\n    t.end();\n});\n\ntest('multipleRadio', function (t) {\n    var w = forms.widgets.multipleRadio();\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleRadio().type, 'multipleRadio');\n\n    t.test('throw on nested choices', function (st) {\n        st['throws'](\n            function () {\n                w.toHTML('name', {\n                    choices: [\n                        ['val1', 'text1'],\n                        ['val2', 'text2'],\n                        ['text3',\n                            [\n                                ['val3', 'text4']\n                            ]\n                        ]\n                    ]\n                });\n            }\n        );\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        st.test('single bound value', function (t2) {\n            var boundValueField = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: 2\n            };\n            var html = w.toHTML('name', boundValueField);\n            var expectedHTML = '<input type=\"radio\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var boundValuesField = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: [2, 3]\n            };\n            var html = w.toHTML('name', boundValuesField);\n            var expectedHTML = '<input type=\"radio\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_3\" value=\"3\" checked=\"checked\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.test('label classes', function (st) {\n        var widget = forms.widgets.multipleRadio({ labelClasses: ['test1', 'test2', 'test3'] });\n        st.equal(\n            widget.toHTML('name', field),\n            '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n            '<label for=\"id_name_one\" class=\"test1 test2 test3\">Item one</label>' +\n            '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n            '<label for=\"id_name_two\" class=\"test1 test2 test3\">Item two</label>' +\n            '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n            '<label for=\"id_name_three\" class=\"test1 test2 test3\">Item three</label>'\n        );\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('multipleRadio multiple selected', function (t) {\n    var w = forms.widgets.multipleRadio();\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: ['two', 'three']\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" checked=\"checked\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleRadio().type, 'multipleRadio');\n    t.end();\n});\n\ntest('multipleSelect', function (t) {\n    t.equal(\n        forms.widgets.multipleSelect().toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" multiple=\"multiple\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    t.equal(\n        forms.widgets.multipleSelect({ classes: ['one', 'two'] }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2',\n                val3: 'text3'\n            },\n            id: 'someid',\n            value: ['val2', 'val3']\n        }),\n        '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\" selected=\"selected\">text2</option>' +\n            '<option value=\"val3\" selected=\"selected\">text3</option>' +\n        '</select>'\n    );\n    t.equal(forms.widgets.multipleSelect().type, 'multipleSelect');\n\n    t.test('stringifies values', function (st) {\n        var widget = forms.widgets.multipleSelect({ classes: ['one', 'two'] });\n\n        st.test('single bound values', function (t2) {\n            var html = widget.toHTML('name', {\n                choices: {\n                    1: 'text1',\n                    2: 'text2',\n                    3: 'text3'\n                },\n                id: 'someid',\n                value: 2\n            });\n            var expectedHTML = '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n                '<option value=\"1\">text1</option>' +\n                '<option value=\"2\" selected=\"selected\">text2</option>' +\n                '<option value=\"3\">text3</option>' +\n            '</select>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var html = widget.toHTML('name', {\n                choices: {\n                    1: 'text1',\n                    2: 'text2',\n                    3: 'text3'\n                },\n                id: 'someid',\n                value: [2, 3]\n            });\n            var expectedHTML = '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n                '<option value=\"1\">text1</option>' +\n                '<option value=\"2\" selected=\"selected\">text2</option>' +\n                '<option value=\"3\" selected=\"selected\">text3</option>' +\n            '</select>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('optional text input', function (t) {\n    t.equal(\n        forms.widgets.text({\n            'data-trigger': 'focus',\n            placeholder: 'Enter some comment'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" data-trigger=\"focus\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            'aria-required': 'false',\n            classes: ['one', 'two'],\n            'data-trigger': 'focus',\n            placeholder: 'Enter some comment'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" class=\"one two\" aria-required=\"false\" data-trigger=\"focus\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            placeholder: 'Enter some comment',\n            unknown: 'foo'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            autocomplete: 'on',\n            max: 10,\n            min: 5,\n            unknown: 'foo'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" autocomplete=\"on\" max=\"10\" min=\"5\" />'\n    );\n    t.equal(\n        forms.widgets.text({ placeholder: 'Enter \"some\" comment' }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" placeholder=\"Enter &quot;some&quot; comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({ tabindex: 1 }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" tabindex=\"1\" />'\n    );\n    t.end();\n});\n\ntest('custom attributes', function (t) {\n    // regex tests\n    t.equal(\n        forms.widgets.text({ 'data-': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-input': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-input=\"foo\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'idata-input': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-input1': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ data_input: 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data--': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-foo-bar': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-foo-bar=\"foo\" />'\n    );\n\n    // widgets not based on the \"input\" widget should support optional attributes\n    t.equal(\n        forms.widgets.textarea({ 'data-test': 'foo' }).toHTML('fieldWithAttrs'),\n        '<textarea name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-test=\"foo\"></textarea>'\n    );\n    t.equal(\n        forms.widgets.label({\n            content: 'Foobar',\n            'data-test': 'foo'\n        }).toHTML('fieldWithAttrs'),\n        '<label for=\"fieldWithAttrs\" data-test=\"foo\">Foobar</label>'\n    );\n    t.equal(\n        forms.widgets.checkbox({ 'data-test': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"checkbox\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" value=\"on\" data-test=\"foo\" />'\n    );\n    t.equal(\n        forms.widgets.select({ 'data-test': 'foo' }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" data-test=\"foo\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    t.equal(\n        forms.widgets.multipleSelect({ 'data-test': 'foo' }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" multiple=\"multiple\" data-test=\"foo\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n\n    var w = forms.widgets.multipleCheckbox({ 'data-test': 'foo' });\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" data-test=\"foo\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" data-test=\"foo\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" data-test=\"foo\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n\n    var w2 = forms.widgets.multipleRadio({ 'data-test': 'foo' });\n    var field2 = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w2.toHTML('name', field2),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" data-test=\"foo\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" data-test=\"foo\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" data-test=\"foo\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n\n    t.end();\n});\n\ntest('label', function (t) {\n    t.equal(\n        forms.widgets.label({\n            classes: ['foo', 'bar', 'quux'],\n            content: 'Foobar'\n        }).toHTML('field1'),\n        '<label for=\"field1\" class=\"foo bar quux\">Foobar</label>'\n    );\n    t.equal(\n        forms.widgets.label({\n            classes: [],\n            content: 'Foobar'\n        }).toHTML('field1'),\n        '<label for=\"field1\">Foobar</label>'\n    );\n    t.end();\n});\n\ntest('dynamic widget attributes', function (t) {\n    var theKeys = keys(forms.widgets);\n    t.plan(theKeys.length);\n    var re = /autocomplete=\"no\"/;\n    theKeys.forEach(function (name) {\n        var w = forms.widgets[name]();\n        w.attrs = { autocomplete: 'no' };\n        var html = w.toHTML('test', { choices: { foo: 'bar' } });\n        t.equal(re.test(html), true);\n    });\n    t.end();\n});\n"], "fixing_code": ["{\n\t\"root\": true,\n\n\t\"extends\": \"@ljharb\",\n\n\t\"rules\": {\n\t\t\"callback-return\": [0],\n\t\t\"camelcase\": [0],\n\t\t\"complexity\": [2, 11],\n\t\t\"dot-notation\": [2, { \"allowKeywords\": false }],\n\t\t\"eqeqeq\": [2, \"allow-null\"],\n\t\t\"id-length\": [2, { \"min\": 1, \"max\": 30 }],\n\t\t\"indent\": [2, 4],\n\t\t\"max-lines\": 0,\n\t\t\"max-nested-callbacks\": [2, 5],\n\t\t\"max-params\": [2, 4],\n\t\t\"max-statements\": [2, 20],\n\t\t\"max-statements-per-line\": [2, { \"max\": 2 }],\n\t\t\"new-cap\": [2, { \"capIsNewExceptions\": [\"Template\"] }],\n\t\t\"no-extra-parens\": [0],\n\t\t\"no-magic-numbers\": [0],\n\t\t\"no-negated-condition\": [0],\n\t\t\"operator-linebreak\": [2, \"after\"],\n\t\t\"sort-keys\": 0\n\t}\n}\n", "'use strict';\n\nvar tag = require('./tag');\nvar wrapWith = function (tagName) {\n    return function (name, field, options) {\n        var opt = options || {};\n        var wrappedContent = [];\n        var errorHTML = opt.hideError ? '' : field.errorHTML();\n        if (field.widget.type === 'multipleCheckbox' || field.widget.type === 'multipleRadio') {\n            var fieldsetAttrs = { classes: [] };\n            if (opt.fieldsetClasses) {\n                fieldsetAttrs.classes = fieldsetAttrs.classes.concat(opt.fieldsetClasses);\n            }\n            var legendAttrs = { classes: [] };\n            if (opt.legendClasses) {\n                legendAttrs.classes = legendAttrs.classes.concat(opt.legendClasses);\n            }\n\n            var fieldset = tag('fieldset', fieldsetAttrs, [\n                tag('legend', legendAttrs, field.labelText(name)),\n                opt.errorAfterField ? '' : errorHTML,\n                field.widget.toHTML(name, field),\n                opt.errorAfterField ? errorHTML : ''\n            ].join(''), true);\n            wrappedContent.push(fieldset);\n        } else {\n            var fieldHTMLs = [field.labelHTML(name, field.id), field.widget.toHTML(name, field)];\n            if (opt.labelAfterField) {\n                fieldHTMLs.reverse();\n            }\n            if (opt.errorAfterField) {\n                fieldHTMLs.push(errorHTML);\n            } else {\n                fieldHTMLs.unshift(errorHTML);\n            }\n            wrappedContent = wrappedContent.concat(fieldHTMLs);\n        }\n        return tag(tagName, { classes: field.classes() }, wrappedContent.join(''), true);\n    };\n};\nexports.div = wrapWith('div');\nexports.p = wrapWith('p');\nexports.li = wrapWith('li');\n\nexports.table = function (name, field, options) {\n    var opt = options || {};\n\n    var th = tag('th', {}, field.labelHTML(name, field.id), true);\n\n    var tdContent = field.widget.toHTML(name, field);\n\n    if (!opt.hideError) {\n        var errorHTML = field.errorHTML();\n        if (opt.errorAfterField) {\n            tdContent += errorHTML;\n        } else {\n            tdContent = errorHTML + tdContent;\n        }\n    }\n\n    var td = tag('td', {}, tdContent, true);\n\n    return tag('tr', { classes: field.classes() }, th + td, true);\n};\n", "'use strict';\n\nvar htmlEscape = require('./htmlEscape');\nvar is = require('is');\nvar keys = require('object-keys');\n\n// generates a string for common HTML tag attributes\nvar attrs = function attrs(a) {\n    if (typeof a.id === 'boolean') {\n        a.id = a.id ? 'id_' + a.name : null;\n    }\n    if (is.array(a.classes) && a.classes.length > 0) {\n        a['class'] = htmlEscape(a.classes.join(' '));\n    }\n    a.classes = null;\n    var pairs = [];\n    keys(a).forEach(function (field) {\n        var value = a[field];\n        if (typeof value === 'boolean') {\n            value = value ? field : null;\n        } else if (typeof value === 'number' && isNaN(value)) {\n            value = null;\n        }\n        if (typeof value !== 'undefined' && value !== null) {\n            pairs.push(htmlEscape(field) + '=\"' + htmlEscape(value) + '\"');\n        }\n    });\n    return pairs.length > 0 ? ' ' + pairs.join(' ') : '';\n};\n\nvar selfClosingTags = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nvar isSelfClosing = function (tagName) {\n    return Object.prototype.hasOwnProperty.call(selfClosingTags, tagName);\n};\n\nvar tag = function tag(tagName, attrsMap, content, contentIsEscaped) {\n    var safeTagName = htmlEscape(tagName);\n    var attrsHTML = !is.array(attrsMap) ? attrs(attrsMap) : attrsMap.reduce(function (html, map) {\n        return html + attrs(map);\n    }, '');\n    var safeContent = contentIsEscaped ? content : htmlEscape(content);\n    return '<' + safeTagName + attrsHTML + (isSelfClosing(safeTagName) ? ' />' : '>' + safeContent + '</' + safeTagName + '>');\n};\n\ntag.attrs = attrs;\n\nmodule.exports = tag;\n", "'use strict';\n\nvar is = require('is');\nvar keys = require('object-keys');\nvar tag = require('./tag');\n\nvar dataRegExp = /^data-[a-z]+([-][a-z]+)*$/;\nvar ariaRegExp = /^aria-[a-z]+$/;\nvar legalAttrs = ['autocomplete', 'autocorrect', 'autofocus', 'autosuggest', 'checked', 'dirname', 'disabled', 'tabindex', 'list', 'max', 'maxlength', 'min', 'novalidate', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step'];\nvar ignoreAttrs = ['id', 'name', 'class', 'classes', 'type', 'value', 'multiple'];\nvar getUserAttrs = function (opt) {\n    return keys(opt).reduce(function (attrs, k) {\n        if ((ignoreAttrs.indexOf(k) === -1 && legalAttrs.indexOf(k) > -1) || dataRegExp.test(k) || ariaRegExp.test(k)) {\n            attrs[k] = opt[k];\n        }\n        return attrs;\n    }, {});\n};\n\n// used to generate different input elements varying only by type attribute\nvar input = function (type) {\n    return function (opts) {\n        var opt = opts || {};\n        var userAttrs = getUserAttrs(opt);\n        var w = {\n            classes: opt.classes,\n            type: type,\n            formatValue: function (value) {\n                return (value || value === 0) ? value : null;\n            }\n        };\n        w.toHTML = function (name, field) {\n            var f = field || {};\n            var attrs = {\n                type: type,\n                name: name,\n                id: f.id === false ? false : (f.id || true),\n                classes: w.classes,\n                value: w.formatValue(f.value)\n            };\n            return tag('input', [attrs, userAttrs, w.attrs || {}]);\n        };\n        return w;\n    };\n};\n\nvar choiceValueEquals = function (value1, value2) {\n    return !is.array(value1) && !is.array(value2) && String(value1) === String(value2);\n};\n\nvar isSelected = function (value, choice) {\n    return value && (is.array(value) ? value.some(choiceValueEquals.bind(null, choice)) : choiceValueEquals(value, choice));\n};\n\nvar renderChoices = function (choices, renderer) {\n    return choices.reduce(function (partialRendered, choice) {\n        var isNested = is.array(choice[1]);\n        var renderData = isNested ?\n            { isNested: true, label: choice[0], choices: choice[1] } :\n            { isNested: false, value: choice[0], label: choice[1] };\n        return partialRendered + renderer(renderData);\n    }, '');\n};\n\nvar isScalar = function (value) {\n    return !value || is.string(value) || is.number(value) || is.bool(value);\n};\n\nvar unifyChoices = function (choices, nestingLevel) {\n    if (nestingLevel < 0) {\n        throw new RangeError('choices nested too deep');\n    }\n\n    var unifyChoiceArray = function (arrayChoices, currentLevel) {\n        return arrayChoices.reduce(function (result, choice) {\n            if (!is.array(choice) || choice.length !== 2) {\n                throw new TypeError('choice must be array with two elements');\n            }\n            if (isScalar(choice[0]) && isScalar(choice[1])) {\n                result.push(choice);\n            } else if (isScalar(choice[0]) && (is.array(choice[1]) || is.object(choice[1]))) {\n                result.push([choice[0], unifyChoices(choice[1], currentLevel - 1)]);\n            } else {\n                throw new TypeError('expected primitive value as first and primitive value, object, or array as second element');\n            }\n            return result;\n        }, []);\n    };\n\n    var unifyChoiceObject = function (objectChoices, currentLevel) {\n        return keys(objectChoices).reduce(function (result, key) {\n            var label = objectChoices[key];\n            if (isScalar(label)) {\n                result.push([key, label]);\n            } else if (is.array(label) || is.object(label)) {\n                result.push([key, unifyChoices(label, currentLevel - 1)]);\n            } else {\n                throw new TypeError('expected primitive value, object, or array as object value');\n            }\n            return result;\n        }, []);\n    };\n\n    return is.array(choices) ? unifyChoiceArray(choices, nestingLevel) : unifyChoiceObject(choices, nestingLevel);\n};\n\nvar select = function (isMultiple) {\n    return function (options) {\n        var opt = options || {};\n        var w = {\n            classes: opt.classes,\n            type: isMultiple ? 'multipleSelect' : 'select'\n        };\n        var userAttrs = getUserAttrs(opt);\n        w.toHTML = function (name, field) {\n            var f = field || {};\n            var choices = unifyChoices(f.choices, 1);\n            var optionsHTML = renderChoices(choices, function render(choice) {\n                if (choice.isNested) {\n                    return tag('optgroup', { label: choice.label }, renderChoices(choice.choices, render), true);\n                } else {\n                    return tag('option', { value: choice.value, selected: !!isSelected(f.value, choice.value) }, choice.label);\n                }\n            });\n            var attrs = {\n                name: name,\n                id: f.id === false ? false : (f.id || true),\n                classes: w.classes\n            };\n            if (isMultiple) {\n                attrs.multiple = true;\n            }\n            return tag('select', [attrs, userAttrs, w.attrs || {}], optionsHTML, true);\n        };\n        return w;\n    };\n};\n\nexports.text = input('text');\nexports.email = input('email');\nexports.number = input('number');\nexports.hidden = input('hidden');\nexports.color = input('color');\nexports.tel = input('tel');\n\nvar passwordWidget = input('password');\nvar passwordFormatValue = function () { return null; };\nexports.password = function (opt) {\n    var w = passwordWidget(opt);\n    w.formatValue = passwordFormatValue;\n    return w;\n};\n\nvar dateWidget = input('date');\nexports.date = function (opt) {\n    var w = dateWidget(opt);\n    w.formatValue = function (value) {\n        if (!value) {\n            return null;\n        }\n\n        var date = is.date(value) ? value : new Date(value);\n\n        if (isNaN(date.getTime())) {\n            return null;\n        }\n\n        return date.toISOString().slice(0, 10);\n    };\n    return w;\n};\n\nexports.select = select(false);\nexports.multipleSelect = select(true);\n\nexports.checkbox = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        type: 'checkbox'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var attrs = {\n            type: 'checkbox',\n            name: name,\n            id: f.id === false ? false : (f.id || true),\n            classes: w.classes,\n            checked: !!f.value,\n            value: 'on'\n        };\n        return tag('input', [attrs, userAttrs, w.attrs || {}]);\n    };\n    return w;\n};\n\nexports.textarea = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        type: 'textarea'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var attrs = {\n            name: name,\n            id: f.id === false ? false : (f.id || true),\n            classes: w.classes,\n            rows: opt.rows || null,\n            cols: opt.cols || null\n        };\n        return tag('textarea', [attrs, userAttrs, w.attrs || {}], f.value || '');\n    };\n    return w;\n};\n\nexports.multipleCheckbox = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        labelClasses: opt.labelClasses,\n        type: 'multipleCheckbox'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var choices = unifyChoices(f.choices, 0);\n        return renderChoices(choices, function (choice) {\n            // input element\n            var id = f.id === false ? false : (f.id ? f.id + '_' + choice.value : 'id_' + name + '_' + choice.value);\n            var checked = isSelected(f.value, choice.value);\n\n            var attrs = {\n                type: 'checkbox',\n                name: name,\n                id: id,\n                classes: w.classes,\n                value: choice.value,\n                checked: !!checked\n            };\n            var inputHTML = tag('input', [attrs, userAttrs, w.attrs || {}]);\n\n            // label element\n            var labelHTML = tag('label', { 'for': id, classes: w.labelClasses }, choice.label);\n\n            return inputHTML + labelHTML;\n        });\n    };\n    return w;\n};\n\nexports.label = function (options) {\n    var opt = options || {};\n    var w = { classes: opt.classes || [] };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (forID) {\n        var attrs = {\n            'for': forID,\n            classes: w.classes\n        };\n        return tag('label', [attrs, userAttrs, w.attrs || {}], opt.content);\n    };\n    return w;\n};\n\nexports.multipleRadio = function (options) {\n    var opt = options || {};\n    var w = {\n        classes: opt.classes,\n        labelClasses: opt.labelClasses,\n        type: 'multipleRadio'\n    };\n    var userAttrs = getUserAttrs(opt);\n    w.toHTML = function (name, field) {\n        var f = field || {};\n        var choices = unifyChoices(f.choices, 0);\n        return renderChoices(choices, function (choice) {\n            // input element\n            var id = f.id === false ? false : (f.id ? f.id + '_' + choice.value : 'id_' + name + '_' + choice.value);\n            var checked = isSelected(f.value, choice.value);\n            var attrs = {\n                type: 'radio',\n                name: name,\n                id: id,\n                classes: w.classes,\n                value: choice.value,\n                checked: !!checked\n            };\n            var inputHTML = tag('input', [attrs, userAttrs, w.attrs || {}]);\n            // label element\n            var labelHTML = tag('label', { 'for': id, classes: w.labelClasses }, choice.label);\n\n            return inputHTML + labelHTML;\n        });\n    };\n    return w;\n};\n", "'use strict';\n\nvar forms = require('../lib/forms');\nvar test = require('tape');\nvar keys = require('object-keys');\n\nvar test_input = function (type) {\n    return function (t) {\n        t.equal(\n            forms.widgets[type]().toHTML('field1'),\n            '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" />'\n        );\n        var w = forms.widgets[type]({ classes: ['test1', 'test2', 'test3'] });\n        t.equal(\n            w.toHTML('field2', { id: 'form2_field2' }),\n            '<input type=\"' + type + '\" name=\"field2\" id=\"form2_field2\" class=\"test1 test2 test3\" />'\n        );\n\n        var expectedHTML = '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" value=\"some value\" />';\n        if (type === 'password') {\n            expectedHTML = '<input type=\"' + type + '\" name=\"field1\" id=\"id_field1\" />';\n        }\n        t.equal(forms.widgets[type]().toHTML('field1', { value: 'some value' }), expectedHTML);\n        t.equal(forms.widgets[type]().type, type);\n\n        var expectedValues = { password: null };\n        var expectedValue = typeof expectedValues[type] !== 'undefined' ? expectedValues[type] : 'hello';\n        t.equal(forms.widgets[type]().formatValue('hello'), expectedValue);\n\n        t.strictEqual(forms.widgets[type]().formatValue(false), null);\n        t.end();\n    };\n};\n\ntest('text', test_input('text'));\ntest('email', test_input('email'));\ntest('number', test_input('number'));\ntest('password', test_input('password'));\ntest('hidden', test_input('hidden'));\ntest('color', test_input('color'));\ntest('tel', test_input('tel'));\n\ntest('date', function (t) {\n    var w = forms.widgets.date();\n    t.equal(w.formatValue(new Date(Date.UTC(2013, 2, 1))), '2013-03-01');\n    t.equal(w.formatValue('2013-03-02'), '2013-03-02');\n    t.strictEqual(w.formatValue('invalid'), null);\n\n    t.equal(w.type, 'date');\n\n    t.equal(\n        w.toHTML('field1'),\n        '<input type=\"date\" name=\"field1\" id=\"id_field1\" />'\n    );\n\n    t.equal(\n        w.toHTML('field1', { value: '2013-03-03' }),\n        '<input type=\"date\" name=\"field1\" id=\"id_field1\" value=\"2013-03-03\" />'\n    );\n\n    t.end();\n});\n\ntest('checkbox', function (t) {\n    t.equal(\n        forms.widgets.checkbox().toHTML('field1'),\n        '<input type=\"checkbox\" name=\"field1\" id=\"id_field1\" value=\"on\" />'\n    );\n    var w = forms.widgets.checkbox({ classes: ['test1', 'test2', 'test3'] });\n    t.equal(\n        w.toHTML('field2', { id: 'form2_field2' }),\n        '<input type=\"checkbox\" name=\"field2\" id=\"form2_field2\" value=\"on\" class=\"test1 test2 test3\" />'\n    );\n    t.equal(\n        forms.widgets.checkbox().toHTML('field', { value: true }),\n        '<input type=\"checkbox\" name=\"field\" id=\"id_field\" checked=\"checked\" value=\"on\" />'\n    );\n    t.equal(\n        forms.widgets.checkbox().toHTML('field', { value: false }),\n        '<input type=\"checkbox\" name=\"field\" id=\"id_field\" value=\"on\" />'\n    );\n    t.equal(forms.widgets.checkbox().type, 'checkbox');\n    t.end();\n});\n\ntest('select', function (t) {\n    t.equal(\n        forms.widgets.select().toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    var widget = forms.widgets.select({ classes: ['one', 'two'] });\n    t.equal(\n        widget.toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            },\n            id: 'someid',\n            value: 'val2'\n        }),\n        '<select name=\"name\" id=\"someid\" class=\"one two\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\" selected=\"selected\">text2</option>' +\n        '</select>'\n    );\n    t.equal(widget.type, 'select');\n\n    t.test('throws on invalid choices', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    [['invalid'], 'text1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', { choices: ['invalid'] });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    [{ invalid: 'invalid' }, 'text1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', function () { return 'invalid'; }]\n                ]\n            });\n        });\n\n        st.end();\n    });\n\n    t.test('supports array choices', function (st) {\n        st.equal(\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', 'text1'],\n                    ['val2', 'text2'],\n                    ['text3',\n                        [\n                            ['val3', 'text4'],\n                            ['val4', 'text5'],\n                            ['val5', 'text6']\n                        ]\n                    ],\n                    ['val6', 'text7']\n                ]\n            }),\n            '<select name=\"name\" id=\"id_name\">' +\n                '<option value=\"val1\">text1</option>' +\n                '<option value=\"val2\">text2</option>' +\n                '<optgroup label=\"text3\">' +\n                    '<option value=\"val3\">text4</option>' +\n                    '<option value=\"val4\">text5</option>' +\n                    '<option value=\"val5\">text6</option>' +\n                '</optgroup>' +\n                '<option value=\"val6\">text7</option>' +\n            '</select>'\n        );\n        st.end();\n    });\n\n    t.test('throws on deeply nested choices', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['text1',\n                        [\n                            ['text2',\n                                [\n                                    ['val1', 'text3']\n                                ]\n                            ]\n                        ]\n                    ]\n                ]\n            });\n        });\n        st.end();\n    });\n\n    t.test('throws on invalid array format', function (st) {\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    []\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1']\n                ]\n            });\n        });\n\n        st['throws'](function () {\n            forms.widgets.select().toHTML('name', {\n                choices: [\n                    ['val1', 'text1', 'invalid']\n                ]\n            });\n        });\n\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        var html = widget.toHTML('name', {\n            choices: {\n                1: 'one',\n                2: 'two'\n            },\n            id: 'someid',\n            value: 2\n        });\n        var expectedHTML = '<select name=\"name\" id=\"someid\" class=\"one two\">' +\n            '<option value=\"1\">one</option>' +\n            '<option value=\"2\" selected=\"selected\">two</option>' +\n        '</select>';\n        st.equal(html, expectedHTML);\n        st.end();\n    });\n    t.end();\n});\n\ntest('textarea', function (t) {\n    t.equal(\n        forms.widgets.textarea().toHTML('name', {}),\n        '<textarea name=\"name\" id=\"id_name\"></textarea>'\n    );\n    t.equal(\n        forms.widgets.textarea({\n            classes: ['one', 'two'],\n            cols: 80,\n            placeholder: 'hi!',\n            rows: 20\n        }).toHTML('name', { id: 'someid', value: 'value' }),\n        '<textarea name=\"name\" id=\"someid\" rows=\"20\" cols=\"80\" class=\"one two\" placeholder=\"hi!\">value</textarea>'\n    );\n    t.equal(forms.widgets.textarea().type, 'textarea');\n\n    t.test('properly escapes contents', function (st) {\n        st.equal(\n            forms.widgets.textarea().toHTML('name', { value: 'Inside</textarea>Escaped the textarea!' }),\n            '<textarea name=\"name\" id=\"id_name\">Inside&lt;/textarea&gt;Escaped the textarea!</textarea>'\n       );\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('multipleCheckbox', function (t) {\n    var w = forms.widgets.multipleCheckbox();\n    t.test('basic functionality', function (st) {\n        var field = {\n            choices: {\n                one: 'Item one',\n                two: 'Item two',\n                three: 'Item three'\n            },\n            value: 'two'\n        };\n        st.equal(\n            w.toHTML('name', field),\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n            '<label for=\"id_name_one\">Item one</label>' +\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n            '<label for=\"id_name_two\">Item two</label>' +\n            '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n            '<label for=\"id_name_three\">Item three</label>'\n        );\n        st.equal(w.type, 'multipleCheckbox');\n\n        st.test('label classes', function (st2) {\n            var widget = forms.widgets.multipleCheckbox({ labelClasses: ['test1', 'test2', 'test3'] });\n            st2.equal(\n                widget.toHTML('name', field),\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n                '<label for=\"id_name_one\" class=\"test1 test2 test3\">Item one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n                '<label for=\"id_name_two\" class=\"test1 test2 test3\">Item two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n                '<label for=\"id_name_three\" class=\"test1 test2 test3\">Item three</label>'\n            );\n            st2.end();\n        });\n\n        st.end();\n    });\n\n    t.test('throws on nested choices', function (st) {\n        st['throws'](\n            function () {\n                w.toHTML('name', {\n                    choices: [\n                        ['val1', 'text1'],\n                        ['val2', 'text2'],\n                        ['text3',\n                            [\n                                ['val3', 'text4']\n                            ]\n                        ]\n                    ]\n                });\n            }\n        );\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        st.test('single bound value', function (t2) {\n            var field = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: 2\n            };\n            var html = w.toHTML('name', field);\n            var expectedHTML = '<input type=\"checkbox\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var field = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: [1, 2]\n            };\n            var html = w.toHTML('name', field);\n            var expectedHTML = '<input type=\"checkbox\" name=\"name\" id=\"id_name_1\" value=\"1\" checked=\"checked\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"checkbox\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('multipleCheckbox multiple selected', function (t) {\n    var w = forms.widgets.multipleCheckbox(),\n        field = {\n            choices: {\n                one: 'Item one',\n                two: 'Item two',\n                three: 'Item three'\n            },\n            value: ['two', 'three']\n        };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" checked=\"checked\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleCheckbox().type, 'multipleCheckbox');\n    t.end();\n});\n\ntest('multipleRadio', function (t) {\n    var w = forms.widgets.multipleRadio();\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleRadio().type, 'multipleRadio');\n\n    t.test('throw on nested choices', function (st) {\n        st['throws'](\n            function () {\n                w.toHTML('name', {\n                    choices: [\n                        ['val1', 'text1'],\n                        ['val2', 'text2'],\n                        ['text3',\n                            [\n                                ['val3', 'text4']\n                            ]\n                        ]\n                    ]\n                });\n            }\n        );\n        st.end();\n    });\n\n    t.test('stringifies values', function (st) {\n        st.test('single bound value', function (t2) {\n            var boundValueField = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: 2\n            };\n            var html = w.toHTML('name', boundValueField);\n            var expectedHTML = '<input type=\"radio\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_3\" value=\"3\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var boundValuesField = {\n                choices: { 1: 'one', 2: 'two', 3: 'three' },\n                value: [2, 3]\n            };\n            var html = w.toHTML('name', boundValuesField);\n            var expectedHTML = '<input type=\"radio\" name=\"name\" id=\"id_name_1\" value=\"1\" />' +\n                '<label for=\"id_name_1\">one</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_2\" value=\"2\" checked=\"checked\" />' +\n                '<label for=\"id_name_2\">two</label>' +\n                '<input type=\"radio\" name=\"name\" id=\"id_name_3\" value=\"3\" checked=\"checked\" />' +\n                '<label for=\"id_name_3\">three</label>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.test('label classes', function (st) {\n        var widget = forms.widgets.multipleRadio({ labelClasses: ['test1', 'test2', 'test3'] });\n        st.equal(\n            widget.toHTML('name', field),\n            '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n            '<label for=\"id_name_one\" class=\"test1 test2 test3\">Item one</label>' +\n            '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n            '<label for=\"id_name_two\" class=\"test1 test2 test3\">Item two</label>' +\n            '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" />' +\n            '<label for=\"id_name_three\" class=\"test1 test2 test3\">Item three</label>'\n        );\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('multipleRadio multiple selected', function (t) {\n    var w = forms.widgets.multipleRadio();\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: ['two', 'three']\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" checked=\"checked\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n    t.equal(forms.widgets.multipleRadio().type, 'multipleRadio');\n    t.end();\n});\n\ntest('multipleSelect', function (t) {\n    t.equal(\n        forms.widgets.multipleSelect().toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" multiple=\"multiple\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    t.equal(\n        forms.widgets.multipleSelect({ classes: ['one', 'two'] }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2',\n                val3: 'text3'\n            },\n            id: 'someid',\n            value: ['val2', 'val3']\n        }),\n        '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\" selected=\"selected\">text2</option>' +\n            '<option value=\"val3\" selected=\"selected\">text3</option>' +\n        '</select>'\n    );\n    t.equal(forms.widgets.multipleSelect().type, 'multipleSelect');\n\n    t.test('stringifies values', function (st) {\n        var widget = forms.widgets.multipleSelect({ classes: ['one', 'two'] });\n\n        st.test('single bound values', function (t2) {\n            var html = widget.toHTML('name', {\n                choices: {\n                    1: 'text1',\n                    2: 'text2',\n                    3: 'text3'\n                },\n                id: 'someid',\n                value: 2\n            });\n            var expectedHTML = '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n                '<option value=\"1\">text1</option>' +\n                '<option value=\"2\" selected=\"selected\">text2</option>' +\n                '<option value=\"3\">text3</option>' +\n            '</select>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.test('multiple bound values', function (t2) {\n            var html = widget.toHTML('name', {\n                choices: {\n                    1: 'text1',\n                    2: 'text2',\n                    3: 'text3'\n                },\n                id: 'someid',\n                value: [2, 3]\n            });\n            var expectedHTML = '<select name=\"name\" id=\"someid\" multiple=\"multiple\" class=\"one two\">' +\n                '<option value=\"1\">text1</option>' +\n                '<option value=\"2\" selected=\"selected\">text2</option>' +\n                '<option value=\"3\" selected=\"selected\">text3</option>' +\n            '</select>';\n            t2.equal(html, expectedHTML);\n            t2.end();\n        });\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('optional text input', function (t) {\n    t.equal(\n        forms.widgets.text({\n            'data-trigger': 'focus',\n            placeholder: 'Enter some comment'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" data-trigger=\"focus\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            'aria-required': 'false',\n            classes: ['one', 'two'],\n            'data-trigger': 'focus',\n            placeholder: 'Enter some comment'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" class=\"one two\" aria-required=\"false\" data-trigger=\"focus\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            placeholder: 'Enter some comment',\n            unknown: 'foo'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" placeholder=\"Enter some comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({\n            autocomplete: 'on',\n            max: 10,\n            min: 5,\n            unknown: 'foo'\n        }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" autocomplete=\"on\" max=\"10\" min=\"5\" />'\n    );\n    t.equal(\n        forms.widgets.text({ placeholder: 'Enter \"some\" comment' }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" placeholder=\"Enter &quot;some&quot; comment\" />'\n    );\n    t.equal(\n        forms.widgets.text({ tabindex: 1 }).toHTML('field1'),\n        '<input type=\"text\" name=\"field1\" id=\"id_field1\" tabindex=\"1\" />'\n    );\n    t.end();\n});\n\ntest('custom attributes', function (t) {\n    // regex tests\n    t.equal(\n        forms.widgets.text({ 'data-': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-input': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-input=\"foo\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'idata-input': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-input1': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ data_input: 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data--': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" />'\n    );\n    t.equal(\n        forms.widgets.text({ 'data-foo-bar': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"text\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-foo-bar=\"foo\" />'\n    );\n\n    // widgets not based on the \"input\" widget should support optional attributes\n    t.equal(\n        forms.widgets.textarea({ 'data-test': 'foo' }).toHTML('fieldWithAttrs'),\n        '<textarea name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" data-test=\"foo\"></textarea>'\n    );\n    t.equal(\n        forms.widgets.label({\n            content: 'Foobar',\n            'data-test': 'foo'\n        }).toHTML('fieldWithAttrs'),\n        '<label for=\"fieldWithAttrs\" data-test=\"foo\">Foobar</label>'\n    );\n    t.equal(\n        forms.widgets.checkbox({ 'data-test': 'foo' }).toHTML('fieldWithAttrs'),\n        '<input type=\"checkbox\" name=\"fieldWithAttrs\" id=\"id_fieldWithAttrs\" value=\"on\" data-test=\"foo\" />'\n    );\n    t.equal(\n        forms.widgets.select({ 'data-test': 'foo' }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" data-test=\"foo\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n    t.equal(\n        forms.widgets.multipleSelect({ 'data-test': 'foo' }).toHTML('name', {\n            choices: {\n                val1: 'text1',\n                val2: 'text2'\n            }\n        }),\n        '<select name=\"name\" id=\"id_name\" multiple=\"multiple\" data-test=\"foo\">' +\n            '<option value=\"val1\">text1</option>' +\n            '<option value=\"val2\">text2</option>' +\n        '</select>'\n    );\n\n    var w = forms.widgets.multipleCheckbox({ 'data-test': 'foo' });\n    var field = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w.toHTML('name', field),\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_one\" value=\"one\" data-test=\"foo\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" data-test=\"foo\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"checkbox\" name=\"name\" id=\"id_name_three\" value=\"three\" data-test=\"foo\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n\n    var w2 = forms.widgets.multipleRadio({ 'data-test': 'foo' });\n    var field2 = {\n        choices: {\n            one: 'Item one',\n            two: 'Item two',\n            three: 'Item three'\n        },\n        value: 'two'\n    };\n    t.equal(\n        w2.toHTML('name', field2),\n        '<input type=\"radio\" name=\"name\" id=\"id_name_one\" value=\"one\" data-test=\"foo\" />' +\n        '<label for=\"id_name_one\">Item one</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_two\" value=\"two\" checked=\"checked\" data-test=\"foo\" />' +\n        '<label for=\"id_name_two\">Item two</label>' +\n        '<input type=\"radio\" name=\"name\" id=\"id_name_three\" value=\"three\" data-test=\"foo\" />' +\n        '<label for=\"id_name_three\">Item three</label>'\n    );\n\n    t.end();\n});\n\ntest('label', function (t) {\n    t.equal(\n        forms.widgets.label({\n            classes: ['foo', 'bar', 'quux'],\n            content: 'Foobar'\n        }).toHTML('field1'),\n        '<label for=\"field1\" class=\"foo bar quux\">Foobar</label>'\n    );\n    t.equal(\n        forms.widgets.label({\n            classes: [],\n            content: 'Foobar'\n        }).toHTML('field1'),\n        '<label for=\"field1\">Foobar</label>'\n    );\n    t.end();\n});\n\ntest('dynamic widget attributes', function (t) {\n    var theKeys = keys(forms.widgets);\n    t.plan(theKeys.length);\n    var re = /autocomplete=\"no\"/;\n    theKeys.forEach(function (name) {\n        var w = forms.widgets[name]();\n        w.attrs = { autocomplete: 'no' };\n        var html = w.toHTML('test', { choices: { foo: 'bar' } });\n        t.equal(re.test(html), true);\n    });\n    t.end();\n});\n"], "filenames": [".eslintrc", "lib/render.js", "lib/tag.js", "lib/widgets.js", "test/test-widgets.js"], "buggy_code_start_loc": [16, 24, 53, 120, 258], "buggy_code_end_loc": [17, 64, 59, 134, 258], "fixing_code_start_loc": [16, 24, 53, 120, 259], "fixing_code_end_loc": [17, 64, 60, 134, 269], "type": "CWE-79", "message": "Forms is a library for easily creating HTML forms. Versions before 1.3.0 did not have proper html escaping. This means that if the application did not sanitize html on behalf of forms, use of forms may be vulnerable to cross site scripting", "other": {"cve": {"id": "CVE-2017-16015", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-04T19:29:00.977", "lastModified": "2019-10-09T23:24:36.500", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Forms is a library for easily creating HTML forms. Versions before 1.3.0 did not have proper html escaping. This means that if the application did not sanitize html on behalf of forms, use of forms may be vulnerable to cross site scripting"}, {"lang": "es", "value": "Forms es una biblioteca para crear formularios HTML f\u00e1cilmente. Las versiones anteriores a la 1.3.0 no contaban con un escapado HTML adecuado. Esto significa que, si la aplicaci\u00f3n no saneaba c\u00f3digo html en representaci\u00f3n de los formularios, su uso podr\u00eda ser vulnerable a Cross-Site Scripting (XSS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-80"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:forms_project:forms:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "10A11156-1800-4EDD-9645-CB77601B5257"}]}]}], "references": [{"url": "https://github.com/caolan/forms/commit/bc01e534a0ff863dedb2026a50bd03153bbc6a5d", "source": "support@hackerone.com", "tags": ["Patch"]}, {"url": "https://nodesecurity.io/advisories/158", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/caolan/forms/commit/bc01e534a0ff863dedb2026a50bd03153bbc6a5d"}}