{"buggy_code": ["# -*- encoding: utf-8 -*-\nlib = File.expand_path('../lib/', __FILE__)\n$:.unshift lib unless $:.include?(lib)\n\nrequire 'carrierwave/version'\n\nGem::Specification.new do |s|\n  s.name = \"carrierwave\"\n  s.version = CarrierWave::VERSION\n\n  s.authors = [\"Jonas Nicklas\"]\n  s.description = \"Upload files in your Ruby applications, map them to a range of ORMs, store them on different backends.\"\n  s.summary = \"Ruby file upload library\"\n  s.email = [\"jonas.nicklas@gmail.com\"]\n  s.extra_rdoc_files = [\"README.md\"]\n  s.files = Dir[\"{bin,lib}/**/*\", \"README.md\"]\n  s.homepage = %q{https://github.com/carrierwaveuploader/carrierwave}\n  s.rdoc_options = [\"--main\"]\n  s.require_paths = [\"lib\"]\n  s.licenses = [\"MIT\"]\n\n  s.required_ruby_version = \">= 2.2.2\"\n\n  s.add_dependency \"activesupport\", \">= 5.0.0\"\n  s.add_dependency \"activemodel\", \">= 5.0.0\"\n  s.add_dependency \"mini_mime\", \">= 0.1.3\"\n  s.add_dependency \"image_processing\", \"~> 1.1\"\n  s.add_dependency \"mimemagic\", \">= 0.3.0\"\n  s.add_dependency \"addressable\", \"~> 2.6\"\n  if RUBY_ENGINE == 'jruby'\n    s.add_development_dependency 'activerecord-jdbcpostgresql-adapter'\n  else\n    s.add_development_dependency \"pg\"\n  end\n  s.add_development_dependency \"rails\", \">= 5.0.0\"\n  s.add_development_dependency \"cucumber\", \"~> 2.3\"\n  s.add_development_dependency \"rspec\", \"~> 3.4\"\n  s.add_development_dependency \"webmock\"\n  s.add_development_dependency \"fog-aws\"\n  s.add_development_dependency \"fog-google\", \"~> 1.7\"\n  s.add_development_dependency \"fog-local\"\n  s.add_development_dependency \"fog-rackspace\"\n  s.add_development_dependency \"mini_magick\", \">= 3.6.0\"\n  if RUBY_ENGINE != 'jruby'\n    s.add_development_dependency \"rmagick\", \">= 2.16\"\n  end\n  s.add_development_dependency \"timecop\"\n  s.add_development_dependency \"generator_spec\", \">= 0.9.1\"\n  s.add_development_dependency \"pry\"\nend\n", "When /^I download the file '([^']+)'/ do |url|\n  unless ENV['REMOTE'] == 'true'\n    stub_request(:get, \"s3.amazonaws.com/Monkey/testfile.txt\").\n      to_return(body: \"S3 Remote File\", headers: { \"Content-Type\" => \"text/plain\" })\n  end\n\n  @uploader.download!(url)\nend\n", "require 'open-uri'\nrequire 'addressable'\nrequire 'carrierwave/downloader/remote_file'\n\nmodule CarrierWave\n  module Downloader\n    class Base\n      attr_reader :uploader\n\n      def initialize(uploader)\n        @uploader = uploader\n      end\n\n      ##\n      # Downloads a file from given URL and returns a RemoteFile.\n      #\n      # === Parameters\n      #\n      # [url (String)] The URL where the remote file is stored\n      # [remote_headers (Hash)] Request headers\n      #\n      def download(url, remote_headers = {})\n        headers = remote_headers.\n          reverse_merge('User-Agent' => \"CarrierWave/#{CarrierWave::VERSION}\")\n        begin\n          file = OpenURI.open_uri(process_uri(url.to_s), headers)\n        rescue StandardError => e\n          raise CarrierWave::DownloadError, \"could not download file: #{e.message}\"\n        end\n        CarrierWave::Downloader::RemoteFile.new(file)\n      end\n\n      ##\n      # Processes the given URL by parsing it, and escaping if necessary. Public to allow overriding.\n      #\n      # === Parameters\n      #\n      # [url (String)] The URL where the remote file is stored\n      #\n      def process_uri(uri)\n        uri_parts = uri.split('?')\n        encoded_uri = Addressable::URI.parse(uri_parts.shift).normalize.to_s\n        query = uri_parts.any? ? \"?#{uri_parts.join('?')}\" : ''\n        begin\n          URI.parse(\"#{encoded_uri}#{query}\")\n        rescue URI::InvalidURIError\n          URI.parse(\"#{encoded_uri}#{URI::DEFAULT_PARSER.escape(query)}\")\n        end\n      rescue URI::InvalidURIError, Addressable::URI::InvalidURIError\n        raise CarrierWave::DownloadError, \"couldn't parse URL: #{uri}\"\n      end\n    end\n  end\nend\n", "module CarrierWave\n  module Downloader\n    class RemoteFile\n      attr_reader :file\n\n      def initialize(file)\n        @file = file.is_a?(String) ? StringIO.new(file) : file\n      end\n\n      def original_filename\n        filename = filename_from_header || filename_from_uri\n        mime_type = MiniMime.lookup_by_content_type(file.content_type)\n        unless File.extname(filename).present? || mime_type.blank?\n          filename = \"#{filename}.#{mime_type.extension}\"\n        end\n        filename\n      end\n\n      def respond_to?(*args)\n        super || file.respond_to?(*args)\n      end\n\n      private\n\n      def filename_from_header\n        return nil unless file.meta.include? 'content-disposition'\n\n        match = file.meta['content-disposition'].match(/filename=(?:\"([^\"]+)\"|([^\";]+))/)\n        return nil unless match\n\n        match[1].presence || match[2].presence\n      end\n\n      def filename_from_uri\n        CGI.unescape(File.basename(file.base_uri.path))\n      end\n\n      def method_missing(*args, &block)\n        file.send(*args, &block)\n      end\n    end\n  end\nend\n\n", "require 'spec_helper'\n\ndescribe CarrierWave::Downloader::Base do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:file) { File.read(file_path(\"test.jpg\")) }\n  let(:filename) { \"test.jpg\" }\n  let(:uri) { \"http://www.example.com/#{CGI.escape(filename)}\" }\n\n  subject { CarrierWave::Downloader::Base.new(uploader) }\n\n  context \"with unicode sybmols in URL\" do\n    let(:filename) { \"\u044e\u043d\u0438\u043a\u043e\u0434.jpg\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    let(:remote_file) { subject.download(uri) }\n\n    it \"downloads a file\" do\n      expect(remote_file).to be_an_instance_of(CarrierWave::Downloader::RemoteFile)\n    end\n\n    it \"sets the filename to the file's decoded sanitized filename\" do\n      expect(remote_file.original_filename).to eq(\"#{filename}\")\n    end\n  end\n\n  context \"with a URL with internationalized domain name\" do\n    let(:uri) { \"http://\u30c9\u30e1\u30a4\u30f3\u540d\u4f8b.jp/#{CGI.escape(filename)}\" }\n    before do\n      stub_request(:get, 'http://xn--eckwd4c7cu47r2wf.jp/test.jpg').to_return(body: file)\n    end\n\n    it \"converts to Punycode URI\" do\n      expect(subject.process_uri(uri).to_s).to eq 'http://xn--eckwd4c7cu47r2wf.jp/test.jpg'\n    end\n\n    it \"downloads a file\" do\n      expect(subject.download(uri).file.read).to eq file\n    end\n  end\n\n  context \"with equal and colons in the query path\" do\n    let(:query) { 'test=query&with=equal&before=colon:param' }\n    let(:uri) { \"https://example.com/#{filename}?#{query}\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    it \"leaves colon in resulting URI\" do\n      expect(subject.process_uri(uri).query).to eq query\n    end\n\n    it \"downloads a file\" do\n      expect(subject.download(uri).file.read).to eq file\n    end\n  end\n\n  context 'with request headers' do\n    let(:authentication_headers) do\n      {\n        'Accept'=>'*/*',\n        'Accept-Encoding'=>'gzip;q=1.0,deflate;q=0.6,identity;q=0.3',\n        'User-Agent'=>\"CarrierWave/#{CarrierWave::VERSION}\",\n        'Authorization'=>'Bearer QWE'\n      }\n    end\n    before do\n      stub_request(:get, uri).\n        with(:headers => authentication_headers).\n        to_return(body: file)\n    end\n\n    it 'pass custom headers to request' do\n      expect(subject.download(uri, { 'Authorization' => 'Bearer QWE' }).file.read).to eq file\n    end\n  end\n\n  it \"raises an error when trying to download a local file\" do\n    expect { subject.download('/etc/passwd') }.to raise_error(CarrierWave::DownloadError)\n  end\n\n  context \"with missing file\" do\n    before do\n      stub_request(:get, uri).to_return(status: 404)\n    end\n\n    it \"raises an error when trying to download a missing file\" do\n      expect{ subject.download(uri) }.to raise_error(CarrierWave::DownloadError)\n    end\n\n    it \"doesn't obscure original exception message\" do\n      expect { subject.download(uri) }.to raise_error(CarrierWave::DownloadError, /could not download file: 404/)\n    end\n  end\n\n  context \"with a url that contains space\" do\n    let(:filename) { \"my test.jpg\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    it \"accepts spaces in the url\" do\n      expect(subject.download(uri).original_filename).to eq filename\n    end\n  end\n\n  context \"with redirects\" do\n    let(:another_uri) { 'http://example.com/redirected.jpg' }\n    before do\n      stub_request(:get, uri).\n        to_return(status: 301, body: \"Redirecting\", headers: { \"Location\" => another_uri })\n      stub_request(:get, another_uri).to_return(body: file)\n    end\n\n    it \"retrieves redirected file\" do\n      expect(subject.download(uri).file.read).to eq file\n    end\n\n    it \"extracts filename from the url after redirection\" do\n      expect(subject.download(uri).original_filename).to eq 'redirected.jpg'\n    end\n  end\n\n  describe '#process_uri' do\n    it \"parses but not escape already escaped uris\" do\n      uri = 'http://example.com/%5B.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"parses but not escape uris with query-string-only characters not needing escaping\" do\n      uri = 'http://example.com/?foo[]=bar'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"escapes and parse unescaped uris\" do\n      uri = 'http://example.com/ %[].jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%20%25%5B%5D.jpg')\n    end\n\n    it \"parses but not escape uris with query-string characters representing urls not needing escaping \" do\n      uri = 'http://example.com/?src0=https%3A%2F%2Fi.vimeocdn.com%2Fvideo%2F1234_1280x720.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"escapes and parse brackets in uri paths without harming the query string\" do\n      uri = 'http://example.com/].jpg?test[]'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%5D.jpg?test[]')\n    end\n\n    it \"escapes and parse unescaped characters in path\" do\n      uri = 'http://example.com/\u3042\u3042\u3042.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%E3%81%82%E3%81%82%E3%81%82.jpg')\n    end\n\n    it \"escapes and parse unescaped characters in query string\" do\n      uri = 'http://example.com/?q=\u3042\u3042\u3042'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/?q=%E3%81%82%E3%81%82%E3%81%82')\n    end\n\n    it \"throws an exception on bad uris\" do\n      uri = '~http:'\n      expect { subject.process_uri(uri) }.to raise_error(CarrierWave::DownloadError)\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Downloader::RemoteFile do\n  let(:file) do\n    File.open(file_path(\"test.jpg\")).tap { |f| OpenURI::Meta.init(f) }\n  end\n  subject { CarrierWave::Downloader::RemoteFile.new(file) }\n\n  before do\n    subject.base_uri = URI.parse 'http://example.com/test'\n    subject.meta_add_field 'content-type', 'image/jpeg'\n  end\n\n  it 'sets file extension based on content-type if missing' do\n    expect(subject.original_filename).to eq \"test.jpeg\"\n  end\n\n  describe 'with content-disposition' do\n    before do\n      subject.meta_add_field 'content-disposition', content_disposition\n    end\n\n    context 'when filename is quoted' do\n      let(:content_disposition){ 'filename=\"another_test.jpg\"' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is quoted and empty' do\n      let(:content_disposition){ 'filename=\"\"' }\n\n      it \"sets file extension based on content-type if missing\" do\n        expect(subject.original_filename).to eq 'test.jpeg'\n      end\n    end\n\n    context 'when filename is not quoted and empty' do\n      let(:content_disposition){ 'filename=' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'test.jpeg'\n      end\n    end\n\n    context 'when filename is not quoted' do\n      let(:content_disposition){ 'filename=another_test.jpg' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is not quoted and terminated by semicolon' do\n      let(:content_disposition){ 'filename=another_test.jpg; size=1234' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is quoted and contains a semicolon' do\n      let(:content_disposition){ 'filename=\"another;_test.jpg\"; size=1234' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another;_test.jpg'\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Mount do\n  let(:klass) { Class.new.send(:extend, CarrierWave::Mount) }\n  let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n  let(:instance) { klass.new }\n  let(:test_file_name) { 'test.jpg' }\n  let(:new_file_name) { 'new.jpeg' }\n  let(:test_file_stub) { stub_file(test_file_name) }\n  let(:new_file_stub) { stub_file(new_file_name) }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '.mount_uploaders' do\n    before { klass.mount_uploaders(:images, uploader) }\n\n    describe \"super behavior\" do\n      before do\n        klass.class_eval do\n          def images_uploader\n            super\n          end\n\n          def images=(val)\n            super\n          end\n        end\n\n        instance.images = [stub_file(test_file_name)]\n      end\n\n      it \"maintains the ability to super\" do\n        expect(instance.images[0]).to be_an_instance_of(uploader)\n      end\n    end\n\n    describe \"upload inheritance\" do\n      let(:subclass) { Class.new(klass) }\n      let(:subclass_instance) { subclass.new }\n\n      before { subclass_instance.images = [test_file_stub, new_file_stub] }\n\n      it \"inherits uploaders to subclasses\" do\n        expect(subclass_instance.images[0]).to be_an_instance_of(uploader)\n        expect(subclass_instance.images[1]).to be_an_instance_of(uploader)\n      end\n    end\n\n    describe \"upload marshalling\" do\n      before do\n        Object.const_set(\"MyClass#{klass.object_id}\".gsub('-', '_'), klass)\n        Object.const_set(\"Uploader#{uploader.object_id}\".gsub('-', '_'), uploader)\n\n        uploader.class_eval do\n          def rotate\n          end\n        end\n\n        uploader.version :thumb do\n          process :rotate\n        end\n\n        instance.images = [test_file_stub]\n      end\n\n      it \"allows marshalling uploaders and versions\" do\n        expect { Marshal.dump(instance.images) }.not_to raise_error\n      end\n    end\n\n    describe \"behavior of subclassed uploaders\" do\n      let(:uploader_1) do\n        Class.new(CarrierWave::Uploader::Base) do\n          [:rotate, :compress, :encrypt, :shrink].each { |m| define_method(m) {} }\n        end.tap do |uploader|\n          uploader.process :rotate\n          uploader.version :thumb do\n            process :compress\n          end\n        end\n      end\n\n      let(:uploader_2) do\n        Class.new(uploader_1).tap do |uploader|\n          uploader.process :shrink\n          uploader.version :secret do\n            process :encrypt\n          end\n        end\n      end\n\n      let(:instance) do\n        klass.new.tap do |instance|\n          instance.images1 = [test_file_stub]\n          instance.images2 = [test_file_stub]\n        end\n      end\n\n      before do\n        klass.mount_uploaders(:images1, uploader_1)\n        klass.mount_uploaders(:images2, uploader_2)\n      end\n\n      context \"defined version inheritance works\" do\n        it { expect(instance.images1[0]).to respond_to(:thumb) }\n\n        it { expect(instance.images2[0]).to respond_to(:thumb) }\n      end\n\n      context \"version inheritance defined in subclasses works\" do\n        it { expect(instance.images1[0]).not_to respond_to(:secret) }\n\n        it { expect(instance.images2[0]).to respond_to(:secret) }\n      end\n\n      context \"defined processors inheritance works\" do\n        it { expect(uploader_1.processors).to eq([[:rotate, [], nil]]) }\n\n        it { expect(uploader_2.processors).to eq([[:rotate, [], nil], [:shrink, [], nil]]) }\n\n        it { expect(uploader_1.versions[:thumb].processors).to eq([[:compress, [], nil]]) }\n\n        it { expect(uploader_2.versions[:thumb].processors).to eq([[:compress, [], nil]]) }\n\n        it { expect(uploader_2.versions[:secret].processors).to eq([[:encrypt, [], nil]]) }\n      end\n    end\n\n    describe '#images' do\n      context \"return an empty array when nothing has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return(nil)\n        end\n\n        it { expect(instance.images).to eq [] }\n      end\n\n      context \"returns an empty array when an empty string has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return('')\n        end\n\n        it { expect(instance.images).to eq [] }\n      end\n\n      context \"retrieves a file from the storage if a value is stored in the database\" do\n        subject(:images) { instance.images }\n\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).at_least(:once).and_return([test_file_name, new_file_name])\n        end\n\n        it { expect(images[0]).to be_an_instance_of(uploader) }\n        it { expect(images[1]).to be_an_instance_of(uploader) }\n      end\n\n      context \"sets the path to the store dir\" do\n        subject(:image) { instance.images.first }\n\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).at_least(:once).and_return(test_file_name)\n        end\n\n        it { expect(image.current_path).to eq(public_path(\"uploads/#{test_file_name}\")) }\n      end\n    end\n\n    describe '#images=' do\n      let(:old_image_stub) { stub_file('old.jpeg') }\n      let(:text_file_stub) { stub_file('bork.txt') }\n\n      context \"caching images\" do\n        before do\n          instance.images = [test_file_stub, old_image_stub]\n        end\n\n        it { expect(instance.images[0]).to be_an_instance_of(uploader) }\n\n        it { expect(instance.images[1]).to be_an_instance_of(uploader) }\n\n        it \"copies files into the cache directory\" do\n          expect(instance.images[0].current_path).to match(/^#{public_path('uploads/tmp')}/)\n        end\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n          expect(instance.images[1].staged).to be true\n        end\n      end\n\n      it \"does nothing when nil is assigned\" do\n        expect(instance).not_to receive(:write_uploader)\n        instance.images = nil\n      end\n\n      it \"does nothing when an empty string is assigned\" do\n        expect(instance).not_to receive(:write_uploader)\n\n        instance.images = [test_file_stub]\n      end\n\n      context \"if the images fails a white list integrity check\" do\n        before do\n          uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which passed the check\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"if the images fails a black list integrity check\" do\n        before do\n          uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which passed the check\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"if the images fails to be processed\" do\n        before do\n          uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\" if file.path =~ /test\\.jpg/\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which was processed successfully\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"with cached files\" do\n        before do\n          instance.images = [text_file_stub, test_file_stub]\n        end\n        let(:cache_names) { instance.images.map(&:cache_name) }\n        let(:identifiers) { instance.images.map(&:identifier) }\n\n        it \"accepts cache name and retrieves from cache\" do\n          instance.images = [cache_names[1]]\n          expect(instance.images.map { |u| u.file.filename }).to eq ['test.jpg']\n        end\n      end\n\n      describe \"with stored files\" do\n        before do\n          instance.images = [text_file_stub, test_file_stub]\n          instance.store_images!\n        end\n        let(:identifiers) { instance.images.map(&:identifier) }\n\n        it \"writes over a previously stored file\" do\n          instance.images = [old_image_stub]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['old.jpeg']\n        end\n\n        it \"preserves existing image of given identifier\" do\n          instance.images = [identifiers[0], old_image_stub]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt','old.jpeg']\n        end\n\n        it \"reorders existing image\" do\n          instance.images = identifiers.reverse\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg', 'bork.txt']\n        end\n\n        it \"allows uploading and reordering at once\" do\n          instance.images = [identifiers[1], old_image_stub, identifiers[0]]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg', 'old.jpeg', 'bork.txt']\n        end\n\n        it \"allows repeating the same identifiers\" do\n          instance.images = ['bork.txt', 'test.jpg', 'bork.txt']\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt', 'test.jpg', 'bork.txt']\n        end\n\n        it \"removes image which is unused\" do\n          @image_paths = instance.images.map(&:current_path)\n          instance.images = [identifiers[0]]\n          instance.store_images!\n          instance.send(:_mounter, :images).remove_previous(identifiers, identifiers[0..0])\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n          expect(File.exist?(@image_paths[0])).to be_truthy\n          expect(File.exist?(@image_paths[1])).to be_falsey\n        end\n\n        it \"ignores unknown identifier\" do\n          instance.images = ['unknown.txt']\n          expect { instance.store_images! }.not_to raise_error\n          expect(instance.images.map(&:identifier)).to be_empty\n        end\n\n        it \"allows deleting all files\" do\n          instance.images = []\n          expect(instance.images.map(&:identifier)).to be_empty\n        end\n\n        it \"allows assignment of uploader instances\" do\n          instance.images = [instance.images[0]]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n    end\n\n    describe '#images?' do\n      subject { instance.images? }\n\n      context \"false when nothing has been assigned\" do\n        before { instance.images = nil }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"false when an empty string has been assigned\" do\n        before { instance.images = '' }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"true when a file has been cached\" do\n        before { instance.images = [test_file_stub] }\n\n        it { is_expected.to be_truthy }\n      end\n    end\n\n    describe '#images_urls' do\n      subject(:images_urls) { instance.images_urls }\n\n      describe \"returns nil when nothing has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return(nil)\n        end\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"should return nil when an empty string has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return('')\n        end\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"gets the url from a retrieved file\" do\n        before do\n          allow(instance).to receive(:read_uploader).at_least(:once).with(:images).and_return(test_file_name)\n        end\n\n        it { expect(images_urls.first).to eq(\"/uploads/#{test_file_name}\") }\n      end\n\n      describe \"gets the url from a cached file\" do\n        before { instance.images = [test_file_stub] }\n\n        it { expect(images_urls[0]).to match(%r{uploads/tmp/[\\d\\-]+/test.jpg}) }\n      end\n\n      describe \"gets the url from a cached file's version\" do\n        before do\n          uploader.version(:thumb)\n          instance.images = [test_file_stub]\n        end\n\n        it { expect(instance.images_urls(:thumb)[0]).to match(%r{uploads/tmp/[\\d\\-]+/thumb_test.jpg}) }\n      end\n    end\n\n    describe '#images_cache' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"when nothing has been assigned\" do\n        it { expect(instance.images_cache).to be_nil }\n      end\n\n      context \"when a file has been stored\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n        end\n\n        it { expect(instance.images_cache).to be_nil }\n      end\n\n      context \"when a file has been cached\" do\n        let(:json_response) { JSON.parse(instance.images_cache) }\n\n        before do\n          instance.images = [test_file_stub, stub_file('old.jpeg')]\n        end\n\n        it { expect(json_response[0]).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/test\\.jpg$)) }\n\n        it { expect(json_response[1]).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/old\\.jpeg$)) }\n      end\n    end\n\n    describe '#images_cache=' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n        CarrierWave::SanitizedFile.new(test_file_stub).copy_to(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      context \"does nothing when nil is assigned\" do\n        before { instance.images_cache = nil }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"does nothing when an empty string is assigned\" do\n        before { instance.images_cache = '' }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"retrieve from cache when a cache name is assigned\" do\n        before { instance.images_cache = ['1369894322-123-0123-1234/test.jpg'].to_json }\n\n        it { expect(instance.images[0].current_path).to eq(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg')) }\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n        end\n      end\n\n      context \"writes over a previously stored file\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n          instance.images_cache = ['1369894322-123-0123-1234/monkey.jpg'].to_json\n        end\n\n        it { expect(instance.images[0].current_path).to match(/monkey.jpg$/) }\n      end\n\n      context \"doesn't write over a previously assigned file\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.images_cache = ['1369894322-123-0123-1234/monkey.jpg'].to_json\n        end\n\n        it { expect(instance.images[0].current_path).to match(/test.jpg$/) }\n      end\n\n      context \"when valid and invalid cache names are assigned\" do\n        before { instance.images_cache = ['1369894322-123-0123-1234/test.jpg', 'invalid'].to_json }\n\n        it \"retrieves valid file only from cache\" do\n          expect(instance.images.map(&:cache_name)).to eq(['1369894322-123-0123-1234/test.jpg'])\n        end\n      end\n\n      context \"when an empty string is assigned\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n          instance.images_cache = [''].to_json\n        end\n\n        it \"does not write over a previously stored file\" do\n          expect(instance.images[0].current_path).to match(/test.jpg$/)\n        end\n      end\n    end\n\n    describe \"#remote_images_urls\" do\n      subject { instance.remote_images_urls }\n\n      before { stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub)) }\n\n      context \"returns nil\" do\n        it { is_expected.to be_nil }\n      end\n\n      context \"returns previously cached URL\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/test.jpg\"] }\n\n        it { is_expected.to eq([\"http://www.example.com/test.jpg\"]) }\n      end\n    end\n\n    describe \"#remote_images_urls=\" do\n      subject(:images) { instance.images }\n\n      before do\n        stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n        stub_request(:get, \"http://www.example.com/test.txt\").to_return(status: 404)\n        instance.remote_images_urls = remote_images_url\n      end\n\n      context \"does nothing when nil is assigned\" do\n        let(:remote_images_url) { nil }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"does nothing when an empty string is assigned\" do\n        let(:remote_images_url) { '' }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"retrieves from cache when a cache name is assigned\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        it { is_expected.to match(/test.jpg$/) }\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n        end\n      end\n\n      context \"writes over a previously stored file\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.store_images!\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it { is_expected.to match(/test.jpg$/) }\n      end\n\n      context \"does not write over a previously assigned file\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it { is_expected.to match(/portrait.jpg$/) }\n      end\n\n      context \"when an empty string is assigned\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.store_images!\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it \"does not write over a previously stored file\" do\n          is_expected.to match(/portrait.jpg$/)\n        end\n      end\n\n      context \"if a file fails to be downloaded\" do\n        let(:remote_images_url) { [\"http://www.example.com/test.txt\", \"http://www.example.com/test.jpg\"] }\n\n        it \"keeps files which was downloaded successfully\" do\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg']\n        end\n      end\n    end\n\n    describe '#store_images!' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"does nothing when no file has been uploaded\" do\n        before { instance.store_images! }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"stores an assigned file\" do\n        let(:images) { [test_file_stub] }\n\n        before do\n          instance.images = images\n          instance.store_images!\n        end\n\n        it { expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\")) }\n\n        it \"marks the uploader as unstaged\" do\n          expect(instance.images[0].staged).to be false\n        end\n      end\n    end\n\n    describe '#remove_images!' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"does nothing when no file has been uploaded\" do\n        before { instance.remove_images! }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"removes an uploaded file\" do\n        before do\n          instance.images = [test_file_stub]\n          @image_path = instance.images[0].current_path\n          instance.remove_images!\n        end\n\n        it { expect(instance.images).to be_empty }\n\n        it { expect(File.exist?(@image_path)).to be_falsey }\n      end\n    end\n\n    describe '#remove_images' do\n      before { instance.remove_images = true }\n\n      it \"stores a value\" do\n        expect(instance.remove_images).to be_truthy\n      end\n    end\n\n    describe '#remove_images?' do\n      subject { instance.remove_images? }\n\n      let(:remove_images) { true }\n\n      before { instance.remove_images = remove_images }\n\n      it \"when value is true\" do\n        is_expected.to be_truthy\n      end\n\n      context \"when value is false\" do\n        let(:remove_images) { false }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is ''\" do\n        let(:remove_images) { '' }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is 0\" do\n        let(:remove_images) { \"0\" }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is false\" do\n        let(:remove_images) { 'false' }\n\n        it { is_expected.to be_falsey }\n      end\n    end\n\n    describe '#images_integrity_errors' do\n      subject(:images_integrity_errors) { instance.images_integrity_errors }\n\n      describe \"default behaviour\" do\n        it { is_expected.to be_empty }\n      end\n\n      context \"when a file is cached\" do\n        before { instance.images = test_file_stub }\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"when an integrity check fails\" do\n        before do\n          uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        context \"when file is cached\" do\n          before { instance.images = [test_file_stub] }\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n\n        context \"when file was downloaded\" do\n          before do\n            stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n            instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n\n        context \"when file is assigned and remote_iamges_url is blank\" do\n          before do\n            instance.images = [test_file_stub]\n            instance.remote_images_urls = \"\"\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n      end\n    end\n\n    describe '#images_processing_errors' do\n      subject(:images_processing_errors) { instance.images_processing_errors }\n\n      describe \"default behavior\" do\n        it { is_expected.to be_empty }\n      end\n\n      context \"when file is cached\" do\n        before { instance.images = [test_file_stub] }\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"when an processing error occurs\" do\n        before do\n          uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n        end\n\n        context \"when file is cached\" do\n          before { instance.images = [test_file_stub] }\n\n          it { is_expected.to include(a_kind_of(CarrierWave::ProcessingError)) }\n        end\n\n        context \"when file was downloaded\" do\n          before do\n            stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n            instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::ProcessingError)) }\n        end\n      end\n    end\n\n    describe '#images_download_errors' do\n      subject(:images_download_errors) { instance.images_download_errors }\n\n      before do\n        stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n        stub_request(:get, \"www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      describe \"default behaviour\" do\n        it { expect(instance.images_download_errors).to be_empty }\n      end\n\n      context \"when file download was successful\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"] }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"when file couldn't be found\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/missing.jpg\"] }\n\n        it { is_expected.to include(a_kind_of(CarrierWave::DownloadError)) }\n      end\n    end\n\n    describe '#write_images_identifier' do\n      after { instance.write_images_identifier }\n\n      it \"writes to the column\" do\n        expect(instance).to receive(:write_uploader).with(:images, [test_file_name]).at_least(:once)\n        instance.images = [test_file_stub]\n        instance.write_images_identifier\n      end\n\n      context \"when remove_images is true\" do\n        before do\n          instance.images = [test_file_name]\n          instance.store_images!\n          instance.remove_images = true\n        end\n\n        it \"clears existing uploaders\" do\n          expect(instance.images).to be_empty\n        end\n\n        it \"removes from the column\" do\n          expect(instance).to receive(:write_uploader).with(:images, nil)\n        end\n      end\n    end\n\n    describe '#images_identifiers' do\n      it \"returns the identifier from the mounted column\" do\n        expect(instance).to receive(:read_uploader).with(:images).and_return(test_file_name)\n        expect(instance.images_identifiers).to eq([test_file_name])\n      end\n    end\n  end\n\n  describe '#mount_uploaders without an uploader' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images)\n      end\n    end\n\n    let(:instance) { klass.new }\n\n    describe '#images' do\n      before do\n        allow(instance).to receive(:read_uploader).and_return(test_file_name)\n      end\n\n      it \"returns an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(instance.images[0]).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"sets the path to the store dir\" do\n        expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\"))\n      end\n    end\n  end\n\n  describe '#mount_uploaders with a block' do\n    describe 'and no uploader given' do\n      subject(:last_image) { instance.images[0] }\n\n      let(:klass) do\n        Class.new do |k|\n          k.send(:extend, CarrierWave::Mount)\n          k.mount_uploaders(:images) do\n            def monkey\n              'blah'\n            end\n          end\n        end\n      end\n\n      before { instance.images = [test_file_stub] }\n\n      it \"returns an instance of a subclass of CarrierWave::Uploader::Base\" do\n        is_expected.to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"applies any custom modifications\" do\n        expect(last_image.monkey).to eq(\"blah\")\n      end\n    end\n\n    describe 'and an uploader given' do\n      let!(:uploader) do\n        Class.new(CarrierWave::Uploader::Base).tap do |u|\n          u.version :thumb do\n            version :mini\n            version :maxi\n          end\n        end\n      end\n\n      let(:klass) do\n        Class.new.tap do |k|\n          k.send(:extend, CarrierWave::Mount)\n          k.mount_uploaders(:images, uploader) do\n            def fish\n              'blub'\n            end\n          end\n        end\n      end\n\n      let(:first_image) { instance.images[0] }\n\n      before { instance.images = [test_file_stub] }\n\n      it \"returns an instance of the uploader specified\" do\n        expect(first_image).to be_a_kind_of(uploader)\n      end\n\n      it \"applies any custom modifications to the instance\" do\n        expect(first_image.fish).to eq(\"blub\")\n      end\n\n      it \"applies any custom modifications to all defined versions\" do\n        expect(first_image.thumb.fish).to eq(\"blub\")\n        expect(first_image.thumb.mini.fish).to eq(\"blub\")\n        expect(first_image.thumb.maxi.fish).to eq(\"blub\")\n      end\n\n      it \"applies any custom modifications to the uploader class\" do\n        expect(uploader.new).not_to respond_to(:fish)\n      end\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_integrity_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, :ignore_integrity_errors => false)\n      end\n    end\n\n    let(:uploader) do\n      Class.new(CarrierWave::Uploader::Base).tap do |u|\n        u.class_eval do\n          def extension_whitelist\n            %w(txt)\n          end\n        end\n      end\n    end\n\n    context \"when a cached image fails an integrity check\" do\n      it { expect(running { instance.images = [test_file_stub] }).to raise_error(CarrierWave::IntegrityError) }\n    end\n\n    context \"when a downloaded image fails an integity check\" do\n      before do\n        stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: test_file_stub)\n      end\n\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::IntegrityError) }\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_processing_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, :ignore_processing_errors => false)\n      end\n    end\n\n    let(:uploader) do\n      Class.new(CarrierWave::Uploader::Base).tap do |u|\n        u.class_eval do\n          process :monkey\n          def monkey\n            raise CarrierWave::ProcessingError, \"Ohh noez!\"\n          end\n        end\n      end\n    end\n\n    context \"when a cached image fails an integrity check\" do\n      it { expect(running { instance.images = [test_file_stub] }).to raise_error(CarrierWave::ProcessingError) }\n    end\n\n    context \"when a downloaded image fails an integity check\" do\n      before do\n        stub_request(:get, \"www.example.com/#{test_file_name}\").to_return(body: test_file_stub)\n      end\n\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::ProcessingError) }\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_download_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, ignore_download_errors: false)\n      end\n    end\n\n    let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n\n    before do\n      uploader.class_eval do\n        def download! uri, headers = {}\n          raise CarrierWave::DownloadError\n        end\n      end\n    end\n\n    context \"when the image fail to be processed\" do\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::DownloadError) }\n    end\n  end\n\n  describe '#mount_uploaders with :mount_on => :monkey' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, mount_on: :monkey)\n      end\n    end\n\n    let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n\n    describe '#images' do\n      context \"when a value is store in the database\" do\n        it \"retrieves a file from the storage\" do\n          expect(instance).to receive(:read_uploader).at_least(:once).with(:monkey).and_return([test_file_name])\n          expect(instance.images[0]).to be_an_instance_of(uploader)\n          expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\"))\n        end\n      end\n    end\n\n    describe '#write_images_identifier' do\n      it \"writes to the given column\" do\n        expect(instance).to receive(:write_uploader).with(:monkey, [test_file_name])\n        instance.images = [test_file_stub]\n        instance.write_images_identifier\n      end\n\n      it \"removes from the given column when remove_images is true\" do\n        instance.images = [test_file_stub]\n        instance.store_images!\n        instance.remove_images = true\n        expect(instance).to receive(:write_uploader).with(:monkey, nil)\n        instance.write_images_identifier\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Mount do\n\n  after do\n    FileUtils.rm_rf(public_path)\n  end\n\n  describe '.mount_uploader' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader)\n      @instance = @class.new\n    end\n\n    it \"should maintain the ability to super\" do\n      @class.class_eval do\n        def image_uploader\n          super\n        end\n\n        def image=(val)\n          super\n        end\n      end\n\n      @instance.image = stub_file('test.jpg')\n      expect(@instance.image).to be_an_instance_of(@uploader)\n    end\n\n    it \"should inherit uploaders to subclasses\" do\n      @subclass = Class.new(@class)\n      @subclass_instance = @subclass.new\n      @subclass_instance.image = stub_file('test.jpg')\n      expect(@subclass_instance.image).to be_an_instance_of(@uploader)\n    end\n\n    it \"should allow marshalling uploaders and versions\" do\n      Object.const_set(\"MyClass#{@class.object_id}\".tr('-', '_'), @class)\n      Object.const_set(\"Uploader#{@uploader.object_id}\".tr('-', '_'), @uploader)\n      @uploader.class_eval do\n        def rotate\n        end\n      end\n      @uploader.version :thumb do\n        process :rotate\n      end\n      @instance.image = stub_file('test.jpg')\n      expect { Marshal.dump @instance.image }.not_to raise_error\n    end\n\n    describe \"expected behavior with subclassed uploaders\" do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @uploader1 = Class.new(CarrierWave::Uploader::Base)\n        @uploader1.process :rotate\n        @uploader1.version :thumb do\n          process :compress\n        end\n        @uploader2 = Class.new(@uploader1)\n        @uploader2.process :shrink\n        @uploader2.version :secret do\n          process :encrypt\n        end\n        @class.mount_uploader(:image1, @uploader1)\n        @class.mount_uploader(:image2, @uploader2)\n        @instance = @class.new\n      end\n\n      it \"should inherit defined versions\" do\n        expect(@instance.image1).to respond_to(:thumb)\n        expect(@instance.image2).to respond_to(:thumb)\n      end\n\n      it \"should not inherit versions defined in subclasses\" do\n        expect(@instance.image1).not_to respond_to(:secret)\n        expect(@instance.image2).to respond_to(:secret)\n      end\n\n      it \"should inherit defined processors properly\" do\n        expect(@uploader1.processors).to eq([[:rotate, [], nil]])\n        expect(@uploader2.processors).to eq([[:rotate, [], nil], [:shrink, [], nil]])\n        expect(@uploader1.versions[:thumb].processors).to eq([[:compress, [], nil]])\n        expect(@uploader2.versions[:thumb].processors).to eq([[:compress, [], nil]])\n        expect(@uploader2.versions[:secret].processors).to eq([[:encrypt, [], nil]])\n      end\n    end\n\n    describe '#image' do\n\n      it \"should return a blank uploader when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should return the same object every time when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image.object_id).to eq @instance.image.object_id\n      end\n\n      it \"should return a blank uploader when an empty string has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return('')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        expect(@instance).to receive(:read_uploader).with(:image).at_least(:once).and_return('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        expect(@instance).to receive(:read_uploader).with(:image).at_least(:once).and_return('test.jpg')\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n\n    end\n\n    describe '#image=' do\n\n      it \"should cache a file\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should copy a file into into the cache directory\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image.current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        expect(@instance).not_to receive(:write_uploader)\n        @instance.image = nil\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        expect(@instance).not_to receive(:write_uploader)\n        @instance.image = stub_file('test.jpg')\n      end\n\n      it \"should fail silently if the image fails a white list integrity check\" do\n        @uploader.class_eval do\n          def extension_whitelist\n            %w(txt)\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should fail silently if the image fails a black list integrity check\" do\n        @uploader.class_eval do\n          def extension_blacklist\n            %w(jpg)\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should fail silently if the image fails to be processed\" do\n        @uploader.class_eval do\n          process :monkey\n          def monkey\n            raise CarrierWave::ProcessingError, \"Ohh noez!\"\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n      end\n\n    end\n\n    describe '#image?' do\n\n      it \"should be false when nothing has been assigned\" do\n        @instance.image = nil\n        expect(@instance.image?).to be_falsey\n      end\n\n      it \"should be false when an empty string has been assigned\" do\n        @instance.image = ''\n        expect(@instance.image?).to be_falsey\n      end\n\n      it \"should be true when a file has been cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image?).to be_truthy\n      end\n\n    end\n\n    describe '#image_url' do\n\n      it \"should return nil when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image_url).to be_nil\n      end\n\n      it \"should return fallback url when nothing has been assigned\" do\n        @uploader.class_eval do\n          def default_url\n            \"foo/bar.jpg\"\n          end\n        end\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image_url).to eq(\"foo/bar.jpg\")\n      end\n\n      it \"should return nil when an empty string has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return('')\n        expect(@instance.image_url).to be_nil\n      end\n\n      it \"should get the url from a retrieved file\" do\n        expect(@instance).to receive(:read_uploader).at_least(:once).with(:image).and_return('test.jpg')\n        expect(@instance.image_url).to eq('/uploads/test.jpg')\n      end\n\n      it \"should get the url from a cached file\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_url).to match(%r{uploads/tmp/[\\d\\-]+/test.jpg})\n      end\n\n      it \"should get the url from a cached file's version\" do\n        @uploader.version(:thumb)\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_url(:thumb)).to match(%r{uploads/tmp/[\\d\\-]+/thumb_test.jpg})\n      end\n\n    end\n\n    describe '#image_cache' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should return nil when nothing has been assigned\" do\n        expect(@instance.image_cache).to be_nil\n      end\n\n      it \"should be nil when a file has been stored\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image.store!\n        expect(@instance.image_cache).to be_nil\n      end\n\n      it \"should be the cache name when a file has been cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_cache).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/test\\.jpg$))\n      end\n\n    end\n\n    describe '#image_cache=' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n        CarrierWave::SanitizedFile.new(file_path('test.jpg')).copy_to(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        @instance.image_cache = nil\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        @instance.image_cache = ''\n        expect(@instance.image).to be_blank\n      end\n\n      it \"retrieve from cache when a cache name is assigned\" do\n        @instance.image_cache = '1369894322-123-0123-1234/test.jpg'\n        expect(@instance.image.current_path).to eq(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      it \"should not write over a previously assigned file\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image_cache = '1369894322-123-0123-1234/monkey.jpg'\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n\n      it \"should not clear a previously stored file when an empty string is assigned\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image.store!\n        @instance.image_cache = ''\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n    end\n\n    describe \"#remote_image_url\" do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      it \"returns nil\" do\n        expect(@instance.remote_image_url).to be_nil\n      end\n\n      it \"returns previously cached URL\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.remote_image_url).to eq(\"http://www.example.com/test.jpg\")\n      end\n\n      describe \"URI with unicode symbols\" do\n        before do\n          stub_request(\n            :get,\n            \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          ).to_return(body: File.read(file_path(\"\u044e\u043d\u0438\u043a\u043e\u0434.jpg\")))\n        end\n\n        it \"works correctly\" do\n          @instance.remote_image_url = \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          expect(@instance.remote_image_url).to eq(\"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\")\n        end\n\n        it \"decodes it correctly\" do\n          @instance.remote_image_url = \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          expect(@instance.image.current_path).to match(/\u044e\u043d\u0438\u043a\u043e\u0434.jpg$/)\n        end\n      end\n    end\n\n    describe \"#remote_image_url=\" do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      it \"does nothing when nil is assigned\" do\n        @instance.remote_image_url = nil\n\n        expect(@instance.image).to be_blank\n      end\n\n      it \"does nothing when an empty string is assigned\" do\n        @instance.remote_image_url = \"\"\n\n        expect(@instance.image).to be_blank\n      end\n\n      it \"retrieves from cache when a cache name is assigned\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n\n      it \"does not write over a previously assigned file\" do\n        @instance.image = stub_file(\"portrait.jpg\")\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.image.current_path).to match(/portrait.jpg$/)\n      end\n\n      it \"does not clear a previously stored file when an empty string is assigned\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        @instance.image.store!\n        @instance.remote_image_url = \"\"\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n    end\n\n    describe '#store_image!' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should do nothing when no file has been uploaded\" do\n        @instance.store_image!\n        expect(@instance.image).to be_blank\n      end\n\n      it \"store an assigned file\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n    end\n\n    describe '#remove_image!' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should do nothing when no file has been uploaded\" do\n        @instance.remove_image!\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should remove an uploaded file\" do\n        @instance.image = stub_file('test.jpg')\n        path = @instance.image.current_path\n        @instance.remove_image!\n        expect(@instance.image).to be_blank\n        expect(File.exist?(path)).to be_falsey\n      end\n    end\n\n    describe '#remove_image' do\n\n      it \"should store a value\" do\n        @instance.remove_image = true\n        expect(@instance.remove_image).to be_truthy\n      end\n\n    end\n\n    describe '#remove_image?' do\n\n      it \"should be true when the value is truthy\" do\n        @instance.remove_image = true\n        expect(@instance.remove_image?).to be_truthy\n      end\n\n      it \"should be false when the value is falsey\" do\n        @instance.remove_image = false\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is ''\" do\n        @instance.remove_image = ''\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is '0'\" do\n        @instance.remove_image = '0'\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is 'false'\" do\n        @instance.remove_image = 'false'\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n    end\n\n    describe '#image_integrity_error' do\n\n      it \"should be nil by default\" do\n        expect(@instance.image_integrity_error).to be_nil\n      end\n\n      it \"should be nil after a file is cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_integrity_error).to be_nil\n      end\n\n      describe \"when an integrity check fails\" do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should be an error instance if file was cached\" do\n          @instance.image = stub_file('test.jpg')\n          e = @instance.image_integrity_error\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n\n        it \"should be an error instance if file was downloaded\" do\n          stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n          @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n          e = @instance.image_integrity_error\n\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n\n        it \"should be an error instance when image file is assigned and remote_image_url is blank\" do\n          @instance.image = stub_file('test.jpg')\n          @instance.remote_image_url = \"\"\n          e = @instance.image_integrity_error\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n      end\n    end\n\n    describe '#image_processing_error' do\n\n      it \"should be nil by default\" do\n        expect(@instance.image_processing_error).to be_nil\n      end\n\n      it \"should be nil after a file is cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_processing_error).to be_nil\n      end\n\n      describe \"when an processing error occurs\" do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n        end\n\n        it \"should be an error instance if file was cached\" do\n          @instance.image = stub_file('test.jpg')\n          expect(@instance.image_processing_error).to be_an_instance_of(CarrierWave::ProcessingError)\n        end\n\n        it \"should be an error instance if file was downloaded\" do\n          stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n          @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n          expect(@instance.image_processing_error).to be_an_instance_of(CarrierWave::ProcessingError)\n        end\n      end\n    end\n\n    describe '#image_download_error' do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n        stub_request(:get, \"www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      it \"should be nil by default\" do\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be nil if file download was successful\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be an error instance if file could not be found\" do\n        @instance.remote_image_url = \"http://www.example.com/missing.jpg\"\n        expect(@instance.image_download_error).to be_an_instance_of(CarrierWave::DownloadError)\n      end\n    end\n\n    describe '#image_download_error' do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n        stub_request(:get, \"www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      it \"should be nil by default\" do\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be nil if file download was successful\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be an error instance if file could not be found\" do\n        @instance.remote_image_url = \"http://www.example.com/missing.jpg\"\n        expect(@instance.image_download_error).to be_an_instance_of(CarrierWave::DownloadError)\n      end\n    end\n\n    describe '#write_image_identifier' do\n      it \"should write to the column\" do\n        expect(@instance).to receive(:write_uploader).with(:image, \"test.jpg\")\n        @instance.image = stub_file('test.jpg')\n        @instance.write_image_identifier\n      end\n\n      it \"should remove from the column when remove_image is true\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        @instance.remove_image = true\n        expect(@instance).to receive(:write_uploader).with(:image, nil)\n        @instance.write_image_identifier\n        expect(@instance.image).to be_blank\n      end\n    end\n\n    describe '#image_identifier' do\n      it \"should return the identifier from the mounted column\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(\"test.jpg\")\n        expect(@instance.image_identifier).to eq('test.jpg')\n      end\n    end\n\n  end\n\n  describe '#mount_uploader without an uploader' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n      @class.mount_uploader(:image)\n      @instance = @class.new\n    end\n\n    describe '#image' do\n\n      before do\n        allow(@instance).to receive(:read_uploader).and_return('test.jpg')\n      end\n\n      it \"should return an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(@instance.image).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"should set the path to the store dir\" do\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n\n    end\n\n  end\n\n  describe '#mount_uploader with a block' do\n    describe 'and no uploader given' do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @class.mount_uploader(:image) do\n          def monkey\n            'blah'\n          end\n        end\n        @instance = @class.new\n      end\n\n      it \"should return an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(@instance.image).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"should apply any custom modifications\" do\n        expect(@instance.image.monkey).to eq(\"blah\")\n      end\n    end\n\n    describe 'and an uploader given' do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @uploader = Class.new(CarrierWave::Uploader::Base)\n        @uploader.version :thumb do\n          version :mini\n          version :maxi\n        end\n        @class.mount_uploader(:image, @uploader) do\n          def fish\n            'blub'\n          end\n        end\n        @instance = @class.new\n      end\n\n      it \"should return an instance of the uploader specified\" do\n        expect(@instance.image).to be_a_kind_of(@uploader)\n      end\n\n      it \"should apply any custom modifications to the instance\" do\n        expect(@instance.image.fish).to eq(\"blub\")\n      end\n\n      it \"should apply any custom modifications to all defined versions\" do\n        expect(@instance.image.thumb.fish).to eq(\"blub\")\n        expect(@instance.image.thumb.mini.fish).to eq(\"blub\")\n        expect(@instance.image.thumb.maxi.fish).to eq(\"blub\")\n      end\n\n      it \"should not apply any custom modifications to the uploader class\" do\n        expect(@uploader.new).not_to respond_to(:fish)\n      end\n    end\n  end\n\n  describe '#mount_uploader with :ignore_integrity_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_integrity_errors => false)\n      @instance = @class.new\n\n      @uploader.class_eval do\n        def extension_whitelist\n          %w(txt)\n        end\n      end\n    end\n\n    it \"should raise an error if the image fails an integrity check when cached\" do\n      expect(running {\n        @instance.image = stub_file('test.jpg')\n      }).to raise_error(CarrierWave::IntegrityError)\n    end\n\n    it \"should raise an error if the image fails an integrity check when downloaded\" do\n      stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::IntegrityError)\n    end\n  end\n\n  describe '#mount_uploader with :ignore_processing_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_processing_errors => false)\n      @instance = @class.new\n\n      @uploader.class_eval do\n        process :monkey\n        def monkey\n          raise CarrierWave::ProcessingError, \"Ohh noez!\"\n        end\n      end\n    end\n\n    it \"should raise an error if the image fails to be processed when cached\" do\n      expect(running {\n        @instance.image = stub_file('test.jpg')\n      }).to raise_error(CarrierWave::ProcessingError)\n    end\n\n    it \"should raise an error if the image fails to be processed when downloaded\" do\n      stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::ProcessingError)\n    end\n\n  end\n\n  describe '#mount_uploader with :ignore_download_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_download_errors => false)\n      @instance = @class.new\n    end\n\n    it \"should raise an error if the image fails to be processed\" do\n      @uploader.class_eval do\n        def download! uri, headers = {}\n          raise CarrierWave::DownloadError\n        end\n      end\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::DownloadError)\n    end\n\n  end\n\n  describe '#mount_uploader with :mount_on => :monkey' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :mount_on => :monkey)\n      @instance = @class.new\n    end\n\n    describe '#image' do\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        expect(@instance).to receive(:read_uploader).at_least(:once).with(:monkey).and_return('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n    end\n\n    describe '#write_image_identifier' do\n      it \"should write to the given column\" do\n        expect(@instance).to receive(:write_uploader).with(:monkey, \"test.jpg\")\n        @instance.image = stub_file('test.jpg')\n        @instance.write_image_identifier\n      end\n\n      it \"should remove from the given column when remove_image is true\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        @instance.remove_image = true\n        expect(@instance).to receive(:write_uploader).with(:monkey, nil)\n        @instance.write_image_identifier\n      end\n    end\n\n  end\n\nend\n", "require 'spec_helper'\nrequire 'support/activerecord'\n\ndef create_table(name)\n  ActiveRecord::Base.connection.create_table(name, force: true) do |t|\n    t.column :image, :string\n    t.column :images, :json\n    t.column :textfile, :string\n    t.column :textfiles, :json\n    t.column :foo, :string\n  end\nend\n\ndef drop_table(name)\n  ActiveRecord::Base.connection.drop_table(name)\nend\n\ndef reset_class(class_name)\n  Object.send(:remove_const, class_name) rescue nil\n  Object.const_set(class_name, Class.new(ActiveRecord::Base))\nend\n\ndescribe CarrierWave::ActiveRecord do\n  before(:all) { create_table(\"events\") }\n  after(:all) { drop_table(\"events\") }\n\n  before do\n    @uploader = Class.new(CarrierWave::Uploader::Base)\n    reset_class(\"Event\")\n    @event = Event.new\n  end\n\n  after do\n    Event.delete_all\n  end\n\n  describe '#mount_uploader' do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    describe '#image' do\n\n      it \"should return blank uploader when nothing has been assigned\" do\n        expect(@event.image).to be_blank\n      end\n\n      it \"should return blank uploader when an empty string has been assigned\" do\n        @event[:image] = ''\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_blank\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should return valid JSON when to_json is called when image is nil\" do\n        expect(@event[:image]).to be_nil\n        hash = JSON.parse(@event.to_json)\n        expect(hash.keys).to include(\"image\")\n        expect(hash[\"image\"].keys).to include(\"url\")\n        expect(hash[\"image\"][\"url\"]).to be_nil\n      end\n\n      it \"should return valid JSON when to_json is called when image is present\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse(@event.to_json)[\"image\"]).to eq({\"url\" => \"/uploads/test.jpeg\"})\n      end\n\n      it \"should return valid JSON when to_json is called on a collection containing uploader from a model\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse({:data => @event.image}.to_json)).to eq({\"data\"=>{\"url\"=>\"/uploads/test.jpeg\"}})\n      end\n\n      it \"should return valid XML when to_xml is called when image is nil\" do\n        hash = Hash.from_xml(@event.to_xml)[\"event\"]\n\n        expect(@event[:image]).to be_nil\n        expect(hash.keys).to include(\"image\")\n        expect(hash[\"image\"].keys).to include(\"url\")\n        expect(hash[\"image\"][\"url\"]).to be_nil\n      end\n\n      it \"should return valid XML when to_xml is called when image is present\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml)[\"event\"][\"image\"]).to eq({\"url\" => \"/uploads/test.jpeg\"})\n      end\n\n      it \"should respect options[:only] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:except] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:except => [:id, :image, :images, :textfiles, :foo])).to eq({\"textfile\" => nil})\n      end\n      it \"should respect both options[:only] and options[:except] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo], :except => [:id])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:only] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"should respect options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(except: [:image]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"should respect both options[:only] and options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo], except: [:id]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"resets cached value on record reload\" do\n        @event.image = CarrierWave::SanitizedFile.new(stub_file('new.jpeg', 'image/jpeg'))\n        @event.save!\n\n        expect(@event.reload.image).to be_present\n\n        Event.find(@event.id).update_column(:image, nil)\n\n        expect(@event.reload.image).to be_blank\n      end\n\n      context \"with CarrierWave::MiniMagick\" do\n        before(:each) do\n          @uploader.send(:include, CarrierWave::MiniMagick)\n        end\n\n        it \"has width and height\" do\n          @event.image = stub_file('landscape.jpg')\n          expect(@event.image.width).to eq 640\n          expect(@event.image.height).to eq 480\n        end\n      end\n\n      context \"with CarrierWave::RMagick\", :rmagick => true do\n        before(:each) do\n          @uploader.send(:include, CarrierWave::RMagick)\n        end\n\n        it \"has width and height\" do\n          @event.image = stub_file('landscape.jpg')\n          expect(@event.image.width).to eq 640\n          expect(@event.image.height).to eq 480\n        end\n      end\n    end\n\n    describe '#image=' do\n\n      it \"should cache a file\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should write nothing to the database, to prevent overriden filenames to fail because of unassigned attributes\" do\n        expect(@event[:image]).to be_nil\n      end\n\n      it \"should copy a file into the cache directory\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.image.current_path).to match(%r(^#{public_path('uploads/tmp')}))\n      end\n\n      context \"when empty string is assigned\" do\n        it \"does nothing when\" do\n          @event.image = ''\n          expect(@event.image).to be_blank\n        end\n\n        context \"and the previous value was an empty string\" do\n          before do\n            @event.image = \"\"\n            @event.save\n          end\n\n          it \"does not write to dirty changes\" do\n            @event.image = ''\n            expect(@event.changes.keys).not_to include(\"image\")\n          end\n        end\n\n      end\n\n      context \"when nil is assigned\" do\n        it \"does nothing\" do\n          @event.image = nil\n          expect(@event.image).to be_blank\n        end\n\n        context \"and the previous value was nil\" do\n          before do\n            @event.image = nil\n            @event.save\n          end\n\n          it \"does not write to dirty changes\" do\n            @event.image = nil\n            expect(@event.changes.keys).not_to include(\"image\")\n          end\n        end\n      end\n\n\n      context 'when validating white list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_whitelist_error => \"Het opladen van %{extension} bestanden is niet toe gestaan. Geaccepteerde types: %{allowed_types}\"\n            }\n          }) do\n            # Assigning image triggers check_whitelist! and thus should be inside change_locale_and_store_translations\n            @event.image = stub_file('test.jpg')\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:image]).to eq (['Het opladen van \"jpg\" bestanden is niet toe gestaan. Geaccepteerde types: txt'])\n          end\n        end\n      end\n\n      context 'when validating black list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_blacklist_error => \"You are not allowed to upload %{extension} files, prohibited types: %{prohibited_types}\"\n            }\n          }) do\n            # Assigning image triggers check_blacklist! and thus should be inside change_locale_and_store_translations\n            @event.image = stub_file('test.jpg')\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:image]).to eq(['You are not allowed to upload \"jpg\" files, prohibited types: jpg'])\n          end\n        end\n      end\n\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError\n            end\n          end\n          @event.image = stub_file('test.jpg')\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for processing errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['failed to be processed'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagem.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['falha ao processar imagem.'])\n          end\n        end\n      end\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n          @event.image = stub_file('test.jpg')\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use the error's messages for processing errors with messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['Ohh noez!'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagem.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['Ohh noez!'])\n          end\n        end\n      end\n    end\n\n    describe '#save' do\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_blank\n      end\n\n      it \"should copy the file to the upload directory when a file has been assigned\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should do nothing when a validation fails\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.image = stub_file('test.jpeg')\n\n        expect(@event.save).to be_falsey\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should assign the filename to the database\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        @event.reload\n        expect(@event[:image]).to eq('test.jpeg')\n        expect(@event.image_identifier).to eq('test.jpeg')\n      end\n\n      it \"should preserve the image when nothing is assigned\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n\n        @event = Event.find(@event.id)\n        @event.foo = \"bar\"\n\n        expect(@event.save).to be_truthy\n        expect(@event[:image]).to eq('test.jpeg')\n        expect(@event.image_identifier).to eq('test.jpeg')\n      end\n\n      it \"should remove the image if remove_image? returns true\" do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n        @event.remove_image = true\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_blank\n        expect(@event[:image]).to eq(nil)\n        expect(@event.image_identifier).to eq(nil)\n      end\n\n      it \"should mark image as changed when saving a new image\" do\n        expect(@event.image_changed?).to be_falsey\n        @event.image = stub_file(\"test.jpeg\")\n        expect(@event.image_changed?).to be_truthy\n        @event.save\n        @event.reload\n        expect(@event.image_changed?).to be_falsey\n        @event.image = stub_file(\"test.jpg\")\n        expect(@event.image_changed?).to be_truthy\n        expect(@event.changed_for_autosave?).to be_truthy\n      end\n    end\n\n    describe \"image?\" do\n      it \"returns true when the file is cached\" do\n        @event.image = stub_file('test.jpg')\n\n        expect(@event.image?).to be_truthy\n      end\n\n      it \"returns false when the file is removed\" do\n        @event.remove_image!\n        @event.save!\n\n        expect(@event.image?).to be_falsey\n      end\n\n      it \"returns true when the file is stored\" do\n        @event.image = stub_file('test.jpg')\n        @event.save!\n\n        expect(@event.image?).to be_truthy\n      end\n\n      it \"returns true when a file is removed and stored again\" do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n        @event.remove_image!\n        @event.save!\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n\n        expect(@event.image?).to be_truthy\n      end\n    end\n\n    describe \"remove_image!\" do\n      before do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n      end\n\n      it \"should clear the serialization column\" do\n        @event.remove_image!\n\n        expect(@event.attributes['image']).to be_blank\n      end\n\n      it \"resets remove_image? to false\" do\n        @event.remove_image = true\n\n        expect {\n          @event.remove_image!\n        }.to change {\n          @event.remove_image?\n        }.from(true).to(false)\n      end\n    end\n\n    describe \"remove_image=\" do\n      it \"should mark the image as changed if changed\" do\n        expect(@event.image_changed?).to be_falsey\n        expect(@event.remove_image).to be_nil\n        @event.remove_image = \"1\"\n        expect(@event.image_changed?).to be_truthy\n      end\n    end\n\n    describe \"#remote_image_url=\" do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      # FIXME ideally image_changed? and remote_image_url_changed? would return true\n      it \"should mark image as changed when setting remote_image_url\" do\n        expect(@event.image_changed?).to be_falsey\n        @event.remote_image_url = 'http://www.example.com/test.jpg'\n        expect(@event.image_changed?).to be_truthy\n        @event.save!\n        @event.reload\n        expect(@event.image_changed?).to be_falsey\n      end\n\n      context 'when validating download' do\n        before do\n          @uploader.class_eval do\n            def download! file, headers = {}\n              raise CarrierWave::DownloadError\n            end\n          end\n          @event.remote_image_url = 'http://www.example.com/missing.jpg'\n        end\n\n        it \"should make the record invalid when a download error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for download errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['could not be downloaded'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_download_error => 'n\u00e3o pode ser descarregado'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['n\u00e3o pode ser descarregado'])\n          end\n        end\n      end\n\n    end\n\n    describe '#destroy' do\n\n      it \"should not raise an error with a custom filename\" do\n        @uploader.class_eval do\n          def filename\n            \"page.jpeg\"\n          end\n        end\n\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect {\n          @event.destroy\n        }.to_not raise_error\n      end\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        @event.destroy\n      end\n\n      it \"should remove the file from the filesystem\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n        @event.destroy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n\n    end\n\n    describe 'with overriddent filename' do\n\n      describe '#save' do\n\n        before do\n          @uploader.class_eval do\n            def filename\n              model.name + File.extname(super)\n            end\n          end\n          allow(@event).to receive(:name).and_return('jonas')\n        end\n\n        it \"should copy the file to the upload directory when a file has been assigned\" do\n          @event.image = stub_file('test.jpeg')\n          expect(@event.save).to be_truthy\n          expect(@event.image).to be_an_instance_of(@uploader)\n          expect(@event.image.current_path).to eq(public_path('uploads/jonas.jpeg'))\n        end\n\n        it \"should assign an overridden filename to the database\" do\n          @event.image = stub_file('test.jpeg')\n          expect(@event.save).to be_truthy\n          @event.reload\n          expect(@event[:image]).to eq('jonas.jpeg')\n        end\n\n      end\n\n    end\n\n    describe 'with validates_presence_of' do\n\n      before do\n        Event.validates_presence_of :image\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has not been cached\" do\n        expect(@event).to_not be_valid\n      end\n\n    end\n\n    describe 'with validates_size_of' do\n\n      before do\n        Event.validates_size_of :image, maximum: 40\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached that matches the size criteria\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has been cached that does not match the size criteria\" do\n        @event.image = stub_file('bork.txt')\n        expect(@event).to_not be_valid\n      end\n\n    end\n  end\n\n  describe '#mount_uploader with mount_on' do\n    describe '#avatar=' do\n      it \"should cache a file\" do\n        reset_class(\"Event\")\n        Event.mount_uploader(:avatar, @uploader, mount_on: :image)\n        @event = Event.new\n        @event.avatar = stub_file('test.jpeg')\n        @event.save\n        @event.reload\n\n        expect(@event.avatar).to be_an_instance_of(@uploader)\n        expect(@event.image).to eq('test.jpeg')\n      end\n\n    end\n  end\n\n  describe '#mount_uploader removing old files' do\n    before do\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    describe 'normally' do\n      it \"should remove old file if old file had a different path\" do\n        @event.image = stub_file('new.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      end\n\n      it \"should not remove old file if old file had a different path but config is false\" do\n        @uploader.remove_previously_stored_files_after_update = false\n        @event.image = stub_file('new.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if old file had the same path\" do\n        @event.image = stub_file('old.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if validations fail on save\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.image = stub_file('new.jpeg')\n\n        expect(@event.save).to be_falsey\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should only delete the file once when the file is removed\" do\n        @event.remove_image = true\n        expect_any_instance_of(CarrierWave::SanitizedFile).to receive(:delete).exactly(1).times\n        expect(@event.save).to be_truthy\n      end\n    end\n\n    describe 'with an overriden filename' do\n      before do\n        @uploader.class_eval do\n          def filename\n            model.foo + File.extname(super)\n          end\n        end\n\n        @event.image = stub_file('old.jpeg')\n        @event.foo = 'test'\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n        expect(@event.image.read).to eq('this is stuff')\n      end\n\n      it \"should not remove file if old file had the same dynamic path\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n      end\n\n      it \"should remove old file if old file had a different dynamic path\" do\n        @event.foo = \"new\"\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n    end\n  end\n\n  describe '#mount_uploader removing old files with versions' do\n    before do\n      @uploader.version :thumb\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.image = stub_file('new.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.image = stub_file('old.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    it 'should not remove old file if transaction is rollback' do\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n        raise ActiveRecord::Rollback\n      end\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe \"#mount_uploader into transaction\" do\n    before do\n      @uploader.version :thumb\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should not store file during rollback\" do\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n\n        raise ActiveRecord::Rollback\n      end\n\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_falsey\n    end\n\n    it \"should not change file during rollback\" do\n      @event.image = stub_file('old.jpeg')\n      @event.save\n\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n\n        raise ActiveRecord::Rollback\n      end\n\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploader removing old files with multiple uploaders' do\n    before do\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n      @uploader1 = Class.new(CarrierWave::Uploader::Base)\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      Event.mount_uploader(:textfile, @uploader1)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n      @event.textfile = stub_file('old.txt')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file1 and file2 if old file1 and file2 had a different paths\" do\n      @event.image = stub_file('new.jpeg')\n      @event.textfile = stub_file('new.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/new.txt'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_falsey\n    end\n\n    it \"should remove old file1 but not file2 if old file1 had a different path but old file2 has the same path\" do\n      @event.image = stub_file('new.jpeg')\n      @event.textfile = stub_file('old.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    it \"should not remove file1 or file2 if file1 and file2 have the same paths\" do\n      @event.image = stub_file('old.jpeg')\n      @event.textfile = stub_file('old.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploader removing old files with with mount_on' do\n    before do\n      reset_class(\"Event\")\n      Event.mount_uploader(:avatar, @uploader, mount_on: :image)\n      @event = Event.new\n      @event.avatar = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.avatar = stub_file('new.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.avatar = stub_file('old.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders' do\n    before do\n      Event.mount_uploaders(:images, @uploader)\n    end\n\n    describe '#images' do\n\n      it \"should return blank uploader when nothing has been assigned\" do\n        expect(@event.images).to be_empty\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should return valid JSON when to_json is called when images is nil\" do\n        expect(@event[:images]).to be_nil\n        hash = JSON.parse(@event.to_json)\n        expect(hash.keys).to include(\"images\")\n        expect(hash[\"images\"]).to be_empty\n      end\n\n      it \"should return valid JSON when to_json is called when images is present\" do\n        @event[:images] = ['test.jpeg', 'old.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse(@event.to_json)[\"images\"]).to eq([{\"url\" => \"/uploads/test.jpeg\"}, {\"url\" => \"/uploads/old.jpeg\"}])\n      end\n\n      it \"should return valid JSON when to_json is called on a collection containing uploader from a model\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse({:data => @event.images}.to_json)).to eq({\"data\"=>[{\"url\"=>\"/uploads/test.jpeg\"}]})\n      end\n\n      it \"should return valid XML when to_xml is called when images is nil\" do\n        hash = Hash.from_xml(@event.to_xml)[\"event\"]\n\n        expect(@event[:images]).to be_nil\n        expect(hash.keys).to include(\"images\")\n        expect(hash[\"images\"]).to be_empty\n      end\n\n      it \"should return valid XML when to_xml is called when images is present\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml)[\"event\"][\"images\"]).to eq([{\"url\" => \"/uploads/test.jpeg\"}])\n      end\n\n      it \"should respect options[:only] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:except] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:except => [:id, :image, :images, :textfile, :foo])).to eq({\"textfiles\" => nil})\n      end\n      it \"should respect both options[:only] and options[:except] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo], :except => [:id])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:only] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo]))[\"event\"][\"images\"]).to be_nil\n      end\n\n      it \"should respect options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(except: [:images]))[\"event\"][\"images\"]).to be_nil\n      end\n\n      it \"should respect both options[:only] and options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo], except: [:id]))[\"event\"][\"images\"]).to be_nil\n      end\n    end\n\n    describe '#images=' do\n\n      it \"should cache a file\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n      end\n\n      it \"should write nothing to the database, to prevent overriden filenames to fail because of unassigned attributes\" do\n        expect(@event[:images]).to be_nil\n      end\n\n      it \"should copy a file into into the cache directory\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.images[0].current_path).to match(%r(^#{public_path('uploads/tmp')}))\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        @event.images = nil\n        expect(@event.images).to be_empty\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        @event.images = ''\n        expect(@event.images).to be_empty\n      end\n\n      context 'when validating white list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_whitelist_error => \"Het opladen van %{extension} bestanden is niet toe gestaan. Geaccepteerde types: %{allowed_types}\"\n            }\n          }) do\n            # Assigning images triggers check_whitelist! and thus should be inside change_locale_and_store_translations\n            @event.images = [stub_file('test.jpg')]\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:images]).to eq (['Het opladen van \"jpg\" bestanden is niet toe gestaan. Geaccepteerde types: txt'])\n          end\n        end\n      end\n\n      context 'when validating black list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_blacklist_error => \"You are not allowed to upload %{extension} files, prohibited types: %{prohibited_types}\"\n            }\n          }) do\n            # Assigning images triggers check_blacklist! and thus should be inside change_locale_and_store_translations\n            @event.images = [stub_file('test.jpg')]\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:images]).to eq(['You are not allowed to upload \"jpg\" files, prohibited types: jpg'])\n          end\n        end\n      end\n\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError\n            end\n          end\n          @event.images = [stub_file('test.jpg')]\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for processing errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['failed to be processed'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagesm.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['falha ao processar imagesm.'])\n          end\n        end\n      end\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n          @event.images = [stub_file('test.jpg')]\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use the error's messages for processing errors with messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['Ohh noez!'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagesm.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['Ohh noez!'])\n          end\n        end\n      end\n    end\n\n    describe '#save' do\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        expect(@event.images).to be_empty\n      end\n\n      it \"should copy the file to the upload directory when a file has been assigned\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should do nothing when a validation fails\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.images = [stub_file('test.jpeg')]\n\n        expect(@event.save).to be_falsey\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should assign the filename to the database\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        @event.reload\n        expect(@event[:images]).to eq(['test.jpeg'])\n        expect(@event.images_identifiers[0]).to eq('test.jpeg')\n      end\n\n      it \"should preserve the images when nothing is assigned\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n\n        @event = Event.find(@event.id)\n        @event.foo = \"bar\"\n\n        expect(@event.save).to be_truthy\n        expect(@event[:images]).to eq(['test.jpeg'])\n        expect(@event.images_identifiers[0]).to eq('test.jpeg')\n      end\n\n      it \"should remove the images if remove_images? returns true\" do\n        @event.images = [stub_file('test.jpeg')]\n        @event.save!\n        @event.remove_images = true\n        @event.save!\n        @event.reload\n        expect(@event.images).to be_empty\n        expect(@event[:images]).to eq(nil)\n        expect(@event.images_identifiers[0]).to eq(nil)\n      end\n\n      it \"should mark images as changed when saving a new images\" do\n        expect(@event.images_changed?).to be_falsey\n        @event.images = [stub_file(\"test.jpeg\")]\n        expect(@event.images_changed?).to be_truthy\n        @event.save\n        @event.reload\n        expect(@event.images_changed?).to be_falsey\n        @event.images = [stub_file(\"test.jpg\")]\n        expect(@event.images_changed?).to be_truthy\n        expect(@event.changed_for_autosave?).to be_truthy\n      end\n    end\n\n    describe \"remove_images!\" do\n      before do\n        @event.images = [stub_file('test.jpeg')]\n        @event.save!\n        @event.remove_images!\n      end\n\n      it \"should clear the serialization column\" do\n        expect(@event.attributes['images']).to be_blank\n      end\n\n      it \"should return to false after being saved\" do\n        @event.save!\n        expect(@event.remove_images).to eq(false)\n        expect(@event.remove_images?).to eq(false)\n      end\n    end\n\n    describe \"remove_images=\" do\n      it \"should mark the images as changed if changed\" do\n        expect(@event.images_changed?).to be_falsey\n        expect(@event.remove_images).to be_nil\n        @event.remove_images = \"1\"\n        expect(@event.images_changed?).to be_truthy\n      end\n\n      it \"should not mark the images as changed if falsey value is assigned\" do\n        @event.remove_images = \"0\"\n        expect(@event.images_changed?).to be_falsey\n        @event.remove_images = \"false\"\n        expect(@event.images_changed?).to be_falsey\n      end\n    end\n\n    describe \"#remote_images_urls=\" do\n      before do\n        stub_request(:get, \"www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      # FIXME ideally images_changed? and remote_images_urls_changed? would return true\n      it \"should mark images as changed when setting remote_images_urls\" do\n        expect(@event.images_changed?).to be_falsey\n        @event.remote_images_urls = ['http://www.example.com/test.jpg']\n        expect(@event.images_changed?).to be_truthy\n        @event.save!\n        @event.reload\n        expect(@event.images_changed?).to be_falsey\n      end\n\n      context 'when validating download' do\n        before do\n          @uploader.class_eval do\n            def download! file, headers = {}\n              raise CarrierWave::DownloadError\n            end\n          end\n          @event.remote_images_urls = ['http://www.example.com/missing.jpg']\n        end\n\n        it \"should make the record invalid when a download error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for download errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['could not be downloaded'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_download_error => 'n\u00e3o pode ser descarregado'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['n\u00e3o pode ser descarregado'])\n          end\n        end\n      end\n\n    end\n\n    describe '#destroy' do\n\n      it \"should not raise an error with a custom filename\" do\n        @uploader.class_eval do\n          def filename\n            \"page.jpeg\"\n          end\n        end\n\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect {\n          @event.destroy\n        }.to_not raise_error\n      end\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        @event.destroy\n      end\n\n      it \"should remove the file from the filesystem\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n        @event.destroy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n\n    end\n\n    describe 'with overriddent filename' do\n\n      describe '#save' do\n\n        before do\n          @uploader.class_eval do\n            def filename\n              model.name + File.extname(super)\n            end\n          end\n          allow(@event).to receive(:name).and_return('jonas')\n        end\n\n        it \"should copy the file to the upload directory when a file has been assigned\" do\n          @event.images = [stub_file('test.jpeg')]\n          expect(@event.save).to be_truthy\n          expect(@event.images[0]).to be_an_instance_of(@uploader)\n          expect(@event.images[0].current_path).to eq(public_path('uploads/jonas.jpeg'))\n        end\n\n        it \"should assign an overridden filename to the database\" do\n          @event.images = [stub_file('test.jpeg')]\n          expect(@event.save).to be_truthy\n          @event.reload\n          expect(@event[:images]).to eq(['jonas.jpeg'])\n        end\n\n      end\n\n    end\n\n    describe 'with validates_presence_of' do\n\n      before do\n        Event.validates_presence_of :images\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has not been cached\" do\n        expect(@event).to_not be_valid\n      end\n\n    end\n\n    describe 'with validates_size_of' do\n\n      before do\n        Event.validates_size_of :images, maximum: 2\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if at the number criteria are met\" do\n        @event.images = [stub_file('test.jpeg'), stub_file('old.jpeg')]\n        expect(@event).to be_valid\n      end\n\n      it \"should be invalid if size criteria are exceeded\" do\n        @event.images = [stub_file('test.jpeg'), stub_file('old.jpeg'), stub_file('new.jpeg')]\n        expect(@event).to_not be_valid\n      end\n\n    end\n  end\n\n  describe '#mount_uploaders with mount_on' do\n    describe '#avatar=' do\n      it \"should cache a file\" do\n        reset_class(\"Event\")\n        Event.mount_uploaders(:avatar, @uploader, mount_on: :images)\n        @event = Event.new\n        @event.avatar = [stub_file('test.jpeg')]\n        @event.save\n        @event.reload\n\n        expect(@event.avatar[0]).to be_an_instance_of(@uploader)\n        expect(@event.images).to eq(['test.jpeg'])\n      end\n\n    end\n  end\n\n  describe '#mount_uploaders removing old files' do\n    before do\n      Event.mount_uploaders(:images, @uploader)\n      @event.images = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    describe 'normally' do\n      it \"should remove old file if old file had a different path\" do\n        @event.images = [stub_file('new.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      end\n\n      it \"should not remove old file if old file had a different path but config is false\" do\n        allow(@uploader).to receive(:remove_previously_stored_files_after_update).and_return(false)\n        @event.images = [stub_file('new.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if old file had the same path\" do\n        @event.images = [stub_file('old.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if validations fail on save\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.images = [stub_file('new.jpeg')]\n\n        expect(@event.save).to be_falsey\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n    end\n\n    describe 'with an overriden filename' do\n      before do\n        @uploader.class_eval do\n          def filename\n            model.foo + File.extname(super)\n          end\n        end\n\n        @event.images = [stub_file('old.jpeg')]\n        @event.foo = 'test'\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n        expect(@event.images[0].read).to eq('this is stuff')\n      end\n\n      it \"should not remove file if old file had the same dynamic path\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n      end\n\n      it \"should remove old file if old file had a different dynamic path\" do\n        @event.foo = \"new\"\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n    end\n  end\n\n  describe '#mount_uploaders removing old files with versions' do\n    before do\n      @uploader.version :thumb\n      Event.mount_uploaders(:images, @uploader)\n      @event.images = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.images = [stub_file('new.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.images = [stub_file('old.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders removing old files with multiple uploaders' do\n    before do\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n      @uploader1 = Class.new(CarrierWave::Uploader::Base)\n      reset_class(\"Event\")\n      Event.mount_uploaders(:images, @uploader)\n      Event.mount_uploaders(:textfiles, @uploader1)\n      @event = Event.new\n      @event.images = [stub_file('old.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file1 and file2 if old file1 and file2 had a different paths\" do\n      @event.images = [stub_file('new.jpeg')]\n      @event.textfiles = [stub_file('new.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/new.txt'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_falsey\n    end\n\n    it \"should remove old file1 but not file2 if old file1 had a different path but old file2 has the same path\" do\n      @event.images = [stub_file('new.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    it \"should not remove file1 or file2 if file1 and file2 have the same paths\" do\n      @event.images = [stub_file('old.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders removing old files with mount_on' do\n    before do\n      Event.mount_uploaders(:avatar, @uploader, mount_on: :images)\n      @event = Event.new\n      @event.avatar = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.avatar = [stub_file('new.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.avatar = [stub_file('old.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    it \"should not raise ArgumentError when with_lock method is called\" do\n      expect { @event.with_lock {} }.to_not raise_error\n    end\n  end\n\n  describe '#reload' do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    context 'when #reload is overriden in the model' do\n      before do\n        Event.class_eval do\n          def reload(*)\n            super\n          end\n        end\n        @event.save\n        @event.image\n      end\n\n      it \"clears @_mounters\" do\n        expect { @event.reload }.to change { @event.instance_variable_get(:@_mounters) }.to(nil)\n      end\n    end\n  end\n\n  describe \"#dup\" do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    it \"appropriately removes the model reference from the new models uploader\" do\n      @event.save\n      new_event = @event.dup\n\n      expect(new_event.image.model).not_to eq @event\n    end\n\n    context 'when #initialize_dup is overriden in the model' do\n      before do\n        Event.class_eval do\n          def initialize_dup(*)\n            super\n          end\n        end\n        @event.image\n      end\n\n      it \"clears @_mounters\" do\n        expect(@event.dup.instance_variable_get(:@_mounters)).to be_blank\n      end\n    end\n  end\nend\n", "require 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'pry'\nrequire 'tempfile'\nrequire 'time'\nrequire 'logger'\n\nrequire 'carrierwave'\nrequire 'timecop'\nrequire 'open-uri'\nrequire \"webmock/rspec\"\nrequire 'mini_magick'\n\nI18n.enforce_available_locales = false\n\nCARRIERWAVE_DIRECTORY = \"carrierwave#{Time.now.to_i}\" unless defined?(CARRIERWAVE_DIRECTORY)\n\nalias :running :lambda\n\ndef file_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'fixtures', *paths))\nend\n\ndef public_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'public', *paths))\nend\n\ndef tmp_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'tmp', *paths))\nend\n\nCarrierWave.root = public_path\nI18n.load_path << File.expand_path(File.join(File.dirname(__FILE__), \"..\", \"lib\", \"carrierwave\", \"locale\", 'en.yml'))\n\nmodule CarrierWave\n  module Test\n    module MockStorage\n      def mock_storage(kind)\n        storage = double(\"storage for #{kind} uploader\")\n        allow(storage).to receive(:setup!)\n        storage\n      end\n    end\n\n    module MockFiles\n      def stub_tempfile(filename, mime_type=nil, fake_name=nil)\n        raise \"#{path} file does not exist\" unless File.exist?(file_path(filename))\n\n        tempfile = Tempfile.new(filename)\n        FileUtils.copy_file(file_path(filename), tempfile.path)\n        allow(tempfile).to receive_messages(:original_filename => fake_name || filename,\n                      :content_type => mime_type)\n        tempfile\n      end\n\n      alias_method :stub_merb_tempfile, :stub_tempfile\n\n      def stub_stringio(filename, mime_type=nil, fake_name=nil)\n        file = IO.read( file_path( filename ) ) if filename\n        stringio = StringIO.new(file)\n        allow(stringio).to receive_messages(:local_path => \"\",\n                      :original_filename => filename || fake_name,\n                      :content_type => mime_type)\n        stringio\n      end\n\n      def stub_file(filename, mime_type=nil, fake_name=nil)\n        f = File.open(file_path(filename))\n        allow(f).to receive(:content_type) { mime_type } if mime_type\n        return f\n      end\n    end\n\n    module I18nHelpers\n      def change_locale_and_store_translations(locale, translations, &block)\n        current_locale = I18n.locale\n        begin\n          # I18n.available_locales needs to be cleared before storing translations:\n          #   https://github.com/svenfuchs/i18n/pull/391\n          I18n.available_locales = nil\n          I18n.backend.store_translations locale, translations\n          I18n.locale = locale\n          yield\n        ensure\n          I18n.reload!\n          I18n.locale = current_locale\n        end\n      end\n\n      def change_and_enforece_available_locales(locale, available_locales, &block)\n        current_available_locales = I18n.available_locales\n        current_enforce_available_locales_value = I18n.enforce_available_locales\n        current_locale = I18n.locale\n        begin\n          I18n.available_locales = [:nl]\n          I18n.enforce_available_locales = true\n          I18n.locale = :nl\n          yield\n        ensure\n          I18n.available_locales = current_available_locales\n          I18n.enforce_available_locales = current_enforce_available_locales_value\n          I18n.locale = current_locale\n        end\n      end\n    end\n\n    module ManipulationHelpers\n      def color_of_pixel(path, x, y)\n        image = ::MiniMagick::Image.open(path)\n        image.run_command(\"convert\", \"#{image.path}[1x1+#{x}+#{y}]\", \"-depth\", \"8\", \"txt:\").split(\"\\n\")[1]\n      end\n    end\n  end\nend\n\nRSpec.configure do |config|\n  config.include CarrierWave::Test::Matchers\n  config.include CarrierWave::Test::MockFiles\n  config.include CarrierWave::Test::MockStorage\n  config.include CarrierWave::Test::I18nHelpers\n  config.include CarrierWave::Test::ManipulationHelpers\n  if RUBY_ENGINE == 'jruby'\n    config.filter_run_excluding :rmagick => true\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Uploader::Download do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:cache_id) { '1369894322-345-1234-2255' }\n  let(:base_url) { \"http://www.example.com\" }\n  let(:url) { base_url + \"/test.jpg\" }\n  let(:test_file) { File.read(file_path(test_file_name)) }\n  let(:test_file_name) { \"test.jpg\" }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '#download!' do\n    before do\n      allow(CarrierWave).to receive(:generate_cache_id).and_return(cache_id)\n\n      stub_request(:get, \"www.example.com/#{test_file_name}\")\n        .to_return(body: test_file)\n    end\n\n    context \"when a file was downloaded\" do\n      before do\n        uploader.download!(url)\n      end\n\n      it \"caches a file\" do\n        expect(uploader.file).to be_an_instance_of(CarrierWave::SanitizedFile)\n      end\n\n      it \"'s cached\" do\n        expect(uploader).to be_cached\n      end\n\n      it \"stores the cache name\" do\n        expect(uploader.cache_name).to eq(\"#{cache_id}/#{test_file_name}\")\n      end\n\n      it \"sets the filename to the file's sanitized filename\" do\n        expect(uploader.filename).to eq(\"#{test_file_name}\")\n      end\n\n      it \"moves it to the tmp dir\" do\n        expect(uploader.file.path).to eq(public_path(\"uploads/tmp/#{cache_id}/#{test_file_name}\"))\n        expect(uploader.file.exists?).to be_truthy\n      end\n\n      it \"sets the url\" do\n        expect(uploader.url).to eq(\"/uploads/tmp/#{cache_id}/#{test_file_name}\")\n      end\n    end\n\n    context \"with directory permissions set\" do\n      let(:permissions) { 0777 }\n\n      it \"sets permissions\" do\n        uploader_class.permissions = permissions\n        uploader.download!(url)\n\n        expect(uploader).to have_permissions(permissions)\n      end\n\n      it \"sets directory permissions\" do\n        uploader_class.directory_permissions = permissions\n        uploader.download!(url)\n\n        expect(uploader).to have_directory_permissions(permissions)\n      end\n    end\n\n    describe \"custom downloader\" do\n      let(:klass) do\n        Class.new(CarrierWave::Downloader::Base) {\n          def download(url, request_headers={})\n          end\n        }\n      end\n      before do\n        uploader.downloader = klass\n      end\n\n      it \"is supported\" do\n        expect_any_instance_of(klass).to receive(:download).with(url, {})\n        uploader.download!(url)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# -*- encoding: utf-8 -*-\nlib = File.expand_path('../lib/', __FILE__)\n$:.unshift lib unless $:.include?(lib)\n\nrequire 'carrierwave/version'\n\nGem::Specification.new do |s|\n  s.name = \"carrierwave\"\n  s.version = CarrierWave::VERSION\n\n  s.authors = [\"Jonas Nicklas\"]\n  s.description = \"Upload files in your Ruby applications, map them to a range of ORMs, store them on different backends.\"\n  s.summary = \"Ruby file upload library\"\n  s.email = [\"jonas.nicklas@gmail.com\"]\n  s.extra_rdoc_files = [\"README.md\"]\n  s.files = Dir[\"{bin,lib}/**/*\", \"README.md\"]\n  s.homepage = %q{https://github.com/carrierwaveuploader/carrierwave}\n  s.rdoc_options = [\"--main\"]\n  s.require_paths = [\"lib\"]\n  s.licenses = [\"MIT\"]\n\n  s.required_ruby_version = \">= 2.2.2\"\n\n  s.add_dependency \"activesupport\", \">= 5.0.0\"\n  s.add_dependency \"activemodel\", \">= 5.0.0\"\n  s.add_dependency \"mini_mime\", \">= 0.1.3\"\n  s.add_dependency \"image_processing\", \"~> 1.1\"\n  s.add_dependency \"mimemagic\", \">= 0.3.0\"\n  s.add_dependency \"addressable\", \"~> 2.6\"\n  s.add_dependency \"ssrf_filter\", \"~> 1.0\"\n  if RUBY_ENGINE == 'jruby'\n    s.add_development_dependency 'activerecord-jdbcpostgresql-adapter'\n  else\n    s.add_development_dependency \"pg\"\n  end\n  s.add_development_dependency \"rails\", \">= 5.0.0\"\n  s.add_development_dependency \"cucumber\", \"~> 2.3\"\n  s.add_development_dependency \"rspec\", \"~> 3.4\"\n  s.add_development_dependency \"webmock\"\n  s.add_development_dependency \"fog-aws\"\n  s.add_development_dependency \"fog-google\", \"~> 1.7\"\n  s.add_development_dependency \"fog-local\"\n  s.add_development_dependency \"fog-rackspace\"\n  s.add_development_dependency \"mini_magick\", \">= 3.6.0\"\n  if RUBY_ENGINE != 'jruby'\n    s.add_development_dependency \"rmagick\", \">= 2.16\"\n  end\n  s.add_development_dependency \"timecop\"\n  s.add_development_dependency \"generator_spec\", \">= 0.9.1\"\n  s.add_development_dependency \"pry\"\nend\n", "When /^I download the file '([^']+)'/ do |url|\n  unless ENV['REMOTE'] == 'true'\n    stub_request(:get, %r{/Monkey/testfile.txt}).\n      to_return(body: \"S3 Remote File\", headers: { \"Content-Type\" => \"text/plain\" })\n  end\n\n  @uploader.download!(url)\nend\n", "require 'open-uri'\nrequire 'ssrf_filter'\nrequire 'addressable'\nrequire 'carrierwave/downloader/remote_file'\n\nmodule CarrierWave\n  module Downloader\n    class Base\n      attr_reader :uploader\n\n      def initialize(uploader)\n        @uploader = uploader\n      end\n\n      ##\n      # Downloads a file from given URL and returns a RemoteFile.\n      #\n      # === Parameters\n      #\n      # [url (String)] The URL where the remote file is stored\n      # [remote_headers (Hash)] Request headers\n      #\n      def download(url, remote_headers = {})\n        headers = remote_headers.\n          reverse_merge('User-Agent' => \"CarrierWave/#{CarrierWave::VERSION}\")\n        uri = process_uri(url.to_s)\n        begin\n          if skip_ssrf_protection?(uri)\n            response = OpenURI.open_uri(process_uri(url.to_s), headers)\n          else\n            request = nil\n            response = SsrfFilter.get(uri, headers: headers) do |req|\n              request = req\n            end\n            response.uri = request.uri\n            response.value\n          end\n        rescue StandardError => e\n          raise CarrierWave::DownloadError, \"could not download file: #{e.message}\"\n        end\n        CarrierWave::Downloader::RemoteFile.new(response)\n      end\n\n      ##\n      # Processes the given URL by parsing it, and escaping if necessary. Public to allow overriding.\n      #\n      # === Parameters\n      #\n      # [url (String)] The URL where the remote file is stored\n      #\n      def process_uri(uri)\n        uri_parts = uri.split('?')\n        encoded_uri = Addressable::URI.parse(uri_parts.shift).normalize.to_s\n        query = uri_parts.any? ? \"?#{uri_parts.join('?')}\" : ''\n        begin\n          URI.parse(\"#{encoded_uri}#{query}\")\n        rescue URI::InvalidURIError\n          URI.parse(\"#{encoded_uri}#{URI::DEFAULT_PARSER.escape(query)}\")\n        end\n      rescue URI::InvalidURIError, Addressable::URI::InvalidURIError\n        raise CarrierWave::DownloadError, \"couldn't parse URL: #{uri}\"\n      end\n\n      ##\n      # If this returns true, SSRF protection will be bypassed.\n      # You can override this if you want to allow accessing specific local URIs that are not SSRF exploitable.\n      #\n      # === Parameters\n      #\n      # [uri (URI)] The URI where the remote file is stored\n      #\n      # === Examples\n      #\n      #     class CarrierWave::Downloader::CustomDownloader < CarrierWave::Downloader::Base\n      #       def skip_ssrf_protection?(uri)\n      #         uri.hostname == 'localhost' && uri.port == 80\n      #       end\n      #     end\n      #\n      #     my_uploader.downloader = CarrierWave::Downloader::CustomDownloader\n      #\n      def skip_ssrf_protection?(uri)\n        false\n      end\n    end\n  end\nend\n", "module CarrierWave\n  module Downloader\n    class RemoteFile\n      attr_reader :file, :uri\n\n      def initialize(file)\n        case file\n        when String\n          @file = StringIO.new(file)\n        when Net::HTTPResponse\n          @file = StringIO.new(file.body)\n          @content_type = file.content_type\n          @headers = file\n          @uri = file.uri\n        else\n          @file = file\n          @content_type = file.content_type\n          @headers = file.meta\n          @uri = file.base_uri\n        end\n      end\n\n      def content_type\n        @content_type || 'application/octet-stream'\n      end\n\n      def headers\n        @headers || {}\n      end\n\n      def original_filename\n        filename = filename_from_header || filename_from_uri\n        mime_type = MiniMime.lookup_by_content_type(content_type)\n        unless File.extname(filename).present? || mime_type.blank?\n          filename = \"#{filename}.#{mime_type.extension}\"\n        end\n        filename\n      end\n\n      def respond_to?(*args)\n        super || file.respond_to?(*args)\n      end\n\n      private\n\n      def filename_from_header\n        return nil unless headers['content-disposition']\n\n        match = headers['content-disposition'].match(/filename=(?:\"([^\"]+)\"|([^\";]+))/)\n        return nil unless match\n\n        match[1].presence || match[2].presence\n      end\n\n      def filename_from_uri\n        CGI.unescape(File.basename(uri.path))\n      end\n\n      def method_missing(*args, &block)\n        file.send(*args, &block)\n      end\n    end\n  end\nend\n\n", "require 'spec_helper'\n\ndescribe CarrierWave::Downloader::Base do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:file) { File.read(file_path(\"test.jpg\")) }\n  let(:filename) { \"test.jpg\" }\n  let(:uri) { \"http://www.example.com/#{CGI.escape(filename)}\" }\n\n  subject { CarrierWave::Downloader::Base.new(uploader) }\n\n  context \"with unicode sybmols in URL\" do\n    let(:filename) { \"\u044e\u043d\u0438\u043a\u043e\u0434.jpg\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    let(:remote_file) { subject.download(uri) }\n\n    it \"downloads a file\" do\n      expect(remote_file).to be_an_instance_of(CarrierWave::Downloader::RemoteFile)\n    end\n\n    it \"sets the filename to the file's decoded sanitized filename\" do\n      expect(remote_file.original_filename).to eq(\"#{filename}\")\n    end\n  end\n\n  context \"with equal and colons in the query path\" do\n    let(:query) { 'test=query&with=equal&before=colon:param' }\n    let(:uri) { \"https://example.com/#{filename}?#{query}\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    it \"leaves colon in resulting URI\" do\n      expect(subject.process_uri(uri).query).to eq query\n    end\n\n    it \"downloads a file\" do\n      expect(subject.download(uri).file.read).to eq file\n    end\n  end\n\n  context 'with request headers' do\n    let(:authentication_headers) do\n      {\n        'Accept'=>'*/*',\n        'Accept-Encoding'=>'gzip;q=1.0,deflate;q=0.6,identity;q=0.3',\n        'User-Agent'=>\"CarrierWave/#{CarrierWave::VERSION}\",\n        'Authorization'=>'Bearer QWE'\n      }\n    end\n    before do\n      stub_request(:get, uri).\n        with(:headers => authentication_headers).\n        to_return(body: file)\n    end\n\n    it 'pass custom headers to request' do\n      expect(subject.download(uri, { 'Authorization' => 'Bearer QWE' }).file.read).to eq file\n    end\n  end\n\n  context \"with missing file\" do\n    before do\n      stub_request(:get, uri).to_return(status: 404)\n    end\n\n    it \"raises an error when trying to download a missing file\" do\n      expect{ subject.download(uri) }.to raise_error(CarrierWave::DownloadError)\n    end\n\n    it \"doesn't obscure original exception message\" do\n      expect { subject.download(uri) }.to raise_error(CarrierWave::DownloadError, /could not download file: 404/)\n    end\n  end\n\n  context \"with server error\" do\n    before do\n      stub_request(:get, uri).to_return(status: 500)\n    end\n\n    it \"raises an error when trying to download\" do\n      expect{ subject.download(uri) }.to raise_error(CarrierWave::DownloadError)\n    end\n\n    it \"doesn't obscure original exception message\" do\n      expect { subject.download(uri) }.to raise_error(CarrierWave::DownloadError, /could not download file: 500/)\n    end\n  end\n\n  context \"with a url that contains space\" do\n    let(:filename) { \"my test.jpg\" }\n    before do\n      stub_request(:get, uri).to_return(body: file)\n    end\n\n    it \"accepts spaces in the url\" do\n      expect(subject.download(uri).original_filename).to eq filename\n    end\n  end\n\n  context \"with redirects\" do\n    let(:another_uri) { 'http://example.com/redirected.jpg' }\n    before do\n      stub_request(:get, uri).\n        to_return(status: 301, body: \"Redirecting\", headers: { \"Location\" => another_uri })\n      stub_request(:get, /redirected.jpg/).to_return(body: file)\n    end\n\n    it \"retrieves redirected file\" do\n      expect(subject.download(uri).file.read).to eq file\n    end\n\n    it \"extracts filename from the url after redirection\" do\n      expect(subject.download(uri).original_filename).to eq 'redirected.jpg'\n    end\n  end\n\n  context \"with SSRF prevention\" do\n    before do\n      stub_request(:get, 'http://169.254.169.254/').to_return(body: file)\n      stub_request(:get, 'http://127.0.0.1/').to_return(body: file)\n    end\n\n    it \"prevents accessing local files\" do\n      expect { subject.download('/etc/passwd') }.to raise_error(CarrierWave::DownloadError)\n      expect { subject.download('file:///etc/passwd') }.to raise_error(CarrierWave::DownloadError)\n    end\n\n    it \"prevents accessing internal addresses\" do\n      expect { uploader.download!(\"http://169.254.169.254/\") }.to raise_error CarrierWave::DownloadError\n      expect { uploader.download!(\"http://lvh.me/\") }.to raise_error CarrierWave::DownloadError\n    end\n  end\n\n  describe '#process_uri' do\n    it \"converts a URL with internationalized domain name to Punycode URI\" do\n      uri = \"http://\u30c9\u30e1\u30a4\u30f3\u540d\u4f8b.jp/#{CGI.escape(filename)}\"\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq 'http://xn--eckwd4c7cu47r2wf.jp/test.jpg'\n    end\n\n    it \"parses but not escape already escaped uris\" do\n      uri = 'http://example.com/%5B.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"parses but not escape uris with query-string-only characters not needing escaping\" do\n      uri = 'http://example.com/?foo[]=bar'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"escapes and parse unescaped uris\" do\n      uri = 'http://example.com/ %[].jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%20%25%5B%5D.jpg')\n    end\n\n    it \"parses but not escape uris with query-string characters representing urls not needing escaping \" do\n      uri = 'http://example.com/?src0=https%3A%2F%2Fi.vimeocdn.com%2Fvideo%2F1234_1280x720.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq(uri)\n    end\n\n    it \"escapes and parse brackets in uri paths without harming the query string\" do\n      uri = 'http://example.com/].jpg?test[]'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%5D.jpg?test[]')\n    end\n\n    it \"escapes and parse unescaped characters in path\" do\n      uri = 'http://example.com/\u3042\u3042\u3042.jpg'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/%E3%81%82%E3%81%82%E3%81%82.jpg')\n    end\n\n    it \"escapes and parse unescaped characters in query string\" do\n      uri = 'http://example.com/?q=\u3042\u3042\u3042'\n      processed = subject.process_uri(uri)\n      expect(processed.class).to eq(URI::HTTP)\n      expect(processed.to_s).to eq('http://example.com/?q=%E3%81%82%E3%81%82%E3%81%82')\n    end\n\n    it \"throws an exception on bad uris\" do\n      uri = '~http:'\n      expect { subject.process_uri(uri) }.to raise_error(CarrierWave::DownloadError)\n    end\n  end\n\n  describe \"#skip_ssrf_protection?\" do\n    let(:uri) { 'http://localhost/test.jpg' }\n    before do\n      WebMock.stub_request(:get, uri).to_return(body: file)\n      allow(subject).to receive(:skip_ssrf_protection?).and_return(true)\n    end\n\n    it \"allows local request to be made\" do\n      expect(subject.download(uri).read).to eq 'this is stuff'\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Downloader::RemoteFile do\n  subject { CarrierWave::Downloader::RemoteFile.new(file) }\n  let(:file) do\n    Net::HTTPSuccess.new('1.0', '200', \"\").tap do |response|\n      response.body = File.read(file_path(\"test.jpg\"))\n      response.instance_variable_set(:@read, true)\n      response.uri = URI.parse 'http://example.com/test'\n      response['content-type'] = 'image/jpeg'\n      response['vary'] = 'Accept-Encoding'\n    end\n  end\n\n  context 'with Net::HTTPResponse instance' do\n    it 'returns content type' do\n      expect(subject.content_type).to eq 'image/jpeg'\n    end\n\n    it 'returns header' do\n      expect(subject.headers['vary']).to eq 'Accept-Encoding'\n    end\n\n    it 'returns URI' do\n      expect(subject.uri.to_s).to eq 'http://example.com/test'\n    end\n  end\n\n  context 'with OpenURI::Meta instance' do\n    let(:file) do\n      File.open(file_path(\"test.jpg\")).tap { |f| OpenURI::Meta.init(f) }.tap do |file|\n        file.base_uri = URI.parse 'http://example.com/test'\n        file.meta_add_field 'content-type', 'image/jpeg'\n        file.meta_add_field 'vary', 'Accept-Encoding'\n      end\n    end\n    it 'returns content type' do\n      expect(subject.content_type).to eq 'image/jpeg'\n    end\n\n    it 'returns header' do\n      expect(subject.headers['vary']).to eq 'Accept-Encoding'\n    end\n\n    it 'returns URI' do\n      expect(subject.uri.to_s).to eq 'http://example.com/test'\n    end\n  end\n\n\n  describe '#original_filename' do\n    let(:content_disposition){ nil }\n    before do\n      file['content-disposition'] = content_disposition if content_disposition\n    end\n\n    it 'sets file extension based on content-type if missing' do\n      expect(subject.original_filename).to eq \"test.jpeg\"\n    end\n\n    context 'when filename is quoted' do\n      let(:content_disposition){ 'filename=\"another_test.jpg\"' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is quoted and empty' do\n      let(:content_disposition){ 'filename=\"\"' }\n\n      it \"sets file extension based on content-type if missing\" do\n        expect(subject.original_filename).to eq 'test.jpeg'\n      end\n    end\n\n    context 'when filename is not quoted and empty' do\n      let(:content_disposition){ 'filename=' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'test.jpeg'\n      end\n    end\n\n    context 'when filename is not quoted' do\n      let(:content_disposition){ 'filename=another_test.jpg' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is not quoted and terminated by semicolon' do\n      let(:content_disposition){ 'filename=another_test.jpg; size=1234' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another_test.jpg'\n      end\n    end\n\n    context 'when filename is quoted and contains a semicolon' do\n      let(:content_disposition){ 'filename=\"another;_test.jpg\"; size=1234' }\n\n      it \"reads filename correctly\" do\n        expect(subject.original_filename).to eq 'another;_test.jpg'\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Mount do\n  let(:klass) { Class.new.send(:extend, CarrierWave::Mount) }\n  let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n  let(:instance) { klass.new }\n  let(:test_file_name) { 'test.jpg' }\n  let(:new_file_name) { 'new.jpeg' }\n  let(:test_file_stub) { stub_file(test_file_name) }\n  let(:new_file_stub) { stub_file(new_file_name) }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '.mount_uploaders' do\n    before { klass.mount_uploaders(:images, uploader) }\n\n    describe \"super behavior\" do\n      before do\n        klass.class_eval do\n          def images_uploader\n            super\n          end\n\n          def images=(val)\n            super\n          end\n        end\n\n        instance.images = [stub_file(test_file_name)]\n      end\n\n      it \"maintains the ability to super\" do\n        expect(instance.images[0]).to be_an_instance_of(uploader)\n      end\n    end\n\n    describe \"upload inheritance\" do\n      let(:subclass) { Class.new(klass) }\n      let(:subclass_instance) { subclass.new }\n\n      before { subclass_instance.images = [test_file_stub, new_file_stub] }\n\n      it \"inherits uploaders to subclasses\" do\n        expect(subclass_instance.images[0]).to be_an_instance_of(uploader)\n        expect(subclass_instance.images[1]).to be_an_instance_of(uploader)\n      end\n    end\n\n    describe \"upload marshalling\" do\n      before do\n        Object.const_set(\"MyClass#{klass.object_id}\".gsub('-', '_'), klass)\n        Object.const_set(\"Uploader#{uploader.object_id}\".gsub('-', '_'), uploader)\n\n        uploader.class_eval do\n          def rotate\n          end\n        end\n\n        uploader.version :thumb do\n          process :rotate\n        end\n\n        instance.images = [test_file_stub]\n      end\n\n      it \"allows marshalling uploaders and versions\" do\n        expect { Marshal.dump(instance.images) }.not_to raise_error\n      end\n    end\n\n    describe \"behavior of subclassed uploaders\" do\n      let(:uploader_1) do\n        Class.new(CarrierWave::Uploader::Base) do\n          [:rotate, :compress, :encrypt, :shrink].each { |m| define_method(m) {} }\n        end.tap do |uploader|\n          uploader.process :rotate\n          uploader.version :thumb do\n            process :compress\n          end\n        end\n      end\n\n      let(:uploader_2) do\n        Class.new(uploader_1).tap do |uploader|\n          uploader.process :shrink\n          uploader.version :secret do\n            process :encrypt\n          end\n        end\n      end\n\n      let(:instance) do\n        klass.new.tap do |instance|\n          instance.images1 = [test_file_stub]\n          instance.images2 = [test_file_stub]\n        end\n      end\n\n      before do\n        klass.mount_uploaders(:images1, uploader_1)\n        klass.mount_uploaders(:images2, uploader_2)\n      end\n\n      context \"defined version inheritance works\" do\n        it { expect(instance.images1[0]).to respond_to(:thumb) }\n\n        it { expect(instance.images2[0]).to respond_to(:thumb) }\n      end\n\n      context \"version inheritance defined in subclasses works\" do\n        it { expect(instance.images1[0]).not_to respond_to(:secret) }\n\n        it { expect(instance.images2[0]).to respond_to(:secret) }\n      end\n\n      context \"defined processors inheritance works\" do\n        it { expect(uploader_1.processors).to eq([[:rotate, [], nil]]) }\n\n        it { expect(uploader_2.processors).to eq([[:rotate, [], nil], [:shrink, [], nil]]) }\n\n        it { expect(uploader_1.versions[:thumb].processors).to eq([[:compress, [], nil]]) }\n\n        it { expect(uploader_2.versions[:thumb].processors).to eq([[:compress, [], nil]]) }\n\n        it { expect(uploader_2.versions[:secret].processors).to eq([[:encrypt, [], nil]]) }\n      end\n    end\n\n    describe '#images' do\n      context \"return an empty array when nothing has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return(nil)\n        end\n\n        it { expect(instance.images).to eq [] }\n      end\n\n      context \"returns an empty array when an empty string has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return('')\n        end\n\n        it { expect(instance.images).to eq [] }\n      end\n\n      context \"retrieves a file from the storage if a value is stored in the database\" do\n        subject(:images) { instance.images }\n\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).at_least(:once).and_return([test_file_name, new_file_name])\n        end\n\n        it { expect(images[0]).to be_an_instance_of(uploader) }\n        it { expect(images[1]).to be_an_instance_of(uploader) }\n      end\n\n      context \"sets the path to the store dir\" do\n        subject(:image) { instance.images.first }\n\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).at_least(:once).and_return(test_file_name)\n        end\n\n        it { expect(image.current_path).to eq(public_path(\"uploads/#{test_file_name}\")) }\n      end\n    end\n\n    describe '#images=' do\n      let(:old_image_stub) { stub_file('old.jpeg') }\n      let(:text_file_stub) { stub_file('bork.txt') }\n\n      context \"caching images\" do\n        before do\n          instance.images = [test_file_stub, old_image_stub]\n        end\n\n        it { expect(instance.images[0]).to be_an_instance_of(uploader) }\n\n        it { expect(instance.images[1]).to be_an_instance_of(uploader) }\n\n        it \"copies files into the cache directory\" do\n          expect(instance.images[0].current_path).to match(/^#{public_path('uploads/tmp')}/)\n        end\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n          expect(instance.images[1].staged).to be true\n        end\n      end\n\n      it \"does nothing when nil is assigned\" do\n        expect(instance).not_to receive(:write_uploader)\n        instance.images = nil\n      end\n\n      it \"does nothing when an empty string is assigned\" do\n        expect(instance).not_to receive(:write_uploader)\n\n        instance.images = [test_file_stub]\n      end\n\n      context \"if the images fails a white list integrity check\" do\n        before do\n          uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which passed the check\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"if the images fails a black list integrity check\" do\n        before do\n          uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which passed the check\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"if the images fails to be processed\" do\n        before do\n          uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\" if file.path =~ /test\\.jpg/\n            end\n          end\n        end\n\n        it \"fails silently\" do\n          expect { instance.images = [test_file_stub] }.not_to raise_error\n        end\n\n        it \"keeps files which was processed successfully\" do\n          instance.images = [test_file_stub, text_file_stub]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n\n      describe \"with cached files\" do\n        before do\n          instance.images = [text_file_stub, test_file_stub]\n        end\n        let(:cache_names) { instance.images.map(&:cache_name) }\n        let(:identifiers) { instance.images.map(&:identifier) }\n\n        it \"accepts cache name and retrieves from cache\" do\n          instance.images = [cache_names[1]]\n          expect(instance.images.map { |u| u.file.filename }).to eq ['test.jpg']\n        end\n      end\n\n      describe \"with stored files\" do\n        before do\n          instance.images = [text_file_stub, test_file_stub]\n          instance.store_images!\n        end\n        let(:identifiers) { instance.images.map(&:identifier) }\n\n        it \"writes over a previously stored file\" do\n          instance.images = [old_image_stub]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['old.jpeg']\n        end\n\n        it \"preserves existing image of given identifier\" do\n          instance.images = [identifiers[0], old_image_stub]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt','old.jpeg']\n        end\n\n        it \"reorders existing image\" do\n          instance.images = identifiers.reverse\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg', 'bork.txt']\n        end\n\n        it \"allows uploading and reordering at once\" do\n          instance.images = [identifiers[1], old_image_stub, identifiers[0]]\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg', 'old.jpeg', 'bork.txt']\n        end\n\n        it \"allows repeating the same identifiers\" do\n          instance.images = ['bork.txt', 'test.jpg', 'bork.txt']\n          instance.store_images!\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt', 'test.jpg', 'bork.txt']\n        end\n\n        it \"removes image which is unused\" do\n          @image_paths = instance.images.map(&:current_path)\n          instance.images = [identifiers[0]]\n          instance.store_images!\n          instance.send(:_mounter, :images).remove_previous(identifiers, identifiers[0..0])\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n          expect(File.exist?(@image_paths[0])).to be_truthy\n          expect(File.exist?(@image_paths[1])).to be_falsey\n        end\n\n        it \"ignores unknown identifier\" do\n          instance.images = ['unknown.txt']\n          expect { instance.store_images! }.not_to raise_error\n          expect(instance.images.map(&:identifier)).to be_empty\n        end\n\n        it \"allows deleting all files\" do\n          instance.images = []\n          expect(instance.images.map(&:identifier)).to be_empty\n        end\n\n        it \"allows assignment of uploader instances\" do\n          instance.images = [instance.images[0]]\n          expect(instance.images.map(&:identifier)).to eq ['bork.txt']\n        end\n      end\n    end\n\n    describe '#images?' do\n      subject { instance.images? }\n\n      context \"false when nothing has been assigned\" do\n        before { instance.images = nil }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"false when an empty string has been assigned\" do\n        before { instance.images = '' }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"true when a file has been cached\" do\n        before { instance.images = [test_file_stub] }\n\n        it { is_expected.to be_truthy }\n      end\n    end\n\n    describe '#images_urls' do\n      subject(:images_urls) { instance.images_urls }\n\n      describe \"returns nil when nothing has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return(nil)\n        end\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"should return nil when an empty string has been assigned\" do\n        before do\n          allow(instance).to receive(:read_uploader).with(:images).and_return('')\n        end\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"gets the url from a retrieved file\" do\n        before do\n          allow(instance).to receive(:read_uploader).at_least(:once).with(:images).and_return(test_file_name)\n        end\n\n        it { expect(images_urls.first).to eq(\"/uploads/#{test_file_name}\") }\n      end\n\n      describe \"gets the url from a cached file\" do\n        before { instance.images = [test_file_stub] }\n\n        it { expect(images_urls[0]).to match(%r{uploads/tmp/[\\d\\-]+/test.jpg}) }\n      end\n\n      describe \"gets the url from a cached file's version\" do\n        before do\n          uploader.version(:thumb)\n          instance.images = [test_file_stub]\n        end\n\n        it { expect(instance.images_urls(:thumb)[0]).to match(%r{uploads/tmp/[\\d\\-]+/thumb_test.jpg}) }\n      end\n    end\n\n    describe '#images_cache' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"when nothing has been assigned\" do\n        it { expect(instance.images_cache).to be_nil }\n      end\n\n      context \"when a file has been stored\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n        end\n\n        it { expect(instance.images_cache).to be_nil }\n      end\n\n      context \"when a file has been cached\" do\n        let(:json_response) { JSON.parse(instance.images_cache) }\n\n        before do\n          instance.images = [test_file_stub, stub_file('old.jpeg')]\n        end\n\n        it { expect(json_response[0]).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/test\\.jpg$)) }\n\n        it { expect(json_response[1]).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/old\\.jpeg$)) }\n      end\n    end\n\n    describe '#images_cache=' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n        CarrierWave::SanitizedFile.new(test_file_stub).copy_to(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      context \"does nothing when nil is assigned\" do\n        before { instance.images_cache = nil }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"does nothing when an empty string is assigned\" do\n        before { instance.images_cache = '' }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"retrieve from cache when a cache name is assigned\" do\n        before { instance.images_cache = ['1369894322-123-0123-1234/test.jpg'].to_json }\n\n        it { expect(instance.images[0].current_path).to eq(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg')) }\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n        end\n      end\n\n      context \"writes over a previously stored file\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n          instance.images_cache = ['1369894322-123-0123-1234/monkey.jpg'].to_json\n        end\n\n        it { expect(instance.images[0].current_path).to match(/monkey.jpg$/) }\n      end\n\n      context \"doesn't write over a previously assigned file\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.images_cache = ['1369894322-123-0123-1234/monkey.jpg'].to_json\n        end\n\n        it { expect(instance.images[0].current_path).to match(/test.jpg$/) }\n      end\n\n      context \"when valid and invalid cache names are assigned\" do\n        before { instance.images_cache = ['1369894322-123-0123-1234/test.jpg', 'invalid'].to_json }\n\n        it \"retrieves valid file only from cache\" do\n          expect(instance.images.map(&:cache_name)).to eq(['1369894322-123-0123-1234/test.jpg'])\n        end\n      end\n\n      context \"when an empty string is assigned\" do\n        before do\n          instance.images = [test_file_stub]\n          instance.store_images!\n          instance.images_cache = [''].to_json\n        end\n\n        it \"does not write over a previously stored file\" do\n          expect(instance.images[0].current_path).to match(/test.jpg$/)\n        end\n      end\n    end\n\n    describe \"#remote_images_urls\" do\n      subject { instance.remote_images_urls }\n\n      before { stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub)) }\n\n      context \"returns nil\" do\n        it { is_expected.to be_nil }\n      end\n\n      context \"returns previously cached URL\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/test.jpg\"] }\n\n        it { is_expected.to eq([\"http://www.example.com/test.jpg\"]) }\n      end\n    end\n\n    describe \"#remote_images_urls=\" do\n      subject(:images) { instance.images }\n\n      before do\n        stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n        stub_request(:get, \"http://www.example.com/test.txt\").to_return(status: 404)\n        instance.remote_images_urls = remote_images_url\n      end\n\n      context \"does nothing when nil is assigned\" do\n        let(:remote_images_url) { nil }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"does nothing when an empty string is assigned\" do\n        let(:remote_images_url) { '' }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"retrieves from cache when a cache name is assigned\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        it { is_expected.to match(/test.jpg$/) }\n\n        it \"marks the uploader as staged\" do\n          expect(instance.images[0].staged).to be true\n        end\n      end\n\n      context \"writes over a previously stored file\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.store_images!\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it { is_expected.to match(/test.jpg$/) }\n      end\n\n      context \"does not write over a previously assigned file\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"http://www.example.com/test.jpg\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it { is_expected.to match(/portrait.jpg$/) }\n      end\n\n      context \"when an empty string is assigned\" do\n        subject { images[0].current_path }\n\n        let(:remote_images_url) { [\"\"] }\n\n        before do\n          instance.images = [stub_file(\"portrait.jpg\")]\n          instance.store_images!\n          instance.remote_images_urls = remote_images_url\n        end\n\n        it \"does not write over a previously stored file\" do\n          is_expected.to match(/portrait.jpg$/)\n        end\n      end\n\n      context \"if a file fails to be downloaded\" do\n        let(:remote_images_url) { [\"http://www.example.com/test.txt\", \"http://www.example.com/test.jpg\"] }\n\n        it \"keeps files which was downloaded successfully\" do\n          expect(instance.images.map(&:identifier)).to eq ['test.jpg']\n        end\n      end\n    end\n\n    describe '#store_images!' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"does nothing when no file has been uploaded\" do\n        before { instance.store_images! }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"stores an assigned file\" do\n        let(:images) { [test_file_stub] }\n\n        before do\n          instance.images = images\n          instance.store_images!\n        end\n\n        it { expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\")) }\n\n        it \"marks the uploader as unstaged\" do\n          expect(instance.images[0].staged).to be false\n        end\n      end\n    end\n\n    describe '#remove_images!' do\n      before do\n        allow(instance).to receive(:write_uploader)\n        allow(instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      context \"does nothing when no file has been uploaded\" do\n        before { instance.remove_images! }\n\n        it { expect(instance.images).to be_empty }\n      end\n\n      context \"removes an uploaded file\" do\n        before do\n          instance.images = [test_file_stub]\n          @image_path = instance.images[0].current_path\n          instance.remove_images!\n        end\n\n        it { expect(instance.images).to be_empty }\n\n        it { expect(File.exist?(@image_path)).to be_falsey }\n      end\n    end\n\n    describe '#remove_images' do\n      before { instance.remove_images = true }\n\n      it \"stores a value\" do\n        expect(instance.remove_images).to be_truthy\n      end\n    end\n\n    describe '#remove_images?' do\n      subject { instance.remove_images? }\n\n      let(:remove_images) { true }\n\n      before { instance.remove_images = remove_images }\n\n      it \"when value is true\" do\n        is_expected.to be_truthy\n      end\n\n      context \"when value is false\" do\n        let(:remove_images) { false }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is ''\" do\n        let(:remove_images) { '' }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is 0\" do\n        let(:remove_images) { \"0\" }\n\n        it { is_expected.to be_falsey }\n      end\n\n      context \"when value is false\" do\n        let(:remove_images) { 'false' }\n\n        it { is_expected.to be_falsey }\n      end\n    end\n\n    describe '#images_integrity_errors' do\n      subject(:images_integrity_errors) { instance.images_integrity_errors }\n\n      describe \"default behaviour\" do\n        it { is_expected.to be_empty }\n      end\n\n      context \"when a file is cached\" do\n        before { instance.images = test_file_stub }\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"when an integrity check fails\" do\n        before do\n          uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        context \"when file is cached\" do\n          before { instance.images = [test_file_stub] }\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n\n        context \"when file was downloaded\" do\n          before do\n            stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n            instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n\n        context \"when file is assigned and remote_iamges_url is blank\" do\n          before do\n            instance.images = [test_file_stub]\n            instance.remote_images_urls = \"\"\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::IntegrityError)) }\n\n          it \"has an error message\" do\n            expect(images_integrity_errors[0].message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n          end\n        end\n      end\n    end\n\n    describe '#images_processing_errors' do\n      subject(:images_processing_errors) { instance.images_processing_errors }\n\n      describe \"default behavior\" do\n        it { is_expected.to be_empty }\n      end\n\n      context \"when file is cached\" do\n        before { instance.images = [test_file_stub] }\n\n        it { is_expected.to be_empty }\n      end\n\n      describe \"when an processing error occurs\" do\n        before do\n          uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n        end\n\n        context \"when file is cached\" do\n          before { instance.images = [test_file_stub] }\n\n          it { is_expected.to include(a_kind_of(CarrierWave::ProcessingError)) }\n        end\n\n        context \"when file was downloaded\" do\n          before do\n            stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n            instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]\n          end\n\n          it { is_expected.to include(a_kind_of(CarrierWave::ProcessingError)) }\n        end\n      end\n    end\n\n    describe '#images_download_errors' do\n      subject(:images_download_errors) { instance.images_download_errors }\n\n      before do\n        stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: File.read(test_file_stub))\n        stub_request(:get, \"http://www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      describe \"default behaviour\" do\n        it { expect(instance.images_download_errors).to be_empty }\n      end\n\n      context \"when file download was successful\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"] }\n\n        it { is_expected.to be_empty }\n      end\n\n      context \"when file couldn't be found\" do\n        before { instance.remote_images_urls = [\"http://www.example.com/missing.jpg\"] }\n\n        it { is_expected.to include(a_kind_of(CarrierWave::DownloadError)) }\n      end\n    end\n\n    describe '#write_images_identifier' do\n      after { instance.write_images_identifier }\n\n      it \"writes to the column\" do\n        expect(instance).to receive(:write_uploader).with(:images, [test_file_name]).at_least(:once)\n        instance.images = [test_file_stub]\n        instance.write_images_identifier\n      end\n\n      context \"when remove_images is true\" do\n        before do\n          instance.images = [test_file_name]\n          instance.store_images!\n          instance.remove_images = true\n        end\n\n        it \"clears existing uploaders\" do\n          expect(instance.images).to be_empty\n        end\n\n        it \"removes from the column\" do\n          expect(instance).to receive(:write_uploader).with(:images, nil)\n        end\n      end\n    end\n\n    describe '#images_identifiers' do\n      it \"returns the identifier from the mounted column\" do\n        expect(instance).to receive(:read_uploader).with(:images).and_return(test_file_name)\n        expect(instance.images_identifiers).to eq([test_file_name])\n      end\n    end\n  end\n\n  describe '#mount_uploaders without an uploader' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images)\n      end\n    end\n\n    let(:instance) { klass.new }\n\n    describe '#images' do\n      before do\n        allow(instance).to receive(:read_uploader).and_return(test_file_name)\n      end\n\n      it \"returns an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(instance.images[0]).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"sets the path to the store dir\" do\n        expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\"))\n      end\n    end\n  end\n\n  describe '#mount_uploaders with a block' do\n    describe 'and no uploader given' do\n      subject(:last_image) { instance.images[0] }\n\n      let(:klass) do\n        Class.new do |k|\n          k.send(:extend, CarrierWave::Mount)\n          k.mount_uploaders(:images) do\n            def monkey\n              'blah'\n            end\n          end\n        end\n      end\n\n      before { instance.images = [test_file_stub] }\n\n      it \"returns an instance of a subclass of CarrierWave::Uploader::Base\" do\n        is_expected.to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"applies any custom modifications\" do\n        expect(last_image.monkey).to eq(\"blah\")\n      end\n    end\n\n    describe 'and an uploader given' do\n      let!(:uploader) do\n        Class.new(CarrierWave::Uploader::Base).tap do |u|\n          u.version :thumb do\n            version :mini\n            version :maxi\n          end\n        end\n      end\n\n      let(:klass) do\n        Class.new.tap do |k|\n          k.send(:extend, CarrierWave::Mount)\n          k.mount_uploaders(:images, uploader) do\n            def fish\n              'blub'\n            end\n          end\n        end\n      end\n\n      let(:first_image) { instance.images[0] }\n\n      before { instance.images = [test_file_stub] }\n\n      it \"returns an instance of the uploader specified\" do\n        expect(first_image).to be_a_kind_of(uploader)\n      end\n\n      it \"applies any custom modifications to the instance\" do\n        expect(first_image.fish).to eq(\"blub\")\n      end\n\n      it \"applies any custom modifications to all defined versions\" do\n        expect(first_image.thumb.fish).to eq(\"blub\")\n        expect(first_image.thumb.mini.fish).to eq(\"blub\")\n        expect(first_image.thumb.maxi.fish).to eq(\"blub\")\n      end\n\n      it \"applies any custom modifications to the uploader class\" do\n        expect(uploader.new).not_to respond_to(:fish)\n      end\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_integrity_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, :ignore_integrity_errors => false)\n      end\n    end\n\n    let(:uploader) do\n      Class.new(CarrierWave::Uploader::Base).tap do |u|\n        u.class_eval do\n          def extension_whitelist\n            %w(txt)\n          end\n        end\n      end\n    end\n\n    context \"when a cached image fails an integrity check\" do\n      it { expect(running { instance.images = [test_file_stub] }).to raise_error(CarrierWave::IntegrityError) }\n    end\n\n    context \"when a downloaded image fails an integity check\" do\n      before do\n        stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: test_file_stub)\n      end\n\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::IntegrityError) }\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_processing_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, :ignore_processing_errors => false)\n      end\n    end\n\n    let(:uploader) do\n      Class.new(CarrierWave::Uploader::Base).tap do |u|\n        u.class_eval do\n          process :monkey\n          def monkey\n            raise CarrierWave::ProcessingError, \"Ohh noez!\"\n          end\n        end\n      end\n    end\n\n    context \"when a cached image fails an integrity check\" do\n      it { expect(running { instance.images = [test_file_stub] }).to raise_error(CarrierWave::ProcessingError) }\n    end\n\n    context \"when a downloaded image fails an integity check\" do\n      before do\n        stub_request(:get, \"http://www.example.com/#{test_file_name}\").to_return(body: test_file_stub)\n      end\n\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::ProcessingError) }\n    end\n  end\n\n  describe '#mount_uploaders with :ignore_download_errors => false' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, ignore_download_errors: false)\n      end\n    end\n\n    let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n\n    before do\n      uploader.class_eval do\n        def download! uri, headers = {}\n          raise CarrierWave::DownloadError\n        end\n      end\n    end\n\n    context \"when the image fail to be processed\" do\n      it { expect(running {instance.remote_images_urls = [\"http://www.example.com/#{test_file_name}\"]}).to raise_error(CarrierWave::DownloadError) }\n    end\n  end\n\n  describe '#mount_uploaders with :mount_on => :monkey' do\n    let(:klass) do\n      Class.new.tap do |k|\n        k.send(:extend, CarrierWave::Mount)\n        k.mount_uploaders(:images, uploader, mount_on: :monkey)\n      end\n    end\n\n    let(:uploader) { Class.new(CarrierWave::Uploader::Base) }\n\n    describe '#images' do\n      context \"when a value is store in the database\" do\n        it \"retrieves a file from the storage\" do\n          expect(instance).to receive(:read_uploader).at_least(:once).with(:monkey).and_return([test_file_name])\n          expect(instance.images[0]).to be_an_instance_of(uploader)\n          expect(instance.images[0].current_path).to eq(public_path(\"uploads/#{test_file_name}\"))\n        end\n      end\n    end\n\n    describe '#write_images_identifier' do\n      it \"writes to the given column\" do\n        expect(instance).to receive(:write_uploader).with(:monkey, [test_file_name])\n        instance.images = [test_file_stub]\n        instance.write_images_identifier\n      end\n\n      it \"removes from the given column when remove_images is true\" do\n        instance.images = [test_file_stub]\n        instance.store_images!\n        instance.remove_images = true\n        expect(instance).to receive(:write_uploader).with(:monkey, nil)\n        instance.write_images_identifier\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Mount do\n\n  after do\n    FileUtils.rm_rf(public_path)\n  end\n\n  describe '.mount_uploader' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader)\n      @instance = @class.new\n    end\n\n    it \"should maintain the ability to super\" do\n      @class.class_eval do\n        def image_uploader\n          super\n        end\n\n        def image=(val)\n          super\n        end\n      end\n\n      @instance.image = stub_file('test.jpg')\n      expect(@instance.image).to be_an_instance_of(@uploader)\n    end\n\n    it \"should inherit uploaders to subclasses\" do\n      @subclass = Class.new(@class)\n      @subclass_instance = @subclass.new\n      @subclass_instance.image = stub_file('test.jpg')\n      expect(@subclass_instance.image).to be_an_instance_of(@uploader)\n    end\n\n    it \"should allow marshalling uploaders and versions\" do\n      Object.const_set(\"MyClass#{@class.object_id}\".tr('-', '_'), @class)\n      Object.const_set(\"Uploader#{@uploader.object_id}\".tr('-', '_'), @uploader)\n      @uploader.class_eval do\n        def rotate\n        end\n      end\n      @uploader.version :thumb do\n        process :rotate\n      end\n      @instance.image = stub_file('test.jpg')\n      expect { Marshal.dump @instance.image }.not_to raise_error\n    end\n\n    describe \"expected behavior with subclassed uploaders\" do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @uploader1 = Class.new(CarrierWave::Uploader::Base)\n        @uploader1.process :rotate\n        @uploader1.version :thumb do\n          process :compress\n        end\n        @uploader2 = Class.new(@uploader1)\n        @uploader2.process :shrink\n        @uploader2.version :secret do\n          process :encrypt\n        end\n        @class.mount_uploader(:image1, @uploader1)\n        @class.mount_uploader(:image2, @uploader2)\n        @instance = @class.new\n      end\n\n      it \"should inherit defined versions\" do\n        expect(@instance.image1).to respond_to(:thumb)\n        expect(@instance.image2).to respond_to(:thumb)\n      end\n\n      it \"should not inherit versions defined in subclasses\" do\n        expect(@instance.image1).not_to respond_to(:secret)\n        expect(@instance.image2).to respond_to(:secret)\n      end\n\n      it \"should inherit defined processors properly\" do\n        expect(@uploader1.processors).to eq([[:rotate, [], nil]])\n        expect(@uploader2.processors).to eq([[:rotate, [], nil], [:shrink, [], nil]])\n        expect(@uploader1.versions[:thumb].processors).to eq([[:compress, [], nil]])\n        expect(@uploader2.versions[:thumb].processors).to eq([[:compress, [], nil]])\n        expect(@uploader2.versions[:secret].processors).to eq([[:encrypt, [], nil]])\n      end\n    end\n\n    describe '#image' do\n\n      it \"should return a blank uploader when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should return the same object every time when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image.object_id).to eq @instance.image.object_id\n      end\n\n      it \"should return a blank uploader when an empty string has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return('')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        expect(@instance).to receive(:read_uploader).with(:image).at_least(:once).and_return('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        expect(@instance).to receive(:read_uploader).with(:image).at_least(:once).and_return('test.jpg')\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n\n    end\n\n    describe '#image=' do\n\n      it \"should cache a file\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should copy a file into into the cache directory\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image.current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        expect(@instance).not_to receive(:write_uploader)\n        @instance.image = nil\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        expect(@instance).not_to receive(:write_uploader)\n        @instance.image = stub_file('test.jpg')\n      end\n\n      it \"should fail silently if the image fails a white list integrity check\" do\n        @uploader.class_eval do\n          def extension_whitelist\n            %w(txt)\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should fail silently if the image fails a black list integrity check\" do\n        @uploader.class_eval do\n          def extension_blacklist\n            %w(jpg)\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should fail silently if the image fails to be processed\" do\n        @uploader.class_eval do\n          process :monkey\n          def monkey\n            raise CarrierWave::ProcessingError, \"Ohh noez!\"\n          end\n        end\n        @instance.image = stub_file('test.jpg')\n      end\n\n    end\n\n    describe '#image?' do\n\n      it \"should be false when nothing has been assigned\" do\n        @instance.image = nil\n        expect(@instance.image?).to be_falsey\n      end\n\n      it \"should be false when an empty string has been assigned\" do\n        @instance.image = ''\n        expect(@instance.image?).to be_falsey\n      end\n\n      it \"should be true when a file has been cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image?).to be_truthy\n      end\n\n    end\n\n    describe '#image_url' do\n\n      it \"should return nil when nothing has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image_url).to be_nil\n      end\n\n      it \"should return fallback url when nothing has been assigned\" do\n        @uploader.class_eval do\n          def default_url\n            \"foo/bar.jpg\"\n          end\n        end\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(nil)\n        expect(@instance.image_url).to eq(\"foo/bar.jpg\")\n      end\n\n      it \"should return nil when an empty string has been assigned\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return('')\n        expect(@instance.image_url).to be_nil\n      end\n\n      it \"should get the url from a retrieved file\" do\n        expect(@instance).to receive(:read_uploader).at_least(:once).with(:image).and_return('test.jpg')\n        expect(@instance.image_url).to eq('/uploads/test.jpg')\n      end\n\n      it \"should get the url from a cached file\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_url).to match(%r{uploads/tmp/[\\d\\-]+/test.jpg})\n      end\n\n      it \"should get the url from a cached file's version\" do\n        @uploader.version(:thumb)\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_url(:thumb)).to match(%r{uploads/tmp/[\\d\\-]+/thumb_test.jpg})\n      end\n\n    end\n\n    describe '#image_cache' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should return nil when nothing has been assigned\" do\n        expect(@instance.image_cache).to be_nil\n      end\n\n      it \"should be nil when a file has been stored\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image.store!\n        expect(@instance.image_cache).to be_nil\n      end\n\n      it \"should be the cache name when a file has been cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_cache).to match(%r(^[\\d]+\\-[\\d]+\\-[\\d]{4}\\-[\\d]{4}/test\\.jpg$))\n      end\n\n    end\n\n    describe '#image_cache=' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n        CarrierWave::SanitizedFile.new(file_path('test.jpg')).copy_to(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        @instance.image_cache = nil\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        @instance.image_cache = ''\n        expect(@instance.image).to be_blank\n      end\n\n      it \"retrieve from cache when a cache name is assigned\" do\n        @instance.image_cache = '1369894322-123-0123-1234/test.jpg'\n        expect(@instance.image.current_path).to eq(public_path('uploads/tmp/1369894322-123-0123-1234/test.jpg'))\n      end\n\n      it \"should not write over a previously assigned file\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image_cache = '1369894322-123-0123-1234/monkey.jpg'\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n\n      it \"should not clear a previously stored file when an empty string is assigned\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.image.store!\n        @instance.image_cache = ''\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n    end\n\n    describe \"#remote_image_url\" do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      it \"returns nil\" do\n        expect(@instance.remote_image_url).to be_nil\n      end\n\n      it \"returns previously cached URL\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.remote_image_url).to eq(\"http://www.example.com/test.jpg\")\n      end\n\n      describe \"URI with unicode symbols\" do\n        before do\n          stub_request(\n            :get,\n            \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          ).to_return(body: File.read(file_path(\"\u044e\u043d\u0438\u043a\u043e\u0434.jpg\")))\n        end\n\n        it \"works correctly\" do\n          @instance.remote_image_url = \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          expect(@instance.remote_image_url).to eq(\"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\")\n        end\n\n        it \"decodes it correctly\" do\n          @instance.remote_image_url = \"http://www.example.com/%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.jpg\"\n          expect(@instance.image.current_path).to match(/\u044e\u043d\u0438\u043a\u043e\u0434.jpg$/)\n        end\n      end\n    end\n\n    describe \"#remote_image_url=\" do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      it \"does nothing when nil is assigned\" do\n        @instance.remote_image_url = nil\n\n        expect(@instance.image).to be_blank\n      end\n\n      it \"does nothing when an empty string is assigned\" do\n        @instance.remote_image_url = \"\"\n\n        expect(@instance.image).to be_blank\n      end\n\n      it \"retrieves from cache when a cache name is assigned\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n\n      it \"does not write over a previously assigned file\" do\n        @instance.image = stub_file(\"portrait.jpg\")\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n        expect(@instance.image.current_path).to match(/portrait.jpg$/)\n      end\n\n      it \"does not clear a previously stored file when an empty string is assigned\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        @instance.image.store!\n        @instance.remote_image_url = \"\"\n        expect(@instance.image.current_path).to match(/test.jpg$/)\n      end\n    end\n\n    describe '#store_image!' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should do nothing when no file has been uploaded\" do\n        @instance.store_image!\n        expect(@instance.image).to be_blank\n      end\n\n      it \"store an assigned file\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n    end\n\n    describe '#remove_image!' do\n\n      before do\n        allow(@instance).to receive(:write_uploader)\n        allow(@instance).to receive(:read_uploader).and_return(nil)\n      end\n\n      it \"should do nothing when no file has been uploaded\" do\n        @instance.remove_image!\n        expect(@instance.image).to be_blank\n      end\n\n      it \"should remove an uploaded file\" do\n        @instance.image = stub_file('test.jpg')\n        path = @instance.image.current_path\n        @instance.remove_image!\n        expect(@instance.image).to be_blank\n        expect(File.exist?(path)).to be_falsey\n      end\n    end\n\n    describe '#remove_image' do\n\n      it \"should store a value\" do\n        @instance.remove_image = true\n        expect(@instance.remove_image).to be_truthy\n      end\n\n    end\n\n    describe '#remove_image?' do\n\n      it \"should be true when the value is truthy\" do\n        @instance.remove_image = true\n        expect(@instance.remove_image?).to be_truthy\n      end\n\n      it \"should be false when the value is falsey\" do\n        @instance.remove_image = false\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is ''\" do\n        @instance.remove_image = ''\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is '0'\" do\n        @instance.remove_image = '0'\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n      it \"should be false when the value is 'false'\" do\n        @instance.remove_image = 'false'\n        expect(@instance.remove_image?).to be_falsey\n      end\n\n    end\n\n    describe '#image_integrity_error' do\n\n      it \"should be nil by default\" do\n        expect(@instance.image_integrity_error).to be_nil\n      end\n\n      it \"should be nil after a file is cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_integrity_error).to be_nil\n      end\n\n      describe \"when an integrity check fails\" do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should be an error instance if file was cached\" do\n          @instance.image = stub_file('test.jpg')\n          e = @instance.image_integrity_error\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n\n        it \"should be an error instance if file was downloaded\" do\n          stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n          @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n          e = @instance.image_integrity_error\n\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n\n        it \"should be an error instance when image file is assigned and remote_image_url is blank\" do\n          @instance.image = stub_file('test.jpg')\n          @instance.remote_image_url = \"\"\n          e = @instance.image_integrity_error\n          expect(e).to be_an_instance_of(CarrierWave::IntegrityError)\n          expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy\n        end\n      end\n    end\n\n    describe '#image_processing_error' do\n\n      it \"should be nil by default\" do\n        expect(@instance.image_processing_error).to be_nil\n      end\n\n      it \"should be nil after a file is cached\" do\n        @instance.image = stub_file('test.jpg')\n        expect(@instance.image_processing_error).to be_nil\n      end\n\n      describe \"when an processing error occurs\" do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n        end\n\n        it \"should be an error instance if file was cached\" do\n          @instance.image = stub_file('test.jpg')\n          expect(@instance.image_processing_error).to be_an_instance_of(CarrierWave::ProcessingError)\n        end\n\n        it \"should be an error instance if file was downloaded\" do\n          stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n          @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n\n          expect(@instance.image_processing_error).to be_an_instance_of(CarrierWave::ProcessingError)\n        end\n      end\n    end\n\n    describe '#image_download_error' do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n        stub_request(:get, \"http://www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      it \"should be nil by default\" do\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be nil if file download was successful\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be an error instance if file could not be found\" do\n        @instance.remote_image_url = \"http://www.example.com/missing.jpg\"\n        expect(@instance.image_download_error).to be_an_instance_of(CarrierWave::DownloadError)\n      end\n    end\n\n    describe '#image_download_error' do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n        stub_request(:get, \"http://www.example.com/missing.jpg\").to_return(status: 404)\n      end\n\n      it \"should be nil by default\" do\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be nil if file download was successful\" do\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n        expect(@instance.image_download_error).to be_nil\n      end\n\n      it \"should be an error instance if file could not be found\" do\n        @instance.remote_image_url = \"http://www.example.com/missing.jpg\"\n        expect(@instance.image_download_error).to be_an_instance_of(CarrierWave::DownloadError)\n      end\n    end\n\n    describe '#write_image_identifier' do\n      it \"should write to the column\" do\n        expect(@instance).to receive(:write_uploader).with(:image, \"test.jpg\")\n        @instance.image = stub_file('test.jpg')\n        @instance.write_image_identifier\n      end\n\n      it \"should remove from the column when remove_image is true\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        @instance.remove_image = true\n        expect(@instance).to receive(:write_uploader).with(:image, nil)\n        @instance.write_image_identifier\n        expect(@instance.image).to be_blank\n      end\n    end\n\n    describe '#image_identifier' do\n      it \"should return the identifier from the mounted column\" do\n        expect(@instance).to receive(:read_uploader).with(:image).and_return(\"test.jpg\")\n        expect(@instance.image_identifier).to eq('test.jpg')\n      end\n    end\n\n  end\n\n  describe '#mount_uploader without an uploader' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n      @class.mount_uploader(:image)\n      @instance = @class.new\n    end\n\n    describe '#image' do\n\n      before do\n        allow(@instance).to receive(:read_uploader).and_return('test.jpg')\n      end\n\n      it \"should return an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(@instance.image).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"should set the path to the store dir\" do\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n\n    end\n\n  end\n\n  describe '#mount_uploader with a block' do\n    describe 'and no uploader given' do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @class.mount_uploader(:image) do\n          def monkey\n            'blah'\n          end\n        end\n        @instance = @class.new\n      end\n\n      it \"should return an instance of a subclass of CarrierWave::Uploader::Base\" do\n        expect(@instance.image).to be_a(CarrierWave::Uploader::Base)\n      end\n\n      it \"should apply any custom modifications\" do\n        expect(@instance.image.monkey).to eq(\"blah\")\n      end\n    end\n\n    describe 'and an uploader given' do\n      before do\n        @class = Class.new\n        @class.send(:extend, CarrierWave::Mount)\n        @uploader = Class.new(CarrierWave::Uploader::Base)\n        @uploader.version :thumb do\n          version :mini\n          version :maxi\n        end\n        @class.mount_uploader(:image, @uploader) do\n          def fish\n            'blub'\n          end\n        end\n        @instance = @class.new\n      end\n\n      it \"should return an instance of the uploader specified\" do\n        expect(@instance.image).to be_a_kind_of(@uploader)\n      end\n\n      it \"should apply any custom modifications to the instance\" do\n        expect(@instance.image.fish).to eq(\"blub\")\n      end\n\n      it \"should apply any custom modifications to all defined versions\" do\n        expect(@instance.image.thumb.fish).to eq(\"blub\")\n        expect(@instance.image.thumb.mini.fish).to eq(\"blub\")\n        expect(@instance.image.thumb.maxi.fish).to eq(\"blub\")\n      end\n\n      it \"should not apply any custom modifications to the uploader class\" do\n        expect(@uploader.new).not_to respond_to(:fish)\n      end\n    end\n  end\n\n  describe '#mount_uploader with :ignore_integrity_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_integrity_errors => false)\n      @instance = @class.new\n\n      @uploader.class_eval do\n        def extension_whitelist\n          %w(txt)\n        end\n      end\n    end\n\n    it \"should raise an error if the image fails an integrity check when cached\" do\n      expect(running {\n        @instance.image = stub_file('test.jpg')\n      }).to raise_error(CarrierWave::IntegrityError)\n    end\n\n    it \"should raise an error if the image fails an integrity check when downloaded\" do\n      stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::IntegrityError)\n    end\n  end\n\n  describe '#mount_uploader with :ignore_processing_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_processing_errors => false)\n      @instance = @class.new\n\n      @uploader.class_eval do\n        process :monkey\n        def monkey\n          raise CarrierWave::ProcessingError, \"Ohh noez!\"\n        end\n      end\n    end\n\n    it \"should raise an error if the image fails to be processed when cached\" do\n      expect(running {\n        @instance.image = stub_file('test.jpg')\n      }).to raise_error(CarrierWave::ProcessingError)\n    end\n\n    it \"should raise an error if the image fails to be processed when downloaded\" do\n      stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::ProcessingError)\n    end\n\n  end\n\n  describe '#mount_uploader with :ignore_download_errors => false' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :ignore_download_errors => false)\n      @instance = @class.new\n    end\n\n    it \"should raise an error if the image fails to be processed\" do\n      @uploader.class_eval do\n        def download! uri, headers = {}\n          raise CarrierWave::DownloadError\n        end\n      end\n\n      expect(running {\n        @instance.remote_image_url = \"http://www.example.com/test.jpg\"\n      }).to raise_error(CarrierWave::DownloadError)\n    end\n\n  end\n\n  describe '#mount_uploader with :mount_on => :monkey' do\n\n    before do\n      @class = Class.new\n      @class.send(:extend, CarrierWave::Mount)\n\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n\n      @class.mount_uploader(:image, @uploader, :mount_on => :monkey)\n      @instance = @class.new\n    end\n\n    describe '#image' do\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        expect(@instance).to receive(:read_uploader).at_least(:once).with(:monkey).and_return('test.jpg')\n        expect(@instance.image).to be_an_instance_of(@uploader)\n        expect(@instance.image.current_path).to eq(public_path('uploads/test.jpg'))\n      end\n    end\n\n    describe '#write_image_identifier' do\n      it \"should write to the given column\" do\n        expect(@instance).to receive(:write_uploader).with(:monkey, \"test.jpg\")\n        @instance.image = stub_file('test.jpg')\n        @instance.write_image_identifier\n      end\n\n      it \"should remove from the given column when remove_image is true\" do\n        @instance.image = stub_file('test.jpg')\n        @instance.store_image!\n        @instance.remove_image = true\n        expect(@instance).to receive(:write_uploader).with(:monkey, nil)\n        @instance.write_image_identifier\n      end\n    end\n\n  end\n\nend\n", "require 'spec_helper'\nrequire 'support/activerecord'\n\ndef create_table(name)\n  ActiveRecord::Base.connection.create_table(name, force: true) do |t|\n    t.column :image, :string\n    t.column :images, :json\n    t.column :textfile, :string\n    t.column :textfiles, :json\n    t.column :foo, :string\n  end\nend\n\ndef drop_table(name)\n  ActiveRecord::Base.connection.drop_table(name)\nend\n\ndef reset_class(class_name)\n  Object.send(:remove_const, class_name) rescue nil\n  Object.const_set(class_name, Class.new(ActiveRecord::Base))\nend\n\ndescribe CarrierWave::ActiveRecord do\n  before(:all) { create_table(\"events\") }\n  after(:all) { drop_table(\"events\") }\n\n  before do\n    @uploader = Class.new(CarrierWave::Uploader::Base)\n    reset_class(\"Event\")\n    @event = Event.new\n  end\n\n  after do\n    Event.delete_all\n  end\n\n  describe '#mount_uploader' do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    describe '#image' do\n\n      it \"should return blank uploader when nothing has been assigned\" do\n        expect(@event.image).to be_blank\n      end\n\n      it \"should return blank uploader when an empty string has been assigned\" do\n        @event[:image] = ''\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_blank\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should return valid JSON when to_json is called when image is nil\" do\n        expect(@event[:image]).to be_nil\n        hash = JSON.parse(@event.to_json)\n        expect(hash.keys).to include(\"image\")\n        expect(hash[\"image\"].keys).to include(\"url\")\n        expect(hash[\"image\"][\"url\"]).to be_nil\n      end\n\n      it \"should return valid JSON when to_json is called when image is present\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse(@event.to_json)[\"image\"]).to eq({\"url\" => \"/uploads/test.jpeg\"})\n      end\n\n      it \"should return valid JSON when to_json is called on a collection containing uploader from a model\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse({:data => @event.image}.to_json)).to eq({\"data\"=>{\"url\"=>\"/uploads/test.jpeg\"}})\n      end\n\n      it \"should return valid XML when to_xml is called when image is nil\" do\n        hash = Hash.from_xml(@event.to_xml)[\"event\"]\n\n        expect(@event[:image]).to be_nil\n        expect(hash.keys).to include(\"image\")\n        expect(hash[\"image\"].keys).to include(\"url\")\n        expect(hash[\"image\"][\"url\"]).to be_nil\n      end\n\n      it \"should return valid XML when to_xml is called when image is present\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml)[\"event\"][\"image\"]).to eq({\"url\" => \"/uploads/test.jpeg\"})\n      end\n\n      it \"should respect options[:only] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:except] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:except => [:id, :image, :images, :textfiles, :foo])).to eq({\"textfile\" => nil})\n      end\n      it \"should respect both options[:only] and options[:except] when passed to as_json for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo], :except => [:id])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:only] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"should respect options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(except: [:image]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"should respect both options[:only] and options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:image] = 'test.jpeg'\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo], except: [:id]))[\"event\"][\"image\"]).to be_nil\n      end\n\n      it \"resets cached value on record reload\" do\n        @event.image = CarrierWave::SanitizedFile.new(stub_file('new.jpeg', 'image/jpeg'))\n        @event.save!\n\n        expect(@event.reload.image).to be_present\n\n        Event.find(@event.id).update_column(:image, nil)\n\n        expect(@event.reload.image).to be_blank\n      end\n\n      context \"with CarrierWave::MiniMagick\" do\n        before(:each) do\n          @uploader.send(:include, CarrierWave::MiniMagick)\n        end\n\n        it \"has width and height\" do\n          @event.image = stub_file('landscape.jpg')\n          expect(@event.image.width).to eq 640\n          expect(@event.image.height).to eq 480\n        end\n      end\n\n      context \"with CarrierWave::RMagick\", :rmagick => true do\n        before(:each) do\n          @uploader.send(:include, CarrierWave::RMagick)\n        end\n\n        it \"has width and height\" do\n          @event.image = stub_file('landscape.jpg')\n          expect(@event.image.width).to eq 640\n          expect(@event.image.height).to eq 480\n        end\n      end\n    end\n\n    describe '#image=' do\n\n      it \"should cache a file\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.image).to be_an_instance_of(@uploader)\n      end\n\n      it \"should write nothing to the database, to prevent overriden filenames to fail because of unassigned attributes\" do\n        expect(@event[:image]).to be_nil\n      end\n\n      it \"should copy a file into the cache directory\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.image.current_path).to match(%r(^#{public_path('uploads/tmp')}))\n      end\n\n      context \"when empty string is assigned\" do\n        it \"does nothing when\" do\n          @event.image = ''\n          expect(@event.image).to be_blank\n        end\n\n        context \"and the previous value was an empty string\" do\n          before do\n            @event.image = \"\"\n            @event.save\n          end\n\n          it \"does not write to dirty changes\" do\n            @event.image = ''\n            expect(@event.changes.keys).not_to include(\"image\")\n          end\n        end\n\n      end\n\n      context \"when nil is assigned\" do\n        it \"does nothing\" do\n          @event.image = nil\n          expect(@event.image).to be_blank\n        end\n\n        context \"and the previous value was nil\" do\n          before do\n            @event.image = nil\n            @event.save\n          end\n\n          it \"does not write to dirty changes\" do\n            @event.image = nil\n            expect(@event.changes.keys).not_to include(\"image\")\n          end\n        end\n      end\n\n\n      context 'when validating white list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_whitelist_error => \"Het opladen van %{extension} bestanden is niet toe gestaan. Geaccepteerde types: %{allowed_types}\"\n            }\n          }) do\n            # Assigning image triggers check_whitelist! and thus should be inside change_locale_and_store_translations\n            @event.image = stub_file('test.jpg')\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:image]).to eq (['Het opladen van \"jpg\" bestanden is niet toe gestaan. Geaccepteerde types: txt'])\n          end\n        end\n      end\n\n      context 'when validating black list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_blacklist_error => \"You are not allowed to upload %{extension} files, prohibited types: %{prohibited_types}\"\n            }\n          }) do\n            # Assigning image triggers check_blacklist! and thus should be inside change_locale_and_store_translations\n            @event.image = stub_file('test.jpg')\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:image]).to eq(['You are not allowed to upload \"jpg\" files, prohibited types: jpg'])\n          end\n        end\n      end\n\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError\n            end\n          end\n          @event.image = stub_file('test.jpg')\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for processing errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['failed to be processed'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagem.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['falha ao processar imagem.'])\n          end\n        end\n      end\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n          @event.image = stub_file('test.jpg')\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use the error's messages for processing errors with messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['Ohh noez!'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagem.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['Ohh noez!'])\n          end\n        end\n      end\n    end\n\n    describe '#save' do\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_blank\n      end\n\n      it \"should copy the file to the upload directory when a file has been assigned\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should do nothing when a validation fails\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.image = stub_file('test.jpeg')\n\n        expect(@event.save).to be_falsey\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should assign the filename to the database\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        @event.reload\n        expect(@event[:image]).to eq('test.jpeg')\n        expect(@event.image_identifier).to eq('test.jpeg')\n      end\n\n      it \"should preserve the image when nothing is assigned\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n\n        @event = Event.find(@event.id)\n        @event.foo = \"bar\"\n\n        expect(@event.save).to be_truthy\n        expect(@event[:image]).to eq('test.jpeg')\n        expect(@event.image_identifier).to eq('test.jpeg')\n      end\n\n      it \"should remove the image if remove_image? returns true\" do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n        @event.remove_image = true\n        @event.save!\n        @event.reload\n        expect(@event.image).to be_blank\n        expect(@event[:image]).to eq(nil)\n        expect(@event.image_identifier).to eq(nil)\n      end\n\n      it \"should mark image as changed when saving a new image\" do\n        expect(@event.image_changed?).to be_falsey\n        @event.image = stub_file(\"test.jpeg\")\n        expect(@event.image_changed?).to be_truthy\n        @event.save\n        @event.reload\n        expect(@event.image_changed?).to be_falsey\n        @event.image = stub_file(\"test.jpg\")\n        expect(@event.image_changed?).to be_truthy\n        expect(@event.changed_for_autosave?).to be_truthy\n      end\n    end\n\n    describe \"image?\" do\n      it \"returns true when the file is cached\" do\n        @event.image = stub_file('test.jpg')\n\n        expect(@event.image?).to be_truthy\n      end\n\n      it \"returns false when the file is removed\" do\n        @event.remove_image!\n        @event.save!\n\n        expect(@event.image?).to be_falsey\n      end\n\n      it \"returns true when the file is stored\" do\n        @event.image = stub_file('test.jpg')\n        @event.save!\n\n        expect(@event.image?).to be_truthy\n      end\n\n      it \"returns true when a file is removed and stored again\" do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n        @event.remove_image!\n        @event.save!\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n\n        expect(@event.image?).to be_truthy\n      end\n    end\n\n    describe \"remove_image!\" do\n      before do\n        @event.image = stub_file('test.jpeg')\n        @event.save!\n      end\n\n      it \"should clear the serialization column\" do\n        @event.remove_image!\n\n        expect(@event.attributes['image']).to be_blank\n      end\n\n      it \"resets remove_image? to false\" do\n        @event.remove_image = true\n\n        expect {\n          @event.remove_image!\n        }.to change {\n          @event.remove_image?\n        }.from(true).to(false)\n      end\n    end\n\n    describe \"remove_image=\" do\n      it \"should mark the image as changed if changed\" do\n        expect(@event.image_changed?).to be_falsey\n        expect(@event.remove_image).to be_nil\n        @event.remove_image = \"1\"\n        expect(@event.image_changed?).to be_truthy\n      end\n    end\n\n    describe \"#remote_image_url=\" do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      # FIXME ideally image_changed? and remote_image_url_changed? would return true\n      it \"should mark image as changed when setting remote_image_url\" do\n        expect(@event.image_changed?).to be_falsey\n        @event.remote_image_url = 'http://www.example.com/test.jpg'\n        expect(@event.image_changed?).to be_truthy\n        @event.save!\n        @event.reload\n        expect(@event.image_changed?).to be_falsey\n      end\n\n      context 'when validating download' do\n        before do\n          @uploader.class_eval do\n            def download! file, headers = {}\n              raise CarrierWave::DownloadError\n            end\n          end\n          @event.remote_image_url = 'http://www.example.com/missing.jpg'\n        end\n\n        it \"should make the record invalid when a download error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for download errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:image]).to eq(['could not be downloaded'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_download_error => 'n\u00e3o pode ser descarregado'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:image]).to eq(['n\u00e3o pode ser descarregado'])\n          end\n        end\n      end\n\n    end\n\n    describe '#destroy' do\n\n      it \"should not raise an error with a custom filename\" do\n        @uploader.class_eval do\n          def filename\n            \"page.jpeg\"\n          end\n        end\n\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect {\n          @event.destroy\n        }.to_not raise_error\n      end\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        @event.destroy\n      end\n\n      it \"should remove the file from the filesystem\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(@event.image).to be_an_instance_of(@uploader)\n        expect(@event.image.current_path).to eq public_path('uploads/test.jpeg')\n        @event.destroy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n\n    end\n\n    describe 'with overriddent filename' do\n\n      describe '#save' do\n\n        before do\n          @uploader.class_eval do\n            def filename\n              model.name + File.extname(super)\n            end\n          end\n          allow(@event).to receive(:name).and_return('jonas')\n        end\n\n        it \"should copy the file to the upload directory when a file has been assigned\" do\n          @event.image = stub_file('test.jpeg')\n          expect(@event.save).to be_truthy\n          expect(@event.image).to be_an_instance_of(@uploader)\n          expect(@event.image.current_path).to eq(public_path('uploads/jonas.jpeg'))\n        end\n\n        it \"should assign an overridden filename to the database\" do\n          @event.image = stub_file('test.jpeg')\n          expect(@event.save).to be_truthy\n          @event.reload\n          expect(@event[:image]).to eq('jonas.jpeg')\n        end\n\n      end\n\n    end\n\n    describe 'with validates_presence_of' do\n\n      before do\n        Event.validates_presence_of :image\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has not been cached\" do\n        expect(@event).to_not be_valid\n      end\n\n    end\n\n    describe 'with validates_size_of' do\n\n      before do\n        Event.validates_size_of :image, maximum: 40\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached that matches the size criteria\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has been cached that does not match the size criteria\" do\n        @event.image = stub_file('bork.txt')\n        expect(@event).to_not be_valid\n      end\n\n    end\n  end\n\n  describe '#mount_uploader with mount_on' do\n    describe '#avatar=' do\n      it \"should cache a file\" do\n        reset_class(\"Event\")\n        Event.mount_uploader(:avatar, @uploader, mount_on: :image)\n        @event = Event.new\n        @event.avatar = stub_file('test.jpeg')\n        @event.save\n        @event.reload\n\n        expect(@event.avatar).to be_an_instance_of(@uploader)\n        expect(@event.image).to eq('test.jpeg')\n      end\n\n    end\n  end\n\n  describe '#mount_uploader removing old files' do\n    before do\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    describe 'normally' do\n      it \"should remove old file if old file had a different path\" do\n        @event.image = stub_file('new.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      end\n\n      it \"should not remove old file if old file had a different path but config is false\" do\n        @uploader.remove_previously_stored_files_after_update = false\n        @event.image = stub_file('new.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if old file had the same path\" do\n        @event.image = stub_file('old.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if validations fail on save\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.image = stub_file('new.jpeg')\n\n        expect(@event.save).to be_falsey\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should only delete the file once when the file is removed\" do\n        @event.remove_image = true\n        expect_any_instance_of(CarrierWave::SanitizedFile).to receive(:delete).exactly(1).times\n        expect(@event.save).to be_truthy\n      end\n    end\n\n    describe 'with an overriden filename' do\n      before do\n        @uploader.class_eval do\n          def filename\n            model.foo + File.extname(super)\n          end\n        end\n\n        @event.image = stub_file('old.jpeg')\n        @event.foo = 'test'\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n        expect(@event.image.read).to eq('this is stuff')\n      end\n\n      it \"should not remove file if old file had the same dynamic path\" do\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n      end\n\n      it \"should remove old file if old file had a different dynamic path\" do\n        @event.foo = \"new\"\n        @event.image = stub_file('test.jpeg')\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n    end\n  end\n\n  describe '#mount_uploader removing old files with versions' do\n    before do\n      @uploader.version :thumb\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.image = stub_file('new.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.image = stub_file('old.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    it 'should not remove old file if transaction is rollback' do\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n        raise ActiveRecord::Rollback\n      end\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe \"#mount_uploader into transaction\" do\n    before do\n      @uploader.version :thumb\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      @event = Event.new\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should not store file during rollback\" do\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n\n        raise ActiveRecord::Rollback\n      end\n\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_falsey\n    end\n\n    it \"should not change file during rollback\" do\n      @event.image = stub_file('old.jpeg')\n      @event.save\n\n      Event.transaction do\n        @event.image = stub_file('new.jpeg')\n        @event.save\n\n        raise ActiveRecord::Rollback\n      end\n\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploader removing old files with multiple uploaders' do\n    before do\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n      @uploader1 = Class.new(CarrierWave::Uploader::Base)\n      reset_class(\"Event\")\n      Event.mount_uploader(:image, @uploader)\n      Event.mount_uploader(:textfile, @uploader1)\n      @event = Event.new\n      @event.image = stub_file('old.jpeg')\n      @event.textfile = stub_file('old.txt')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file1 and file2 if old file1 and file2 had a different paths\" do\n      @event.image = stub_file('new.jpeg')\n      @event.textfile = stub_file('new.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/new.txt'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_falsey\n    end\n\n    it \"should remove old file1 but not file2 if old file1 had a different path but old file2 has the same path\" do\n      @event.image = stub_file('new.jpeg')\n      @event.textfile = stub_file('old.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    it \"should not remove file1 or file2 if file1 and file2 have the same paths\" do\n      @event.image = stub_file('old.jpeg')\n      @event.textfile = stub_file('old.txt')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploader removing old files with with mount_on' do\n    before do\n      reset_class(\"Event\")\n      Event.mount_uploader(:avatar, @uploader, mount_on: :image)\n      @event = Event.new\n      @event.avatar = stub_file('old.jpeg')\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.avatar = stub_file('new.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.avatar = stub_file('old.jpeg')\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders' do\n    before do\n      Event.mount_uploaders(:images, @uploader)\n    end\n\n    describe '#images' do\n\n      it \"should return blank uploader when nothing has been assigned\" do\n        expect(@event.images).to be_empty\n      end\n\n      it \"should retrieve a file from the storage if a value is stored in the database\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n      end\n\n      it \"should set the path to the store dir\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should return valid JSON when to_json is called when images is nil\" do\n        expect(@event[:images]).to be_nil\n        hash = JSON.parse(@event.to_json)\n        expect(hash.keys).to include(\"images\")\n        expect(hash[\"images\"]).to be_empty\n      end\n\n      it \"should return valid JSON when to_json is called when images is present\" do\n        @event[:images] = ['test.jpeg', 'old.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse(@event.to_json)[\"images\"]).to eq([{\"url\" => \"/uploads/test.jpeg\"}, {\"url\" => \"/uploads/old.jpeg\"}])\n      end\n\n      it \"should return valid JSON when to_json is called on a collection containing uploader from a model\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(JSON.parse({:data => @event.images}.to_json)).to eq({\"data\"=>[{\"url\"=>\"/uploads/test.jpeg\"}]})\n      end\n\n      it \"should return valid XML when to_xml is called when images is nil\" do\n        hash = Hash.from_xml(@event.to_xml)[\"event\"]\n\n        expect(@event[:images]).to be_nil\n        expect(hash.keys).to include(\"images\")\n        expect(hash[\"images\"]).to be_empty\n      end\n\n      it \"should return valid XML when to_xml is called when images is present\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml)[\"event\"][\"images\"]).to eq([{\"url\" => \"/uploads/test.jpeg\"}])\n      end\n\n      it \"should respect options[:only] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:except] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:except => [:id, :image, :images, :textfile, :foo])).to eq({\"textfiles\" => nil})\n      end\n      it \"should respect both options[:only] and options[:except] when passed to as_json for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(@event.as_json(:only => [:foo], :except => [:id])).to eq({\"foo\" => nil})\n      end\n\n      it \"should respect options[:only] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo]))[\"event\"][\"images\"]).to be_nil\n      end\n\n      it \"should respect options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(except: [:images]))[\"event\"][\"images\"]).to be_nil\n      end\n\n      it \"should respect both options[:only] and options[:except] when passed to to_xml for the serializable hash\" do\n        @event[:images] = ['test.jpeg']\n        @event.save!\n        @event.reload\n\n        expect(Hash.from_xml(@event.to_xml(only: [:foo], except: [:id]))[\"event\"][\"images\"]).to be_nil\n      end\n    end\n\n    describe '#images=' do\n\n      it \"should cache a file\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n      end\n\n      it \"should write nothing to the database, to prevent overriden filenames to fail because of unassigned attributes\" do\n        expect(@event[:images]).to be_nil\n      end\n\n      it \"should copy a file into into the cache directory\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.images[0].current_path).to match(%r(^#{public_path('uploads/tmp')}))\n      end\n\n      it \"should do nothing when nil is assigned\" do\n        @event.images = nil\n        expect(@event.images).to be_empty\n      end\n\n      it \"should do nothing when an empty string is assigned\" do\n        @event.images = ''\n        expect(@event.images).to be_empty\n      end\n\n      context 'when validating white list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_whitelist\n              %w(txt)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_whitelist_error => \"Het opladen van %{extension} bestanden is niet toe gestaan. Geaccepteerde types: %{allowed_types}\"\n            }\n          }) do\n            # Assigning images triggers check_whitelist! and thus should be inside change_locale_and_store_translations\n            @event.images = [stub_file('test.jpg')]\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:images]).to eq (['Het opladen van \"jpg\" bestanden is niet toe gestaan. Geaccepteerde types: txt'])\n          end\n        end\n      end\n\n      context 'when validating black list integrity' do\n        before do\n          @uploader.class_eval do\n            def extension_blacklist\n              %w(jpg)\n            end\n          end\n        end\n\n        it \"should use I18n for integrity error messages\" do\n          # Localize the error message to Dutch\n          change_locale_and_store_translations(:nl, :errors => {\n            :messages => {\n              :extension_blacklist_error => \"You are not allowed to upload %{extension} files, prohibited types: %{prohibited_types}\"\n            }\n          }) do\n            # Assigning images triggers check_blacklist! and thus should be inside change_locale_and_store_translations\n            @event.images = [stub_file('test.jpg')]\n            expect(@event).to_not be_valid\n            @event.valid?\n            expect(@event.errors[:images]).to eq(['You are not allowed to upload \"jpg\" files, prohibited types: jpg'])\n          end\n        end\n      end\n\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError\n            end\n          end\n          @event.images = [stub_file('test.jpg')]\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for processing errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['failed to be processed'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagesm.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['falha ao processar imagesm.'])\n          end\n        end\n      end\n\n      context 'when validating processing' do\n        before do\n          @uploader.class_eval do\n            process :monkey\n            def monkey\n              raise CarrierWave::ProcessingError, \"Ohh noez!\"\n            end\n          end\n          @event.images = [stub_file('test.jpg')]\n        end\n\n        it \"should make the record invalid when a processing error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use the error's messages for processing errors with messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['Ohh noez!'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_processing_error => 'falha ao processar imagesm.'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['Ohh noez!'])\n          end\n        end\n      end\n    end\n\n    describe '#save' do\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        expect(@event.images).to be_empty\n      end\n\n      it \"should copy the file to the upload directory when a file has been assigned\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n      end\n\n      it \"should do nothing when a validation fails\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.images = [stub_file('test.jpeg')]\n\n        expect(@event.save).to be_falsey\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to match(/^#{public_path('uploads/tmp')}/)\n      end\n\n      it \"should assign the filename to the database\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        @event.reload\n        expect(@event[:images]).to eq(['test.jpeg'])\n        expect(@event.images_identifiers[0]).to eq('test.jpeg')\n      end\n\n      it \"should preserve the images when nothing is assigned\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n\n        @event = Event.find(@event.id)\n        @event.foo = \"bar\"\n\n        expect(@event.save).to be_truthy\n        expect(@event[:images]).to eq(['test.jpeg'])\n        expect(@event.images_identifiers[0]).to eq('test.jpeg')\n      end\n\n      it \"should remove the images if remove_images? returns true\" do\n        @event.images = [stub_file('test.jpeg')]\n        @event.save!\n        @event.remove_images = true\n        @event.save!\n        @event.reload\n        expect(@event.images).to be_empty\n        expect(@event[:images]).to eq(nil)\n        expect(@event.images_identifiers[0]).to eq(nil)\n      end\n\n      it \"should mark images as changed when saving a new images\" do\n        expect(@event.images_changed?).to be_falsey\n        @event.images = [stub_file(\"test.jpeg\")]\n        expect(@event.images_changed?).to be_truthy\n        @event.save\n        @event.reload\n        expect(@event.images_changed?).to be_falsey\n        @event.images = [stub_file(\"test.jpg\")]\n        expect(@event.images_changed?).to be_truthy\n        expect(@event.changed_for_autosave?).to be_truthy\n      end\n    end\n\n    describe \"remove_images!\" do\n      before do\n        @event.images = [stub_file('test.jpeg')]\n        @event.save!\n        @event.remove_images!\n      end\n\n      it \"should clear the serialization column\" do\n        expect(@event.attributes['images']).to be_blank\n      end\n\n      it \"should return to false after being saved\" do\n        @event.save!\n        expect(@event.remove_images).to eq(false)\n        expect(@event.remove_images?).to eq(false)\n      end\n    end\n\n    describe \"remove_images=\" do\n      it \"should mark the images as changed if changed\" do\n        expect(@event.images_changed?).to be_falsey\n        expect(@event.remove_images).to be_nil\n        @event.remove_images = \"1\"\n        expect(@event.images_changed?).to be_truthy\n      end\n\n      it \"should not mark the images as changed if falsey value is assigned\" do\n        @event.remove_images = \"0\"\n        expect(@event.images_changed?).to be_falsey\n        @event.remove_images = \"false\"\n        expect(@event.images_changed?).to be_falsey\n      end\n    end\n\n    describe \"#remote_images_urls=\" do\n      before do\n        stub_request(:get, \"http://www.example.com/test.jpg\").to_return(body: File.read(file_path(\"test.jpg\")))\n      end\n\n      # FIXME ideally images_changed? and remote_images_urls_changed? would return true\n      it \"should mark images as changed when setting remote_images_urls\" do\n        expect(@event.images_changed?).to be_falsey\n        @event.remote_images_urls = ['http://www.example.com/test.jpg']\n        expect(@event.images_changed?).to be_truthy\n        @event.save!\n        @event.reload\n        expect(@event.images_changed?).to be_falsey\n      end\n\n      context 'when validating download' do\n        before do\n          @uploader.class_eval do\n            def download! file, headers = {}\n              raise CarrierWave::DownloadError\n            end\n          end\n          @event.remote_images_urls = ['http://www.example.com/missing.jpg']\n        end\n\n        it \"should make the record invalid when a download error occurs\" do\n          expect(@event).to_not be_valid\n        end\n\n        it \"should use I18n for download errors without messages\" do\n          @event.valid?\n          expect(@event.errors[:images]).to eq(['could not be downloaded'])\n\n          change_locale_and_store_translations(:pt, :activerecord => {\n            :errors => {\n              :messages => {\n                :carrierwave_download_error => 'n\u00e3o pode ser descarregado'\n              }\n            }\n          }) do\n            expect(@event).to_not be_valid\n            expect(@event.errors[:images]).to eq(['n\u00e3o pode ser descarregado'])\n          end\n        end\n      end\n\n    end\n\n    describe '#destroy' do\n\n      it \"should not raise an error with a custom filename\" do\n        @uploader.class_eval do\n          def filename\n            \"page.jpeg\"\n          end\n        end\n\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect {\n          @event.destroy\n        }.to_not raise_error\n      end\n\n      it \"should do nothing when no file has been assigned\" do\n        expect(@event.save).to be_truthy\n        @event.destroy\n      end\n\n      it \"should remove the file from the filesystem\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(@event.images[0]).to be_an_instance_of(@uploader)\n        expect(@event.images[0].current_path).to eq public_path('uploads/test.jpeg')\n        @event.destroy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n\n    end\n\n    describe 'with overriddent filename' do\n\n      describe '#save' do\n\n        before do\n          @uploader.class_eval do\n            def filename\n              model.name + File.extname(super)\n            end\n          end\n          allow(@event).to receive(:name).and_return('jonas')\n        end\n\n        it \"should copy the file to the upload directory when a file has been assigned\" do\n          @event.images = [stub_file('test.jpeg')]\n          expect(@event.save).to be_truthy\n          expect(@event.images[0]).to be_an_instance_of(@uploader)\n          expect(@event.images[0].current_path).to eq(public_path('uploads/jonas.jpeg'))\n        end\n\n        it \"should assign an overridden filename to the database\" do\n          @event.images = [stub_file('test.jpeg')]\n          expect(@event.save).to be_truthy\n          @event.reload\n          expect(@event[:images]).to eq(['jonas.jpeg'])\n        end\n\n      end\n\n    end\n\n    describe 'with validates_presence_of' do\n\n      before do\n        Event.validates_presence_of :images\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if a file has been cached\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event).to be_valid\n      end\n\n      it \"should not be valid if a file has not been cached\" do\n        expect(@event).to_not be_valid\n      end\n\n    end\n\n    describe 'with validates_size_of' do\n\n      before do\n        Event.validates_size_of :images, maximum: 2\n        allow(@event).to receive(:name).and_return('jonas')\n      end\n\n      it \"should be valid if at the number criteria are met\" do\n        @event.images = [stub_file('test.jpeg'), stub_file('old.jpeg')]\n        expect(@event).to be_valid\n      end\n\n      it \"should be invalid if size criteria are exceeded\" do\n        @event.images = [stub_file('test.jpeg'), stub_file('old.jpeg'), stub_file('new.jpeg')]\n        expect(@event).to_not be_valid\n      end\n\n    end\n  end\n\n  describe '#mount_uploaders with mount_on' do\n    describe '#avatar=' do\n      it \"should cache a file\" do\n        reset_class(\"Event\")\n        Event.mount_uploaders(:avatar, @uploader, mount_on: :images)\n        @event = Event.new\n        @event.avatar = [stub_file('test.jpeg')]\n        @event.save\n        @event.reload\n\n        expect(@event.avatar[0]).to be_an_instance_of(@uploader)\n        expect(@event.images).to eq(['test.jpeg'])\n      end\n\n    end\n  end\n\n  describe '#mount_uploaders removing old files' do\n    before do\n      Event.mount_uploaders(:images, @uploader)\n      @event.images = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    describe 'normally' do\n      it \"should remove old file if old file had a different path\" do\n        @event.images = [stub_file('new.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      end\n\n      it \"should not remove old file if old file had a different path but config is false\" do\n        allow(@uploader).to receive(:remove_previously_stored_files_after_update).and_return(false)\n        @event.images = [stub_file('new.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if old file had the same path\" do\n        @event.images = [stub_file('old.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n\n      it \"should not remove file if validations fail on save\" do\n        Event.validate { |r| r.errors.add :textfile, \"FAIL!\" }\n        @event.images = [stub_file('new.jpeg')]\n\n        expect(@event.save).to be_falsey\n        expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      end\n    end\n\n    describe 'with an overriden filename' do\n      before do\n        @uploader.class_eval do\n          def filename\n            model.foo + File.extname(super)\n          end\n        end\n\n        @event.images = [stub_file('old.jpeg')]\n        @event.foo = 'test'\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n        expect(@event.images[0].read).to eq('this is stuff')\n      end\n\n      it \"should not remove file if old file had the same dynamic path\" do\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_truthy\n      end\n\n      it \"should remove old file if old file had a different dynamic path\" do\n        @event.foo = \"new\"\n        @event.images = [stub_file('test.jpeg')]\n        expect(@event.save).to be_truthy\n        expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n        expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey\n      end\n    end\n  end\n\n  describe '#mount_uploaders removing old files with versions' do\n    before do\n      @uploader.version :thumb\n      Event.mount_uploaders(:images, @uploader)\n      @event.images = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.images = [stub_file('new.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.images = [stub_file('old.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/thumb_old.jpeg'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders removing old files with multiple uploaders' do\n    before do\n      @uploader = Class.new(CarrierWave::Uploader::Base)\n      @uploader1 = Class.new(CarrierWave::Uploader::Base)\n      reset_class(\"Event\")\n      Event.mount_uploaders(:images, @uploader)\n      Event.mount_uploaders(:textfiles, @uploader1)\n      @event = Event.new\n      @event.images = [stub_file('old.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file1 and file2 if old file1 and file2 had a different paths\" do\n      @event.images = [stub_file('new.jpeg')]\n      @event.textfiles = [stub_file('new.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/new.txt'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_falsey\n    end\n\n    it \"should remove old file1 but not file2 if old file1 had a different path but old file2 has the same path\" do\n      @event.images = [stub_file('new.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n\n    it \"should not remove file1 or file2 if file1 and file2 have the same paths\" do\n      @event.images = [stub_file('old.jpeg')]\n      @event.textfiles = [stub_file('old.txt')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.txt'))).to be_truthy\n    end\n  end\n\n  describe '#mount_uploaders removing old files with mount_on' do\n    before do\n      Event.mount_uploaders(:avatar, @uploader, mount_on: :images)\n      @event = Event.new\n      @event.avatar = [stub_file('old.jpeg')]\n\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    after do\n      FileUtils.rm_rf(public_path(\"uploads\"))\n    end\n\n    it \"should remove old file if old file had a different path\" do\n      @event.avatar = [stub_file('new.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/new.jpeg'))).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_falsey\n    end\n\n    it \"should not remove file if old file had the same path\" do\n      @event.avatar = [stub_file('old.jpeg')]\n      expect(@event.save).to be_truthy\n      expect(File.exist?(public_path('uploads/old.jpeg'))).to be_truthy\n    end\n\n    it \"should not raise ArgumentError when with_lock method is called\" do\n      expect { @event.with_lock {} }.to_not raise_error\n    end\n  end\n\n  describe '#reload' do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    context 'when #reload is overriden in the model' do\n      before do\n        Event.class_eval do\n          def reload(*)\n            super\n          end\n        end\n        @event.save\n        @event.image\n      end\n\n      it \"clears @_mounters\" do\n        expect { @event.reload }.to change { @event.instance_variable_get(:@_mounters) }.to(nil)\n      end\n    end\n  end\n\n  describe \"#dup\" do\n    before do\n      Event.mount_uploader(:image, @uploader)\n    end\n\n    it \"appropriately removes the model reference from the new models uploader\" do\n      @event.save\n      new_event = @event.dup\n\n      expect(new_event.image.model).not_to eq @event\n    end\n\n    context 'when #initialize_dup is overriden in the model' do\n      before do\n        Event.class_eval do\n          def initialize_dup(*)\n            super\n          end\n        end\n        @event.image\n      end\n\n      it \"clears @_mounters\" do\n        expect(@event.dup.instance_variable_get(:@_mounters)).to be_blank\n      end\n    end\n  end\nend\n", "require 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'pry'\nrequire 'tempfile'\nrequire 'time'\nrequire 'logger'\n\nrequire 'carrierwave'\nrequire 'timecop'\nrequire 'open-uri'\nrequire \"webmock/rspec\"\nrequire 'mini_magick'\n\nI18n.enforce_available_locales = false\n\nCARRIERWAVE_DIRECTORY = \"carrierwave#{Time.now.to_i}\" unless defined?(CARRIERWAVE_DIRECTORY)\n\nalias :running :lambda\n\ndef file_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'fixtures', *paths))\nend\n\ndef public_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'public', *paths))\nend\n\ndef tmp_path( *paths )\n  File.expand_path(File.join(File.dirname(__FILE__), 'tmp', *paths))\nend\n\nCarrierWave.root = public_path\nI18n.load_path << File.expand_path(File.join(File.dirname(__FILE__), \"..\", \"lib\", \"carrierwave\", \"locale\", 'en.yml'))\n\nmodule CarrierWave\n  module Test\n    module MockStorage\n      def mock_storage(kind)\n        storage = double(\"storage for #{kind} uploader\")\n        allow(storage).to receive(:setup!)\n        storage\n      end\n    end\n\n    module MockFiles\n      def stub_tempfile(filename, mime_type=nil, fake_name=nil)\n        raise \"#{path} file does not exist\" unless File.exist?(file_path(filename))\n\n        tempfile = Tempfile.new(filename)\n        FileUtils.copy_file(file_path(filename), tempfile.path)\n        allow(tempfile).to receive_messages(:original_filename => fake_name || filename,\n                      :content_type => mime_type)\n        tempfile\n      end\n\n      alias_method :stub_merb_tempfile, :stub_tempfile\n\n      def stub_stringio(filename, mime_type=nil, fake_name=nil)\n        file = IO.read( file_path( filename ) ) if filename\n        stringio = StringIO.new(file)\n        allow(stringio).to receive_messages(:local_path => \"\",\n                      :original_filename => filename || fake_name,\n                      :content_type => mime_type)\n        stringio\n      end\n\n      def stub_file(filename, mime_type=nil, fake_name=nil)\n        f = File.open(file_path(filename))\n        allow(f).to receive(:content_type) { mime_type } if mime_type\n        return f\n      end\n    end\n\n    module I18nHelpers\n      def change_locale_and_store_translations(locale, translations, &block)\n        current_locale = I18n.locale\n        begin\n          # I18n.available_locales needs to be cleared before storing translations:\n          #   https://github.com/svenfuchs/i18n/pull/391\n          I18n.available_locales = nil\n          I18n.backend.store_translations locale, translations\n          I18n.locale = locale\n          yield\n        ensure\n          I18n.reload!\n          I18n.locale = current_locale\n        end\n      end\n\n      def change_and_enforece_available_locales(locale, available_locales, &block)\n        current_available_locales = I18n.available_locales\n        current_enforce_available_locales_value = I18n.enforce_available_locales\n        current_locale = I18n.locale\n        begin\n          I18n.available_locales = [:nl]\n          I18n.enforce_available_locales = true\n          I18n.locale = :nl\n          yield\n        ensure\n          I18n.available_locales = current_available_locales\n          I18n.enforce_available_locales = current_enforce_available_locales_value\n          I18n.locale = current_locale\n        end\n      end\n    end\n\n    module ManipulationHelpers\n      def color_of_pixel(path, x, y)\n        image = ::MiniMagick::Image.open(path)\n        image.run_command(\"convert\", \"#{image.path}[1x1+#{x}+#{y}]\", \"-depth\", \"8\", \"txt:\").split(\"\\n\")[1]\n      end\n    end\n\n    module SsrfProtectionAwareWebMock\n      def stub_request(method, uri)\n        uri = URI.parse(uri) if uri.is_a?(String)\n        uri.hostname = Resolv.getaddress(uri.hostname) if uri.is_a?(URI)\n        super\n      end\n    end\n  end\nend\n\nRSpec.configure do |config|\n  config.include CarrierWave::Test::Matchers\n  config.include CarrierWave::Test::MockFiles\n  config.include CarrierWave::Test::MockStorage\n  config.include CarrierWave::Test::I18nHelpers\n  config.include CarrierWave::Test::ManipulationHelpers\n  config.prepend CarrierWave::Test::SsrfProtectionAwareWebMock\n  if RUBY_ENGINE == 'jruby'\n    config.filter_run_excluding :rmagick => true\n  end\nend\n", "require 'spec_helper'\n\ndescribe CarrierWave::Uploader::Download do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:cache_id) { '1369894322-345-1234-2255' }\n  let(:base_url) { \"http://www.example.com\" }\n  let(:url) { base_url + \"/test.jpg\" }\n  let(:test_file) { File.read(file_path(test_file_name)) }\n  let(:test_file_name) { \"test.jpg\" }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '#download!' do\n    before do\n      allow(CarrierWave).to receive(:generate_cache_id).and_return(cache_id)\n\n      stub_request(:get, \"http://www.example.com/#{test_file_name}\")\n        .to_return(body: test_file, headers: {'content-type': 'image/jpeg'})\n    end\n\n    context \"when a file was downloaded\" do\n      before do\n        uploader.download!(url)\n      end\n\n      it \"caches a file\" do\n        expect(uploader.file).to be_an_instance_of(CarrierWave::SanitizedFile)\n      end\n\n      it \"'s cached\" do\n        expect(uploader).to be_cached\n      end\n\n      it \"stores the cache name\" do\n        expect(uploader.cache_name).to eq(\"#{cache_id}/#{test_file_name}\")\n      end\n\n      it \"sets the filename to the file's sanitized filename\" do\n        expect(uploader.filename).to eq(\"#{test_file_name}\")\n      end\n\n      it \"moves it to the tmp dir\" do\n        expect(uploader.file.path).to eq(public_path(\"uploads/tmp/#{cache_id}/#{test_file_name}\"))\n        expect(uploader.file.exists?).to be_truthy\n      end\n\n      it \"sets the url\" do\n        expect(uploader.url).to eq(\"/uploads/tmp/#{cache_id}/#{test_file_name}\")\n      end\n\n      it \"sets the content type\" do\n        expect(uploader.content_type).to eq(\"image/jpeg\")\n      end\n    end\n\n    context \"with directory permissions set\" do\n      let(:permissions) { 0777 }\n\n      it \"sets permissions\" do\n        uploader_class.permissions = permissions\n        uploader.download!(url)\n\n        expect(uploader).to have_permissions(permissions)\n      end\n\n      it \"sets directory permissions\" do\n        uploader_class.directory_permissions = permissions\n        uploader.download!(url)\n\n        expect(uploader).to have_directory_permissions(permissions)\n      end\n    end\n\n    describe \"custom downloader\" do\n      let(:klass) do\n        Class.new(CarrierWave::Downloader::Base) {\n          def download(url, request_headers={})\n          end\n        }\n      end\n      before do\n        uploader.downloader = klass\n      end\n\n      it \"is supported\" do\n        expect_any_instance_of(klass).to receive(:download).with(url, {})\n        uploader.download!(url)\n      end\n    end\n  end\nend\n"], "filenames": ["carrierwave.gemspec", "features/step_definitions/download_steps.rb", "lib/carrierwave/downloader/base.rb", "lib/carrierwave/downloader/remote_file.rb", "spec/downloader/base_spec.rb", "spec/downloader/remote_file_spec.rb", "spec/mount_multiple_spec.rb", "spec/mount_single_spec.rb", "spec/orm/activerecord_spec.rb", "spec/spec_helper.rb", "spec/uploader/download_spec.rb"], "buggy_code_start_loc": [29, 3, 1, 4, 26, 3, 507, 302, 499, 113, 18], "buggy_code_end_loc": [29, 4, 51, 36, 180, 21, 1014, 746, 1264, 122, 49], "fixing_code_start_loc": [30, 3, 2, 4, 25, 4, 507, 302, 499, 114, 18], "fixing_code_end_loc": [31, 4, 85, 57, 212, 59, 1014, 746, 1264, 132, 54], "type": "CWE-918", "message": "CarrierWave is an open-source RubyGem which provides a simple and flexible way to upload files from Ruby applications. In CarrierWave before versions 1.3.2 and 2.1.1 the download feature has an SSRF vulnerability, allowing attacks to provide DNS entries or IP addresses that are intended for internal use and gather information about the Intranet infrastructure of the platform. This is fixed in versions 1.3.2 and 2.1.1.", "other": {"cve": {"id": "CVE-2021-21288", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-08T20:15:12.277", "lastModified": "2021-02-12T16:30:33.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CarrierWave is an open-source RubyGem which provides a simple and flexible way to upload files from Ruby applications. In CarrierWave before versions 1.3.2 and 2.1.1 the download feature has an SSRF vulnerability, allowing attacks to provide DNS entries or IP addresses that are intended for internal use and gather information about the Intranet infrastructure of the platform. This is fixed in versions 1.3.2 and 2.1.1."}, {"lang": "es", "value": "CarrierWave es un RubyGem de c\u00f3digo abierto que proporciona una forma simple y flexible de cargar archivos desde aplicaciones Ruby.&#xa0;En CarrierWave versiones anteriores a 1.3.2 y 2.1.1, la funcionalidad de descarga tiene una vulnerabilidad SSRF, permitiendo ataques para proporcionar entradas DNS o direcciones IP que est\u00e1n destinadas a uso interno y recopilen informaci\u00f3n sobre la infraestructura de Intranet de la plataforma.&#xa0;Esto se corrigi\u00f3 en las versiones 1.3.2 y 2.1.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.3.2", "matchCriteriaId": "68FBD42F-C60B-4C66-B772-C35F4AED519C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "2.0.1", "versionEndExcluding": "2.1.1", "matchCriteriaId": "B9D2FEB0-C576-4E14-A2F6-7642E83CC6F1"}]}]}], "references": [{"url": "https://github.com/carrierwaveuploader/carrierwave/blob/master/CHANGELOG.md#132---2021-02-08", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/blob/master/CHANGELOG.md#211---2021-02-08", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/commit/012702eb3ba1663452aa025831caa304d1a665c0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://rubygems.org/gems/carrierwave/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/012702eb3ba1663452aa025831caa304d1a665c0"}}