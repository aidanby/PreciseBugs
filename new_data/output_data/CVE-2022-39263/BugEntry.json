{"buggy_code": ["import type { Account as AdapterAccount } from \"next-auth\"\nimport type {\n  Adapter,\n  AdapterUser,\n  AdapterSession,\n  VerificationToken,\n} from \"next-auth/adapters\"\nimport type { Redis } from \"@upstash/redis\"\n\nimport { v4 as uuid } from \"uuid\"\n\nexport interface UpstashRedisAdapterOptions {\n  baseKeyPrefix?: string\n  accountKeyPrefix?: string\n  accountByUserIdPrefix?: string\n  emailKeyPrefix?: string\n  sessionKeyPrefix?: string\n  sessionByUserIdKeyPrefix?: string\n  userKeyPrefix?: string\n  verificationTokenKeyPrefix?: string\n}\n\nexport const defaultOptions = {\n  baseKeyPrefix: \"\",\n  accountKeyPrefix: \"user:account:\",\n  accountByUserIdPrefix: \"user:account:by-user-id:\",\n  emailKeyPrefix: \"user:email:\",\n  sessionKeyPrefix: \"user:session:\",\n  sessionByUserIdKeyPrefix: \"user:session:by-user-id:\",\n  userKeyPrefix: \"user:\",\n  verificationTokenKeyPrefix: \"user:token:\",\n}\n\nconst isoDateRE =\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nfunction isDate(value: any) {\n  return value && isoDateRE.test(value) && !isNaN(Date.parse(value))\n}\n\nexport function hydrateDates(json: object) {\n  return Object.entries(json).reduce((acc, [key, val]) => {\n    acc[key] = isDate(val) ? new Date(val as string) : val\n    return acc\n  }, {} as any)\n}\n\nexport function UpstashRedisAdapter(\n  client: Redis,\n  options: UpstashRedisAdapterOptions = {}\n): Adapter {\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options,\n  }\n\n  const { baseKeyPrefix } = mergedOptions\n  const accountKeyPrefix = baseKeyPrefix + mergedOptions.accountKeyPrefix\n  const accountByUserIdPrefix =\n    baseKeyPrefix + mergedOptions.accountByUserIdPrefix\n  const emailKeyPrefix = baseKeyPrefix + mergedOptions.emailKeyPrefix\n  const sessionKeyPrefix = baseKeyPrefix + mergedOptions.sessionKeyPrefix\n  const sessionByUserIdKeyPrefix =\n    baseKeyPrefix + mergedOptions.sessionByUserIdKeyPrefix\n  const userKeyPrefix = baseKeyPrefix + mergedOptions.userKeyPrefix\n  const verificationTokenKeyPrefix =\n    baseKeyPrefix + mergedOptions.verificationTokenKeyPrefix\n\n  const setObjectAsJson = async (key: string, obj: any) =>\n    await client.set(key, JSON.stringify(obj))\n\n  const setAccount = async (id: string, account: AdapterAccount) => {\n    const accountKey = accountKeyPrefix + id\n    await setObjectAsJson(accountKey, account)\n    await client.set(accountByUserIdPrefix + account.userId, accountKey)\n    return account\n  }\n\n  const getAccount = async (id: string) => {\n    const account = await client.get<AdapterAccount>(accountKeyPrefix + id)\n    if (!account) return null\n    return hydrateDates(account)\n  }\n\n  const setSession = async (\n    id: string,\n    session: AdapterSession\n  ): Promise<AdapterSession> => {\n    const sessionKey = sessionKeyPrefix + id\n    await setObjectAsJson(sessionKey, session)\n    await client.set(sessionByUserIdKeyPrefix + session.userId, sessionKey)\n    return session\n  }\n\n  const getSession = async (id: string) => {\n    const session = await client.get<AdapterSession>(sessionKeyPrefix + id)\n    if (!session) return null\n    return hydrateDates(session)\n  }\n\n  const setUser = async (\n    id: string,\n    user: AdapterUser\n  ): Promise<AdapterUser> => {\n    await setObjectAsJson(userKeyPrefix + id, user)\n    await client.set(`${emailKeyPrefix}${user.email as string}`, id)\n    return user\n  }\n\n  const getUser = async (id: string) => {\n    const user = await client.get<AdapterUser>(userKeyPrefix + id)\n    if (!user) return null\n    return hydrateDates(user)\n  }\n\n  return {\n    async createUser(user) {\n      const id = uuid()\n      // TypeScript thinks the emailVerified field is missing\n      // but all fields are copied directly from user, so it's there\n      // @ts-expect-error\n      return await setUser(id, { ...user, id })\n    },\n    getUser,\n    async getUserByEmail(email) {\n      const userId = await client.get<string>(emailKeyPrefix + email)\n      if (!userId) {\n        return null\n      }\n      return await getUser(userId)\n    },\n    async getUserByAccount(account) {\n      const dbAccount = await getAccount(\n        `${account.provider}:${account.providerAccountId}`\n      )\n      if (!dbAccount) return null\n      return await getUser(dbAccount.userId)\n    },\n    async updateUser(updates) {\n      const userId = updates.id as string\n      const user = await getUser(userId)\n      return await setUser(userId, { ...(user as AdapterUser), ...updates })\n    },\n    async linkAccount(account) {\n      const id = `${account.provider}:${account.providerAccountId}`\n      return await setAccount(id, { ...account, id })\n    },\n    async createSession(session) {\n      const id = session.sessionToken\n      return await setSession(id, { ...session, id })\n    },\n    async getSessionAndUser(sessionToken) {\n      const session = await getSession(sessionToken)\n      if (!session) return null\n      const user = await getUser(session.userId)\n      if (!user) return null\n      return { session, user }\n    },\n    async updateSession(updates) {\n      const session = await getSession(updates.sessionToken)\n      if (!session) return null\n      return await setSession(updates.sessionToken, { ...session, ...updates })\n    },\n    async deleteSession(sessionToken) {\n      await client.del(sessionKeyPrefix + sessionToken)\n    },\n    async createVerificationToken(verificationToken) {\n      await setObjectAsJson(\n        verificationTokenKeyPrefix + verificationToken.identifier,\n        verificationToken\n      )\n      return verificationToken\n    },\n    async useVerificationToken(verificationToken) {\n      const tokenKey = verificationTokenKeyPrefix + verificationToken.identifier\n\n      const token = await client.get<VerificationToken>(tokenKey)\n      if (!token) return null\n\n      await client.del(tokenKey)\n      return hydrateDates(token)\n      // return reviveFromJson(token)\n    },\n    async unlinkAccount(account) {\n      const id = `${account.provider}:${account.providerAccountId}`\n      const dbAccount = await getAccount(id)\n      if (!dbAccount) return\n      const accountKey = `${accountKeyPrefix}${id}`\n      await client.del(\n        accountKey,\n        `${accountByUserIdPrefix} + ${dbAccount.userId as string}`\n      )\n    },\n    async deleteUser(userId) {\n      const user = await getUser(userId)\n      if (!user) return\n      const accountByUserKey = accountByUserIdPrefix + userId\n      const accountKey = await client.get<string>(accountByUserKey)\n      const sessionByUserIdKey = sessionByUserIdKeyPrefix + userId\n      const sessionKey = await client.get<string>(sessionByUserIdKey)\n      await client.del(\n        userKeyPrefix + userId,\n        `${emailKeyPrefix}${user.email as string}`,\n        accountKey as string,\n        accountByUserKey,\n        sessionKey as string,\n        sessionByUserIdKey\n      )\n    },\n  }\n}\n"], "fixing_code": ["import type { Account as AdapterAccount } from \"next-auth\"\nimport type {\n  Adapter,\n  AdapterUser,\n  AdapterSession,\n  VerificationToken,\n} from \"next-auth/adapters\"\nimport type { Redis } from \"@upstash/redis\"\n\nimport { v4 as uuid } from \"uuid\"\n\nexport interface UpstashRedisAdapterOptions {\n  baseKeyPrefix?: string\n  accountKeyPrefix?: string\n  accountByUserIdPrefix?: string\n  emailKeyPrefix?: string\n  sessionKeyPrefix?: string\n  sessionByUserIdKeyPrefix?: string\n  userKeyPrefix?: string\n  verificationTokenKeyPrefix?: string\n}\n\nexport const defaultOptions = {\n  baseKeyPrefix: \"\",\n  accountKeyPrefix: \"user:account:\",\n  accountByUserIdPrefix: \"user:account:by-user-id:\",\n  emailKeyPrefix: \"user:email:\",\n  sessionKeyPrefix: \"user:session:\",\n  sessionByUserIdKeyPrefix: \"user:session:by-user-id:\",\n  userKeyPrefix: \"user:\",\n  verificationTokenKeyPrefix: \"user:token:\",\n}\n\nconst isoDateRE =\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nfunction isDate(value: any) {\n  return value && isoDateRE.test(value) && !isNaN(Date.parse(value))\n}\n\nexport function hydrateDates(json: object) {\n  return Object.entries(json).reduce((acc, [key, val]) => {\n    acc[key] = isDate(val) ? new Date(val as string) : val\n    return acc\n  }, {} as any)\n}\n\nexport function UpstashRedisAdapter(\n  client: Redis,\n  options: UpstashRedisAdapterOptions = {}\n): Adapter {\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options,\n  }\n\n  const { baseKeyPrefix } = mergedOptions\n  const accountKeyPrefix = baseKeyPrefix + mergedOptions.accountKeyPrefix\n  const accountByUserIdPrefix =\n    baseKeyPrefix + mergedOptions.accountByUserIdPrefix\n  const emailKeyPrefix = baseKeyPrefix + mergedOptions.emailKeyPrefix\n  const sessionKeyPrefix = baseKeyPrefix + mergedOptions.sessionKeyPrefix\n  const sessionByUserIdKeyPrefix =\n    baseKeyPrefix + mergedOptions.sessionByUserIdKeyPrefix\n  const userKeyPrefix = baseKeyPrefix + mergedOptions.userKeyPrefix\n  const verificationTokenKeyPrefix =\n    baseKeyPrefix + mergedOptions.verificationTokenKeyPrefix\n\n  const setObjectAsJson = async (key: string, obj: any) =>\n    await client.set(key, JSON.stringify(obj))\n\n  const setAccount = async (id: string, account: AdapterAccount) => {\n    const accountKey = accountKeyPrefix + id\n    await setObjectAsJson(accountKey, account)\n    await client.set(accountByUserIdPrefix + account.userId, accountKey)\n    return account\n  }\n\n  const getAccount = async (id: string) => {\n    const account = await client.get<AdapterAccount>(accountKeyPrefix + id)\n    if (!account) return null\n    return hydrateDates(account)\n  }\n\n  const setSession = async (\n    id: string,\n    session: AdapterSession\n  ): Promise<AdapterSession> => {\n    const sessionKey = sessionKeyPrefix + id\n    await setObjectAsJson(sessionKey, session)\n    await client.set(sessionByUserIdKeyPrefix + session.userId, sessionKey)\n    return session\n  }\n\n  const getSession = async (id: string) => {\n    const session = await client.get<AdapterSession>(sessionKeyPrefix + id)\n    if (!session) return null\n    return hydrateDates(session)\n  }\n\n  const setUser = async (\n    id: string,\n    user: AdapterUser\n  ): Promise<AdapterUser> => {\n    await setObjectAsJson(userKeyPrefix + id, user)\n    await client.set(`${emailKeyPrefix}${user.email as string}`, id)\n    return user\n  }\n\n  const getUser = async (id: string) => {\n    const user = await client.get<AdapterUser>(userKeyPrefix + id)\n    if (!user) return null\n    return hydrateDates(user)\n  }\n\n  return {\n    async createUser(user) {\n      const id = uuid()\n      // TypeScript thinks the emailVerified field is missing\n      // but all fields are copied directly from user, so it's there\n      // @ts-expect-error\n      return await setUser(id, { ...user, id })\n    },\n    getUser,\n    async getUserByEmail(email) {\n      const userId = await client.get<string>(emailKeyPrefix + email)\n      if (!userId) {\n        return null\n      }\n      return await getUser(userId)\n    },\n    async getUserByAccount(account) {\n      const dbAccount = await getAccount(\n        `${account.provider}:${account.providerAccountId}`\n      )\n      if (!dbAccount) return null\n      return await getUser(dbAccount.userId)\n    },\n    async updateUser(updates) {\n      const userId = updates.id as string\n      const user = await getUser(userId)\n      return await setUser(userId, { ...(user as AdapterUser), ...updates })\n    },\n    async linkAccount(account) {\n      const id = `${account.provider}:${account.providerAccountId}`\n      return await setAccount(id, { ...account, id })\n    },\n    async createSession(session) {\n      const id = session.sessionToken\n      return await setSession(id, { ...session, id })\n    },\n    async getSessionAndUser(sessionToken) {\n      const session = await getSession(sessionToken)\n      if (!session) return null\n      const user = await getUser(session.userId)\n      if (!user) return null\n      return { session, user }\n    },\n    async updateSession(updates) {\n      const session = await getSession(updates.sessionToken)\n      if (!session) return null\n      return await setSession(updates.sessionToken, { ...session, ...updates })\n    },\n    async deleteSession(sessionToken) {\n      await client.del(sessionKeyPrefix + sessionToken)\n    },\n    async createVerificationToken(verificationToken) {\n      await setObjectAsJson(\n        verificationTokenKeyPrefix +\n          verificationToken.identifier +\n          \":\" +\n          verificationToken.token,\n        verificationToken\n      )\n      return verificationToken\n    },\n    async useVerificationToken(verificationToken) {\n      const tokenKey =\n        verificationTokenKeyPrefix +\n        verificationToken.identifier +\n        \":\" +\n        verificationToken.token\n\n      const token = await client.get<VerificationToken>(tokenKey)\n      if (!token) return null\n\n      await client.del(tokenKey)\n      return hydrateDates(token)\n      // return reviveFromJson(token)\n    },\n    async unlinkAccount(account) {\n      const id = `${account.provider}:${account.providerAccountId}`\n      const dbAccount = await getAccount(id)\n      if (!dbAccount) return\n      const accountKey = `${accountKeyPrefix}${id}`\n      await client.del(\n        accountKey,\n        `${accountByUserIdPrefix} + ${dbAccount.userId as string}`\n      )\n    },\n    async deleteUser(userId) {\n      const user = await getUser(userId)\n      if (!user) return\n      const accountByUserKey = accountByUserIdPrefix + userId\n      const accountKey = await client.get<string>(accountByUserKey)\n      const sessionByUserIdKey = sessionByUserIdKeyPrefix + userId\n      const sessionKey = await client.get<string>(sessionByUserIdKey)\n      await client.del(\n        userKeyPrefix + userId,\n        `${emailKeyPrefix}${user.email as string}`,\n        accountKey as string,\n        accountByUserKey,\n        sessionKey as string,\n        sessionByUserIdKey\n      )\n    },\n  }\n}\n"], "filenames": ["packages/adapter-upstash-redis/src/index.ts"], "buggy_code_start_loc": [168], "buggy_code_end_loc": [175], "fixing_code_start_loc": [168], "fixing_code_end_loc": [182], "type": "CWE-287", "message": "`@next-auth/upstash-redis-adapter` is the Upstash Redis adapter for NextAuth.js, which provides authentication for Next.js. Applications that use `next-auth` Email Provider and `@next-auth/upstash-redis-adapter` before v3.0.2 are affected by this vulnerability. The Upstash Redis adapter implementation did not check for both the identifier (email) and the token, but only checking for the identifier when verifying the token in the email callback flow. An attacker who knows about the victim's email could easily sign in as the victim, given the attacker also knows about the verification token's expired duration. The vulnerability is patched in v3.0.2. A workaround is available. Using Advanced Initialization, developers can check the requests and compare the query's token and identifier before proceeding.", "other": {"cve": {"id": "CVE-2022-39263", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-28T21:15:14.590", "lastModified": "2023-03-03T20:08:04.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "`@next-auth/upstash-redis-adapter` is the Upstash Redis adapter for NextAuth.js, which provides authentication for Next.js. Applications that use `next-auth` Email Provider and `@next-auth/upstash-redis-adapter` before v3.0.2 are affected by this vulnerability. The Upstash Redis adapter implementation did not check for both the identifier (email) and the token, but only checking for the identifier when verifying the token in the email callback flow. An attacker who knows about the victim's email could easily sign in as the victim, given the attacker also knows about the verification token's expired duration. The vulnerability is patched in v3.0.2. A workaround is available. Using Advanced Initialization, developers can check the requests and compare the query's token and identifier before proceeding."}, {"lang": "es", "value": "\"@next-auth/upstash-redis-adapter\" es el adaptador de Upstash Redis para NextAuth.js, que proporciona autenticaci\u00f3n para Next.js. Las aplicaciones que usan el proveedor de correo electr\u00f3nico \"next-auth\" y \"@next-auth/upstash-redis-adapter\" versiones anteriores a 3.0.2, est\u00e1n afectadas por esta vulnerabilidad. La implementaci\u00f3n del adaptador Upstash Redis no comprobaba tanto el identificador (correo electr\u00f3nico) como el token, sino que s\u00f3lo comprobaba el identificador cuando verificaba el token en el flujo de devoluci\u00f3n de llamada del correo electr\u00f3nico. Un atacante que conozca el correo electr\u00f3nico de la v\u00edctima podr\u00eda iniciar sesi\u00f3n f\u00e1cilmente como la v\u00edctima, dado que el atacante tambi\u00e9n conoce la duraci\u00f3n del token de verificaci\u00f3n. La vulnerabilidad est\u00e1 parcheada en versi\u00f3n 3.0.2. Se presenta una mitigaci\u00f3n disponible. usando la Inicializaci\u00f3n Avanzada, los desarrolladores pueden comprobar las peticiones y comparar el token y el identificador de la consulta antes de proceder"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextauth.js:next-auth:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.0.2", "matchCriteriaId": "9739A761-9DBD-4177-B34D-AC887CFE81C8"}]}]}], "references": [{"url": "https://github.com/nextauthjs/next-auth/commit/d16e04848ee703cf797724194d4ad2907fe125a9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nextauthjs/next-auth/security/advisories/GHSA-4rxr-27mm-mxq9", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nextauthjs/next-auth/commit/d16e04848ee703cf797724194d4ad2907fe125a9"}}