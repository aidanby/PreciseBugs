{"buggy_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t\tCreatorID: userID,\n\t\t}\n\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tID:        resourceID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tif strings.HasPrefix(resource.Type, echo.MIMETextHTML) {\n\t\t\tc.Response().Writer.Header().Set(\"Content-Type\", echo.MIMETextPlain)\n\t\t} else {\n\t\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\t}\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/server/profile\"\n\t\"github.com/usememos/memos/store\"\n\n\t\"github.com/gorilla/securecookie\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Server struct {\n\te *echo.Echo\n\n\tCollector *MetricCollector\n\n\tProfile *profile.Profile\n\n\tStore *store.Store\n}\n\nfunc NewServer(profile *profile.Profile) *Server {\n\te := echo.New()\n\te.Debug = true\n\te.HideBanner = true\n\te.HidePort = true\n\n\te.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `{\"time\":\"${time_rfc3339}\",` +\n\t\t\t`\"method\":\"${method}\",\"uri\":\"${uri}\",` +\n\t\t\t`\"status\":${status},\"error\":\"${error}\"}` + \"\\n\",\n\t}))\n\n\te.Use(middleware.CORS())\n\n\te.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n\t\tSkipper:      middleware.DefaultSkipper,\n\t\tErrorMessage: \"Request timeout\",\n\t\tTimeout:      30 * time.Second,\n\t}))\n\n\tembedFrontend(e)\n\n\t// In dev mode, set the const secret key to make signin session persistence.\n\tsecret := []byte(\"usememos\")\n\tif profile.Mode == \"prod\" {\n\t\tsecret = securecookie.GenerateRandomKey(16)\n\t}\n\te.Use(session.Middleware(sessions.NewCookieStore(secret)))\n\n\ts := &Server{\n\t\te:       e,\n\t\tProfile: profile,\n\t}\n\n\trootGroup := e.Group(\"\")\n\ts.registerRSSRoutes(rootGroup)\n\n\twebhookGroup := e.Group(\"/h\")\n\ts.registerResourcePublicRoutes(webhookGroup)\n\n\tpublicGroup := e.Group(\"/o\")\n\ts.registerResourcePublicRoutes(publicGroup)\n\ts.registerGetterPublicRoutes(publicGroup)\n\n\tapiGroup := e.Group(\"/api\")\n\tapiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn aclMiddleware(s, next)\n\t})\n\ts.registerSystemRoutes(apiGroup)\n\ts.registerAuthRoutes(apiGroup)\n\ts.registerUserRoutes(apiGroup)\n\ts.registerMemoRoutes(apiGroup)\n\ts.registerShortcutRoutes(apiGroup)\n\ts.registerResourceRoutes(apiGroup)\n\ts.registerTagRoutes(apiGroup)\n\n\treturn s\n}\n\nfunc (server *Server) Run() error {\n\treturn server.e.Start(fmt.Sprintf(\":%d\", server.Profile.Port))\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t\tCreatorID: userID,\n\t\t}\n\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tID:        resourceID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/server/profile\"\n\t\"github.com/usememos/memos/store\"\n\n\t\"github.com/gorilla/securecookie\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Server struct {\n\te *echo.Echo\n\n\tCollector *MetricCollector\n\n\tProfile *profile.Profile\n\n\tStore *store.Store\n}\n\nfunc NewServer(profile *profile.Profile) *Server {\n\te := echo.New()\n\te.Debug = true\n\te.HideBanner = true\n\te.HidePort = true\n\n\te.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `{\"time\":\"${time_rfc3339}\",` +\n\t\t\t`\"method\":\"${method}\",\"uri\":\"${uri}\",` +\n\t\t\t`\"status\":${status},\"error\":\"${error}\"}` + \"\\n\",\n\t}))\n\n\te.Use(middleware.CORS())\n\n\te.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n\t\tSkipper:      middleware.DefaultSkipper,\n\t\tErrorMessage: \"Request timeout\",\n\t\tTimeout:      30 * time.Second,\n\t}))\n\n\te.Use(middleware.SecureWithConfig(middleware.SecureConfig{\n\t\tContentSecurityPolicy: \"default-src 'self'\",\n\t}))\n\n\tembedFrontend(e)\n\n\t// In dev mode, set the const secret key to make signin session persistence.\n\tsecret := []byte(\"usememos\")\n\tif profile.Mode == \"prod\" {\n\t\tsecret = securecookie.GenerateRandomKey(16)\n\t}\n\te.Use(session.Middleware(sessions.NewCookieStore(secret)))\n\n\ts := &Server{\n\t\te:       e,\n\t\tProfile: profile,\n\t}\n\n\trootGroup := e.Group(\"\")\n\ts.registerRSSRoutes(rootGroup)\n\n\twebhookGroup := e.Group(\"/h\")\n\ts.registerResourcePublicRoutes(webhookGroup)\n\n\tpublicGroup := e.Group(\"/o\")\n\ts.registerResourcePublicRoutes(publicGroup)\n\ts.registerGetterPublicRoutes(publicGroup)\n\n\tapiGroup := e.Group(\"/api\")\n\tapiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn aclMiddleware(s, next)\n\t})\n\ts.registerSystemRoutes(apiGroup)\n\ts.registerAuthRoutes(apiGroup)\n\ts.registerUserRoutes(apiGroup)\n\ts.registerMemoRoutes(apiGroup)\n\ts.registerShortcutRoutes(apiGroup)\n\ts.registerResourceRoutes(apiGroup)\n\ts.registerTagRoutes(apiGroup)\n\n\treturn s\n}\n\nfunc (server *Server) Run() error {\n\treturn server.e.Start(fmt.Sprintf(\":%d\", server.Profile.Port))\n}\n"], "filenames": ["server/resource.go", "server/server.go"], "buggy_code_start_loc": [10, 46], "buggy_code_end_loc": [271, 46], "fixing_code_start_loc": [9, 47], "fixing_code_end_loc": [266, 51], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0.", "other": {"cve": {"id": "CVE-2022-4691", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-27T15:15:11.453", "lastModified": "2023-01-05T14:07:33.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "9E9BB4B3-BBB1-406D-96EE-69114B828CF0"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/c07b4a57caa89905e54b800f4d8fb720bbf5bf82", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/459b55c1-22f5-4556-9cda-9b86aa91582f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/c07b4a57caa89905e54b800f4d8fb720bbf5bf82"}}