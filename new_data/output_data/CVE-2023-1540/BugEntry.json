{"buggy_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\t_, err := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UseRePassword(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPassWordRequest  true \"UserModifyPassWordRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/google/uuid\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserRepo user repository\n\n// UserService user service\ntype UserService struct {\n\tuserCommonService *usercommon.UserCommon\n\tuserRepo          usercommon.UserRepo\n\tuserActivity      activity.UserActiveActivityRepo\n\tactivityRepo      activity_common.ActivityRepo\n\tserviceConfig     *service_config.ServiceConfig\n\temailService      *export.EmailService\n\tauthService       *auth.AuthService\n\tsiteInfoService   *siteinfo_common.SiteInfoCommonService\n\tuserRoleService   *role.UserRoleRelService\n}\n\nfunc NewUserService(userRepo usercommon.UserRepo,\n\tuserActivity activity.UserActiveActivityRepo,\n\tactivityRepo activity_common.ActivityRepo,\n\temailService *export.EmailService,\n\tauthService *auth.AuthService,\n\tserviceConfig *service_config.ServiceConfig,\n\tsiteInfoService *siteinfo_common.SiteInfoCommonService,\n\tuserRoleService *role.UserRoleRelService,\n\tuserCommonService *usercommon.UserCommon,\n) *UserService {\n\treturn &UserService{\n\t\tuserCommonService: userCommonService,\n\t\tuserRepo:          userRepo,\n\t\tuserActivity:      userActivity,\n\t\tactivityRepo:      activityRepo,\n\t\temailService:      emailService,\n\t\tserviceConfig:     serviceConfig,\n\t\tauthService:       authService,\n\t\tsiteInfoService:   siteInfoService,\n\t\tuserRoleService:   userRoleService,\n\t}\n}\n\n// GetUserInfoByUserID get user info by user id\nfunc (us *UserService) GetUserInfoByUserID(ctx context.Context, token, userID string) (resp *schema.GetUserToSetShowResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp = &schema.GetUserToSetShowResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tresp.AccessToken = token\n\tresp.IsAdmin = roleID == role.RoleAdminID\n\treturn resp, nil\n}\n\nfunc (us *UserService) GetOtherUserInfoByUsername(ctx context.Context, username string) (\n\tresp *schema.GetOtherUserInfoResp, err error,\n) {\n\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp = &schema.GetOtherUserInfoResp{}\n\tif !exist {\n\t\treturn resp, nil\n\t}\n\tresp.Has = true\n\tresp.Info = &schema.GetOtherUserInfoByUsernameResp{}\n\tresp.Info.GetFromUserEntity(userInfo)\n\treturn resp, nil\n}\n\n// EmailLogin email login\nfunc (us *UserService) EmailLogin(ctx context.Context, req *schema.UserEmailLogin) (resp *schema.GetUserResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist || userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\tif !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\n\terr = us.userRepo.UpdateLastLoginDate(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(\"UpdateLastLoginDate\", err.Error())\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\n// RetrievePassWord .\nfunc (us *UserService) RetrievePassWord(ctx context.Context, req *schema.UserRetrievePassWordRequest) (string, error) {\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif !has {\n\t\treturn \"\", errors.BadRequest(reason.UserNotFound)\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/password-reset?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.PassResetTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, req.Email, title, body, code, data.ToJSONString())\n\treturn code, nil\n}\n\n// UseRePassword\nfunc (us *UserService) UseRePassword(ctx context.Context, req *schema.UserRePassWordRequest) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tenpass, err := us.encryptPassword(ctx, req.Pass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp = &schema.GetUserResp{}\n\treturn resp, nil\n}\n\nfunc (us *UserService) UserModifyPassWordVerification(ctx context.Context, request *schema.UserModifyPassWordRequest) (bool, error) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n\n// UserModifyPassword user modify password\nfunc (us *UserService) UserModifyPassword(ctx context.Context, request *schema.UserModifyPassWordRequest) error {\n\tenpass, err := us.encryptPassword(ctx, request.Pass)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn fmt.Errorf(\"the old password verification failed\")\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// UpdateInfo update user info\nfunc (us *UserService) UpdateInfo(ctx context.Context, req *schema.UpdateInfoRequest) (\n\terrFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exist && userInfo.ID != req.UserID {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameDuplicate,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameDuplicate)\n\t\t}\n\t\tif checker.IsReservedUsername(req.Username) {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\tavatar, err := json.Marshal(req.Avatar)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserSetAvatar).WithError(err).WithStack()\n\t}\n\tuserInfo := entity.User{}\n\tuserInfo.ID = req.UserID\n\tuserInfo.Avatar = string(avatar)\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Bio = req.Bio\n\tuserInfo.BioHTML = req.BioHTML\n\tuserInfo.Location = req.Location\n\tuserInfo.Website = req.Website\n\tuserInfo.Username = req.Username\n\terr = us.userRepo.UpdateInfo(ctx, &userInfo)\n\treturn nil, err\n}\n\nfunc (us *UserService) UserEmailHas(ctx context.Context, email string) (bool, error) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, email)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn has, nil\n}\n\n// UserUpdateInterface update user interface\nfunc (us *UserService) UserUpdateInterface(ctx context.Context, req *schema.UpdateUserInterfaceRequest) (err error) {\n\tif !translator.CheckLanguageIsValid(req.Language) {\n\t\treturn errors.BadRequest(reason.LangNotFound)\n\t}\n\terr = us.userRepo.UpdateLanguage(ctx, req.UserId, req.Language)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn nil\n}\n\n// UserRegisterByEmail user register\nfunc (us *UserService) UserRegisterByEmail(ctx context.Context, registerUserInfo *schema.UserRegisterReq) (\n\tresp *schema.GetUserResp, errFields []*validator.FormErrorField, err error,\n) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, registerUserInfo.Email)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif has {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   reason.EmailDuplicate,\n\t\t})\n\t\treturn nil, errFields, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = registerUserInfo.Email\n\tuserInfo.DisplayName = registerUserInfo.Name\n\tuserInfo.Pass, err = us.encryptPassword(ctx, registerUserInfo.Pass)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, registerUserInfo.Name)\n\tif err != nil {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t})\n\t\treturn nil, errFields, err\n\t}\n\tuserInfo.IPInfo = registerUserInfo.IP\n\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.LastLoginDate = time.Now()\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  registerUserInfo.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\t// return user info and token\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\treturn resp, nil, nil\n}\n\nfunc (us *UserService) UserVerifyEmailSend(ctx context.Context, userID string) error {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  userInfo.EMail,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\nfunc (us *UserService) UserNoticeSet(ctx context.Context, userID string, noticeSwitch bool) (\n\tresp *schema.UserNoticeSetResp, err error,\n) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tif noticeSwitch {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOn\n\t} else {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOff\n\t}\n\terr = us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, userInfo.NoticeStatus)\n\treturn &schema.UserNoticeSetResp{NoticeSwitch: noticeSwitch}, err\n}\n\nfunc (us *UserService) UserVerifyEmail(ctx context.Context, req *schema.UserVerifyEmailReq) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\terr = us.userRepo.UpdateEmailStatus(ctx, userInfo.ID, userInfo.MailStatus)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = us.userActivity.UserActive(ctx, userInfo.ID); err != nil {\n\t\tlog.Error(err)\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// verifyPassword\n// Compare whether the password is correct\nfunc (us *UserService) verifyPassword(ctx context.Context, LoginPass, UserPass string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(UserPass), []byte(LoginPass))\n\treturn err == nil\n}\n\n// encryptPassword\n// The password does irreversible encryption.\nfunc (us *UserService) encryptPassword(ctx context.Context, Pass string) (string, error) {\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(Pass), bcrypt.DefaultCost)\n\t// This encrypted string can be saved to the database and can be used as password matching verification\n\treturn string(hashPwd), err\n}\n\n// UserChangeEmailSendCode user change email verification\nfunc (us *UserService) UserChangeEmailSendCode(ctx context.Context, req *schema.UserChangeEmailSendCodeReq) (\n\tresp []*validator.FormErrorField, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\t_, exist, err = us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\tresp = append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.EmailDuplicate),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: req.UserID,\n\t}\n\tcode := uuid.NewString()\n\tvar title, body string\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/confirm-new-email?code=%s\", us.getSiteUrl(ctx), code)\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\ttitle, body, err = us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\t} else {\n\t\ttitle, body, err = us.emailService.ChangeEmailTemplate(ctx, verifyEmailURL)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.Infof(\"send email confirmation %s\", verifyEmailURL)\n\n\tgo us.emailService.SendAndSaveCode(context.Background(), req.Email, title, body, code, data.ToJSONString())\n\treturn nil, nil\n}\n\n// UserChangeEmailVerify user change email verify code\nfunc (us *UserService) UserChangeEmailVerify(ctx context.Context, content string) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(content)\n\tif err != nil {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\t_, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif exist {\n\t\treturn errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\t_, exist, err = us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmail(ctx, data.UserID, data.Email)\n\tif err != nil {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmailStatus(ctx, data.UserID, entity.EmailStatusAvailable)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// getSiteUrl get site url\nfunc (us *UserService) getSiteUrl(ctx context.Context) string {\n\tsiteGeneral, err := us.siteInfoService.GetSiteGeneral(ctx)\n\tif err != nil {\n\t\tlog.Errorf(\"get site general failed: %s\", err)\n\t\treturn \"\"\n\t}\n\treturn siteGeneral.SiteUrl\n}\n\n// UserRanking get user ranking\nfunc (us *UserService) UserRanking(ctx context.Context) (resp *schema.UserRankingResp, err error) {\n\tlimit := 20\n\tendTime := time.Now()\n\tstartTime := endTime.AddDate(0, 0, -7)\n\tuserIDs, userIDExist := make([]string, 0), make(map[string]bool, 0)\n\n\t// get most reputation users\n\trankStat, rankStatUserIDs, err := us.getActivityUserRankStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, rankStatUserIDs...)\n\n\t// get most vote users\n\tvoteStat, voteStatUserIDs, err := us.getActivityUserVoteStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, voteStatUserIDs...)\n\n\t// get all staff members\n\tuserRoleRels, staffUserIDs, err := us.getStaff(ctx, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, staffUserIDs...)\n\n\t// get user information\n\tuserInfoMapping, err := us.getUserInfoMapping(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn us.warpStatRankingResp(userInfoMapping, rankStat, voteStat, userRoleRels), nil\n}\n\n// UserUnsubscribeEmailNotification user unsubscribe email notification\nfunc (us *UserService) UserUnsubscribeEmailNotification(\n\tctx context.Context, req *schema.UserUnsubscribeEmailNotificationReq) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil || len(data.UserID) == 0 {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\treturn us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, schema.NoticeStatusOff)\n}\n\nfunc (us *UserService) getActivityUserRankStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (rankStat []*entity.ActivityUserRankStat, userIDs []string, err error) {\n\trankStat, err = us.activityRepo.GetUsersWhoHasGainedTheMostReputation(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn rankStat, userIDs, nil\n}\n\nfunc (us *UserService) getActivityUserVoteStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (voteStat []*entity.ActivityUserVoteStat, userIDs []string, err error) {\n\tvoteStat, err = us.activityRepo.GetUsersWhoHasVoteMost(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn voteStat, userIDs, nil\n}\n\nfunc (us *UserService) getStaff(ctx context.Context, userIDExist map[string]bool) (\n\tuserRoleRels []*entity.UserRoleRel, userIDs []string, err error) {\n\tuserRoleRels, err = us.userRoleService.GetUserByRoleID(ctx, []int{role.RoleAdminID, role.RoleModeratorID})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userIDExist[rel.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, rel.UserID)\n\t\tuserIDExist[rel.UserID] = true\n\t}\n\treturn userRoleRels, userIDs, nil\n}\n\nfunc (us *UserService) getUserInfoMapping(ctx context.Context, userIDs []string) (\n\tuserInfoMapping map[string]*entity.User, err error) {\n\tuserInfoMapping = make(map[string]*entity.User, 0)\n\tif len(userIDs) == 0 {\n\t\treturn userInfoMapping, nil\n\t}\n\tuserInfoList, err := us.userRepo.BatchGetByID(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, user := range userInfoList {\n\t\tuser.Avatar = schema.FormatAvatarInfo(user.Avatar)\n\t\tuserInfoMapping[user.ID] = user\n\t}\n\treturn userInfoMapping, nil\n}\n\nfunc (us *UserService) warpStatRankingResp(\n\tuserInfoMapping map[string]*entity.User,\n\trankStat []*entity.ActivityUserRankStat,\n\tvoteStat []*entity.ActivityUserVoteStat,\n\tuserRoleRels []*entity.UserRoleRel) (resp *schema.UserRankingResp) {\n\tresp = &schema.UserRankingResp{\n\t\tUsersWithTheMostReputation: make([]*schema.UserRankingSimpleInfo, 0),\n\t\tUsersWithTheMostVote:       make([]*schema.UserRankingSimpleInfo, 0),\n\t\tStaffs:                     make([]*schema.UserRankingSimpleInfo, 0),\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostReputation = append(resp.UsersWithTheMostReputation, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        stat.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostVote = append(resp.UsersWithTheMostVote, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tVoteCount:   stat.VoteCount,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userInfo := userInfoMapping[rel.UserID]; userInfo != nil {\n\t\t\tresp.Staffs = append(resp.Staffs, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        userInfo.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\treturn resp\n}\n"], "fixing_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\terr := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UseRePassword(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPassWordRequest  true \"UserModifyPassWordRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/google/uuid\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// UserRepo user repository\n\n// UserService user service\ntype UserService struct {\n\tuserCommonService *usercommon.UserCommon\n\tuserRepo          usercommon.UserRepo\n\tuserActivity      activity.UserActiveActivityRepo\n\tactivityRepo      activity_common.ActivityRepo\n\tserviceConfig     *service_config.ServiceConfig\n\temailService      *export.EmailService\n\tauthService       *auth.AuthService\n\tsiteInfoService   *siteinfo_common.SiteInfoCommonService\n\tuserRoleService   *role.UserRoleRelService\n}\n\nfunc NewUserService(userRepo usercommon.UserRepo,\n\tuserActivity activity.UserActiveActivityRepo,\n\tactivityRepo activity_common.ActivityRepo,\n\temailService *export.EmailService,\n\tauthService *auth.AuthService,\n\tserviceConfig *service_config.ServiceConfig,\n\tsiteInfoService *siteinfo_common.SiteInfoCommonService,\n\tuserRoleService *role.UserRoleRelService,\n\tuserCommonService *usercommon.UserCommon,\n) *UserService {\n\treturn &UserService{\n\t\tuserCommonService: userCommonService,\n\t\tuserRepo:          userRepo,\n\t\tuserActivity:      userActivity,\n\t\tactivityRepo:      activityRepo,\n\t\temailService:      emailService,\n\t\tserviceConfig:     serviceConfig,\n\t\tauthService:       authService,\n\t\tsiteInfoService:   siteInfoService,\n\t\tuserRoleService:   userRoleService,\n\t}\n}\n\n// GetUserInfoByUserID get user info by user id\nfunc (us *UserService) GetUserInfoByUserID(ctx context.Context, token, userID string) (resp *schema.GetUserToSetShowResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp = &schema.GetUserToSetShowResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tresp.AccessToken = token\n\tresp.IsAdmin = roleID == role.RoleAdminID\n\treturn resp, nil\n}\n\nfunc (us *UserService) GetOtherUserInfoByUsername(ctx context.Context, username string) (\n\tresp *schema.GetOtherUserInfoResp, err error,\n) {\n\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp = &schema.GetOtherUserInfoResp{}\n\tif !exist {\n\t\treturn resp, nil\n\t}\n\tresp.Has = true\n\tresp.Info = &schema.GetOtherUserInfoByUsernameResp{}\n\tresp.Info.GetFromUserEntity(userInfo)\n\treturn resp, nil\n}\n\n// EmailLogin email login\nfunc (us *UserService) EmailLogin(ctx context.Context, req *schema.UserEmailLogin) (resp *schema.GetUserResp, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist || userInfo.Status == entity.UserStatusDeleted {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\tif !us.verifyPassword(ctx, req.Pass, userInfo.Pass) {\n\t\treturn nil, errors.BadRequest(reason.EmailOrPasswordWrong)\n\t}\n\n\terr = us.userRepo.UpdateLastLoginDate(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(\"UpdateLastLoginDate\", err.Error())\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, userCacheInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\n// RetrievePassWord .\nfunc (us *UserService) RetrievePassWord(ctx context.Context, req *schema.UserRetrievePassWordRequest) error {\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn nil\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/password-reset?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.PassResetTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, req.Email, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\n// UseRePassword\nfunc (us *UserService) UseRePassword(ctx context.Context, req *schema.UserRePassWordRequest) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tenpass, err := us.encryptPassword(ctx, req.Pass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp = &schema.GetUserResp{}\n\treturn resp, nil\n}\n\nfunc (us *UserService) UserModifyPassWordVerification(ctx context.Context, request *schema.UserModifyPassWordRequest) (bool, error) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n\n// UserModifyPassword user modify password\nfunc (us *UserService) UserModifyPassword(ctx context.Context, request *schema.UserModifyPassWordRequest) error {\n\tenpass, err := us.encryptPassword(ctx, request.Pass)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, request.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn fmt.Errorf(\"user does not exist\")\n\t}\n\tisPass := us.verifyPassword(ctx, request.OldPass, userInfo.Pass)\n\tif !isPass {\n\t\treturn fmt.Errorf(\"the old password verification failed\")\n\t}\n\terr = us.userRepo.UpdatePass(ctx, userInfo.ID, enpass)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// UpdateInfo update user info\nfunc (us *UserService) UpdateInfo(ctx context.Context, req *schema.UpdateInfoRequest) (\n\terrFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := us.userRepo.GetByUsername(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exist && userInfo.ID != req.UserID {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameDuplicate,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameDuplicate)\n\t\t}\n\t\tif checker.IsReservedUsername(req.Username) {\n\t\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t})\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\tavatar, err := json.Marshal(req.Avatar)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.UserSetAvatar).WithError(err).WithStack()\n\t}\n\tuserInfo := entity.User{}\n\tuserInfo.ID = req.UserID\n\tuserInfo.Avatar = string(avatar)\n\tuserInfo.DisplayName = req.DisplayName\n\tuserInfo.Bio = req.Bio\n\tuserInfo.BioHTML = req.BioHTML\n\tuserInfo.Location = req.Location\n\tuserInfo.Website = req.Website\n\tuserInfo.Username = req.Username\n\terr = us.userRepo.UpdateInfo(ctx, &userInfo)\n\treturn nil, err\n}\n\nfunc (us *UserService) UserEmailHas(ctx context.Context, email string) (bool, error) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, email)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn has, nil\n}\n\n// UserUpdateInterface update user interface\nfunc (us *UserService) UserUpdateInterface(ctx context.Context, req *schema.UpdateUserInterfaceRequest) (err error) {\n\tif !translator.CheckLanguageIsValid(req.Language) {\n\t\treturn errors.BadRequest(reason.LangNotFound)\n\t}\n\terr = us.userRepo.UpdateLanguage(ctx, req.UserId, req.Language)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn nil\n}\n\n// UserRegisterByEmail user register\nfunc (us *UserService) UserRegisterByEmail(ctx context.Context, registerUserInfo *schema.UserRegisterReq) (\n\tresp *schema.GetUserResp, errFields []*validator.FormErrorField, err error,\n) {\n\t_, has, err := us.userRepo.GetByEmail(ctx, registerUserInfo.Email)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif has {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   reason.EmailDuplicate,\n\t\t})\n\t\treturn nil, errFields, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tuserInfo := &entity.User{}\n\tuserInfo.EMail = registerUserInfo.Email\n\tuserInfo.DisplayName = registerUserInfo.Name\n\tuserInfo.Pass, err = us.encryptPassword(ctx, registerUserInfo.Pass)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tuserInfo.Username, err = us.userCommonService.MakeUsername(ctx, registerUserInfo.Name)\n\tif err != nil {\n\t\terrFields = append(errFields, &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t})\n\t\treturn nil, errFields, err\n\t}\n\tuserInfo.IPInfo = registerUserInfo.IP\n\tuserInfo.MailStatus = entity.EmailStatusToBeVerified\n\tuserInfo.Status = entity.UserStatusAvailable\n\tuserInfo.LastLoginDate = time.Now()\n\terr = us.userRepo.AddUser(ctx, userInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// send email\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  registerUserInfo.Email,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\t// return user info and token\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\treturn resp, nil, nil\n}\n\nfunc (us *UserService) UserVerifyEmailSend(ctx context.Context, userID string) error {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !has {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  userInfo.EMail,\n\t\tUserID: userInfo.ID,\n\t}\n\tcode := uuid.NewString()\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/account-activation?code=%s\", us.getSiteUrl(ctx), code)\n\ttitle, body, err := us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo us.emailService.SendAndSaveCode(ctx, userInfo.EMail, title, body, code, data.ToJSONString())\n\treturn nil\n}\n\nfunc (us *UserService) UserNoticeSet(ctx context.Context, userID string, noticeSwitch bool) (\n\tresp *schema.UserNoticeSetResp, err error,\n) {\n\tuserInfo, has, err := us.userRepo.GetByUserID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tif noticeSwitch {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOn\n\t} else {\n\t\tuserInfo.NoticeStatus = schema.NoticeStatusOff\n\t}\n\terr = us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, userInfo.NoticeStatus)\n\treturn &schema.UserNoticeSetResp{NoticeSwitch: noticeSwitch}, err\n}\n\nfunc (us *UserService) UserVerifyEmail(ctx context.Context, req *schema.UserVerifyEmailReq) (resp *schema.GetUserResp, err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil {\n\t\treturn nil, errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, has, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\tuserInfo.MailStatus = entity.EmailStatusAvailable\n\terr = us.userRepo.UpdateEmailStatus(ctx, userInfo.ID, userInfo.MailStatus)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = us.userActivity.UserActive(ctx, userInfo.ID); err != nil {\n\t\tlog.Error(err)\n\t}\n\n\troleID, err := us.userRoleService.GetUserRole(ctx, userInfo.ID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\n\tresp = &schema.GetUserResp{}\n\tresp.GetFromUserEntity(userInfo)\n\tuserCacheInfo := &entity.UserCacheInfo{\n\t\tUserID:      userInfo.ID,\n\t\tEmailStatus: userInfo.MailStatus,\n\t\tUserStatus:  userInfo.Status,\n\t\tIsAdmin:     roleID == role.RoleAdminID,\n\t}\n\tresp.AccessToken, err = us.authService.SetUserCacheInfo(ctx, userCacheInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// User verified email will update user email status. So user status cache should be updated.\n\tif err = us.authService.SetUserStatus(ctx, userCacheInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tresp.IsAdmin = userCacheInfo.IsAdmin\n\tif resp.IsAdmin {\n\t\terr = us.authService.SetAdminUserCacheInfo(ctx, resp.AccessToken, &entity.UserCacheInfo{UserID: userInfo.ID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn resp, nil\n}\n\n// verifyPassword\n// Compare whether the password is correct\nfunc (us *UserService) verifyPassword(ctx context.Context, LoginPass, UserPass string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(UserPass), []byte(LoginPass))\n\treturn err == nil\n}\n\n// encryptPassword\n// The password does irreversible encryption.\nfunc (us *UserService) encryptPassword(ctx context.Context, Pass string) (string, error) {\n\thashPwd, err := bcrypt.GenerateFromPassword([]byte(Pass), bcrypt.DefaultCost)\n\t// This encrypted string can be saved to the database and can be used as password matching verification\n\treturn string(hashPwd), err\n}\n\n// UserChangeEmailSendCode user change email verification\nfunc (us *UserService) UserChangeEmailSendCode(ctx context.Context, req *schema.UserChangeEmailSendCodeReq) (\n\tresp []*validator.FormErrorField, err error) {\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, req.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exist {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\t_, exist, err = us.userRepo.GetByEmail(ctx, req.Email)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\tresp = append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLangByCtx(ctx), reason.EmailDuplicate),\n\t\t})\n\t\treturn resp, errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\tdata := &schema.EmailCodeContent{\n\t\tEmail:  req.Email,\n\t\tUserID: req.UserID,\n\t}\n\tcode := uuid.NewString()\n\tvar title, body string\n\tverifyEmailURL := fmt.Sprintf(\"%s/users/confirm-new-email?code=%s\", us.getSiteUrl(ctx), code)\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\ttitle, body, err = us.emailService.RegisterTemplate(ctx, verifyEmailURL)\n\t} else {\n\t\ttitle, body, err = us.emailService.ChangeEmailTemplate(ctx, verifyEmailURL)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.Infof(\"send email confirmation %s\", verifyEmailURL)\n\n\tgo us.emailService.SendAndSaveCode(context.Background(), req.Email, title, body, code, data.ToJSONString())\n\treturn nil, nil\n}\n\n// UserChangeEmailVerify user change email verify code\nfunc (us *UserService) UserChangeEmailVerify(ctx context.Context, content string) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(content)\n\tif err != nil {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\t_, exist, err := us.userRepo.GetByEmail(ctx, data.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif exist {\n\t\treturn errors.BadRequest(reason.EmailDuplicate)\n\t}\n\n\t_, exist, err = us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmail(ctx, data.UserID, data.Email)\n\tif err != nil {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\terr = us.userRepo.UpdateEmailStatus(ctx, data.UserID, entity.EmailStatusAvailable)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// getSiteUrl get site url\nfunc (us *UserService) getSiteUrl(ctx context.Context) string {\n\tsiteGeneral, err := us.siteInfoService.GetSiteGeneral(ctx)\n\tif err != nil {\n\t\tlog.Errorf(\"get site general failed: %s\", err)\n\t\treturn \"\"\n\t}\n\treturn siteGeneral.SiteUrl\n}\n\n// UserRanking get user ranking\nfunc (us *UserService) UserRanking(ctx context.Context) (resp *schema.UserRankingResp, err error) {\n\tlimit := 20\n\tendTime := time.Now()\n\tstartTime := endTime.AddDate(0, 0, -7)\n\tuserIDs, userIDExist := make([]string, 0), make(map[string]bool, 0)\n\n\t// get most reputation users\n\trankStat, rankStatUserIDs, err := us.getActivityUserRankStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, rankStatUserIDs...)\n\n\t// get most vote users\n\tvoteStat, voteStatUserIDs, err := us.getActivityUserVoteStat(ctx, startTime, endTime, limit, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, voteStatUserIDs...)\n\n\t// get all staff members\n\tuserRoleRels, staffUserIDs, err := us.getStaff(ctx, userIDExist)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserIDs = append(userIDs, staffUserIDs...)\n\n\t// get user information\n\tuserInfoMapping, err := us.getUserInfoMapping(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn us.warpStatRankingResp(userInfoMapping, rankStat, voteStat, userRoleRels), nil\n}\n\n// UserUnsubscribeEmailNotification user unsubscribe email notification\nfunc (us *UserService) UserUnsubscribeEmailNotification(\n\tctx context.Context, req *schema.UserUnsubscribeEmailNotificationReq) (err error) {\n\tdata := &schema.EmailCodeContent{}\n\terr = data.FromJSONString(req.Content)\n\tif err != nil || len(data.UserID) == 0 {\n\t\treturn errors.BadRequest(reason.EmailVerifyURLExpired)\n\t}\n\n\tuserInfo, exist, err := us.userRepo.GetByUserID(ctx, data.UserID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exist {\n\t\treturn errors.BadRequest(reason.UserNotFound)\n\t}\n\treturn us.userRepo.UpdateNoticeStatus(ctx, userInfo.ID, schema.NoticeStatusOff)\n}\n\nfunc (us *UserService) getActivityUserRankStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (rankStat []*entity.ActivityUserRankStat, userIDs []string, err error) {\n\trankStat, err = us.activityRepo.GetUsersWhoHasGainedTheMostReputation(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn rankStat, userIDs, nil\n}\n\nfunc (us *UserService) getActivityUserVoteStat(ctx context.Context, startTime, endTime time.Time, limit int,\n\tuserIDExist map[string]bool) (voteStat []*entity.ActivityUserVoteStat, userIDs []string, err error) {\n\tvoteStat, err = us.activityRepo.GetUsersWhoHasVoteMost(ctx, startTime, endTime, limit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userIDExist[stat.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, stat.UserID)\n\t\tuserIDExist[stat.UserID] = true\n\t}\n\treturn voteStat, userIDs, nil\n}\n\nfunc (us *UserService) getStaff(ctx context.Context, userIDExist map[string]bool) (\n\tuserRoleRels []*entity.UserRoleRel, userIDs []string, err error) {\n\tuserRoleRels, err = us.userRoleService.GetUserByRoleID(ctx, []int{role.RoleAdminID, role.RoleModeratorID})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userIDExist[rel.UserID] {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, rel.UserID)\n\t\tuserIDExist[rel.UserID] = true\n\t}\n\treturn userRoleRels, userIDs, nil\n}\n\nfunc (us *UserService) getUserInfoMapping(ctx context.Context, userIDs []string) (\n\tuserInfoMapping map[string]*entity.User, err error) {\n\tuserInfoMapping = make(map[string]*entity.User, 0)\n\tif len(userIDs) == 0 {\n\t\treturn userInfoMapping, nil\n\t}\n\tuserInfoList, err := us.userRepo.BatchGetByID(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, user := range userInfoList {\n\t\tuser.Avatar = schema.FormatAvatarInfo(user.Avatar)\n\t\tuserInfoMapping[user.ID] = user\n\t}\n\treturn userInfoMapping, nil\n}\n\nfunc (us *UserService) warpStatRankingResp(\n\tuserInfoMapping map[string]*entity.User,\n\trankStat []*entity.ActivityUserRankStat,\n\tvoteStat []*entity.ActivityUserVoteStat,\n\tuserRoleRels []*entity.UserRoleRel) (resp *schema.UserRankingResp) {\n\tresp = &schema.UserRankingResp{\n\t\tUsersWithTheMostReputation: make([]*schema.UserRankingSimpleInfo, 0),\n\t\tUsersWithTheMostVote:       make([]*schema.UserRankingSimpleInfo, 0),\n\t\tStaffs:                     make([]*schema.UserRankingSimpleInfo, 0),\n\t}\n\tfor _, stat := range rankStat {\n\t\tif stat.Rank <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostReputation = append(resp.UsersWithTheMostReputation, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        stat.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, stat := range voteStat {\n\t\tif stat.VoteCount <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif userInfo := userInfoMapping[stat.UserID]; userInfo != nil {\n\t\t\tresp.UsersWithTheMostVote = append(resp.UsersWithTheMostVote, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tVoteCount:   stat.VoteCount,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, rel := range userRoleRels {\n\t\tif userInfo := userInfoMapping[rel.UserID]; userInfo != nil {\n\t\t\tresp.Staffs = append(resp.Staffs, &schema.UserRankingSimpleInfo{\n\t\t\t\tUsername:    userInfo.Username,\n\t\t\t\tRank:        userInfo.Rank,\n\t\t\t\tDisplayName: userInfo.DisplayName,\n\t\t\t\tAvatar:      userInfo.Avatar,\n\t\t\t})\n\t\t}\n\t}\n\treturn resp\n}\n"], "filenames": ["internal/controller/user_controller.go", "internal/service/user_service.go"], "buggy_code_start_loc": [160, 152], "buggy_code_end_loc": [161, 174], "fixing_code_start_loc": [160, 152], "fixing_code_end_loc": [161, 174], "type": "CWE-203", "message": "Observable Response Discrepancy in GitHub repository answerdev/answer prior to 1.0.6.", "other": {"cve": {"id": "CVE-2023-1540", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-21T05:15:09.997", "lastModified": "2023-03-23T15:52:20.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Observable Response Discrepancy in GitHub repository answerdev/answer prior to 1.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-204"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.6", "matchCriteriaId": "BC30C65B-0A27-4181-94A2-75BDAD7D7145"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/1de3ec27e50ba7389c9449c59e8ea3a37a908ee4", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/d8d6c259-a0f2-4209-a3b0-ecbf3eb092f4", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/1de3ec27e50ba7389c9449c59e8ea3a37a908ee4"}}