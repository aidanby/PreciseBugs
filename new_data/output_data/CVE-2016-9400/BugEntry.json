{"buggy_code": ["/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n#include <new>\n\n#include <stdlib.h> // qsort\n#include <stdarg.h>\n\n#include <base/math.h>\n#include <base/system.h>\n\n#include <engine/client.h>\n#include <engine/config.h>\n#include <engine/console.h>\n#include <engine/editor.h>\n#include <engine/engine.h>\n#include <engine/graphics.h>\n#include <engine/input.h>\n#include <engine/keys.h>\n#include <engine/map.h>\n#include <engine/masterserver.h>\n#include <engine/serverbrowser.h>\n#include <engine/sound.h>\n#include <engine/storage.h>\n#include <engine/textrender.h>\n\n#include <engine/shared/config.h>\n#include <engine/shared/compression.h>\n#include <engine/shared/datafile.h>\n#include <engine/shared/demo.h>\n#include <engine/shared/filecollection.h>\n#include <engine/shared/mapchecker.h>\n#include <engine/shared/network.h>\n#include <engine/shared/packer.h>\n#include <engine/shared/protocol.h>\n#include <engine/shared/ringbuffer.h>\n#include <engine/shared/snapshot.h>\n\n#include <game/version.h>\n\n#include <mastersrv/mastersrv.h>\n#include <versionsrv/versionsrv.h>\n\n#include \"friends.h\"\n#include \"serverbrowser.h\"\n#include \"client.h\"\n\n#if defined(CONF_FAMILY_WINDOWS)\n\t#define _WIN32_WINNT 0x0501\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n#endif\n\n#include \"SDL.h\"\n#ifdef main\n#undef main\n#endif\n\nvoid CGraph::Init(float Min, float Max)\n{\n\tm_Min = Min;\n\tm_Max = Max;\n\tm_Index = 0;\n}\n\nvoid CGraph::ScaleMax()\n{\n\tint i = 0;\n\tm_Max = 0;\n\tfor(i = 0; i < MAX_VALUES; i++)\n\t{\n\t\tif(m_aValues[i] > m_Max)\n\t\t\tm_Max = m_aValues[i];\n\t}\n}\n\nvoid CGraph::ScaleMin()\n{\n\tint i = 0;\n\tm_Min = m_Max;\n\tfor(i = 0; i < MAX_VALUES; i++)\n\t{\n\t\tif(m_aValues[i] < m_Min)\n\t\t\tm_Min = m_aValues[i];\n\t}\n}\n\nvoid CGraph::Add(float v, float r, float g, float b)\n{\n\tm_Index = (m_Index+1)&(MAX_VALUES-1);\n\tm_aValues[m_Index] = v;\n\tm_aColors[m_Index][0] = r;\n\tm_aColors[m_Index][1] = g;\n\tm_aColors[m_Index][2] = b;\n}\n\nvoid CGraph::Render(IGraphics *pGraphics, int Font, float x, float y, float w, float h, const char *pDescription)\n{\n\t//m_pGraphics->BlendNormal();\n\n\n\tpGraphics->TextureSet(-1);\n\n\tpGraphics->QuadsBegin();\n\tpGraphics->SetColor(0, 0, 0, 0.75f);\n\tIGraphics::CQuadItem QuadItem(x, y, w, h);\n\tpGraphics->QuadsDrawTL(&QuadItem, 1);\n\tpGraphics->QuadsEnd();\n\n\tpGraphics->LinesBegin();\n\tpGraphics->SetColor(0.95f, 0.95f, 0.95f, 1.00f);\n\tIGraphics::CLineItem LineItem(x, y+h/2, x+w, y+h/2);\n\tpGraphics->LinesDraw(&LineItem, 1);\n\tpGraphics->SetColor(0.5f, 0.5f, 0.5f, 0.75f);\n\tIGraphics::CLineItem Array[2] = {\n\t\tIGraphics::CLineItem(x, y+(h*3)/4, x+w, y+(h*3)/4),\n\t\tIGraphics::CLineItem(x, y+h/4, x+w, y+h/4)};\n\tpGraphics->LinesDraw(Array, 2);\n\tfor(int i = 1; i < MAX_VALUES; i++)\n\t{\n\t\tfloat a0 = (i-1)/(float)MAX_VALUES;\n\t\tfloat a1 = i/(float)MAX_VALUES;\n\t\tint i0 = (m_Index+i-1)&(MAX_VALUES-1);\n\t\tint i1 = (m_Index+i)&(MAX_VALUES-1);\n\n\t\tfloat v0 = (m_aValues[i0]-m_Min) / (m_Max-m_Min);\n\t\tfloat v1 = (m_aValues[i1]-m_Min) / (m_Max-m_Min);\n\n\t\tIGraphics::CColorVertex Array[2] = {\n\t\t\tIGraphics::CColorVertex(0, m_aColors[i0][0], m_aColors[i0][1], m_aColors[i0][2], 0.75f),\n\t\t\tIGraphics::CColorVertex(1, m_aColors[i1][0], m_aColors[i1][1], m_aColors[i1][2], 0.75f)};\n\t\tpGraphics->SetColorVertex(Array, 2);\n\t\tIGraphics::CLineItem LineItem(x+a0*w, y+h-v0*h, x+a1*w, y+h-v1*h);\n\t\tpGraphics->LinesDraw(&LineItem, 1);\n\n\t}\n\tpGraphics->LinesEnd();\n\n\tpGraphics->TextureSet(Font);\n\tpGraphics->QuadsBegin();\n\tpGraphics->QuadsText(x+2, y+h-16, 16, pDescription);\n\n\tchar aBuf[32];\n\tstr_format(aBuf, sizeof(aBuf), \"%.2f\", m_Max);\n\tpGraphics->QuadsText(x+w-8*str_length(aBuf)-8, y+2, 16, aBuf);\n\n\tstr_format(aBuf, sizeof(aBuf), \"%.2f\", m_Min);\n\tpGraphics->QuadsText(x+w-8*str_length(aBuf)-8, y+h-16, 16, aBuf);\n\tpGraphics->QuadsEnd();\n}\n\n\nvoid CSmoothTime::Init(int64 Target)\n{\n\tm_Snap = time_get();\n\tm_Current = Target;\n\tm_Target = Target;\n\tm_aAdjustSpeed[0] = 0.3f;\n\tm_aAdjustSpeed[1] = 0.3f;\n\tm_Graph.Init(0.0f, 0.5f);\n}\n\nvoid CSmoothTime::SetAdjustSpeed(int Direction, float Value)\n{\n\tm_aAdjustSpeed[Direction] = Value;\n}\n\nint64 CSmoothTime::Get(int64 Now)\n{\n\tint64 c = m_Current + (Now - m_Snap);\n\tint64 t = m_Target + (Now - m_Snap);\n\n\t// it's faster to adjust upward instead of downward\n\t// we might need to adjust these abit\n\n\tfloat AdjustSpeed = m_aAdjustSpeed[0];\n\tif(t > c)\n\t\tAdjustSpeed = m_aAdjustSpeed[1];\n\n\tfloat a = ((Now-m_Snap)/(float)time_freq()) * AdjustSpeed;\n\tif(a > 1.0f)\n\t\ta = 1.0f;\n\n\tint64 r = c + (int64)((t-c)*a);\n\n\tm_Graph.Add(a+0.5f,1,1,1);\n\n\treturn r;\n}\n\nvoid CSmoothTime::UpdateInt(int64 Target)\n{\n\tint64 Now = time_get();\n\tm_Current = Get(Now);\n\tm_Snap = Now;\n\tm_Target = Target;\n}\n\nvoid CSmoothTime::Update(CGraph *pGraph, int64 Target, int TimeLeft, int AdjustDirection)\n{\n\tint UpdateTimer = 1;\n\n\tif(TimeLeft < 0)\n\t{\n\t\tint IsSpike = 0;\n\t\tif(TimeLeft < -50)\n\t\t{\n\t\t\tIsSpike = 1;\n\n\t\t\tm_SpikeCounter += 5;\n\t\t\tif(m_SpikeCounter > 50)\n\t\t\t\tm_SpikeCounter = 50;\n\t\t}\n\n\t\tif(IsSpike && m_SpikeCounter < 15)\n\t\t{\n\t\t\t// ignore this ping spike\n\t\t\tUpdateTimer = 0;\n\t\t\tpGraph->Add(TimeLeft, 1,1,0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpGraph->Add(TimeLeft, 1,0,0);\n\t\t\tif(m_aAdjustSpeed[AdjustDirection] < 30.0f)\n\t\t\t\tm_aAdjustSpeed[AdjustDirection] *= 2.0f;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(m_SpikeCounter)\n\t\t\tm_SpikeCounter--;\n\n\t\tpGraph->Add(TimeLeft, 0,1,0);\n\n\t\tm_aAdjustSpeed[AdjustDirection] *= 0.95f;\n\t\tif(m_aAdjustSpeed[AdjustDirection] < 2.0f)\n\t\t\tm_aAdjustSpeed[AdjustDirection] = 2.0f;\n\t}\n\n\tif(UpdateTimer)\n\t\tUpdateInt(Target);\n}\n\n\nCClient::CClient() : m_DemoPlayer(&m_SnapshotDelta), m_DemoRecorder(&m_SnapshotDelta)\n{\n\tm_pEditor = 0;\n\tm_pInput = 0;\n\tm_pGraphics = 0;\n\tm_pSound = 0;\n\tm_pGameClient = 0;\n\tm_pMap = 0;\n\tm_pConsole = 0;\n\n\tm_RenderFrameTime = 0.0001f;\n\tm_RenderFrameTimeLow = 1.0f;\n\tm_RenderFrameTimeHigh = 0.0f;\n\tm_RenderFrames = 0;\n\tm_LastRenderTime = time_get();\n\n\tm_GameTickSpeed = SERVER_TICK_SPEED;\n\n\tm_WindowMustRefocus = 0;\n\tm_SnapCrcErrors = 0;\n\tm_AutoScreenshotRecycle = false;\n\tm_EditorActive = false;\n\n\tm_AckGameTick = -1;\n\tm_CurrentRecvTick = 0;\n\tm_RconAuthed = 0;\n\n\t// version-checking\n\tm_aVersionStr[0] = '0';\n\tm_aVersionStr[1] = 0;\n\n\t// pinging\n\tm_PingStartTime = 0;\n\n\t//\n\tm_aCurrentMap[0] = 0;\n\tm_CurrentMapCrc = 0;\n\n\t//\n\tm_aCmdConnect[0] = 0;\n\n\t// map download\n\tm_aMapdownloadFilename[0] = 0;\n\tm_aMapdownloadName[0] = 0;\n\tm_MapdownloadFile = 0;\n\tm_MapdownloadChunk = 0;\n\tm_MapdownloadCrc = 0;\n\tm_MapdownloadAmount = -1;\n\tm_MapdownloadTotalsize = -1;\n\n\tm_CurrentServerInfoRequestTime = -1;\n\n\tm_CurrentInput = 0;\n\n\tm_State = IClient::STATE_OFFLINE;\n\tm_aServerAddressStr[0] = 0;\n\n\tmem_zero(m_aSnapshots, sizeof(m_aSnapshots));\n\tm_SnapshotStorage.Init();\n\tm_RecivedSnapshots = 0;\n\n\tm_VersionInfo.m_State = CVersionInfo::STATE_INIT;\n}\n\n// ----- send functions -----\nint CClient::SendMsg(CMsgPacker *pMsg, int Flags)\n{\n\treturn SendMsgEx(pMsg, Flags, false);\n}\n\nint CClient::SendMsgEx(CMsgPacker *pMsg, int Flags, bool System)\n{\n\tCNetChunk Packet;\n\n\tif(State() == IClient::STATE_OFFLINE)\n\t\treturn 0;\n\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\n\tPacket.m_ClientID = 0;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\n\t// HACK: modify the message id in the packet and store the system flag\n\tif(*((unsigned char*)Packet.m_pData) == 1 && System && Packet.m_DataSize == 1)\n\t\tdbg_break();\n\n\t*((unsigned char*)Packet.m_pData) <<= 1;\n\tif(System)\n\t\t*((unsigned char*)Packet.m_pData) |= 1;\n\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\n\tif(Flags&MSGFLAG_RECORD)\n\t{\n\t\tif(m_DemoRecorder.IsRecording())\n\t\t\tm_DemoRecorder.RecordMessage(Packet.m_pData, Packet.m_DataSize);\n\t}\n\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t\tm_NetClient.Send(&Packet);\n\treturn 0;\n}\n\nvoid CClient::SendInfo()\n{\n\tCMsgPacker Msg(NETMSG_INFO);\n\tMsg.AddString(GameClient()->NetVersion(), 128);\n\tMsg.AddString(g_Config.m_Password, 128);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\n\nvoid CClient::SendEnterGame()\n{\n\tCMsgPacker Msg(NETMSG_ENTERGAME);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\nvoid CClient::SendReady()\n{\n\tCMsgPacker Msg(NETMSG_READY);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\nvoid CClient::RconAuth(const char *pName, const char *pPassword)\n{\n\tif(RconAuthed())\n\t\treturn;\n\n\tCMsgPacker Msg(NETMSG_RCON_AUTH);\n\tMsg.AddString(pName, 32);\n\tMsg.AddString(pPassword, 32);\n\tMsg.AddInt(1);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL);\n}\n\nvoid CClient::Rcon(const char *pCmd)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD);\n\tMsg.AddString(pCmd, 256);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL);\n}\n\nbool CClient::ConnectionProblems()\n{\n\treturn m_NetClient.GotProblems() != 0;\n}\n\nvoid CClient::DirectInput(int *pInput, int Size)\n{\n\tint i;\n\tCMsgPacker Msg(NETMSG_INPUT);\n\tMsg.AddInt(m_AckGameTick);\n\tMsg.AddInt(m_PredTick);\n\tMsg.AddInt(Size);\n\n\tfor(i = 0; i < Size/4; i++)\n\t\tMsg.AddInt(pInput[i]);\n\n\tSendMsgEx(&Msg, 0);\n}\n\n\nvoid CClient::SendInput()\n{\n\tint64 Now = time_get();\n\n\tif(m_PredTick <= 0)\n\t\treturn;\n\n\t// fetch input\n\tint Size = GameClient()->OnSnapInput(m_aInputs[m_CurrentInput].m_aData);\n\n\tif(!Size)\n\t\treturn;\n\n\t// pack input\n\tCMsgPacker Msg(NETMSG_INPUT);\n\tMsg.AddInt(m_AckGameTick);\n\tMsg.AddInt(m_PredTick);\n\tMsg.AddInt(Size);\n\n\tm_aInputs[m_CurrentInput].m_Tick = m_PredTick;\n\tm_aInputs[m_CurrentInput].m_PredictedTime = m_PredictedTime.Get(Now);\n\tm_aInputs[m_CurrentInput].m_Time = Now;\n\n\t// pack it\n\tfor(int i = 0; i < Size/4; i++)\n\t\tMsg.AddInt(m_aInputs[m_CurrentInput].m_aData[i]);\n\n\tm_CurrentInput++;\n\tm_CurrentInput%=200;\n\n\tSendMsgEx(&Msg, MSGFLAG_FLUSH);\n}\n\nconst char *CClient::LatestVersion()\n{\n\treturn m_aVersionStr;\n}\n\n// TODO: OPT: do this alot smarter!\nint *CClient::GetInput(int Tick)\n{\n\tint Best = -1;\n\tfor(int i = 0; i < 200; i++)\n\t{\n\t\tif(m_aInputs[i].m_Tick <= Tick && (Best == -1 || m_aInputs[Best].m_Tick < m_aInputs[i].m_Tick))\n\t\t\tBest = i;\n\t}\n\n\tif(Best != -1)\n\t\treturn (int *)m_aInputs[Best].m_aData;\n\treturn 0;\n}\n\n// ------ state handling -----\nvoid CClient::SetState(int s)\n{\n\tif(m_State == IClient::STATE_QUITING)\n\t\treturn;\n\n\tint Old = m_State;\n\tif(g_Config.m_Debug)\n\t{\n\t\tchar aBuf[128];\n\t\tstr_format(aBuf, sizeof(aBuf), \"state change. last=%d current=%d\", m_State, s);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t}\n\tm_State = s;\n\tif(Old != s)\n\t\tGameClient()->OnStateChange(m_State, Old);\n}\n\n// called when the map is loaded and we should init for a new round\nvoid CClient::OnEnterGame()\n{\n\t// reset input\n\tint i;\n\tfor(i = 0; i < 200; i++)\n\t\tm_aInputs[i].m_Tick = -1;\n\tm_CurrentInput = 0;\n\n\t// reset snapshots\n\tm_aSnapshots[SNAP_CURRENT] = 0;\n\tm_aSnapshots[SNAP_PREV] = 0;\n\tm_SnapshotStorage.PurgeAll();\n\tm_RecivedSnapshots = 0;\n\tm_SnapshotParts = 0;\n\tm_PredTick = 0;\n\tm_CurrentRecvTick = 0;\n\tm_CurGameTick = 0;\n\tm_PrevGameTick = 0;\n}\n\nvoid CClient::EnterGame()\n{\n\tif(State() == IClient::STATE_DEMOPLAYBACK)\n\t\treturn;\n\n\t// now we will wait for two snapshots\n\t// to finish the connection\n\tSendEnterGame();\n\tOnEnterGame();\n}\n\nvoid CClient::Connect(const char *pAddress)\n{\n\tchar aBuf[512];\n\tint Port = 8303;\n\n\tDisconnect();\n\n\tstr_copy(m_aServerAddressStr, pAddress, sizeof(m_aServerAddressStr));\n\n\tstr_format(aBuf, sizeof(aBuf), \"connecting to '%s'\", m_aServerAddressStr);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\tServerInfoRequest();\n\n\tif(net_host_lookup(m_aServerAddressStr, &m_ServerAddress, m_NetClient.NetType()) != 0)\n\t{\n\t\tchar aBufMsg[256];\n\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"could not find the address of %s, connecting to localhost\", aBuf);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBufMsg);\n\t\tnet_host_lookup(\"localhost\", &m_ServerAddress, m_NetClient.NetType());\n\t}\n\n\tm_RconAuthed = 0;\n\tif(m_ServerAddress.port == 0)\n\t\tm_ServerAddress.port = Port;\n\tm_NetClient.Connect(&m_ServerAddress);\n\tSetState(IClient::STATE_CONNECTING);\n\n\tif(m_DemoRecorder.IsRecording())\n\t\tDemoRecorder_Stop();\n\n\tm_InputtimeMarginGraph.Init(-150.0f, 150.0f);\n\tm_GametimeMarginGraph.Init(-150.0f, 150.0f);\n}\n\nvoid CClient::DisconnectWithReason(const char *pReason)\n{\n\tchar aBuf[512];\n\tstr_format(aBuf, sizeof(aBuf), \"disconnecting. reason='%s'\", pReason?pReason:\"unknown\");\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\t// stop demo playback and recorder\n\tm_DemoPlayer.Stop();\n\tDemoRecorder_Stop();\n\n\t//\n\tm_RconAuthed = 0;\n\tm_UseTempRconCommands = 0;\n\tm_pConsole->DeregisterTempAll();\n\tm_NetClient.Disconnect(pReason);\n\tSetState(IClient::STATE_OFFLINE);\n\tm_pMap->Unload();\n\n\t// disable all downloads\n\tm_MapdownloadChunk = 0;\n\tif(m_MapdownloadFile)\n\t\tio_close(m_MapdownloadFile);\n\tm_MapdownloadFile = 0;\n\tm_MapdownloadCrc = 0;\n\tm_MapdownloadTotalsize = -1;\n\tm_MapdownloadAmount = 0;\n\n\t// clear the current server info\n\tmem_zero(&m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n\tmem_zero(&m_ServerAddress, sizeof(m_ServerAddress));\n\n\t// clear snapshots\n\tm_aSnapshots[SNAP_CURRENT] = 0;\n\tm_aSnapshots[SNAP_PREV] = 0;\n\tm_RecivedSnapshots = 0;\n}\n\nvoid CClient::Disconnect()\n{\n\tDisconnectWithReason(0);\n}\n\n\nvoid CClient::GetServerInfo(CServerInfo *pServerInfo)\n{\n\tmem_copy(pServerInfo, &m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n}\n\nvoid CClient::ServerInfoRequest()\n{\n\tmem_zero(&m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n\tm_CurrentServerInfoRequestTime = 0;\n}\n\nint CClient::LoadData()\n{\n\tm_DebugFont = Graphics()->LoadTexture(\"debug_font.png\", IStorage::TYPE_ALL, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_NORESAMPLE);\n\treturn 1;\n}\n\n// ---\n\nvoid *CClient::SnapGetItem(int SnapID, int Index, CSnapItem *pItem)\n{\n\tCSnapshotItem *i;\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\ti = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(Index);\n\tpItem->m_DataSize = m_aSnapshots[SnapID]->m_pAltSnap->GetItemSize(Index);\n\tpItem->m_Type = i->Type();\n\tpItem->m_ID = i->ID();\n\treturn (void *)i->Data();\n}\n\nvoid CClient::SnapInvalidateItem(int SnapID, int Index)\n{\n\tCSnapshotItem *i;\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\ti = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(Index);\n\tif(i)\n\t{\n\t\tif((char *)i < (char *)m_aSnapshots[SnapID]->m_pAltSnap || (char *)i > (char *)m_aSnapshots[SnapID]->m_pAltSnap + m_aSnapshots[SnapID]->m_SnapSize)\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"snap invalidate problem\");\n\t\tif((char *)i >= (char *)m_aSnapshots[SnapID]->m_pSnap && (char *)i < (char *)m_aSnapshots[SnapID]->m_pSnap + m_aSnapshots[SnapID]->m_SnapSize)\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"snap invalidate problem\");\n\t\ti->m_TypeAndID = -1;\n\t}\n}\n\nvoid *CClient::SnapFindItem(int SnapID, int Type, int ID)\n{\n\t// TODO: linear search. should be fixed.\n\tint i;\n\n\tif(!m_aSnapshots[SnapID])\n\t\treturn 0x0;\n\n\tfor(i = 0; i < m_aSnapshots[SnapID]->m_pSnap->NumItems(); i++)\n\t{\n\t\tCSnapshotItem *pItem = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(i);\n\t\tif(pItem->Type() == Type && pItem->ID() == ID)\n\t\t\treturn (void *)pItem->Data();\n\t}\n\treturn 0x0;\n}\n\nint CClient::SnapNumItems(int SnapID)\n{\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\tif(!m_aSnapshots[SnapID])\n\t\treturn 0;\n\treturn m_aSnapshots[SnapID]->m_pSnap->NumItems();\n}\n\nvoid CClient::SnapSetStaticsize(int ItemType, int Size)\n{\n\tm_SnapshotDelta.SetStaticsize(ItemType, Size);\n}\n\n\nvoid CClient::DebugRender()\n{\n\tstatic NETSTATS Prev, Current;\n\tstatic int64 LastSnap = 0;\n\tstatic float FrameTimeAvg = 0;\n\tint64 Now = time_get();\n\tchar aBuffer[512];\n\n\tif(!g_Config.m_Debug)\n\t\treturn;\n\n\t//m_pGraphics->BlendNormal();\n\tGraphics()->TextureSet(m_DebugFont);\n\tGraphics()->MapScreen(0,0,Graphics()->ScreenWidth(),Graphics()->ScreenHeight());\n\tGraphics()->QuadsBegin();\n\n\tif(time_get()-LastSnap > time_freq())\n\t{\n\t\tLastSnap = time_get();\n\t\tPrev = Current;\n\t\tnet_stats(&Current);\n\t}\n\n\t/*\n\t\teth = 14\n\t\tip = 20\n\t\tudp = 8\n\t\ttotal = 42\n\t*/\n\tFrameTimeAvg = FrameTimeAvg*0.9f + m_RenderFrameTime*0.1f;\n\tstr_format(aBuffer, sizeof(aBuffer), \"ticks: %8d %8d mem %dk %d gfxmem: %dk fps: %3d\",\n\t\tm_CurGameTick, m_PredTick,\n\t\tmem_stats()->allocated/1024,\n\t\tmem_stats()->total_allocations,\n\t\tGraphics()->MemoryUsage()/1024,\n\t\t(int)(1.0f/FrameTimeAvg + 0.5f));\n\tGraphics()->QuadsText(2, 2, 16, aBuffer);\n\n\n\t{\n\t\tint SendPackets = (Current.sent_packets-Prev.sent_packets);\n\t\tint SendBytes = (Current.sent_bytes-Prev.sent_bytes);\n\t\tint SendTotal = SendBytes + SendPackets*42;\n\t\tint RecvPackets = (Current.recv_packets-Prev.recv_packets);\n\t\tint RecvBytes = (Current.recv_bytes-Prev.recv_bytes);\n\t\tint RecvTotal = RecvBytes + RecvPackets*42;\n\n\t\tif(!SendPackets) SendPackets++;\n\t\tif(!RecvPackets) RecvPackets++;\n\t\tstr_format(aBuffer, sizeof(aBuffer), \"send: %3d %5d+%4d=%5d (%3d kbps) avg: %5d\\nrecv: %3d %5d+%4d=%5d (%3d kbps) avg: %5d\",\n\t\t\tSendPackets, SendBytes, SendPackets*42, SendTotal, (SendTotal*8)/1024, SendBytes/SendPackets,\n\t\t\tRecvPackets, RecvBytes, RecvPackets*42, RecvTotal, (RecvTotal*8)/1024, RecvBytes/RecvPackets);\n\t\tGraphics()->QuadsText(2, 14, 16, aBuffer);\n\t}\n\n\t// render rates\n\t{\n\t\tint y = 0;\n\t\tint i;\n\t\tfor(i = 0; i < 256; i++)\n\t\t{\n\t\t\tif(m_SnapshotDelta.GetDataRate(i))\n\t\t\t{\n\t\t\t\tstr_format(aBuffer, sizeof(aBuffer), \"%4d %20s: %8d %8d %8d\", i, GameClient()->GetItemName(i), m_SnapshotDelta.GetDataRate(i)/8, m_SnapshotDelta.GetDataUpdates(i),\n\t\t\t\t\t(m_SnapshotDelta.GetDataRate(i)/m_SnapshotDelta.GetDataUpdates(i))/8);\n\t\t\t\tGraphics()->QuadsText(2, 100+y*12, 16, aBuffer);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstr_format(aBuffer, sizeof(aBuffer), \"pred: %d ms\",\n\t\t(int)((m_PredictedTime.Get(Now)-m_GameTime.Get(Now))*1000/(float)time_freq()));\n\tGraphics()->QuadsText(2, 70, 16, aBuffer);\n\tGraphics()->QuadsEnd();\n\n\t// render graphs\n\tif(g_Config.m_DbgGraphs)\n\t{\n\t\t//Graphics()->MapScreen(0,0,400.0f,300.0f);\n\t\tfloat w = Graphics()->ScreenWidth()/4.0f;\n\t\tfloat h = Graphics()->ScreenHeight()/6.0f;\n\t\tfloat sp = Graphics()->ScreenWidth()/100.0f;\n\t\tfloat x = Graphics()->ScreenWidth()-w-sp;\n\n\t\tm_FpsGraph.ScaleMax();\n\t\tm_FpsGraph.ScaleMin();\n\t\tm_FpsGraph.Render(Graphics(), m_DebugFont, x, sp*5, w, h, \"FPS\");\n\t\tm_InputtimeMarginGraph.Render(Graphics(), m_DebugFont, x, sp*5+h+sp, w, h, \"Prediction Margin\");\n\t\tm_GametimeMarginGraph.Render(Graphics(), m_DebugFont, x, sp*5+h+sp+h+sp, w, h, \"Gametime Margin\");\n\t}\n}\n\nvoid CClient::Quit()\n{\n\tSetState(IClient::STATE_QUITING);\n}\n\nconst char *CClient::ErrorString()\n{\n\treturn m_NetClient.ErrorString();\n}\n\nvoid CClient::Render()\n{\n\tif(g_Config.m_GfxClear)\n\t\tGraphics()->Clear(1,1,0);\n\n\tGameClient()->OnRender();\n\tDebugRender();\n}\n\nconst char *CClient::LoadMap(const char *pName, const char *pFilename, unsigned WantedCrc)\n{\n\tstatic char aErrorMsg[128];\n\n\tSetState(IClient::STATE_LOADING);\n\n\tif(!m_pMap->Load(pFilename))\n\t{\n\t\tstr_format(aErrorMsg, sizeof(aErrorMsg), \"map '%s' not found\", pFilename);\n\t\treturn aErrorMsg;\n\t}\n\n\t// get the crc of the map\n\tif(m_pMap->Crc() != WantedCrc)\n\t{\n\t\tstr_format(aErrorMsg, sizeof(aErrorMsg), \"map differs from the server. %08x != %08x\", m_pMap->Crc(), WantedCrc);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aErrorMsg);\n\t\tm_pMap->Unload();\n\t\treturn aErrorMsg;\n\t}\n\n\t// stop demo recording if we loaded a new map\n\tDemoRecorder_Stop();\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"loaded map '%s'\", pFilename);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aBuf);\n\tm_RecivedSnapshots = 0;\n\n\tstr_copy(m_aCurrentMap, pName, sizeof(m_aCurrentMap));\n\tm_CurrentMapCrc = m_pMap->Crc();\n\n\treturn 0x0;\n}\n\n\n\nconst char *CClient::LoadMapSearch(const char *pMapName, int WantedCrc)\n{\n\tconst char *pError = 0;\n\tchar aBuf[512];\n\tstr_format(aBuf, sizeof(aBuf), \"loading map, map=%s wanted crc=%08x\", pMapName, WantedCrc);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aBuf);\n\tSetState(IClient::STATE_LOADING);\n\n\t// try the normal maps folder\n\tstr_format(aBuf, sizeof(aBuf), \"maps/%s.map\", pMapName);\n\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\tif(!pError)\n\t\treturn pError;\n\n\t// try the downloaded maps\n\tstr_format(aBuf, sizeof(aBuf), \"downloadedmaps/%s_%08x.map\", pMapName, WantedCrc);\n\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\tif(!pError)\n\t\treturn pError;\n\n\t// search for the map within subfolders\n\tchar aFilename[128];\n\tstr_format(aFilename, sizeof(aFilename), \"%s.map\", pMapName);\n\tif(Storage()->FindFile(aFilename, \"maps\", IStorage::TYPE_ALL, aBuf, sizeof(aBuf)))\n\t\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\n\treturn pError;\n}\n\nint CClient::PlayerScoreComp(const void *a, const void *b)\n{\n\tCServerInfo::CClient *p0 = (CServerInfo::CClient *)a;\n\tCServerInfo::CClient *p1 = (CServerInfo::CClient *)b;\n\tif(p0->m_Player && !p1->m_Player)\n\t\treturn -1;\n\tif(!p0->m_Player && p1->m_Player)\n\t\treturn 1;\n\tif(p0->m_Score == p1->m_Score)\n\t\treturn 0;\n\tif(p0->m_Score < p1->m_Score)\n\t\treturn 1;\n\treturn -1;\n}\n\nvoid CClient::ProcessConnlessPacket(CNetChunk *pPacket)\n{\n\t// version server\n\tif(m_VersionInfo.m_State == CVersionInfo::STATE_READY && net_addr_comp(&pPacket->m_Address, &m_VersionInfo.m_VersionServeraddr.m_Addr) == 0)\n\t{\n\t\t// version info\n\t\tif(pPacket->m_DataSize == (int)(sizeof(VERSIONSRV_VERSION) + sizeof(GAME_RELEASE_VERSION)) &&\n\t\t\tmem_comp(pPacket->m_pData, VERSIONSRV_VERSION, sizeof(VERSIONSRV_VERSION)) == 0)\n\n\t\t{\n\t\t\tchar *pVersionData = (char*)pPacket->m_pData + sizeof(VERSIONSRV_VERSION);\n\t\t\tint VersionMatch = !mem_comp(pVersionData, GAME_RELEASE_VERSION, sizeof(GAME_RELEASE_VERSION));\n\n\t\t\tchar aVersion[sizeof(GAME_RELEASE_VERSION)];\n\t\t\tstr_copy(aVersion, pVersionData, sizeof(aVersion));\n\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"version does %s (%s)\",\n\t\t\t\tVersionMatch ? \"match\" : \"NOT match\",\n\t\t\t\taVersion);\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/version\", aBuf);\n\n\t\t\t// assume version is out of date when version-data doesn't match\n\t\t\tif(!VersionMatch)\n\t\t\t{\n\t\t\t\tstr_copy(m_aVersionStr, aVersion, sizeof(m_aVersionStr));\n\t\t\t}\n\n\t\t\t// request the map version list now\n\t\t\tCNetChunk Packet;\n\t\t\tmem_zero(&Packet, sizeof(Packet));\n\t\t\tPacket.m_ClientID = -1;\n\t\t\tPacket.m_Address = m_VersionInfo.m_VersionServeraddr.m_Addr;\n\t\t\tPacket.m_pData = VERSIONSRV_GETMAPLIST;\n\t\t\tPacket.m_DataSize = sizeof(VERSIONSRV_GETMAPLIST);\n\t\t\tPacket.m_Flags = NETSENDFLAG_CONNLESS;\n\t\t\tm_ContactClient.Send(&Packet);\n\t\t}\n\n\t\t// map version list\n\t\tif(pPacket->m_DataSize >= (int)sizeof(VERSIONSRV_MAPLIST) &&\n\t\t\tmem_comp(pPacket->m_pData, VERSIONSRV_MAPLIST, sizeof(VERSIONSRV_MAPLIST)) == 0)\n\t\t{\n\t\t\tint Size = pPacket->m_DataSize-sizeof(VERSIONSRV_MAPLIST);\n\t\t\tint Num = Size/sizeof(CMapVersion);\n\t\t\tm_MapChecker.AddMaplist((CMapVersion *)((char*)pPacket->m_pData+sizeof(VERSIONSRV_MAPLIST)), Num);\n\t\t}\n\t}\n\n\t// server list from master server\n\tif(pPacket->m_DataSize >= (int)sizeof(SERVERBROWSE_LIST) &&\n\t\tmem_comp(pPacket->m_pData, SERVERBROWSE_LIST, sizeof(SERVERBROWSE_LIST)) == 0)\n\t{\n\t\t// check for valid master server address\n\t\tbool Valid = false;\n\t\tfor(int i = 0; i < IMasterServer::MAX_MASTERSERVERS; ++i)\n\t\t{\n\t\t\tif(m_pMasterServer->IsValid(i))\n\t\t\t{\n\t\t\t\tNETADDR Addr = m_pMasterServer->GetAddr(i);\n\t\t\t\tif(net_addr_comp(&pPacket->m_Address, &Addr) == 0)\n\t\t\t\t{\n\t\t\t\t\tValid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!Valid)\n\t\t\treturn;\n\n\t\tint Size = pPacket->m_DataSize-sizeof(SERVERBROWSE_LIST);\n\t\tint Num = Size/sizeof(CMastersrvAddr);\n\t\tCMastersrvAddr *pAddrs = (CMastersrvAddr *)((char*)pPacket->m_pData+sizeof(SERVERBROWSE_LIST));\n\t\tfor(int i = 0; i < Num; i++)\n\t\t{\n\t\t\tNETADDR Addr;\n\n\t\t\tstatic unsigned char IPV4Mapping[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };\n\n\t\t\t// copy address\n\t\t\tif(!mem_comp(IPV4Mapping, pAddrs[i].m_aIp, sizeof(IPV4Mapping)))\n\t\t\t{\n\t\t\t\tmem_zero(&Addr, sizeof(Addr));\n\t\t\t\tAddr.type = NETTYPE_IPV4;\n\t\t\t\tAddr.ip[0] = pAddrs[i].m_aIp[12];\n\t\t\t\tAddr.ip[1] = pAddrs[i].m_aIp[13];\n\t\t\t\tAddr.ip[2] = pAddrs[i].m_aIp[14];\n\t\t\t\tAddr.ip[3] = pAddrs[i].m_aIp[15];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAddr.type = NETTYPE_IPV6;\n\t\t\t\tmem_copy(Addr.ip, pAddrs[i].m_aIp, sizeof(Addr.ip));\n\t\t\t}\n\t\t\tAddr.port = (pAddrs[i].m_aPort[0]<<8) | pAddrs[i].m_aPort[1];\n\n\t\t\tm_ServerBrowser.Set(Addr, IServerBrowser::SET_MASTER_ADD, -1, 0x0);\n\t\t}\n\t}\n\n\t// server info\n\tif(pPacket->m_DataSize >= (int)sizeof(SERVERBROWSE_INFO) && mem_comp(pPacket->m_pData, SERVERBROWSE_INFO, sizeof(SERVERBROWSE_INFO)) == 0)\n\t{\n\t\t// we got ze info\n\t\tCUnpacker Up;\n\t\tCServerInfo Info = {0};\n\n\t\tUp.Reset((unsigned char*)pPacket->m_pData+sizeof(SERVERBROWSE_INFO), pPacket->m_DataSize-sizeof(SERVERBROWSE_INFO));\n\t\tint Token = str_toint(Up.GetString());\n\t\tstr_copy(Info.m_aVersion, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aVersion));\n\t\tstr_copy(Info.m_aName, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aName));\n\t\tstr_copy(Info.m_aMap, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aMap));\n\t\tstr_copy(Info.m_aGameType, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aGameType));\n\t\tInfo.m_Flags = str_toint(Up.GetString());\n\t\tInfo.m_NumPlayers = str_toint(Up.GetString());\n\t\tInfo.m_MaxPlayers = str_toint(Up.GetString());\n\t\tInfo.m_NumClients = str_toint(Up.GetString());\n\t\tInfo.m_MaxClients = str_toint(Up.GetString());\n\n\t\t// don't add invalid info to the server browser list\n\t\tif(Info.m_NumClients < 0 || Info.m_NumClients > MAX_CLIENTS || Info.m_MaxClients < 0 || Info.m_MaxClients > MAX_CLIENTS ||\n\t\t\tInfo.m_NumPlayers < 0 || Info.m_NumPlayers > Info.m_NumClients || Info.m_MaxPlayers < 0 || Info.m_MaxPlayers > Info.m_MaxClients)\n\t\t\treturn;\n\n\t\tnet_addr_str(&pPacket->m_Address, Info.m_aAddress, sizeof(Info.m_aAddress), true);\n\n\t\tfor(int i = 0; i < Info.m_NumClients; i++)\n\t\t{\n\t\t\tstr_copy(Info.m_aClients[i].m_aName, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aClients[i].m_aName));\n\t\t\tstr_copy(Info.m_aClients[i].m_aClan, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aClients[i].m_aClan));\n\t\t\tInfo.m_aClients[i].m_Country = str_toint(Up.GetString());\n\t\t\tInfo.m_aClients[i].m_Score = str_toint(Up.GetString());\n\t\t\tInfo.m_aClients[i].m_Player = str_toint(Up.GetString()) != 0 ? true : false;\n\t\t}\n\n\t\tif(!Up.Error())\n\t\t{\n\t\t\t// sort players\n\t\t\tqsort(Info.m_aClients, Info.m_NumClients, sizeof(*Info.m_aClients), PlayerScoreComp);\n\n\t\t\tif(net_addr_comp(&m_ServerAddress, &pPacket->m_Address) == 0)\n\t\t\t{\n\t\t\t\tmem_copy(&m_CurrentServerInfo, &Info, sizeof(m_CurrentServerInfo));\n\t\t\t\tm_CurrentServerInfo.m_NetAddr = m_ServerAddress;\n\t\t\t\tm_CurrentServerInfoRequestTime = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_ServerBrowser.Set(pPacket->m_Address, IServerBrowser::SET_TOKEN, Token, &Info);\n\t\t}\n\t}\n}\n\nvoid CClient::ProcessServerPacket(CNetChunk *pPacket)\n{\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_CHANGE)\n\t\t{\n\t\t\tconst char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES);\n\t\t\tint MapCrc = Unpacker.GetInt();\n\t\t\tint MapSize = Unpacker.GetInt();\n\t\t\tconst char *pError = 0;\n\n\t\t\tif(Unpacker.Error())\n\t\t\t\treturn;\n\n\t\t\t// check for valid standard map\n\t\t\tif(!m_MapChecker.IsMapValid(pMap, MapCrc, MapSize))\n\t\t\t\tpError = \"invalid standard map\";\n\n\t\t\tfor(int i = 0; pMap[i]; i++) // protect the player from nasty map names\n\t\t\t{\n\t\t\t\tif(pMap[i] == '/' || pMap[i] == '\\\\')\n\t\t\t\t\tpError = \"strange character in map name\";\n\t\t\t}\n\n\t\t\tif(MapSize < 0)\n\t\t\t\tpError = \"invalid map size\";\n\n\t\t\tif(pError)\n\t\t\t\tDisconnectWithReason(pError);\n\t\t\telse\n\t\t\t{\n\t\t\t\tpError = LoadMapSearch(pMap, MapCrc);\n\n\t\t\t\tif(!pError)\n\t\t\t\t{\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"loading done\");\n\t\t\t\t\tSendReady();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr_format(m_aMapdownloadFilename, sizeof(m_aMapdownloadFilename), \"downloadedmaps/%s_%08x.map\", pMap, MapCrc);\n\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"starting to download map to '%s'\", m_aMapdownloadFilename);\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", aBuf);\n\n\t\t\t\t\tm_MapdownloadChunk = 0;\n\t\t\t\t\tstr_copy(m_aMapdownloadName, pMap, sizeof(m_aMapdownloadName));\n\t\t\t\t\tif(m_MapdownloadFile)\n\t\t\t\t\t\tio_close(m_MapdownloadFile);\n\t\t\t\t\tm_MapdownloadFile = Storage()->OpenFile(m_aMapdownloadFilename, IOFLAG_WRITE, IStorage::TYPE_SAVE);\n\t\t\t\t\tm_MapdownloadCrc = MapCrc;\n\t\t\t\t\tm_MapdownloadTotalsize = MapSize;\n\t\t\t\t\tm_MapdownloadAmount = 0;\n\n\t\t\t\t\tCMsgPacker Msg(NETMSG_REQUEST_MAP_DATA);\n\t\t\t\t\tMsg.AddInt(m_MapdownloadChunk);\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n\n\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t{\n\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);\n\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client/network\", aBuf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA)\n\t\t{\n\t\t\tint Last = Unpacker.GetInt();\n\t\t\tint MapCRC = Unpacker.GetInt();\n\t\t\tint Chunk = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\t\t\tconst unsigned char *pData = Unpacker.GetRaw(Size);\n\n\t\t\t// check fior errors\n\t\t\tif(Unpacker.Error() || Size <= 0 || MapCRC != m_MapdownloadCrc || Chunk != m_MapdownloadChunk || !m_MapdownloadFile)\n\t\t\t\treturn;\n\n\t\t\tio_write(m_MapdownloadFile, pData, Size);\n\n\t\t\tm_MapdownloadAmount += Size;\n\n\t\t\tif(Last)\n\t\t\t{\n\t\t\t\tconst char *pError;\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"download complete, loading map\");\n\n\t\t\t\tif(m_MapdownloadFile)\n\t\t\t\t\tio_close(m_MapdownloadFile);\n\t\t\t\tm_MapdownloadFile = 0;\n\t\t\t\tm_MapdownloadAmount = 0;\n\t\t\t\tm_MapdownloadTotalsize = -1;\n\n\t\t\t\t// load map\n\t\t\t\tpError = LoadMap(m_aMapdownloadName, m_aMapdownloadFilename, m_MapdownloadCrc);\n\t\t\t\tif(!pError)\n\t\t\t\t{\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"loading done\");\n\t\t\t\t\tSendReady();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDisconnectWithReason(pError);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// request new chunk\n\t\t\t\tm_MapdownloadChunk++;\n\n\t\t\t\tCMsgPacker Msg(NETMSG_REQUEST_MAP_DATA);\n\t\t\t\tMsg.AddInt(m_MapdownloadChunk);\n\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n\n\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t{\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client/network\", aBuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY)\n\t\t{\n\t\t\tGameClient()->OnConnected();\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY);\n\t\t\tSendMsgEx(&Msg, 0);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD)\n\t\t{\n\t\t\tconst char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tconst char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tconst char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM)\n\t\t{\n\t\t\tconst char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_pConsole->DeregisterTemp(pName);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_STATUS)\n\t\t{\n\t\t\tint Result = Unpacker.GetInt();\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_RconAuthed = Result;\n\t\t\tint Old = m_UseTempRconCommands;\n\t\t\tm_UseTempRconCommands = Unpacker.GetInt();\n\t\t\tif(Unpacker.Error() != 0)\n\t\t\t\tm_UseTempRconCommands = 0;\n\t\t\tif(Old != 0 && m_UseTempRconCommands == 0)\n\t\t\t\tm_pConsole->DeregisterTempAll();\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE)\n\t\t{\n\t\t\tconst char *pLine = Unpacker.GetString();\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tGameClient()->OnRconLine(pLine);\n\t\t}\n\t\telse if(Msg == NETMSG_PING_REPLY)\n\t\t{\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"latency %.2f\", (time_get() - m_PingStartTime)*1000 / (float)time_freq());\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client/network\", aBuf);\n\t\t}\n\t\telse if(Msg == NETMSG_INPUTTIMING)\n\t\t{\n\t\t\tint InputPredTick = Unpacker.GetInt();\n\t\t\tint TimeLeft = Unpacker.GetInt();\n\n\t\t\t// adjust our prediction time\n\t\t\tint64 Target = 0;\n\t\t\tfor(int k = 0; k < 200; k++)\n\t\t\t{\n\t\t\t\tif(m_aInputs[k].m_Tick == InputPredTick)\n\t\t\t\t{\n\t\t\t\t\tTarget = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time);\n\t\t\t\t\tTarget = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(Target)\n\t\t\t\tm_PredictedTime.Update(&m_InputtimeMarginGraph, Target, TimeLeft, 1);\n\t\t}\n\t\telse if(Msg == NETMSG_SNAP || Msg == NETMSG_SNAPSINGLE || Msg == NETMSG_SNAPEMPTY)\n\t\t{\n\t\t\tint NumParts = 1;\n\t\t\tint Part = 0;\n\t\t\tint GameTick = Unpacker.GetInt();\n\t\t\tint DeltaTick = GameTick-Unpacker.GetInt();\n\t\t\tint PartSize = 0;\n\t\t\tint Crc = 0;\n\t\t\tint CompleteSize = 0;\n\t\t\tconst char *pData = 0;\n\n\t\t\t// we are not allowed to process snapshot yet\n\t\t\tif(State() < IClient::STATE_LOADING)\n\t\t\t\treturn;\n\n\t\t\tif(Msg == NETMSG_SNAP)\n\t\t\t{\n\t\t\t\tNumParts = Unpacker.GetInt();\n\t\t\t\tPart = Unpacker.GetInt();\n\t\t\t}\n\n\t\t\tif(Msg != NETMSG_SNAPEMPTY)\n\t\t\t{\n\t\t\t\tCrc = Unpacker.GetInt();\n\t\t\t\tPartSize = Unpacker.GetInt();\n\t\t\t}\n\n\t\t\tpData = (const char *)Unpacker.GetRaw(PartSize);\n\n\t\t\tif(Unpacker.Error())\n\t\t\t\treturn;\n\n\t\t\tif(GameTick >= m_CurrentRecvTick)\n\t\t\t{\n\t\t\t\tif(GameTick != m_CurrentRecvTick)\n\t\t\t\t{\n\t\t\t\t\tm_SnapshotParts = 0;\n\t\t\t\t\tm_CurrentRecvTick = GameTick;\n\t\t\t\t}\n\n\t\t\t\t// TODO: clean this up abit\n\t\t\t\tmem_copy((char*)m_aSnapshotIncommingData + Part*MAX_SNAPSHOT_PACKSIZE, pData, PartSize);\n\t\t\t\tm_SnapshotParts |= 1<<Part;\n\n\t\t\t\tif(m_SnapshotParts == (unsigned)((1<<NumParts)-1))\n\t\t\t\t{\n\t\t\t\t\tstatic CSnapshot Emptysnap;\n\t\t\t\t\tCSnapshot *pDeltaShot = &Emptysnap;\n\t\t\t\t\tint PurgeTick;\n\t\t\t\t\tvoid *pDeltaData;\n\t\t\t\t\tint DeltaSize;\n\t\t\t\t\tunsigned char aTmpBuffer2[CSnapshot::MAX_SIZE];\n\t\t\t\t\tunsigned char aTmpBuffer3[CSnapshot::MAX_SIZE];\n\t\t\t\t\tCSnapshot *pTmpBuffer3 = (CSnapshot*)aTmpBuffer3;\t// Fix compiler warning for strict-aliasing\n\t\t\t\t\tint SnapSize;\n\n\t\t\t\t\tCompleteSize = (NumParts-1) * MAX_SNAPSHOT_PACKSIZE + PartSize;\n\n\t\t\t\t\t// reset snapshoting\n\t\t\t\t\tm_SnapshotParts = 0;\n\n\t\t\t\t\t// find snapshot that we should use as delta\n\t\t\t\t\tEmptysnap.Clear();\n\n\t\t\t\t\t// find delta\n\t\t\t\t\tif(DeltaTick >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint DeltashotSize = m_SnapshotStorage.Get(DeltaTick, 0, &pDeltaShot, 0);\n\n\t\t\t\t\t\tif(DeltashotSize < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// couldn't find the delta snapshots that the server used\n\t\t\t\t\t\t\t// to compress this snapshot. force the server to resync\n\t\t\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"error, couldn't find the delta snapshot\");\n\t\t\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// ack snapshot\n\t\t\t\t\t\t\t// TODO: combine this with the input message\n\t\t\t\t\t\t\tm_AckGameTick = -1;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress snapshot\n\t\t\t\t\tpDeltaData = m_SnapshotDelta.EmptyDelta();\n\t\t\t\t\tDeltaSize = sizeof(int)*3;\n\n\t\t\t\t\tif(CompleteSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tint IntSize = CVariableInt::Decompress(m_aSnapshotIncommingData, CompleteSize, aTmpBuffer2);\n\n\t\t\t\t\t\tif(IntSize < 0) // failure during decompression, bail\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tpDeltaData = aTmpBuffer2;\n\t\t\t\t\t\tDeltaSize = IntSize;\n\t\t\t\t\t}\n\n\t\t\t\t\t// unpack delta\n\t\t\t\t\tSnapSize = m_SnapshotDelta.UnpackDelta(pDeltaShot, pTmpBuffer3, pDeltaData, DeltaSize);\n\t\t\t\t\tif(SnapSize < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"delta unpack failed!\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(Msg != NETMSG_SNAPEMPTY && pTmpBuffer3->Crc() != Crc)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"snapshot crc error #%d - tick=%d wantedcrc=%d gotcrc=%d compressed_size=%d delta_tick=%d\",\n\t\t\t\t\t\t\t\tm_SnapCrcErrors, GameTick, Crc, pTmpBuffer3->Crc(), CompleteSize, DeltaTick);\n\t\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm_SnapCrcErrors++;\n\t\t\t\t\t\tif(m_SnapCrcErrors > 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// to many errors, send reset\n\t\t\t\t\t\t\tm_AckGameTick = -1;\n\t\t\t\t\t\t\tSendInput();\n\t\t\t\t\t\t\tm_SnapCrcErrors = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_SnapCrcErrors)\n\t\t\t\t\t\t\tm_SnapCrcErrors--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// purge old snapshots\n\t\t\t\t\tPurgeTick = DeltaTick;\n\t\t\t\t\tif(m_aSnapshots[SNAP_PREV] && m_aSnapshots[SNAP_PREV]->m_Tick < PurgeTick)\n\t\t\t\t\t\tPurgeTick = m_aSnapshots[SNAP_PREV]->m_Tick;\n\t\t\t\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_CURRENT]->m_Tick < PurgeTick)\n\t\t\t\t\t\tPurgeTick = m_aSnapshots[SNAP_CURRENT]->m_Tick;\n\t\t\t\t\tm_SnapshotStorage.PurgeUntil(PurgeTick);\n\n\t\t\t\t\t// add new\n\t\t\t\t\tm_SnapshotStorage.Add(GameTick, time_get(), SnapSize, pTmpBuffer3, 1);\n\n\t\t\t\t\t// add snapshot to demo\n\t\t\t\t\tif(m_DemoRecorder.IsRecording())\n\t\t\t\t\t{\n\t\t\t\t\t\t// write snapshot\n\t\t\t\t\t\tm_DemoRecorder.RecordSnapshot(GameTick, pTmpBuffer3, SnapSize);\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply snapshot, cycle pointers\n\t\t\t\t\tm_RecivedSnapshots++;\n\n\t\t\t\t\tm_CurrentRecvTick = GameTick;\n\n\t\t\t\t\t// we got two snapshots until we see us self as connected\n\t\t\t\t\tif(m_RecivedSnapshots == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t// start at 200ms and work from there\n\t\t\t\t\t\tm_PredictedTime.Init(GameTick*time_freq()/50);\n\t\t\t\t\t\tm_PredictedTime.SetAdjustSpeed(1, 1000.0f);\n\t\t\t\t\t\tm_GameTime.Init((GameTick-1)*time_freq()/50);\n\t\t\t\t\t\tm_aSnapshots[SNAP_PREV] = m_SnapshotStorage.m_pFirst;\n\t\t\t\t\t\tm_aSnapshots[SNAP_CURRENT] = m_SnapshotStorage.m_pLast;\n\t\t\t\t\t\tm_LocalStartTime = time_get();\n\t\t\t\t\t\tSetState(IClient::STATE_ONLINE);\n\t\t\t\t\t\tDemoRecorder_HandleAutoStart();\n\t\t\t\t\t}\n\n\t\t\t\t\t// adjust game time\n\t\t\t\t\tif(m_RecivedSnapshots > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 Now = m_GameTime.Get(time_get());\n\t\t\t\t\t\tint64 TickStart = GameTick*time_freq()/50;\n\t\t\t\t\t\tint64 TimeLeft = (TickStart-Now)*1000 / time_freq();\n\t\t\t\t\t\tm_GameTime.Update(&m_GametimeMarginGraph, (GameTick-1)*time_freq()/50, TimeLeft, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\t// ack snapshot\n\t\t\t\t\tm_AckGameTick = GameTick;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0)\n\t\t{\n\t\t\t// game message\n\t\t\tif(m_DemoRecorder.IsRecording())\n\t\t\t\tm_DemoRecorder.RecordMessage(pPacket->m_pData, pPacket->m_DataSize);\n\n\t\t\tGameClient()->OnMessage(Msg, &Unpacker);\n\t\t}\n\t}\n}\n\nvoid CClient::PumpNetwork()\n{\n\tm_NetClient.Update();\n\n\tif(State() != IClient::STATE_DEMOPLAYBACK)\n\t{\n\t\t// check for errors\n\t\tif(State() != IClient::STATE_OFFLINE && State() != IClient::STATE_QUITING && m_NetClient.State() == NETSTATE_OFFLINE)\n\t\t{\n\t\t\tSetState(IClient::STATE_OFFLINE);\n\t\t\tDisconnect();\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"offline error='%s'\", m_NetClient.ErrorString());\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\t\t}\n\n\t\t//\n\t\tif(State() == IClient::STATE_CONNECTING && m_NetClient.State() == NETSTATE_ONLINE)\n\t\t{\n\t\t\t// we switched to online\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", \"connected, sending info\");\n\t\t\tSetState(IClient::STATE_LOADING);\n\t\t\tSendInfo();\n\t\t}\n\t}\n\n\t// process non-connless packets\n\tCNetChunk Packet;\n\twhile(m_NetClient.Recv(&Packet))\n\t{\n\t\tif(Packet.m_ClientID != -1)\n\t\t\tProcessServerPacket(&Packet);\n\t}\n\n\t// process connless packets data\n\tm_ContactClient.Update();\n\twhile(m_ContactClient.Recv(&Packet))\n\t{\n\t\tif(Packet.m_ClientID == -1)\n\t\t\tProcessConnlessPacket(&Packet);\n\t}\n}\n\nvoid CClient::OnDemoPlayerSnapshot(void *pData, int Size)\n{\n\t// update ticks, they could have changed\n\tconst CDemoPlayer::CPlaybackInfo *pInfo = m_DemoPlayer.Info();\n\tCSnapshotStorage::CHolder *pTemp;\n\tm_CurGameTick = pInfo->m_Info.m_CurrentTick;\n\tm_PrevGameTick = pInfo->m_PreviousTick;\n\n\t// handle snapshots\n\tpTemp = m_aSnapshots[SNAP_PREV];\n\tm_aSnapshots[SNAP_PREV] = m_aSnapshots[SNAP_CURRENT];\n\tm_aSnapshots[SNAP_CURRENT] = pTemp;\n\n\tmem_copy(m_aSnapshots[SNAP_CURRENT]->m_pSnap, pData, Size);\n\tmem_copy(m_aSnapshots[SNAP_CURRENT]->m_pAltSnap, pData, Size);\n\n\tGameClient()->OnNewSnapshot();\n}\n\nvoid CClient::OnDemoPlayerMessage(void *pData, int Size)\n{\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pData, Size);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(!Sys)\n\t\tGameClient()->OnMessage(Msg, &Unpacker);\n}\n/*\nconst IDemoPlayer::CInfo *client_demoplayer_getinfo()\n{\n\tstatic DEMOPLAYBACK_INFO ret;\n\tconst DEMOREC_PLAYBACKINFO *info = m_DemoPlayer.Info();\n\tret.first_tick = info->first_tick;\n\tret.last_tick = info->last_tick;\n\tret.current_tick = info->current_tick;\n\tret.paused = info->paused;\n\tret.speed = info->speed;\n\treturn &ret;\n}*/\n\n/*\nvoid DemoPlayer()->SetPos(float percent)\n{\n\tdemorec_playback_set(percent);\n}\n\nvoid DemoPlayer()->SetSpeed(float speed)\n{\n\tdemorec_playback_setspeed(speed);\n}\n\nvoid DemoPlayer()->SetPause(int paused)\n{\n\tif(paused)\n\t\tdemorec_playback_pause();\n\telse\n\t\tdemorec_playback_unpause();\n}*/\n\nvoid CClient::Update()\n{\n\tif(State() == IClient::STATE_DEMOPLAYBACK)\n\t{\n\t\tm_DemoPlayer.Update();\n\t\tif(m_DemoPlayer.IsPlaying())\n\t\t{\n\t\t\t// update timers\n\t\t\tconst CDemoPlayer::CPlaybackInfo *pInfo = m_DemoPlayer.Info();\n\t\t\tm_CurGameTick = pInfo->m_Info.m_CurrentTick;\n\t\t\tm_PrevGameTick = pInfo->m_PreviousTick;\n\t\t\tm_GameIntraTick = pInfo->m_IntraTick;\n\t\t\tm_GameTickTime = pInfo->m_TickTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// disconnect on error\n\t\t\tDisconnect();\n\t\t}\n\t}\n\telse if(State() == IClient::STATE_ONLINE && m_RecivedSnapshots >= 3)\n\t{\n\t\t// switch snapshot\n\t\tint Repredict = 0;\n\t\tint64 Freq = time_freq();\n\t\tint64 Now = m_GameTime.Get(time_get());\n\t\tint64 PredNow = m_PredictedTime.Get(time_get());\n\n\t\twhile(1)\n\t\t{\n\t\t\tCSnapshotStorage::CHolder *pCur = m_aSnapshots[SNAP_CURRENT];\n\t\t\tint64 TickStart = (pCur->m_Tick)*time_freq()/50;\n\n\t\t\tif(TickStart < Now)\n\t\t\t{\n\t\t\t\tCSnapshotStorage::CHolder *pNext = m_aSnapshots[SNAP_CURRENT]->m_pNext;\n\t\t\t\tif(pNext)\n\t\t\t\t{\n\t\t\t\t\tm_aSnapshots[SNAP_PREV] = m_aSnapshots[SNAP_CURRENT];\n\t\t\t\t\tm_aSnapshots[SNAP_CURRENT] = pNext;\n\n\t\t\t\t\t// set ticks\n\t\t\t\t\tm_CurGameTick = m_aSnapshots[SNAP_CURRENT]->m_Tick;\n\t\t\t\t\tm_PrevGameTick = m_aSnapshots[SNAP_PREV]->m_Tick;\n\n\t\t\t\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_PREV])\n\t\t\t\t\t{\n\t\t\t\t\t\tGameClient()->OnNewSnapshot();\n\t\t\t\t\t\tRepredict = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_PREV])\n\t\t{\n\t\t\tint64 CurtickStart = (m_aSnapshots[SNAP_CURRENT]->m_Tick)*time_freq()/50;\n\t\t\tint64 PrevtickStart = (m_aSnapshots[SNAP_PREV]->m_Tick)*time_freq()/50;\n\t\t\tint PrevPredTick = (int)(PredNow*50/time_freq());\n\t\t\tint NewPredTick = PrevPredTick+1;\n\n\t\t\tm_GameIntraTick = (Now - PrevtickStart) / (float)(CurtickStart-PrevtickStart);\n\t\t\tm_GameTickTime = (Now - PrevtickStart) / (float)Freq; //(float)SERVER_TICK_SPEED);\n\n\t\t\tCurtickStart = NewPredTick*time_freq()/50;\n\t\t\tPrevtickStart = PrevPredTick*time_freq()/50;\n\t\t\tm_PredIntraTick = (PredNow - PrevtickStart) / (float)(CurtickStart-PrevtickStart);\n\n\t\t\tif(NewPredTick < m_aSnapshots[SNAP_PREV]->m_Tick-SERVER_TICK_SPEED || NewPredTick > m_aSnapshots[SNAP_PREV]->m_Tick+SERVER_TICK_SPEED)\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", \"prediction time reset!\");\n\t\t\t\tm_PredictedTime.Init(m_aSnapshots[SNAP_CURRENT]->m_Tick*time_freq()/50);\n\t\t\t}\n\n\t\t\tif(NewPredTick > m_PredTick)\n\t\t\t{\n\t\t\t\tm_PredTick = NewPredTick;\n\t\t\t\tRepredict = 1;\n\n\t\t\t\t// send input\n\t\t\t\tSendInput();\n\t\t\t}\n\t\t}\n\n\t\t// only do sane predictions\n\t\tif(Repredict)\n\t\t{\n\t\t\tif(m_PredTick > m_CurGameTick && m_PredTick < m_CurGameTick+50)\n\t\t\t\tGameClient()->OnPredict();\n\t\t}\n\n\t\t// fetch server info if we don't have it\n\t\tif(State() >= IClient::STATE_LOADING &&\n\t\t\tm_CurrentServerInfoRequestTime >= 0 &&\n\t\t\ttime_get() > m_CurrentServerInfoRequestTime)\n\t\t{\n\t\t\tm_ServerBrowser.Request(m_ServerAddress);\n\t\t\tm_CurrentServerInfoRequestTime = time_get()+time_freq()*2;\n\t\t}\n\t}\n\n\t// STRESS TEST: join the server again\n\tif(g_Config.m_DbgStress)\n\t{\n\t\tstatic int64 ActionTaken = 0;\n\t\tint64 Now = time_get();\n\t\tif(State() == IClient::STATE_OFFLINE)\n\t\t{\n\t\t\tif(Now > ActionTaken+time_freq()*2)\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"stress\", \"reconnecting!\");\n\t\t\t\tConnect(g_Config.m_DbgStressServer);\n\t\t\t\tActionTaken = Now;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Now > ActionTaken+time_freq()*(10+g_Config.m_DbgStress))\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"stress\", \"disconnecting!\");\n\t\t\t\tDisconnect();\n\t\t\t\tActionTaken = Now;\n\t\t\t}\n\t\t}\n\t}\n\n\t// pump the network\n\tPumpNetwork();\n\n\t// update the maser server registry\n\tMasterServer()->Update();\n\n\t// update the server browser\n\tm_ServerBrowser.Update(m_ResortServerBrowser);\n\tm_ResortServerBrowser = false;\n}\n\nvoid CClient::VersionUpdate()\n{\n\tif(m_VersionInfo.m_State == CVersionInfo::STATE_INIT)\n\t{\n\t\tEngine()->HostLookup(&m_VersionInfo.m_VersionServeraddr, g_Config.m_ClVersionServer, m_ContactClient.NetType());\n\t\tm_VersionInfo.m_State = CVersionInfo::STATE_START;\n\t}\n\telse if(m_VersionInfo.m_State == CVersionInfo::STATE_START)\n\t{\n\t\tif(m_VersionInfo.m_VersionServeraddr.m_Job.Status() == CJob::STATE_DONE)\n\t\t{\n\t\t\tCNetChunk Packet;\n\n\t\t\tmem_zero(&Packet, sizeof(Packet));\n\n\t\t\tm_VersionInfo.m_VersionServeraddr.m_Addr.port = VERSIONSRV_PORT;\n\n\t\t\tPacket.m_ClientID = -1;\n\t\t\tPacket.m_Address = m_VersionInfo.m_VersionServeraddr.m_Addr;\n\t\t\tPacket.m_pData = VERSIONSRV_GETVERSION;\n\t\t\tPacket.m_DataSize = sizeof(VERSIONSRV_GETVERSION);\n\t\t\tPacket.m_Flags = NETSENDFLAG_CONNLESS;\n\n\t\t\tm_ContactClient.Send(&Packet);\n\t\t\tm_VersionInfo.m_State = CVersionInfo::STATE_READY;\n\t\t}\n\t}\n}\n\nvoid CClient::RegisterInterfaces()\n{\n\tKernel()->RegisterInterface(static_cast<IDemoRecorder*>(&m_DemoRecorder));\n\tKernel()->RegisterInterface(static_cast<IDemoPlayer*>(&m_DemoPlayer));\n\tKernel()->RegisterInterface(static_cast<IServerBrowser*>(&m_ServerBrowser));\n\tKernel()->RegisterInterface(static_cast<IFriends*>(&m_Friends));\n}\n\nvoid CClient::InitInterfaces()\n{\n\t// fetch interfaces\n\tm_pEngine = Kernel()->RequestInterface<IEngine>();\n\tm_pEditor = Kernel()->RequestInterface<IEditor>();\n\t//m_pGraphics = Kernel()->RequestInterface<IEngineGraphics>();\n\tm_pSound = Kernel()->RequestInterface<IEngineSound>();\n\tm_pGameClient = Kernel()->RequestInterface<IGameClient>();\n\tm_pInput = Kernel()->RequestInterface<IEngineInput>();\n\tm_pMap = Kernel()->RequestInterface<IEngineMap>();\n\tm_pMasterServer = Kernel()->RequestInterface<IEngineMasterServer>();\n\tm_pStorage = Kernel()->RequestInterface<IStorage>();\n\n\t//\n\tm_ServerBrowser.SetBaseInfo(&m_ContactClient, m_pGameClient->NetVersion());\n\tm_Friends.Init();\n}\n\nvoid CClient::Run()\n{\n\tm_LocalStartTime = time_get();\n\tm_SnapshotParts = 0;\n\n\t// init SDL\n\t{\n\t\tif(SDL_Init(0) < 0)\n\t\t{\n\t\t\tdbg_msg(\"client\", \"unable to init SDL base: %s\", SDL_GetError());\n\t\t\treturn;\n\t\t}\n\n\t\tatexit(SDL_Quit); // ignore_convention\n\t}\n\n\t// init graphics\n\t{\n\t\tif(g_Config.m_GfxThreaded)\n\t\t\tm_pGraphics = CreateEngineGraphicsThreaded();\n\t\telse\n\t\t\tm_pGraphics = CreateEngineGraphics();\n\n\t\tbool RegisterFail = false;\n\t\tRegisterFail = RegisterFail || !Kernel()->RegisterInterface(static_cast<IEngineGraphics*>(m_pGraphics)); // register graphics as both\n\t\tRegisterFail = RegisterFail || !Kernel()->RegisterInterface(static_cast<IGraphics*>(m_pGraphics));\n\n\t\tif(RegisterFail || m_pGraphics->Init() != 0)\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't init graphics\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// init sound, allowed to fail\n\tm_SoundInitFailed = Sound()->Init() != 0;\n\n\t// open socket\n\t{\n\t\tNETADDR BindAddr;\n\t\tif(g_Config.m_Bindaddr[0] && net_host_lookup(g_Config.m_Bindaddr, &BindAddr, NETTYPE_ALL) == 0)\n\t\t{\n\t\t\t// got bindaddr\n\t\t\tBindAddr.type = NETTYPE_ALL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmem_zero(&BindAddr, sizeof(BindAddr));\n\t\t\tBindAddr.type = NETTYPE_ALL;\n\t\t}\n\t\tif(!m_NetClient.Open(BindAddr, BindAddr.port ? 0 : NETCREATE_FLAG_RANDOMPORT))\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't open socket(net)\");\n\t\t\treturn;\n\t\t}\n\t\tBindAddr.port = 0;\n\t\tif(!m_ContactClient.Open(BindAddr, 0))\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't open socket(contact)\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// init font rendering\n\tKernel()->RequestInterface<IEngineTextRender>()->Init();\n\n\t// init the input\n\tInput()->Init();\n\n\t// start refreshing addresses while we load\n\tMasterServer()->RefreshAddresses(m_ContactClient.NetType());\n\n\t// init the editor\n\tm_pEditor->Init();\n\n\n\t// load data\n\tif(!LoadData())\n\t\treturn;\n\n\tGameClient()->OnInit();\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"version %s\", GameClient()->NetVersion());\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\t// connect to the server if wanted\n\t/*\n\tif(config.cl_connect[0] != 0)\n\t\tConnect(config.cl_connect);\n\tconfig.cl_connect[0] = 0;\n\t*/\n\n\t//\n\tm_FpsGraph.Init(0.0f, 200.0f);\n\n\t// never start with the editor\n\tg_Config.m_ClEditor = 0;\n\n\tInput()->MouseModeRelative();\n\n\t// process pending commands\n\tm_pConsole->StoreCommands(false);\n\n\twhile (1)\n\t{\n\t\t//\n\t\tVersionUpdate();\n\n\t\t// handle pending connects\n\t\tif(m_aCmdConnect[0])\n\t\t{\n\t\t\tstr_copy(g_Config.m_UiServerAddress, m_aCmdConnect, sizeof(g_Config.m_UiServerAddress));\n\t\t\tConnect(m_aCmdConnect);\n\t\t\tm_aCmdConnect[0] = 0;\n\t\t}\n\n\t\t// update input\n\t\tif(Input()->Update())\n\t\t\tbreak;\t// SDL_QUIT\n\n\t\t// update sound\n\t\tSound()->Update();\n\n\t\t// release focus\n\t\tif(!m_pGraphics->WindowActive())\n\t\t{\n\t\t\tif(m_WindowMustRefocus == 0)\n\t\t\t\tInput()->MouseModeAbsolute();\n\t\t\tm_WindowMustRefocus = 1;\n\t\t}\n\t\telse if (g_Config.m_DbgFocus && Input()->KeyPressed(KEY_ESCAPE))\n\t\t{\n\t\t\tInput()->MouseModeAbsolute();\n\t\t\tm_WindowMustRefocus = 1;\n\t\t}\n\n\t\t// refocus\n\t\tif(m_WindowMustRefocus && m_pGraphics->WindowActive())\n\t\t{\n\t\t\tif(m_WindowMustRefocus < 3)\n\t\t\t{\n\t\t\t\tInput()->MouseModeAbsolute();\n\t\t\t\tm_WindowMustRefocus++;\n\t\t\t}\n\n\t\t\tif(m_WindowMustRefocus >= 3 || Input()->KeyPressed(KEY_MOUSE_1))\n\t\t\t{\n\t\t\t\tInput()->MouseModeRelative();\n\t\t\t\tm_WindowMustRefocus = 0;\n\t\t\t}\n\t\t}\n\n\t\t// panic quit button\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyPressed('q'))\n\t\t{\n\t\t\tQuit();\n\t\t\tbreak;\n\t\t}\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('d'))\n\t\t\tg_Config.m_Debug ^= 1;\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('g'))\n\t\t\tg_Config.m_DbgGraphs ^= 1;\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('e'))\n\t\t{\n\t\t\tg_Config.m_ClEditor = g_Config.m_ClEditor^1;\n\t\t\tInput()->MouseModeRelative();\n\t\t}\n\n\t\t/*\n\t\tif(!gfx_window_open())\n\t\t\tbreak;\n\t\t*/\n\n\t\t// render\n\t\t{\n\t\t\tif(g_Config.m_ClEditor)\n\t\t\t{\n\t\t\t\tif(!m_EditorActive)\n\t\t\t\t{\n\t\t\t\t\tGameClient()->OnActivateEditor();\n\t\t\t\t\tm_EditorActive = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(m_EditorActive)\n\t\t\t\tm_EditorActive = false;\n\n\t\t\tUpdate();\n\n\t\t\tif(!g_Config.m_GfxAsyncRender || m_pGraphics->IsIdle())\n\t\t\t{\n\t\t\t\tm_RenderFrames++;\n\n\t\t\t\t// update frametime\n\t\t\t\tint64 Now = time_get();\n\t\t\t\tm_RenderFrameTime = (Now - m_LastRenderTime) / (float)time_freq();\n\t\t\t\tif(m_RenderFrameTime < m_RenderFrameTimeLow)\n\t\t\t\t\tm_RenderFrameTimeLow = m_RenderFrameTime;\n\t\t\t\tif(m_RenderFrameTime > m_RenderFrameTimeHigh)\n\t\t\t\t\tm_RenderFrameTimeHigh = m_RenderFrameTime;\n\t\t\t\tm_FpsGraph.Add(1.0f/m_RenderFrameTime, 1,1,1);\n\n\t\t\t\tm_LastRenderTime = Now;\n\n\t\t\t\tif(g_Config.m_DbgStress)\n\t\t\t\t{\n\t\t\t\t\tif((m_RenderFrames%10) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!m_EditorActive)\n\t\t\t\t\t\t\tRender();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_pEditor->UpdateAndRender();\n\t\t\t\t\t\t\tDebugRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm_pGraphics->Swap();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(!m_EditorActive)\n\t\t\t\t\t\tRender();\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pEditor->UpdateAndRender();\n\t\t\t\t\t\tDebugRender();\n\t\t\t\t\t}\n\t\t\t\t\tm_pGraphics->Swap();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAutoScreenshot_Cleanup();\n\n\t\t// check conditions\n\t\tif(State() == IClient::STATE_QUITING)\n\t\t\tbreak;\n\n\t\t// beNice\n\t\tif(g_Config.m_ClCpuThrottle)\n\t\t\tthread_sleep(g_Config.m_ClCpuThrottle);\n\t\telse if(g_Config.m_DbgStress || !m_pGraphics->WindowActive())\n\t\t\tthread_sleep(5);\n\n\t\tif(g_Config.m_DbgHitch)\n\t\t{\n\t\t\tthread_sleep(g_Config.m_DbgHitch);\n\t\t\tg_Config.m_DbgHitch = 0;\n\t\t}\n\n\t\t/*\n\t\tif(ReportTime < time_get())\n\t\t{\n\t\t\tif(0 && g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tdbg_msg(\"client/report\", \"fps=%.02f (%.02f %.02f) netstate=%d\",\n\t\t\t\t\tm_Frames/(float)(ReportInterval/time_freq()),\n\t\t\t\t\t1.0f/m_RenderFrameTimeHigh,\n\t\t\t\t\t1.0f/m_RenderFrameTimeLow,\n\t\t\t\t\tm_NetClient.State());\n\t\t\t}\n\t\t\tm_RenderFrameTimeLow = 1;\n\t\t\tm_RenderFrameTimeHigh = 0;\n\t\t\tm_RenderFrames = 0;\n\t\t\tReportTime += ReportInterval;\n\t\t}*/\n\n\t\t// update local time\n\t\tm_LocalTime = (time_get()-m_LocalStartTime)/(float)time_freq();\n\t}\n\n\tGameClient()->OnShutdown();\n\tDisconnect();\n\n\tm_pGraphics->Shutdown();\n\tm_pSound->Shutdown();\n\n\t// shutdown SDL\n\t{\n\t\tSDL_Quit();\n\t}\n}\n\n\nvoid CClient::Con_Connect(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tstr_copy(pSelf->m_aCmdConnect, pResult->GetString(0), sizeof(pSelf->m_aCmdConnect));\n}\n\nvoid CClient::Con_Disconnect(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Disconnect();\n}\n\nvoid CClient::Con_Quit(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Quit();\n}\n\nvoid CClient::Con_Minimize(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Graphics()->Minimize();\n}\n\nvoid CClient::Con_Ping(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\n\tCMsgPacker Msg(NETMSG_PING);\n\tpSelf->SendMsgEx(&Msg, 0);\n\tpSelf->m_PingStartTime = time_get();\n}\n\nvoid CClient::AutoScreenshot_Start()\n{\n\tif(g_Config.m_ClAutoScreenshot)\n\t{\n\t\tGraphics()->TakeScreenshot(\"auto/autoscreen\");\n\t\tm_AutoScreenshotRecycle = true;\n\t}\n}\n\nvoid CClient::AutoScreenshot_Cleanup()\n{\n\tif(m_AutoScreenshotRecycle)\n\t{\n\t\tif(g_Config.m_ClAutoScreenshotMax)\n\t\t{\n\t\t\t// clean up auto taken screens\n\t\t\tCFileCollection AutoScreens;\n\t\t\tAutoScreens.Init(Storage(), \"screenshots/auto\", \"autoscreen\", \".png\", g_Config.m_ClAutoScreenshotMax);\n\t\t}\n\t\tm_AutoScreenshotRecycle = false;\n\t}\n}\n\nvoid CClient::Con_Screenshot(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Graphics()->TakeScreenshot(0);\n}\n\nvoid CClient::Con_Rcon(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Rcon(pResult->GetString(0));\n}\n\nvoid CClient::Con_RconAuth(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->RconAuth(\"\", pResult->GetString(0));\n}\n\nvoid CClient::Con_AddFavorite(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tNETADDR Addr;\n\tif(net_addr_from_str(&Addr, pResult->GetString(0)) == 0)\n\t\tpSelf->m_ServerBrowser.AddFavorite(Addr);\n}\n\nvoid CClient::Con_RemoveFavorite(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tNETADDR Addr;\n\tif(net_addr_from_str(&Addr, pResult->GetString(0)) == 0)\n\t\tpSelf->m_ServerBrowser.RemoveFavorite(Addr);\n}\n\nconst char *CClient::DemoPlayer_Play(const char *pFilename, int StorageType)\n{\n\tint Crc;\n\tconst char *pError;\n\tDisconnect();\n\tm_NetClient.ResetErrorString();\n\n\t// try to start playback\n\tm_DemoPlayer.SetListner(this);\n\n\tif(m_DemoPlayer.Load(Storage(), m_pConsole, pFilename, StorageType))\n\t\treturn \"error loading demo\";\n\n\t// load map\n\tCrc = (m_DemoPlayer.Info()->m_Header.m_aMapCrc[0]<<24)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[1]<<16)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[2]<<8)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[3]);\n\tpError = LoadMapSearch(m_DemoPlayer.Info()->m_Header.m_aMapName, Crc);\n\tif(pError)\n\t{\n\t\tDisconnectWithReason(pError);\n\t\treturn pError;\n\t}\n\n\tGameClient()->OnConnected();\n\n\t// setup buffers\n\tmem_zero(m_aDemorecSnapshotData, sizeof(m_aDemorecSnapshotData));\n\n\tm_aSnapshots[SNAP_CURRENT] = &m_aDemorecSnapshotHolders[SNAP_CURRENT];\n\tm_aSnapshots[SNAP_PREV] = &m_aDemorecSnapshotHolders[SNAP_PREV];\n\n\tm_aSnapshots[SNAP_CURRENT]->m_pSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_CURRENT][0];\n\tm_aSnapshots[SNAP_CURRENT]->m_pAltSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_CURRENT][1];\n\tm_aSnapshots[SNAP_CURRENT]->m_SnapSize = 0;\n\tm_aSnapshots[SNAP_CURRENT]->m_Tick = -1;\n\n\tm_aSnapshots[SNAP_PREV]->m_pSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_PREV][0];\n\tm_aSnapshots[SNAP_PREV]->m_pAltSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_PREV][1];\n\tm_aSnapshots[SNAP_PREV]->m_SnapSize = 0;\n\tm_aSnapshots[SNAP_PREV]->m_Tick = -1;\n\n\t// enter demo playback state\n\tSetState(IClient::STATE_DEMOPLAYBACK);\n\n\tm_DemoPlayer.Play();\n\tGameClient()->OnEnterGame();\n\n\treturn 0;\n}\n\nvoid CClient::Con_Play(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoPlayer_Play(pResult->GetString(0), IStorage::TYPE_ALL);\n}\n\nvoid CClient::DemoRecorder_Start(const char *pFilename, bool WithTimestamp)\n{\n\tif(State() != IClient::STATE_ONLINE)\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"demorec/record\", \"client is not online\");\n\telse\n\t{\n\t\tchar aFilename[128];\n\t\tif(WithTimestamp)\n\t\t{\n\t\t\tchar aDate[20];\n\t\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s_%s.demo\", pFilename, aDate);\n\t\t}\n\t\telse\n\t\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s.demo\", pFilename);\n\t\tm_DemoRecorder.Start(Storage(), m_pConsole, aFilename, GameClient()->NetVersion(), m_aCurrentMap, m_CurrentMapCrc, \"client\");\n\t}\n}\n\nvoid CClient::DemoRecorder_HandleAutoStart()\n{\n\tif(g_Config.m_ClAutoDemoRecord)\n\t{\n\t\tDemoRecorder_Stop();\n\t\tDemoRecorder_Start(\"auto/autorecord\", true);\n\t\tif(g_Config.m_ClAutoDemoMax)\n\t\t{\n\t\t\t// clean up auto recorded demos\n\t\t\tCFileCollection AutoDemos;\n\t\t\tAutoDemos.Init(Storage(), \"demos/auto\", \"autorecord\", \".demo\", g_Config.m_ClAutoDemoMax);\n\t\t}\n\t}\n}\n\nvoid CClient::DemoRecorder_Stop()\n{\n\tm_DemoRecorder.Stop();\n}\n\nvoid CClient::DemoRecorder_AddDemoMarker()\n{\n\tm_DemoRecorder.AddDemoMarker();\n}\n\nvoid CClient::Con_Record(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tif(pResult->NumArguments())\n\t\tpSelf->DemoRecorder_Start(pResult->GetString(0), false);\n\telse\n\t\tpSelf->DemoRecorder_Start(\"demo\", true);\n}\n\nvoid CClient::Con_StopRecord(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoRecorder_Stop();\n}\n\nvoid CClient::Con_AddDemoMarker(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoRecorder_AddDemoMarker();\n}\n\nvoid CClient::ServerBrowserUpdate()\n{\n\tm_ResortServerBrowser = true;\n}\n\nvoid CClient::ConchainServerBrowserUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments())\n\t\t((CClient *)pUserData)->ServerBrowserUpdate();\n}\n\nvoid CClient::RegisterCommands()\n{\n\tm_pConsole = Kernel()->RequestInterface<IConsole>();\n\t// register server dummy commands for tab completion\n\tm_pConsole->Register(\"kick\", \"i?r\", CFGFLAG_SERVER, 0, 0, \"Kick player with specified id for any reason\");\n\tm_pConsole->Register(\"ban\", \"s?ir\", CFGFLAG_SERVER, 0, 0, \"Ban player with ip/id for x minutes for any reason\");\n\tm_pConsole->Register(\"unban\", \"s\", CFGFLAG_SERVER, 0, 0, \"Unban ip\");\n\tm_pConsole->Register(\"bans\", \"\", CFGFLAG_SERVER, 0, 0, \"Show banlist\");\n\tm_pConsole->Register(\"status\", \"\", CFGFLAG_SERVER, 0, 0, \"List players\");\n\tm_pConsole->Register(\"shutdown\", \"\", CFGFLAG_SERVER, 0, 0, \"Shut down\");\n\tm_pConsole->Register(\"record\", \"?s\", CFGFLAG_SERVER, 0, 0, \"Record to a file\");\n\tm_pConsole->Register(\"stoprecord\", \"\", CFGFLAG_SERVER, 0, 0, \"Stop recording\");\n\tm_pConsole->Register(\"reload\", \"\", CFGFLAG_SERVER, 0, 0, \"Reload the map\");\n\n\tm_pConsole->Register(\"quit\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Quit, this, \"Quit Teeworlds\");\n\tm_pConsole->Register(\"exit\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Quit, this, \"Quit Teeworlds\");\n\tm_pConsole->Register(\"minimize\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Minimize, this, \"Minimize Teeworlds\");\n\tm_pConsole->Register(\"connect\", \"s\", CFGFLAG_CLIENT, Con_Connect, this, \"Connect to the specified host/ip\");\n\tm_pConsole->Register(\"disconnect\", \"\", CFGFLAG_CLIENT, Con_Disconnect, this, \"Disconnect from the server\");\n\tm_pConsole->Register(\"ping\", \"\", CFGFLAG_CLIENT, Con_Ping, this, \"Ping the current server\");\n\tm_pConsole->Register(\"screenshot\", \"\", CFGFLAG_CLIENT, Con_Screenshot, this, \"Take a screenshot\");\n\tm_pConsole->Register(\"rcon\", \"r\", CFGFLAG_CLIENT, Con_Rcon, this, \"Send specified command to rcon\");\n\tm_pConsole->Register(\"rcon_auth\", \"s\", CFGFLAG_CLIENT, Con_RconAuth, this, \"Authenticate to rcon\");\n\tm_pConsole->Register(\"play\", \"r\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Play, this, \"Play the file specified\");\n\tm_pConsole->Register(\"record\", \"?s\", CFGFLAG_CLIENT, Con_Record, this, \"Record to the file\");\n\tm_pConsole->Register(\"stoprecord\", \"\", CFGFLAG_CLIENT, Con_StopRecord, this, \"Stop recording\");\n\tm_pConsole->Register(\"add_demomarker\", \"\", CFGFLAG_CLIENT, Con_AddDemoMarker, this, \"Add demo timeline marker\");\n\tm_pConsole->Register(\"add_favorite\", \"s\", CFGFLAG_CLIENT, Con_AddFavorite, this, \"Add a server as a favorite\");\n\tm_pConsole->Register(\"remove_favorite\", \"s\", CFGFLAG_CLIENT, Con_RemoveFavorite, this, \"Remove a server from favorites\");\n\n\t// used for server browser update\n\tm_pConsole->Chain(\"br_filter_string\", ConchainServerBrowserUpdate, this);\n\tm_pConsole->Chain(\"br_filter_gametype\", ConchainServerBrowserUpdate, this);\n\tm_pConsole->Chain(\"br_filter_serveraddress\", ConchainServerBrowserUpdate, this);\n}\n\nstatic CClient *CreateClient()\n{\n\tCClient *pClient = static_cast<CClient *>(mem_alloc(sizeof(CClient), 1));\n\tmem_zero(pClient, sizeof(CClient));\n\treturn new(pClient) CClient;\n}\n\n/*\n\tServer Time\n\tClient Mirror Time\n\tClient Predicted Time\n\n\tSnapshot Latency\n\t\tDownstream latency\n\n\tPrediction Latency\n\t\tUpstream latency\n*/\n\n#if defined(CONF_PLATFORM_MACOSX)\nextern \"C\" int SDL_main(int argc, char **argv_) // ignore_convention\n{\n\tconst char **argv = const_cast<const char **>(argv_);\n#else\nint main(int argc, const char **argv) // ignore_convention\n{\n#endif\n#if defined(CONF_FAMILY_WINDOWS)\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-s\", argv[i]) == 0 || str_comp(\"--silent\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tFreeConsole();\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\n\tCClient *pClient = CreateClient();\n\tIKernel *pKernel = IKernel::Create();\n\tpKernel->RegisterInterface(pClient);\n\tpClient->RegisterInterfaces();\n\n\t// create the components\n\tIEngine *pEngine = CreateEngine(\"Teeworlds\");\n\tIConsole *pConsole = CreateConsole(CFGFLAG_CLIENT);\n\tIStorage *pStorage = CreateStorage(\"Teeworlds\", IStorage::STORAGETYPE_CLIENT, argc, argv); // ignore_convention\n\tIConfig *pConfig = CreateConfig();\n\tIEngineSound *pEngineSound = CreateEngineSound();\n\tIEngineInput *pEngineInput = CreateEngineInput();\n\tIEngineTextRender *pEngineTextRender = CreateEngineTextRender();\n\tIEngineMap *pEngineMap = CreateEngineMap();\n\tIEngineMasterServer *pEngineMasterServer = CreateEngineMasterServer();\n\n\t{\n\t\tbool RegisterFail = false;\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pEngine);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConsole);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConfig);\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineSound*>(pEngineSound)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<ISound*>(pEngineSound));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineInput*>(pEngineInput)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IInput*>(pEngineInput));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineTextRender*>(pEngineTextRender)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<ITextRender*>(pEngineTextRender));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMap*>(pEngineMap)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMap*>(pEngineMap));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMasterServer*>(pEngineMasterServer)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMasterServer*>(pEngineMasterServer));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(CreateEditor());\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(CreateGameClient());\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pStorage);\n\n\t\tif(RegisterFail)\n\t\t\treturn -1;\n\t}\n\n\tpEngine->Init();\n\tpConfig->Init();\n\tpEngineMasterServer->Init();\n\tpEngineMasterServer->Load();\n\n\t// register all console commands\n\tpClient->RegisterCommands();\n\n\tpKernel->RequestInterface<IGameClient>()->OnConsoleInit();\n\n\t// init client's interfaces\n\tpClient->InitInterfaces();\n\n\t// execute config file\n\tpConsole->ExecuteFile(\"settings.cfg\");\n\n\t// execute autoexec file\n\tpConsole->ExecuteFile(\"autoexec.cfg\");\n\n\t// parse the command line arguments\n\tif(argc > 1) // ignore_convention\n\t\tpConsole->ParseArguments(argc-1, &argv[1]); // ignore_convention\n\n\t// restore empty config strings to their defaults\n\tpConfig->RestoreStrings();\n\n\tpClient->Engine()->InitLogfile();\n\n\t// run the client\n\tdbg_msg(\"client\", \"starting...\");\n\tpClient->Run();\n\n\t// write down the config and quit\n\tpConfig->Save();\n\n\treturn 0;\n}\n", "/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n#ifndef ENGINE_SHARED_SNAPSHOT_H\n#define ENGINE_SHARED_SNAPSHOT_H\n\n#include <base/system.h>\n\n// CSnapshot\n\nclass CSnapshotItem\n{\npublic:\n\tint m_TypeAndID;\n\n\tint *Data() { return (int *)(this+1); }\n\tint Type() { return m_TypeAndID>>16; }\n\tint ID() { return m_TypeAndID&0xffff; }\n\tint Key() { return m_TypeAndID; }\n};\n\n\nclass CSnapshot\n{\n\tfriend class CSnapshotBuilder;\n\tint m_DataSize;\n\tint m_NumItems;\n\n\tint *Offsets() const { return (int *)(this+1); }\n\tchar *DataStart() const { return (char*)(Offsets()+m_NumItems); }\n\npublic:\n\tenum\n\t{\n\t\tMAX_SIZE=64*1024\n\t};\n\n\tvoid Clear() { m_DataSize = 0; m_NumItems = 0; }\n\tint NumItems() const { return m_NumItems; }\n\tCSnapshotItem *GetItem(int Index);\n\tint GetItemSize(int Index);\n\tint GetItemIndex(int Key);\n\n\tint Crc();\n\tvoid DebugDump();\n};\n\n\n// CSnapshotDelta\n\nclass CSnapshotDelta\n{\npublic:\n\tclass CData\n\t{\n\tpublic:\n\t\tint m_NumDeletedItems;\n\t\tint m_NumUpdateItems;\n\t\tint m_NumTempItems; // needed?\n\t\tint m_pData[1];\n\t};\n\nprivate:\n\t// TODO: strange arbitrary number\n\tshort m_aItemSizes[64];\n\tint m_aSnapshotDataRate[0xffff];\n\tint m_aSnapshotDataUpdates[0xffff];\n\tint m_SnapshotCurrent;\n\tCData m_Empty;\n\n\tvoid UndiffItem(int *pPast, int *pDiff, int *pOut, int Size);\n\npublic:\n\tCSnapshotDelta();\n\tint GetDataRate(int Index) { return m_aSnapshotDataRate[Index]; }\n\tint GetDataUpdates(int Index) { return m_aSnapshotDataUpdates[Index]; }\n\tvoid SetStaticsize(int ItemType, int Size);\n\tCData *EmptyDelta();\n\tint CreateDelta(class CSnapshot *pFrom, class CSnapshot *pTo, void *pData);\n\tint UnpackDelta(class CSnapshot *pFrom, class CSnapshot *pTo, void *pData, int DataSize);\n};\n\n\n// CSnapshotStorage\n\nclass CSnapshotStorage\n{\npublic:\n\tclass CHolder\n\t{\n\tpublic:\n\t\tCHolder *m_pPrev;\n\t\tCHolder *m_pNext;\n\n\t\tint64 m_Tagtime;\n\t\tint m_Tick;\n\n\t\tint m_SnapSize;\n\t\tCSnapshot *m_pSnap;\n\t\tCSnapshot *m_pAltSnap;\n\t};\n\n\n\tCHolder *m_pFirst;\n\tCHolder *m_pLast;\n\n\tvoid Init();\n\tvoid PurgeAll();\n\tvoid PurgeUntil(int Tick);\n\tvoid Add(int Tick, int64 Tagtime, int DataSize, void *pData, int CreateAlt);\n\tint Get(int Tick, int64 *pTagtime, CSnapshot **ppData, CSnapshot **ppAltData);\n};\n\nclass CSnapshotBuilder\n{\n\tenum\n\t{\n\t\tMAX_ITEMS = 1024\n\t};\n\n\tchar m_aData[CSnapshot::MAX_SIZE];\n\tint m_DataSize;\n\n\tint m_aOffsets[MAX_ITEMS];\n\tint m_NumItems;\n\npublic:\n\tvoid Init();\n\n\tvoid *NewItem(int Type, int ID, int Size);\n\n\tCSnapshotItem *GetItem(int Index);\n\tint *GetItemData(int Key);\n\n\tint Finish(void *pSnapdata);\n};\n\n\n#endif // ENGINE_SNAPSHOT_H\n"], "fixing_code": ["/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n#include <new>\n\n#include <stdlib.h> // qsort\n#include <stdarg.h>\n\n#include <base/math.h>\n#include <base/system.h>\n\n#include <engine/client.h>\n#include <engine/config.h>\n#include <engine/console.h>\n#include <engine/editor.h>\n#include <engine/engine.h>\n#include <engine/graphics.h>\n#include <engine/input.h>\n#include <engine/keys.h>\n#include <engine/map.h>\n#include <engine/masterserver.h>\n#include <engine/serverbrowser.h>\n#include <engine/sound.h>\n#include <engine/storage.h>\n#include <engine/textrender.h>\n\n#include <engine/shared/config.h>\n#include <engine/shared/compression.h>\n#include <engine/shared/datafile.h>\n#include <engine/shared/demo.h>\n#include <engine/shared/filecollection.h>\n#include <engine/shared/mapchecker.h>\n#include <engine/shared/network.h>\n#include <engine/shared/packer.h>\n#include <engine/shared/protocol.h>\n#include <engine/shared/ringbuffer.h>\n#include <engine/shared/snapshot.h>\n\n#include <game/version.h>\n\n#include <mastersrv/mastersrv.h>\n#include <versionsrv/versionsrv.h>\n\n#include \"friends.h\"\n#include \"serverbrowser.h\"\n#include \"client.h\"\n\n#if defined(CONF_FAMILY_WINDOWS)\n\t#define _WIN32_WINNT 0x0501\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n#endif\n\n#include \"SDL.h\"\n#ifdef main\n#undef main\n#endif\n\nvoid CGraph::Init(float Min, float Max)\n{\n\tm_Min = Min;\n\tm_Max = Max;\n\tm_Index = 0;\n}\n\nvoid CGraph::ScaleMax()\n{\n\tint i = 0;\n\tm_Max = 0;\n\tfor(i = 0; i < MAX_VALUES; i++)\n\t{\n\t\tif(m_aValues[i] > m_Max)\n\t\t\tm_Max = m_aValues[i];\n\t}\n}\n\nvoid CGraph::ScaleMin()\n{\n\tint i = 0;\n\tm_Min = m_Max;\n\tfor(i = 0; i < MAX_VALUES; i++)\n\t{\n\t\tif(m_aValues[i] < m_Min)\n\t\t\tm_Min = m_aValues[i];\n\t}\n}\n\nvoid CGraph::Add(float v, float r, float g, float b)\n{\n\tm_Index = (m_Index+1)&(MAX_VALUES-1);\n\tm_aValues[m_Index] = v;\n\tm_aColors[m_Index][0] = r;\n\tm_aColors[m_Index][1] = g;\n\tm_aColors[m_Index][2] = b;\n}\n\nvoid CGraph::Render(IGraphics *pGraphics, int Font, float x, float y, float w, float h, const char *pDescription)\n{\n\t//m_pGraphics->BlendNormal();\n\n\n\tpGraphics->TextureSet(-1);\n\n\tpGraphics->QuadsBegin();\n\tpGraphics->SetColor(0, 0, 0, 0.75f);\n\tIGraphics::CQuadItem QuadItem(x, y, w, h);\n\tpGraphics->QuadsDrawTL(&QuadItem, 1);\n\tpGraphics->QuadsEnd();\n\n\tpGraphics->LinesBegin();\n\tpGraphics->SetColor(0.95f, 0.95f, 0.95f, 1.00f);\n\tIGraphics::CLineItem LineItem(x, y+h/2, x+w, y+h/2);\n\tpGraphics->LinesDraw(&LineItem, 1);\n\tpGraphics->SetColor(0.5f, 0.5f, 0.5f, 0.75f);\n\tIGraphics::CLineItem Array[2] = {\n\t\tIGraphics::CLineItem(x, y+(h*3)/4, x+w, y+(h*3)/4),\n\t\tIGraphics::CLineItem(x, y+h/4, x+w, y+h/4)};\n\tpGraphics->LinesDraw(Array, 2);\n\tfor(int i = 1; i < MAX_VALUES; i++)\n\t{\n\t\tfloat a0 = (i-1)/(float)MAX_VALUES;\n\t\tfloat a1 = i/(float)MAX_VALUES;\n\t\tint i0 = (m_Index+i-1)&(MAX_VALUES-1);\n\t\tint i1 = (m_Index+i)&(MAX_VALUES-1);\n\n\t\tfloat v0 = (m_aValues[i0]-m_Min) / (m_Max-m_Min);\n\t\tfloat v1 = (m_aValues[i1]-m_Min) / (m_Max-m_Min);\n\n\t\tIGraphics::CColorVertex Array[2] = {\n\t\t\tIGraphics::CColorVertex(0, m_aColors[i0][0], m_aColors[i0][1], m_aColors[i0][2], 0.75f),\n\t\t\tIGraphics::CColorVertex(1, m_aColors[i1][0], m_aColors[i1][1], m_aColors[i1][2], 0.75f)};\n\t\tpGraphics->SetColorVertex(Array, 2);\n\t\tIGraphics::CLineItem LineItem(x+a0*w, y+h-v0*h, x+a1*w, y+h-v1*h);\n\t\tpGraphics->LinesDraw(&LineItem, 1);\n\n\t}\n\tpGraphics->LinesEnd();\n\n\tpGraphics->TextureSet(Font);\n\tpGraphics->QuadsBegin();\n\tpGraphics->QuadsText(x+2, y+h-16, 16, pDescription);\n\n\tchar aBuf[32];\n\tstr_format(aBuf, sizeof(aBuf), \"%.2f\", m_Max);\n\tpGraphics->QuadsText(x+w-8*str_length(aBuf)-8, y+2, 16, aBuf);\n\n\tstr_format(aBuf, sizeof(aBuf), \"%.2f\", m_Min);\n\tpGraphics->QuadsText(x+w-8*str_length(aBuf)-8, y+h-16, 16, aBuf);\n\tpGraphics->QuadsEnd();\n}\n\n\nvoid CSmoothTime::Init(int64 Target)\n{\n\tm_Snap = time_get();\n\tm_Current = Target;\n\tm_Target = Target;\n\tm_aAdjustSpeed[0] = 0.3f;\n\tm_aAdjustSpeed[1] = 0.3f;\n\tm_Graph.Init(0.0f, 0.5f);\n}\n\nvoid CSmoothTime::SetAdjustSpeed(int Direction, float Value)\n{\n\tm_aAdjustSpeed[Direction] = Value;\n}\n\nint64 CSmoothTime::Get(int64 Now)\n{\n\tint64 c = m_Current + (Now - m_Snap);\n\tint64 t = m_Target + (Now - m_Snap);\n\n\t// it's faster to adjust upward instead of downward\n\t// we might need to adjust these abit\n\n\tfloat AdjustSpeed = m_aAdjustSpeed[0];\n\tif(t > c)\n\t\tAdjustSpeed = m_aAdjustSpeed[1];\n\n\tfloat a = ((Now-m_Snap)/(float)time_freq()) * AdjustSpeed;\n\tif(a > 1.0f)\n\t\ta = 1.0f;\n\n\tint64 r = c + (int64)((t-c)*a);\n\n\tm_Graph.Add(a+0.5f,1,1,1);\n\n\treturn r;\n}\n\nvoid CSmoothTime::UpdateInt(int64 Target)\n{\n\tint64 Now = time_get();\n\tm_Current = Get(Now);\n\tm_Snap = Now;\n\tm_Target = Target;\n}\n\nvoid CSmoothTime::Update(CGraph *pGraph, int64 Target, int TimeLeft, int AdjustDirection)\n{\n\tint UpdateTimer = 1;\n\n\tif(TimeLeft < 0)\n\t{\n\t\tint IsSpike = 0;\n\t\tif(TimeLeft < -50)\n\t\t{\n\t\t\tIsSpike = 1;\n\n\t\t\tm_SpikeCounter += 5;\n\t\t\tif(m_SpikeCounter > 50)\n\t\t\t\tm_SpikeCounter = 50;\n\t\t}\n\n\t\tif(IsSpike && m_SpikeCounter < 15)\n\t\t{\n\t\t\t// ignore this ping spike\n\t\t\tUpdateTimer = 0;\n\t\t\tpGraph->Add(TimeLeft, 1,1,0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpGraph->Add(TimeLeft, 1,0,0);\n\t\t\tif(m_aAdjustSpeed[AdjustDirection] < 30.0f)\n\t\t\t\tm_aAdjustSpeed[AdjustDirection] *= 2.0f;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(m_SpikeCounter)\n\t\t\tm_SpikeCounter--;\n\n\t\tpGraph->Add(TimeLeft, 0,1,0);\n\n\t\tm_aAdjustSpeed[AdjustDirection] *= 0.95f;\n\t\tif(m_aAdjustSpeed[AdjustDirection] < 2.0f)\n\t\t\tm_aAdjustSpeed[AdjustDirection] = 2.0f;\n\t}\n\n\tif(UpdateTimer)\n\t\tUpdateInt(Target);\n}\n\n\nCClient::CClient() : m_DemoPlayer(&m_SnapshotDelta), m_DemoRecorder(&m_SnapshotDelta)\n{\n\tm_pEditor = 0;\n\tm_pInput = 0;\n\tm_pGraphics = 0;\n\tm_pSound = 0;\n\tm_pGameClient = 0;\n\tm_pMap = 0;\n\tm_pConsole = 0;\n\n\tm_RenderFrameTime = 0.0001f;\n\tm_RenderFrameTimeLow = 1.0f;\n\tm_RenderFrameTimeHigh = 0.0f;\n\tm_RenderFrames = 0;\n\tm_LastRenderTime = time_get();\n\n\tm_GameTickSpeed = SERVER_TICK_SPEED;\n\n\tm_WindowMustRefocus = 0;\n\tm_SnapCrcErrors = 0;\n\tm_AutoScreenshotRecycle = false;\n\tm_EditorActive = false;\n\n\tm_AckGameTick = -1;\n\tm_CurrentRecvTick = 0;\n\tm_RconAuthed = 0;\n\n\t// version-checking\n\tm_aVersionStr[0] = '0';\n\tm_aVersionStr[1] = 0;\n\n\t// pinging\n\tm_PingStartTime = 0;\n\n\t//\n\tm_aCurrentMap[0] = 0;\n\tm_CurrentMapCrc = 0;\n\n\t//\n\tm_aCmdConnect[0] = 0;\n\n\t// map download\n\tm_aMapdownloadFilename[0] = 0;\n\tm_aMapdownloadName[0] = 0;\n\tm_MapdownloadFile = 0;\n\tm_MapdownloadChunk = 0;\n\tm_MapdownloadCrc = 0;\n\tm_MapdownloadAmount = -1;\n\tm_MapdownloadTotalsize = -1;\n\n\tm_CurrentServerInfoRequestTime = -1;\n\n\tm_CurrentInput = 0;\n\n\tm_State = IClient::STATE_OFFLINE;\n\tm_aServerAddressStr[0] = 0;\n\n\tmem_zero(m_aSnapshots, sizeof(m_aSnapshots));\n\tm_SnapshotStorage.Init();\n\tm_RecivedSnapshots = 0;\n\n\tm_VersionInfo.m_State = CVersionInfo::STATE_INIT;\n}\n\n// ----- send functions -----\nint CClient::SendMsg(CMsgPacker *pMsg, int Flags)\n{\n\treturn SendMsgEx(pMsg, Flags, false);\n}\n\nint CClient::SendMsgEx(CMsgPacker *pMsg, int Flags, bool System)\n{\n\tCNetChunk Packet;\n\n\tif(State() == IClient::STATE_OFFLINE)\n\t\treturn 0;\n\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\n\tPacket.m_ClientID = 0;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\n\t// HACK: modify the message id in the packet and store the system flag\n\tif(*((unsigned char*)Packet.m_pData) == 1 && System && Packet.m_DataSize == 1)\n\t\tdbg_break();\n\n\t*((unsigned char*)Packet.m_pData) <<= 1;\n\tif(System)\n\t\t*((unsigned char*)Packet.m_pData) |= 1;\n\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\n\tif(Flags&MSGFLAG_RECORD)\n\t{\n\t\tif(m_DemoRecorder.IsRecording())\n\t\t\tm_DemoRecorder.RecordMessage(Packet.m_pData, Packet.m_DataSize);\n\t}\n\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t\tm_NetClient.Send(&Packet);\n\treturn 0;\n}\n\nvoid CClient::SendInfo()\n{\n\tCMsgPacker Msg(NETMSG_INFO);\n\tMsg.AddString(GameClient()->NetVersion(), 128);\n\tMsg.AddString(g_Config.m_Password, 128);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\n\nvoid CClient::SendEnterGame()\n{\n\tCMsgPacker Msg(NETMSG_ENTERGAME);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\nvoid CClient::SendReady()\n{\n\tCMsgPacker Msg(NETMSG_READY);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}\n\nvoid CClient::RconAuth(const char *pName, const char *pPassword)\n{\n\tif(RconAuthed())\n\t\treturn;\n\n\tCMsgPacker Msg(NETMSG_RCON_AUTH);\n\tMsg.AddString(pName, 32);\n\tMsg.AddString(pPassword, 32);\n\tMsg.AddInt(1);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL);\n}\n\nvoid CClient::Rcon(const char *pCmd)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD);\n\tMsg.AddString(pCmd, 256);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL);\n}\n\nbool CClient::ConnectionProblems()\n{\n\treturn m_NetClient.GotProblems() != 0;\n}\n\nvoid CClient::DirectInput(int *pInput, int Size)\n{\n\tint i;\n\tCMsgPacker Msg(NETMSG_INPUT);\n\tMsg.AddInt(m_AckGameTick);\n\tMsg.AddInt(m_PredTick);\n\tMsg.AddInt(Size);\n\n\tfor(i = 0; i < Size/4; i++)\n\t\tMsg.AddInt(pInput[i]);\n\n\tSendMsgEx(&Msg, 0);\n}\n\n\nvoid CClient::SendInput()\n{\n\tint64 Now = time_get();\n\n\tif(m_PredTick <= 0)\n\t\treturn;\n\n\t// fetch input\n\tint Size = GameClient()->OnSnapInput(m_aInputs[m_CurrentInput].m_aData);\n\n\tif(!Size)\n\t\treturn;\n\n\t// pack input\n\tCMsgPacker Msg(NETMSG_INPUT);\n\tMsg.AddInt(m_AckGameTick);\n\tMsg.AddInt(m_PredTick);\n\tMsg.AddInt(Size);\n\n\tm_aInputs[m_CurrentInput].m_Tick = m_PredTick;\n\tm_aInputs[m_CurrentInput].m_PredictedTime = m_PredictedTime.Get(Now);\n\tm_aInputs[m_CurrentInput].m_Time = Now;\n\n\t// pack it\n\tfor(int i = 0; i < Size/4; i++)\n\t\tMsg.AddInt(m_aInputs[m_CurrentInput].m_aData[i]);\n\n\tm_CurrentInput++;\n\tm_CurrentInput%=200;\n\n\tSendMsgEx(&Msg, MSGFLAG_FLUSH);\n}\n\nconst char *CClient::LatestVersion()\n{\n\treturn m_aVersionStr;\n}\n\n// TODO: OPT: do this alot smarter!\nint *CClient::GetInput(int Tick)\n{\n\tint Best = -1;\n\tfor(int i = 0; i < 200; i++)\n\t{\n\t\tif(m_aInputs[i].m_Tick <= Tick && (Best == -1 || m_aInputs[Best].m_Tick < m_aInputs[i].m_Tick))\n\t\t\tBest = i;\n\t}\n\n\tif(Best != -1)\n\t\treturn (int *)m_aInputs[Best].m_aData;\n\treturn 0;\n}\n\n// ------ state handling -----\nvoid CClient::SetState(int s)\n{\n\tif(m_State == IClient::STATE_QUITING)\n\t\treturn;\n\n\tint Old = m_State;\n\tif(g_Config.m_Debug)\n\t{\n\t\tchar aBuf[128];\n\t\tstr_format(aBuf, sizeof(aBuf), \"state change. last=%d current=%d\", m_State, s);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t}\n\tm_State = s;\n\tif(Old != s)\n\t\tGameClient()->OnStateChange(m_State, Old);\n}\n\n// called when the map is loaded and we should init for a new round\nvoid CClient::OnEnterGame()\n{\n\t// reset input\n\tint i;\n\tfor(i = 0; i < 200; i++)\n\t\tm_aInputs[i].m_Tick = -1;\n\tm_CurrentInput = 0;\n\n\t// reset snapshots\n\tm_aSnapshots[SNAP_CURRENT] = 0;\n\tm_aSnapshots[SNAP_PREV] = 0;\n\tm_SnapshotStorage.PurgeAll();\n\tm_RecivedSnapshots = 0;\n\tm_SnapshotParts = 0;\n\tm_PredTick = 0;\n\tm_CurrentRecvTick = 0;\n\tm_CurGameTick = 0;\n\tm_PrevGameTick = 0;\n}\n\nvoid CClient::EnterGame()\n{\n\tif(State() == IClient::STATE_DEMOPLAYBACK)\n\t\treturn;\n\n\t// now we will wait for two snapshots\n\t// to finish the connection\n\tSendEnterGame();\n\tOnEnterGame();\n}\n\nvoid CClient::Connect(const char *pAddress)\n{\n\tchar aBuf[512];\n\tint Port = 8303;\n\n\tDisconnect();\n\n\tstr_copy(m_aServerAddressStr, pAddress, sizeof(m_aServerAddressStr));\n\n\tstr_format(aBuf, sizeof(aBuf), \"connecting to '%s'\", m_aServerAddressStr);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\tServerInfoRequest();\n\n\tif(net_host_lookup(m_aServerAddressStr, &m_ServerAddress, m_NetClient.NetType()) != 0)\n\t{\n\t\tchar aBufMsg[256];\n\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"could not find the address of %s, connecting to localhost\", aBuf);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBufMsg);\n\t\tnet_host_lookup(\"localhost\", &m_ServerAddress, m_NetClient.NetType());\n\t}\n\n\tm_RconAuthed = 0;\n\tif(m_ServerAddress.port == 0)\n\t\tm_ServerAddress.port = Port;\n\tm_NetClient.Connect(&m_ServerAddress);\n\tSetState(IClient::STATE_CONNECTING);\n\n\tif(m_DemoRecorder.IsRecording())\n\t\tDemoRecorder_Stop();\n\n\tm_InputtimeMarginGraph.Init(-150.0f, 150.0f);\n\tm_GametimeMarginGraph.Init(-150.0f, 150.0f);\n}\n\nvoid CClient::DisconnectWithReason(const char *pReason)\n{\n\tchar aBuf[512];\n\tstr_format(aBuf, sizeof(aBuf), \"disconnecting. reason='%s'\", pReason?pReason:\"unknown\");\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\t// stop demo playback and recorder\n\tm_DemoPlayer.Stop();\n\tDemoRecorder_Stop();\n\n\t//\n\tm_RconAuthed = 0;\n\tm_UseTempRconCommands = 0;\n\tm_pConsole->DeregisterTempAll();\n\tm_NetClient.Disconnect(pReason);\n\tSetState(IClient::STATE_OFFLINE);\n\tm_pMap->Unload();\n\n\t// disable all downloads\n\tm_MapdownloadChunk = 0;\n\tif(m_MapdownloadFile)\n\t\tio_close(m_MapdownloadFile);\n\tm_MapdownloadFile = 0;\n\tm_MapdownloadCrc = 0;\n\tm_MapdownloadTotalsize = -1;\n\tm_MapdownloadAmount = 0;\n\n\t// clear the current server info\n\tmem_zero(&m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n\tmem_zero(&m_ServerAddress, sizeof(m_ServerAddress));\n\n\t// clear snapshots\n\tm_aSnapshots[SNAP_CURRENT] = 0;\n\tm_aSnapshots[SNAP_PREV] = 0;\n\tm_RecivedSnapshots = 0;\n}\n\nvoid CClient::Disconnect()\n{\n\tDisconnectWithReason(0);\n}\n\n\nvoid CClient::GetServerInfo(CServerInfo *pServerInfo)\n{\n\tmem_copy(pServerInfo, &m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n}\n\nvoid CClient::ServerInfoRequest()\n{\n\tmem_zero(&m_CurrentServerInfo, sizeof(m_CurrentServerInfo));\n\tm_CurrentServerInfoRequestTime = 0;\n}\n\nint CClient::LoadData()\n{\n\tm_DebugFont = Graphics()->LoadTexture(\"debug_font.png\", IStorage::TYPE_ALL, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_NORESAMPLE);\n\treturn 1;\n}\n\n// ---\n\nvoid *CClient::SnapGetItem(int SnapID, int Index, CSnapItem *pItem)\n{\n\tCSnapshotItem *i;\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\ti = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(Index);\n\tpItem->m_DataSize = m_aSnapshots[SnapID]->m_pAltSnap->GetItemSize(Index);\n\tpItem->m_Type = i->Type();\n\tpItem->m_ID = i->ID();\n\treturn (void *)i->Data();\n}\n\nvoid CClient::SnapInvalidateItem(int SnapID, int Index)\n{\n\tCSnapshotItem *i;\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\ti = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(Index);\n\tif(i)\n\t{\n\t\tif((char *)i < (char *)m_aSnapshots[SnapID]->m_pAltSnap || (char *)i > (char *)m_aSnapshots[SnapID]->m_pAltSnap + m_aSnapshots[SnapID]->m_SnapSize)\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"snap invalidate problem\");\n\t\tif((char *)i >= (char *)m_aSnapshots[SnapID]->m_pSnap && (char *)i < (char *)m_aSnapshots[SnapID]->m_pSnap + m_aSnapshots[SnapID]->m_SnapSize)\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"snap invalidate problem\");\n\t\ti->m_TypeAndID = -1;\n\t}\n}\n\nvoid *CClient::SnapFindItem(int SnapID, int Type, int ID)\n{\n\t// TODO: linear search. should be fixed.\n\tint i;\n\n\tif(!m_aSnapshots[SnapID])\n\t\treturn 0x0;\n\n\tfor(i = 0; i < m_aSnapshots[SnapID]->m_pSnap->NumItems(); i++)\n\t{\n\t\tCSnapshotItem *pItem = m_aSnapshots[SnapID]->m_pAltSnap->GetItem(i);\n\t\tif(pItem->Type() == Type && pItem->ID() == ID)\n\t\t\treturn (void *)pItem->Data();\n\t}\n\treturn 0x0;\n}\n\nint CClient::SnapNumItems(int SnapID)\n{\n\tdbg_assert(SnapID >= 0 && SnapID < NUM_SNAPSHOT_TYPES, \"invalid SnapID\");\n\tif(!m_aSnapshots[SnapID])\n\t\treturn 0;\n\treturn m_aSnapshots[SnapID]->m_pSnap->NumItems();\n}\n\nvoid CClient::SnapSetStaticsize(int ItemType, int Size)\n{\n\tm_SnapshotDelta.SetStaticsize(ItemType, Size);\n}\n\n\nvoid CClient::DebugRender()\n{\n\tstatic NETSTATS Prev, Current;\n\tstatic int64 LastSnap = 0;\n\tstatic float FrameTimeAvg = 0;\n\tint64 Now = time_get();\n\tchar aBuffer[512];\n\n\tif(!g_Config.m_Debug)\n\t\treturn;\n\n\t//m_pGraphics->BlendNormal();\n\tGraphics()->TextureSet(m_DebugFont);\n\tGraphics()->MapScreen(0,0,Graphics()->ScreenWidth(),Graphics()->ScreenHeight());\n\tGraphics()->QuadsBegin();\n\n\tif(time_get()-LastSnap > time_freq())\n\t{\n\t\tLastSnap = time_get();\n\t\tPrev = Current;\n\t\tnet_stats(&Current);\n\t}\n\n\t/*\n\t\teth = 14\n\t\tip = 20\n\t\tudp = 8\n\t\ttotal = 42\n\t*/\n\tFrameTimeAvg = FrameTimeAvg*0.9f + m_RenderFrameTime*0.1f;\n\tstr_format(aBuffer, sizeof(aBuffer), \"ticks: %8d %8d mem %dk %d gfxmem: %dk fps: %3d\",\n\t\tm_CurGameTick, m_PredTick,\n\t\tmem_stats()->allocated/1024,\n\t\tmem_stats()->total_allocations,\n\t\tGraphics()->MemoryUsage()/1024,\n\t\t(int)(1.0f/FrameTimeAvg + 0.5f));\n\tGraphics()->QuadsText(2, 2, 16, aBuffer);\n\n\n\t{\n\t\tint SendPackets = (Current.sent_packets-Prev.sent_packets);\n\t\tint SendBytes = (Current.sent_bytes-Prev.sent_bytes);\n\t\tint SendTotal = SendBytes + SendPackets*42;\n\t\tint RecvPackets = (Current.recv_packets-Prev.recv_packets);\n\t\tint RecvBytes = (Current.recv_bytes-Prev.recv_bytes);\n\t\tint RecvTotal = RecvBytes + RecvPackets*42;\n\n\t\tif(!SendPackets) SendPackets++;\n\t\tif(!RecvPackets) RecvPackets++;\n\t\tstr_format(aBuffer, sizeof(aBuffer), \"send: %3d %5d+%4d=%5d (%3d kbps) avg: %5d\\nrecv: %3d %5d+%4d=%5d (%3d kbps) avg: %5d\",\n\t\t\tSendPackets, SendBytes, SendPackets*42, SendTotal, (SendTotal*8)/1024, SendBytes/SendPackets,\n\t\t\tRecvPackets, RecvBytes, RecvPackets*42, RecvTotal, (RecvTotal*8)/1024, RecvBytes/RecvPackets);\n\t\tGraphics()->QuadsText(2, 14, 16, aBuffer);\n\t}\n\n\t// render rates\n\t{\n\t\tint y = 0;\n\t\tint i;\n\t\tfor(i = 0; i < 256; i++)\n\t\t{\n\t\t\tif(m_SnapshotDelta.GetDataRate(i))\n\t\t\t{\n\t\t\t\tstr_format(aBuffer, sizeof(aBuffer), \"%4d %20s: %8d %8d %8d\", i, GameClient()->GetItemName(i), m_SnapshotDelta.GetDataRate(i)/8, m_SnapshotDelta.GetDataUpdates(i),\n\t\t\t\t\t(m_SnapshotDelta.GetDataRate(i)/m_SnapshotDelta.GetDataUpdates(i))/8);\n\t\t\t\tGraphics()->QuadsText(2, 100+y*12, 16, aBuffer);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstr_format(aBuffer, sizeof(aBuffer), \"pred: %d ms\",\n\t\t(int)((m_PredictedTime.Get(Now)-m_GameTime.Get(Now))*1000/(float)time_freq()));\n\tGraphics()->QuadsText(2, 70, 16, aBuffer);\n\tGraphics()->QuadsEnd();\n\n\t// render graphs\n\tif(g_Config.m_DbgGraphs)\n\t{\n\t\t//Graphics()->MapScreen(0,0,400.0f,300.0f);\n\t\tfloat w = Graphics()->ScreenWidth()/4.0f;\n\t\tfloat h = Graphics()->ScreenHeight()/6.0f;\n\t\tfloat sp = Graphics()->ScreenWidth()/100.0f;\n\t\tfloat x = Graphics()->ScreenWidth()-w-sp;\n\n\t\tm_FpsGraph.ScaleMax();\n\t\tm_FpsGraph.ScaleMin();\n\t\tm_FpsGraph.Render(Graphics(), m_DebugFont, x, sp*5, w, h, \"FPS\");\n\t\tm_InputtimeMarginGraph.Render(Graphics(), m_DebugFont, x, sp*5+h+sp, w, h, \"Prediction Margin\");\n\t\tm_GametimeMarginGraph.Render(Graphics(), m_DebugFont, x, sp*5+h+sp+h+sp, w, h, \"Gametime Margin\");\n\t}\n}\n\nvoid CClient::Quit()\n{\n\tSetState(IClient::STATE_QUITING);\n}\n\nconst char *CClient::ErrorString()\n{\n\treturn m_NetClient.ErrorString();\n}\n\nvoid CClient::Render()\n{\n\tif(g_Config.m_GfxClear)\n\t\tGraphics()->Clear(1,1,0);\n\n\tGameClient()->OnRender();\n\tDebugRender();\n}\n\nconst char *CClient::LoadMap(const char *pName, const char *pFilename, unsigned WantedCrc)\n{\n\tstatic char aErrorMsg[128];\n\n\tSetState(IClient::STATE_LOADING);\n\n\tif(!m_pMap->Load(pFilename))\n\t{\n\t\tstr_format(aErrorMsg, sizeof(aErrorMsg), \"map '%s' not found\", pFilename);\n\t\treturn aErrorMsg;\n\t}\n\n\t// get the crc of the map\n\tif(m_pMap->Crc() != WantedCrc)\n\t{\n\t\tstr_format(aErrorMsg, sizeof(aErrorMsg), \"map differs from the server. %08x != %08x\", m_pMap->Crc(), WantedCrc);\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aErrorMsg);\n\t\tm_pMap->Unload();\n\t\treturn aErrorMsg;\n\t}\n\n\t// stop demo recording if we loaded a new map\n\tDemoRecorder_Stop();\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"loaded map '%s'\", pFilename);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aBuf);\n\tm_RecivedSnapshots = 0;\n\n\tstr_copy(m_aCurrentMap, pName, sizeof(m_aCurrentMap));\n\tm_CurrentMapCrc = m_pMap->Crc();\n\n\treturn 0x0;\n}\n\n\n\nconst char *CClient::LoadMapSearch(const char *pMapName, int WantedCrc)\n{\n\tconst char *pError = 0;\n\tchar aBuf[512];\n\tstr_format(aBuf, sizeof(aBuf), \"loading map, map=%s wanted crc=%08x\", pMapName, WantedCrc);\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", aBuf);\n\tSetState(IClient::STATE_LOADING);\n\n\t// try the normal maps folder\n\tstr_format(aBuf, sizeof(aBuf), \"maps/%s.map\", pMapName);\n\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\tif(!pError)\n\t\treturn pError;\n\n\t// try the downloaded maps\n\tstr_format(aBuf, sizeof(aBuf), \"downloadedmaps/%s_%08x.map\", pMapName, WantedCrc);\n\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\tif(!pError)\n\t\treturn pError;\n\n\t// search for the map within subfolders\n\tchar aFilename[128];\n\tstr_format(aFilename, sizeof(aFilename), \"%s.map\", pMapName);\n\tif(Storage()->FindFile(aFilename, \"maps\", IStorage::TYPE_ALL, aBuf, sizeof(aBuf)))\n\t\tpError = LoadMap(pMapName, aBuf, WantedCrc);\n\n\treturn pError;\n}\n\nint CClient::PlayerScoreComp(const void *a, const void *b)\n{\n\tCServerInfo::CClient *p0 = (CServerInfo::CClient *)a;\n\tCServerInfo::CClient *p1 = (CServerInfo::CClient *)b;\n\tif(p0->m_Player && !p1->m_Player)\n\t\treturn -1;\n\tif(!p0->m_Player && p1->m_Player)\n\t\treturn 1;\n\tif(p0->m_Score == p1->m_Score)\n\t\treturn 0;\n\tif(p0->m_Score < p1->m_Score)\n\t\treturn 1;\n\treturn -1;\n}\n\nvoid CClient::ProcessConnlessPacket(CNetChunk *pPacket)\n{\n\t// version server\n\tif(m_VersionInfo.m_State == CVersionInfo::STATE_READY && net_addr_comp(&pPacket->m_Address, &m_VersionInfo.m_VersionServeraddr.m_Addr) == 0)\n\t{\n\t\t// version info\n\t\tif(pPacket->m_DataSize == (int)(sizeof(VERSIONSRV_VERSION) + sizeof(GAME_RELEASE_VERSION)) &&\n\t\t\tmem_comp(pPacket->m_pData, VERSIONSRV_VERSION, sizeof(VERSIONSRV_VERSION)) == 0)\n\n\t\t{\n\t\t\tchar *pVersionData = (char*)pPacket->m_pData + sizeof(VERSIONSRV_VERSION);\n\t\t\tint VersionMatch = !mem_comp(pVersionData, GAME_RELEASE_VERSION, sizeof(GAME_RELEASE_VERSION));\n\n\t\t\tchar aVersion[sizeof(GAME_RELEASE_VERSION)];\n\t\t\tstr_copy(aVersion, pVersionData, sizeof(aVersion));\n\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"version does %s (%s)\",\n\t\t\t\tVersionMatch ? \"match\" : \"NOT match\",\n\t\t\t\taVersion);\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/version\", aBuf);\n\n\t\t\t// assume version is out of date when version-data doesn't match\n\t\t\tif(!VersionMatch)\n\t\t\t{\n\t\t\t\tstr_copy(m_aVersionStr, aVersion, sizeof(m_aVersionStr));\n\t\t\t}\n\n\t\t\t// request the map version list now\n\t\t\tCNetChunk Packet;\n\t\t\tmem_zero(&Packet, sizeof(Packet));\n\t\t\tPacket.m_ClientID = -1;\n\t\t\tPacket.m_Address = m_VersionInfo.m_VersionServeraddr.m_Addr;\n\t\t\tPacket.m_pData = VERSIONSRV_GETMAPLIST;\n\t\t\tPacket.m_DataSize = sizeof(VERSIONSRV_GETMAPLIST);\n\t\t\tPacket.m_Flags = NETSENDFLAG_CONNLESS;\n\t\t\tm_ContactClient.Send(&Packet);\n\t\t}\n\n\t\t// map version list\n\t\tif(pPacket->m_DataSize >= (int)sizeof(VERSIONSRV_MAPLIST) &&\n\t\t\tmem_comp(pPacket->m_pData, VERSIONSRV_MAPLIST, sizeof(VERSIONSRV_MAPLIST)) == 0)\n\t\t{\n\t\t\tint Size = pPacket->m_DataSize-sizeof(VERSIONSRV_MAPLIST);\n\t\t\tint Num = Size/sizeof(CMapVersion);\n\t\t\tm_MapChecker.AddMaplist((CMapVersion *)((char*)pPacket->m_pData+sizeof(VERSIONSRV_MAPLIST)), Num);\n\t\t}\n\t}\n\n\t// server list from master server\n\tif(pPacket->m_DataSize >= (int)sizeof(SERVERBROWSE_LIST) &&\n\t\tmem_comp(pPacket->m_pData, SERVERBROWSE_LIST, sizeof(SERVERBROWSE_LIST)) == 0)\n\t{\n\t\t// check for valid master server address\n\t\tbool Valid = false;\n\t\tfor(int i = 0; i < IMasterServer::MAX_MASTERSERVERS; ++i)\n\t\t{\n\t\t\tif(m_pMasterServer->IsValid(i))\n\t\t\t{\n\t\t\t\tNETADDR Addr = m_pMasterServer->GetAddr(i);\n\t\t\t\tif(net_addr_comp(&pPacket->m_Address, &Addr) == 0)\n\t\t\t\t{\n\t\t\t\t\tValid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!Valid)\n\t\t\treturn;\n\n\t\tint Size = pPacket->m_DataSize-sizeof(SERVERBROWSE_LIST);\n\t\tint Num = Size/sizeof(CMastersrvAddr);\n\t\tCMastersrvAddr *pAddrs = (CMastersrvAddr *)((char*)pPacket->m_pData+sizeof(SERVERBROWSE_LIST));\n\t\tfor(int i = 0; i < Num; i++)\n\t\t{\n\t\t\tNETADDR Addr;\n\n\t\t\tstatic unsigned char IPV4Mapping[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };\n\n\t\t\t// copy address\n\t\t\tif(!mem_comp(IPV4Mapping, pAddrs[i].m_aIp, sizeof(IPV4Mapping)))\n\t\t\t{\n\t\t\t\tmem_zero(&Addr, sizeof(Addr));\n\t\t\t\tAddr.type = NETTYPE_IPV4;\n\t\t\t\tAddr.ip[0] = pAddrs[i].m_aIp[12];\n\t\t\t\tAddr.ip[1] = pAddrs[i].m_aIp[13];\n\t\t\t\tAddr.ip[2] = pAddrs[i].m_aIp[14];\n\t\t\t\tAddr.ip[3] = pAddrs[i].m_aIp[15];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAddr.type = NETTYPE_IPV6;\n\t\t\t\tmem_copy(Addr.ip, pAddrs[i].m_aIp, sizeof(Addr.ip));\n\t\t\t}\n\t\t\tAddr.port = (pAddrs[i].m_aPort[0]<<8) | pAddrs[i].m_aPort[1];\n\n\t\t\tm_ServerBrowser.Set(Addr, IServerBrowser::SET_MASTER_ADD, -1, 0x0);\n\t\t}\n\t}\n\n\t// server info\n\tif(pPacket->m_DataSize >= (int)sizeof(SERVERBROWSE_INFO) && mem_comp(pPacket->m_pData, SERVERBROWSE_INFO, sizeof(SERVERBROWSE_INFO)) == 0)\n\t{\n\t\t// we got ze info\n\t\tCUnpacker Up;\n\t\tCServerInfo Info = {0};\n\n\t\tUp.Reset((unsigned char*)pPacket->m_pData+sizeof(SERVERBROWSE_INFO), pPacket->m_DataSize-sizeof(SERVERBROWSE_INFO));\n\t\tint Token = str_toint(Up.GetString());\n\t\tstr_copy(Info.m_aVersion, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aVersion));\n\t\tstr_copy(Info.m_aName, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aName));\n\t\tstr_copy(Info.m_aMap, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aMap));\n\t\tstr_copy(Info.m_aGameType, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aGameType));\n\t\tInfo.m_Flags = str_toint(Up.GetString());\n\t\tInfo.m_NumPlayers = str_toint(Up.GetString());\n\t\tInfo.m_MaxPlayers = str_toint(Up.GetString());\n\t\tInfo.m_NumClients = str_toint(Up.GetString());\n\t\tInfo.m_MaxClients = str_toint(Up.GetString());\n\n\t\t// don't add invalid info to the server browser list\n\t\tif(Info.m_NumClients < 0 || Info.m_NumClients > MAX_CLIENTS || Info.m_MaxClients < 0 || Info.m_MaxClients > MAX_CLIENTS ||\n\t\t\tInfo.m_NumPlayers < 0 || Info.m_NumPlayers > Info.m_NumClients || Info.m_MaxPlayers < 0 || Info.m_MaxPlayers > Info.m_MaxClients)\n\t\t\treturn;\n\n\t\tnet_addr_str(&pPacket->m_Address, Info.m_aAddress, sizeof(Info.m_aAddress), true);\n\n\t\tfor(int i = 0; i < Info.m_NumClients; i++)\n\t\t{\n\t\t\tstr_copy(Info.m_aClients[i].m_aName, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aClients[i].m_aName));\n\t\t\tstr_copy(Info.m_aClients[i].m_aClan, Up.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES), sizeof(Info.m_aClients[i].m_aClan));\n\t\t\tInfo.m_aClients[i].m_Country = str_toint(Up.GetString());\n\t\t\tInfo.m_aClients[i].m_Score = str_toint(Up.GetString());\n\t\t\tInfo.m_aClients[i].m_Player = str_toint(Up.GetString()) != 0 ? true : false;\n\t\t}\n\n\t\tif(!Up.Error())\n\t\t{\n\t\t\t// sort players\n\t\t\tqsort(Info.m_aClients, Info.m_NumClients, sizeof(*Info.m_aClients), PlayerScoreComp);\n\n\t\t\tif(net_addr_comp(&m_ServerAddress, &pPacket->m_Address) == 0)\n\t\t\t{\n\t\t\t\tmem_copy(&m_CurrentServerInfo, &Info, sizeof(m_CurrentServerInfo));\n\t\t\t\tm_CurrentServerInfo.m_NetAddr = m_ServerAddress;\n\t\t\t\tm_CurrentServerInfoRequestTime = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_ServerBrowser.Set(pPacket->m_Address, IServerBrowser::SET_TOKEN, Token, &Info);\n\t\t}\n\t}\n}\n\nvoid CClient::ProcessServerPacket(CNetChunk *pPacket)\n{\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_CHANGE)\n\t\t{\n\t\t\tconst char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES);\n\t\t\tint MapCrc = Unpacker.GetInt();\n\t\t\tint MapSize = Unpacker.GetInt();\n\t\t\tconst char *pError = 0;\n\n\t\t\tif(Unpacker.Error())\n\t\t\t\treturn;\n\n\t\t\t// check for valid standard map\n\t\t\tif(!m_MapChecker.IsMapValid(pMap, MapCrc, MapSize))\n\t\t\t\tpError = \"invalid standard map\";\n\n\t\t\tfor(int i = 0; pMap[i]; i++) // protect the player from nasty map names\n\t\t\t{\n\t\t\t\tif(pMap[i] == '/' || pMap[i] == '\\\\')\n\t\t\t\t\tpError = \"strange character in map name\";\n\t\t\t}\n\n\t\t\tif(MapSize < 0)\n\t\t\t\tpError = \"invalid map size\";\n\n\t\t\tif(pError)\n\t\t\t\tDisconnectWithReason(pError);\n\t\t\telse\n\t\t\t{\n\t\t\t\tpError = LoadMapSearch(pMap, MapCrc);\n\n\t\t\t\tif(!pError)\n\t\t\t\t{\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"loading done\");\n\t\t\t\t\tSendReady();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr_format(m_aMapdownloadFilename, sizeof(m_aMapdownloadFilename), \"downloadedmaps/%s_%08x.map\", pMap, MapCrc);\n\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"starting to download map to '%s'\", m_aMapdownloadFilename);\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", aBuf);\n\n\t\t\t\t\tm_MapdownloadChunk = 0;\n\t\t\t\t\tstr_copy(m_aMapdownloadName, pMap, sizeof(m_aMapdownloadName));\n\t\t\t\t\tif(m_MapdownloadFile)\n\t\t\t\t\t\tio_close(m_MapdownloadFile);\n\t\t\t\t\tm_MapdownloadFile = Storage()->OpenFile(m_aMapdownloadFilename, IOFLAG_WRITE, IStorage::TYPE_SAVE);\n\t\t\t\t\tm_MapdownloadCrc = MapCrc;\n\t\t\t\t\tm_MapdownloadTotalsize = MapSize;\n\t\t\t\t\tm_MapdownloadAmount = 0;\n\n\t\t\t\t\tCMsgPacker Msg(NETMSG_REQUEST_MAP_DATA);\n\t\t\t\t\tMsg.AddInt(m_MapdownloadChunk);\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n\n\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t{\n\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);\n\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client/network\", aBuf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA)\n\t\t{\n\t\t\tint Last = Unpacker.GetInt();\n\t\t\tint MapCRC = Unpacker.GetInt();\n\t\t\tint Chunk = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\t\t\tconst unsigned char *pData = Unpacker.GetRaw(Size);\n\n\t\t\t// check fior errors\n\t\t\tif(Unpacker.Error() || Size <= 0 || MapCRC != m_MapdownloadCrc || Chunk != m_MapdownloadChunk || !m_MapdownloadFile)\n\t\t\t\treturn;\n\n\t\t\tio_write(m_MapdownloadFile, pData, Size);\n\n\t\t\tm_MapdownloadAmount += Size;\n\n\t\t\tif(Last)\n\t\t\t{\n\t\t\t\tconst char *pError;\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"download complete, loading map\");\n\n\t\t\t\tif(m_MapdownloadFile)\n\t\t\t\t\tio_close(m_MapdownloadFile);\n\t\t\t\tm_MapdownloadFile = 0;\n\t\t\t\tm_MapdownloadAmount = 0;\n\t\t\t\tm_MapdownloadTotalsize = -1;\n\n\t\t\t\t// load map\n\t\t\t\tpError = LoadMap(m_aMapdownloadName, m_aMapdownloadFilename, m_MapdownloadCrc);\n\t\t\t\tif(!pError)\n\t\t\t\t{\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"loading done\");\n\t\t\t\t\tSendReady();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDisconnectWithReason(pError);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// request new chunk\n\t\t\t\tm_MapdownloadChunk++;\n\n\t\t\t\tCMsgPacker Msg(NETMSG_REQUEST_MAP_DATA);\n\t\t\t\tMsg.AddInt(m_MapdownloadChunk);\n\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n\n\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t{\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);\n\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client/network\", aBuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY)\n\t\t{\n\t\t\tGameClient()->OnConnected();\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY);\n\t\t\tSendMsgEx(&Msg, 0);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD)\n\t\t{\n\t\t\tconst char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tconst char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tconst char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM)\n\t\t{\n\t\t\tconst char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_pConsole->DeregisterTemp(pName);\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_STATUS)\n\t\t{\n\t\t\tint Result = Unpacker.GetInt();\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tm_RconAuthed = Result;\n\t\t\tint Old = m_UseTempRconCommands;\n\t\t\tm_UseTempRconCommands = Unpacker.GetInt();\n\t\t\tif(Unpacker.Error() != 0)\n\t\t\t\tm_UseTempRconCommands = 0;\n\t\t\tif(Old != 0 && m_UseTempRconCommands == 0)\n\t\t\t\tm_pConsole->DeregisterTempAll();\n\t\t}\n\t\telse if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE)\n\t\t{\n\t\t\tconst char *pLine = Unpacker.GetString();\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t\tGameClient()->OnRconLine(pLine);\n\t\t}\n\t\telse if(Msg == NETMSG_PING_REPLY)\n\t\t{\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"latency %.2f\", (time_get() - m_PingStartTime)*1000 / (float)time_freq());\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client/network\", aBuf);\n\t\t}\n\t\telse if(Msg == NETMSG_INPUTTIMING)\n\t\t{\n\t\t\tint InputPredTick = Unpacker.GetInt();\n\t\t\tint TimeLeft = Unpacker.GetInt();\n\n\t\t\t// adjust our prediction time\n\t\t\tint64 Target = 0;\n\t\t\tfor(int k = 0; k < 200; k++)\n\t\t\t{\n\t\t\t\tif(m_aInputs[k].m_Tick == InputPredTick)\n\t\t\t\t{\n\t\t\t\t\tTarget = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time);\n\t\t\t\t\tTarget = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(Target)\n\t\t\t\tm_PredictedTime.Update(&m_InputtimeMarginGraph, Target, TimeLeft, 1);\n\t\t}\n\t\telse if(Msg == NETMSG_SNAP || Msg == NETMSG_SNAPSINGLE || Msg == NETMSG_SNAPEMPTY)\n\t\t{\n\t\t\tint NumParts = 1;\n\t\t\tint Part = 0;\n\t\t\tint GameTick = Unpacker.GetInt();\n\t\t\tint DeltaTick = GameTick-Unpacker.GetInt();\n\t\t\tint PartSize = 0;\n\t\t\tint Crc = 0;\n\t\t\tint CompleteSize = 0;\n\t\t\tconst char *pData = 0;\n\n\t\t\t// we are not allowed to process snapshot yet\n\t\t\tif(State() < IClient::STATE_LOADING)\n\t\t\t\treturn;\n\n\t\t\tif(Msg == NETMSG_SNAP)\n\t\t\t{\n\t\t\t\tNumParts = Unpacker.GetInt();\n\t\t\t\tPart = Unpacker.GetInt();\n\t\t\t}\n\n\t\t\tif(Msg != NETMSG_SNAPEMPTY)\n\t\t\t{\n\t\t\t\tCrc = Unpacker.GetInt();\n\t\t\t\tPartSize = Unpacker.GetInt();\n\t\t\t}\n\n\t\t\tpData = (const char *)Unpacker.GetRaw(PartSize);\n\n\t\t\tif(Unpacker.Error() || NumParts < 1 || NumParts > CSnapshot::MAX_PARTS || Part < 0 | Part >= NumParts || PartSize < 0 || PartSize > MAX_SNAPSHOT_PACKSIZE)\n\t\t\t\treturn;\n\n\t\t\tif(GameTick >= m_CurrentRecvTick)\n\t\t\t{\n\t\t\t\tif(GameTick != m_CurrentRecvTick)\n\t\t\t\t{\n\t\t\t\t\tm_SnapshotParts = 0;\n\t\t\t\t\tm_CurrentRecvTick = GameTick;\n\t\t\t\t}\n\n\t\t\t\t// TODO: clean this up abit\n\t\t\t\tmem_copy((char*)m_aSnapshotIncommingData + Part*MAX_SNAPSHOT_PACKSIZE, pData, PartSize);\n\t\t\t\tm_SnapshotParts |= 1<<Part;\n\n\t\t\t\tif(m_SnapshotParts == (unsigned)((1<<NumParts)-1))\n\t\t\t\t{\n\t\t\t\t\tstatic CSnapshot Emptysnap;\n\t\t\t\t\tCSnapshot *pDeltaShot = &Emptysnap;\n\t\t\t\t\tint PurgeTick;\n\t\t\t\t\tvoid *pDeltaData;\n\t\t\t\t\tint DeltaSize;\n\t\t\t\t\tunsigned char aTmpBuffer2[CSnapshot::MAX_SIZE];\n\t\t\t\t\tunsigned char aTmpBuffer3[CSnapshot::MAX_SIZE];\n\t\t\t\t\tCSnapshot *pTmpBuffer3 = (CSnapshot*)aTmpBuffer3;\t// Fix compiler warning for strict-aliasing\n\t\t\t\t\tint SnapSize;\n\n\t\t\t\t\tCompleteSize = (NumParts-1) * MAX_SNAPSHOT_PACKSIZE + PartSize;\n\n\t\t\t\t\t// reset snapshoting\n\t\t\t\t\tm_SnapshotParts = 0;\n\n\t\t\t\t\t// find snapshot that we should use as delta\n\t\t\t\t\tEmptysnap.Clear();\n\n\t\t\t\t\t// find delta\n\t\t\t\t\tif(DeltaTick >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint DeltashotSize = m_SnapshotStorage.Get(DeltaTick, 0, &pDeltaShot, 0);\n\n\t\t\t\t\t\tif(DeltashotSize < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// couldn't find the delta snapshots that the server used\n\t\t\t\t\t\t\t// to compress this snapshot. force the server to resync\n\t\t\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"error, couldn't find the delta snapshot\");\n\t\t\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// ack snapshot\n\t\t\t\t\t\t\t// TODO: combine this with the input message\n\t\t\t\t\t\t\tm_AckGameTick = -1;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress snapshot\n\t\t\t\t\tpDeltaData = m_SnapshotDelta.EmptyDelta();\n\t\t\t\t\tDeltaSize = sizeof(int)*3;\n\n\t\t\t\t\tif(CompleteSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tint IntSize = CVariableInt::Decompress(m_aSnapshotIncommingData, CompleteSize, aTmpBuffer2);\n\n\t\t\t\t\t\tif(IntSize < 0) // failure during decompression, bail\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tpDeltaData = aTmpBuffer2;\n\t\t\t\t\t\tDeltaSize = IntSize;\n\t\t\t\t\t}\n\n\t\t\t\t\t// unpack delta\n\t\t\t\t\tSnapSize = m_SnapshotDelta.UnpackDelta(pDeltaShot, pTmpBuffer3, pDeltaData, DeltaSize);\n\t\t\t\t\tif(SnapSize < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", \"delta unpack failed!\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(Msg != NETMSG_SNAPEMPTY && pTmpBuffer3->Crc() != Crc)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(g_Config.m_Debug)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"snapshot crc error #%d - tick=%d wantedcrc=%d gotcrc=%d compressed_size=%d delta_tick=%d\",\n\t\t\t\t\t\t\t\tm_SnapCrcErrors, GameTick, Crc, pTmpBuffer3->Crc(), CompleteSize, DeltaTick);\n\t\t\t\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"client\", aBuf);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm_SnapCrcErrors++;\n\t\t\t\t\t\tif(m_SnapCrcErrors > 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// to many errors, send reset\n\t\t\t\t\t\t\tm_AckGameTick = -1;\n\t\t\t\t\t\t\tSendInput();\n\t\t\t\t\t\t\tm_SnapCrcErrors = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m_SnapCrcErrors)\n\t\t\t\t\t\t\tm_SnapCrcErrors--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// purge old snapshots\n\t\t\t\t\tPurgeTick = DeltaTick;\n\t\t\t\t\tif(m_aSnapshots[SNAP_PREV] && m_aSnapshots[SNAP_PREV]->m_Tick < PurgeTick)\n\t\t\t\t\t\tPurgeTick = m_aSnapshots[SNAP_PREV]->m_Tick;\n\t\t\t\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_CURRENT]->m_Tick < PurgeTick)\n\t\t\t\t\t\tPurgeTick = m_aSnapshots[SNAP_CURRENT]->m_Tick;\n\t\t\t\t\tm_SnapshotStorage.PurgeUntil(PurgeTick);\n\n\t\t\t\t\t// add new\n\t\t\t\t\tm_SnapshotStorage.Add(GameTick, time_get(), SnapSize, pTmpBuffer3, 1);\n\n\t\t\t\t\t// add snapshot to demo\n\t\t\t\t\tif(m_DemoRecorder.IsRecording())\n\t\t\t\t\t{\n\t\t\t\t\t\t// write snapshot\n\t\t\t\t\t\tm_DemoRecorder.RecordSnapshot(GameTick, pTmpBuffer3, SnapSize);\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply snapshot, cycle pointers\n\t\t\t\t\tm_RecivedSnapshots++;\n\n\t\t\t\t\tm_CurrentRecvTick = GameTick;\n\n\t\t\t\t\t// we got two snapshots until we see us self as connected\n\t\t\t\t\tif(m_RecivedSnapshots == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t// start at 200ms and work from there\n\t\t\t\t\t\tm_PredictedTime.Init(GameTick*time_freq()/50);\n\t\t\t\t\t\tm_PredictedTime.SetAdjustSpeed(1, 1000.0f);\n\t\t\t\t\t\tm_GameTime.Init((GameTick-1)*time_freq()/50);\n\t\t\t\t\t\tm_aSnapshots[SNAP_PREV] = m_SnapshotStorage.m_pFirst;\n\t\t\t\t\t\tm_aSnapshots[SNAP_CURRENT] = m_SnapshotStorage.m_pLast;\n\t\t\t\t\t\tm_LocalStartTime = time_get();\n\t\t\t\t\t\tSetState(IClient::STATE_ONLINE);\n\t\t\t\t\t\tDemoRecorder_HandleAutoStart();\n\t\t\t\t\t}\n\n\t\t\t\t\t// adjust game time\n\t\t\t\t\tif(m_RecivedSnapshots > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 Now = m_GameTime.Get(time_get());\n\t\t\t\t\t\tint64 TickStart = GameTick*time_freq()/50;\n\t\t\t\t\t\tint64 TimeLeft = (TickStart-Now)*1000 / time_freq();\n\t\t\t\t\t\tm_GameTime.Update(&m_GametimeMarginGraph, (GameTick-1)*time_freq()/50, TimeLeft, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\t// ack snapshot\n\t\t\t\t\tm_AckGameTick = GameTick;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0)\n\t\t{\n\t\t\t// game message\n\t\t\tif(m_DemoRecorder.IsRecording())\n\t\t\t\tm_DemoRecorder.RecordMessage(pPacket->m_pData, pPacket->m_DataSize);\n\n\t\t\tGameClient()->OnMessage(Msg, &Unpacker);\n\t\t}\n\t}\n}\n\nvoid CClient::PumpNetwork()\n{\n\tm_NetClient.Update();\n\n\tif(State() != IClient::STATE_DEMOPLAYBACK)\n\t{\n\t\t// check for errors\n\t\tif(State() != IClient::STATE_OFFLINE && State() != IClient::STATE_QUITING && m_NetClient.State() == NETSTATE_OFFLINE)\n\t\t{\n\t\t\tSetState(IClient::STATE_OFFLINE);\n\t\t\tDisconnect();\n\t\t\tchar aBuf[256];\n\t\t\tstr_format(aBuf, sizeof(aBuf), \"offline error='%s'\", m_NetClient.ErrorString());\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\t\t}\n\n\t\t//\n\t\tif(State() == IClient::STATE_CONNECTING && m_NetClient.State() == NETSTATE_ONLINE)\n\t\t{\n\t\t\t// we switched to online\n\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", \"connected, sending info\");\n\t\t\tSetState(IClient::STATE_LOADING);\n\t\t\tSendInfo();\n\t\t}\n\t}\n\n\t// process non-connless packets\n\tCNetChunk Packet;\n\twhile(m_NetClient.Recv(&Packet))\n\t{\n\t\tif(Packet.m_ClientID != -1)\n\t\t\tProcessServerPacket(&Packet);\n\t}\n\n\t// process connless packets data\n\tm_ContactClient.Update();\n\twhile(m_ContactClient.Recv(&Packet))\n\t{\n\t\tif(Packet.m_ClientID == -1)\n\t\t\tProcessConnlessPacket(&Packet);\n\t}\n}\n\nvoid CClient::OnDemoPlayerSnapshot(void *pData, int Size)\n{\n\t// update ticks, they could have changed\n\tconst CDemoPlayer::CPlaybackInfo *pInfo = m_DemoPlayer.Info();\n\tCSnapshotStorage::CHolder *pTemp;\n\tm_CurGameTick = pInfo->m_Info.m_CurrentTick;\n\tm_PrevGameTick = pInfo->m_PreviousTick;\n\n\t// handle snapshots\n\tpTemp = m_aSnapshots[SNAP_PREV];\n\tm_aSnapshots[SNAP_PREV] = m_aSnapshots[SNAP_CURRENT];\n\tm_aSnapshots[SNAP_CURRENT] = pTemp;\n\n\tmem_copy(m_aSnapshots[SNAP_CURRENT]->m_pSnap, pData, Size);\n\tmem_copy(m_aSnapshots[SNAP_CURRENT]->m_pAltSnap, pData, Size);\n\n\tGameClient()->OnNewSnapshot();\n}\n\nvoid CClient::OnDemoPlayerMessage(void *pData, int Size)\n{\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pData, Size);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(!Sys)\n\t\tGameClient()->OnMessage(Msg, &Unpacker);\n}\n/*\nconst IDemoPlayer::CInfo *client_demoplayer_getinfo()\n{\n\tstatic DEMOPLAYBACK_INFO ret;\n\tconst DEMOREC_PLAYBACKINFO *info = m_DemoPlayer.Info();\n\tret.first_tick = info->first_tick;\n\tret.last_tick = info->last_tick;\n\tret.current_tick = info->current_tick;\n\tret.paused = info->paused;\n\tret.speed = info->speed;\n\treturn &ret;\n}*/\n\n/*\nvoid DemoPlayer()->SetPos(float percent)\n{\n\tdemorec_playback_set(percent);\n}\n\nvoid DemoPlayer()->SetSpeed(float speed)\n{\n\tdemorec_playback_setspeed(speed);\n}\n\nvoid DemoPlayer()->SetPause(int paused)\n{\n\tif(paused)\n\t\tdemorec_playback_pause();\n\telse\n\t\tdemorec_playback_unpause();\n}*/\n\nvoid CClient::Update()\n{\n\tif(State() == IClient::STATE_DEMOPLAYBACK)\n\t{\n\t\tm_DemoPlayer.Update();\n\t\tif(m_DemoPlayer.IsPlaying())\n\t\t{\n\t\t\t// update timers\n\t\t\tconst CDemoPlayer::CPlaybackInfo *pInfo = m_DemoPlayer.Info();\n\t\t\tm_CurGameTick = pInfo->m_Info.m_CurrentTick;\n\t\t\tm_PrevGameTick = pInfo->m_PreviousTick;\n\t\t\tm_GameIntraTick = pInfo->m_IntraTick;\n\t\t\tm_GameTickTime = pInfo->m_TickTime;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// disconnect on error\n\t\t\tDisconnect();\n\t\t}\n\t}\n\telse if(State() == IClient::STATE_ONLINE && m_RecivedSnapshots >= 3)\n\t{\n\t\t// switch snapshot\n\t\tint Repredict = 0;\n\t\tint64 Freq = time_freq();\n\t\tint64 Now = m_GameTime.Get(time_get());\n\t\tint64 PredNow = m_PredictedTime.Get(time_get());\n\n\t\twhile(1)\n\t\t{\n\t\t\tCSnapshotStorage::CHolder *pCur = m_aSnapshots[SNAP_CURRENT];\n\t\t\tint64 TickStart = (pCur->m_Tick)*time_freq()/50;\n\n\t\t\tif(TickStart < Now)\n\t\t\t{\n\t\t\t\tCSnapshotStorage::CHolder *pNext = m_aSnapshots[SNAP_CURRENT]->m_pNext;\n\t\t\t\tif(pNext)\n\t\t\t\t{\n\t\t\t\t\tm_aSnapshots[SNAP_PREV] = m_aSnapshots[SNAP_CURRENT];\n\t\t\t\t\tm_aSnapshots[SNAP_CURRENT] = pNext;\n\n\t\t\t\t\t// set ticks\n\t\t\t\t\tm_CurGameTick = m_aSnapshots[SNAP_CURRENT]->m_Tick;\n\t\t\t\t\tm_PrevGameTick = m_aSnapshots[SNAP_PREV]->m_Tick;\n\n\t\t\t\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_PREV])\n\t\t\t\t\t{\n\t\t\t\t\t\tGameClient()->OnNewSnapshot();\n\t\t\t\t\t\tRepredict = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_PREV])\n\t\t{\n\t\t\tint64 CurtickStart = (m_aSnapshots[SNAP_CURRENT]->m_Tick)*time_freq()/50;\n\t\t\tint64 PrevtickStart = (m_aSnapshots[SNAP_PREV]->m_Tick)*time_freq()/50;\n\t\t\tint PrevPredTick = (int)(PredNow*50/time_freq());\n\t\t\tint NewPredTick = PrevPredTick+1;\n\n\t\t\tm_GameIntraTick = (Now - PrevtickStart) / (float)(CurtickStart-PrevtickStart);\n\t\t\tm_GameTickTime = (Now - PrevtickStart) / (float)Freq; //(float)SERVER_TICK_SPEED);\n\n\t\t\tCurtickStart = NewPredTick*time_freq()/50;\n\t\t\tPrevtickStart = PrevPredTick*time_freq()/50;\n\t\t\tm_PredIntraTick = (PredNow - PrevtickStart) / (float)(CurtickStart-PrevtickStart);\n\n\t\t\tif(NewPredTick < m_aSnapshots[SNAP_PREV]->m_Tick-SERVER_TICK_SPEED || NewPredTick > m_aSnapshots[SNAP_PREV]->m_Tick+SERVER_TICK_SPEED)\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client\", \"prediction time reset!\");\n\t\t\t\tm_PredictedTime.Init(m_aSnapshots[SNAP_CURRENT]->m_Tick*time_freq()/50);\n\t\t\t}\n\n\t\t\tif(NewPredTick > m_PredTick)\n\t\t\t{\n\t\t\t\tm_PredTick = NewPredTick;\n\t\t\t\tRepredict = 1;\n\n\t\t\t\t// send input\n\t\t\t\tSendInput();\n\t\t\t}\n\t\t}\n\n\t\t// only do sane predictions\n\t\tif(Repredict)\n\t\t{\n\t\t\tif(m_PredTick > m_CurGameTick && m_PredTick < m_CurGameTick+50)\n\t\t\t\tGameClient()->OnPredict();\n\t\t}\n\n\t\t// fetch server info if we don't have it\n\t\tif(State() >= IClient::STATE_LOADING &&\n\t\t\tm_CurrentServerInfoRequestTime >= 0 &&\n\t\t\ttime_get() > m_CurrentServerInfoRequestTime)\n\t\t{\n\t\t\tm_ServerBrowser.Request(m_ServerAddress);\n\t\t\tm_CurrentServerInfoRequestTime = time_get()+time_freq()*2;\n\t\t}\n\t}\n\n\t// STRESS TEST: join the server again\n\tif(g_Config.m_DbgStress)\n\t{\n\t\tstatic int64 ActionTaken = 0;\n\t\tint64 Now = time_get();\n\t\tif(State() == IClient::STATE_OFFLINE)\n\t\t{\n\t\t\tif(Now > ActionTaken+time_freq()*2)\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"stress\", \"reconnecting!\");\n\t\t\t\tConnect(g_Config.m_DbgStressServer);\n\t\t\t\tActionTaken = Now;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Now > ActionTaken+time_freq()*(10+g_Config.m_DbgStress))\n\t\t\t{\n\t\t\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"stress\", \"disconnecting!\");\n\t\t\t\tDisconnect();\n\t\t\t\tActionTaken = Now;\n\t\t\t}\n\t\t}\n\t}\n\n\t// pump the network\n\tPumpNetwork();\n\n\t// update the maser server registry\n\tMasterServer()->Update();\n\n\t// update the server browser\n\tm_ServerBrowser.Update(m_ResortServerBrowser);\n\tm_ResortServerBrowser = false;\n}\n\nvoid CClient::VersionUpdate()\n{\n\tif(m_VersionInfo.m_State == CVersionInfo::STATE_INIT)\n\t{\n\t\tEngine()->HostLookup(&m_VersionInfo.m_VersionServeraddr, g_Config.m_ClVersionServer, m_ContactClient.NetType());\n\t\tm_VersionInfo.m_State = CVersionInfo::STATE_START;\n\t}\n\telse if(m_VersionInfo.m_State == CVersionInfo::STATE_START)\n\t{\n\t\tif(m_VersionInfo.m_VersionServeraddr.m_Job.Status() == CJob::STATE_DONE)\n\t\t{\n\t\t\tCNetChunk Packet;\n\n\t\t\tmem_zero(&Packet, sizeof(Packet));\n\n\t\t\tm_VersionInfo.m_VersionServeraddr.m_Addr.port = VERSIONSRV_PORT;\n\n\t\t\tPacket.m_ClientID = -1;\n\t\t\tPacket.m_Address = m_VersionInfo.m_VersionServeraddr.m_Addr;\n\t\t\tPacket.m_pData = VERSIONSRV_GETVERSION;\n\t\t\tPacket.m_DataSize = sizeof(VERSIONSRV_GETVERSION);\n\t\t\tPacket.m_Flags = NETSENDFLAG_CONNLESS;\n\n\t\t\tm_ContactClient.Send(&Packet);\n\t\t\tm_VersionInfo.m_State = CVersionInfo::STATE_READY;\n\t\t}\n\t}\n}\n\nvoid CClient::RegisterInterfaces()\n{\n\tKernel()->RegisterInterface(static_cast<IDemoRecorder*>(&m_DemoRecorder));\n\tKernel()->RegisterInterface(static_cast<IDemoPlayer*>(&m_DemoPlayer));\n\tKernel()->RegisterInterface(static_cast<IServerBrowser*>(&m_ServerBrowser));\n\tKernel()->RegisterInterface(static_cast<IFriends*>(&m_Friends));\n}\n\nvoid CClient::InitInterfaces()\n{\n\t// fetch interfaces\n\tm_pEngine = Kernel()->RequestInterface<IEngine>();\n\tm_pEditor = Kernel()->RequestInterface<IEditor>();\n\t//m_pGraphics = Kernel()->RequestInterface<IEngineGraphics>();\n\tm_pSound = Kernel()->RequestInterface<IEngineSound>();\n\tm_pGameClient = Kernel()->RequestInterface<IGameClient>();\n\tm_pInput = Kernel()->RequestInterface<IEngineInput>();\n\tm_pMap = Kernel()->RequestInterface<IEngineMap>();\n\tm_pMasterServer = Kernel()->RequestInterface<IEngineMasterServer>();\n\tm_pStorage = Kernel()->RequestInterface<IStorage>();\n\n\t//\n\tm_ServerBrowser.SetBaseInfo(&m_ContactClient, m_pGameClient->NetVersion());\n\tm_Friends.Init();\n}\n\nvoid CClient::Run()\n{\n\tm_LocalStartTime = time_get();\n\tm_SnapshotParts = 0;\n\n\t// init SDL\n\t{\n\t\tif(SDL_Init(0) < 0)\n\t\t{\n\t\t\tdbg_msg(\"client\", \"unable to init SDL base: %s\", SDL_GetError());\n\t\t\treturn;\n\t\t}\n\n\t\tatexit(SDL_Quit); // ignore_convention\n\t}\n\n\t// init graphics\n\t{\n\t\tif(g_Config.m_GfxThreaded)\n\t\t\tm_pGraphics = CreateEngineGraphicsThreaded();\n\t\telse\n\t\t\tm_pGraphics = CreateEngineGraphics();\n\n\t\tbool RegisterFail = false;\n\t\tRegisterFail = RegisterFail || !Kernel()->RegisterInterface(static_cast<IEngineGraphics*>(m_pGraphics)); // register graphics as both\n\t\tRegisterFail = RegisterFail || !Kernel()->RegisterInterface(static_cast<IGraphics*>(m_pGraphics));\n\n\t\tif(RegisterFail || m_pGraphics->Init() != 0)\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't init graphics\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// init sound, allowed to fail\n\tm_SoundInitFailed = Sound()->Init() != 0;\n\n\t// open socket\n\t{\n\t\tNETADDR BindAddr;\n\t\tif(g_Config.m_Bindaddr[0] && net_host_lookup(g_Config.m_Bindaddr, &BindAddr, NETTYPE_ALL) == 0)\n\t\t{\n\t\t\t// got bindaddr\n\t\t\tBindAddr.type = NETTYPE_ALL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmem_zero(&BindAddr, sizeof(BindAddr));\n\t\t\tBindAddr.type = NETTYPE_ALL;\n\t\t}\n\t\tif(!m_NetClient.Open(BindAddr, BindAddr.port ? 0 : NETCREATE_FLAG_RANDOMPORT))\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't open socket(net)\");\n\t\t\treturn;\n\t\t}\n\t\tBindAddr.port = 0;\n\t\tif(!m_ContactClient.Open(BindAddr, 0))\n\t\t{\n\t\t\tdbg_msg(\"client\", \"couldn't open socket(contact)\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// init font rendering\n\tKernel()->RequestInterface<IEngineTextRender>()->Init();\n\n\t// init the input\n\tInput()->Init();\n\n\t// start refreshing addresses while we load\n\tMasterServer()->RefreshAddresses(m_ContactClient.NetType());\n\n\t// init the editor\n\tm_pEditor->Init();\n\n\n\t// load data\n\tif(!LoadData())\n\t\treturn;\n\n\tGameClient()->OnInit();\n\n\tchar aBuf[256];\n\tstr_format(aBuf, sizeof(aBuf), \"version %s\", GameClient()->NetVersion());\n\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"client\", aBuf);\n\n\t// connect to the server if wanted\n\t/*\n\tif(config.cl_connect[0] != 0)\n\t\tConnect(config.cl_connect);\n\tconfig.cl_connect[0] = 0;\n\t*/\n\n\t//\n\tm_FpsGraph.Init(0.0f, 200.0f);\n\n\t// never start with the editor\n\tg_Config.m_ClEditor = 0;\n\n\tInput()->MouseModeRelative();\n\n\t// process pending commands\n\tm_pConsole->StoreCommands(false);\n\n\twhile (1)\n\t{\n\t\t//\n\t\tVersionUpdate();\n\n\t\t// handle pending connects\n\t\tif(m_aCmdConnect[0])\n\t\t{\n\t\t\tstr_copy(g_Config.m_UiServerAddress, m_aCmdConnect, sizeof(g_Config.m_UiServerAddress));\n\t\t\tConnect(m_aCmdConnect);\n\t\t\tm_aCmdConnect[0] = 0;\n\t\t}\n\n\t\t// update input\n\t\tif(Input()->Update())\n\t\t\tbreak;\t// SDL_QUIT\n\n\t\t// update sound\n\t\tSound()->Update();\n\n\t\t// release focus\n\t\tif(!m_pGraphics->WindowActive())\n\t\t{\n\t\t\tif(m_WindowMustRefocus == 0)\n\t\t\t\tInput()->MouseModeAbsolute();\n\t\t\tm_WindowMustRefocus = 1;\n\t\t}\n\t\telse if (g_Config.m_DbgFocus && Input()->KeyPressed(KEY_ESCAPE))\n\t\t{\n\t\t\tInput()->MouseModeAbsolute();\n\t\t\tm_WindowMustRefocus = 1;\n\t\t}\n\n\t\t// refocus\n\t\tif(m_WindowMustRefocus && m_pGraphics->WindowActive())\n\t\t{\n\t\t\tif(m_WindowMustRefocus < 3)\n\t\t\t{\n\t\t\t\tInput()->MouseModeAbsolute();\n\t\t\t\tm_WindowMustRefocus++;\n\t\t\t}\n\n\t\t\tif(m_WindowMustRefocus >= 3 || Input()->KeyPressed(KEY_MOUSE_1))\n\t\t\t{\n\t\t\t\tInput()->MouseModeRelative();\n\t\t\t\tm_WindowMustRefocus = 0;\n\t\t\t}\n\t\t}\n\n\t\t// panic quit button\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyPressed('q'))\n\t\t{\n\t\t\tQuit();\n\t\t\tbreak;\n\t\t}\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('d'))\n\t\t\tg_Config.m_Debug ^= 1;\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('g'))\n\t\t\tg_Config.m_DbgGraphs ^= 1;\n\n\t\tif(Input()->KeyPressed(KEY_LCTRL) && Input()->KeyPressed(KEY_LSHIFT) && Input()->KeyDown('e'))\n\t\t{\n\t\t\tg_Config.m_ClEditor = g_Config.m_ClEditor^1;\n\t\t\tInput()->MouseModeRelative();\n\t\t}\n\n\t\t/*\n\t\tif(!gfx_window_open())\n\t\t\tbreak;\n\t\t*/\n\n\t\t// render\n\t\t{\n\t\t\tif(g_Config.m_ClEditor)\n\t\t\t{\n\t\t\t\tif(!m_EditorActive)\n\t\t\t\t{\n\t\t\t\t\tGameClient()->OnActivateEditor();\n\t\t\t\t\tm_EditorActive = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(m_EditorActive)\n\t\t\t\tm_EditorActive = false;\n\n\t\t\tUpdate();\n\n\t\t\tif(!g_Config.m_GfxAsyncRender || m_pGraphics->IsIdle())\n\t\t\t{\n\t\t\t\tm_RenderFrames++;\n\n\t\t\t\t// update frametime\n\t\t\t\tint64 Now = time_get();\n\t\t\t\tm_RenderFrameTime = (Now - m_LastRenderTime) / (float)time_freq();\n\t\t\t\tif(m_RenderFrameTime < m_RenderFrameTimeLow)\n\t\t\t\t\tm_RenderFrameTimeLow = m_RenderFrameTime;\n\t\t\t\tif(m_RenderFrameTime > m_RenderFrameTimeHigh)\n\t\t\t\t\tm_RenderFrameTimeHigh = m_RenderFrameTime;\n\t\t\t\tm_FpsGraph.Add(1.0f/m_RenderFrameTime, 1,1,1);\n\n\t\t\t\tm_LastRenderTime = Now;\n\n\t\t\t\tif(g_Config.m_DbgStress)\n\t\t\t\t{\n\t\t\t\t\tif((m_RenderFrames%10) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!m_EditorActive)\n\t\t\t\t\t\t\tRender();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_pEditor->UpdateAndRender();\n\t\t\t\t\t\t\tDebugRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm_pGraphics->Swap();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(!m_EditorActive)\n\t\t\t\t\t\tRender();\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pEditor->UpdateAndRender();\n\t\t\t\t\t\tDebugRender();\n\t\t\t\t\t}\n\t\t\t\t\tm_pGraphics->Swap();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAutoScreenshot_Cleanup();\n\n\t\t// check conditions\n\t\tif(State() == IClient::STATE_QUITING)\n\t\t\tbreak;\n\n\t\t// beNice\n\t\tif(g_Config.m_ClCpuThrottle)\n\t\t\tthread_sleep(g_Config.m_ClCpuThrottle);\n\t\telse if(g_Config.m_DbgStress || !m_pGraphics->WindowActive())\n\t\t\tthread_sleep(5);\n\n\t\tif(g_Config.m_DbgHitch)\n\t\t{\n\t\t\tthread_sleep(g_Config.m_DbgHitch);\n\t\t\tg_Config.m_DbgHitch = 0;\n\t\t}\n\n\t\t/*\n\t\tif(ReportTime < time_get())\n\t\t{\n\t\t\tif(0 && g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tdbg_msg(\"client/report\", \"fps=%.02f (%.02f %.02f) netstate=%d\",\n\t\t\t\t\tm_Frames/(float)(ReportInterval/time_freq()),\n\t\t\t\t\t1.0f/m_RenderFrameTimeHigh,\n\t\t\t\t\t1.0f/m_RenderFrameTimeLow,\n\t\t\t\t\tm_NetClient.State());\n\t\t\t}\n\t\t\tm_RenderFrameTimeLow = 1;\n\t\t\tm_RenderFrameTimeHigh = 0;\n\t\t\tm_RenderFrames = 0;\n\t\t\tReportTime += ReportInterval;\n\t\t}*/\n\n\t\t// update local time\n\t\tm_LocalTime = (time_get()-m_LocalStartTime)/(float)time_freq();\n\t}\n\n\tGameClient()->OnShutdown();\n\tDisconnect();\n\n\tm_pGraphics->Shutdown();\n\tm_pSound->Shutdown();\n\n\t// shutdown SDL\n\t{\n\t\tSDL_Quit();\n\t}\n}\n\n\nvoid CClient::Con_Connect(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tstr_copy(pSelf->m_aCmdConnect, pResult->GetString(0), sizeof(pSelf->m_aCmdConnect));\n}\n\nvoid CClient::Con_Disconnect(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Disconnect();\n}\n\nvoid CClient::Con_Quit(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Quit();\n}\n\nvoid CClient::Con_Minimize(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Graphics()->Minimize();\n}\n\nvoid CClient::Con_Ping(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\n\tCMsgPacker Msg(NETMSG_PING);\n\tpSelf->SendMsgEx(&Msg, 0);\n\tpSelf->m_PingStartTime = time_get();\n}\n\nvoid CClient::AutoScreenshot_Start()\n{\n\tif(g_Config.m_ClAutoScreenshot)\n\t{\n\t\tGraphics()->TakeScreenshot(\"auto/autoscreen\");\n\t\tm_AutoScreenshotRecycle = true;\n\t}\n}\n\nvoid CClient::AutoScreenshot_Cleanup()\n{\n\tif(m_AutoScreenshotRecycle)\n\t{\n\t\tif(g_Config.m_ClAutoScreenshotMax)\n\t\t{\n\t\t\t// clean up auto taken screens\n\t\t\tCFileCollection AutoScreens;\n\t\t\tAutoScreens.Init(Storage(), \"screenshots/auto\", \"autoscreen\", \".png\", g_Config.m_ClAutoScreenshotMax);\n\t\t}\n\t\tm_AutoScreenshotRecycle = false;\n\t}\n}\n\nvoid CClient::Con_Screenshot(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Graphics()->TakeScreenshot(0);\n}\n\nvoid CClient::Con_Rcon(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->Rcon(pResult->GetString(0));\n}\n\nvoid CClient::Con_RconAuth(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->RconAuth(\"\", pResult->GetString(0));\n}\n\nvoid CClient::Con_AddFavorite(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tNETADDR Addr;\n\tif(net_addr_from_str(&Addr, pResult->GetString(0)) == 0)\n\t\tpSelf->m_ServerBrowser.AddFavorite(Addr);\n}\n\nvoid CClient::Con_RemoveFavorite(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tNETADDR Addr;\n\tif(net_addr_from_str(&Addr, pResult->GetString(0)) == 0)\n\t\tpSelf->m_ServerBrowser.RemoveFavorite(Addr);\n}\n\nconst char *CClient::DemoPlayer_Play(const char *pFilename, int StorageType)\n{\n\tint Crc;\n\tconst char *pError;\n\tDisconnect();\n\tm_NetClient.ResetErrorString();\n\n\t// try to start playback\n\tm_DemoPlayer.SetListner(this);\n\n\tif(m_DemoPlayer.Load(Storage(), m_pConsole, pFilename, StorageType))\n\t\treturn \"error loading demo\";\n\n\t// load map\n\tCrc = (m_DemoPlayer.Info()->m_Header.m_aMapCrc[0]<<24)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[1]<<16)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[2]<<8)|\n\t\t(m_DemoPlayer.Info()->m_Header.m_aMapCrc[3]);\n\tpError = LoadMapSearch(m_DemoPlayer.Info()->m_Header.m_aMapName, Crc);\n\tif(pError)\n\t{\n\t\tDisconnectWithReason(pError);\n\t\treturn pError;\n\t}\n\n\tGameClient()->OnConnected();\n\n\t// setup buffers\n\tmem_zero(m_aDemorecSnapshotData, sizeof(m_aDemorecSnapshotData));\n\n\tm_aSnapshots[SNAP_CURRENT] = &m_aDemorecSnapshotHolders[SNAP_CURRENT];\n\tm_aSnapshots[SNAP_PREV] = &m_aDemorecSnapshotHolders[SNAP_PREV];\n\n\tm_aSnapshots[SNAP_CURRENT]->m_pSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_CURRENT][0];\n\tm_aSnapshots[SNAP_CURRENT]->m_pAltSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_CURRENT][1];\n\tm_aSnapshots[SNAP_CURRENT]->m_SnapSize = 0;\n\tm_aSnapshots[SNAP_CURRENT]->m_Tick = -1;\n\n\tm_aSnapshots[SNAP_PREV]->m_pSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_PREV][0];\n\tm_aSnapshots[SNAP_PREV]->m_pAltSnap = (CSnapshot *)m_aDemorecSnapshotData[SNAP_PREV][1];\n\tm_aSnapshots[SNAP_PREV]->m_SnapSize = 0;\n\tm_aSnapshots[SNAP_PREV]->m_Tick = -1;\n\n\t// enter demo playback state\n\tSetState(IClient::STATE_DEMOPLAYBACK);\n\n\tm_DemoPlayer.Play();\n\tGameClient()->OnEnterGame();\n\n\treturn 0;\n}\n\nvoid CClient::Con_Play(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoPlayer_Play(pResult->GetString(0), IStorage::TYPE_ALL);\n}\n\nvoid CClient::DemoRecorder_Start(const char *pFilename, bool WithTimestamp)\n{\n\tif(State() != IClient::STATE_ONLINE)\n\t\tm_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"demorec/record\", \"client is not online\");\n\telse\n\t{\n\t\tchar aFilename[128];\n\t\tif(WithTimestamp)\n\t\t{\n\t\t\tchar aDate[20];\n\t\t\tstr_timestamp(aDate, sizeof(aDate));\n\t\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s_%s.demo\", pFilename, aDate);\n\t\t}\n\t\telse\n\t\t\tstr_format(aFilename, sizeof(aFilename), \"demos/%s.demo\", pFilename);\n\t\tm_DemoRecorder.Start(Storage(), m_pConsole, aFilename, GameClient()->NetVersion(), m_aCurrentMap, m_CurrentMapCrc, \"client\");\n\t}\n}\n\nvoid CClient::DemoRecorder_HandleAutoStart()\n{\n\tif(g_Config.m_ClAutoDemoRecord)\n\t{\n\t\tDemoRecorder_Stop();\n\t\tDemoRecorder_Start(\"auto/autorecord\", true);\n\t\tif(g_Config.m_ClAutoDemoMax)\n\t\t{\n\t\t\t// clean up auto recorded demos\n\t\t\tCFileCollection AutoDemos;\n\t\t\tAutoDemos.Init(Storage(), \"demos/auto\", \"autorecord\", \".demo\", g_Config.m_ClAutoDemoMax);\n\t\t}\n\t}\n}\n\nvoid CClient::DemoRecorder_Stop()\n{\n\tm_DemoRecorder.Stop();\n}\n\nvoid CClient::DemoRecorder_AddDemoMarker()\n{\n\tm_DemoRecorder.AddDemoMarker();\n}\n\nvoid CClient::Con_Record(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tif(pResult->NumArguments())\n\t\tpSelf->DemoRecorder_Start(pResult->GetString(0), false);\n\telse\n\t\tpSelf->DemoRecorder_Start(\"demo\", true);\n}\n\nvoid CClient::Con_StopRecord(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoRecorder_Stop();\n}\n\nvoid CClient::Con_AddDemoMarker(IConsole::IResult *pResult, void *pUserData)\n{\n\tCClient *pSelf = (CClient *)pUserData;\n\tpSelf->DemoRecorder_AddDemoMarker();\n}\n\nvoid CClient::ServerBrowserUpdate()\n{\n\tm_ResortServerBrowser = true;\n}\n\nvoid CClient::ConchainServerBrowserUpdate(IConsole::IResult *pResult, void *pUserData, IConsole::FCommandCallback pfnCallback, void *pCallbackUserData)\n{\n\tpfnCallback(pResult, pCallbackUserData);\n\tif(pResult->NumArguments())\n\t\t((CClient *)pUserData)->ServerBrowserUpdate();\n}\n\nvoid CClient::RegisterCommands()\n{\n\tm_pConsole = Kernel()->RequestInterface<IConsole>();\n\t// register server dummy commands for tab completion\n\tm_pConsole->Register(\"kick\", \"i?r\", CFGFLAG_SERVER, 0, 0, \"Kick player with specified id for any reason\");\n\tm_pConsole->Register(\"ban\", \"s?ir\", CFGFLAG_SERVER, 0, 0, \"Ban player with ip/id for x minutes for any reason\");\n\tm_pConsole->Register(\"unban\", \"s\", CFGFLAG_SERVER, 0, 0, \"Unban ip\");\n\tm_pConsole->Register(\"bans\", \"\", CFGFLAG_SERVER, 0, 0, \"Show banlist\");\n\tm_pConsole->Register(\"status\", \"\", CFGFLAG_SERVER, 0, 0, \"List players\");\n\tm_pConsole->Register(\"shutdown\", \"\", CFGFLAG_SERVER, 0, 0, \"Shut down\");\n\tm_pConsole->Register(\"record\", \"?s\", CFGFLAG_SERVER, 0, 0, \"Record to a file\");\n\tm_pConsole->Register(\"stoprecord\", \"\", CFGFLAG_SERVER, 0, 0, \"Stop recording\");\n\tm_pConsole->Register(\"reload\", \"\", CFGFLAG_SERVER, 0, 0, \"Reload the map\");\n\n\tm_pConsole->Register(\"quit\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Quit, this, \"Quit Teeworlds\");\n\tm_pConsole->Register(\"exit\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Quit, this, \"Quit Teeworlds\");\n\tm_pConsole->Register(\"minimize\", \"\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Minimize, this, \"Minimize Teeworlds\");\n\tm_pConsole->Register(\"connect\", \"s\", CFGFLAG_CLIENT, Con_Connect, this, \"Connect to the specified host/ip\");\n\tm_pConsole->Register(\"disconnect\", \"\", CFGFLAG_CLIENT, Con_Disconnect, this, \"Disconnect from the server\");\n\tm_pConsole->Register(\"ping\", \"\", CFGFLAG_CLIENT, Con_Ping, this, \"Ping the current server\");\n\tm_pConsole->Register(\"screenshot\", \"\", CFGFLAG_CLIENT, Con_Screenshot, this, \"Take a screenshot\");\n\tm_pConsole->Register(\"rcon\", \"r\", CFGFLAG_CLIENT, Con_Rcon, this, \"Send specified command to rcon\");\n\tm_pConsole->Register(\"rcon_auth\", \"s\", CFGFLAG_CLIENT, Con_RconAuth, this, \"Authenticate to rcon\");\n\tm_pConsole->Register(\"play\", \"r\", CFGFLAG_CLIENT|CFGFLAG_STORE, Con_Play, this, \"Play the file specified\");\n\tm_pConsole->Register(\"record\", \"?s\", CFGFLAG_CLIENT, Con_Record, this, \"Record to the file\");\n\tm_pConsole->Register(\"stoprecord\", \"\", CFGFLAG_CLIENT, Con_StopRecord, this, \"Stop recording\");\n\tm_pConsole->Register(\"add_demomarker\", \"\", CFGFLAG_CLIENT, Con_AddDemoMarker, this, \"Add demo timeline marker\");\n\tm_pConsole->Register(\"add_favorite\", \"s\", CFGFLAG_CLIENT, Con_AddFavorite, this, \"Add a server as a favorite\");\n\tm_pConsole->Register(\"remove_favorite\", \"s\", CFGFLAG_CLIENT, Con_RemoveFavorite, this, \"Remove a server from favorites\");\n\n\t// used for server browser update\n\tm_pConsole->Chain(\"br_filter_string\", ConchainServerBrowserUpdate, this);\n\tm_pConsole->Chain(\"br_filter_gametype\", ConchainServerBrowserUpdate, this);\n\tm_pConsole->Chain(\"br_filter_serveraddress\", ConchainServerBrowserUpdate, this);\n}\n\nstatic CClient *CreateClient()\n{\n\tCClient *pClient = static_cast<CClient *>(mem_alloc(sizeof(CClient), 1));\n\tmem_zero(pClient, sizeof(CClient));\n\treturn new(pClient) CClient;\n}\n\n/*\n\tServer Time\n\tClient Mirror Time\n\tClient Predicted Time\n\n\tSnapshot Latency\n\t\tDownstream latency\n\n\tPrediction Latency\n\t\tUpstream latency\n*/\n\n#if defined(CONF_PLATFORM_MACOSX)\nextern \"C\" int SDL_main(int argc, char **argv_) // ignore_convention\n{\n\tconst char **argv = const_cast<const char **>(argv_);\n#else\nint main(int argc, const char **argv) // ignore_convention\n{\n#endif\n#if defined(CONF_FAMILY_WINDOWS)\n\tfor(int i = 1; i < argc; i++) // ignore_convention\n\t{\n\t\tif(str_comp(\"-s\", argv[i]) == 0 || str_comp(\"--silent\", argv[i]) == 0) // ignore_convention\n\t\t{\n\t\t\tFreeConsole();\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\n\tCClient *pClient = CreateClient();\n\tIKernel *pKernel = IKernel::Create();\n\tpKernel->RegisterInterface(pClient);\n\tpClient->RegisterInterfaces();\n\n\t// create the components\n\tIEngine *pEngine = CreateEngine(\"Teeworlds\");\n\tIConsole *pConsole = CreateConsole(CFGFLAG_CLIENT);\n\tIStorage *pStorage = CreateStorage(\"Teeworlds\", IStorage::STORAGETYPE_CLIENT, argc, argv); // ignore_convention\n\tIConfig *pConfig = CreateConfig();\n\tIEngineSound *pEngineSound = CreateEngineSound();\n\tIEngineInput *pEngineInput = CreateEngineInput();\n\tIEngineTextRender *pEngineTextRender = CreateEngineTextRender();\n\tIEngineMap *pEngineMap = CreateEngineMap();\n\tIEngineMasterServer *pEngineMasterServer = CreateEngineMasterServer();\n\n\t{\n\t\tbool RegisterFail = false;\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pEngine);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConsole);\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pConfig);\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineSound*>(pEngineSound)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<ISound*>(pEngineSound));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineInput*>(pEngineInput)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IInput*>(pEngineInput));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineTextRender*>(pEngineTextRender)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<ITextRender*>(pEngineTextRender));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMap*>(pEngineMap)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMap*>(pEngineMap));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IEngineMasterServer*>(pEngineMasterServer)); // register as both\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(static_cast<IMasterServer*>(pEngineMasterServer));\n\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(CreateEditor());\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(CreateGameClient());\n\t\tRegisterFail = RegisterFail || !pKernel->RegisterInterface(pStorage);\n\n\t\tif(RegisterFail)\n\t\t\treturn -1;\n\t}\n\n\tpEngine->Init();\n\tpConfig->Init();\n\tpEngineMasterServer->Init();\n\tpEngineMasterServer->Load();\n\n\t// register all console commands\n\tpClient->RegisterCommands();\n\n\tpKernel->RequestInterface<IGameClient>()->OnConsoleInit();\n\n\t// init client's interfaces\n\tpClient->InitInterfaces();\n\n\t// execute config file\n\tpConsole->ExecuteFile(\"settings.cfg\");\n\n\t// execute autoexec file\n\tpConsole->ExecuteFile(\"autoexec.cfg\");\n\n\t// parse the command line arguments\n\tif(argc > 1) // ignore_convention\n\t\tpConsole->ParseArguments(argc-1, &argv[1]); // ignore_convention\n\n\t// restore empty config strings to their defaults\n\tpConfig->RestoreStrings();\n\n\tpClient->Engine()->InitLogfile();\n\n\t// run the client\n\tdbg_msg(\"client\", \"starting...\");\n\tpClient->Run();\n\n\t// write down the config and quit\n\tpConfig->Save();\n\n\treturn 0;\n}\n", "/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n#ifndef ENGINE_SHARED_SNAPSHOT_H\n#define ENGINE_SHARED_SNAPSHOT_H\n\n#include <base/system.h>\n\n// CSnapshot\n\nclass CSnapshotItem\n{\npublic:\n\tint m_TypeAndID;\n\n\tint *Data() { return (int *)(this+1); }\n\tint Type() { return m_TypeAndID>>16; }\n\tint ID() { return m_TypeAndID&0xffff; }\n\tint Key() { return m_TypeAndID; }\n};\n\n\nclass CSnapshot\n{\n\tfriend class CSnapshotBuilder;\n\tint m_DataSize;\n\tint m_NumItems;\n\n\tint *Offsets() const { return (int *)(this+1); }\n\tchar *DataStart() const { return (char*)(Offsets()+m_NumItems); }\n\npublic:\n\tenum\n\t{\n\t\tMAX_PARTS\t= 64,\n\t\tMAX_SIZE\t= MAX_PARTS*1024\n\t};\n\n\tvoid Clear() { m_DataSize = 0; m_NumItems = 0; }\n\tint NumItems() const { return m_NumItems; }\n\tCSnapshotItem *GetItem(int Index);\n\tint GetItemSize(int Index);\n\tint GetItemIndex(int Key);\n\n\tint Crc();\n\tvoid DebugDump();\n};\n\n\n// CSnapshotDelta\n\nclass CSnapshotDelta\n{\npublic:\n\tclass CData\n\t{\n\tpublic:\n\t\tint m_NumDeletedItems;\n\t\tint m_NumUpdateItems;\n\t\tint m_NumTempItems; // needed?\n\t\tint m_pData[1];\n\t};\n\nprivate:\n\t// TODO: strange arbitrary number\n\tshort m_aItemSizes[64];\n\tint m_aSnapshotDataRate[0xffff];\n\tint m_aSnapshotDataUpdates[0xffff];\n\tint m_SnapshotCurrent;\n\tCData m_Empty;\n\n\tvoid UndiffItem(int *pPast, int *pDiff, int *pOut, int Size);\n\npublic:\n\tCSnapshotDelta();\n\tint GetDataRate(int Index) { return m_aSnapshotDataRate[Index]; }\n\tint GetDataUpdates(int Index) { return m_aSnapshotDataUpdates[Index]; }\n\tvoid SetStaticsize(int ItemType, int Size);\n\tCData *EmptyDelta();\n\tint CreateDelta(class CSnapshot *pFrom, class CSnapshot *pTo, void *pData);\n\tint UnpackDelta(class CSnapshot *pFrom, class CSnapshot *pTo, void *pData, int DataSize);\n};\n\n\n// CSnapshotStorage\n\nclass CSnapshotStorage\n{\npublic:\n\tclass CHolder\n\t{\n\tpublic:\n\t\tCHolder *m_pPrev;\n\t\tCHolder *m_pNext;\n\n\t\tint64 m_Tagtime;\n\t\tint m_Tick;\n\n\t\tint m_SnapSize;\n\t\tCSnapshot *m_pSnap;\n\t\tCSnapshot *m_pAltSnap;\n\t};\n\n\n\tCHolder *m_pFirst;\n\tCHolder *m_pLast;\n\n\tvoid Init();\n\tvoid PurgeAll();\n\tvoid PurgeUntil(int Tick);\n\tvoid Add(int Tick, int64 Tagtime, int DataSize, void *pData, int CreateAlt);\n\tint Get(int Tick, int64 *pTagtime, CSnapshot **ppData, CSnapshot **ppAltData);\n};\n\nclass CSnapshotBuilder\n{\n\tenum\n\t{\n\t\tMAX_ITEMS = 1024\n\t};\n\n\tchar m_aData[CSnapshot::MAX_SIZE];\n\tint m_DataSize;\n\n\tint m_aOffsets[MAX_ITEMS];\n\tint m_NumItems;\n\npublic:\n\tvoid Init();\n\n\tvoid *NewItem(int Type, int ID, int Size);\n\n\tCSnapshotItem *GetItem(int Index);\n\tint *GetItemData(int Key);\n\n\tint Finish(void *pSnapdata);\n};\n\n\n#endif // ENGINE_SNAPSHOT_H\n"], "filenames": ["src/engine/client/client.cpp", "src/engine/shared/snapshot.h"], "buggy_code_start_loc": [1242, 34], "buggy_code_end_loc": [1243, 35], "fixing_code_start_loc": [1242, 34], "fixing_code_end_loc": [1243, 36], "type": "CWE-119", "message": "The CClient::ProcessServerPacket method in engine/client/client.cpp in Teeworlds before 0.6.4 allows remote servers to write to arbitrary physical memory locations and possibly execute arbitrary code via vectors involving snap handling.", "other": {"cve": {"id": "CVE-2016-9400", "sourceIdentifier": "security@debian.org", "published": "2017-02-22T16:59:00.347", "lastModified": "2020-06-11T15:22:57.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The CClient::ProcessServerPacket method in engine/client/client.cpp in Teeworlds before 0.6.4 allows remote servers to write to arbitrary physical memory locations and possibly execute arbitrary code via vectors involving snap handling."}, {"lang": "es", "value": "El m\u00e9todo CClient::ProcessServerPacket en engine/client/client.cpp en Teeworlds en versiones anteriores a 0.6.4 permite a servidores remotos escribir en ubicaciones de memoria f\u00edsica arbitrarias y posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de vectores que involucran manipulaci\u00f3n r\u00e1pida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teeworlds:teeworlds:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.4", "matchCriteriaId": "3B5CAEFC-09C5-47D5-B3B0-2006F7F785F0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/16/8", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/17/8", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94381", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/teeworlds/teeworlds/commit/ff254722a2683867fcb3e67569ffd36226c4bc62", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C4JNSBXXPE7O32ZMFK7D7YL6EKLG7PRV/", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201705-13", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.teeworlds.com/?page=news&id=12086", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/teeworlds/teeworlds/commit/ff254722a2683867fcb3e67569ffd36226c4bc62"}}