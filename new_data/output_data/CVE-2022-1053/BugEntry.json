{"buggy_code": ["#!/usr/bin/python3\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\nimport signal\nimport traceback\nimport sys\nimport functools\nimport asyncio\nimport os\nfrom multiprocessing import Process\n\n\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime import config\nfrom keylime import json\nfrom keylime import registrar_client\nfrom keylime.agentstates import AgentAttestStates\nfrom keylime.common import states, validators, retry\nfrom keylime.db.verifier_db import VerfierMain\nfrom keylime.db.verifier_db import VerifierAllowlist\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import keylime_logging\nfrom keylime import cloud_verifier_common\nfrom keylime import revocation_notifier\nfrom keylime import web_util\nfrom keylime import tornado_requests\nfrom keylime import api_version as keylime_api_version\nfrom keylime.failure import MAX_SEVERITY_LABEL, Failure, Component\n\nlogger = keylime_logging.init_logging('cloudverifier')\n\n\ntry:\n    engine = DBEngineManager().make_engine('cloud_verifier')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine or session: %s', err)\n    sys.exit(1)\n\n\ndef get_session():\n    return SessionManager().make_session(engine)\n\n\ndef get_AgentAttestStates():\n    return AgentAttestStates.get_instance()\n\n\n# The \"exclude_db\" dict values are removed from the response before adding the dict to the DB\n# This is because we want these values to remain ephemeral and not stored in the database.\nexclude_db = {\n    'registrar_data': '',\n    'nonce': '',\n    'b64_encrypted_V': '',\n    'provide_V': True,\n    'num_retries': 0,\n    'pending_event': None,\n    'first_verified': False,\n    # the following 3 items are updated to VerifierDB only when the AgentState is stored\n    'boottime': '',\n    'ima_pcrs': [],\n    'pcr10': '',\n    'next_ima_ml_entry': 0,\n    'learned_ima_keyrings': {},\n    'ssl_context': None,\n}\n\n\ndef _from_db_obj(agent_db_obj):\n    fields = [ 'agent_id', \\\n                'v', \\\n                'ip', \\\n                'port', \\\n                'operational_state', \\\n                'public_key', \\\n                'tpm_policy', \\\n                'meta_data', \\\n                'mb_refstate', \\\n                'allowlist', \\\n                'ima_sign_verification_keys', \\\n                'revocation_key', \\\n                'accept_tpm_hash_algs', \\\n                'accept_tpm_encryption_algs', \\\n                'accept_tpm_signing_algs', \\\n                'hash_alg', \\\n                'enc_alg', \\\n                'sign_alg', \\\n                'boottime', \\\n                'ima_pcrs', \\\n                'pcr10', \\\n                'next_ima_ml_entry', \\\n                'learned_ima_keyrings',\n                'supported_version',\n                'mtls_cert',\n                'ak_tpm',\n               ]\n    agent_dict = {}\n    for field in fields:\n        agent_dict[field] = getattr(agent_db_obj, field, None)\n\n    # add default fields that are ephemeral\n    for key,val in exclude_db.items():\n        agent_dict[key] = val\n\n    return agent_dict\n\n\ndef verifier_db_delete_agent(session, agent_id):\n    get_AgentAttestStates().delete_by_agent_id(agent_id)\n    session.query(VerfierMain).filter_by(\n                  agent_id=agent_id).delete()\n    session.commit()\n\n\ndef store_attestation_state(agentAttestState):\n    # Only store if IMA log was evaluated\n    if agentAttestState.get_ima_pcrs():\n        session = get_session()\n        try:\n            update_agent = session.query(VerfierMain).get(agentAttestState.get_agent_id())\n            update_agent.boottime = agentAttestState.get_boottime()\n            update_agent.next_ima_ml_entry = agentAttestState.get_next_ima_ml_entry()\n            ima_pcrs_dict = agentAttestState.get_ima_pcrs()\n            update_agent.ima_pcrs = list(ima_pcrs_dict.keys())\n            for pcr_num, value in ima_pcrs_dict.items():\n                setattr(update_agent, f'pcr{pcr_num}', value)\n            update_agent.learned_ima_keyrings = agentAttestState.get_ima_keyrings().to_json()\n            try:\n                session.add(update_agent)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n    def prepare(self):  # pylint: disable=W0235\n        super().prepare()\n\n    def write_error(self, status_code, **kwargs):\n\n        self.set_header('Content-Type', 'text/json')\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'traceback': lines,\n                'results': {},\n            }))\n        else:\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'results': {},\n            }))\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\nclass VersionHandler(BaseHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def get(self):\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET returning 400 response. URI not supported: %s', self.request.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    mtls_options = None  # Stores the cert, key and password used by the verifier for mTLS connections\n\n    def initialize(self, mtls_options):\n        self.mtls_options = mtls_options\n\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. Agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.  If the agent_id\n        was not found, it either completed successfully, or failed.  If found, the agent_id is still polling\n        to contact the Cloud Agent.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if (agent_id is not None) and (agent_id != ''):\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id).one_or_none()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is not None:\n                response = cloud_verifier_common.process_get_status(agent)\n                web_util.echo_json_response(self, 200, \"Success\", response)\n            else:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n        else:\n            json_response = None\n            if \"bulk\" in rest_params:\n                agent_list = None\n\n                if (\"verifier\" in rest_params) and (rest_params[\"verifier\"] != ''):\n                    agent_list = session.query(VerfierMain).filter_by(verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    agent_list = session.query(VerfierMain).all()\n\n                json_response = {}\n                for agent in agent_list:\n                    json_response[agent.agent_id] = cloud_verifier_common.process_get_status(agent)\n\n                web_util.echo_json_response(self, 200, \"Success\", json_response)\n            else:\n                if (\"verifier\" in rest_params) and (rest_params[\"verifier\"] != ''):\n                    json_response = session.query(VerfierMain.agent_id).filter_by(\n                        verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    json_response = session.query(VerfierMain.agent_id).all()\n\n                web_util.echo_json_response(self, 200, \"Success\", {\n                    'uuids': json_response})\n\n            logger.info('GET returning 200 response for agent_id list')\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n            return\n\n        try:\n            agent = session.query(VerfierMain).filter_by(\n                agent_id=agent_id).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        if agent is None:\n            web_util.echo_json_response(self, 404, \"agent id not found\")\n            logger.info('DELETE returning 404 response. agent id: %s not found.', agent_id)\n            return\n\n        verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n        if verifier_id != agent.verifier_id:\n            web_util.echo_json_response(self, 404, \"agent id associated to this verifier\")\n            logger.info('DELETE returning 404 response. agent id: %s not associated to this verifer.', agent_id)\n            return\n\n        op_state = agent.operational_state\n        if op_state in (states.SAVED, states.FAILED, states.TERMINATED,\n                        states.TENANT_FAILED, states.INVALID_QUOTE):\n            try:\n                verifier_db_delete_agent(session, agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('DELETE returning 200 response for agent id: %s', agent_id)\n        else:\n            try:\n                update_agent = session.query(VerfierMain).get(agent_id)\n                update_agent.operational_state = states.TERMINATED\n                try:\n                    session.add(update_agent)\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                session.commit()\n                web_util.echo_json_response(self, 202, \"Accepted\")\n                logger.info('DELETE returning 202 response for agent id: %s', agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is not None:\n                # If the agent ID is not valid (wrong set of\n                # characters), just do nothing.\n                if not validators.valid_agent_id(agent_id):\n                    web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                    logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n                    return\n\n                content_length = len(self.request.body)\n                if content_length == 0:\n                    web_util.echo_json_response(\n                        self, 400, \"Expected non zero content length\")\n                    logger.warning('POST returning 400 response. Expected non zero content length.')\n                else:\n                    json_body = json.loads(self.request.body)\n                    agent_data = {}\n                    agent_data['v'] = json_body['v']\n                    agent_data['ip'] = json_body['cloudagent_ip']\n                    agent_data['port'] = int(json_body['cloudagent_port'])\n                    agent_data['operational_state'] = states.START\n                    agent_data['public_key'] = \"\"\n                    agent_data['tpm_policy'] = json_body['tpm_policy']\n                    agent_data['meta_data'] = json_body['metadata']\n                    agent_data['allowlist'] = json_body['allowlist']\n                    agent_data['mb_refstate'] = json_body['mb_refstate']\n                    agent_data['ima_sign_verification_keys'] = json_body['ima_sign_verification_keys']\n                    agent_data['revocation_key'] = json_body['revocation_key']\n                    agent_data['accept_tpm_hash_algs'] = json_body['accept_tpm_hash_algs']\n                    agent_data['accept_tpm_encryption_algs'] = json_body['accept_tpm_encryption_algs']\n                    agent_data['accept_tpm_signing_algs'] = json_body['accept_tpm_signing_algs']\n                    agent_data['supported_version'] = json_body['supported_version']\n                    agent_data['hash_alg'] = \"\"\n                    agent_data['enc_alg'] = \"\"\n                    agent_data['sign_alg'] = \"\"\n                    agent_data['agent_id'] = agent_id\n                    agent_data['boottime'] = 0\n                    agent_data['ima_pcrs'] = []\n                    agent_data['pcr10'] = None\n                    agent_data['next_ima_ml_entry'] = 0\n                    agent_data['learned_ima_keyrings'] = {}\n                    agent_data['verifier_id'] = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                    agent_data['verifier_ip'] = config.get('cloud_verifier', 'cloudverifier_ip')\n                    agent_data['verifier_port'] = config.get('cloud_verifier', 'cloudverifier_port')\n\n                    # We fetch the registrar data directly here because we require it for connecting to the agent\n                    # using mTLS\n                    registrar_client.init_client_tls('cloud_verifier')\n                    registrar_data = registrar_client.getData(config.get(\"cloud_verifier\", \"registrar_ip\"),\n                                                              config.get(\"cloud_verifier\", \"registrar_port\"), agent_id)\n                    if registrar_data is None:\n                        web_util.echo_json_response(self, 400,\n                                                    f\"Data for agent {agent_id} could not be found in registrar!\")\n                        logger.warning(\"Data for agent %s could not be found in registrar!\", agent_id)\n                        return\n\n                    agent_data['mtls_cert'] = registrar_data.get('mtls_cert', None)\n                    agent_data['ak_tpm'] = registrar_data['aik_tpm']\n\n                    # TODO: Always error for v1.0 version after initial upgrade\n                    if registrar_data.get('mtls_cert', None) is None and agent_data['supported_version'] != \"1.0\":\n                        web_util.echo_json_response(self, 400, \"mTLS certificate for agent is required!\")\n                        return\n\n                    is_valid, err_msg = cloud_verifier_common.validate_agent_data(agent_data)\n                    if not is_valid:\n                        web_util.echo_json_response(self, 400, err_msg)\n                        logger.warning(err_msg)\n                        return\n\n                    try:\n                        new_agent_count = session.query(\n                            VerfierMain).filter_by(agent_id=agent_id).count()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise e\n\n                    # don't allow overwriting\n\n                    if new_agent_count > 0:\n                        web_util.echo_json_response(\n                            self, 409, f\"Agent of uuid {agent_id} already exists\")\n                        logger.warning(\"Agent of uuid %s already exists\", agent_id)\n                    else:\n                        try:\n                            # Add the agent and data\n                            session.add(VerfierMain(**agent_data))\n                            session.commit()\n                        except SQLAlchemyError as e:\n                            logger.error('SQLAlchemy Error: %s', e)\n                            raise e\n\n                        # add default fields that are ephemeral\n                        for key,val in exclude_db.items():\n                            agent_data[key] = val\n\n                        # Prepare SSLContext for mTLS connections\n                        agent_mtls_cert_enabled = config.getboolean('cloud_verifier', 'agent_mtls_cert_enabled', fallback=False)\n                        mtls_cert = registrar_data.get('mtls_cert', None)\n                        agent_data['ssl_context'] = None\n                        if agent_mtls_cert_enabled and mtls_cert:\n                            agent_data['ssl_context'] = web_util.generate_agent_mtls_context(mtls_cert, self.mtls_options)\n\n                        if agent_data['ssl_context'] is None:\n                            logger.warning('Connecting to agent without mTLS: %s', agent_id)\n\n                        asyncio.ensure_future(\n                            process_agent(agent_data, states.GET_QUOTE))\n                        web_util.echo_json_response(self, 200, \"Success\")\n                        logger.info('POST returning 200 response for adding agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"POST returning 400 response. uri not supported\")\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Exception error: {str(e)}\")\n            logger.warning(\"POST returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is None:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id, verifier_id=verifier_id).one()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise e\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n                logger.info('PUT returning 404 response. agent id: %s not found.', agent_id)\n                return\n\n            if \"reactivate\" in rest_params:\n                if not isinstance(agent, dict):\n                    agent = _from_db_obj(agent)\n                if agent[\"mtls_cert\"]:\n                    agent['ssl_context'] = web_util.generate_agent_mtls_context(agent[\"mtls_cert\"], self.mtls_options)\n                agent[\"operational_state\"] = states.START\n                asyncio.ensure_future(\n                    process_agent(agent, states.GET_QUOTE))\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            elif \"stop\" in rest_params:\n                # do stuff for terminate\n                logger.debug(\"Stopping polling on %s\", agent_id)\n                try:\n                    session.query(VerfierMain).filter(VerfierMain.agent_id == agent_id).update(\n                        {'operational_state': states.TENANT_FAILED})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Exception error: {str(e)}\")\n            logger.warning(\"PUT returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AllowlistHandler(BaseHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: HEAD Not Implemented\")\n\n    def get(self):\n        \"\"\"Get an allowlist\n\n        GET /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'GET returning 400 response: %s', self.request.path)\n            return\n\n        session = get_session()\n        try:\n            allowlist = session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, f\"Allowlist {allowlist_name} not found\")\n            return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        response = {}\n        for field in ('name', 'tpm_policy', 'ima_policy'):\n            response[field] = getattr(allowlist, field, None)\n        web_util.echo_json_response(self, 200, 'Success', response)\n\n    def delete(self):\n        \"\"\"Delete an allowlist\n\n        DELETE /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'DELETE returning 400 response: %s', self.request.path)\n            return\n\n        session = get_session()\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, f\"Allowlist {allowlist_name} not found\")\n            return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).delete()\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        # NOTE(kaifeng) 204 Can not have response body, but current helper\n        # doesn't support this case.\n        self.set_status(204)\n        self.set_header('Content-Type', 'application/json')\n        self.finish()\n        logger.info(\n            'DELETE returning 204 response for allowlist: %s', allowlist_name)\n\n    def post(self):\n        \"\"\"Create an allowlist\n\n        POST /allowlists/{name}\n        body: {\"tpm_policy\": {..} ...\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        content_length = len(self.request.body)\n        if content_length == 0:\n            web_util.echo_json_response(\n                self, 400, \"Expected non zero content length\")\n            logger.warning(\n                'POST returning 400 response. Expected non zero content length.')\n            return\n\n        allowlist = {}\n        json_body = json.loads(self.request.body)\n        allowlist['name'] = allowlist_name\n        tpm_policy = json_body.get('tpm_policy')\n        if tpm_policy:\n            allowlist['tpm_policy'] = tpm_policy\n        ima_policy = json_body.get('ima_policy')\n        if ima_policy:\n            allowlist['ima_policy'] = ima_policy\n\n        session = get_session()\n        # don't allow overwritting\n        try:\n            al_count = session.query(\n                VerifierAllowlist).filter_by(name=allowlist_name).count()\n            if al_count > 0:\n                web_util.echo_json_response(\n                    self, 409, f\"Allowlist with name {allowlist_name} already exists\")\n                logger.warning(\n                    \"Allowlist with name %s already exists\", allowlist_name)\n                return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            raise\n\n        try:\n            # Add the agent and data\n            session.add(VerifierAllowlist(**allowlist))\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            raise\n\n        web_util.echo_json_response(self, 201)\n        logger.info('POST returning 201')\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: PUT Not Implemented\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nasync def invoke_get_quote(agent, need_pubkey):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"agent deleted while being processed\")\n    params = cloud_verifier_common.prepare_get_quote(agent)\n\n    partial_req = \"1\"\n    if need_pubkey:\n        partial_req = \"0\"\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\"GET\",\n                                       f\"https://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/quotes/integrity\"\n                                       f\"?nonce={params['nonce']}&mask={params['mask']}\"\n                                       f\"&partial={partial_req}&ima_ml_entry={params['ima_ml_entry']}\",\n                                       context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\"GET\",\n                                       f\"http://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/quotes/integrity\"\n                                       f\"?nonce={params['nonce']}&mask={params['mask']}\"\n                                       f\"&partial={partial_req}&ima_ml_entry={params['ima_ml_entry']}\")\n    response = await res\n\n    if response.status_code != 200:\n        # this is a connection error, retry get quote\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(process_agent(\n                agent, states.GET_QUOTE_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Get Quote response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_quote\", \"Unexpected Get Quote reponse from agent\", False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        try:\n            json_response = json.loads(response.body)\n\n            # validate the cloud agent response\n            if 'provide_V' not in agent :\n                agent['provide_V'] = True\n            agentAttestState = get_AgentAttestStates().get_by_agent_id(agent['agent_id'])\n            failure = cloud_verifier_common.process_quote_response(agent, json_response['results'], agentAttestState)\n            if not failure:\n                if agent['provide_V']:\n                    asyncio.ensure_future(process_agent(agent, states.PROVIDE_V))\n                else:\n                    asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n            else:\n                asyncio.ensure_future(process_agent(agent, states.INVALID_QUOTE, failure))\n\n            # store the attestation state\n            store_attestation_state(agentAttestState)\n\n        except Exception as e:\n            logger.exception(e)\n\n\nasync def invoke_provide_v(agent):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"Agent deleted while being processed\")\n    try:\n        if agent['pending_event'] is not None:\n            agent['pending_event'] = None\n    except KeyError:\n        pass\n    v_json_message = cloud_verifier_common.prepare_v(agent)\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\n            \"POST\", f\"https://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/keys/vkey\",\n            data=v_json_message, context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\n            \"POST\", f\"http://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/keys/vkey\",\n            data=v_json_message)\n\n    response = await res\n\n    if response.status_code != 200:\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(\n                process_agent(agent, states.PROVIDE_V_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Provide V response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_v\", {\"message\": \"Unexpected provide V response\", \"data\": response.status_code}, False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n\n\nasync def process_agent(agent, new_operational_state, failure=Failure(Component.INTERNAL, [\"verifier\"])):\n    # Convert to dict if the agent arg is a db object\n    if not isinstance(agent, dict):\n        agent = _from_db_obj(agent)\n\n    session = get_session()\n    try:  # pylint: disable=R1702\n        main_agent_operational_state = agent['operational_state']\n        try:\n            stored_agent = session.query(VerfierMain).filter_by(\n                agent_id=str(agent['agent_id'])).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # if the user did terminated this agent\n        if stored_agent.operational_state == states.TERMINATED:\n            logger.warning(\"Agent %s terminated by user.\", agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            verifier_db_delete_agent(session, agent['agent_id'])\n            return\n\n        # if the user tells us to stop polling because the tenant quote check failed\n        if stored_agent.operational_state == states.TENANT_FAILED:\n            logger.warning(\"Agent %s has failed tenant quote. Stopping polling\",  agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            return\n\n        # If failed during processing, log regardless and drop it on the floor\n        # The administration application (tenant) can GET the status and act accordingly (delete/retry/etc).\n        if new_operational_state in (states.FAILED, states.INVALID_QUOTE):\n            assert failure, \"States FAILED and INVALID QUOTE should only be reached with a failure message\"\n\n            if agent.get('severity_level') is None or agent['severity_level'] < failure.highest_severity.severity:\n                agent['severity_level'] = failure.highest_severity.severity\n                agent['last_event_id'] = failure.highest_severity_event.event_id\n                agent['operational_state'] = new_operational_state\n\n                # issue notification for invalid quotes\n                if new_operational_state == states.INVALID_QUOTE:\n                    cloud_verifier_common.notify_error(agent, event=failure.highest_severity_event)\n\n                # When the failure is irrecoverable we stop polling the agent\n                if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                    if agent['pending_event'] is not None:\n                        tornado.ioloop.IOLoop.current().remove_timeout(\n                            agent['pending_event'])\n                    for key in exclude_db:\n                        if key in agent:\n                            del agent[key]\n                    session.query(VerfierMain).filter_by(\n                        agent_id=agent['agent_id']).update(agent)\n                    session.commit()\n\n        # propagate all state, but remove none DB keys first (using exclude_db)\n        try:\n            agent_db = dict(agent)\n            for key in exclude_db:\n                if key in agent_db:\n                    del agent_db[key]\n\n            session.query(VerfierMain).filter_by(\n                agent_id=agent_db['agent_id']).update(agent_db)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # If agent was in a failed state we check if we either stop polling\n        # or just add it again to the event loop\n        if new_operational_state in [states.FAILED, states.INVALID_QUOTE]:\n            if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                logger.warning(\"Agent %s failed, stopping polling\", agent['agent_id'])\n                return\n\n            await invoke_get_quote(agent, False)\n            return\n\n        # if new, get a quote\n        if (main_agent_operational_state == states.START and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.GET_QUOTE\n            await invoke_get_quote(agent, True)\n            return\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.PROVIDE_V):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.PROVIDE_V\n            await invoke_provide_v(agent)\n            return\n\n        if (main_agent_operational_state in (states.PROVIDE_V, states.GET_QUOTE) and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            interval = config.getfloat('cloud_verifier', 'quote_interval')\n            agent['operational_state'] = states.GET_QUOTE\n            if interval == 0:\n                await invoke_get_quote(agent, False)\n            else:\n                logger.debug(\"Setting up callback to check again in %f seconds\", interval)\n                # set up a call back to check again\n                cb = functools.partial(invoke_get_quote, agent, False)\n                pending = tornado.ioloop.IOLoop.current().call_later(interval, cb)\n                agent['pending_event'] = pending\n            return\n\n        maxr = config.getint('cloud_verifier', 'max_retries')\n        interval = config.getfloat('cloud_verifier', 'retry_interval')\n        exponential_backoff = config.getboolean('cloud_verifier', 'exponential_backoff')\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.GET_QUOTE_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable for quote in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable\", \"agent was not reachable from verifier\", False)\n                if agent['first_verified']:  # only notify on previously good agents\n                    cloud_verifier_common.notify_error(\n                        agent, msgtype='comm_error', event=failure.highest_severity_event)\n                else:\n                    logger.debug(\"Communication error for new agent. No notification will be sent\")\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.GET_QUOTE\n                cb = functools.partial(invoke_get_quote, agent, True)\n                agent['num_retries'] += 1\n                next_retry = retry.retry_time(exponential_backoff, interval, agent['num_retries'], logger)\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, next_retry)\n                tornado.ioloop.IOLoop.current().call_later(next_retry, cb)\n            return\n\n        if (main_agent_operational_state == states.PROVIDE_V and\n                new_operational_state == states.PROVIDE_V_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable to provide v in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable_v\", \"agent was not reachable to provide V\", False)\n                cloud_verifier_common.notify_error(\n                    agent, msgtype='comm_error', event=failure.highest_severity_event)\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.PROVIDE_V\n                cb = functools.partial(invoke_provide_v, agent)\n                agent['num_retries'] += 1\n                next_retry = retry.retry_time(exponential_backoff, interval, agent['num_retries'], logger)\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, next_retry)\n                tornado.ioloop.IOLoop.current().call_later(next_retry, cb)\n            return\n        raise Exception(\"nothing should ever fall out of this!\")\n\n    except Exception as e:\n        logger.error(\"Polling thread error: %s\", e)\n        logger.exception(e)\n\n\nasync def activate_agents(verifier_id, verifier_ip, verifier_port, mtls_options):\n    session = get_session()\n    aas = get_AgentAttestStates()\n    try:\n        agents = session.query(VerfierMain).filter_by(\n            verifier_id=verifier_id).all()\n        for agent in agents:\n            agent.verifier_ip = verifier_ip\n            agent.verifier_host = verifier_port\n            agent_run = _from_db_obj(agent)\n            if agent_run[\"mtls_cert\"]:\n                agent_run[\"ssl_context\"] = web_util.generate_agent_mtls_context(agent_run[\"mtls_cert\"], mtls_options)\n            if agent.operational_state == states.START:\n                asyncio.ensure_future(process_agent(agent_run, states.GET_QUOTE))\n            if agent.boottime:\n                ima_pcrs_dict = {}\n                for pcr_num in agent.ima_pcrs:\n                    ima_pcrs_dict[pcr_num] = getattr(agent, f'pcr{pcr_num}')\n                aas.add(agent.agent_id, agent.boottime, ima_pcrs_dict, agent.next_ima_ml_entry, agent.learned_ima_keyrings)\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n\ndef main():\n    \"\"\"Main method of the Cloud Verifier Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    cloudverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\n    cloudverifier_host = config.get('cloud_verifier', 'cloudverifier_ip')\n    cloudverifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n\n    # allow tornado's max upload size to be configurable\n    max_upload_size = None\n    if config.has_option('cloud_verifier', 'max_upload_size'):\n        max_upload_size = int(config.get('cloud_verifier', 'max_upload_size'))\n\n    # set a conservative general umask\n    os.umask(0o077)\n\n    VerfierMain.metadata.create_all(engine, checkfirst=True)\n    session = get_session()\n    try:\n        query_all = session.query(VerfierMain).all()\n        for row in query_all:\n            if row.operational_state in states.APPROVED_REACTIVATE_STATES:\n                row.operational_state = states.START\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    num = session.query(VerfierMain.agent_id).count()\n    if num > 0:\n        agent_ids = session.query(VerfierMain.agent_id).all()\n        logger.info(\"Agent ids in db loaded from file: %s\", agent_ids)\n\n    logger.info('Starting Cloud Verifier (tornado) on port %s, use <Ctrl-C> to stop', cloudverifier_port)\n\n    # print out API versions we support\n    keylime_api_version.log_api_versions(logger)\n\n    context, mtls_options = web_util.init_mtls(logger=logger)\n\n    # Check for user defined CA to connect to agent\n    agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n    agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n    agent_mtls_private_key_pw = config.get(\"cloud_verifier\", \"agent_mtls_private_key_pw\", fallback=None)\n\n    # Only set custom options if the cert should not be the same as used by the verifier\n    if agent_mtls_cert != \"CV\":\n        mtls_options = (agent_mtls_cert, agent_mtls_private_key, agent_mtls_private_key_pw)\n\n    app = tornado.web.Application([\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/agents/.*\", AgentsHandler, {\"mtls_options\": mtls_options}),\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/allowlists/.*\", AllowlistHandler),\n        (r\"/versions?\", VersionHandler),\n        (r\".*\", MainHandler),\n    ])\n\n    sockets = tornado.netutil.bind_sockets(\n        int(cloudverifier_port), address=cloudverifier_host)\n\n    def server_process(task_id):\n        logger.info(\"Starting server of process %s\", task_id)\n        engine.dispose()\n        server = tornado.httpserver.HTTPServer(app, ssl_options=context, max_buffer_size=max_upload_size)\n        server.add_sockets(sockets)\n\n        def server_sig_handler(*_):\n            logger.info(\"Shutting down server %s..\", task_id)\n            # Stop server to not accept new incoming connections\n            server.stop()\n\n            # Wait for all connections to be closed and then stop ioloop\n            async def stop():\n                await server.close_all_connections()\n                tornado.ioloop.IOLoop.current().stop()\n            asyncio.ensure_future(stop())\n\n        # Attach signal handler to ioloop.\n        # Do not use signal.signal(..) for that because it does not work!\n        loop = asyncio.get_event_loop()\n        loop.add_signal_handler(signal.SIGINT, server_sig_handler)\n        loop.add_signal_handler(signal.SIGTERM, server_sig_handler)\n\n        server.start()\n        if task_id == 0:\n            # Reactivate agents\n            asyncio.ensure_future(activate_agents(cloudverifier_id, cloudverifier_host, cloudverifier_port, mtls_options))\n        tornado.ioloop.IOLoop.current().start()\n        logger.debug(\"Server %s stopped.\", task_id)\n        sys.exit(0)\n\n    processes = []\n\n    def sig_handler(*_):\n        if config.getboolean('cloud_verifier', 'revocation_notifier'):\n            revocation_notifier.stop_broker()\n        for p in processes:\n            p.join()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, sig_handler)\n    signal.signal(signal.SIGTERM, sig_handler)\n    if config.getboolean('cloud_verifier', 'revocation_notifier'):\n        logger.info(\"Starting service for revocation notifications on port %s\",\n                    config.getint('cloud_verifier', 'revocation_notifier_port'))\n        revocation_notifier.start_broker()\n\n    num_workers = config.getint(\n        'cloud_verifier', 'multiprocessing_pool_num_workers')\n    if num_workers <= 0:\n        num_workers = tornado.process.cpu_count()\n    for task_id in range(0, num_workers):\n        process = Process(target=server_process, args=(task_id,))\n        process.start()\n        processes.append(process)\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport argparse\nimport base64\nimport hashlib\nimport io\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nimport zipfile\nimport json\nimport tempfile\nimport requests\n\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom keylime.agentstates import AgentAttestState\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import states, retry\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import registrar_client\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime import crypto\nfrom keylime.cmd import user_data_encrypt\nfrom keylime import ca_util\nfrom keylime.common import algorithms, validators\nfrom keylime.ima import ima, file_signatures\nfrom keylime import measured_boot\nfrom keylime import signing\nfrom keylime import api_version as keylime_api_version\n\n# setup logging\nlogger = keylime_logging.init_logging('tenant')\n\n# special exception that suppresses stack traces when it happens\nclass UserError(Exception):\n    pass\n\n\nclass Tenant():\n    \"\"\"Simple command processor example.\"\"\"\n\n    config = None\n\n    cloudverifier_ip = None\n    cloudverifier_port = None\n\n    cloudagent_ip = None\n    cv_cloudagent_ip = None\n    cloudagent_port = None\n\n    registrar_ip = None\n    registrar_port = None\n    registrar_data = None\n\n    webapp_ip = None\n    webapp_port = None\n\n    api_version = None\n\n    uuid_service_generate_locally = None\n    agent_uuid = None\n\n    K = None\n    V = None\n    U = None\n    auth_tag = None\n\n    tpm_policy = None\n    metadata = {}\n    allowlist = {}\n    ima_sign_verification_keys = []\n    revocation_key = \"\"\n    accept_tpm_hash_algs = []\n    accept_tpm_encryption_algs = []\n    accept_tpm_signing_algs = []\n    mb_refstate = None\n    supported_version = None\n\n    payload = None\n\n    tpm_instance = tpm()\n\n    def __init__(self):\n        \"\"\" Set up required values and TLS\n        \"\"\"\n        self.nonce = None\n        self.agent_ip = None\n        self.verifier_id = None\n        self.agent_port = None\n        self.verifier_ip = config.get('tenant', 'cloudverifier_ip')\n        self.verifier_port = config.get('tenant', 'cloudverifier_port')\n        self.registrar_ip = config.get('tenant', 'registrar_ip')\n        self.registrar_port = config.get('tenant', 'registrar_port')\n        self.webapp_port = config.getint('webapp', 'webapp_port')\n        self.webapp_ip = config.get('webapp', 'webapp_ip')\n\n        self.api_version = keylime_api_version.current_version()\n\n        (self.my_cert, self.my_priv_key), (self.my_agent_cert, self.my_agent_priv_key), self.verifier_ca_cert = Tenant.get_tls_context()\n        self.cert = (self.my_cert, self.my_priv_key)\n        self.agent_cert = (self.my_agent_cert, self.my_agent_priv_key)\n        if config.getboolean('general', \"enable_tls\"):\n            self.tls_cv_enabled = True\n        else:\n            self.tls_cv_enabled = False\n            self.cert = \"\"\n            logger.warning(\n                \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n        self.tls_agent_enabled = True\n        self.verify_custom = None\n\n    @property\n    def verifier_base_url(self):\n        return f'{self.verifier_ip}:{self.verifier_port}'\n\n    @staticmethod\n    def get_tls_context():\n        \"\"\"Generate certifcate naming and path\n\n        Returns:\n            string -- my_cert (client_cert), my_priv_key (client private key)\n        \"\"\"\n        verifier_ca_cert = config.get('tenant', 'ca_cert')\n        my_cert = config.get('tenant', 'my_cert')\n        my_priv_key = config.get('tenant', 'private_key')\n        tls_dir = config.get('tenant', 'tls_dir')\n\n        if tls_dir == 'default':\n            verifier_ca_cert = 'cacert.crt'\n            my_cert = 'client-cert.crt'\n            my_priv_key = 'client-private.pem'\n            tls_dir = 'cv_ca'\n\n        if tls_dir[0] != '/':\n            tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n        logger.info(\"Setting up client TLS in %s\", tls_dir)\n        verifier_ca_cert = os.path.join(tls_dir, verifier_ca_cert)\n        my_cert = os.path.join(tls_dir, my_cert)\n        my_priv_key = os.path.join(tls_dir, my_priv_key)\n\n        tls_context = (my_cert, my_priv_key)\n\n        agent_mtls_context = (None, None)\n        # Check for user defined CA to connect to agent\n        agent_mtls_cert_enabled = config.getboolean('tenant', 'agent_mtls_cert_enabled', fallback=False)\n\n        if agent_mtls_cert_enabled:\n            agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n            agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n            agent_mtls_context = tls_context\n            if agent_mtls_cert != \"CV\":\n                agent_mtls_context = (agent_mtls_cert, agent_mtls_private_key)\n\n        return tls_context, agent_mtls_context, verifier_ca_cert\n\n    def process_allowlist(self, args):\n        # Set up PCR values\n        tpm_policy = config.get('tenant', 'tpm_policy')\n        if \"tpm_policy\" in args and args[\"tpm_policy\"] is not None:\n            tpm_policy = args[\"tpm_policy\"]\n        self.tpm_policy = TPM_Utilities.readPolicy(tpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.tpm_policy['mask'])\n\n        if len(args.get(\"ima_sign_verification_keys\")) > 0:\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            # Add all IMA file signing verification keys to a keyring\n            tenant_keyring = file_signatures.ImaKeyring()\n            for filename in args[\"ima_sign_verification_keys\"]:\n                pubkey, keyidv2 = file_signatures.get_pubkey_from_file(filename)\n                if not pubkey:\n                    raise UserError(f\"File '{filename}' is not a file with a key\")\n                tenant_keyring.add_pubkey(pubkey, keyidv2)\n            self.ima_sign_verification_keys = tenant_keyring.to_string()\n\n        # Read command-line path string allowlist\n        al_data = None\n\n        if \"allowlist\" in args and args[\"allowlist\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), [ config.IMA_PCR ], \"IMA\")\n\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            if isinstance(args[\"allowlist\"], str):\n                if args[\"allowlist\"] == \"default\":\n                    args[\"allowlist\"] = config.get('tenant', 'allowlist')\n                try:\n                    al_data = ima.read_allowlist(args[\"allowlist\"], args[\"allowlist_checksum\"], args[\"allowlist_sig\"], args[\"allowlist_sig_key\"])\n                except Exception as ima_e:\n                    raise UserError(str(ima_e)) from ima_e\n            elif isinstance(args[\"allowlist\"], list):\n                al_data = args[\"allowlist\"]\n            else:\n                raise UserError(\"Invalid allowlist provided\")\n\n        # Read command-line path string IMA exclude list\n        excl_data = None\n        if \"ima_exclude\" in args and args[\"ima_exclude\"] is not None:\n            if isinstance(args[\"ima_exclude\"], str):\n                if args[\"ima_exclude\"] == \"default\":\n                    args[\"ima_exclude\"] = config.get(\n                        'tenant', 'ima_excludelist')\n                excl_data = ima.read_excllist(args[\"ima_exclude\"])\n            elif isinstance(args[\"ima_exclude\"], list):\n                excl_data = args[\"ima_exclude\"]\n            else:\n                raise UserError(\"Invalid exclude list provided\")\n\n        # Set up IMA\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.IMA_PCR):\n            # Process allowlists\n            self.allowlist = ima.process_allowlists(al_data, excl_data)\n\n        # Read command-line path string TPM event log (measured boot) reference state\n        mb_refstate_data = None\n        if \"mb_refstate\" in args and args[\"mb_refstate\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), config.MEASUREDBOOT_PCRS, \"measured boot\")\n\n            # Auto-enable TPM event log mesured boot (or-bit mask)\n            for _pcr in config.MEASUREDBOOT_PCRS:\n                self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << _pcr))\n\n            logger.info(\"TPM PCR Mask automatically modified is %s to include IMA/Event log PCRs\", self.tpm_policy['mask'])\n\n            if isinstance(args[\"mb_refstate\"], str):\n                if args[\"mb_refstate\"] == \"default\":\n                    args[\"mb_refstate\"] = config.get('tenant', 'mb_refstate')\n                mb_refstate_data = measured_boot.read_mb_refstate(args[\"mb_refstate\"])\n            else:\n                raise UserError(\"Invalid measured boot reference state (intended state) provided\")\n\n        # Set up measured boot (TPM event log) reference state\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.MEASUREDBOOT_PCRS[2]) :\n            # Process measured boot reference state\n            self.mb_refstate = mb_refstate_data\n\n    def init_add(self, args):\n        \"\"\" Set up required values. Command line options can overwrite these config values\n\n        Arguments:\n            args {[string]} -- agent_ip|agent_port|cv_agent_ip\n        \"\"\"\n        if \"agent_ip\" in args:\n            self.agent_ip = args[\"agent_ip\"]\n\n        if 'agent_port' in args and args['agent_port'] is not None:\n            self.agent_port = args['agent_port']\n\n        registrar_client.init_client_tls(\"tenant\")\n        self.registrar_data = registrar_client.getData(self.registrar_ip, self.registrar_port, self.agent_uuid)\n\n        if self.registrar_data is None:\n            raise UserError(f\"Agent ${self.agent_uuid} data not found in the Registrar.\")\n\n        # try to get the port or ip from the registrar if it is missing\n        if (self.agent_ip is None or self.agent_port is None) and self.registrar_data is not None:\n            if self.agent_ip is None:\n                if self.registrar_data['ip'] is not None:\n                    self.agent_ip = self.registrar_data['ip']\n                else:\n                    raise UserError(\"No Ip was specified or found in the Registrar\")\n\n            if self.agent_port is None and self.registrar_data['port'] is not None:\n                self.agent_port = self.registrar_data[\"port\"]\n\n        # If no agent port was found try to use the default from the config file\n        if self.agent_port is None:\n            self.agent_port = config.get('cloud_agent', 'cloudagent_port')\n\n        # Check if a contact ip and port for the agent was found\n        if self.agent_ip is None:\n            raise UserError(\"The contact ip address for the agent was not specified.\")\n\n        if self.agent_port is None:\n            raise UserError(\"The contact port for the agent was not specified.\")\n\n        # Auto-detection for API version\n        self.supported_version = args[\"supported_version\"]\n        if self.supported_version is None:\n            # Default to 1.0 if the agent did not send a mTLS certificate\n            if self.registrar_data.get(\"mtls_cert\", None) is None:\n                self.supported_version = \"1.0\"\n            else:\n                # Try to connect to the agent to get supported version\n                if self.registrar_data['mtls_cert'] == \"disabled\":\n                    self.tls_agent_enabled = False\n                    self.verify_custom = False\n                    logger.warning(\n                        \"Warning: mTLS for agents is disabled: the identity of each node will be based on the properties of the TPM only. \"\n                        \"Unless you have strict control of your network, it is strongly advised that remote code execution should be disabled, \"\n                        \"by setting \\\"payload_script=\\\" and \\\"extract_payload_zip=False\\\" under \\\"[cloud_agent]\\\"\")\n                else:\n                    self.verify_custom = self.registrar_data['mtls_cert']\n\n                with RequestsClient(f\"{self.agent_ip}:{self.agent_port}\", tls_enabled=self.tls_agent_enabled, cert=self.agent_cert,\n                                    ignore_hostname=True, verify_custom=self.verify_custom) as get_version:\n                    res = get_version.get(\"/version\")\n                    if res and res.status_code == 200:\n                        try:\n                            data = res.json()\n                            api_version = data[\"results\"][\"supported_version\"]\n                            if keylime_api_version.validate_version(api_version):\n                                self.supported_version = api_version\n                            else:\n                                logger.warning(\"API version provided by the agent is not valid\")\n                        except (TypeError, KeyError):\n                            pass\n\n        if self.supported_version is None:\n            api_version = keylime_api_version.current_version()\n            logger.warning(\"Could not detect supported API version. Defaulting to %s\", api_version)\n            self.supported_version = api_version\n\n        # Now set the cv_agent_ip\n        if 'cv_agent_ip' in args and args['cv_agent_ip'] is not None:\n            self.cv_cloudagent_ip = args['cv_agent_ip']\n        else:\n            self.cv_cloudagent_ip = self.agent_ip\n\n        # Make sure all keys exist in dictionary\n        if \"file\" not in args:\n            args[\"file\"] = None\n        if \"keyfile\" not in args:\n            args[\"keyfile\"] = None\n        if \"payload\" not in args:\n            args[\"payload\"] = None\n        if \"ca_dir\" not in args:\n            args[\"ca_dir\"] = None\n        if \"incl_dir\" not in args:\n            args[\"incl_dir\"] = None\n        if \"ca_dir_pw\" not in args:\n            args[\"ca_dir_pw\"] = None\n\n        # Set up accepted algorithms\n        self.accept_tpm_hash_algs = config.get(\n            'tenant', 'accept_tpm_hash_algs').split(',')\n        self.accept_tpm_encryption_algs = config.get(\n            'tenant', 'accept_tpm_encryption_algs').split(',')\n        self.accept_tpm_signing_algs = config.get(\n            'tenant', 'accept_tpm_signing_algs').split(',')\n\n        self.process_allowlist(args)\n\n        # if none\n        if (args[\"file\"] is None and args[\"keyfile\"] is None and args[\"ca_dir\"] is None):\n            raise UserError(\n                \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n        if args[\"keyfile\"] is not None:\n            if args[\"file\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            # read the keys in\n            if isinstance(args[\"keyfile\"], dict) and \"data\" in args[\"keyfile\"]:\n                if isinstance(args[\"keyfile\"][\"data\"], list) and len(args[\"keyfile\"][\"data\"]) == 1:\n                    keyfile = args[\"keyfile\"][\"data\"][0]\n                    if keyfile is None:\n                        raise UserError(\"Invalid key file contents\")\n                    f = io.StringIO(keyfile)\n                else:\n                    raise UserError(\"Invalid key file provided\")\n            else:\n                f = open(args[\"keyfile\"], encoding=\"utf-8\")  #pylint: disable=consider-using-with\n            self.K = base64.b64decode(f.readline())\n            self.U = base64.b64decode(f.readline())\n            self.V = base64.b64decode(f.readline())\n            f.close()\n\n            # read the payload in (opt.)\n            if isinstance(args[\"payload\"], dict) and \"data\" in args[\"payload\"]:\n                if isinstance(args[\"payload\"][\"data\"], list) and len(args[\"payload\"][\"data\"]) > 0:\n                    self.payload = args[\"payload\"][\"data\"][0]\n            else:\n                if args[\"payload\"] is not None:\n                    with open(args[\"payload\"], 'rb') as f:\n                        self.payload = f.read()\n\n        if args[\"file\"] is not None:\n            if args[\"keyfile\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            if isinstance(args[\"file\"], dict) and \"data\" in args[\"file\"]:\n                if isinstance(args[\"file\"][\"data\"], list) and len(args[\"file\"][\"data\"]) > 0:\n                    contents = args[\"file\"][\"data\"][0]\n                    if contents is None:\n                        raise UserError(\"Invalid file payload contents\")\n                else:\n                    raise UserError(\"Invalid file payload provided\")\n            else:\n                with open(args[\"file\"], encoding=\"utf-8\") as f:\n                    contents = f.read()\n            ret = user_data_encrypt.encrypt(contents)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.payload = ret['ciphertext']\n\n        if args[\"ca_dir\"] is None and args[\"incl_dir\"] is not None:\n            raise UserError(\n                \"--include option is only valid when used with --cert\")\n        if args[\"ca_dir\"] is not None:\n            if args[\"file\"] is not None or args[\"keyfile\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n            if args[\"ca_dir\"] == 'default':\n                args[\"ca_dir\"] = config.CA_WORK_DIR\n\n            if \"ca_dir_pw\" in args and args[\"ca_dir_pw\"] is not None:\n                ca_util.setpassword(args[\"ca_dir_pw\"])\n\n            if not os.path.exists(args[\"ca_dir\"]) or not os.path.exists(os.path.join(args[\"ca_dir\"], \"cacert.crt\")):\n                logger.warning(\"CA directory does not exist. Creating...\")\n                ca_util.cmd_init(args[\"ca_dir\"])\n            if not os.path.exists(\n                    os.path.join(args[\"ca_dir\"],\n                                 f\"{self.agent_uuid}-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], self.agent_uuid)\n\n            cert_pkg, serial, subject = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], self.agent_uuid)\n\n            # support revocation\n            if not os.path.exists(os.path.join(args[\"ca_dir\"], \"RevocationNotifier-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], \"RevocationNotifier\")\n            rev_package, _, _ = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], \"RevocationNotifier\")\n\n            # extract public and private keys from package\n            sf = io.BytesIO(rev_package)\n            with zipfile.ZipFile(sf) as zf:\n                privkey = zf.read(\"RevocationNotifier-private.pem\")\n                cert = zf.read(\"RevocationNotifier-cert.crt\")\n\n            # put the cert of the revoker into the cert package\n            sf = io.BytesIO(cert_pkg)\n            with zipfile.ZipFile(sf, 'a', compression=zipfile.ZIP_STORED) as zf:\n                zf.writestr('RevocationNotifier-cert.crt', cert)\n\n                # add additional files to zip\n                if args[\"incl_dir\"] is not None:\n                    if isinstance(args[\"incl_dir\"], dict) and \"data\" in args[\"incl_dir\"] and \"name\" in args[\"incl_dir\"]:\n                        if isinstance(args[\"incl_dir\"][\"data\"], list) and isinstance(args[\"incl_dir\"][\"name\"], list):\n                            if len(args[\"incl_dir\"][\"data\"]) != len(args[\"incl_dir\"][\"name\"]):\n                                raise UserError(\"Invalid incl_dir provided\")\n                            for i in range(len(args[\"incl_dir\"][\"data\"])):\n                                zf.writestr(os.path.basename(\n                                    args[\"incl_dir\"][\"name\"][i]), args[\"incl_dir\"][\"data\"][i])\n                    else:\n                        if os.path.exists(args[\"incl_dir\"]):\n                            files = next(os.walk(args[\"incl_dir\"]))[2]\n                            for filename in files:\n                                with open(os.path.join(args[\"incl_dir\"],\n                                                       filename), 'rb') as f:\n                                    zf.writestr(\n                                        os.path.basename(f.name), f.read())\n                        else:\n                            logger.warning('Specified include directory %s does not exist. Skipping...', args[\"incl_dir\"])\n\n            cert_pkg = sf.getvalue()\n\n            # put the private key into the data to be send to the CV\n            self.revocation_key = privkey.decode('utf-8')\n\n            # encrypt up the cert package\n            ret = user_data_encrypt.encrypt(cert_pkg)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.metadata = {'cert_serial': serial, 'subject': subject}\n            self.payload = ret['ciphertext']\n\n        if self.payload is not None and len(self.payload) > config.getint('tenant', 'max_payload_size'):\n            raise UserError(f\"Payload size {len(self.payload)} exceeds max size {config.getint('tenant', 'max_payload_size')}\")\n\n    def enforce_pcrs(self, policy_pcrs, protected_pcrs, pcr_use) :\n        policy_pcrs = list(self.tpm_policy.keys())\n        policy_pcrs.remove('mask')\n\n        for _pcr in policy_pcrs :\n            if int(_pcr) in protected_pcrs :\n                logger.error('WARNING: PCR %s is specified in \"tpm_policy\", but will in fact be used by %s. Please remove it from policy', _pcr, pcr_use)\n                sys.exit(1)\n\n    def preloop(self):\n        \"\"\" encrypt the agent UUID as a check for delivering the correct key\n        \"\"\"\n        self.auth_tag = crypto.do_hmac(self.K, self.agent_uuid)\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"K: %s\", base64.b64encode(self.K))\n            logger.debug(\"V: %s\", base64.b64encode(self.V))\n            logger.debug(\"U: %s\", base64.b64encode(self.U))\n            logger.debug(\"Auth Tag: %s\", self.auth_tag)\n\n    def check_ek(self, ekcert):\n        \"\"\" Check the Entity Key\n\n        Arguments:\n            ekcert {str} -- The endorsement key, either None, \"emulator\", or base64 encoded der cert\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        if config.getboolean('tenant', 'require_ek_cert'):\n            if ekcert == 'emulator' and config.DISABLE_EK_CERT_CHECK_EMULATOR:\n                logger.info(\"Not checking ekcert of TPM emulator\")\n            elif ekcert is None:\n                logger.warning(\"No EK cert provided, require_ek_cert option in config set to True\")\n                return False\n            elif not self.tpm_instance.verify_ek(base64.b64decode(ekcert)):\n                logger.warning(\"Invalid EK certificate\")\n                return False\n\n        return True\n\n    def validate_tpm_quote(self, public_key, quote, hash_alg):\n        \"\"\" Validate TPM Quote received from the Agent\n\n        Arguments:\n            public_key {[type]} -- [description]\n            quote {[type]} -- [description]\n            hash_alg {bool} -- [description]\n\n        Raises:\n            UserError: [description]\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        registrar_client.init_client_tls('tenant')\n        if self.registrar_data is None:\n            logger.warning(\"AIK not found in registrar, quote not validated\")\n            return False\n\n        failure = self.tpm_instance.check_quote(AgentAttestState(self.agent_uuid), self.nonce, public_key, quote,\n                                                self.registrar_data['aik_tpm'], hash_alg=hash_alg,\n                                                compressed=(self.supported_version == \"1.0\"))\n        if failure:\n            if self.registrar_data['regcount'] > 1:\n                logger.error(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured or a malicious host is present. Run 'regdelete' for this agent and restart\")\n                sys.exit()\n            return False\n\n        if self.registrar_data['regcount'] > 1:\n            logger.warning(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured. Run 'regdelete' for this agent and restart\")\n\n        if not config.getboolean('tenant', 'require_ek_cert') and config.get('tenant', 'ek_check_script') == \"\":\n            logger.warning(\n                \"DANGER: EK cert checking is disabled and no additional checks on EKs have been specified with ek_check_script option. Keylime is not secure!!\")\n\n        # check EK cert and make sure it matches EK\n        if not self.check_ek(self.registrar_data['ekcert']):\n            return False\n        # if agent is virtual, check phyisical EK cert and make sure it matches phyiscal EK\n        if 'provider_keys' in self.registrar_data:\n            if not self.check_ek(self.registrar_data['provider_keys']['ekcert']):\n                return False\n\n        # check all EKs with optional script:\n        script = config.get('tenant', 'ek_check_script')\n        if not script:\n            return True\n\n        if script[0] != '/':\n            script = os.path.join(config.WORK_DIR, script)\n\n        logger.info(\"Checking EK with script %s\", script)\n        # now we need to exec the script with the ek and ek cert in vars\n        env = os.environ.copy()\n        env['AGENT_UUID'] = self.agent_uuid\n        env['EK'] = tpm2_objects.pubkey_from_tpm2b_public(\n            base64.b64decode(self.registrar_data['ek_tpm']),\n            ).public_bytes(\n                crypto_serialization.Encoding.PEM,\n                crypto_serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n        env['EK_TPM'] = self.registrar_data['ek_tpm']\n        if self.registrar_data['ekcert'] is not None:\n            env['EK_CERT'] = self.registrar_data['ekcert']\n        else:\n            env['EK_CERT'] = \"\"\n\n        env['PROVKEYS'] = json.dumps(self.registrar_data.get('provider_keys', {}))\n        with subprocess.Popen(script, env=env, shell=True,\n                              cwd=config.WORK_DIR, stdout=subprocess.PIPE,\n                              stderr=subprocess.STDOUT) as proc:\n            retval = proc.wait()\n            if retval != 0:\n                raise UserError(\"External check script failed to validate EK\")\n            logger.debug(\"External check script successfully to validated EK\")\n            while True:\n                line = proc.stdout.readline().decode()\n                if line == \"\":\n                    break\n                logger.debug(\"ek_check output: %s\", line.strip())\n        return True\n\n    def do_cv(self):\n        \"\"\" Initiaite v, agent_id and ip and initiate the cloudinit sequence\n        \"\"\"\n        b64_v = base64.b64encode(self.V).decode('utf-8')\n        logger.debug(\"b64_v: %s\", b64_v)\n        data = {\n            'v': b64_v,\n            'cloudagent_ip': self.cv_cloudagent_ip,\n            'cloudagent_port': self.agent_port,\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'allowlist': json.dumps(self.allowlist),\n            'mb_refstate': json.dumps(self.mb_refstate),\n            'ima_sign_verification_keys': json.dumps(self.ima_sign_verification_keys),\n            'metadata': json.dumps(self.metadata),\n            'revocation_key': self.revocation_key,\n            'accept_tpm_hash_algs': self.accept_tpm_hash_algs,\n            'accept_tpm_encryption_algs': self.accept_tpm_encryption_algs,\n            'accept_tpm_signing_algs': self.accept_tpm_signing_algs,\n            'supported_version': self.supported_version,\n        }\n        json_message = json.dumps(data)\n        do_cv = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cv.post(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            data=json_message,\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code == 409:\n            # this is a conflict, need to update or delete it\n            logger.error(\"Agent %s already existed at CV. Please use delete or update.\", self.agent_uuid)\n            sys.exit()\n        elif response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response.json())\n            logger.error(\"POST command response: %s Unexpected response from Cloud Verifier: %s\", response.status_code, response.text)\n            sys.exit()\n\n    def do_cvstatus(self):\n        \"\"\"Perform operational state look up for agent on the verifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            res = response.pop('results')\n            response['results'] = {self.agent_uuid: res}\n\n            operational_state = states.state_to_str(\n                response['results'][self.agent_uuid]['operational_state'])\n            response['results'][self.agent_uuid]['operational_state'] = operational_state\n\n            logger.info(\"Agent Info:\\n%s\", json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvlist(self):\n        \"\"\"List all agent statuses in cloudverifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?verifier={verifier_id}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            logger.info('From verifier %s port %s retrieved: \"%s\"',\n                        self.verifier_ip, self.verifier_port, response)\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvbulkinfo(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?bulk={True}&verifier={verifier_id}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            for agent in response[\"results\"].keys():\n                response[\"results\"][agent][\"operational_state\"] = \\\n                    states.state_to_str(response[\"results\"][agent][\n                                            \"operational_state\"])\n            logger.info(\"Bulk Agent Info:\\n%s\", json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvdelete(self, verifier_check=True):\n        \"\"\"Delete agent from Verifier.\"\"\"\n        if verifier_check:\n            cvresponse = self.do_cvstatus()\n\n            if not isinstance(cvresponse, dict):\n                return cvresponse\n\n            if cvresponse['code'] != 200:\n                logger.error(\"Could not get status of agent %s from \"\n                             \"verifier %s.\", self.agent_uuid, self.verifier_ip)\n                return cvresponse\n\n            self.verifier_ip = cvresponse['results'][self.agent_uuid][\"verifier_ip\"]\n            self.verifier_port = cvresponse['results'][self.agent_uuid][\"verifier_port\"]\n\n        do_cvdelete = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvdelete.delete(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        response = response.json()\n\n        if response['code'] == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 202:\n            deleted = False\n            for _ in range(12):\n                get_cvdelete = RequestsClient(\n                    self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n                response = get_cvdelete.get(\n                    (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n                    cert=self.cert,\n                    verify=self.verifier_ca_cert\n                )\n\n                if response.status_code == 404:\n                    deleted = True\n                    break\n                time.sleep(.4)\n            if deleted:\n                logger.info(\"CV completed deletion of agent %s\", self.agent_uuid)\n                return response.json()\n            logger.error(\"Timed out waiting for delete of agent %s to complete at CV\", self.agent_uuid)\n            return response.json()\n        if response['code'] == 200:\n            logger.info(\"Agent %s deleted from the CV\", self.agent_uuid)\n            return response\n\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response)\n        return response\n\n    def do_regstatus(self):\n        registrar_client.init_client_tls('tenant')\n        agent_info = registrar_client.getData(self.registrar_ip,\n                                              self.registrar_port,\n                                              self.agent_uuid)\n\n        if not agent_info:\n            logger.info(\n                \"Agent %s does not exist on the registrar. Please register the agent with the registrar.\",\n                self.agent_uuid)\n            response = {'code': 404,\n                        'status': f\"Agent {self.agent_uuid} does not exist on \"\n                                  f\"registrar {self.registrar_ip} port {self.registrar_port}.\",\n                        'results': {}}\n            logger.info(json.dumps(response))\n            return response\n\n        response = {'code': 200,\n                    'status': f\"Agent {self.agent_uuid} exists on \"\n                              f\"registrar {self.registrar_ip} port {self.registrar_port}.\",\n                    'results': {}}\n        response['results'][self.agent_uuid] = agent_info\n        response['results'][self.agent_uuid]['operational_state'] = \\\n            states.state_to_str(states.REGISTERED)\n\n        logger.info(json.dumps(response))\n\n        return response\n\n    def do_reglist(self):\n        \"\"\"List agents from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarList(\n            self.registrar_ip, self.registrar_port)\n\n        logger.info(\"From registrar %s port %s retrieved %s\",\n                    self.registrar_ip, self.registrar_port,\n                    json.dumps(response))\n        return response\n\n    def do_regdelete(self):\n        \"\"\"Delete agent from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarDelete(self.registrar_ip,\n                                           self.registrar_port,\n                                           self.agent_uuid)\n\n        return response\n\n    def do_status(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        regresponse = self.do_regstatus()\n\n        if regresponse['code'] == 404:\n            return regresponse\n\n        cvresponse = self.do_cvstatus()\n\n        if not isinstance(cvresponse, dict):\n            logger.error(\"Unexpected response from Cloud Verifier %s on \"\n                         \"port %s. response %s\", self.verifier_ip,\n                         self.verifier_port, str(cvresponse))\n            return cvresponse\n\n        if regresponse['code'] == 200 and cvresponse['code'] == 200:\n            return cvresponse\n        if regresponse['code'] == 200 and cvresponse['code'] != 200:\n            return regresponse\n\n        logger.error(\"Unknown inconsistent state between registrar %s on \"\n                     \"port %s and verifier %s on port %s occured. Got \"\n                     \"registrar response %s verifier response %s\",\n                     self.verifier_ip, self.verifier_port, self.registrar_ip,\n                     self.registrar_port, str(regresponse), str(cvresponse))\n\n        return {'registrar': regresponse, 'verifier': cvresponse}\n\n    def do_cvreactivate(self, verifier_check=True):\n        \"\"\"Reactive Agent.\"\"\"\n        if verifier_check:\n            agent_json = self.do_cvstatus()\n            self.verifier_ip = agent_json['results'][self.agent_uuid]['verifier_ip']\n            self.verifier_port = agent_json['results'][self.agent_uuid]['verifier_port']\n\n        do_cvreactivate = RequestsClient(\n            self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvreactivate.put(\n            f'/v{self.api_version}/agents/{self.agent_uuid}/reactivate',\n            data=b'',\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 200:\n            logger.info(\"Agent %s re-activated\", self.agent_uuid)\n            return response.json()\n\n        response_body = response.json()\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response_body)\n        logger.error(\"Update command response: %s Unexpected response from Cloud Verifier.\", response.status_code)\n        return response.json()\n\n    def do_cvstop(self):\n        \"\"\" Stop declared active agent\n        \"\"\"\n        params = f'/v{self.api_version}/agents/{self.agent_uuid}/stop'\n        do_cvstop = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvstop.put(\n            params,\n            cert=self.cert,\n            data=b'',\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        response_body = response.json()\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n        else:\n            logger.info(\"Agent %s stopped\", self.agent_uuid)\n\n    def do_quote(self):\n        \"\"\" Perform TPM quote by GET towards Agent\n\n        Raises:\n            UserError: Connection handler\n        \"\"\"\n        self.nonce = TPM_Utilities.random_password(20)\n\n        numtries = 0\n        response = None\n        # Note: We need a specific retry handler (perhaps in common), no point having localised unless we have too.\n        while True:\n            try:\n                params = f'/v{self.supported_version}/quotes/identity?nonce=%s' % (self.nonce)\n                cloudagent_base_url = f'{self.agent_ip}:{self.agent_port}'\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=self.tls_agent_enabled, ignore_hostname=True, cert=self.agent_cert,\n                                        verify_custom=self.verify_custom) as do_quote:\n                        response = do_quote.get(params)\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_quote = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_quote.get(params)\n\n                print(response)\n                response_body = response.json()\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Tenant cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    interval = config.getfloat('tenant', 'retry_interval')\n                    exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                    next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                    logger.info(\"Tenant connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, next_retry)\n                    time.sleep(next_retry)\n                    continue\n\n                raise e\n            break\n\n        if response is not None and response.status_code != 200:\n            raise UserError(\n               f\"Status command response: {response.status_code} Unexpected response from Cloud Agent.\")\n\n        if \"results\" not in response_body:\n            raise UserError(\n                f\"Error: unexpected http response body from Cloud Agent: {str(response.status)}\")\n\n        quote = response_body[\"results\"][\"quote\"]\n        logger.debug(\"Agent_quote received quote: %s\", quote)\n\n        public_key = response_body[\"results\"][\"pubkey\"]\n        logger.debug(\"Agent_quote received public key: %s\", public_key)\n\n        # Ensure hash_alg is in accept_tpm_hash_algs list\n        hash_alg = response_body[\"results\"][\"hash_alg\"]\n        logger.debug(\"Agent_quote received hash algorithm: %s\", hash_alg)\n        if not algorithms.is_accepted(hash_alg, config.get('tenant', 'accept_tpm_hash_algs').split(','))\\\n                or not algorithms.Hash.is_recognized(hash_alg):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted hash algorithm: {hash_alg}\")\n\n        # Ensure enc_alg is in accept_tpm_encryption_algs list\n        enc_alg = response_body[\"results\"][\"enc_alg\"]\n        logger.debug(\"Agent_quote received encryption algorithm: %s\", enc_alg)\n        if not algorithms.is_accepted(enc_alg, config.get('tenant', 'accept_tpm_encryption_algs').split(',')):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted encryption algorithm: {enc_alg}\")\n\n        # Ensure sign_alg is in accept_tpm_encryption_algs list\n        sign_alg = response_body[\"results\"][\"sign_alg\"]\n        logger.debug(\"Agent_quote received signing algorithm: %s\", sign_alg)\n        if not algorithms.is_accepted(sign_alg, config.get('tenant', 'accept_tpm_signing_algs').split(',')):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted signing algorithm: {sign_alg}\")\n\n        if not self.validate_tpm_quote(public_key, quote, algorithms.Hash(hash_alg)):\n            raise UserError(\n                f\"TPM Quote from cloud agent is invalid for nonce: {self.nonce}\")\n\n        logger.info(\"Quote from %s validated\", self.agent_ip)\n\n        # encrypt U with the public key\n        encrypted_U = crypto.rsa_encrypt(\n            crypto.rsa_import_pubkey(public_key), self.U)\n\n        b64_encrypted_u = base64.b64encode(encrypted_U)\n        logger.debug(\"b64_encrypted_u: %s\", b64_encrypted_u.decode('utf-8'))\n        data = {\n            'encrypted_key': b64_encrypted_u.decode('utf-8'),\n            'auth_tag': self.auth_tag\n        }\n\n        if self.payload is not None:\n            data['payload'] = self.payload.decode('utf-8')\n\n\n        # post encrypted U back to CloudAgent\n        params = f'/v{self.supported_version}/keys/ukey'\n        cloudagent_base_url = (\n            f'{self.agent_ip}:{self.agent_port}'\n        )\n\n        if self.registrar_data['mtls_cert']:\n            with RequestsClient(cloudagent_base_url, tls_enabled=self.tls_agent_enabled, ignore_hostname=True, cert=self.agent_cert,\n                                verify_custom=self.verify_custom) as post_ukey:\n                response = post_ukey.post(params, json=data)\n        else:\n            logger.warning(\"Connecting to agent without using mTLS!\")\n            post_ukey = RequestsClient(cloudagent_base_url, tls_enabled=False)\n            response = post_ukey.post(params, json=data)\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Agent at %s with Port %s. Connection refused.\", self.agent_ip, self.agent_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n            raise UserError(\n                f\"Posting of Encrypted U to the Cloud Agent failed with response code {response.status_code} ({response.text})\")\n\n    def do_verify(self):\n        \"\"\" Perform verify using a random generated challenge\n        \"\"\"\n        challenge = TPM_Utilities.random_password(20)\n        numtries = 0\n\n        while True:\n            response = None\n            try:\n                cloudagent_base_url = (\n                    f'{self.agent_ip}:{self.agent_port}'\n                )\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True,\n                                        cert=self.agent_cert, verify_custom=self.registrar_data['mtls_cert']) as do_verify:\n                        response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_verify = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n\n                response_body = response.json()\n            except Exception as e:\n                if response is not None and response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        self.do_cvstop()\n                        sys.exit()\n                    interval = config.getfloat('tenant', 'retry_interval')\n                    exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                    next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                    logger.info(\"Verifier connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, next_retry)\n                    time.sleep(next_retry)\n                    continue\n                self.do_cvstop()\n                raise e\n            if response.status_code == 200:\n                if \"results\" not in response_body or 'hmac' not in response_body['results']:\n                    logger.critical(\"Error: unexpected http response body from Cloud Agent: %s\", response.status_code)\n                    self.do_cvstop()\n                    break\n                mac = response_body['results']['hmac']\n\n                ex_mac = crypto.do_hmac(self.K, challenge)\n\n                if mac == ex_mac:\n                    logger.info(\"Key derivation successful\")\n                else:\n                    logger.error(\"Key derivation failed\")\n                    self.do_cvstop()\n            else:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                numtries += 1\n                maxr = config.getint('tenant', 'max_retries')\n                if numtries >= maxr:\n                    logger.error(\"Agent on %s with port %s failed key derivation\", self.agent_ip, self.agent_port)\n                    self.do_cvstop()\n                    sys.exit()\n                interval = config.getfloat('tenant', 'retry_interval')\n                exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                logger.info(\"Key derivation not yet complete (retry %s/%s), trying again in %s seconds... (Ctrl-C to stop)\",\n                    numtries, maxr, next_retry)\n                time.sleep(next_retry)\n                continue\n            break\n\n    def do_add_allowlist(self, args):\n        if 'allowlist_name' not in args or not args['allowlist_name']:\n            raise UserError('allowlist_name is required to add an allowlist')\n\n        allowlist_name = args['allowlist_name']\n        self.process_allowlist(args)\n        data = {\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'allowlist': json.dumps(self.allowlist)\n        }\n        body = json.dumps(data)\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.post(f'/v{self.api_version}/allowlists/{allowlist_name}', data=body,\n                                  cert=self.cert, verify=self.verifier_ca_cert)\n        Tenant._print_json_response(response)\n\n    def do_delete_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.delete(f'/v{self.api_version}/allowlists/{name}',\n                                    cert=self.cert, verify=self.verifier_ca_cert)\n        Tenant._print_json_response(response)\n\n    def do_show_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.get(f'/v{self.api_version}/allowlists/{name}',\n                                 cert=self.cert, verify=self.verifier_ca_cert)\n        print(f\"Show allowlist command response: {response.status_code}.\")\n        Tenant._print_json_response(response)\n\n    @staticmethod\n    def _print_json_response(response):\n        try:\n            json_response = response.json()\n        except ValueError:\n            json_response = '{}'\n        print(json_response)\n\n\ndef write_to_namedtempfile(data, delete_tmp_files):\n    temp = tempfile.NamedTemporaryFile(prefix=\"keylime-\", delete=delete_tmp_files)  #pylint: disable=consider-using-with\n    temp.write(data)\n    temp.flush()\n    return temp.name\n\ndef main(argv=sys.argv):  #pylint: disable=dangerous-default-value\n    \"\"\"[summary]\n\n    Keyword Arguments:\n        argv {[type]} -- [description] (default: {sys.argv})\n\n    Raises:\n        UserError: [description]\n        UserError: [description]\n        UserError: [description]\n    \"\"\"\n    parser = argparse.ArgumentParser(argv[0])\n    parser.add_argument('-c', '--command', action='store', dest='command', default='add',\n                        help=\"valid commands are add,delete,update,\"\n                             \"regstatus,cvstatus,status,reglist,cvlist,reactivate,\"\n                             \"regdelete,bulkinfo,addallowlist,showallowlist,deleteallowlist. defaults to add\")\n    parser.add_argument('-t', '--targethost', action='store',\n                        dest='agent_ip', help=\"the IP address of the host to provision\")\n    parser.add_argument('-tp', '--targetport', action='store',\n                        dest='agent_port', help=\"the Port of the host to provision\")\n    parser.add_argument('-r', '--registrarhost', action='store',\n                        dest='registrar_ip', help=\"the IP address of the registrar where to retrieve the agents data from.\")\n    parser.add_argument('-rp', '--registrarport', action=\"store\",\n                        dest='registrar_port', help=\"the port of the registrar.\")\n    parser.add_argument('--cv_targethost', action='store', default=None, dest='cv_agent_ip',\n                        help='the IP address of the host to provision that the verifier will use (optional).  Use only if different than argument to option -t/--targethost')\n    parser.add_argument('-v', '--cv', action='store', dest='verifier_ip',\n                        help=\"the IP address of the cloud verifier\")\n    parser.add_argument('-vp', '--cvport', action='store', dest='verifier_port',\n                        help=\"the port of the cloud verifier\")\n    parser.add_argument('-vi', '--cvid', action='store', dest='verifier_id',\n                        help=\"the unique identifier of a cloud verifier\")\n    parser.add_argument('-nvc', '--no-verifier-check', action='store_false', dest='verifier_check', default=True,\n                        help='Disable the check to confirm if the agent is being processed by the specified verifier. Use only with -c/--command delete or reactivate')\n    parser.add_argument('-u', '--uuid', action='store',\n                        dest='agent_uuid', help=\"UUID for the agent to provision\")\n    parser.add_argument('-f', '--file', action='store', default=None,\n                        help='Deliver the specified plaintext to the provisioned agent')\n    parser.add_argument('--cert', action='store', dest='ca_dir', default=None,\n                        help='Create and deliver a certificate using a CA created by ca-util. Pass in the CA directory or use \"default\" to use the standard dir')\n    parser.add_argument('-k', '--key', action='store', dest='keyfile',\n                        help='an intermedia key file produced by user_data_encrypt')\n    parser.add_argument('-p', '--payload', action='store', default=None,\n                        help='Specify the encrypted payload to deliver with encrypted keys specified by -k')\n    parser.add_argument('--include', action='store', dest='incl_dir', default=None,\n                        help=\"Include additional files in provided directory in certificate zip file.  Must be specified with --cert\")\n    parser.add_argument('--allowlist', action='store', dest='allowlist',\n                        default=None, help=\"Specify the file path of an allowlist\")\n    parser.add_argument('--signature-verification-key', '--sign_verification_key', action='append', dest='ima_sign_verification_keys',\n                        default=[], help=\"Specify an IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig', action='append', dest='ima_sign_verification_key_sigs',\n                        default=[], help=\"Specify the GPG signature file for an IMA file signature verification key; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-sig-key', action='append', dest='ima_sign_verification_key_sig_keys',\n                        default=[], help=\"Specify the GPG public key file use to validate the --signature-verification-key-sig; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-url', action='append', dest='ima_sign_verification_key_urls',\n                        default=[], help=\"Specify the URL for a remote IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig-url', action='append',\n                        dest='ima_sign_verification_key_sig_urls',\n                        default=[], help=\"Specify the URL for the remote GPG signature of a remote IMA file signature verification key; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--signature-verification-key-sig-url-key', action='append',\n                        dest='ima_sign_verification_key_sig_url_keys',\n                        default=[], help=\"Specify the GPG public key file used to validate the --signature-verification-key-sig-url; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--mb_refstate', action='store', dest='mb_refstate',\n                        default=None, help=\"Specify the location of a measure boot reference state (intended state)\")\n    parser.add_argument('--allowlist-checksum', action='store', dest='allowlist_checksum',\n                        default=None, help=\"Specify the SHA-256 checksum of an allowlist\")\n    parser.add_argument('--allowlist-sig', action='store', dest='allowlist_sig',\n                        default=None, help=\"Specify the GPG signature file of an allowlist\")\n    parser.add_argument('--allowlist-sig-key', action='store', dest='allowlist_sig_key',\n                        default=None, help=\"Specify the GPG public key file used to validate the --allowlist-sig or --allowlist-sig-url\")\n    parser.add_argument('--allowlist-url', action='store', dest='allowlist_url',\n                        default=None, help=\"Specify the URL of a remote allowlist\")\n    parser.add_argument('--allowlist-sig-url', action='store', dest='allowlist_sig_url',\n                        default=None, help=\"Specify the URL of the remote GPG signature file of an allowlist\")\n    parser.add_argument('--exclude', action='store', dest='ima_exclude',\n                        default=None, help=\"Specify the location of an IMA exclude list\")\n    parser.add_argument('--tpm_policy', action='store', dest='tpm_policy', default=None,\n                        help=\"Specify a TPM policy in JSON format. e.g., {\\\"15\\\":\\\"0000000000000000000000000000000000000000\\\"}\")\n    parser.add_argument('--verify', action='store_true', default=False,\n                        help='Block on cryptographically checked key derivation confirmation from the agent once it has been provisioned')\n    parser.add_argument('--allowlist-name', help='The name of allowlist to operate with')\n    parser.add_argument('--supported-version', default=None, action=\"store\", dest='supported_version', help='API version that is supported by the agent. Detected automatically by default')\n\n    args = parser.parse_args(argv[1:])\n\n    # Make sure argument dependencies are enforced\n    if( args.allowlist and args.allowlist_url):\n        parser.error(\"--allowlist and --allowlist-url cannot be specified at the same time\")\n    if( args.allowlist_url and not (args.allowlist_sig or args.allowlist_sig_url or args.allowlist_checksum)):\n        parser.error(\"--allowlist-url must have either --allowlist-sig, --allowlist-sig-url or --allowlist-checksum to verifier integrity\")\n    if( args.allowlist_sig and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig_url and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig-url must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_checksum and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-checksum must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_url and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig-url must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_key and not (args.allowlist_sig or args.allowlist_sig_url)):\n        parser.error(\"--allowlist-sig-key must have either --allowlist-sig or --allowlist-sig-url\")\n\n    mytenant = Tenant()\n\n    if args.agent_uuid is not None:\n        mytenant.agent_uuid = args.agent_uuid\n        # if the uuid is actually a public key, then hash it\n        if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):\n            mytenant.agent_uuid = hashlib.sha256(\n                mytenant.agent_uuid).hexdigest()\n        if not validators.valid_agent_id(mytenant.agent_uuid):\n            raise UserError(\"The agent ID set via agent uuid parameter use invalid characters\")\n    else:\n        logger.warning(\"Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000\")\n        mytenant.agent_uuid = \"d432fbb3-d2f1-4a97-9ef7-75bd81c00000\"\n\n    if args.verifier_id is not None:\n        mytenant.verifier_id = args.verifier_id\n    if args.verifier_ip is not None:\n        mytenant.verifier_ip = args.verifier_ip\n    if args.verifier_port is not None:\n        mytenant.verifier_port = args.verifier_port\n\n    if args.registrar_ip is not None:\n        mytenant.registrar_ip = args.registrar_ip\n    if args.registrar_port is not None:\n        mytenant.registrar_port = args.registrar_port\n\n    # we only need to fetch remote files if we are adding or updating\n    if args.command in ['add', 'update', 'addallowlist']:\n        delete_tmp_files = logger.level > logging.DEBUG # delete tmp files unless in DEBUG mode\n\n        if args.allowlist_url:\n            logger.info(\"Downloading Allowlist from %s\", args.allowlist_url)\n            response = requests.get(args.allowlist_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist temporarily saved in %s\", args.allowlist)\n            else:\n                raise Exception(f\"Downloading allowlist ({args.allowlist_url}) failed with status code {response.status_code}!\")\n\n        if args.allowlist_sig_url:\n            logger.info(\"Downloading Allowlist signature from %s\", args.allowlist_sig_url)\n            response = requests.get(args.allowlist_sig_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist_sig = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist signature temporarily saved in %s\", args.allowlist_sig)\n            else:\n                raise Exception(f\"Downloading allowlist signature ({args.allowlist_sig_url}) failed with status code {response.status_code}!\")\n\n        # verify all the local keys for which we have a signature file and a key to verify\n        for i, key_file in enumerate(args.ima_sign_verification_keys):\n            if len(args.ima_sign_verification_key_sigs) <= i:\n                break\n            keysig_file = args.ima_sign_verification_key_sigs[i]\n            if len(args.ima_sign_verification_key_sig_keys) == 0:\n                raise UserError(f\"A gpg key is missing for key signature file '{keysig_file}'\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_keys[i]\n            signing.verify_signature_from_file(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n\n            logger.info(\"Signature verification on %s was successful\", key_file)\n\n        # verify all the remote keys for which we have a signature URL and key to to verify\n        # Append the downloaded key files to args.ima_sign_verification_keys\n        for i, key_url in enumerate(args.ima_sign_verification_key_urls):\n\n            logger.info(\"Downloading key from %s\", key_url)\n            response = requests.get(key_url, allow_redirects=False)\n            if response.status_code == 200:\n                key_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                args.ima_sign_verification_keys.append(key_file)\n                logger.debug(\"Key temporarily saved in %s\", key_file)\n            else:\n                raise Exception(f\"Downloading key ({key_url}) failed with status code {response.status_code}!\")\n\n            if len(args.ima_sign_verification_key_sig_urls) <= i:\n                continue\n\n            keysig_url = args.ima_sign_verification_key_sig_urls[i]\n\n            if len(args.ima_sign_verification_key_sig_url_keys) == 0:\n                raise UserError(f\"A gpg key is missing for key signature URL '{keysig_url}'\")\n\n            logger.info(\"Downloading key signature from %s\", keysig_url)\n            response = requests.get(keysig_url, allow_redirects=False)\n            if response.status_code == 200:\n                keysig_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Key signature temporarily saved in %s\", keysig_file)\n            else:\n                raise Exception(f\"Downloading key signature ({key_url}) failed with status code {response.status_code}!\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_url_keys[i]\n            signing.verify_signature_from_file(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n            logger.info(\"Signature verification on %s was successful\", key_url)\n\n    if args.command == 'add':\n        mytenant.init_add(vars(args))\n        mytenant.preloop()\n        mytenant.do_quote()\n        mytenant.do_cv()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'update':\n        mytenant.init_add(vars(args))\n        mytenant.do_cvdelete(args.verifier_check)\n        mytenant.preloop()\n        mytenant.do_quote()\n        mytenant.do_cv()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'delete':\n        mytenant.do_cvdelete(args.verifier_check)\n    elif args.command == 'status':\n        mytenant.do_status()\n    elif args.command == 'cvstatus':\n        mytenant.do_cvstatus()\n    elif args.command == 'bulkinfo':\n        mytenant.do_cvbulkinfo()\n    elif args.command == 'cvlist':\n        mytenant.do_cvlist()\n    elif args.command == 'reactivate':\n        mytenant.do_cvreactivate(args.verifier_check)\n    elif args.command == 'regstatus':\n        mytenant.do_regstatus()\n    elif args.command == 'reglist':\n        mytenant.do_reglist()\n    elif args.command == 'regdelete':\n        mytenant.do_regdelete()\n    elif args.command == 'addallowlist':\n        mytenant.do_add_allowlist(vars(args))\n    elif args.command == 'showallowlist':\n        mytenant.do_show_allowlist(args.allowlist_name)\n    elif args.command == 'deleteallowlist':\n        mytenant.do_delete_allowlist(args.allowlist_name)\n    else:\n        raise UserError(f\"Invalid command specified: {args.command}\")\n"], "fixing_code": ["#!/usr/bin/python3\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\nimport signal\nimport traceback\nimport sys\nimport functools\nimport asyncio\nimport os\nfrom multiprocessing import Process\n\n\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime import config\nfrom keylime import json\nfrom keylime.agentstates import AgentAttestStates\nfrom keylime.common import states, validators, retry\nfrom keylime.db.verifier_db import VerfierMain\nfrom keylime.db.verifier_db import VerifierAllowlist\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import keylime_logging\nfrom keylime import cloud_verifier_common\nfrom keylime import revocation_notifier\nfrom keylime import web_util\nfrom keylime import tornado_requests\nfrom keylime import api_version as keylime_api_version\nfrom keylime.failure import MAX_SEVERITY_LABEL, Failure, Component\n\nlogger = keylime_logging.init_logging('cloudverifier')\n\n\ntry:\n    engine = DBEngineManager().make_engine('cloud_verifier')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine or session: %s', err)\n    sys.exit(1)\n\n\ndef get_session():\n    return SessionManager().make_session(engine)\n\n\ndef get_AgentAttestStates():\n    return AgentAttestStates.get_instance()\n\n\n# The \"exclude_db\" dict values are removed from the response before adding the dict to the DB\n# This is because we want these values to remain ephemeral and not stored in the database.\nexclude_db = {\n    'registrar_data': '',\n    'nonce': '',\n    'b64_encrypted_V': '',\n    'provide_V': True,\n    'num_retries': 0,\n    'pending_event': None,\n    'first_verified': False,\n    # the following 3 items are updated to VerifierDB only when the AgentState is stored\n    'boottime': '',\n    'ima_pcrs': [],\n    'pcr10': '',\n    'next_ima_ml_entry': 0,\n    'learned_ima_keyrings': {},\n    'ssl_context': None,\n}\n\n\ndef _from_db_obj(agent_db_obj):\n    fields = [ 'agent_id', \\\n                'v', \\\n                'ip', \\\n                'port', \\\n                'operational_state', \\\n                'public_key', \\\n                'tpm_policy', \\\n                'meta_data', \\\n                'mb_refstate', \\\n                'allowlist', \\\n                'ima_sign_verification_keys', \\\n                'revocation_key', \\\n                'accept_tpm_hash_algs', \\\n                'accept_tpm_encryption_algs', \\\n                'accept_tpm_signing_algs', \\\n                'hash_alg', \\\n                'enc_alg', \\\n                'sign_alg', \\\n                'boottime', \\\n                'ima_pcrs', \\\n                'pcr10', \\\n                'next_ima_ml_entry', \\\n                'learned_ima_keyrings',\n                'supported_version',\n                'mtls_cert',\n                'ak_tpm',\n               ]\n    agent_dict = {}\n    for field in fields:\n        agent_dict[field] = getattr(agent_db_obj, field, None)\n\n    # add default fields that are ephemeral\n    for key,val in exclude_db.items():\n        agent_dict[key] = val\n\n    return agent_dict\n\n\ndef verifier_db_delete_agent(session, agent_id):\n    get_AgentAttestStates().delete_by_agent_id(agent_id)\n    session.query(VerfierMain).filter_by(\n                  agent_id=agent_id).delete()\n    session.commit()\n\n\ndef store_attestation_state(agentAttestState):\n    # Only store if IMA log was evaluated\n    if agentAttestState.get_ima_pcrs():\n        session = get_session()\n        try:\n            update_agent = session.query(VerfierMain).get(agentAttestState.get_agent_id())\n            update_agent.boottime = agentAttestState.get_boottime()\n            update_agent.next_ima_ml_entry = agentAttestState.get_next_ima_ml_entry()\n            ima_pcrs_dict = agentAttestState.get_ima_pcrs()\n            update_agent.ima_pcrs = list(ima_pcrs_dict.keys())\n            for pcr_num, value in ima_pcrs_dict.items():\n                setattr(update_agent, f'pcr{pcr_num}', value)\n            update_agent.learned_ima_keyrings = agentAttestState.get_ima_keyrings().to_json()\n            try:\n                session.add(update_agent)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n    def prepare(self):  # pylint: disable=W0235\n        super().prepare()\n\n    def write_error(self, status_code, **kwargs):\n\n        self.set_header('Content-Type', 'text/json')\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'traceback': lines,\n                'results': {},\n            }))\n        else:\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'results': {},\n            }))\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\nclass VersionHandler(BaseHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def get(self):\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET returning 400 response. URI not supported: %s', self.request.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    mtls_options = None  # Stores the cert, key and password used by the verifier for mTLS connections\n\n    def initialize(self, mtls_options):\n        self.mtls_options = mtls_options\n\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. Agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.  If the agent_id\n        was not found, it either completed successfully, or failed.  If found, the agent_id is still polling\n        to contact the Cloud Agent.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if (agent_id is not None) and (agent_id != ''):\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id).one_or_none()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is not None:\n                response = cloud_verifier_common.process_get_status(agent)\n                web_util.echo_json_response(self, 200, \"Success\", response)\n            else:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n        else:\n            json_response = None\n            if \"bulk\" in rest_params:\n                agent_list = None\n\n                if (\"verifier\" in rest_params) and (rest_params[\"verifier\"] != ''):\n                    agent_list = session.query(VerfierMain).filter_by(verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    agent_list = session.query(VerfierMain).all()\n\n                json_response = {}\n                for agent in agent_list:\n                    json_response[agent.agent_id] = cloud_verifier_common.process_get_status(agent)\n\n                web_util.echo_json_response(self, 200, \"Success\", json_response)\n            else:\n                if (\"verifier\" in rest_params) and (rest_params[\"verifier\"] != ''):\n                    json_response = session.query(VerfierMain.agent_id).filter_by(\n                        verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    json_response = session.query(VerfierMain.agent_id).all()\n\n                web_util.echo_json_response(self, 200, \"Success\", {\n                    'uuids': json_response})\n\n            logger.info('GET returning 200 response for agent_id list')\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n            return\n\n        try:\n            agent = session.query(VerfierMain).filter_by(\n                agent_id=agent_id).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        if agent is None:\n            web_util.echo_json_response(self, 404, \"agent id not found\")\n            logger.info('DELETE returning 404 response. agent id: %s not found.', agent_id)\n            return\n\n        verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n        if verifier_id != agent.verifier_id:\n            web_util.echo_json_response(self, 404, \"agent id associated to this verifier\")\n            logger.info('DELETE returning 404 response. agent id: %s not associated to this verifer.', agent_id)\n            return\n\n        op_state = agent.operational_state\n        if op_state in (states.SAVED, states.FAILED, states.TERMINATED,\n                        states.TENANT_FAILED, states.INVALID_QUOTE):\n            try:\n                verifier_db_delete_agent(session, agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('DELETE returning 200 response for agent id: %s', agent_id)\n        else:\n            try:\n                update_agent = session.query(VerfierMain).get(agent_id)\n                update_agent.operational_state = states.TERMINATED\n                try:\n                    session.add(update_agent)\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                session.commit()\n                web_util.echo_json_response(self, 202, \"Accepted\")\n                logger.info('DELETE returning 202 response for agent id: %s', agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is not None:\n                # If the agent ID is not valid (wrong set of\n                # characters), just do nothing.\n                if not validators.valid_agent_id(agent_id):\n                    web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                    logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n                    return\n\n                content_length = len(self.request.body)\n                if content_length == 0:\n                    web_util.echo_json_response(\n                        self, 400, \"Expected non zero content length\")\n                    logger.warning('POST returning 400 response. Expected non zero content length.')\n                else:\n                    json_body = json.loads(self.request.body)\n                    agent_data = {}\n                    agent_data['v'] = json_body['v']\n                    agent_data['ip'] = json_body['cloudagent_ip']\n                    agent_data['port'] = int(json_body['cloudagent_port'])\n                    agent_data['operational_state'] = states.START\n                    agent_data['public_key'] = \"\"\n                    agent_data['tpm_policy'] = json_body['tpm_policy']\n                    agent_data['meta_data'] = json_body['metadata']\n                    agent_data['allowlist'] = json_body['allowlist']\n                    agent_data['mb_refstate'] = json_body['mb_refstate']\n                    agent_data['ima_sign_verification_keys'] = json_body['ima_sign_verification_keys']\n                    agent_data['revocation_key'] = json_body['revocation_key']\n                    agent_data['accept_tpm_hash_algs'] = json_body['accept_tpm_hash_algs']\n                    agent_data['accept_tpm_encryption_algs'] = json_body['accept_tpm_encryption_algs']\n                    agent_data['accept_tpm_signing_algs'] = json_body['accept_tpm_signing_algs']\n                    agent_data['supported_version'] = json_body['supported_version']\n                    agent_data['ak_tpm'] = json_body['ak_tpm']\n                    agent_data['mtls_cert'] = json_body.get('mtls_cert', None)\n                    agent_data['hash_alg'] = \"\"\n                    agent_data['enc_alg'] = \"\"\n                    agent_data['sign_alg'] = \"\"\n                    agent_data['agent_id'] = agent_id\n                    agent_data['boottime'] = 0\n                    agent_data['ima_pcrs'] = []\n                    agent_data['pcr10'] = None\n                    agent_data['next_ima_ml_entry'] = 0\n                    agent_data['learned_ima_keyrings'] = {}\n                    agent_data['verifier_id'] = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                    agent_data['verifier_ip'] = config.get('cloud_verifier', 'cloudverifier_ip')\n                    agent_data['verifier_port'] = config.get('cloud_verifier', 'cloudverifier_port')\n\n                    # TODO: Always error for v1.0 version after initial upgrade\n                    if agent_data['mtls_cert'] is None and agent_data['supported_version'] != \"1.0\":\n                        web_util.echo_json_response(self, 400, \"mTLS certificate for agent is required!\")\n                        return\n\n                    is_valid, err_msg = cloud_verifier_common.validate_agent_data(agent_data)\n                    if not is_valid:\n                        web_util.echo_json_response(self, 400, err_msg)\n                        logger.warning(err_msg)\n                        return\n\n                    try:\n                        new_agent_count = session.query(\n                            VerfierMain).filter_by(agent_id=agent_id).count()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise e\n\n                    # don't allow overwriting\n\n                    if new_agent_count > 0:\n                        web_util.echo_json_response(\n                            self, 409, f\"Agent of uuid {agent_id} already exists\")\n                        logger.warning(\"Agent of uuid %s already exists\", agent_id)\n                    else:\n                        try:\n                            # Add the agent and data\n                            session.add(VerfierMain(**agent_data))\n                            session.commit()\n                        except SQLAlchemyError as e:\n                            logger.error('SQLAlchemy Error: %s', e)\n                            raise e\n\n                        # add default fields that are ephemeral\n                        for key,val in exclude_db.items():\n                            agent_data[key] = val\n\n                        # Prepare SSLContext for mTLS connections\n                        agent_mtls_cert_enabled = config.getboolean('cloud_verifier', 'agent_mtls_cert_enabled', fallback=False)\n                        mtls_cert = agent_data['mtls_cert']\n                        agent_data['ssl_context'] = None\n                        if agent_mtls_cert_enabled and mtls_cert:\n                            agent_data['ssl_context'] = web_util.generate_agent_mtls_context(mtls_cert, self.mtls_options)\n\n                        if agent_data['ssl_context'] is None:\n                            logger.warning('Connecting to agent without mTLS: %s', agent_id)\n\n                        asyncio.ensure_future(\n                            process_agent(agent_data, states.GET_QUOTE))\n                        web_util.echo_json_response(self, 200, \"Success\")\n                        logger.info('POST returning 200 response for adding agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"POST returning 400 response. uri not supported\")\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Exception error: {str(e)}\")\n            logger.warning(\"POST returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is None:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id, verifier_id=verifier_id).one()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise e\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n                logger.info('PUT returning 404 response. agent id: %s not found.', agent_id)\n                return\n\n            if \"reactivate\" in rest_params:\n                if not isinstance(agent, dict):\n                    agent = _from_db_obj(agent)\n                if agent[\"mtls_cert\"]:\n                    agent['ssl_context'] = web_util.generate_agent_mtls_context(agent[\"mtls_cert\"], self.mtls_options)\n                agent[\"operational_state\"] = states.START\n                asyncio.ensure_future(\n                    process_agent(agent, states.GET_QUOTE))\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            elif \"stop\" in rest_params:\n                # do stuff for terminate\n                logger.debug(\"Stopping polling on %s\", agent_id)\n                try:\n                    session.query(VerfierMain).filter(VerfierMain.agent_id == agent_id).update(\n                        {'operational_state': states.TENANT_FAILED})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Exception error: {str(e)}\")\n            logger.warning(\"PUT returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AllowlistHandler(BaseHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: HEAD Not Implemented\")\n\n    def get(self):\n        \"\"\"Get an allowlist\n\n        GET /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'GET returning 400 response: %s', self.request.path)\n            return\n\n        session = get_session()\n        try:\n            allowlist = session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, f\"Allowlist {allowlist_name} not found\")\n            return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        response = {}\n        for field in ('name', 'tpm_policy', 'ima_policy'):\n            response[field] = getattr(allowlist, field, None)\n        web_util.echo_json_response(self, 200, 'Success', response)\n\n    def delete(self):\n        \"\"\"Delete an allowlist\n\n        DELETE /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'DELETE returning 400 response: %s', self.request.path)\n            return\n\n        session = get_session()\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, f\"Allowlist {allowlist_name} not found\")\n            return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).delete()\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        # NOTE(kaifeng) 204 Can not have response body, but current helper\n        # doesn't support this case.\n        self.set_status(204)\n        self.set_header('Content-Type', 'application/json')\n        self.finish()\n        logger.info(\n            'DELETE returning 204 response for allowlist: %s', allowlist_name)\n\n    def post(self):\n        \"\"\"Create an allowlist\n\n        POST /allowlists/{name}\n        body: {\"tpm_policy\": {..} ...\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not web_util.validate_api_version(self, rest_params[\"api_version\"], logger):\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        content_length = len(self.request.body)\n        if content_length == 0:\n            web_util.echo_json_response(\n                self, 400, \"Expected non zero content length\")\n            logger.warning(\n                'POST returning 400 response. Expected non zero content length.')\n            return\n\n        allowlist = {}\n        json_body = json.loads(self.request.body)\n        allowlist['name'] = allowlist_name\n        tpm_policy = json_body.get('tpm_policy')\n        if tpm_policy:\n            allowlist['tpm_policy'] = tpm_policy\n        ima_policy = json_body.get('ima_policy')\n        if ima_policy:\n            allowlist['ima_policy'] = ima_policy\n\n        session = get_session()\n        # don't allow overwritting\n        try:\n            al_count = session.query(\n                VerifierAllowlist).filter_by(name=allowlist_name).count()\n            if al_count > 0:\n                web_util.echo_json_response(\n                    self, 409, f\"Allowlist with name {allowlist_name} already exists\")\n                logger.warning(\n                    \"Allowlist with name %s already exists\", allowlist_name)\n                return\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            raise\n\n        try:\n            # Add the agent and data\n            session.add(VerifierAllowlist(**allowlist))\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n            raise\n\n        web_util.echo_json_response(self, 201)\n        logger.info('POST returning 201')\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: PUT Not Implemented\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nasync def invoke_get_quote(agent, need_pubkey):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"agent deleted while being processed\")\n    params = cloud_verifier_common.prepare_get_quote(agent)\n\n    partial_req = \"1\"\n    if need_pubkey:\n        partial_req = \"0\"\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\"GET\",\n                                       f\"https://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/quotes/integrity\"\n                                       f\"?nonce={params['nonce']}&mask={params['mask']}\"\n                                       f\"&partial={partial_req}&ima_ml_entry={params['ima_ml_entry']}\",\n                                       context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\"GET\",\n                                       f\"http://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/quotes/integrity\"\n                                       f\"?nonce={params['nonce']}&mask={params['mask']}\"\n                                       f\"&partial={partial_req}&ima_ml_entry={params['ima_ml_entry']}\")\n    response = await res\n\n    if response.status_code != 200:\n        # this is a connection error, retry get quote\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(process_agent(\n                agent, states.GET_QUOTE_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Get Quote response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_quote\", \"Unexpected Get Quote reponse from agent\", False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        try:\n            json_response = json.loads(response.body)\n\n            # validate the cloud agent response\n            if 'provide_V' not in agent :\n                agent['provide_V'] = True\n            agentAttestState = get_AgentAttestStates().get_by_agent_id(agent['agent_id'])\n            failure = cloud_verifier_common.process_quote_response(agent, json_response['results'], agentAttestState)\n            if not failure:\n                if agent['provide_V']:\n                    asyncio.ensure_future(process_agent(agent, states.PROVIDE_V))\n                else:\n                    asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n            else:\n                asyncio.ensure_future(process_agent(agent, states.INVALID_QUOTE, failure))\n\n            # store the attestation state\n            store_attestation_state(agentAttestState)\n\n        except Exception as e:\n            logger.exception(e)\n\n\nasync def invoke_provide_v(agent):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"Agent deleted while being processed\")\n    try:\n        if agent['pending_event'] is not None:\n            agent['pending_event'] = None\n    except KeyError:\n        pass\n    v_json_message = cloud_verifier_common.prepare_v(agent)\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\n            \"POST\", f\"https://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/keys/vkey\",\n            data=v_json_message, context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\n            \"POST\", f\"http://{agent['ip']}:{agent['port']}/v{agent['supported_version']}/keys/vkey\",\n            data=v_json_message)\n\n    response = await res\n\n    if response.status_code != 200:\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(\n                process_agent(agent, states.PROVIDE_V_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Provide V response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_v\", {\"message\": \"Unexpected provide V response\", \"data\": response.status_code}, False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n\n\nasync def process_agent(agent, new_operational_state, failure=Failure(Component.INTERNAL, [\"verifier\"])):\n    # Convert to dict if the agent arg is a db object\n    if not isinstance(agent, dict):\n        agent = _from_db_obj(agent)\n\n    session = get_session()\n    try:  # pylint: disable=R1702\n        main_agent_operational_state = agent['operational_state']\n        try:\n            stored_agent = session.query(VerfierMain).filter_by(\n                agent_id=str(agent['agent_id'])).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # if the user did terminated this agent\n        if stored_agent.operational_state == states.TERMINATED:\n            logger.warning(\"Agent %s terminated by user.\", agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            verifier_db_delete_agent(session, agent['agent_id'])\n            return\n\n        # if the user tells us to stop polling because the tenant quote check failed\n        if stored_agent.operational_state == states.TENANT_FAILED:\n            logger.warning(\"Agent %s has failed tenant quote. Stopping polling\",  agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            return\n\n        # If failed during processing, log regardless and drop it on the floor\n        # The administration application (tenant) can GET the status and act accordingly (delete/retry/etc).\n        if new_operational_state in (states.FAILED, states.INVALID_QUOTE):\n            assert failure, \"States FAILED and INVALID QUOTE should only be reached with a failure message\"\n\n            if agent.get('severity_level') is None or agent['severity_level'] < failure.highest_severity.severity:\n                agent['severity_level'] = failure.highest_severity.severity\n                agent['last_event_id'] = failure.highest_severity_event.event_id\n                agent['operational_state'] = new_operational_state\n\n                # issue notification for invalid quotes\n                if new_operational_state == states.INVALID_QUOTE:\n                    cloud_verifier_common.notify_error(agent, event=failure.highest_severity_event)\n\n                # When the failure is irrecoverable we stop polling the agent\n                if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                    if agent['pending_event'] is not None:\n                        tornado.ioloop.IOLoop.current().remove_timeout(\n                            agent['pending_event'])\n                    for key in exclude_db:\n                        if key in agent:\n                            del agent[key]\n                    session.query(VerfierMain).filter_by(\n                        agent_id=agent['agent_id']).update(agent)\n                    session.commit()\n\n        # propagate all state, but remove none DB keys first (using exclude_db)\n        try:\n            agent_db = dict(agent)\n            for key in exclude_db:\n                if key in agent_db:\n                    del agent_db[key]\n\n            session.query(VerfierMain).filter_by(\n                agent_id=agent_db['agent_id']).update(agent_db)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # If agent was in a failed state we check if we either stop polling\n        # or just add it again to the event loop\n        if new_operational_state in [states.FAILED, states.INVALID_QUOTE]:\n            if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                logger.warning(\"Agent %s failed, stopping polling\", agent['agent_id'])\n                return\n\n            await invoke_get_quote(agent, False)\n            return\n\n        # if new, get a quote\n        if (main_agent_operational_state == states.START and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.GET_QUOTE\n            await invoke_get_quote(agent, True)\n            return\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.PROVIDE_V):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.PROVIDE_V\n            await invoke_provide_v(agent)\n            return\n\n        if (main_agent_operational_state in (states.PROVIDE_V, states.GET_QUOTE) and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            interval = config.getfloat('cloud_verifier', 'quote_interval')\n            agent['operational_state'] = states.GET_QUOTE\n            if interval == 0:\n                await invoke_get_quote(agent, False)\n            else:\n                logger.debug(\"Setting up callback to check again in %f seconds\", interval)\n                # set up a call back to check again\n                cb = functools.partial(invoke_get_quote, agent, False)\n                pending = tornado.ioloop.IOLoop.current().call_later(interval, cb)\n                agent['pending_event'] = pending\n            return\n\n        maxr = config.getint('cloud_verifier', 'max_retries')\n        interval = config.getfloat('cloud_verifier', 'retry_interval')\n        exponential_backoff = config.getboolean('cloud_verifier', 'exponential_backoff')\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.GET_QUOTE_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable for quote in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable\", \"agent was not reachable from verifier\", False)\n                if agent['first_verified']:  # only notify on previously good agents\n                    cloud_verifier_common.notify_error(\n                        agent, msgtype='comm_error', event=failure.highest_severity_event)\n                else:\n                    logger.debug(\"Communication error for new agent. No notification will be sent\")\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.GET_QUOTE\n                cb = functools.partial(invoke_get_quote, agent, True)\n                agent['num_retries'] += 1\n                next_retry = retry.retry_time(exponential_backoff, interval, agent['num_retries'], logger)\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, next_retry)\n                tornado.ioloop.IOLoop.current().call_later(next_retry, cb)\n            return\n\n        if (main_agent_operational_state == states.PROVIDE_V and\n                new_operational_state == states.PROVIDE_V_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable to provide v in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable_v\", \"agent was not reachable to provide V\", False)\n                cloud_verifier_common.notify_error(\n                    agent, msgtype='comm_error', event=failure.highest_severity_event)\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.PROVIDE_V\n                cb = functools.partial(invoke_provide_v, agent)\n                agent['num_retries'] += 1\n                next_retry = retry.retry_time(exponential_backoff, interval, agent['num_retries'], logger)\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, next_retry)\n                tornado.ioloop.IOLoop.current().call_later(next_retry, cb)\n            return\n        raise Exception(\"nothing should ever fall out of this!\")\n\n    except Exception as e:\n        logger.error(\"Polling thread error: %s\", e)\n        logger.exception(e)\n\n\nasync def activate_agents(verifier_id, verifier_ip, verifier_port, mtls_options):\n    session = get_session()\n    aas = get_AgentAttestStates()\n    try:\n        agents = session.query(VerfierMain).filter_by(\n            verifier_id=verifier_id).all()\n        for agent in agents:\n            agent.verifier_ip = verifier_ip\n            agent.verifier_host = verifier_port\n            agent_run = _from_db_obj(agent)\n            if agent_run[\"mtls_cert\"]:\n                agent_run[\"ssl_context\"] = web_util.generate_agent_mtls_context(agent_run[\"mtls_cert\"], mtls_options)\n            if agent.operational_state == states.START:\n                asyncio.ensure_future(process_agent(agent_run, states.GET_QUOTE))\n            if agent.boottime:\n                ima_pcrs_dict = {}\n                for pcr_num in agent.ima_pcrs:\n                    ima_pcrs_dict[pcr_num] = getattr(agent, f'pcr{pcr_num}')\n                aas.add(agent.agent_id, agent.boottime, ima_pcrs_dict, agent.next_ima_ml_entry, agent.learned_ima_keyrings)\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n\ndef main():\n    \"\"\"Main method of the Cloud Verifier Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    cloudverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\n    cloudverifier_host = config.get('cloud_verifier', 'cloudverifier_ip')\n    cloudverifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n\n    # allow tornado's max upload size to be configurable\n    max_upload_size = None\n    if config.has_option('cloud_verifier', 'max_upload_size'):\n        max_upload_size = int(config.get('cloud_verifier', 'max_upload_size'))\n\n    # set a conservative general umask\n    os.umask(0o077)\n\n    VerfierMain.metadata.create_all(engine, checkfirst=True)\n    session = get_session()\n    try:\n        query_all = session.query(VerfierMain).all()\n        for row in query_all:\n            if row.operational_state in states.APPROVED_REACTIVATE_STATES:\n                row.operational_state = states.START\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    num = session.query(VerfierMain.agent_id).count()\n    if num > 0:\n        agent_ids = session.query(VerfierMain.agent_id).all()\n        logger.info(\"Agent ids in db loaded from file: %s\", agent_ids)\n\n    logger.info('Starting Cloud Verifier (tornado) on port %s, use <Ctrl-C> to stop', cloudverifier_port)\n\n    # print out API versions we support\n    keylime_api_version.log_api_versions(logger)\n\n    context, mtls_options = web_util.init_mtls(logger=logger)\n\n    # Check for user defined CA to connect to agent\n    agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n    agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n    agent_mtls_private_key_pw = config.get(\"cloud_verifier\", \"agent_mtls_private_key_pw\", fallback=None)\n\n    # Only set custom options if the cert should not be the same as used by the verifier\n    if agent_mtls_cert != \"CV\":\n        mtls_options = (agent_mtls_cert, agent_mtls_private_key, agent_mtls_private_key_pw)\n\n    app = tornado.web.Application([\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/agents/.*\", AgentsHandler, {\"mtls_options\": mtls_options}),\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/allowlists/.*\", AllowlistHandler),\n        (r\"/versions?\", VersionHandler),\n        (r\".*\", MainHandler),\n    ])\n\n    sockets = tornado.netutil.bind_sockets(\n        int(cloudverifier_port), address=cloudverifier_host)\n\n    def server_process(task_id):\n        logger.info(\"Starting server of process %s\", task_id)\n        engine.dispose()\n        server = tornado.httpserver.HTTPServer(app, ssl_options=context, max_buffer_size=max_upload_size)\n        server.add_sockets(sockets)\n\n        def server_sig_handler(*_):\n            logger.info(\"Shutting down server %s..\", task_id)\n            # Stop server to not accept new incoming connections\n            server.stop()\n\n            # Wait for all connections to be closed and then stop ioloop\n            async def stop():\n                await server.close_all_connections()\n                tornado.ioloop.IOLoop.current().stop()\n            asyncio.ensure_future(stop())\n\n        # Attach signal handler to ioloop.\n        # Do not use signal.signal(..) for that because it does not work!\n        loop = asyncio.get_event_loop()\n        loop.add_signal_handler(signal.SIGINT, server_sig_handler)\n        loop.add_signal_handler(signal.SIGTERM, server_sig_handler)\n\n        server.start()\n        if task_id == 0:\n            # Reactivate agents\n            asyncio.ensure_future(activate_agents(cloudverifier_id, cloudverifier_host, cloudverifier_port, mtls_options))\n        tornado.ioloop.IOLoop.current().start()\n        logger.debug(\"Server %s stopped.\", task_id)\n        sys.exit(0)\n\n    processes = []\n\n    def sig_handler(*_):\n        if config.getboolean('cloud_verifier', 'revocation_notifier'):\n            revocation_notifier.stop_broker()\n        for p in processes:\n            p.join()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, sig_handler)\n    signal.signal(signal.SIGTERM, sig_handler)\n    if config.getboolean('cloud_verifier', 'revocation_notifier'):\n        logger.info(\"Starting service for revocation notifications on port %s\",\n                    config.getint('cloud_verifier', 'revocation_notifier_port'))\n        revocation_notifier.start_broker()\n\n    num_workers = config.getint(\n        'cloud_verifier', 'multiprocessing_pool_num_workers')\n    if num_workers <= 0:\n        num_workers = tornado.process.cpu_count()\n    for task_id in range(0, num_workers):\n        process = Process(target=server_process, args=(task_id,))\n        process.start()\n        processes.append(process)\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport argparse\nimport base64\nimport hashlib\nimport io\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nimport zipfile\nimport json\nimport tempfile\nimport requests\n\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom keylime.agentstates import AgentAttestState\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import states, retry\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import registrar_client\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime import crypto\nfrom keylime.cmd import user_data_encrypt\nfrom keylime import ca_util\nfrom keylime.common import algorithms, validators\nfrom keylime.ima import ima, file_signatures\nfrom keylime import measured_boot\nfrom keylime import signing\nfrom keylime import api_version as keylime_api_version\n\n# setup logging\nlogger = keylime_logging.init_logging('tenant')\n\n# special exception that suppresses stack traces when it happens\nclass UserError(Exception):\n    pass\n\n\nclass Tenant():\n    \"\"\"Simple command processor example.\"\"\"\n\n    config = None\n\n    cloudverifier_ip = None\n    cloudverifier_port = None\n\n    cloudagent_ip = None\n    cv_cloudagent_ip = None\n    cloudagent_port = None\n\n    registrar_ip = None\n    registrar_port = None\n    registrar_data = None\n\n    webapp_ip = None\n    webapp_port = None\n\n    api_version = None\n\n    uuid_service_generate_locally = None\n    agent_uuid = None\n\n    K = None\n    V = None\n    U = None\n    auth_tag = None\n\n    tpm_policy = None\n    metadata = {}\n    allowlist = {}\n    ima_sign_verification_keys = []\n    revocation_key = \"\"\n    accept_tpm_hash_algs = []\n    accept_tpm_encryption_algs = []\n    accept_tpm_signing_algs = []\n    mb_refstate = None\n    supported_version = None\n\n    payload = None\n\n    tpm_instance = tpm()\n\n    def __init__(self):\n        \"\"\" Set up required values and TLS\n        \"\"\"\n        self.nonce = None\n        self.agent_ip = None\n        self.verifier_id = None\n        self.agent_port = None\n        self.verifier_ip = config.get('tenant', 'cloudverifier_ip')\n        self.verifier_port = config.get('tenant', 'cloudverifier_port')\n        self.registrar_ip = config.get('tenant', 'registrar_ip')\n        self.registrar_port = config.get('tenant', 'registrar_port')\n        self.webapp_port = config.getint('webapp', 'webapp_port')\n        self.webapp_ip = config.get('webapp', 'webapp_ip')\n\n        self.api_version = keylime_api_version.current_version()\n\n        (self.my_cert, self.my_priv_key), (self.my_agent_cert, self.my_agent_priv_key), self.verifier_ca_cert = Tenant.get_tls_context()\n        self.cert = (self.my_cert, self.my_priv_key)\n        self.agent_cert = (self.my_agent_cert, self.my_agent_priv_key)\n        if config.getboolean('general', \"enable_tls\"):\n            self.tls_cv_enabled = True\n        else:\n            self.tls_cv_enabled = False\n            self.cert = \"\"\n            logger.warning(\n                \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n        self.tls_agent_enabled = True\n        self.verify_custom = None\n\n    @property\n    def verifier_base_url(self):\n        return f'{self.verifier_ip}:{self.verifier_port}'\n\n    @staticmethod\n    def get_tls_context():\n        \"\"\"Generate certifcate naming and path\n\n        Returns:\n            string -- my_cert (client_cert), my_priv_key (client private key)\n        \"\"\"\n        verifier_ca_cert = config.get('tenant', 'ca_cert')\n        my_cert = config.get('tenant', 'my_cert')\n        my_priv_key = config.get('tenant', 'private_key')\n        tls_dir = config.get('tenant', 'tls_dir')\n\n        if tls_dir == 'default':\n            verifier_ca_cert = 'cacert.crt'\n            my_cert = 'client-cert.crt'\n            my_priv_key = 'client-private.pem'\n            tls_dir = 'cv_ca'\n\n        if tls_dir[0] != '/':\n            tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n        logger.info(\"Setting up client TLS in %s\", tls_dir)\n        verifier_ca_cert = os.path.join(tls_dir, verifier_ca_cert)\n        my_cert = os.path.join(tls_dir, my_cert)\n        my_priv_key = os.path.join(tls_dir, my_priv_key)\n\n        tls_context = (my_cert, my_priv_key)\n\n        agent_mtls_context = (None, None)\n        # Check for user defined CA to connect to agent\n        agent_mtls_cert_enabled = config.getboolean('tenant', 'agent_mtls_cert_enabled', fallback=False)\n\n        if agent_mtls_cert_enabled:\n            agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n            agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n            agent_mtls_context = tls_context\n            if agent_mtls_cert != \"CV\":\n                agent_mtls_context = (agent_mtls_cert, agent_mtls_private_key)\n\n        return tls_context, agent_mtls_context, verifier_ca_cert\n\n    def process_allowlist(self, args):\n        # Set up PCR values\n        tpm_policy = config.get('tenant', 'tpm_policy')\n        if \"tpm_policy\" in args and args[\"tpm_policy\"] is not None:\n            tpm_policy = args[\"tpm_policy\"]\n        self.tpm_policy = TPM_Utilities.readPolicy(tpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.tpm_policy['mask'])\n\n        if len(args.get(\"ima_sign_verification_keys\")) > 0:\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            # Add all IMA file signing verification keys to a keyring\n            tenant_keyring = file_signatures.ImaKeyring()\n            for filename in args[\"ima_sign_verification_keys\"]:\n                pubkey, keyidv2 = file_signatures.get_pubkey_from_file(filename)\n                if not pubkey:\n                    raise UserError(f\"File '{filename}' is not a file with a key\")\n                tenant_keyring.add_pubkey(pubkey, keyidv2)\n            self.ima_sign_verification_keys = tenant_keyring.to_string()\n\n        # Read command-line path string allowlist\n        al_data = None\n\n        if \"allowlist\" in args and args[\"allowlist\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), [ config.IMA_PCR ], \"IMA\")\n\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            if isinstance(args[\"allowlist\"], str):\n                if args[\"allowlist\"] == \"default\":\n                    args[\"allowlist\"] = config.get('tenant', 'allowlist')\n                try:\n                    al_data = ima.read_allowlist(args[\"allowlist\"], args[\"allowlist_checksum\"], args[\"allowlist_sig\"], args[\"allowlist_sig_key\"])\n                except Exception as ima_e:\n                    raise UserError(str(ima_e)) from ima_e\n            elif isinstance(args[\"allowlist\"], list):\n                al_data = args[\"allowlist\"]\n            else:\n                raise UserError(\"Invalid allowlist provided\")\n\n        # Read command-line path string IMA exclude list\n        excl_data = None\n        if \"ima_exclude\" in args and args[\"ima_exclude\"] is not None:\n            if isinstance(args[\"ima_exclude\"], str):\n                if args[\"ima_exclude\"] == \"default\":\n                    args[\"ima_exclude\"] = config.get(\n                        'tenant', 'ima_excludelist')\n                excl_data = ima.read_excllist(args[\"ima_exclude\"])\n            elif isinstance(args[\"ima_exclude\"], list):\n                excl_data = args[\"ima_exclude\"]\n            else:\n                raise UserError(\"Invalid exclude list provided\")\n\n        # Set up IMA\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.IMA_PCR):\n            # Process allowlists\n            self.allowlist = ima.process_allowlists(al_data, excl_data)\n\n        # Read command-line path string TPM event log (measured boot) reference state\n        mb_refstate_data = None\n        if \"mb_refstate\" in args and args[\"mb_refstate\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), config.MEASUREDBOOT_PCRS, \"measured boot\")\n\n            # Auto-enable TPM event log mesured boot (or-bit mask)\n            for _pcr in config.MEASUREDBOOT_PCRS:\n                self.tpm_policy['mask'] = hex(int(self.tpm_policy['mask'], 0) | (1 << _pcr))\n\n            logger.info(\"TPM PCR Mask automatically modified is %s to include IMA/Event log PCRs\", self.tpm_policy['mask'])\n\n            if isinstance(args[\"mb_refstate\"], str):\n                if args[\"mb_refstate\"] == \"default\":\n                    args[\"mb_refstate\"] = config.get('tenant', 'mb_refstate')\n                mb_refstate_data = measured_boot.read_mb_refstate(args[\"mb_refstate\"])\n            else:\n                raise UserError(\"Invalid measured boot reference state (intended state) provided\")\n\n        # Set up measured boot (TPM event log) reference state\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.MEASUREDBOOT_PCRS[2]) :\n            # Process measured boot reference state\n            self.mb_refstate = mb_refstate_data\n\n    def init_add(self, args):\n        \"\"\" Set up required values. Command line options can overwrite these config values\n\n        Arguments:\n            args {[string]} -- agent_ip|agent_port|cv_agent_ip\n        \"\"\"\n        if \"agent_ip\" in args:\n            self.agent_ip = args[\"agent_ip\"]\n\n        if 'agent_port' in args and args['agent_port'] is not None:\n            self.agent_port = args['agent_port']\n\n        registrar_client.init_client_tls(\"tenant\")\n        self.registrar_data = registrar_client.getData(self.registrar_ip, self.registrar_port, self.agent_uuid)\n\n        if self.registrar_data is None:\n            raise UserError(f\"Agent ${self.agent_uuid} data not found in the Registrar.\")\n\n        # try to get the port or ip from the registrar if it is missing\n        if (self.agent_ip is None or self.agent_port is None) and self.registrar_data is not None:\n            if self.agent_ip is None:\n                if self.registrar_data['ip'] is not None:\n                    self.agent_ip = self.registrar_data['ip']\n                else:\n                    raise UserError(\"No Ip was specified or found in the Registrar\")\n\n            if self.agent_port is None and self.registrar_data['port'] is not None:\n                self.agent_port = self.registrar_data[\"port\"]\n\n        # If no agent port was found try to use the default from the config file\n        if self.agent_port is None:\n            self.agent_port = config.get('cloud_agent', 'cloudagent_port')\n\n        # Check if a contact ip and port for the agent was found\n        if self.agent_ip is None:\n            raise UserError(\"The contact ip address for the agent was not specified.\")\n\n        if self.agent_port is None:\n            raise UserError(\"The contact port for the agent was not specified.\")\n\n        # Auto-detection for API version\n        self.supported_version = args[\"supported_version\"]\n        if self.supported_version is None:\n            # Default to 1.0 if the agent did not send a mTLS certificate\n            if self.registrar_data.get(\"mtls_cert\", None) is None:\n                self.supported_version = \"1.0\"\n            else:\n                # Try to connect to the agent to get supported version\n                if self.registrar_data['mtls_cert'] == \"disabled\":\n                    self.tls_agent_enabled = False\n                    self.verify_custom = False\n                    logger.warning(\n                        \"Warning: mTLS for agents is disabled: the identity of each node will be based on the properties of the TPM only. \"\n                        \"Unless you have strict control of your network, it is strongly advised that remote code execution should be disabled, \"\n                        \"by setting \\\"payload_script=\\\" and \\\"extract_payload_zip=False\\\" under \\\"[cloud_agent]\\\"\")\n                else:\n                    self.verify_custom = self.registrar_data['mtls_cert']\n\n                with RequestsClient(f\"{self.agent_ip}:{self.agent_port}\", tls_enabled=self.tls_agent_enabled, cert=self.agent_cert,\n                                    ignore_hostname=True, verify_custom=self.verify_custom) as get_version:\n                    res = get_version.get(\"/version\")\n                    if res and res.status_code == 200:\n                        try:\n                            data = res.json()\n                            api_version = data[\"results\"][\"supported_version\"]\n                            if keylime_api_version.validate_version(api_version):\n                                self.supported_version = api_version\n                            else:\n                                logger.warning(\"API version provided by the agent is not valid\")\n                        except (TypeError, KeyError):\n                            pass\n\n        if self.supported_version is None:\n            api_version = keylime_api_version.current_version()\n            logger.warning(\"Could not detect supported API version. Defaulting to %s\", api_version)\n            self.supported_version = api_version\n\n        # Now set the cv_agent_ip\n        if 'cv_agent_ip' in args and args['cv_agent_ip'] is not None:\n            self.cv_cloudagent_ip = args['cv_agent_ip']\n        else:\n            self.cv_cloudagent_ip = self.agent_ip\n\n        # Make sure all keys exist in dictionary\n        if \"file\" not in args:\n            args[\"file\"] = None\n        if \"keyfile\" not in args:\n            args[\"keyfile\"] = None\n        if \"payload\" not in args:\n            args[\"payload\"] = None\n        if \"ca_dir\" not in args:\n            args[\"ca_dir\"] = None\n        if \"incl_dir\" not in args:\n            args[\"incl_dir\"] = None\n        if \"ca_dir_pw\" not in args:\n            args[\"ca_dir_pw\"] = None\n\n        # Set up accepted algorithms\n        self.accept_tpm_hash_algs = config.get(\n            'tenant', 'accept_tpm_hash_algs').split(',')\n        self.accept_tpm_encryption_algs = config.get(\n            'tenant', 'accept_tpm_encryption_algs').split(',')\n        self.accept_tpm_signing_algs = config.get(\n            'tenant', 'accept_tpm_signing_algs').split(',')\n\n        self.process_allowlist(args)\n\n        # if none\n        if (args[\"file\"] is None and args[\"keyfile\"] is None and args[\"ca_dir\"] is None):\n            raise UserError(\n                \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n        if args[\"keyfile\"] is not None:\n            if args[\"file\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            # read the keys in\n            if isinstance(args[\"keyfile\"], dict) and \"data\" in args[\"keyfile\"]:\n                if isinstance(args[\"keyfile\"][\"data\"], list) and len(args[\"keyfile\"][\"data\"]) == 1:\n                    keyfile = args[\"keyfile\"][\"data\"][0]\n                    if keyfile is None:\n                        raise UserError(\"Invalid key file contents\")\n                    f = io.StringIO(keyfile)\n                else:\n                    raise UserError(\"Invalid key file provided\")\n            else:\n                f = open(args[\"keyfile\"], encoding=\"utf-8\")  #pylint: disable=consider-using-with\n            self.K = base64.b64decode(f.readline())\n            self.U = base64.b64decode(f.readline())\n            self.V = base64.b64decode(f.readline())\n            f.close()\n\n            # read the payload in (opt.)\n            if isinstance(args[\"payload\"], dict) and \"data\" in args[\"payload\"]:\n                if isinstance(args[\"payload\"][\"data\"], list) and len(args[\"payload\"][\"data\"]) > 0:\n                    self.payload = args[\"payload\"][\"data\"][0]\n            else:\n                if args[\"payload\"] is not None:\n                    with open(args[\"payload\"], 'rb') as f:\n                        self.payload = f.read()\n\n        if args[\"file\"] is not None:\n            if args[\"keyfile\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            if isinstance(args[\"file\"], dict) and \"data\" in args[\"file\"]:\n                if isinstance(args[\"file\"][\"data\"], list) and len(args[\"file\"][\"data\"]) > 0:\n                    contents = args[\"file\"][\"data\"][0]\n                    if contents is None:\n                        raise UserError(\"Invalid file payload contents\")\n                else:\n                    raise UserError(\"Invalid file payload provided\")\n            else:\n                with open(args[\"file\"], encoding=\"utf-8\") as f:\n                    contents = f.read()\n            ret = user_data_encrypt.encrypt(contents)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.payload = ret['ciphertext']\n\n        if args[\"ca_dir\"] is None and args[\"incl_dir\"] is not None:\n            raise UserError(\n                \"--include option is only valid when used with --cert\")\n        if args[\"ca_dir\"] is not None:\n            if args[\"file\"] is not None or args[\"keyfile\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n            if args[\"ca_dir\"] == 'default':\n                args[\"ca_dir\"] = config.CA_WORK_DIR\n\n            if \"ca_dir_pw\" in args and args[\"ca_dir_pw\"] is not None:\n                ca_util.setpassword(args[\"ca_dir_pw\"])\n\n            if not os.path.exists(args[\"ca_dir\"]) or not os.path.exists(os.path.join(args[\"ca_dir\"], \"cacert.crt\")):\n                logger.warning(\"CA directory does not exist. Creating...\")\n                ca_util.cmd_init(args[\"ca_dir\"])\n            if not os.path.exists(\n                    os.path.join(args[\"ca_dir\"],\n                                 f\"{self.agent_uuid}-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], self.agent_uuid)\n\n            cert_pkg, serial, subject = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], self.agent_uuid)\n\n            # support revocation\n            if not os.path.exists(os.path.join(args[\"ca_dir\"], \"RevocationNotifier-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], \"RevocationNotifier\")\n            rev_package, _, _ = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], \"RevocationNotifier\")\n\n            # extract public and private keys from package\n            sf = io.BytesIO(rev_package)\n            with zipfile.ZipFile(sf) as zf:\n                privkey = zf.read(\"RevocationNotifier-private.pem\")\n                cert = zf.read(\"RevocationNotifier-cert.crt\")\n\n            # put the cert of the revoker into the cert package\n            sf = io.BytesIO(cert_pkg)\n            with zipfile.ZipFile(sf, 'a', compression=zipfile.ZIP_STORED) as zf:\n                zf.writestr('RevocationNotifier-cert.crt', cert)\n\n                # add additional files to zip\n                if args[\"incl_dir\"] is not None:\n                    if isinstance(args[\"incl_dir\"], dict) and \"data\" in args[\"incl_dir\"] and \"name\" in args[\"incl_dir\"]:\n                        if isinstance(args[\"incl_dir\"][\"data\"], list) and isinstance(args[\"incl_dir\"][\"name\"], list):\n                            if len(args[\"incl_dir\"][\"data\"]) != len(args[\"incl_dir\"][\"name\"]):\n                                raise UserError(\"Invalid incl_dir provided\")\n                            for i in range(len(args[\"incl_dir\"][\"data\"])):\n                                zf.writestr(os.path.basename(\n                                    args[\"incl_dir\"][\"name\"][i]), args[\"incl_dir\"][\"data\"][i])\n                    else:\n                        if os.path.exists(args[\"incl_dir\"]):\n                            files = next(os.walk(args[\"incl_dir\"]))[2]\n                            for filename in files:\n                                with open(os.path.join(args[\"incl_dir\"],\n                                                       filename), 'rb') as f:\n                                    zf.writestr(\n                                        os.path.basename(f.name), f.read())\n                        else:\n                            logger.warning('Specified include directory %s does not exist. Skipping...', args[\"incl_dir\"])\n\n            cert_pkg = sf.getvalue()\n\n            # put the private key into the data to be send to the CV\n            self.revocation_key = privkey.decode('utf-8')\n\n            # encrypt up the cert package\n            ret = user_data_encrypt.encrypt(cert_pkg)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.metadata = {'cert_serial': serial, 'subject': subject}\n            self.payload = ret['ciphertext']\n\n        if self.payload is not None and len(self.payload) > config.getint('tenant', 'max_payload_size'):\n            raise UserError(f\"Payload size {len(self.payload)} exceeds max size {config.getint('tenant', 'max_payload_size')}\")\n\n    def enforce_pcrs(self, policy_pcrs, protected_pcrs, pcr_use) :\n        policy_pcrs = list(self.tpm_policy.keys())\n        policy_pcrs.remove('mask')\n\n        for _pcr in policy_pcrs :\n            if int(_pcr) in protected_pcrs :\n                logger.error('WARNING: PCR %s is specified in \"tpm_policy\", but will in fact be used by %s. Please remove it from policy', _pcr, pcr_use)\n                sys.exit(1)\n\n    def preloop(self):\n        \"\"\" encrypt the agent UUID as a check for delivering the correct key\n        \"\"\"\n        self.auth_tag = crypto.do_hmac(self.K, self.agent_uuid)\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"K: %s\", base64.b64encode(self.K))\n            logger.debug(\"V: %s\", base64.b64encode(self.V))\n            logger.debug(\"U: %s\", base64.b64encode(self.U))\n            logger.debug(\"Auth Tag: %s\", self.auth_tag)\n\n    def check_ek(self, ekcert):\n        \"\"\" Check the Entity Key\n\n        Arguments:\n            ekcert {str} -- The endorsement key, either None, \"emulator\", or base64 encoded der cert\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        if config.getboolean('tenant', 'require_ek_cert'):\n            if ekcert == 'emulator' and config.DISABLE_EK_CERT_CHECK_EMULATOR:\n                logger.info(\"Not checking ekcert of TPM emulator\")\n            elif ekcert is None:\n                logger.warning(\"No EK cert provided, require_ek_cert option in config set to True\")\n                return False\n            elif not self.tpm_instance.verify_ek(base64.b64decode(ekcert)):\n                logger.warning(\"Invalid EK certificate\")\n                return False\n\n        return True\n\n    def validate_tpm_quote(self, public_key, quote, hash_alg):\n        \"\"\" Validate TPM Quote received from the Agent\n\n        Arguments:\n            public_key {[type]} -- [description]\n            quote {[type]} -- [description]\n            hash_alg {bool} -- [description]\n\n        Raises:\n            UserError: [description]\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        registrar_client.init_client_tls('tenant')\n        if self.registrar_data is None:\n            logger.warning(\"AIK not found in registrar, quote not validated\")\n            return False\n\n        failure = self.tpm_instance.check_quote(AgentAttestState(self.agent_uuid), self.nonce, public_key, quote,\n                                                self.registrar_data['aik_tpm'], hash_alg=hash_alg,\n                                                compressed=(self.supported_version == \"1.0\"))\n        if failure:\n            if self.registrar_data['regcount'] > 1:\n                logger.error(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured or a malicious host is present. Run 'regdelete' for this agent and restart\")\n                sys.exit()\n            return False\n\n        if self.registrar_data['regcount'] > 1:\n            logger.warning(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured. Run 'regdelete' for this agent and restart\")\n\n        if not config.getboolean('tenant', 'require_ek_cert') and config.get('tenant', 'ek_check_script') == \"\":\n            logger.warning(\n                \"DANGER: EK cert checking is disabled and no additional checks on EKs have been specified with ek_check_script option. Keylime is not secure!!\")\n\n        # check EK cert and make sure it matches EK\n        if not self.check_ek(self.registrar_data['ekcert']):\n            return False\n        # if agent is virtual, check phyisical EK cert and make sure it matches phyiscal EK\n        if 'provider_keys' in self.registrar_data:\n            if not self.check_ek(self.registrar_data['provider_keys']['ekcert']):\n                return False\n\n        # check all EKs with optional script:\n        script = config.get('tenant', 'ek_check_script')\n        if not script:\n            return True\n\n        if script[0] != '/':\n            script = os.path.join(config.WORK_DIR, script)\n\n        logger.info(\"Checking EK with script %s\", script)\n        # now we need to exec the script with the ek and ek cert in vars\n        env = os.environ.copy()\n        env['AGENT_UUID'] = self.agent_uuid\n        env['EK'] = tpm2_objects.pubkey_from_tpm2b_public(\n            base64.b64decode(self.registrar_data['ek_tpm']),\n            ).public_bytes(\n                crypto_serialization.Encoding.PEM,\n                crypto_serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n        env['EK_TPM'] = self.registrar_data['ek_tpm']\n        if self.registrar_data['ekcert'] is not None:\n            env['EK_CERT'] = self.registrar_data['ekcert']\n        else:\n            env['EK_CERT'] = \"\"\n\n        env['PROVKEYS'] = json.dumps(self.registrar_data.get('provider_keys', {}))\n        with subprocess.Popen(script, env=env, shell=True,\n                              cwd=config.WORK_DIR, stdout=subprocess.PIPE,\n                              stderr=subprocess.STDOUT) as proc:\n            retval = proc.wait()\n            if retval != 0:\n                raise UserError(\"External check script failed to validate EK\")\n            logger.debug(\"External check script successfully to validated EK\")\n            while True:\n                line = proc.stdout.readline().decode()\n                if line == \"\":\n                    break\n                logger.debug(\"ek_check output: %s\", line.strip())\n        return True\n\n    def do_cv(self):\n        \"\"\" Initiaite v, agent_id and ip and initiate the cloudinit sequence\n        \"\"\"\n        b64_v = base64.b64encode(self.V).decode('utf-8')\n        logger.debug(\"b64_v: %s\", b64_v)\n        data = {\n            'v': b64_v,\n            'cloudagent_ip': self.cv_cloudagent_ip,\n            'cloudagent_port': self.agent_port,\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'allowlist': json.dumps(self.allowlist),\n            'mb_refstate': json.dumps(self.mb_refstate),\n            'ima_sign_verification_keys': json.dumps(self.ima_sign_verification_keys),\n            'metadata': json.dumps(self.metadata),\n            'revocation_key': self.revocation_key,\n            'accept_tpm_hash_algs': self.accept_tpm_hash_algs,\n            'accept_tpm_encryption_algs': self.accept_tpm_encryption_algs,\n            'accept_tpm_signing_algs': self.accept_tpm_signing_algs,\n            'ak_tpm': self.registrar_data['aik_tpm'],\n            'mtls_cert': self.registrar_data.get('mtls_cert', None),\n            'supported_version': self.supported_version,\n        }\n        json_message = json.dumps(data)\n        do_cv = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cv.post(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            data=json_message,\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code == 409:\n            # this is a conflict, need to update or delete it\n            logger.error(\"Agent %s already existed at CV. Please use delete or update.\", self.agent_uuid)\n            sys.exit()\n        elif response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response.json())\n            logger.error(\"POST command response: %s Unexpected response from Cloud Verifier: %s\", response.status_code, response.text)\n            sys.exit()\n\n    def do_cvstatus(self):\n        \"\"\"Perform operational state look up for agent on the verifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            res = response.pop('results')\n            response['results'] = {self.agent_uuid: res}\n\n            operational_state = states.state_to_str(\n                response['results'][self.agent_uuid]['operational_state'])\n            response['results'][self.agent_uuid]['operational_state'] = operational_state\n\n            logger.info(\"Agent Info:\\n%s\", json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvlist(self):\n        \"\"\"List all agent statuses in cloudverifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?verifier={verifier_id}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            logger.info('From verifier %s port %s retrieved: \"%s\"',\n                        self.verifier_ip, self.verifier_port, response)\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvbulkinfo(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?bulk={True}&verifier={verifier_id}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            for agent in response[\"results\"].keys():\n                response[\"results\"][agent][\"operational_state\"] = \\\n                    states.state_to_str(response[\"results\"][agent][\n                                            \"operational_state\"])\n            logger.info(\"Bulk Agent Info:\\n%s\", json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvdelete(self, verifier_check=True):\n        \"\"\"Delete agent from Verifier.\"\"\"\n        if verifier_check:\n            cvresponse = self.do_cvstatus()\n\n            if not isinstance(cvresponse, dict):\n                return cvresponse\n\n            if cvresponse['code'] != 200:\n                logger.error(\"Could not get status of agent %s from \"\n                             \"verifier %s.\", self.agent_uuid, self.verifier_ip)\n                return cvresponse\n\n            self.verifier_ip = cvresponse['results'][self.agent_uuid][\"verifier_ip\"]\n            self.verifier_port = cvresponse['results'][self.agent_uuid][\"verifier_port\"]\n\n        do_cvdelete = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvdelete.delete(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        response = response.json()\n\n        if response['code'] == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 202:\n            deleted = False\n            for _ in range(12):\n                get_cvdelete = RequestsClient(\n                    self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n                response = get_cvdelete.get(\n                    (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n                    cert=self.cert,\n                    verify=self.verifier_ca_cert\n                )\n\n                if response.status_code == 404:\n                    deleted = True\n                    break\n                time.sleep(.4)\n            if deleted:\n                logger.info(\"CV completed deletion of agent %s\", self.agent_uuid)\n                return response.json()\n            logger.error(\"Timed out waiting for delete of agent %s to complete at CV\", self.agent_uuid)\n            return response.json()\n        if response['code'] == 200:\n            logger.info(\"Agent %s deleted from the CV\", self.agent_uuid)\n            return response\n\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response)\n        return response\n\n    def do_regstatus(self):\n        registrar_client.init_client_tls('tenant')\n        agent_info = registrar_client.getData(self.registrar_ip,\n                                              self.registrar_port,\n                                              self.agent_uuid)\n\n        if not agent_info:\n            logger.info(\n                \"Agent %s does not exist on the registrar. Please register the agent with the registrar.\",\n                self.agent_uuid)\n            response = {'code': 404,\n                        'status': f\"Agent {self.agent_uuid} does not exist on \"\n                                  f\"registrar {self.registrar_ip} port {self.registrar_port}.\",\n                        'results': {}}\n            logger.info(json.dumps(response))\n            return response\n\n        response = {'code': 200,\n                    'status': f\"Agent {self.agent_uuid} exists on \"\n                              f\"registrar {self.registrar_ip} port {self.registrar_port}.\",\n                    'results': {}}\n        response['results'][self.agent_uuid] = agent_info\n        response['results'][self.agent_uuid]['operational_state'] = \\\n            states.state_to_str(states.REGISTERED)\n\n        logger.info(json.dumps(response))\n\n        return response\n\n    def do_reglist(self):\n        \"\"\"List agents from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarList(\n            self.registrar_ip, self.registrar_port)\n\n        logger.info(\"From registrar %s port %s retrieved %s\",\n                    self.registrar_ip, self.registrar_port,\n                    json.dumps(response))\n        return response\n\n    def do_regdelete(self):\n        \"\"\"Delete agent from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarDelete(self.registrar_ip,\n                                           self.registrar_port,\n                                           self.agent_uuid)\n\n        return response\n\n    def do_status(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        regresponse = self.do_regstatus()\n\n        if regresponse['code'] == 404:\n            return regresponse\n\n        cvresponse = self.do_cvstatus()\n\n        if not isinstance(cvresponse, dict):\n            logger.error(\"Unexpected response from Cloud Verifier %s on \"\n                         \"port %s. response %s\", self.verifier_ip,\n                         self.verifier_port, str(cvresponse))\n            return cvresponse\n\n        if regresponse['code'] == 200 and cvresponse['code'] == 200:\n            return cvresponse\n        if regresponse['code'] == 200 and cvresponse['code'] != 200:\n            return regresponse\n\n        logger.error(\"Unknown inconsistent state between registrar %s on \"\n                     \"port %s and verifier %s on port %s occured. Got \"\n                     \"registrar response %s verifier response %s\",\n                     self.verifier_ip, self.verifier_port, self.registrar_ip,\n                     self.registrar_port, str(regresponse), str(cvresponse))\n\n        return {'registrar': regresponse, 'verifier': cvresponse}\n\n    def do_cvreactivate(self, verifier_check=True):\n        \"\"\"Reactive Agent.\"\"\"\n        if verifier_check:\n            agent_json = self.do_cvstatus()\n            self.verifier_ip = agent_json['results'][self.agent_uuid]['verifier_ip']\n            self.verifier_port = agent_json['results'][self.agent_uuid]['verifier_port']\n\n        do_cvreactivate = RequestsClient(\n            self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvreactivate.put(\n            f'/v{self.api_version}/agents/{self.agent_uuid}/reactivate',\n            data=b'',\n            cert=self.cert,\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 200:\n            logger.info(\"Agent %s re-activated\", self.agent_uuid)\n            return response.json()\n\n        response_body = response.json()\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response_body)\n        logger.error(\"Update command response: %s Unexpected response from Cloud Verifier.\", response.status_code)\n        return response.json()\n\n    def do_cvstop(self):\n        \"\"\" Stop declared active agent\n        \"\"\"\n        params = f'/v{self.api_version}/agents/{self.agent_uuid}/stop'\n        do_cvstop = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = do_cvstop.put(\n            params,\n            cert=self.cert,\n            data=b'',\n            verify=self.verifier_ca_cert\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        response_body = response.json()\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n        else:\n            logger.info(\"Agent %s stopped\", self.agent_uuid)\n\n    def do_quote(self):\n        \"\"\" Perform TPM quote by GET towards Agent\n\n        Raises:\n            UserError: Connection handler\n        \"\"\"\n        self.nonce = TPM_Utilities.random_password(20)\n\n        numtries = 0\n        response = None\n        # Note: We need a specific retry handler (perhaps in common), no point having localised unless we have too.\n        while True:\n            try:\n                params = f'/v{self.supported_version}/quotes/identity?nonce=%s' % (self.nonce)\n                cloudagent_base_url = f'{self.agent_ip}:{self.agent_port}'\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=self.tls_agent_enabled, ignore_hostname=True, cert=self.agent_cert,\n                                        verify_custom=self.verify_custom) as do_quote:\n                        response = do_quote.get(params)\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_quote = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_quote.get(params)\n\n                print(response)\n                response_body = response.json()\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Tenant cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    interval = config.getfloat('tenant', 'retry_interval')\n                    exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                    next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                    logger.info(\"Tenant connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, next_retry)\n                    time.sleep(next_retry)\n                    continue\n\n                raise e\n            break\n\n        if response is not None and response.status_code != 200:\n            raise UserError(\n               f\"Status command response: {response.status_code} Unexpected response from Cloud Agent.\")\n\n        if \"results\" not in response_body:\n            raise UserError(\n                f\"Error: unexpected http response body from Cloud Agent: {str(response.status)}\")\n\n        quote = response_body[\"results\"][\"quote\"]\n        logger.debug(\"Agent_quote received quote: %s\", quote)\n\n        public_key = response_body[\"results\"][\"pubkey\"]\n        logger.debug(\"Agent_quote received public key: %s\", public_key)\n\n        # Ensure hash_alg is in accept_tpm_hash_algs list\n        hash_alg = response_body[\"results\"][\"hash_alg\"]\n        logger.debug(\"Agent_quote received hash algorithm: %s\", hash_alg)\n        if not algorithms.is_accepted(hash_alg, config.get('tenant', 'accept_tpm_hash_algs').split(','))\\\n                or not algorithms.Hash.is_recognized(hash_alg):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted hash algorithm: {hash_alg}\")\n\n        # Ensure enc_alg is in accept_tpm_encryption_algs list\n        enc_alg = response_body[\"results\"][\"enc_alg\"]\n        logger.debug(\"Agent_quote received encryption algorithm: %s\", enc_alg)\n        if not algorithms.is_accepted(enc_alg, config.get('tenant', 'accept_tpm_encryption_algs').split(',')):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted encryption algorithm: {enc_alg}\")\n\n        # Ensure sign_alg is in accept_tpm_encryption_algs list\n        sign_alg = response_body[\"results\"][\"sign_alg\"]\n        logger.debug(\"Agent_quote received signing algorithm: %s\", sign_alg)\n        if not algorithms.is_accepted(sign_alg, config.get('tenant', 'accept_tpm_signing_algs').split(',')):\n            raise UserError(\n                f\"TPM Quote is using an unaccepted signing algorithm: {sign_alg}\")\n\n        if not self.validate_tpm_quote(public_key, quote, algorithms.Hash(hash_alg)):\n            raise UserError(\n                f\"TPM Quote from cloud agent is invalid for nonce: {self.nonce}\")\n\n        logger.info(\"Quote from %s validated\", self.agent_ip)\n\n        # encrypt U with the public key\n        encrypted_U = crypto.rsa_encrypt(\n            crypto.rsa_import_pubkey(public_key), self.U)\n\n        b64_encrypted_u = base64.b64encode(encrypted_U)\n        logger.debug(\"b64_encrypted_u: %s\", b64_encrypted_u.decode('utf-8'))\n        data = {\n            'encrypted_key': b64_encrypted_u.decode('utf-8'),\n            'auth_tag': self.auth_tag\n        }\n\n        if self.payload is not None:\n            data['payload'] = self.payload.decode('utf-8')\n\n\n        # post encrypted U back to CloudAgent\n        params = f'/v{self.supported_version}/keys/ukey'\n        cloudagent_base_url = (\n            f'{self.agent_ip}:{self.agent_port}'\n        )\n\n        if self.registrar_data['mtls_cert']:\n            with RequestsClient(cloudagent_base_url, tls_enabled=self.tls_agent_enabled, ignore_hostname=True, cert=self.agent_cert,\n                                verify_custom=self.verify_custom) as post_ukey:\n                response = post_ukey.post(params, json=data)\n        else:\n            logger.warning(\"Connecting to agent without using mTLS!\")\n            post_ukey = RequestsClient(cloudagent_base_url, tls_enabled=False)\n            response = post_ukey.post(params, json=data)\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Agent at %s with Port %s. Connection refused.\", self.agent_ip, self.agent_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n            raise UserError(\n                f\"Posting of Encrypted U to the Cloud Agent failed with response code {response.status_code} ({response.text})\")\n\n    def do_verify(self):\n        \"\"\" Perform verify using a random generated challenge\n        \"\"\"\n        challenge = TPM_Utilities.random_password(20)\n        numtries = 0\n\n        while True:\n            response = None\n            try:\n                cloudagent_base_url = (\n                    f'{self.agent_ip}:{self.agent_port}'\n                )\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True,\n                                        cert=self.agent_cert, verify_custom=self.registrar_data['mtls_cert']) as do_verify:\n                        response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_verify = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n\n                response_body = response.json()\n            except Exception as e:\n                if response is not None and response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        self.do_cvstop()\n                        sys.exit()\n                    interval = config.getfloat('tenant', 'retry_interval')\n                    exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                    next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                    logger.info(\"Verifier connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, next_retry)\n                    time.sleep(next_retry)\n                    continue\n                self.do_cvstop()\n                raise e\n            if response.status_code == 200:\n                if \"results\" not in response_body or 'hmac' not in response_body['results']:\n                    logger.critical(\"Error: unexpected http response body from Cloud Agent: %s\", response.status_code)\n                    self.do_cvstop()\n                    break\n                mac = response_body['results']['hmac']\n\n                ex_mac = crypto.do_hmac(self.K, challenge)\n\n                if mac == ex_mac:\n                    logger.info(\"Key derivation successful\")\n                else:\n                    logger.error(\"Key derivation failed\")\n                    self.do_cvstop()\n            else:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                numtries += 1\n                maxr = config.getint('tenant', 'max_retries')\n                if numtries >= maxr:\n                    logger.error(\"Agent on %s with port %s failed key derivation\", self.agent_ip, self.agent_port)\n                    self.do_cvstop()\n                    sys.exit()\n                interval = config.getfloat('tenant', 'retry_interval')\n                exponential_backoff = config.getboolean('tenant', 'exponential_backoff')\n                next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)\n                logger.info(\"Key derivation not yet complete (retry %s/%s), trying again in %s seconds... (Ctrl-C to stop)\",\n                    numtries, maxr, next_retry)\n                time.sleep(next_retry)\n                continue\n            break\n\n    def do_add_allowlist(self, args):\n        if 'allowlist_name' not in args or not args['allowlist_name']:\n            raise UserError('allowlist_name is required to add an allowlist')\n\n        allowlist_name = args['allowlist_name']\n        self.process_allowlist(args)\n        data = {\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'allowlist': json.dumps(self.allowlist)\n        }\n        body = json.dumps(data)\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.post(f'/v{self.api_version}/allowlists/{allowlist_name}', data=body,\n                                  cert=self.cert, verify=self.verifier_ca_cert)\n        Tenant._print_json_response(response)\n\n    def do_delete_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.delete(f'/v{self.api_version}/allowlists/{name}',\n                                    cert=self.cert, verify=self.verifier_ca_cert)\n        Tenant._print_json_response(response)\n\n    def do_show_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_cv_enabled, ignore_hostname=True)\n        response = cv_client.get(f'/v{self.api_version}/allowlists/{name}',\n                                 cert=self.cert, verify=self.verifier_ca_cert)\n        print(f\"Show allowlist command response: {response.status_code}.\")\n        Tenant._print_json_response(response)\n\n    @staticmethod\n    def _print_json_response(response):\n        try:\n            json_response = response.json()\n        except ValueError:\n            json_response = '{}'\n        print(json_response)\n\n\ndef write_to_namedtempfile(data, delete_tmp_files):\n    temp = tempfile.NamedTemporaryFile(prefix=\"keylime-\", delete=delete_tmp_files)  #pylint: disable=consider-using-with\n    temp.write(data)\n    temp.flush()\n    return temp.name\n\ndef main(argv=sys.argv):  #pylint: disable=dangerous-default-value\n    \"\"\"[summary]\n\n    Keyword Arguments:\n        argv {[type]} -- [description] (default: {sys.argv})\n\n    Raises:\n        UserError: [description]\n        UserError: [description]\n        UserError: [description]\n    \"\"\"\n    parser = argparse.ArgumentParser(argv[0])\n    parser.add_argument('-c', '--command', action='store', dest='command', default='add',\n                        help=\"valid commands are add,delete,update,\"\n                             \"regstatus,cvstatus,status,reglist,cvlist,reactivate,\"\n                             \"regdelete,bulkinfo,addallowlist,showallowlist,deleteallowlist. defaults to add\")\n    parser.add_argument('-t', '--targethost', action='store',\n                        dest='agent_ip', help=\"the IP address of the host to provision\")\n    parser.add_argument('-tp', '--targetport', action='store',\n                        dest='agent_port', help=\"the Port of the host to provision\")\n    parser.add_argument('-r', '--registrarhost', action='store',\n                        dest='registrar_ip', help=\"the IP address of the registrar where to retrieve the agents data from.\")\n    parser.add_argument('-rp', '--registrarport', action=\"store\",\n                        dest='registrar_port', help=\"the port of the registrar.\")\n    parser.add_argument('--cv_targethost', action='store', default=None, dest='cv_agent_ip',\n                        help='the IP address of the host to provision that the verifier will use (optional).  Use only if different than argument to option -t/--targethost')\n    parser.add_argument('-v', '--cv', action='store', dest='verifier_ip',\n                        help=\"the IP address of the cloud verifier\")\n    parser.add_argument('-vp', '--cvport', action='store', dest='verifier_port',\n                        help=\"the port of the cloud verifier\")\n    parser.add_argument('-vi', '--cvid', action='store', dest='verifier_id',\n                        help=\"the unique identifier of a cloud verifier\")\n    parser.add_argument('-nvc', '--no-verifier-check', action='store_false', dest='verifier_check', default=True,\n                        help='Disable the check to confirm if the agent is being processed by the specified verifier. Use only with -c/--command delete or reactivate')\n    parser.add_argument('-u', '--uuid', action='store',\n                        dest='agent_uuid', help=\"UUID for the agent to provision\")\n    parser.add_argument('-f', '--file', action='store', default=None,\n                        help='Deliver the specified plaintext to the provisioned agent')\n    parser.add_argument('--cert', action='store', dest='ca_dir', default=None,\n                        help='Create and deliver a certificate using a CA created by ca-util. Pass in the CA directory or use \"default\" to use the standard dir')\n    parser.add_argument('-k', '--key', action='store', dest='keyfile',\n                        help='an intermedia key file produced by user_data_encrypt')\n    parser.add_argument('-p', '--payload', action='store', default=None,\n                        help='Specify the encrypted payload to deliver with encrypted keys specified by -k')\n    parser.add_argument('--include', action='store', dest='incl_dir', default=None,\n                        help=\"Include additional files in provided directory in certificate zip file.  Must be specified with --cert\")\n    parser.add_argument('--allowlist', action='store', dest='allowlist',\n                        default=None, help=\"Specify the file path of an allowlist\")\n    parser.add_argument('--signature-verification-key', '--sign_verification_key', action='append', dest='ima_sign_verification_keys',\n                        default=[], help=\"Specify an IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig', action='append', dest='ima_sign_verification_key_sigs',\n                        default=[], help=\"Specify the GPG signature file for an IMA file signature verification key; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-sig-key', action='append', dest='ima_sign_verification_key_sig_keys',\n                        default=[], help=\"Specify the GPG public key file use to validate the --signature-verification-key-sig; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-url', action='append', dest='ima_sign_verification_key_urls',\n                        default=[], help=\"Specify the URL for a remote IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig-url', action='append',\n                        dest='ima_sign_verification_key_sig_urls',\n                        default=[], help=\"Specify the URL for the remote GPG signature of a remote IMA file signature verification key; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--signature-verification-key-sig-url-key', action='append',\n                        dest='ima_sign_verification_key_sig_url_keys',\n                        default=[], help=\"Specify the GPG public key file used to validate the --signature-verification-key-sig-url; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--mb_refstate', action='store', dest='mb_refstate',\n                        default=None, help=\"Specify the location of a measure boot reference state (intended state)\")\n    parser.add_argument('--allowlist-checksum', action='store', dest='allowlist_checksum',\n                        default=None, help=\"Specify the SHA-256 checksum of an allowlist\")\n    parser.add_argument('--allowlist-sig', action='store', dest='allowlist_sig',\n                        default=None, help=\"Specify the GPG signature file of an allowlist\")\n    parser.add_argument('--allowlist-sig-key', action='store', dest='allowlist_sig_key',\n                        default=None, help=\"Specify the GPG public key file used to validate the --allowlist-sig or --allowlist-sig-url\")\n    parser.add_argument('--allowlist-url', action='store', dest='allowlist_url',\n                        default=None, help=\"Specify the URL of a remote allowlist\")\n    parser.add_argument('--allowlist-sig-url', action='store', dest='allowlist_sig_url',\n                        default=None, help=\"Specify the URL of the remote GPG signature file of an allowlist\")\n    parser.add_argument('--exclude', action='store', dest='ima_exclude',\n                        default=None, help=\"Specify the location of an IMA exclude list\")\n    parser.add_argument('--tpm_policy', action='store', dest='tpm_policy', default=None,\n                        help=\"Specify a TPM policy in JSON format. e.g., {\\\"15\\\":\\\"0000000000000000000000000000000000000000\\\"}\")\n    parser.add_argument('--verify', action='store_true', default=False,\n                        help='Block on cryptographically checked key derivation confirmation from the agent once it has been provisioned')\n    parser.add_argument('--allowlist-name', help='The name of allowlist to operate with')\n    parser.add_argument('--supported-version', default=None, action=\"store\", dest='supported_version', help='API version that is supported by the agent. Detected automatically by default')\n\n    args = parser.parse_args(argv[1:])\n\n    # Make sure argument dependencies are enforced\n    if( args.allowlist and args.allowlist_url):\n        parser.error(\"--allowlist and --allowlist-url cannot be specified at the same time\")\n    if( args.allowlist_url and not (args.allowlist_sig or args.allowlist_sig_url or args.allowlist_checksum)):\n        parser.error(\"--allowlist-url must have either --allowlist-sig, --allowlist-sig-url or --allowlist-checksum to verifier integrity\")\n    if( args.allowlist_sig and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig_url and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig-url must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_checksum and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-checksum must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_url and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig-url must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_key and not (args.allowlist_sig or args.allowlist_sig_url)):\n        parser.error(\"--allowlist-sig-key must have either --allowlist-sig or --allowlist-sig-url\")\n\n    mytenant = Tenant()\n\n    if args.agent_uuid is not None:\n        mytenant.agent_uuid = args.agent_uuid\n        # if the uuid is actually a public key, then hash it\n        if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):\n            mytenant.agent_uuid = hashlib.sha256(\n                mytenant.agent_uuid).hexdigest()\n        if not validators.valid_agent_id(mytenant.agent_uuid):\n            raise UserError(\"The agent ID set via agent uuid parameter use invalid characters\")\n    else:\n        logger.warning(\"Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000\")\n        mytenant.agent_uuid = \"d432fbb3-d2f1-4a97-9ef7-75bd81c00000\"\n\n    if args.verifier_id is not None:\n        mytenant.verifier_id = args.verifier_id\n    if args.verifier_ip is not None:\n        mytenant.verifier_ip = args.verifier_ip\n    if args.verifier_port is not None:\n        mytenant.verifier_port = args.verifier_port\n\n    if args.registrar_ip is not None:\n        mytenant.registrar_ip = args.registrar_ip\n    if args.registrar_port is not None:\n        mytenant.registrar_port = args.registrar_port\n\n    # we only need to fetch remote files if we are adding or updating\n    if args.command in ['add', 'update', 'addallowlist']:\n        delete_tmp_files = logger.level > logging.DEBUG # delete tmp files unless in DEBUG mode\n\n        if args.allowlist_url:\n            logger.info(\"Downloading Allowlist from %s\", args.allowlist_url)\n            response = requests.get(args.allowlist_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist temporarily saved in %s\", args.allowlist)\n            else:\n                raise Exception(f\"Downloading allowlist ({args.allowlist_url}) failed with status code {response.status_code}!\")\n\n        if args.allowlist_sig_url:\n            logger.info(\"Downloading Allowlist signature from %s\", args.allowlist_sig_url)\n            response = requests.get(args.allowlist_sig_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist_sig = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist signature temporarily saved in %s\", args.allowlist_sig)\n            else:\n                raise Exception(f\"Downloading allowlist signature ({args.allowlist_sig_url}) failed with status code {response.status_code}!\")\n\n        # verify all the local keys for which we have a signature file and a key to verify\n        for i, key_file in enumerate(args.ima_sign_verification_keys):\n            if len(args.ima_sign_verification_key_sigs) <= i:\n                break\n            keysig_file = args.ima_sign_verification_key_sigs[i]\n            if len(args.ima_sign_verification_key_sig_keys) == 0:\n                raise UserError(f\"A gpg key is missing for key signature file '{keysig_file}'\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_keys[i]\n            signing.verify_signature_from_file(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n\n            logger.info(\"Signature verification on %s was successful\", key_file)\n\n        # verify all the remote keys for which we have a signature URL and key to to verify\n        # Append the downloaded key files to args.ima_sign_verification_keys\n        for i, key_url in enumerate(args.ima_sign_verification_key_urls):\n\n            logger.info(\"Downloading key from %s\", key_url)\n            response = requests.get(key_url, allow_redirects=False)\n            if response.status_code == 200:\n                key_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                args.ima_sign_verification_keys.append(key_file)\n                logger.debug(\"Key temporarily saved in %s\", key_file)\n            else:\n                raise Exception(f\"Downloading key ({key_url}) failed with status code {response.status_code}!\")\n\n            if len(args.ima_sign_verification_key_sig_urls) <= i:\n                continue\n\n            keysig_url = args.ima_sign_verification_key_sig_urls[i]\n\n            if len(args.ima_sign_verification_key_sig_url_keys) == 0:\n                raise UserError(f\"A gpg key is missing for key signature URL '{keysig_url}'\")\n\n            logger.info(\"Downloading key signature from %s\", keysig_url)\n            response = requests.get(keysig_url, allow_redirects=False)\n            if response.status_code == 200:\n                keysig_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Key signature temporarily saved in %s\", keysig_file)\n            else:\n                raise Exception(f\"Downloading key signature ({key_url}) failed with status code {response.status_code}!\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_url_keys[i]\n            signing.verify_signature_from_file(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n            logger.info(\"Signature verification on %s was successful\", key_url)\n\n    if args.command == 'add':\n        mytenant.init_add(vars(args))\n        mytenant.preloop()\n        mytenant.do_quote()\n        mytenant.do_cv()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'update':\n        mytenant.init_add(vars(args))\n        mytenant.do_cvdelete(args.verifier_check)\n        mytenant.preloop()\n        mytenant.do_quote()\n        mytenant.do_cv()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'delete':\n        mytenant.do_cvdelete(args.verifier_check)\n    elif args.command == 'status':\n        mytenant.do_status()\n    elif args.command == 'cvstatus':\n        mytenant.do_cvstatus()\n    elif args.command == 'bulkinfo':\n        mytenant.do_cvbulkinfo()\n    elif args.command == 'cvlist':\n        mytenant.do_cvlist()\n    elif args.command == 'reactivate':\n        mytenant.do_cvreactivate(args.verifier_check)\n    elif args.command == 'regstatus':\n        mytenant.do_regstatus()\n    elif args.command == 'reglist':\n        mytenant.do_reglist()\n    elif args.command == 'regdelete':\n        mytenant.do_regdelete()\n    elif args.command == 'addallowlist':\n        mytenant.do_add_allowlist(vars(args))\n    elif args.command == 'showallowlist':\n        mytenant.do_show_allowlist(args.allowlist_name)\n    elif args.command == 'deleteallowlist':\n        mytenant.do_delete_allowlist(args.allowlist_name)\n    else:\n        raise UserError(f\"Invalid command specified: {args.command}\")\n"], "filenames": ["keylime/cloud_verifier_tornado.py", "keylime/tenant.py"], "buggy_code_start_loc": [22, 633], "buggy_code_end_loc": [514, 633], "fixing_code_start_loc": [21, 634], "fixing_code_end_loc": [501, 636], "type": "CWE-20", "message": "Keylime does not enforce that the agent registrar data is the same when the tenant uses it for validation of the EK and identity quote and the verifier for validating the integrity quote. This allows an attacker to use one AK, EK pair from a real TPM to pass EK validation and give the verifier an AK of a software TPM. A successful attack breaks the entire chain of trust because a not validated AK is used by the verifier. This issue is worse if the validation happens first and then the agent gets added to the verifier because the timing is easier and the verifier does not validate the regcount entry being equal to 1,", "other": {"cve": {"id": "CVE-2022-1053", "sourceIdentifier": "secalert@redhat.com", "published": "2022-05-06T17:15:08.770", "lastModified": "2022-05-16T18:38:42.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Keylime does not enforce that the agent registrar data is the same when the tenant uses it for validation of the EK and identity quote and the verifier for validating the integrity quote. This allows an attacker to use one AK, EK pair from a real TPM to pass EK validation and give the verifier an AK of a software TPM. A successful attack breaks the entire chain of trust because a not validated AK is used by the verifier. This issue is worse if the validation happens first and then the agent gets added to the verifier because the timing is easier and the verifier does not validate the regcount entry being equal to 1,"}, {"lang": "es", "value": "Keylime no hace valer que los datos de registro del agente sean los mismos cuando el inquilino lo usa para la comprobaci\u00f3n del EK y la cita de identidad y el verificador para comprobar la cita de integridad. Esto permite a un atacante usar un par AK, EK de un TPM real para pasar la comprobaci\u00f3n del EK y dar al verificador un AK de un TPM de software. Un ataque con \u00e9xito rompe toda la cadena confiable porque un AK no comprobado es usado por el verificador. Este problema es peor si la comprobaci\u00f3n ocurre primero y luego el agente es agregado al verificador porque el tiempo es m\u00e1s f\u00e1cil y el verificador no comprueba que la entrada regcount sea igual a 1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keylime:keylime:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.0", "matchCriteriaId": "154878D6-11B2-481B-91A6-E509C45E4451"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2065024,", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://github.com/keylime/keylime/commit/bd5de712acdd77860e7dc58969181e16c7a8dc5d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/security/advisories/GHSA-jf66-3q76-h5p5,", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A7WAKVXM7L5D2DUACV6EHA6EJNAX2GVL/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RF6QHU4UGSBATC3HOOE7OP66CYVTR7CV/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WEW2PAXO5YGLDLPG45YV2OPLJXJSCECQ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keylime/keylime/commit/bd5de712acdd77860e7dc58969181e16c7a8dc5d"}}