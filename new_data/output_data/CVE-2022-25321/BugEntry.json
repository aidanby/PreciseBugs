{"buggy_code": ["<?php\n\nnamespace App\\Model\\Table;\n\nuse App\\Model\\Table\\AppTable;\nuse Cake\\ORM\\Table;\nuse Cake\\Validation\\Validator;\n\nrequire_once(APP . 'Model' . DS . 'Table' . DS . 'SettingProviders' . DS . 'UserSettingsProvider.php');\nuse App\\Settings\\SettingsProvider\\UserSettingsProvider;\n\nclass UserSettingsTable extends AppTable\n{\n    public $BOOKMARK_SETTING_NAME = 'ui.bookmarks';\n\n    public function initialize(array $config): void\n    {\n        parent::initialize($config);\n        $this->addBehavior('Timestamp');\n        $this->belongsTo(\n            'Users'\n        );\n        $this->setDisplayField('name');\n\n        $this->SettingsProvider = new UserSettingsProvider();\n    }\n\n    public function validationDefault(Validator $validator): Validator\n    {\n        $validator\n            ->requirePresence(['name', 'user_id'], 'create')\n            ->notEmptyString('name', __('Please fill this field'))\n            ->notEmptyString('user_id', __('Please supply the user id to which this setting belongs to'));\n        return $validator;\n    }\n\n    public function getSettingsFromProviderForUser($user_id, $full = false): array\n    {\n        $settingsTmp = $this->getSettingsForUser($user_id)->toArray();\n        $settings = [];\n        foreach ($settingsTmp as $setting) {\n            $settings[$setting->name] = $setting->value;\n        }\n        if (empty($full)) {\n            return $settings;\n        } else {\n            $settingsProvider = $this->SettingsProvider->getSettingsConfiguration($settings);\n            $settingsFlattened = $this->SettingsProvider->flattenSettingsConfiguration($settingsProvider);\n            $notices = $this->SettingsProvider->getNoticesFromSettingsConfiguration($settingsProvider, $settings);\n            return [\n                'settings' => $settings,\n                'settingsProvider' => $settingsProvider,\n                'settingsFlattened' => $settingsFlattened,\n                'notices' => $notices,\n            ];\n        }\n    }\n\n    public function getSettingsForUser($user_id)\n    {\n        return $this->find()->where([\n            'user_id' => $user_id,\n        ])->all();\n    }\n\n    public function getSettingByName($user, $name)\n    {\n        return $this->find()->where([\n            'user_id' => $user->id,\n            'name' => $name,\n        ])->first();\n    }\n\n    public function createSetting($user, $name, $value)\n    {\n        $setting = $this->newEmptyEntity();\n        $data = [\n            'name' => $name,\n            'value' => $value,\n            'user_id' => $user->id,\n        ];\n        $setting = $this->patchEntity($setting, $data);\n        $savedData = $this->save($setting);\n        return $savedData;\n    }\n\n    public function editSetting($user, $name, $value)\n    {\n        $setting = $this->getSettingByName($user, $name);\n        $setting = $this->patchEntity($setting, [\n            'value' => $value\n        ]);\n        $savedData = $this->save($setting);\n        return $savedData;\n    }\n\n    public function saveBookmark($user, $data)\n    {\n        $setting = $this->getSettingByName($user, $this->BOOKMARK_SETTING_NAME);\n        $bookmarkData = [\n            'label' => $data['bookmark_label'],\n            'name' => $data['bookmark_name'],\n            'url' => $data['bookmark_url'],\n        ];\n        if (is_null($setting)) { // setting not found, create it\n            $bookmarksData = json_encode([$bookmarkData]);\n            $result = $this->createSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        } else {\n            $bookmarksData = json_decode($setting->value);\n            $bookmarksData[] = $bookmarkData;\n            $bookmarksData = json_encode($bookmarksData);\n            $result = $this->editSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        }\n        return $result;\n    }\n\n    public function deleteBookmark($user, $data)\n    {\n        $setting = $this->getSettingByName($user, $this->BOOKMARK_SETTING_NAME);\n        $bookmarkData = [\n            'name' => $data['bookmark_name'],\n            'url' => $data['bookmark_url'],\n        ];\n        if (is_null($setting)) { // Can't delete something that doesn't exist\n            return null;\n        } else {\n            $bookmarksData = json_decode($setting->value, true);\n            foreach ($bookmarksData as $i => $savedBookmark) {\n                if ($savedBookmark['name'] == $bookmarkData['name'] && $savedBookmark['url'] == $bookmarkData['url']) {\n                    unset($bookmarksData[$i]);\n                }\n            }\n            $bookmarksData = json_encode($bookmarksData);\n            $result = $this->editSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        }\n        return $result;\n    }\n}\n", "<?php\n$bookmarks = !empty($loggedUser->user_settings_by_name['ui.bookmarks']['value']) ? json_decode($loggedUser->user_settings_by_name['ui.bookmarks']['value'], true) : [];\n?>\n\n<h3>\n    <?= $this->Bootstrap->icon('bookmark', [\n        'class' => ['fa-fw']\n    ]); ?>\n    <?= __('Bookmarks') ?>\n</h3>\n<div class=\"row\">\n    <?php if (!empty($bookmarks)): ?>\n        <ul class=\"col-sm-12 col-md-10 col-l-8 col-xl-8 mb-3\">\n            <?php foreach ($bookmarks as $bookmark) : ?>\n                <li class=\"list-group-item\">\n                    <a href=\"<?= h($bookmark['url']) ?>\" class=\"w-bold\">\n                        <?= h($bookmark['label']) ?>\n                    </a>\n                    <span class=\"ms-3 fw-light\"><?= h($bookmark['name']) ?></span>\n                </li>\n            <?php endforeach; ?>\n        </ul>\n    <?php else: ?>\n        <p class=\"fw-light\"><?= __('No bookmarks') ?></p>\n    <?php endif; ?>\n</div>\n\n<h3>\n    <?= $this->Bootstrap->icon('chart-bar', [\n        'class' => ['fa-fw']\n    ]); ?>\n    <?= __('Activity') ?>\n</h3>\n<div class=\"row\">\n    <?php foreach ($statistics as $modelName => $statistics) : ?>\n        <div class=\"col-sm-6 col-md-5 col-l-4 col-xl-3 mb-3\">\n            <?php\n            $exploded = explode('.', $modelName);\n            $modelForDisplay = $exploded[count($exploded) - 1];\n            $panelTitle = $this->Html->link(\n                h($modelForDisplay),\n                $this->Url->build([\n                    'controller' => $modelForDisplay,\n                    'action' => 'index',\n                ]),\n                ['class' => 'text-white text-decoration-none fw-light stretched-link']\n            );\n            echo $this->element('widgets/highlight-panel', [\n                'titleHtml' => $panelTitle,\n                'number' => $statistics['amount'],\n                'variation' => $statistics['variation'] ?? '',\n                'chartData' => $statistics['timeline'] ?? []\n            ]);\n            ?>\n        </div>\n    <?php endforeach ?>\n</div>\n", "<?php\n    use Cake\\Routing\\Router;\n\n    $seed = 'sb-' . mt_rand();\n    $icon = $entry['icon'] ?? '';\n    $label = $entry['label'] ?? '';\n    $name = $entry['name'] ?? '';\n    $active = false;\n\n    $url = $entry['url'];\n\n    $currentURL = Router::url(null);\n    if ($url == $currentURL) {\n        $active = true;\n    }\n\n    echo $this->Bootstrap->button([\n        'nodeType' => 'a',\n        'text' => h($label),\n        'title' => h($name),\n        'variant' => 'dark',\n        'outline' => !$active,\n        'size' => 'sm',\n        'icon' => h($icon),\n        'class' => ['mb-1'],\n        'params' => [\n            'href' => h($url),\n        ]\n    ]);\n?>\n"], "fixing_code": ["<?php\n\nnamespace App\\Model\\Table;\n\nuse App\\Model\\Table\\AppTable;\nuse Cake\\ORM\\Table;\nuse Cake\\Validation\\Validator;\n\nrequire_once(APP . 'Model' . DS . 'Table' . DS . 'SettingProviders' . DS . 'UserSettingsProvider.php');\nuse App\\Settings\\SettingsProvider\\UserSettingsProvider;\n\nclass UserSettingsTable extends AppTable\n{\n    public $BOOKMARK_SETTING_NAME = 'ui.bookmarks';\n\n    public function initialize(array $config): void\n    {\n        parent::initialize($config);\n        $this->addBehavior('Timestamp');\n        $this->belongsTo(\n            'Users'\n        );\n        $this->setDisplayField('name');\n\n        $this->SettingsProvider = new UserSettingsProvider();\n    }\n\n    public function validationDefault(Validator $validator): Validator\n    {\n        $validator\n            ->requirePresence(['name', 'user_id'], 'create')\n            ->notEmptyString('name', __('Please fill this field'))\n            ->notEmptyString('user_id', __('Please supply the user id to which this setting belongs to'));\n        return $validator;\n    }\n\n    public function getSettingsFromProviderForUser($user_id, $full = false): array\n    {\n        $settingsTmp = $this->getSettingsForUser($user_id)->toArray();\n        $settings = [];\n        foreach ($settingsTmp as $setting) {\n            $settings[$setting->name] = $setting->value;\n        }\n        if (empty($full)) {\n            return $settings;\n        } else {\n            $settingsProvider = $this->SettingsProvider->getSettingsConfiguration($settings);\n            $settingsFlattened = $this->SettingsProvider->flattenSettingsConfiguration($settingsProvider);\n            $notices = $this->SettingsProvider->getNoticesFromSettingsConfiguration($settingsProvider, $settings);\n            return [\n                'settings' => $settings,\n                'settingsProvider' => $settingsProvider,\n                'settingsFlattened' => $settingsFlattened,\n                'notices' => $notices,\n            ];\n        }\n    }\n\n    public function getSettingsForUser($user_id)\n    {\n        return $this->find()->where([\n            'user_id' => $user_id,\n        ])->all();\n    }\n\n    public function getSettingByName($user, $name)\n    {\n        return $this->find()->where([\n            'user_id' => $user->id,\n            'name' => $name,\n        ])->first();\n    }\n\n    public function createSetting($user, $name, $value)\n    {\n        $setting = $this->newEmptyEntity();\n        $data = [\n            'name' => $name,\n            'value' => $value,\n            'user_id' => $user->id,\n        ];\n        $setting = $this->patchEntity($setting, $data);\n        $savedData = $this->save($setting);\n        return $savedData;\n    }\n\n    public function editSetting($user, $name, $value)\n    {\n        $setting = $this->getSettingByName($user, $name);\n        $setting = $this->patchEntity($setting, [\n            'value' => $value\n        ]);\n        $savedData = $this->save($setting);\n        return $savedData;\n    }\n\n    public function saveBookmark($user, $data)\n    {\n        $setting = $this->getSettingByName($user, $this->BOOKMARK_SETTING_NAME);\n        $bookmarkData = [\n            'label' => $data['bookmark_label'],\n            'name' => $data['bookmark_name'],\n            'url' => $data['bookmark_url'],\n        ];\n        if (is_null($setting)) { // setting not found, create it\n            $bookmarksData = json_encode([$bookmarkData]);\n            $result = $this->createSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        } else {\n            $bookmarksData = json_decode($setting->value);\n            $bookmarksData[] = $bookmarkData;\n            $bookmarksData = json_encode($bookmarksData);\n            $result = $this->editSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        }\n        return $result;\n    }\n\n    public function deleteBookmark($user, $data)\n    {\n        $setting = $this->getSettingByName($user, $this->BOOKMARK_SETTING_NAME);\n        $bookmarkData = [\n            'name' => $data['bookmark_name'],\n            'url' => $data['bookmark_url'],\n        ];\n        if (is_null($setting)) { // Can't delete something that doesn't exist\n            return null;\n        } else {\n            $bookmarksData = json_decode($setting->value, true);\n            foreach ($bookmarksData as $i => $savedBookmark) {\n                if ($savedBookmark['name'] == $bookmarkData['name'] && $savedBookmark['url'] == $bookmarkData['url']) {\n                    unset($bookmarksData[$i]);\n                }\n            }\n            $bookmarksData = json_encode($bookmarksData);\n            $result = $this->editSetting($user, $this->BOOKMARK_SETTING_NAME, $bookmarksData);\n        }\n        return $result;\n    }\n\n    /**\n     * validURI - Ensure the provided URI can be safely put as a link\n     *\n     * @param String $uri\n     * @return bool if the URI is safe to be put as a link\n     */\n    public function validURI(String $uri): bool\n    {\n        $parsed = parse_url($uri);\n        $isLocalPath = empty($parsed['scheme']) && empty($parsed['domain']) && !empty($parsed['path']);\n        $isValidURL = !empty($parsed['scheme']) && in_array($parsed['scheme'], ['http', 'https']) && filter_var($uri, FILTER_SANITIZE_URL);\n        return $isLocalPath || $isValidURL;\n    }\n}\n", "<?php\n\nuse Cake\\ORM\\TableRegistry;\n\n$bookmarks = !empty($loggedUser->user_settings_by_name['ui.bookmarks']['value']) ? json_decode($loggedUser->user_settings_by_name['ui.bookmarks']['value'], true) : [];\n$this->userSettingsTable = TableRegistry::getTableLocator()->get('UserSettings');\n?>\n\n<h3>\n    <?= $this->Bootstrap->icon('bookmark', [\n        'class' => ['fa-fw']\n    ]); ?>\n    <?= __('Bookmarks') ?>\n</h3>\n<div class=\"row\">\n    <?php if (!empty($bookmarks)) : ?>\n        <ul class=\"col-sm-12 col-md-10 col-l-8 col-xl-8 mb-3\">\n            <?php foreach ($bookmarks as $bookmark) : ?>\n                <li class=\"list-group-item\">\n                    <?php if ($this->userSettingsTable->validURI($bookmark['url'])): ?>\n                        <a href=\"<?= h($bookmark['url']) ?>\" class=\"w-bold\">\n                            <?= h($bookmark['label']) ?>\n                        </a>\n                    <?php else: ?>\n                        <span class=\"w-bold\">\n                            <?= h($bookmark['url']) ?>\n                        </span>\n                    <?php endif; ?>\n                    <span class=\"ms-3 fw-light\"><?= h($bookmark['name']) ?></span>\n                </li>\n            <?php endforeach; ?>\n        </ul>\n    <?php else : ?>\n        <p class=\"fw-light\"><?= __('No bookmarks') ?></p>\n    <?php endif; ?>\n</div>\n\n<h3>\n    <?= $this->Bootstrap->icon('chart-bar', [\n        'class' => ['fa-fw']\n    ]); ?>\n    <?= __('Activity') ?>\n</h3>\n<div class=\"row\">\n    <?php foreach ($statistics as $modelName => $statistics) : ?>\n        <div class=\"col-sm-6 col-md-5 col-l-4 col-xl-3 mb-3\">\n            <?php\n            $exploded = explode('.', $modelName);\n            $modelForDisplay = $exploded[count($exploded) - 1];\n            $panelTitle = $this->Html->link(\n                h($modelForDisplay),\n                $this->Url->build([\n                    'controller' => $modelForDisplay,\n                    'action' => 'index',\n                ]),\n                ['class' => 'text-white text-decoration-none fw-light stretched-link']\n            );\n            echo $this->element('widgets/highlight-panel', [\n                'titleHtml' => $panelTitle,\n                'number' => $statistics['amount'],\n                'variation' => $statistics['variation'] ?? '',\n                'chartData' => $statistics['timeline'] ?? []\n            ]);\n            ?>\n        </div>\n    <?php endforeach ?>\n</div>\n", "<?php\n    use Cake\\Routing\\Router;\n    use Cake\\ORM\\TableRegistry;\n\n    $this->userSettingsTable = TableRegistry::getTableLocator()->get('UserSettings');\n\n    $seed = 'sb-' . mt_rand();\n    $icon = $entry['icon'] ?? '';\n    $label = $entry['label'] ?? '';\n    $name = $entry['name'] ?? '';\n    $active = false;\n\n    $url = $entry['url'];\n\n    $currentURL = Router::url(null);\n    if ($url == $currentURL) {\n        $active = true;\n    }\n\n    $validURI = $this->userSettingsTable->validURI($url);\n\n    echo $this->Bootstrap->button([\n        'nodeType' => 'a',\n        'text' => h($label),\n        'title' => h($name),\n        'variant' => 'dark',\n        'outline' => !$active,\n        'size' => 'sm',\n        'icon' => h($icon),\n        'class' => ['mb-1', !$validURI ? 'disabled' : ''],\n        'params' => [\n            'href' => $validURI ? h($url) : '#',\n        ]\n    ]);\n?>\n"], "filenames": ["src/Model/Table/UserSettingsTable.php", "templates/Instance/home.php", "templates/element/layouts/sidebar/bookmark-entry.php"], "buggy_code_start_loc": [137, 1, 2], "buggy_code_end_loc": [137, 24, 28], "fixing_code_start_loc": [138, 2, 3], "fixing_code_end_loc": [152, 34, 33], "type": "CWE-79", "message": "An issue was discovered in Cerebrate through 1.4. XSS could occur in the bookmarks component.", "other": {"cve": {"id": "CVE-2022-25321", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-18T06:15:10.587", "lastModified": "2022-02-24T20:20:45.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Cerebrate through 1.4. XSS could occur in the bookmarks component."}, {"lang": "es", "value": "Se ha detectado un problema en Cerebrate versiones hasta 1.4. Se pod\u00eda producir un ataque de tipo XSS en el componente bookmarks"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cerebrate-project:cerebrate:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4", "matchCriteriaId": "94801AF4-44EE-499D-AD31-99E3EA6C79E2"}]}]}], "references": [{"url": "https://github.com/cerebrate-project/cerebrate/commit/14ec995c2bd618b181197dc6b64e63fd966b4860", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cerebrate-project/cerebrate/commit/e13b4e7bc5f1a0ff59b52162cc99405e89c0544a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cerebrate-project/cerebrate/commit/14ec995c2bd618b181197dc6b64e63fd966b4860"}}