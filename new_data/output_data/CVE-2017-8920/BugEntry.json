{"buggy_code": ["#!/usr/bin/perl\n# CGI:IRC - http://cgiirc.org/\n# Copyright (C) 2000-2007 David Leadbeater <http://dgl.cx/>\n# vim:set ts=3 expandtab shiftwidth=3 cindent:\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n# Uncomment this if the server doesn't chdir (Boa).\n# BEGIN { (my $dir = $0) =~ s|[^/]+$||; chdir($dir) }\n\nuse strict;\nuse vars qw($VERSION $config $config_path);\nuse lib qw/modules interfaces/;\nno warnings 'uninitialized';\n\n($VERSION =\n'0.5.11 $Id$'\n) =~ s/^.*?(\\d\\S+) .*?([0-9a-f]{4}).*/$1 . (index($1, \"g\") > 0 ? \"$2\" : \"\")/e;\n\nrequire 'parse.pl';\n\nmy $cgi = cgi_read();\n\nfor('', '/etc/cgiirc/', '/etc/') {\n   last if -r ($config_path = $_) . 'cgiirc.config';\n}\n\n$config = parse_config($config_path . 'cgiirc.config');\n\nif(!parse_cookie()) {\n   my $cookie_domain = $config->{javascript_domain};\n   if(defined $cookie_domain) {\n      $cookie_domain = \";domain=.$cookie_domain\";\n   } else {\n      $cookie_domain = \"\";\n   }\n   print \"Set-cookie: cgiircauth=\". random(25) .\";path=/$cookie_domain\\r\\n\";\n}\nprint join(\"\\r\\n\",\n# Hack to make sure we print the correct type for stylesheets too..\n\t  'Content-type: text/' . (ref $cgi && defined $cgi->{item} &&\n        $cgi->{item} eq 'style' ? 'css' : 'html')\n# We need this for some JavaScript magic that detects the character set.\n# Basically don't send a character set for the login page..\n         . (ref $cgi && ($cgi->{item} || $cgi->{Nickname}) ? '; charset=utf-8' : ''),\n      'Pragma: no-cache',\n      'Cache-control: must-revalidate, no-cache',\n      'Expires: -1') . \"\\r\\n\";\n\n# Please leave this.\nmy $copy = <<EOF;\n<a href=\"http://cgiirc.org/\">CGI:IRC</a> $VERSION<br />\nEOF\n\nmy $scriptname = $config->{script_login} || 'irc.cgi';\n\nmy $interface = ref $cgi && defined $cgi->{interface} ? $cgi->{interface} : 'default';\n$interface =~ /^([a-z0-9]+)/;\n$interface = $1;\nrequire($interface . '.pm');\n\nif(ref $cgi && defined $cgi->{item}) {\n   print \"\\r\\n\"; # send final header\n   my $name = $cgi->{item};\n   exit unless $interface->exists($name);\n   $interface->$name($cgi, $config, 0);\n}elsif(ref $cgi && defined $cgi->{Nickname}) {\n   print \"\\r\\n\"; # send final header\n   my $r = random();\n   my($format, $style);\n   \n   my %p = ( \n         Nickname => 'nick', \n         Channel => 'chan',\n         Port => 'port',\n         Server => 'serv',\n         Realname => 'name',\n         interface => 'interface',\n         Password => 'pass',\n         Format => 'format',\n         'Character_set' => 'charset',\n      );\n   my $out;\n   for(keys %p) {\n     if(exists $cgi->{\"${_}_text\"}) {\n       if(!defined $cgi->{$_} or $cgi->{$_} eq '') {\n         $cgi->{$_} = $cgi->{\"${_}_text\"};\n       }\n     }      \n\t  next unless exists $cgi->{$_};\n\t  $out .= cgi_encode($p{$_}) . '=' . cgi_encode($cgi->{$_}) . '&';\n   }\n\n   $format = exists $cgi->{Format}\n            ? $cgi->{Format} \n            : $config->{format} || 'default';\n   $format =~ s/[^a-z]//gi;\n   $format = parse_config($config_path . \"formats/$format\");\n   $style = exists $format->{style} ? $format->{style} : 'default';\n\n   $out .= \"R=$r\";\n\n   if(defined $config->{'login secret'}) {\n      require Digest::MD5;\n      my $t = time;\n      my $token = Digest::MD5::md5_hex($t . $config->{'login secret'} . $r);\n      $out .= \"&token=$token&time=$t\";\n   }\n\n   $interface->frameset($scriptname, $config, $r, $out, $interface, $style);\n\n}elsif(defined $config->{form_redirect}) {\n   print join(\"\\r\\n\",\n         \"Status: 302\",\n         \"Location: $config->{form_redirect}\",\n         \"\",\n         $config->{form_redirect});\n}else{\n   print \"\\r\\n\"; # send final header\n\n   my $have_entities = 0;\n   eval { require HTML::Entities; $have_entities = 1; };\n\n   my(%items,@order);\n\n   my $server = dolist($config->{default_server});\n   my $channel = dolist($config->{default_channel});\n   my $port = dolist($config->{default_port});\n   my $nickname = $ENV{REMOTE_USER} || $config->{default_nick};\n   \n   my $charset = [ $config->{'irc charset'} || 'Unicode (UTF-8)' ];\n\n   # Add some useful suggestions for character sets:\n   for my $set('Western (ISO-8859-1)', 'Cyrillic (ISO-8859-5)',\n     'Cyrillic (KOI8-R)', 'Japanese (ShiftJIS)', 'Chinese (Big5)',\n     'Chinese (GB2312)', 'Korean (EUC-KR)') {\n      push @$charset, $set unless grep { $set =~ /$_/i } @$charset\n   }\n\n   if(defined $ENV{HTTP_ACCEPT_CHARSET}) {\n      for my $set(split ',', $ENV{HTTP_ACCEPT_CHARSET}) {\n         next if $set =~ /;q=0($|\\.0$)/ or $set =~ /\\*/;\n         $set =~ s/;.*//;\n         push @$charset, $set unless grep { /$set/i } @$charset; \n      }\n   }\n\n   if(ref $cgi && $cgi->{chan}) {\n      $channel = $cgi->{chan};\n   }\n\n   if(ref $cgi && $cgi->{nick}) {\n      $nickname = $cgi->{nick};\n   }\n\n   if(!defined $config->{allow_non_default} || !$config->{allow_non_default}) {\n       add_disabled($server);\n       add_disabled($channel);\n       add_disabled($port);\n   }else{\n       add_disabled($server) unless defined $config->{access_server};\n       add_disabled($port) unless defined $config->{access_port};\n       add_disabled($channel) unless defined $config->{access_channel};\n   }\n\n   opendir(FORMATS, $config_path . \"formats\");\n   my @formats;\n   for(sort readdir FORMATS) {\n      next unless !/^\\./ && -f $config_path . \"formats/$_\";\n      if($_ eq ($config->{format} || 'default')) {\n         unshift(@formats, $_);\n      }else{\n         push(@formats, $_);\n      }\n   }\n   closedir(FORMATS);\n\n   %items = (\n      Nickname => $nickname,\n      Channel => $channel,\n      Server => $server,\n      Port => $port,\n      Password => '-PASSWORD-',\n      Realname => $config->{default_name},\n      Format => \\@formats,\n      'Character set' => $charset\n   );\n\n   my $func = \\&escape_html;\n   $func = \\&HTML::Entities::encode_entities if $have_entities;\n   @items{keys %items} = map { ref $_\n         ? [map { $func->($_) } @$_]\n         : $func->($_) }\n      values %items;\n\n   $items{Nickname} =~ s/\\?/int rand 10/eg;\n\n   if(ref $cgi && $cgi->{adv}) {\n\t  if($config->{'login advanced'}) {\n\t\t @order = split(/,\\s*/, $config->{'login advanced'});\n\t  }else{\n\t\t @order = qw/Nickname Realname Server Port Channel Password Format/;\n       push @order, 'Character set';\n\t  }\n   }else{\n\t  if($config->{'login basic'}) {\n\t\t @order = split(/,\\s*/, $config->{'login basic'});\n\t  }else{\n\t\t @order = qw/Nickname Server Channel/;\n\t  }\n   }\n   $interface->login($scriptname, $interface, $copy, $config, \n         \\@order, \\%items,\n         (ref $cgi && $cgi->{adv} ? 0 : 1));\n}\n\nsub random {\n   return join('',map(('a'..'z','0'..'9')[int rand 62], 0..($_[0] || 15)));\n}\n\nsub dolist {\n   my($var) = @_;\n   my @tmp = split(/,\\s*/, $var);\n   return [@tmp] if $#tmp > 0;\n   return $var;\n}\n\nsub add_disabled {\n   if(ref $_[0]) {\n      unshift @{$_[0]}, \"-DISABLED-\";\n   } else {\n      $_[0] = \"-DISABLED- $_[0]\";\n   }\n}\n\nsub cgi_read { \n   return unless defined $ENV{REQUEST_METHOD};\n   if($ENV{REQUEST_METHOD} eq 'GET' && $ENV{QUERY_STRING}) {\n\t  return parse_query($ENV{QUERY_STRING});\n   }elsif($ENV{REQUEST_METHOD} eq 'POST' && $ENV{CONTENT_LENGTH}) {\n\t  my $tmp;\n\t  read(STDIN, $tmp, $ENV{CONTENT_LENGTH});\n\t  return parse_query($tmp);\n   }\n}\n\nsub cgi_encode { # from CGI.pm\n   my $toencode = shift;\n   $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf(\"%%%02x\",ord($1))/eg;\n   return $toencode;\n}\n\nsub error {\n   die(@_);\n}\n"], "fixing_code": ["#!/usr/bin/perl\n# CGI:IRC - http://cgiirc.org/\n# Copyright (C) 2000-2007 David Leadbeater <http://dgl.cx/>\n# vim:set ts=3 expandtab shiftwidth=3 cindent:\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n# Uncomment this if the server doesn't chdir (Boa).\n# BEGIN { (my $dir = $0) =~ s|[^/]+$||; chdir($dir) }\n\nuse strict;\nuse vars qw($VERSION $config $config_path);\nuse lib qw/modules interfaces/;\nno warnings 'uninitialized';\n\n($VERSION =\n'0.5.11 $Id$'\n) =~ s/^.*?(\\d\\S+) .*?([0-9a-f]{4}).*/$1 . (index($1, \"g\") > 0 ? \"$2\" : \"\")/e;\n\nrequire 'parse.pl';\n\nmy $cgi = cgi_read();\n\nfor('', '/etc/cgiirc/', '/etc/') {\n   last if -r ($config_path = $_) . 'cgiirc.config';\n}\n\n$config = parse_config($config_path . 'cgiirc.config');\n\nif(!parse_cookie()) {\n   my $cookie_domain = $config->{javascript_domain};\n   if(defined $cookie_domain) {\n      $cookie_domain = \";domain=.$cookie_domain\";\n   } else {\n      $cookie_domain = \"\";\n   }\n   print \"Set-cookie: cgiircauth=\". random(25) .\";path=/$cookie_domain\\r\\n\";\n}\nprint join(\"\\r\\n\",\n# Hack to make sure we print the correct type for stylesheets too..\n\t  'Content-type: text/' . (ref $cgi && defined $cgi->{item} &&\n        $cgi->{item} eq 'style' ? 'css' : 'html')\n# We need this for some JavaScript magic that detects the character set.\n# Basically don't send a character set for the login page..\n         . (ref $cgi && ($cgi->{item} || $cgi->{Nickname}) ? '; charset=utf-8' : ''),\n      'Pragma: no-cache',\n      'Cache-control: must-revalidate, no-cache',\n      'Expires: -1') . \"\\r\\n\";\n\n# Please leave this.\nmy $copy = <<EOF;\n<a href=\"http://cgiirc.org/\">CGI:IRC</a> $VERSION<br />\nEOF\n\nmy $scriptname = $config->{script_login} || 'irc.cgi';\n\nmy $interface = ref $cgi && defined $cgi->{interface} ? $cgi->{interface} : 'default';\n$interface =~ /^([a-z0-9]+)/;\n$interface = $1;\nrequire($interface . '.pm');\n\nif(ref $cgi && defined $cgi->{item}) {\n   print \"\\r\\n\"; # send final header\n   error('Communication socket name is invalid') if $cgi->{R} =~ /[^A-Za-z0-9]/;\n   my $name = $cgi->{item};\n   exit unless $interface->exists($name);\n   $interface->$name($cgi, $config, 0);\n}elsif(ref $cgi && defined $cgi->{Nickname}) {\n   print \"\\r\\n\"; # send final header\n   my $r = random();\n   my($format, $style);\n   \n   my %p = ( \n         Nickname => 'nick', \n         Channel => 'chan',\n         Port => 'port',\n         Server => 'serv',\n         Realname => 'name',\n         interface => 'interface',\n         Password => 'pass',\n         Format => 'format',\n         'Character_set' => 'charset',\n      );\n   my $out;\n   for(keys %p) {\n     if(exists $cgi->{\"${_}_text\"}) {\n       if(!defined $cgi->{$_} or $cgi->{$_} eq '') {\n         $cgi->{$_} = $cgi->{\"${_}_text\"};\n       }\n     }      \n\t  next unless exists $cgi->{$_};\n\t  $out .= cgi_encode($p{$_}) . '=' . cgi_encode($cgi->{$_}) . '&';\n   }\n\n   $format = exists $cgi->{Format}\n            ? $cgi->{Format} \n            : $config->{format} || 'default';\n   $format =~ s/[^a-z]//gi;\n   $format = parse_config($config_path . \"formats/$format\");\n   $style = exists $format->{style} ? $format->{style} : 'default';\n\n   $out .= \"R=$r\";\n\n   if(defined $config->{'login secret'}) {\n      require Digest::MD5;\n      my $t = time;\n      my $token = Digest::MD5::md5_hex($t . $config->{'login secret'} . $r);\n      $out .= \"&token=$token&time=$t\";\n   }\n\n   $interface->frameset($scriptname, $config, $r, $out, $interface, $style);\n\n}elsif(defined $config->{form_redirect}) {\n   print join(\"\\r\\n\",\n         \"Status: 302\",\n         \"Location: $config->{form_redirect}\",\n         \"\",\n         $config->{form_redirect});\n}else{\n   print \"\\r\\n\"; # send final header\n\n   my $have_entities = 0;\n   eval { require HTML::Entities; $have_entities = 1; };\n\n   my(%items,@order);\n\n   my $server = dolist($config->{default_server});\n   my $channel = dolist($config->{default_channel});\n   my $port = dolist($config->{default_port});\n   my $nickname = $ENV{REMOTE_USER} || $config->{default_nick};\n   \n   my $charset = [ $config->{'irc charset'} || 'Unicode (UTF-8)' ];\n\n   # Add some useful suggestions for character sets:\n   for my $set('Western (ISO-8859-1)', 'Cyrillic (ISO-8859-5)',\n     'Cyrillic (KOI8-R)', 'Japanese (ShiftJIS)', 'Chinese (Big5)',\n     'Chinese (GB2312)', 'Korean (EUC-KR)') {\n      push @$charset, $set unless grep { $set =~ /$_/i } @$charset\n   }\n\n   if(defined $ENV{HTTP_ACCEPT_CHARSET}) {\n      for my $set(split ',', $ENV{HTTP_ACCEPT_CHARSET}) {\n         next if $set =~ /;q=0($|\\.0$)/ or $set =~ /\\*/;\n         $set =~ s/;.*//;\n         push @$charset, $set unless grep { /$set/i } @$charset; \n      }\n   }\n\n   if(ref $cgi && $cgi->{chan}) {\n      $channel = $cgi->{chan};\n   }\n\n   if(ref $cgi && $cgi->{nick}) {\n      $nickname = $cgi->{nick};\n   }\n\n   if(!defined $config->{allow_non_default} || !$config->{allow_non_default}) {\n       add_disabled($server);\n       add_disabled($channel);\n       add_disabled($port);\n   }else{\n       add_disabled($server) unless defined $config->{access_server};\n       add_disabled($port) unless defined $config->{access_port};\n       add_disabled($channel) unless defined $config->{access_channel};\n   }\n\n   opendir(FORMATS, $config_path . \"formats\");\n   my @formats;\n   for(sort readdir FORMATS) {\n      next unless !/^\\./ && -f $config_path . \"formats/$_\";\n      if($_ eq ($config->{format} || 'default')) {\n         unshift(@formats, $_);\n      }else{\n         push(@formats, $_);\n      }\n   }\n   closedir(FORMATS);\n\n   %items = (\n      Nickname => $nickname,\n      Channel => $channel,\n      Server => $server,\n      Port => $port,\n      Password => '-PASSWORD-',\n      Realname => $config->{default_name},\n      Format => \\@formats,\n      'Character set' => $charset\n   );\n\n   my $func = \\&escape_html;\n   $func = \\&HTML::Entities::encode_entities if $have_entities;\n   @items{keys %items} = map { ref $_\n         ? [map { $func->($_) } @$_]\n         : $func->($_) }\n      values %items;\n\n   $items{Nickname} =~ s/\\?/int rand 10/eg;\n\n   if(ref $cgi && $cgi->{adv}) {\n\t  if($config->{'login advanced'}) {\n\t\t @order = split(/,\\s*/, $config->{'login advanced'});\n\t  }else{\n\t\t @order = qw/Nickname Realname Server Port Channel Password Format/;\n       push @order, 'Character set';\n\t  }\n   }else{\n\t  if($config->{'login basic'}) {\n\t\t @order = split(/,\\s*/, $config->{'login basic'});\n\t  }else{\n\t\t @order = qw/Nickname Server Channel/;\n\t  }\n   }\n   $interface->login($scriptname, $interface, $copy, $config, \n         \\@order, \\%items,\n         (ref $cgi && $cgi->{adv} ? 0 : 1));\n}\n\nsub random {\n   return join('',map(('a'..'z','0'..'9')[int rand 62], 0..($_[0] || 15)));\n}\n\nsub dolist {\n   my($var) = @_;\n   my @tmp = split(/,\\s*/, $var);\n   return [@tmp] if $#tmp > 0;\n   return $var;\n}\n\nsub add_disabled {\n   if(ref $_[0]) {\n      unshift @{$_[0]}, \"-DISABLED-\";\n   } else {\n      $_[0] = \"-DISABLED- $_[0]\";\n   }\n}\n\nsub cgi_read { \n   return unless defined $ENV{REQUEST_METHOD};\n   if($ENV{REQUEST_METHOD} eq 'GET' && $ENV{QUERY_STRING}) {\n\t  return parse_query($ENV{QUERY_STRING});\n   }elsif($ENV{REQUEST_METHOD} eq 'POST' && $ENV{CONTENT_LENGTH}) {\n\t  my $tmp;\n\t  read(STDIN, $tmp, $ENV{CONTENT_LENGTH});\n\t  return parse_query($tmp);\n   }\n}\n\nsub cgi_encode { # from CGI.pm\n   my $toencode = shift;\n   $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf(\"%%%02x\",ord($1))/eg;\n   return $toencode;\n}\n\nsub error {\n   die(@_);\n}\n"], "filenames": ["irc.cgi"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [75], "fixing_code_start_loc": [76], "fixing_code_end_loc": [77], "type": "CWE-79", "message": "irc.cgi in CGI:IRC before 0.5.12 reflects user-supplied input from the R parameter without proper output encoding, aka XSS.", "other": {"cve": {"id": "CVE-2017-8920", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-06T16:29:00.203", "lastModified": "2017-06-13T18:34:21.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "irc.cgi in CGI:IRC before 0.5.12 reflects user-supplied input from the R parameter without proper output encoding, aka XSS."}, {"lang": "es", "value": "El archivo irc.cgi en CGI:IRC anterior a versi\u00f3n 0.5.12, refleja la entrada suministrada por el usuario desde el par\u00e1metro R sin la codificaci\u00f3n de salida apropiada, tambi\u00e9n se conoce como XSS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cgiirc:cgi\\:irc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.11", "matchCriteriaId": "50A7472F-64E7-42B7-98CD-3D273F86648E"}]}]}], "references": [{"url": "http://cgiirc.org/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/dgl/cgiirc/commit/46dd48442204207b52c16065ad67d294194afd8d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dgl/cgiirc/commit/46dd48442204207b52c16065ad67d294194afd8d"}}