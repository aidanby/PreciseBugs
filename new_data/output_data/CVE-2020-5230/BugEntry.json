{"buggy_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.mediapackage.identifier;\n\nimport javax.xml.bind.annotation.adapters.XmlAdapter;\nimport javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n\n/**\n * Interface for an identifier.\n */\n@XmlJavaTypeAdapter(Id.Adapter.class)\npublic interface Id {\n\n  /**\n   * Returns the local identifier of this {@link Id}. The local identifier is defined to be free of separator characters\n   * that could potentially get into the way when creating file or directory names from the identifier.\n   *\n   * For example, given that the interface is implemented by a class representing CNRI handles, the identifier would\n   * then look something like <code>10.3930/ETHZ/abcd</code>, whith <code>10.3930</code> being the handle prefix,\n   * <code>ETH</code> the authority and <code>abcd</code> the local part. <code>toURI()</code> would then return\n   * <code>10.3930-ETH-abcd</code> or any other suitable form.\n   *\n   * @return a path separator-free representation of the identifier\n   */\n  String compact();\n\n  class Adapter extends XmlAdapter<IdImpl, Id> {\n    public IdImpl marshal(Id id) throws Exception {\n      if (id instanceof IdImpl) {\n        return (IdImpl) id;\n      } else {\n        throw new IllegalStateException(\"an unknown ID is un use: \" + id);\n      }\n    }\n\n    public Id unmarshal(IdImpl id) throws Exception {\n      return id;\n    }\n  }\n\n  /**\n   * Return a string representation of the identifier from which an object of type Id should\n   * be reconstructable.\n   */\n  String toString();\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.mediapackage.identifier;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlType;\nimport javax.xml.bind.annotation.XmlValue;\n\n/**\n * Simple and straightforward implementation of the {@link Id} interface.\n */\n@XmlType\n@XmlAccessorType(XmlAccessType.NONE)\npublic class IdImpl implements Id {\n\n  /** The identifier */\n  @XmlValue\n  protected String id = null;\n\n  /**\n   * Needed for JAXB serialization\n   */\n  public IdImpl() {\n  }\n\n  /**\n   * Creates a new identifier.\n   *\n   * @param id\n   *          the identifier\n   */\n  public IdImpl(String id) {\n    this.id = id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.mediapackage.identifier.Id#compact()\n   */\n  public String compact() {\n    return id.replaceAll(\"/\", \"-\").replaceAll(\"\\\\\\\\\", \"-\");\n  }\n\n  @Override\n  public String toString() {\n    return id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#equals(java.lang.Object)\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof IdImpl) {\n      IdImpl other = (IdImpl) o;\n      return id != null && other.id != null && id.equals(other.id);\n    }\n    return false;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#hashCode()\n   */\n  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.endpoint;\n\nimport static org.apache.commons.lang3.StringUtils.trimToNull;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.IngestServiceImpl;\nimport org.opencastproject.job.api.JobProducer;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCores;\nimport org.opencastproject.rest.AbstractJobProducerEndpoint;\nimport org.opencastproject.scheduler.api.SchedulerConflictException;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Function0.X;\nimport org.opencastproject.util.doc.rest.RestParameter;\nimport org.opencastproject.util.doc.rest.RestQuery;\nimport org.opencastproject.util.doc.rest.RestResponse;\nimport org.opencastproject.util.doc.rest.RestService;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowParser;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.fileupload.FileItemIterator;\nimport org.apache.commons.fileupload.FileItemStream;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedHashMap;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.Response.Status;\n\n/**\n * Creates and augments Opencast MediaPackages using the api. Stores media into the Working File Repository.\n */\n@Path(\"/\")\n@RestService(name = \"ingestservice\", title = \"Ingest Service\", abstractText = \"This service creates and augments Opencast media packages that include media tracks, metadata \"\n        + \"catalogs and attachments.\", notes = {\n        \"All paths above are relative to the REST endpoint base (something like http://your.server/files)\",\n        \"If the service is down or not working it will return a status 503, this means the the underlying service is \"\n                + \"not working and is either restarting or has failed\",\n        \"A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In \"\n                + \"other words, there is a bug! You should file an error report with your server logs from the time when the \"\n                + \"error occurred: <a href=\\\"https://opencast.jira.com\\\">Opencast Issue Tracker</a>\" })\npublic class IngestRestService extends AbstractJobProducerEndpoint {\n\n  private static final Logger logger = LoggerFactory.getLogger(IngestRestService.class);\n\n  /** Key for the default workflow definition in config.properties */\n  protected static final String DEFAULT_WORKFLOW_DEFINITION = \"org.opencastproject.workflow.default.definition\";\n\n  /** Key for the default maximum number of ingests in config.properties */\n  protected static final String MAX_INGESTS_KEY = \"org.opencastproject.ingest.max.concurrent\";\n\n  /** The http request parameter used to provide the workflow instance id */\n  protected static final String WORKFLOW_INSTANCE_ID_PARAM = \"workflowInstanceId\";\n\n  /** The http request parameter used to provide the workflow definition id */\n  protected static final String WORKFLOW_DEFINITION_ID_PARAM = \"workflowDefinitionId\";\n\n  /** The default workflow definition */\n  private String defaultWorkflowDefinitionId = null;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** Dublin Core Terms: http://purl.org/dc/terms/ */\n  private static List<String> dcterms = Arrays.asList(\"abstract\", \"accessRights\", \"accrualMethod\",\n          \"accrualPeriodicity\", \"accrualPolicy\", \"alternative\", \"audience\", \"available\", \"bibliographicCitation\",\n          \"conformsTo\", \"contributor\", \"coverage\", \"created\", \"creator\", \"date\", \"dateAccepted\", \"dateCopyrighted\",\n          \"dateSubmitted\", \"description\", \"educationLevel\", \"extent\", \"format\", \"hasFormat\", \"hasPart\", \"hasVersion\",\n          \"identifier\", \"instructionalMethod\", \"isFormatOf\", \"isPartOf\", \"isReferencedBy\", \"isReplacedBy\",\n          \"isRequiredBy\", \"issued\", \"isVersionOf\", \"language\", \"license\", \"mediator\", \"medium\", \"modified\",\n          \"provenance\", \"publisher\", \"references\", \"relation\", \"replaces\", \"requires\", \"rights\", \"rightsHolder\",\n          \"source\", \"spatial\", \"subject\", \"tableOfContents\", \"temporal\", \"title\", \"type\", \"valid\");\n\n  private MediaPackageBuilderFactory factory = null;\n  private IngestService ingestService = null;\n  private ServiceRegistry serviceRegistry = null;\n  private DublinCoreCatalogService dublinCoreService;\n  // The number of ingests this service can handle concurrently.\n  private int ingestLimit = -1;\n  /* Stores a map workflow ID and date to update the ingest start times post-hoc */\n  private Cache<String, Date> startCache = null;\n  /* Formatter to for the date into a string */\n  private DateFormat formatter = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);\n\n  public IngestRestService() {\n    factory = MediaPackageBuilderFactory.newInstance();\n    startCache = CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.DAYS).build();\n  }\n\n  /**\n   * Returns the maximum number of concurrent ingest operations or <code>-1</code> if no limit is enforced.\n   *\n   * @return the maximum number of concurrent ingest operations\n   * @see #isIngestLimitEnabled()\n   */\n  protected synchronized int getIngestLimit() {\n    return ingestLimit;\n  }\n\n  /**\n   * Sets the maximum number of concurrent ingest operations. Use <code>-1</code> to indicate no limit.\n   *\n   * @param ingestLimit\n   *          the limit\n   */\n  private synchronized void setIngestLimit(int ingestLimit) {\n    this.ingestLimit = ingestLimit;\n  }\n\n  /**\n   * Returns <code>true</code> if a maximum number of concurrent ingest operations has been defined.\n   *\n   * @return <code>true</code> if there is a maximum number of concurrent ingests\n   */\n  protected synchronized boolean isIngestLimitEnabled() {\n    return ingestLimit >= 0;\n  }\n\n  /**\n   * Callback for activation of this component.\n   */\n  public void activate(ComponentContext cc) {\n    if (cc != null) {\n      defaultWorkflowDefinitionId = trimToNull(cc.getBundleContext().getProperty(DEFAULT_WORKFLOW_DEFINITION));\n      if (defaultWorkflowDefinitionId == null) {\n        defaultWorkflowDefinitionId = \"schedule-and-upload\";\n      }\n      if (cc.getBundleContext().getProperty(MAX_INGESTS_KEY) != null) {\n        try {\n          ingestLimit = Integer.parseInt(trimToNull(cc.getBundleContext().getProperty(MAX_INGESTS_KEY)));\n          if (ingestLimit == 0) {\n            ingestLimit = -1;\n          }\n        } catch (NumberFormatException e) {\n          logger.warn(\"Max ingest property with key \" + MAX_INGESTS_KEY\n                  + \" isn't defined so no ingest limit will be used.\");\n          ingestLimit = -1;\n        }\n      }\n    }\n  }\n\n  @PUT\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"createMediaPackageWithID/{id}\")\n  @RestQuery(name = \"createMediaPackageWithID\", description = \"Create an empty media package with ID /n Overrides Existing Mediapackage \", pathParameters = {\n          @RestParameter(description = \"The Id for the new Mediapackage\", isRequired = true, name = \"id\", type = RestParameter.Type.STRING) }, reponses = {\n          @RestResponse(description = \"Returns media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response createMediaPackage(@PathParam(\"id\") String mediaPackageId) {\n    MediaPackage mp;\n    try {\n      mp = ingestService.createMediaPackage(mediaPackageId);\n\n      startCache.put(mp.getIdentifier().toString(), new Date());\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @GET\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"createMediaPackage\")\n  @RestQuery(name = \"createMediaPackage\", description = \"Create an empty media package\", restParameters = {\n         }, reponses = {\n          @RestResponse(description = \"Returns media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response createMediaPackage() {\n    MediaPackage mp;\n    try {\n      mp = ingestService.createMediaPackage();\n      startCache.put(mp.getIdentifier().toString(), new Date());\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Path(\"discardMediaPackage\")\n  @RestQuery(name = \"discardMediaPackage\", description = \"Discard a media package\", restParameters = { @RestParameter(description = \"Given media package to be destroyed\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response discardMediaPackage(@FormParam(\"mediaPackage\") String mpx) {\n    logger.debug(\"discardMediaPackage(MediaPackage): {}\", mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      ingestService.discardMediaPackage(mp);\n      return Response.ok().build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addTrack\")\n  @RestQuery(name = \"addTrackURL\", description = \"Add a media track to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the media\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of media\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The Tags of the  media track\", isRequired = false, name = \"tags\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageTrack(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,  @FormParam(\"tags\")  String tags,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add media package from url: {} flavor: {} tags: {} mediaPackage: {}\", url, flavor, tags, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      String[] tagsArray = null;\n      if (tags != null) {\n        tagsArray = tags.split(\",\");\n      }\n      mp = ingestService.addTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), tagsArray, mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addTrack\")\n  @RestQuery(\n    name = \"addTrackInputStream\",\n    description = \"Add a media track to a given media package using an input stream\",\n    restParameters = {\n      @RestParameter(description = \"The kind of media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The Tags of the  media track\", isRequired = false, name = \"tags\", type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n    bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n    reponses = {\n      @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n      @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n    returnDescription = \"\")\n  public Response addMediaPackageTrack(@Context HttpServletRequest request) {\n    logger.trace(\"add track as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Track);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addPartialTrack\")\n  @RestQuery(name = \"addPartialTrackURL\", description = \"Add a partial media track to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the media\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of media\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The start time in milliseconds\", isRequired = true, name = \"startTime\", type = RestParameter.Type.INTEGER),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackagePartialTrack(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"startTime\") Long startTime, @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add partial track with url: {} flavor: {} startTime: {} mediaPackage: {}\",\n            url, flavor, startTime, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n\n      mp = ingestService.addPartialTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), startTime, mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addPartialTrack\")\n  @RestQuery(name = \"addPartialTrackInputStream\", description = \"Add a partial media track to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The start time in milliseconds\", isRequired = true, name = \"startTime\", type = RestParameter.Type.INTEGER),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackagePartialTrack(@Context HttpServletRequest request) {\n    logger.trace(\"add partial track as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Track);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addCatalog\")\n  @RestQuery(name = \"addCatalogURL\", description = \"Add a metadata catalog to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the catalog\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of catalog\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageCatalog(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add catalog with url: {} flavor: {} mediaPackage: {}\", url, flavor, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      MediaPackage resultingMediaPackage = ingestService.addCatalog(new URI(url),\n              MediaPackageElementFlavor.parseFlavor(flavor), mp);\n      return Response.ok(resultingMediaPackage).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addCatalog\")\n  @RestQuery(name = \"addCatalogInputStream\", description = \"Add a metadata catalog to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of media catalog\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The metadata catalog file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageCatalog(@Context HttpServletRequest request) {\n    logger.trace(\"add catalog as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Catalog);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addAttachment\")\n  @RestQuery(name = \"addAttachmentURL\", description = \"Add an attachment to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the attachment\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of attachment\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageAttachment(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add attachment with url: {} flavor: {} mediaPackage: {}\", url, flavor, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      mp = ingestService.addAttachment(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addAttachment\")\n  @RestQuery(name = \"addAttachmentInputStream\", description = \"Add an attachment to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of attachment\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The attachment file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageAttachment(@Context HttpServletRequest request) {\n    logger.trace(\"add attachment as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Attachment);\n  }\n\n  protected Response addMediaPackageElement(HttpServletRequest request, MediaPackageElement.Type type) {\n    MediaPackageElementFlavor flavor = null;\n    InputStream in = null;\n    try {\n      String fileName = null;\n      MediaPackage mp = null;\n      Long startTime = null;\n      String[] tags = null;\n      /* Only accept multipart/form-data */\n      if (!ServletFileUpload.isMultipartContent(request)) {\n        logger.trace(\"request isn't multipart-form-data\");\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      }\n      boolean isDone = false;\n      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n        FileItemStream item = iter.next();\n        String fieldName = item.getFieldName();\n        if (item.isFormField()) {\n          if (\"flavor\".equals(fieldName)) {\n            String flavorString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"flavor: {}\", flavorString);\n            if (flavorString != null) {\n              try {\n                flavor = MediaPackageElementFlavor.parseFlavor(flavorString);\n              } catch (IllegalArgumentException e) {\n                String error = String.format(\"Could not parse flavor '%s'\", flavorString);\n                logger.debug(error, e);\n                return Response.status(Status.BAD_REQUEST).entity(error).build();\n              }\n            }\n          } else if (\"tags\".equals(fieldName)) {\n            String tagsString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"tags: {}\", tagsString);\n            tags = tagsString.split(\",\");\n          } else if (\"mediaPackage\".equals(fieldName)) {\n            try {\n              String mediaPackageString = Streams.asString(item.openStream(), \"UTF-8\");\n              logger.trace(\"mediaPackage: {}\", mediaPackageString);\n              mp = factory.newMediaPackageBuilder().loadFromXml(mediaPackageString);\n            } catch (MediaPackageException e) {\n              logger.debug(\"Unable to parse the 'mediaPackage' parameter: {}\", ExceptionUtils.getMessage(e));\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n          } else if (\"startTime\".equals(fieldName) && \"/addPartialTrack\".equals(request.getPathInfo())) {\n            String startTimeString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"startTime: {}\", startTime);\n            try {\n              startTime = Long.parseLong(startTimeString);\n            } catch (Exception e) {\n              logger.debug(\"Unable to parse the 'startTime' parameter: {}\", ExceptionUtils.getMessage(e));\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n          }\n        } else {\n          if (flavor == null) {\n            /* A flavor has to be specified in the request prior the video file */\n            logger.debug(\"A flavor has to be specified in the request prior to the content BODY\");\n            return Response.serverError().status(Status.BAD_REQUEST).build();\n          }\n          fileName = item.getName();\n          in = item.openStream();\n          isDone = true;\n        }\n        if (isDone) {\n          break;\n        }\n      }\n      /*\n       * Check if we actually got a valid request including a message body and a valid mediapackage to attach the\n       * element to\n       */\n      if (in == null || mp == null || MediaPackageSupport.sanityCheck(mp).isSome()) {\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      }\n      switch (type) {\n        case Attachment:\n          mp = ingestService.addAttachment(in, fileName, flavor, tags, mp);\n          break;\n        case Catalog:\n          mp = ingestService.addCatalog(in, fileName, flavor, tags, mp);\n          break;\n        case Track:\n          if (startTime == null) {\n            mp = ingestService.addTrack(in, fileName, flavor, tags, mp);\n          } else {\n            mp = ingestService.addPartialTrack(in, fileName, flavor, startTime, mp);\n          }\n          break;\n        default:\n          throw new IllegalStateException(\"Type must be one of track, catalog, or attachment\");\n      }\n      return Response.ok(MediaPackageParser.getAsXml(mp)).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addMediaPackage\")\n  @RestQuery(name = \"addMediaPackage\",\n      description = \"<p>Create and ingest media package from media tracks with additional Dublin Core metadata. It is \"\n        + \"mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC \"\n        + \"catalog with a title included.  The identifier of the newly created media package will be taken from the \"\n        + \"<em>identifier</em> field or the episode DublinCore catalog (deprecated<sup>*</sup>). If no identifier is \"\n        + \"set, a new random UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for \"\n        + \"scheduled recordings. Its primary use is for manual ingests with command line tools like curl.</p> \"\n        + \"<p>Multiple tracks can be ingested by using multiple form fields. It is important to always set the \"\n        + \"flavor of the next media file <em>before</em> sending the media file itself.</p>\"\n        + \"<b>(*)</b> The special treatment of the identifier field is deprecated and may be removed in future versions \"\n        + \"without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. \"\n        + \"<h3>Example curl command:</h3>\"\n        + \"<p>Ingest one video file:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \\n\"\n        + \"</pre></p>\"\n        + \"<p>Ingest two video files:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\\\\n\"\n        + \"    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \\n\"\n        + \"</pre></p>\",\n      restParameters = {\n          @RestParameter(description = \"The kind of media track. This has to be specified prior to each media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"abstract\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"accessRights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"available\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"contributor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"coverage\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"created\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"creator\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"date\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"description\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"extent\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"format\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"identifier\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isPartOf\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReferencedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReplacedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"language\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"license\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"publisher\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"relation\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"replaces\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rightsHolder\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"source\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"spatial\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"subject\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"temporal\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"title\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"type\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of a media track file\", isRequired = false, name = \"mediaUri\", type = RestParameter.Type.STRING) },\n      bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n      reponses = {\n          @RestResponse(description = \"Ingest successfull. Returns workflow instance as xml\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Ingest failed due to invalid requests.\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"Ingest failed. Something went wrong internally. Please have a look at the log files\",\n              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n      returnDescription = \"\")\n  public Response addMediaPackage(@Context HttpServletRequest request) {\n    logger.trace(\"add mediapackage as multipart-form-data\");\n    return addMediaPackage(request, null);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addMediaPackage/{wdID}\")\n  @RestQuery(name = \"addMediaPackage\",\n      description = \"<p>Create and ingest media package from media tracks with additional Dublin Core metadata. It is \"\n        + \"mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC \"\n        + \"catalog with a title included.  The identifier of the newly created media package will be taken from the \"\n        + \"<em>identifier</em> field or the episode DublinCore catalog (deprecated<sup>*</sup>). If no identifier is \"\n        + \"set, a newa randumm UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for \"\n        + \"scheduled recordings. It's primary use is for manual ingests with command line tools like curl.</p> \"\n        + \"<p>Multiple tracks can be ingested by using multiple form fields. It's important, however, to always set the \"\n        + \"flavor of the next media file <em>before</em> sending the media file itself.</p>\"\n        + \"<b>(*)</b> The special treatment of the identifier field is deprecated any may be removed in future versions \"\n        + \"without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. \"\n        + \"<h3>Example curl command:</h3>\"\n        + \"<p>Ingest one video file:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage/fast -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \\n\"\n        + \"</pre></p>\"\n        + \"<p>Ingest two video files:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage/fast -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\\\\n\"\n        + \"    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \\n\"\n        + \"</pre></p>\",\n      pathParameters = {\n          @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n      restParameters = {\n          @RestParameter(description = \"The kind of media track. This has to be specified prior to each media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"abstract\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"accessRights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"available\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"contributor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"coverage\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"created\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"creator\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"date\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"description\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"extent\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"format\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"identifier\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isPartOf\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReferencedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReplacedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"language\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"license\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"publisher\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"relation\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"replaces\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rightsHolder\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"source\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"spatial\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"subject\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"temporal\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"title\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"type\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of a media track file\", isRequired = false, name = \"mediaUri\", type = RestParameter.Type.STRING) },\n      bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n      reponses = {\n          @RestResponse(description = \"Ingest successfull. Returns workflow instance as XML\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Ingest failed due to invalid requests.\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"Ingest failed. Something went wrong internally. Please have a look at the log files\",\n              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n      returnDescription = \"\")\n  public Response addMediaPackage(@Context HttpServletRequest request, @PathParam(\"wdID\") String wdID) {\n    logger.trace(\"add mediapackage as multipart-form-data with workflow definition id: {}\", wdID);\n    MediaPackageElementFlavor flavor = null;\n    try {\n      MediaPackage mp = ingestService.createMediaPackage();\n      DublinCoreCatalog dcc = null;\n      Map<String, String> workflowProperties = new HashMap<>();\n      int seriesDCCatalogNumber = 0;\n      int episodeDCCatalogNumber = 0;\n      boolean hasMedia = false;\n      if (ServletFileUpload.isMultipartContent(request)) {\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            String fieldName = item.getFieldName();\n            String value = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"form field {}: {}\", fieldName, value);\n            /* Ignore empty fields */\n            if (\"\".equals(value)) {\n              continue;\n            }\n\n            /* \u201cRemember\u201d the flavor for the next media. */\n            if (\"flavor\".equals(fieldName)) {\n              try {\n                flavor = MediaPackageElementFlavor.parseFlavor(value);\n              } catch (IllegalArgumentException e) {\n                String error = String.format(\"Could not parse flavor '%s'\", value);\n                logger.debug(error, e);\n                return Response.status(Status.BAD_REQUEST).entity(error).build();\n              }\n              /* Fields for DC catalog */\n            } else if (dcterms.contains(fieldName)) {\n              if (\"identifier\".equals(fieldName)) {\n                /* Use the identifier for the mediapackage */\n                mp.setIdentifier(new IdImpl(value));\n              }\n              EName en = new EName(DublinCore.TERMS_NS_URI, fieldName);\n              if (dcc == null) {\n                dcc = dublinCoreService.newInstance();\n              }\n              dcc.add(en, value);\n\n              /* Episode metadata by URL */\n            } else if (\"episodeDCCatalogUri\".equals(fieldName)) {\n              try {\n                URI dcurl = new URI(value);\n                updateMediaPackageID(mp, dcurl);\n                ingestService.addCatalog(dcurl, MediaPackageElements.EPISODE, mp);\n                episodeDCCatalogNumber += 1;\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n\n              /* Episode metadata DC catalog (XML) as string */\n            } else if (\"episodeDCCatalog\".equals(fieldName)) {\n              InputStream is = new ByteArrayInputStream(value.getBytes(\"UTF-8\"));\n              updateMediaPackageID(mp, is);\n              is.reset();\n              String fileName = \"episode\" + episodeDCCatalogNumber + \".xml\";\n              episodeDCCatalogNumber += 1;\n              ingestService.addCatalog(is, fileName, MediaPackageElements.EPISODE, mp);\n\n              /* Series by URL */\n            } else if (\"seriesDCCatalogUri\".equals(fieldName)) {\n              try {\n                URI dcurl = new URI(value);\n                ingestService.addCatalog(dcurl, MediaPackageElements.SERIES, mp);\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n\n              /* Series DC catalog (XML) as string */\n            } else if (\"seriesDCCatalog\".equals(fieldName)) {\n              String fileName = \"series\" + seriesDCCatalogNumber + \".xml\";\n              seriesDCCatalogNumber += 1;\n              InputStream is = new ByteArrayInputStream(value.getBytes(\"UTF-8\"));\n              ingestService.addCatalog(is, fileName, MediaPackageElements.SERIES, mp);\n\n              /* Add media files by URL */\n            } else if (\"mediaUri\".equals(fieldName)) {\n              if (flavor == null) {\n                /* A flavor has to be specified in the request prior the media file */\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n              URI mediaUrl;\n              try {\n                mediaUrl = new URI(value);\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n              ingestService.addTrack(mediaUrl, flavor, mp);\n              hasMedia = true;\n\n            } else {\n              /* Tread everything else as workflow properties */\n              workflowProperties.put(fieldName, value);\n            }\n\n            /* Media files as request parameter */\n          } else {\n            if (flavor == null) {\n              /* A flavor has to be specified in the request prior the video file */\n              logger.debug(\"A flavor has to be specified in the request prior to the content BODY\");\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n            ingestService.addTrack(item.openStream(), item.getName(), flavor, mp);\n            hasMedia = true;\n          }\n        }\n\n        /* Check if we got any media. Fail if not. */\n        if (!hasMedia) {\n          logger.warn(\"Rejected ingest without actual media.\");\n          return Response.serverError().status(Status.BAD_REQUEST).build();\n        }\n\n        /* Add episode mediapackage if metadata were send separately */\n        if (dcc != null) {\n          ByteArrayOutputStream out = new ByteArrayOutputStream();\n          dcc.toXml(out, true);\n          InputStream in = new ByteArrayInputStream(out.toByteArray());\n          ingestService.addCatalog(in, \"dublincore.xml\", MediaPackageElements.EPISODE, mp);\n\n          /* Check if we have metadata for the episode */\n        } else if (episodeDCCatalogNumber == 0) {\n          logger.warn(\"Rejected ingest without episode metadata. At least provide a title.\");\n          return Response.serverError().status(Status.BAD_REQUEST).build();\n        }\n\n        WorkflowInstance workflow = (wdID == null) ? ingestService.ingest(mp) : ingestService.ingest(mp, wdID,\n                workflowProperties);\n        return Response.ok(workflow).build();\n      }\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  /**\n   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.\n   *\n   * @param mp\n   *          MediaPackage to modify\n   * @param is\n   *          InputStream containing the episode DublinCore catalog\n   */\n  private void updateMediaPackageID(MediaPackage mp, InputStream is) throws IOException {\n    DublinCoreCatalog dc = DublinCores.read(is);\n    EName en = new EName(DublinCore.TERMS_NS_URI, \"identifier\");\n    String id = dc.getFirst(en);\n    if (id != null) {\n      mp.setIdentifier(new IdImpl(id));\n    }\n  }\n\n  /**\n   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.\n   *\n   * @param mp\n   *          MediaPackage to modify\n   * @param uri\n   *          URI to get the episode DublinCore catalog from\n   */\n  private void updateMediaPackageID(MediaPackage mp, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        response = httpClient.execute(get);\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else {\n        in = uri.toURL().openStream();\n      }\n      updateMediaPackageID(mp, in);\n      in.close();\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n  }\n\n  @POST\n  @Path(\"addZippedMediaPackage/{workflowDefinitionId}\")\n  @Produces(MediaType.TEXT_XML)\n  @RestQuery(name = \"addZippedMediaPackage\", description = \"Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments\", pathParameters = { @RestParameter(description = \"Workflow definition id\", isRequired = true, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING) }, restParameters = { @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = \"The compressed (application/zip) media package file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_NOT_FOUND),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = \"\")\n  public Response addZippedMediaPackage(@Context HttpServletRequest request,\n          @PathParam(\"workflowDefinitionId\") String wdID, @QueryParam(\"id\") String wiID) {\n    logger.trace(\"add zipped media package with workflow definition id: {} and workflow instance id: {}\", wdID, wiID);\n    if (!isIngestLimitEnabled() || getIngestLimit() > 0) {\n      return ingestZippedMediaPackage(request, wdID, wiID);\n    } else {\n      logger.warn(\"Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.\");\n      return Response.status(Status.SERVICE_UNAVAILABLE).build();\n    }\n  }\n\n  @POST\n  @Path(\"addZippedMediaPackage\")\n  @Produces(MediaType.TEXT_XML)\n  @RestQuery(name = \"addZippedMediaPackage\", description = \"Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments\", restParameters = {\n          @RestParameter(description = \"The workflow definition ID to run on this mediapackage. \"\n                  + \"This parameter has to be set in the request prior to the zipped mediapackage \"\n                  + \"(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} instead)\", isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage. \"\n                  + \"This parameter has to be set in the request prior to the zipped mediapackage \"\n                  + \"(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} with a path parameter instead)\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = \"The compressed (application/zip) media package file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_NOT_FOUND),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = \"\")\n  public Response addZippedMediaPackage(@Context HttpServletRequest request) {\n    logger.trace(\"add zipped media package\");\n    if (!isIngestLimitEnabled() || getIngestLimit() > 0) {\n      return ingestZippedMediaPackage(request, null, null);\n    } else {\n      logger.warn(\"Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.\");\n      return Response.status(Status.SERVICE_UNAVAILABLE).build();\n    }\n  }\n\n  private Response ingestZippedMediaPackage(HttpServletRequest request, String wdID, String wiID) {\n    if (isIngestLimitEnabled()) {\n      setIngestLimit(getIngestLimit() - 1);\n      logger.debug(\"An ingest has started so remaining ingest limit is \" + getIngestLimit());\n    }\n    InputStream in = null;\n    Date started = new Date();\n\n    logger.info(\"Received new request from {} to ingest a zipped mediapackage\", request.getRemoteHost());\n\n    try {\n      String workflowDefinitionId = wdID;\n      String workflowIdAsString = wiID;\n      Long workflowInstanceIdAsLong = null;\n      Map<String, String> workflowConfig = new HashMap<>();\n      if (ServletFileUpload.isMultipartContent(request)) {\n        boolean isDone = false;\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            String fieldName = item.getFieldName();\n            String value = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"{}: {}\", fieldName, value);\n            if (WORKFLOW_INSTANCE_ID_PARAM.equals(fieldName)) {\n              workflowIdAsString = value;\n              continue;\n            } else if (WORKFLOW_DEFINITION_ID_PARAM.equals(fieldName)) {\n              workflowDefinitionId = value;\n              continue;\n            } else {\n              logger.debug(\"Processing form field: \" + fieldName);\n              workflowConfig.put(fieldName, value);\n            }\n          } else {\n            logger.debug(\"Processing file item\");\n            // once the body gets read iter.hasNext must not be invoked or the stream can not be read\n            // MH-9579\n            in = item.openStream();\n            isDone = true;\n          }\n          if (isDone)\n            break;\n        }\n      } else {\n        logger.debug(\"Processing file item\");\n        in = request.getInputStream();\n      }\n\n      // Adding ingest start time to workflow configuration\n      DateFormat formatter = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);\n      workflowConfig.put(IngestService.START_DATE_KEY, formatter.format(started));\n\n      /* Legacy support: Try to convert the workflowId to integer */\n      if (!StringUtils.isBlank(workflowIdAsString)) {\n        try {\n          workflowInstanceIdAsLong = Long.parseLong(workflowIdAsString);\n        } catch (NumberFormatException e) {\n          // The workflowId is not a long value and might be the media package identifier\n          workflowConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowIdAsString);\n        }\n      }\n      if (StringUtils.isBlank(workflowDefinitionId)) {\n        workflowDefinitionId = defaultWorkflowDefinitionId;\n      }\n\n      WorkflowInstance workflow;\n      if (workflowInstanceIdAsLong != null) {\n        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig,\n                workflowInstanceIdAsLong);\n      } else {\n        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig);\n      }\n      return Response.ok(WorkflowParser.toXml(workflow)).build();\n    } catch (NotFoundException e) {\n      logger.info(e.getMessage());\n      return Response.status(Status.NOT_FOUND).build();\n    } catch (MediaPackageException e) {\n      logger.warn(e.getMessage());\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    } finally {\n      IOUtils.closeQuietly(in);\n      if (isIngestLimitEnabled()) {\n        setIngestLimit(getIngestLimit() + 1);\n        logger.debug(\"An ingest has finished so increased ingest limit to \" + getIngestLimit());\n      }\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_HTML)\n  @Path(\"ingest/{wdID}\")\n  @RestQuery(name = \"ingest\", description = \"Ingest the completed media package into the system, retrieving all URL-referenced files, and starting a specified workflow\",\n    pathParameters = {\n      @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n    restParameters = {\n      @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n    reponses = {\n      @RestResponse(description = \"Returns the media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n    returnDescription = \"\")\n  public Response ingest(@Context HttpServletRequest request, @PathParam(\"wdID\") String wdID) {\n    logger.trace(\"ingest media package with workflow definition id: {}\", wdID);\n    if (StringUtils.isBlank(wdID)) {\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n    return ingest(wdID, request);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_HTML)\n  @Path(\"ingest\")\n  @RestQuery(name = \"ingest\", description = \"Ingest the completed media package into the system, retrieving all URL-referenced files\",\n    restParameters = {\n      @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT),\n      @RestParameter(description = \"Workflow definition id\", isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) },\n    reponses = {\n      @RestResponse(description = \"Returns the media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n    returnDescription = \"\")\n  public Response ingest(@Context HttpServletRequest request) {\n    return ingest(null, request);\n  }\n\n  private Map<String, String> getWorkflowConfig(MultivaluedMap<String, String> formData) {\n    Map<String, String> wfConfig = new HashMap<>();\n    for (String key : formData.keySet()) {\n      if (!\"mediaPackage\".equals(key)) {\n        wfConfig.put(key, formData.getFirst(key));\n      }\n    }\n    return wfConfig;\n  }\n\n  private Response ingest(final String wdID, final HttpServletRequest request) {\n    /* Note: We use a MultivaluedMap here to ensure that we can get any arbitrary form parameters. This is required to\n     * enable things like holding for trim or distributing to YouTube. */\n    final MultivaluedMap<String, String> formData = new MultivaluedHashMap<>();\n    if (ServletFileUpload.isMultipartContent(request)) {\n      // parse form fields\n      try {\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            final String value = Streams.asString(item.openStream(), \"UTF-8\");\n            formData.putSingle(item.getFieldName(), value);\n          }\n        }\n      } catch (FileUploadException | IOException e) {\n        return Response.status(Response.Status.BAD_REQUEST).build();\n      }\n    } else {\n      request.getParameterMap().forEach((key, value) -> formData.put(key, Arrays.asList(value)));\n    }\n\n    final Map<String, String> wfConfig = getWorkflowConfig(formData);\n    if (StringUtils.isNotBlank(wdID))\n      wfConfig.put(WORKFLOW_DEFINITION_ID_PARAM, wdID);\n\n    final MediaPackage mp;\n    try {\n      mp = factory.newMediaPackageBuilder().loadFromXml(formData.getFirst(\"mediaPackage\"));\n      if (MediaPackageSupport.sanityCheck(mp).isSome()) {\n        logger.warn(\"Rejected ingest with invalid mediapackage {}\", mp);\n        return Response.status(Status.BAD_REQUEST).build();\n      }\n    } catch (Exception e) {\n      logger.warn(\"Rejected ingest without mediapackage\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    final String workflowInstance = wfConfig.get(WORKFLOW_INSTANCE_ID_PARAM);\n    final String workflowDefinition = wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM);\n\n    // Adding ingest start time to workflow configuration\n    wfConfig.put(IngestService.START_DATE_KEY, formatter.format(startCache.asMap().get(mp.getIdentifier().toString())));\n\n    final X<WorkflowInstance> ingest = new X<WorkflowInstance>() {\n      @Override\n      public WorkflowInstance xapply() throws Exception {\n        /* Legacy support: Try to convert the workflowInstance to integer */\n        Long workflowInstanceId = null;\n        if (StringUtils.isNotBlank(workflowInstance)) {\n          try {\n            workflowInstanceId = Long.parseLong(workflowInstance);\n          } catch (NumberFormatException e) {\n            // The workflowId is not a long value and might be the media package identifier\n            wfConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowInstance);\n          }\n        }\n\n        if (workflowInstanceId != null) {\n          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig, workflowInstanceId);\n        } else {\n          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig);\n        }\n      }\n    };\n\n    try {\n      WorkflowInstance workflow = ingest.apply();\n      startCache.asMap().remove(mp.getIdentifier().toString());\n      return Response.ok(WorkflowParser.toXml(workflow)).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Path(\"schedule\")\n  @RestQuery(name = \"schedule\", description = \"Schedule an event based on the given media package\",\n          restParameters = {\n                  @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n          reponses = {\n                  @RestResponse(description = \"Event scheduled\", responseCode = HttpServletResponse.SC_CREATED),\n                  @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n          returnDescription = \"\")\n  public Response schedule(MultivaluedMap<String, String> formData) {\n    logger.trace(\"pass schedule with default workflow definition id {}\", defaultWorkflowDefinitionId);\n    return this.schedule(defaultWorkflowDefinitionId, formData);\n  }\n\n  @POST\n  @Path(\"schedule/{wdID}\")\n  @RestQuery(name = \"schedule\", description = \"Schedule an event based on the given media package\",\n          pathParameters = {\n          @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n          restParameters = {\n          @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n          reponses = {\n          @RestResponse(description = \"Event scheduled\", responseCode = HttpServletResponse.SC_CREATED),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n          returnDescription = \"\")\n  public Response schedule(@PathParam(\"wdID\") String wdID, MultivaluedMap<String, String> formData) {\n    if (StringUtils.isBlank(wdID)) {\n      logger.trace(\"workflow definition id is not specified\");\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n\n    Map<String, String> wfConfig = getWorkflowConfig(formData);\n    if (StringUtils.isNotBlank(wdID)) {\n      wfConfig.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, wdID);\n    }\n    logger.debug(\"Schedule with workflow definition '{}'\", wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM));\n\n    String mediaPackageXml = formData.getFirst(\"mediaPackage\");\n    if (StringUtils.isBlank(mediaPackageXml)) {\n      logger.debug(\"Rejected schedule without media package\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    MediaPackage mp = null;\n    try {\n      mp = factory.newMediaPackageBuilder().loadFromXml(mediaPackageXml);\n      if (MediaPackageSupport.sanityCheck(mp).isSome()) {\n        throw new MediaPackageException(\"Insane media package\");\n      }\n    } catch (MediaPackageException e) {\n      logger.debug(\"Rejected ingest with invalid media package {}\", mp);\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    MediaPackageElement[] mediaPackageElements = mp.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    try {\n      ingestService.schedule(mp, wdID, wfConfig);\n      return Response.status(Status.CREATED).build();\n    } catch (IngestException e) {\n      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();\n    } catch (SchedulerConflictException e) {\n      return Response.status(Status.CONFLICT).entity(e.getMessage()).build();\n    } catch (NotFoundException | UnauthorizedException | SchedulerException e) {\n      return Response.serverError().build();\n    }\n  }\n\n  /**\n   * Adds a dublinCore metadata catalog to the MediaPackage and returns the grown mediaPackage. JQuery Ajax functions\n   * doesn't support multipart/form-data encoding.\n   *\n   * @param mp\n   *          MediaPackage\n   * @param dc\n   *          DublinCoreCatalog\n   * @return grown MediaPackage XML\n   */\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addDCCatalog\")\n  @RestQuery(name = \"addDCCatalog\", description = \"Add a dublincore episode catalog to a given media package using an url\", restParameters = {\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT),\n          @RestParameter(description = \"DublinCore catalog as XML\", isRequired = true, name = \"dublinCore\", type = RestParameter.Type.TEXT),\n          @RestParameter(defaultValue = \"dublincore/episode\", description = \"DublinCore Flavor\", isRequired = false, name = \"flavor\", type = RestParameter.Type.STRING) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addDCCatalog(@FormParam(\"mediaPackage\") String mp, @FormParam(\"dublinCore\") String dc,\n          @FormParam(\"flavor\") String flavor) {\n    logger.trace(\"add DC catalog: {} with flavor: {} to media package: {}\", dc, flavor, mp);\n    MediaPackageElementFlavor dcFlavor = MediaPackageElements.EPISODE;\n    if (flavor != null) {\n      try {\n        dcFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n      } catch (IllegalArgumentException e) {\n        logger.warn(\"Unable to set dublin core flavor to {}, using {} instead\", flavor, MediaPackageElements.EPISODE);\n      }\n    }\n    MediaPackage mediaPackage;\n    /* Check if we got a proper mediapackage and try to parse it */\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().loadFromXml(mp);\n    } catch (MediaPackageException e) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n    if (MediaPackageSupport.sanityCheck(mediaPackage).isSome()) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n\n    /* Check if we got a proper catalog */\n    if (StringUtils.isBlank(dc)) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n\n    InputStream in = null;\n    try {\n      in = IOUtils.toInputStream(dc, \"UTF-8\");\n      mediaPackage = ingestService.addCatalog(in, \"dublincore.xml\", dcFlavor, mediaPackage);\n    } catch (MediaPackageException e) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (IOException e) {\n      /* Return an internal server error if we could not write to disk */\n      logger.error(\"Could not write catalog to disk: {}\", e.getMessage());\n      return Response.serverError().build();\n    } catch (Exception e) {\n      logger.error(e.getMessage());\n      return Response.serverError().build();\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n    return Response.ok(mediaPackage).build();\n  }\n\n  @Override\n  public JobProducer getService() {\n    return ingestService;\n  }\n\n  @Override\n  public ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the ingest service.\n   *\n   * @param ingestService\n   *          the ingest service\n   */\n  void setIngestService(IngestService ingestService) {\n    this.ingestService = ingestService;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the service registry.\n   *\n   * @param serviceRegistry\n   *          the service registry\n   */\n  void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the dublin core service.\n   *\n   * @param dcService\n   *          the dublin core service\n   */\n  void setDublinCoreService(DublinCoreCatalogService dcService) {\n    this.dublinCoreService = dcService;\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n}\n"], "fixing_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.mediapackage.identifier;\n\nimport javax.xml.bind.annotation.adapters.XmlAdapter;\nimport javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n\n/**\n * Interface for an identifier.\n */\n@XmlJavaTypeAdapter(Id.Adapter.class)\npublic interface Id {\n\n  /**\n   * Returns the local identifier of this {@link Id}. The local identifier is defined to be free of separator characters\n   * that could potentially get into the way when creating file or directory names from the identifier.\n   *\n   * For example, given that the interface is implemented by a class representing CNRI handles, the identifier would\n   * then look something like <code>10.3930/ETHZ/abcd</code>, whith <code>10.3930</code> being the handle prefix,\n   * <code>ETH</code> the authority and <code>abcd</code> the local part. <code>toURI()</code> would then return\n   * <code>10.3930-ETH-abcd</code> or any other suitable form.\n   *\n   * @return a path separator-free representation of the identifier\n   */\n  @Deprecated\n  String compact();\n\n  class Adapter extends XmlAdapter<IdImpl, Id> {\n    public IdImpl marshal(Id id) throws Exception {\n      if (id instanceof IdImpl) {\n        return (IdImpl) id;\n      } else {\n        throw new IllegalStateException(\"an unknown ID is un use: \" + id);\n      }\n    }\n\n    public Id unmarshal(IdImpl id) throws Exception {\n      return id;\n    }\n  }\n\n  /**\n   * Return a string representation of the identifier from which an object of type Id should\n   * be reconstructable.\n   */\n  String toString();\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.mediapackage.identifier;\n\nimport java.util.regex.Pattern;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlType;\nimport javax.xml.bind.annotation.XmlValue;\n\n/**\n * Simple and straightforward implementation of the {@link Id} interface.\n */\n@XmlType\n@XmlAccessorType(XmlAccessType.NONE)\npublic class IdImpl implements Id {\n\n  private static final Pattern pattern = Pattern.compile(\"[\\\\w-_.:;()]+\");\n\n  /** The identifier */\n  @XmlValue\n  protected String id = null;\n\n  /**\n   * Needed for JAXB serialization\n   */\n  public IdImpl() {\n  }\n\n  /**\n   * Creates a new identifier.\n   *\n   * @param id\n   *          the identifier\n   */\n  public IdImpl(final String id) {\n    if (!pattern.matcher(id).matches()) {\n      throw new IllegalArgumentException(\"Id must match \" + pattern);\n    }\n    this.id = id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.mediapackage.identifier.Id#compact()\n   */\n  public String compact() {\n    return toString();\n  }\n\n  @Override\n  public String toString() {\n    return id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#equals(java.lang.Object)\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof IdImpl) {\n      IdImpl other = (IdImpl) o;\n      return id != null && other.id != null && id.equals(other.id);\n    }\n    return false;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#hashCode()\n   */\n  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.endpoint;\n\nimport static org.apache.commons.lang3.StringUtils.trimToNull;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.IngestServiceImpl;\nimport org.opencastproject.job.api.JobProducer;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCores;\nimport org.opencastproject.rest.AbstractJobProducerEndpoint;\nimport org.opencastproject.scheduler.api.SchedulerConflictException;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Function0.X;\nimport org.opencastproject.util.doc.rest.RestParameter;\nimport org.opencastproject.util.doc.rest.RestQuery;\nimport org.opencastproject.util.doc.rest.RestResponse;\nimport org.opencastproject.util.doc.rest.RestService;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowParser;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.fileupload.FileItemIterator;\nimport org.apache.commons.fileupload.FileItemStream;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedHashMap;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.Response.Status;\n\n/**\n * Creates and augments Opencast MediaPackages using the api. Stores media into the Working File Repository.\n */\n@Path(\"/\")\n@RestService(name = \"ingestservice\", title = \"Ingest Service\", abstractText = \"This service creates and augments Opencast media packages that include media tracks, metadata \"\n        + \"catalogs and attachments.\", notes = {\n        \"All paths above are relative to the REST endpoint base (something like http://your.server/files)\",\n        \"If the service is down or not working it will return a status 503, this means the the underlying service is \"\n                + \"not working and is either restarting or has failed\",\n        \"A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In \"\n                + \"other words, there is a bug! You should file an error report with your server logs from the time when the \"\n                + \"error occurred: <a href=\\\"https://opencast.jira.com\\\">Opencast Issue Tracker</a>\" })\npublic class IngestRestService extends AbstractJobProducerEndpoint {\n\n  private static final Logger logger = LoggerFactory.getLogger(IngestRestService.class);\n\n  /** Key for the default workflow definition in config.properties */\n  protected static final String DEFAULT_WORKFLOW_DEFINITION = \"org.opencastproject.workflow.default.definition\";\n\n  /** Key for the default maximum number of ingests in config.properties */\n  protected static final String MAX_INGESTS_KEY = \"org.opencastproject.ingest.max.concurrent\";\n\n  /** The http request parameter used to provide the workflow instance id */\n  protected static final String WORKFLOW_INSTANCE_ID_PARAM = \"workflowInstanceId\";\n\n  /** The http request parameter used to provide the workflow definition id */\n  protected static final String WORKFLOW_DEFINITION_ID_PARAM = \"workflowDefinitionId\";\n\n  /** The default workflow definition */\n  private String defaultWorkflowDefinitionId = null;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** Dublin Core Terms: http://purl.org/dc/terms/ */\n  private static List<String> dcterms = Arrays.asList(\"abstract\", \"accessRights\", \"accrualMethod\",\n          \"accrualPeriodicity\", \"accrualPolicy\", \"alternative\", \"audience\", \"available\", \"bibliographicCitation\",\n          \"conformsTo\", \"contributor\", \"coverage\", \"created\", \"creator\", \"date\", \"dateAccepted\", \"dateCopyrighted\",\n          \"dateSubmitted\", \"description\", \"educationLevel\", \"extent\", \"format\", \"hasFormat\", \"hasPart\", \"hasVersion\",\n          \"identifier\", \"instructionalMethod\", \"isFormatOf\", \"isPartOf\", \"isReferencedBy\", \"isReplacedBy\",\n          \"isRequiredBy\", \"issued\", \"isVersionOf\", \"language\", \"license\", \"mediator\", \"medium\", \"modified\",\n          \"provenance\", \"publisher\", \"references\", \"relation\", \"replaces\", \"requires\", \"rights\", \"rightsHolder\",\n          \"source\", \"spatial\", \"subject\", \"tableOfContents\", \"temporal\", \"title\", \"type\", \"valid\");\n\n  private MediaPackageBuilderFactory factory = null;\n  private IngestService ingestService = null;\n  private ServiceRegistry serviceRegistry = null;\n  private DublinCoreCatalogService dublinCoreService;\n  // The number of ingests this service can handle concurrently.\n  private int ingestLimit = -1;\n  /* Stores a map workflow ID and date to update the ingest start times post-hoc */\n  private Cache<String, Date> startCache = null;\n  /* Formatter to for the date into a string */\n  private DateFormat formatter = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);\n\n  public IngestRestService() {\n    factory = MediaPackageBuilderFactory.newInstance();\n    startCache = CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.DAYS).build();\n  }\n\n  /**\n   * Returns the maximum number of concurrent ingest operations or <code>-1</code> if no limit is enforced.\n   *\n   * @return the maximum number of concurrent ingest operations\n   * @see #isIngestLimitEnabled()\n   */\n  protected synchronized int getIngestLimit() {\n    return ingestLimit;\n  }\n\n  /**\n   * Sets the maximum number of concurrent ingest operations. Use <code>-1</code> to indicate no limit.\n   *\n   * @param ingestLimit\n   *          the limit\n   */\n  private synchronized void setIngestLimit(int ingestLimit) {\n    this.ingestLimit = ingestLimit;\n  }\n\n  /**\n   * Returns <code>true</code> if a maximum number of concurrent ingest operations has been defined.\n   *\n   * @return <code>true</code> if there is a maximum number of concurrent ingests\n   */\n  protected synchronized boolean isIngestLimitEnabled() {\n    return ingestLimit >= 0;\n  }\n\n  /**\n   * Callback for activation of this component.\n   */\n  public void activate(ComponentContext cc) {\n    if (cc != null) {\n      defaultWorkflowDefinitionId = trimToNull(cc.getBundleContext().getProperty(DEFAULT_WORKFLOW_DEFINITION));\n      if (defaultWorkflowDefinitionId == null) {\n        defaultWorkflowDefinitionId = \"schedule-and-upload\";\n      }\n      if (cc.getBundleContext().getProperty(MAX_INGESTS_KEY) != null) {\n        try {\n          ingestLimit = Integer.parseInt(trimToNull(cc.getBundleContext().getProperty(MAX_INGESTS_KEY)));\n          if (ingestLimit == 0) {\n            ingestLimit = -1;\n          }\n        } catch (NumberFormatException e) {\n          logger.warn(\"Max ingest property with key \" + MAX_INGESTS_KEY\n                  + \" isn't defined so no ingest limit will be used.\");\n          ingestLimit = -1;\n        }\n      }\n    }\n  }\n\n  @PUT\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"createMediaPackageWithID/{id}\")\n  @RestQuery(name = \"createMediaPackageWithID\", description = \"Create an empty media package with ID /n Overrides Existing Mediapackage \", pathParameters = {\n          @RestParameter(description = \"The Id for the new Mediapackage\", isRequired = true, name = \"id\", type = RestParameter.Type.STRING) }, reponses = {\n          @RestResponse(description = \"Returns media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response createMediaPackage(@PathParam(\"id\") String mediaPackageId) {\n    MediaPackage mp;\n    try {\n      mp = ingestService.createMediaPackage(mediaPackageId);\n\n      startCache.put(mp.getIdentifier().toString(), new Date());\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @GET\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"createMediaPackage\")\n  @RestQuery(name = \"createMediaPackage\", description = \"Create an empty media package\", restParameters = {\n         }, reponses = {\n          @RestResponse(description = \"Returns media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response createMediaPackage() {\n    MediaPackage mp;\n    try {\n      mp = ingestService.createMediaPackage();\n      startCache.put(mp.getIdentifier().toString(), new Date());\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Path(\"discardMediaPackage\")\n  @RestQuery(name = \"discardMediaPackage\", description = \"Discard a media package\", restParameters = { @RestParameter(description = \"Given media package to be destroyed\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response discardMediaPackage(@FormParam(\"mediaPackage\") String mpx) {\n    logger.debug(\"discardMediaPackage(MediaPackage): {}\", mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      ingestService.discardMediaPackage(mp);\n      return Response.ok().build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addTrack\")\n  @RestQuery(name = \"addTrackURL\", description = \"Add a media track to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the media\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of media\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The Tags of the  media track\", isRequired = false, name = \"tags\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageTrack(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,  @FormParam(\"tags\")  String tags,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add media package from url: {} flavor: {} tags: {} mediaPackage: {}\", url, flavor, tags, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      String[] tagsArray = null;\n      if (tags != null) {\n        tagsArray = tags.split(\",\");\n      }\n      mp = ingestService.addTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), tagsArray, mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addTrack\")\n  @RestQuery(\n    name = \"addTrackInputStream\",\n    description = \"Add a media track to a given media package using an input stream\",\n    restParameters = {\n      @RestParameter(description = \"The kind of media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The Tags of the  media track\", isRequired = false, name = \"tags\", type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n    bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n    reponses = {\n      @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n      @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n    returnDescription = \"\")\n  public Response addMediaPackageTrack(@Context HttpServletRequest request) {\n    logger.trace(\"add track as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Track);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addPartialTrack\")\n  @RestQuery(name = \"addPartialTrackURL\", description = \"Add a partial media track to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the media\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of media\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The start time in milliseconds\", isRequired = true, name = \"startTime\", type = RestParameter.Type.INTEGER),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackagePartialTrack(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"startTime\") Long startTime, @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add partial track with url: {} flavor: {} startTime: {} mediaPackage: {}\",\n            url, flavor, startTime, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n\n      mp = ingestService.addPartialTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), startTime, mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addPartialTrack\")\n  @RestQuery(name = \"addPartialTrackInputStream\", description = \"Add a partial media track to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The start time in milliseconds\", isRequired = true, name = \"startTime\", type = RestParameter.Type.INTEGER),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackagePartialTrack(@Context HttpServletRequest request) {\n    logger.trace(\"add partial track as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Track);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addCatalog\")\n  @RestQuery(name = \"addCatalogURL\", description = \"Add a metadata catalog to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the catalog\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of catalog\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageCatalog(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add catalog with url: {} flavor: {} mediaPackage: {}\", url, flavor, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      MediaPackage resultingMediaPackage = ingestService.addCatalog(new URI(url),\n              MediaPackageElementFlavor.parseFlavor(flavor), mp);\n      return Response.ok(resultingMediaPackage).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addCatalog\")\n  @RestQuery(name = \"addCatalogInputStream\", description = \"Add a metadata catalog to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of media catalog\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The metadata catalog file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageCatalog(@Context HttpServletRequest request) {\n    logger.trace(\"add catalog as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Catalog);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addAttachment\")\n  @RestQuery(name = \"addAttachmentURL\", description = \"Add an attachment to a given media package using an URL\", restParameters = {\n          @RestParameter(description = \"The location of the attachment\", isRequired = true, name = \"url\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The kind of attachment\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageAttachment(@FormParam(\"url\") String url, @FormParam(\"flavor\") String flavor,\n          @FormParam(\"mediaPackage\") String mpx) {\n    logger.trace(\"add attachment with url: {} flavor: {} mediaPackage: {}\", url, flavor, mpx);\n    try {\n      MediaPackage mp = factory.newMediaPackageBuilder().loadFromXml(mpx);\n      if (MediaPackageSupport.sanityCheck(mp).isSome())\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      mp = ingestService.addAttachment(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), mp);\n      return Response.ok(mp).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addAttachment\")\n  @RestQuery(name = \"addAttachmentInputStream\", description = \"Add an attachment to a given media package using an input stream\", restParameters = {\n          @RestParameter(description = \"The kind of attachment\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = \"The attachment file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addMediaPackageAttachment(@Context HttpServletRequest request) {\n    logger.trace(\"add attachment as multipart-form-data\");\n    return addMediaPackageElement(request, MediaPackageElement.Type.Attachment);\n  }\n\n  protected Response addMediaPackageElement(HttpServletRequest request, MediaPackageElement.Type type) {\n    MediaPackageElementFlavor flavor = null;\n    InputStream in = null;\n    try {\n      String fileName = null;\n      MediaPackage mp = null;\n      Long startTime = null;\n      String[] tags = null;\n      /* Only accept multipart/form-data */\n      if (!ServletFileUpload.isMultipartContent(request)) {\n        logger.trace(\"request isn't multipart-form-data\");\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      }\n      boolean isDone = false;\n      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n        FileItemStream item = iter.next();\n        String fieldName = item.getFieldName();\n        if (item.isFormField()) {\n          if (\"flavor\".equals(fieldName)) {\n            String flavorString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"flavor: {}\", flavorString);\n            if (flavorString != null) {\n              try {\n                flavor = MediaPackageElementFlavor.parseFlavor(flavorString);\n              } catch (IllegalArgumentException e) {\n                String error = String.format(\"Could not parse flavor '%s'\", flavorString);\n                logger.debug(error, e);\n                return Response.status(Status.BAD_REQUEST).entity(error).build();\n              }\n            }\n          } else if (\"tags\".equals(fieldName)) {\n            String tagsString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"tags: {}\", tagsString);\n            tags = tagsString.split(\",\");\n          } else if (\"mediaPackage\".equals(fieldName)) {\n            try {\n              String mediaPackageString = Streams.asString(item.openStream(), \"UTF-8\");\n              logger.trace(\"mediaPackage: {}\", mediaPackageString);\n              mp = factory.newMediaPackageBuilder().loadFromXml(mediaPackageString);\n            } catch (MediaPackageException e) {\n              logger.debug(\"Unable to parse the 'mediaPackage' parameter: {}\", ExceptionUtils.getMessage(e));\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n          } else if (\"startTime\".equals(fieldName) && \"/addPartialTrack\".equals(request.getPathInfo())) {\n            String startTimeString = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"startTime: {}\", startTime);\n            try {\n              startTime = Long.parseLong(startTimeString);\n            } catch (Exception e) {\n              logger.debug(\"Unable to parse the 'startTime' parameter: {}\", ExceptionUtils.getMessage(e));\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n          }\n        } else {\n          if (flavor == null) {\n            /* A flavor has to be specified in the request prior the video file */\n            logger.debug(\"A flavor has to be specified in the request prior to the content BODY\");\n            return Response.serverError().status(Status.BAD_REQUEST).build();\n          }\n          fileName = item.getName();\n          in = item.openStream();\n          isDone = true;\n        }\n        if (isDone) {\n          break;\n        }\n      }\n      /*\n       * Check if we actually got a valid request including a message body and a valid mediapackage to attach the\n       * element to\n       */\n      if (in == null || mp == null || MediaPackageSupport.sanityCheck(mp).isSome()) {\n        return Response.serverError().status(Status.BAD_REQUEST).build();\n      }\n      switch (type) {\n        case Attachment:\n          mp = ingestService.addAttachment(in, fileName, flavor, tags, mp);\n          break;\n        case Catalog:\n          mp = ingestService.addCatalog(in, fileName, flavor, tags, mp);\n          break;\n        case Track:\n          if (startTime == null) {\n            mp = ingestService.addTrack(in, fileName, flavor, tags, mp);\n          } else {\n            mp = ingestService.addPartialTrack(in, fileName, flavor, startTime, mp);\n          }\n          break;\n        default:\n          throw new IllegalStateException(\"Type must be one of track, catalog, or attachment\");\n      }\n      return Response.ok(MediaPackageParser.getAsXml(mp)).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addMediaPackage\")\n  @RestQuery(name = \"addMediaPackage\",\n      description = \"<p>Create and ingest media package from media tracks with additional Dublin Core metadata. It is \"\n        + \"mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC \"\n        + \"catalog with a title included.  The identifier of the newly created media package will be taken from the \"\n        + \"<em>identifier</em> field or the episode DublinCore catalog (deprecated<sup>*</sup>). If no identifier is \"\n        + \"set, a new random UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for \"\n        + \"scheduled recordings. Its primary use is for manual ingests with command line tools like curl.</p> \"\n        + \"<p>Multiple tracks can be ingested by using multiple form fields. It is important to always set the \"\n        + \"flavor of the next media file <em>before</em> sending the media file itself.</p>\"\n        + \"<b>(*)</b> The special treatment of the identifier field is deprecated and may be removed in future versions \"\n        + \"without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. \"\n        + \"<h3>Example curl command:</h3>\"\n        + \"<p>Ingest one video file:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \\n\"\n        + \"</pre></p>\"\n        + \"<p>Ingest two video files:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\\\\n\"\n        + \"    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \\n\"\n        + \"</pre></p>\",\n      restParameters = {\n          @RestParameter(description = \"The kind of media track. This has to be specified prior to each media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"abstract\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"accessRights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"available\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"contributor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"coverage\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"created\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"creator\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"date\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"description\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"extent\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"format\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"identifier\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isPartOf\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReferencedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReplacedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"language\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"license\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"publisher\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"relation\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"replaces\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rightsHolder\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"source\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"spatial\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"subject\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"temporal\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"title\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"type\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of a media track file\", isRequired = false, name = \"mediaUri\", type = RestParameter.Type.STRING) },\n      bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n      reponses = {\n          @RestResponse(description = \"Ingest successfull. Returns workflow instance as xml\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Ingest failed due to invalid requests.\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"Ingest failed. Something went wrong internally. Please have a look at the log files\",\n              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n      returnDescription = \"\")\n  public Response addMediaPackage(@Context HttpServletRequest request) {\n    logger.trace(\"add mediapackage as multipart-form-data\");\n    return addMediaPackage(request, null);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Consumes(MediaType.MULTIPART_FORM_DATA)\n  @Path(\"addMediaPackage/{wdID}\")\n  @RestQuery(name = \"addMediaPackage\",\n      description = \"<p>Create and ingest media package from media tracks with additional Dublin Core metadata. It is \"\n        + \"mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC \"\n        + \"catalog with a title included.  The identifier of the newly created media package will be taken from the \"\n        + \"<em>identifier</em> field or the episode DublinCore catalog (deprecated<sup>*</sup>). If no identifier is \"\n        + \"set, a newa randumm UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for \"\n        + \"scheduled recordings. It's primary use is for manual ingests with command line tools like curl.</p> \"\n        + \"<p>Multiple tracks can be ingested by using multiple form fields. It's important, however, to always set the \"\n        + \"flavor of the next media file <em>before</em> sending the media file itself.</p>\"\n        + \"<b>(*)</b> The special treatment of the identifier field is deprecated any may be removed in future versions \"\n        + \"without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. \"\n        + \"<h3>Example curl command:</h3>\"\n        + \"<p>Ingest one video file:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage/fast -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \\n\"\n        + \"</pre></p>\"\n        + \"<p>Ingest two video files:</p>\"\n        + \"<p><pre>\\n\"\n        + \"curl -f -i --digest -u opencast_system_account:CHANGE_ME -H 'X-Requested-Auth: Digest' \\\\\\n\"\n        + \"    http://localhost:8080/ingest/addMediaPackage/fast -F creator='John Doe' -F title='Test Recording' \\\\\\n\"\n        + \"    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\\\\n\"\n        + \"    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \\n\"\n        + \"</pre></p>\",\n      pathParameters = {\n          @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n      restParameters = {\n          @RestParameter(description = \"The kind of media track. This has to be specified prior to each media track\", isRequired = true, name = \"flavor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"abstract\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"accessRights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"available\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"contributor\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"coverage\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"created\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"creator\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"date\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"description\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"extent\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"format\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"identifier\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isPartOf\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReferencedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"isReplacedBy\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"language\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"license\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"publisher\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"relation\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"replaces\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rights\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"rightsHolder\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"source\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"spatial\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"subject\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"temporal\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"title\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode metadata value\", isRequired = false, name = \"type\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Episode DublinCore Catalog\", isRequired = false, name = \"episodeDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalogUri\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Series DublinCore Catalog\", isRequired = false, name = \"seriesDCCatalog\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"URL of a media track file\", isRequired = false, name = \"mediaUri\", type = RestParameter.Type.STRING) },\n      bodyParameter = @RestParameter(description = \"The media track file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE),\n      reponses = {\n          @RestResponse(description = \"Ingest successfull. Returns workflow instance as XML\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Ingest failed due to invalid requests.\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"Ingest failed. Something went wrong internally. Please have a look at the log files\",\n              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },\n      returnDescription = \"\")\n  public Response addMediaPackage(@Context HttpServletRequest request, @PathParam(\"wdID\") String wdID) {\n    logger.trace(\"add mediapackage as multipart-form-data with workflow definition id: {}\", wdID);\n    MediaPackageElementFlavor flavor = null;\n    try {\n      MediaPackage mp = ingestService.createMediaPackage();\n      DublinCoreCatalog dcc = null;\n      Map<String, String> workflowProperties = new HashMap<>();\n      int seriesDCCatalogNumber = 0;\n      int episodeDCCatalogNumber = 0;\n      boolean hasMedia = false;\n      if (ServletFileUpload.isMultipartContent(request)) {\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            String fieldName = item.getFieldName();\n            String value = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"form field {}: {}\", fieldName, value);\n            /* Ignore empty fields */\n            if (\"\".equals(value)) {\n              continue;\n            }\n\n            /* \u201cRemember\u201d the flavor for the next media. */\n            if (\"flavor\".equals(fieldName)) {\n              try {\n                flavor = MediaPackageElementFlavor.parseFlavor(value);\n              } catch (IllegalArgumentException e) {\n                String error = String.format(\"Could not parse flavor '%s'\", value);\n                logger.debug(error, e);\n                return Response.status(Status.BAD_REQUEST).entity(error).build();\n              }\n              /* Fields for DC catalog */\n            } else if (dcterms.contains(fieldName)) {\n              if (\"identifier\".equals(fieldName)) {\n                /* Use the identifier for the mediapackage */\n                mp.setIdentifier(new IdImpl(value));\n              }\n              EName en = new EName(DublinCore.TERMS_NS_URI, fieldName);\n              if (dcc == null) {\n                dcc = dublinCoreService.newInstance();\n              }\n              dcc.add(en, value);\n\n              /* Episode metadata by URL */\n            } else if (\"episodeDCCatalogUri\".equals(fieldName)) {\n              try {\n                URI dcurl = new URI(value);\n                updateMediaPackageID(mp, dcurl);\n                ingestService.addCatalog(dcurl, MediaPackageElements.EPISODE, mp);\n                episodeDCCatalogNumber += 1;\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n\n              /* Episode metadata DC catalog (XML) as string */\n            } else if (\"episodeDCCatalog\".equals(fieldName)) {\n              InputStream is = new ByteArrayInputStream(value.getBytes(\"UTF-8\"));\n              updateMediaPackageID(mp, is);\n              is.reset();\n              String fileName = \"episode\" + episodeDCCatalogNumber + \".xml\";\n              episodeDCCatalogNumber += 1;\n              ingestService.addCatalog(is, fileName, MediaPackageElements.EPISODE, mp);\n\n              /* Series by URL */\n            } else if (\"seriesDCCatalogUri\".equals(fieldName)) {\n              try {\n                URI dcurl = new URI(value);\n                ingestService.addCatalog(dcurl, MediaPackageElements.SERIES, mp);\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n\n              /* Series DC catalog (XML) as string */\n            } else if (\"seriesDCCatalog\".equals(fieldName)) {\n              String fileName = \"series\" + seriesDCCatalogNumber + \".xml\";\n              seriesDCCatalogNumber += 1;\n              InputStream is = new ByteArrayInputStream(value.getBytes(\"UTF-8\"));\n              ingestService.addCatalog(is, fileName, MediaPackageElements.SERIES, mp);\n\n              /* Add media files by URL */\n            } else if (\"mediaUri\".equals(fieldName)) {\n              if (flavor == null) {\n                /* A flavor has to be specified in the request prior the media file */\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n              URI mediaUrl;\n              try {\n                mediaUrl = new URI(value);\n              } catch (java.net.URISyntaxException e) {\n                /* Parameter was not a valid URL: Return 400 Bad Request */\n                logger.warn(e.getMessage(), e);\n                return Response.serverError().status(Status.BAD_REQUEST).build();\n              }\n              ingestService.addTrack(mediaUrl, flavor, mp);\n              hasMedia = true;\n\n            } else {\n              /* Tread everything else as workflow properties */\n              workflowProperties.put(fieldName, value);\n            }\n\n            /* Media files as request parameter */\n          } else {\n            if (flavor == null) {\n              /* A flavor has to be specified in the request prior the video file */\n              logger.debug(\"A flavor has to be specified in the request prior to the content BODY\");\n              return Response.serverError().status(Status.BAD_REQUEST).build();\n            }\n            ingestService.addTrack(item.openStream(), item.getName(), flavor, mp);\n            hasMedia = true;\n          }\n        }\n\n        /* Check if we got any media. Fail if not. */\n        if (!hasMedia) {\n          logger.warn(\"Rejected ingest without actual media.\");\n          return Response.serverError().status(Status.BAD_REQUEST).build();\n        }\n\n        /* Add episode mediapackage if metadata were send separately */\n        if (dcc != null) {\n          ByteArrayOutputStream out = new ByteArrayOutputStream();\n          dcc.toXml(out, true);\n          InputStream in = new ByteArrayInputStream(out.toByteArray());\n          ingestService.addCatalog(in, \"dublincore.xml\", MediaPackageElements.EPISODE, mp);\n\n          /* Check if we have metadata for the episode */\n        } else if (episodeDCCatalogNumber == 0) {\n          logger.warn(\"Rejected ingest without episode metadata. At least provide a title.\");\n          return Response.serverError().status(Status.BAD_REQUEST).build();\n        }\n\n        WorkflowInstance workflow = (wdID == null)\n            ? ingestService.ingest(mp)\n            : ingestService.ingest(mp, wdID, workflowProperties);\n        return Response.ok(workflow).build();\n      }\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (IllegalArgumentException e) {\n      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  /**\n   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.\n   *\n   * @param mp\n   *          MediaPackage to modify\n   * @param is\n   *          InputStream containing the episode DublinCore catalog\n   */\n  private void updateMediaPackageID(MediaPackage mp, InputStream is) throws IOException {\n    DublinCoreCatalog dc = DublinCores.read(is);\n    EName en = new EName(DublinCore.TERMS_NS_URI, \"identifier\");\n    String id = dc.getFirst(en);\n    if (id != null) {\n      mp.setIdentifier(new IdImpl(id));\n    }\n  }\n\n  /**\n   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.\n   *\n   * @param mp\n   *          MediaPackage to modify\n   * @param uri\n   *          URI to get the episode DublinCore catalog from\n   */\n  private void updateMediaPackageID(MediaPackage mp, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        response = httpClient.execute(get);\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else {\n        in = uri.toURL().openStream();\n      }\n      updateMediaPackageID(mp, in);\n      in.close();\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n  }\n\n  @POST\n  @Path(\"addZippedMediaPackage/{workflowDefinitionId}\")\n  @Produces(MediaType.TEXT_XML)\n  @RestQuery(name = \"addZippedMediaPackage\", description = \"Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments\", pathParameters = { @RestParameter(description = \"Workflow definition id\", isRequired = true, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING) }, restParameters = { @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = \"The compressed (application/zip) media package file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_NOT_FOUND),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = \"\")\n  public Response addZippedMediaPackage(@Context HttpServletRequest request,\n          @PathParam(\"workflowDefinitionId\") String wdID, @QueryParam(\"id\") String wiID) {\n    logger.trace(\"add zipped media package with workflow definition id: {} and workflow instance id: {}\", wdID, wiID);\n    if (!isIngestLimitEnabled() || getIngestLimit() > 0) {\n      return ingestZippedMediaPackage(request, wdID, wiID);\n    } else {\n      logger.warn(\"Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.\");\n      return Response.status(Status.SERVICE_UNAVAILABLE).build();\n    }\n  }\n\n  @POST\n  @Path(\"addZippedMediaPackage\")\n  @Produces(MediaType.TEXT_XML)\n  @RestQuery(name = \"addZippedMediaPackage\", description = \"Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments\", restParameters = {\n          @RestParameter(description = \"The workflow definition ID to run on this mediapackage. \"\n                  + \"This parameter has to be set in the request prior to the zipped mediapackage \"\n                  + \"(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} instead)\", isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),\n          @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage. \"\n                  + \"This parameter has to be set in the request prior to the zipped mediapackage \"\n                  + \"(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} with a path parameter instead)\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = \"The compressed (application/zip) media package file\", isRequired = true, name = \"BODY\", type = RestParameter.Type.FILE), reponses = {\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_NOT_FOUND),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = \"\")\n  public Response addZippedMediaPackage(@Context HttpServletRequest request) {\n    logger.trace(\"add zipped media package\");\n    if (!isIngestLimitEnabled() || getIngestLimit() > 0) {\n      return ingestZippedMediaPackage(request, null, null);\n    } else {\n      logger.warn(\"Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.\");\n      return Response.status(Status.SERVICE_UNAVAILABLE).build();\n    }\n  }\n\n  private Response ingestZippedMediaPackage(HttpServletRequest request, String wdID, String wiID) {\n    if (isIngestLimitEnabled()) {\n      setIngestLimit(getIngestLimit() - 1);\n      logger.debug(\"An ingest has started so remaining ingest limit is \" + getIngestLimit());\n    }\n    InputStream in = null;\n    Date started = new Date();\n\n    logger.info(\"Received new request from {} to ingest a zipped mediapackage\", request.getRemoteHost());\n\n    try {\n      String workflowDefinitionId = wdID;\n      String workflowIdAsString = wiID;\n      Long workflowInstanceIdAsLong = null;\n      Map<String, String> workflowConfig = new HashMap<>();\n      if (ServletFileUpload.isMultipartContent(request)) {\n        boolean isDone = false;\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            String fieldName = item.getFieldName();\n            String value = Streams.asString(item.openStream(), \"UTF-8\");\n            logger.trace(\"{}: {}\", fieldName, value);\n            if (WORKFLOW_INSTANCE_ID_PARAM.equals(fieldName)) {\n              workflowIdAsString = value;\n              continue;\n            } else if (WORKFLOW_DEFINITION_ID_PARAM.equals(fieldName)) {\n              workflowDefinitionId = value;\n              continue;\n            } else {\n              logger.debug(\"Processing form field: \" + fieldName);\n              workflowConfig.put(fieldName, value);\n            }\n          } else {\n            logger.debug(\"Processing file item\");\n            // once the body gets read iter.hasNext must not be invoked or the stream can not be read\n            // MH-9579\n            in = item.openStream();\n            isDone = true;\n          }\n          if (isDone)\n            break;\n        }\n      } else {\n        logger.debug(\"Processing file item\");\n        in = request.getInputStream();\n      }\n\n      // Adding ingest start time to workflow configuration\n      DateFormat formatter = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);\n      workflowConfig.put(IngestService.START_DATE_KEY, formatter.format(started));\n\n      /* Legacy support: Try to convert the workflowId to integer */\n      if (!StringUtils.isBlank(workflowIdAsString)) {\n        try {\n          workflowInstanceIdAsLong = Long.parseLong(workflowIdAsString);\n        } catch (NumberFormatException e) {\n          // The workflowId is not a long value and might be the media package identifier\n          workflowConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowIdAsString);\n        }\n      }\n      if (StringUtils.isBlank(workflowDefinitionId)) {\n        workflowDefinitionId = defaultWorkflowDefinitionId;\n      }\n\n      WorkflowInstance workflow;\n      if (workflowInstanceIdAsLong != null) {\n        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig,\n                workflowInstanceIdAsLong);\n      } else {\n        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig);\n      }\n      return Response.ok(WorkflowParser.toXml(workflow)).build();\n    } catch (NotFoundException e) {\n      logger.info(e.getMessage());\n      return Response.status(Status.NOT_FOUND).build();\n    } catch (MediaPackageException e) {\n      logger.warn(e.getMessage());\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    } finally {\n      IOUtils.closeQuietly(in);\n      if (isIngestLimitEnabled()) {\n        setIngestLimit(getIngestLimit() + 1);\n        logger.debug(\"An ingest has finished so increased ingest limit to \" + getIngestLimit());\n      }\n    }\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_HTML)\n  @Path(\"ingest/{wdID}\")\n  @RestQuery(name = \"ingest\", description = \"Ingest the completed media package into the system, retrieving all URL-referenced files, and starting a specified workflow\",\n    pathParameters = {\n      @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n    restParameters = {\n      @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n    reponses = {\n      @RestResponse(description = \"Returns the media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n    returnDescription = \"\")\n  public Response ingest(@Context HttpServletRequest request, @PathParam(\"wdID\") String wdID) {\n    logger.trace(\"ingest media package with workflow definition id: {}\", wdID);\n    if (StringUtils.isBlank(wdID)) {\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n    return ingest(wdID, request);\n  }\n\n  @POST\n  @Produces(MediaType.TEXT_HTML)\n  @Path(\"ingest\")\n  @RestQuery(name = \"ingest\", description = \"Ingest the completed media package into the system, retrieving all URL-referenced files\",\n    restParameters = {\n      @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT),\n      @RestParameter(description = \"Workflow definition id\", isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),\n      @RestParameter(description = \"The workflow instance ID to associate with this zipped mediapackage\", isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) },\n    reponses = {\n      @RestResponse(description = \"Returns the media package\", responseCode = HttpServletResponse.SC_OK),\n      @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n    returnDescription = \"\")\n  public Response ingest(@Context HttpServletRequest request) {\n    return ingest(null, request);\n  }\n\n  private Map<String, String> getWorkflowConfig(MultivaluedMap<String, String> formData) {\n    Map<String, String> wfConfig = new HashMap<>();\n    for (String key : formData.keySet()) {\n      if (!\"mediaPackage\".equals(key)) {\n        wfConfig.put(key, formData.getFirst(key));\n      }\n    }\n    return wfConfig;\n  }\n\n  private Response ingest(final String wdID, final HttpServletRequest request) {\n    /* Note: We use a MultivaluedMap here to ensure that we can get any arbitrary form parameters. This is required to\n     * enable things like holding for trim or distributing to YouTube. */\n    final MultivaluedMap<String, String> formData = new MultivaluedHashMap<>();\n    if (ServletFileUpload.isMultipartContent(request)) {\n      // parse form fields\n      try {\n        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {\n          FileItemStream item = iter.next();\n          if (item.isFormField()) {\n            final String value = Streams.asString(item.openStream(), \"UTF-8\");\n            formData.putSingle(item.getFieldName(), value);\n          }\n        }\n      } catch (FileUploadException | IOException e) {\n        return Response.status(Response.Status.BAD_REQUEST).build();\n      }\n    } else {\n      request.getParameterMap().forEach((key, value) -> formData.put(key, Arrays.asList(value)));\n    }\n\n    final Map<String, String> wfConfig = getWorkflowConfig(formData);\n    if (StringUtils.isNotBlank(wdID))\n      wfConfig.put(WORKFLOW_DEFINITION_ID_PARAM, wdID);\n\n    final MediaPackage mp;\n    try {\n      mp = factory.newMediaPackageBuilder().loadFromXml(formData.getFirst(\"mediaPackage\"));\n      if (MediaPackageSupport.sanityCheck(mp).isSome()) {\n        logger.warn(\"Rejected ingest with invalid mediapackage {}\", mp);\n        return Response.status(Status.BAD_REQUEST).build();\n      }\n    } catch (Exception e) {\n      logger.warn(\"Rejected ingest without mediapackage\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    final String workflowInstance = wfConfig.get(WORKFLOW_INSTANCE_ID_PARAM);\n    final String workflowDefinition = wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM);\n\n    // Adding ingest start time to workflow configuration\n    wfConfig.put(IngestService.START_DATE_KEY, formatter.format(startCache.asMap().get(mp.getIdentifier().toString())));\n\n    final X<WorkflowInstance> ingest = new X<WorkflowInstance>() {\n      @Override\n      public WorkflowInstance xapply() throws Exception {\n        /* Legacy support: Try to convert the workflowInstance to integer */\n        Long workflowInstanceId = null;\n        if (StringUtils.isNotBlank(workflowInstance)) {\n          try {\n            workflowInstanceId = Long.parseLong(workflowInstance);\n          } catch (NumberFormatException e) {\n            // The workflowId is not a long value and might be the media package identifier\n            wfConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowInstance);\n          }\n        }\n\n        if (workflowInstanceId != null) {\n          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig, workflowInstanceId);\n        } else {\n          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig);\n        }\n      }\n    };\n\n    try {\n      WorkflowInstance workflow = ingest.apply();\n      startCache.asMap().remove(mp.getIdentifier().toString());\n      return Response.ok(WorkflowParser.toXml(workflow)).build();\n    } catch (Exception e) {\n      logger.warn(e.getMessage(), e);\n      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n    }\n  }\n\n  @POST\n  @Path(\"schedule\")\n  @RestQuery(name = \"schedule\", description = \"Schedule an event based on the given media package\",\n          restParameters = {\n                  @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n          reponses = {\n                  @RestResponse(description = \"Event scheduled\", responseCode = HttpServletResponse.SC_CREATED),\n                  @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n          returnDescription = \"\")\n  public Response schedule(MultivaluedMap<String, String> formData) {\n    logger.trace(\"pass schedule with default workflow definition id {}\", defaultWorkflowDefinitionId);\n    return this.schedule(defaultWorkflowDefinitionId, formData);\n  }\n\n  @POST\n  @Path(\"schedule/{wdID}\")\n  @RestQuery(name = \"schedule\", description = \"Schedule an event based on the given media package\",\n          pathParameters = {\n          @RestParameter(description = \"Workflow definition id\", isRequired = true, name = \"wdID\", type = RestParameter.Type.STRING) },\n          restParameters = {\n          @RestParameter(description = \"The media package\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT) },\n          reponses = {\n          @RestResponse(description = \"Event scheduled\", responseCode = HttpServletResponse.SC_CREATED),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST) },\n          returnDescription = \"\")\n  public Response schedule(@PathParam(\"wdID\") String wdID, MultivaluedMap<String, String> formData) {\n    if (StringUtils.isBlank(wdID)) {\n      logger.trace(\"workflow definition id is not specified\");\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n\n    Map<String, String> wfConfig = getWorkflowConfig(formData);\n    if (StringUtils.isNotBlank(wdID)) {\n      wfConfig.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, wdID);\n    }\n    logger.debug(\"Schedule with workflow definition '{}'\", wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM));\n\n    String mediaPackageXml = formData.getFirst(\"mediaPackage\");\n    if (StringUtils.isBlank(mediaPackageXml)) {\n      logger.debug(\"Rejected schedule without media package\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    MediaPackage mp = null;\n    try {\n      mp = factory.newMediaPackageBuilder().loadFromXml(mediaPackageXml);\n      if (MediaPackageSupport.sanityCheck(mp).isSome()) {\n        throw new MediaPackageException(\"Insane media package\");\n      }\n    } catch (MediaPackageException e) {\n      logger.debug(\"Rejected ingest with invalid media package {}\", mp);\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    MediaPackageElement[] mediaPackageElements = mp.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n\n    try {\n      ingestService.schedule(mp, wdID, wfConfig);\n      return Response.status(Status.CREATED).build();\n    } catch (IngestException e) {\n      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();\n    } catch (SchedulerConflictException e) {\n      return Response.status(Status.CONFLICT).entity(e.getMessage()).build();\n    } catch (NotFoundException | UnauthorizedException | SchedulerException e) {\n      return Response.serverError().build();\n    }\n  }\n\n  /**\n   * Adds a dublinCore metadata catalog to the MediaPackage and returns the grown mediaPackage. JQuery Ajax functions\n   * doesn't support multipart/form-data encoding.\n   *\n   * @param mp\n   *          MediaPackage\n   * @param dc\n   *          DublinCoreCatalog\n   * @return grown MediaPackage XML\n   */\n  @POST\n  @Produces(MediaType.TEXT_XML)\n  @Path(\"addDCCatalog\")\n  @RestQuery(name = \"addDCCatalog\", description = \"Add a dublincore episode catalog to a given media package using an url\", restParameters = {\n          @RestParameter(description = \"The media package as XML\", isRequired = true, name = \"mediaPackage\", type = RestParameter.Type.TEXT),\n          @RestParameter(description = \"DublinCore catalog as XML\", isRequired = true, name = \"dublinCore\", type = RestParameter.Type.TEXT),\n          @RestParameter(defaultValue = \"dublincore/episode\", description = \"DublinCore Flavor\", isRequired = false, name = \"flavor\", type = RestParameter.Type.STRING) }, reponses = {\n          @RestResponse(description = \"Returns augmented media package\", responseCode = HttpServletResponse.SC_OK),\n          @RestResponse(description = \"Media package not valid\", responseCode = HttpServletResponse.SC_BAD_REQUEST),\n          @RestResponse(description = \"\", responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = \"\")\n  public Response addDCCatalog(@FormParam(\"mediaPackage\") String mp, @FormParam(\"dublinCore\") String dc,\n          @FormParam(\"flavor\") String flavor) {\n    logger.trace(\"add DC catalog: {} with flavor: {} to media package: {}\", dc, flavor, mp);\n    MediaPackageElementFlavor dcFlavor = MediaPackageElements.EPISODE;\n    if (flavor != null) {\n      try {\n        dcFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n      } catch (IllegalArgumentException e) {\n        logger.warn(\"Unable to set dublin core flavor to {}, using {} instead\", flavor, MediaPackageElements.EPISODE);\n      }\n    }\n    MediaPackage mediaPackage;\n    /* Check if we got a proper mediapackage and try to parse it */\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().loadFromXml(mp);\n    } catch (MediaPackageException e) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n    if (MediaPackageSupport.sanityCheck(mediaPackage).isSome()) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n\n    /* Check if we got a proper catalog */\n    if (StringUtils.isBlank(dc)) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    }\n\n    InputStream in = null;\n    try {\n      in = IOUtils.toInputStream(dc, \"UTF-8\");\n      mediaPackage = ingestService.addCatalog(in, \"dublincore.xml\", dcFlavor, mediaPackage);\n    } catch (MediaPackageException e) {\n      return Response.serverError().status(Status.BAD_REQUEST).build();\n    } catch (IOException e) {\n      /* Return an internal server error if we could not write to disk */\n      logger.error(\"Could not write catalog to disk: {}\", e.getMessage());\n      return Response.serverError().build();\n    } catch (Exception e) {\n      logger.error(e.getMessage());\n      return Response.serverError().build();\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n    return Response.ok(mediaPackage).build();\n  }\n\n  @Override\n  public JobProducer getService() {\n    return ingestService;\n  }\n\n  @Override\n  public ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the ingest service.\n   *\n   * @param ingestService\n   *          the ingest service\n   */\n  void setIngestService(IngestService ingestService) {\n    this.ingestService = ingestService;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the service registry.\n   *\n   * @param serviceRegistry\n   *          the service registry\n   */\n  void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * OSGi Declarative Services callback to set the reference to the dublin core service.\n   *\n   * @param dcService\n   *          the dublin core service\n   */\n  void setDublinCoreService(DublinCoreCatalogService dcService) {\n    this.dublinCoreService = dcService;\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n}\n"], "filenames": ["modules/common/src/main/java/org/opencastproject/mediapackage/identifier/Id.java", "modules/common/src/main/java/org/opencastproject/mediapackage/identifier/IdImpl.java", "modules/ingest-service-impl/src/main/java/org/opencastproject/ingest/endpoint/IngestRestService.java"], "buggy_code_start_loc": [43, 24, 840], "buggy_code_end_loc": [43, 64, 844], "fixing_code_start_loc": [44, 25, 840], "fixing_code_end_loc": [45, 71, 848], "type": "CWE-74", "message": "Opencast before 8.1 and 7.6 allows almost arbitrary identifiers for media packages and elements to be used. This can be problematic for operation and security since such identifiers are sometimes used for file system operations which may lead to an attacker being able to escape working directories and write files to other locations. In addition, Opencast's Id.toString(\u2026) vs Id.compact(\u2026) behavior, the latter trying to mitigate some of the file system problems, can cause errors due to identifier mismatch since an identifier may unintentionally change. This issue is fixed in Opencast 7.6 and 8.1.", "other": {"cve": {"id": "CVE-2020-5230", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-30T21:15:15.167", "lastModified": "2020-02-10T21:55:25.790", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Opencast before 8.1 and 7.6 allows almost arbitrary identifiers for media packages and elements to be used. This can be problematic for operation and security since such identifiers are sometimes used for file system operations which may lead to an attacker being able to escape working directories and write files to other locations. In addition, Opencast's Id.toString(\u2026) vs Id.compact(\u2026) behavior, the latter trying to mitigate some of the file system problems, can cause errors due to identifier mismatch since an identifier may unintentionally change. This issue is fixed in Opencast 7.6 and 8.1."}, {"lang": "es", "value": "Opencast anterior a las versiones  8.1 y 7.6 permite utilizar identificadores casi arbitrarios para paquetes y elementos de medios. Esto puede ser problem\u00e1tico para la operaci\u00f3n y la seguridad, ya que tales identificadores a veces se usan para las operaciones del sistema de archivos, lo que puede llevar a un atacante a escapar de directorios de trabajo y escribir archivos en otras ubicaciones. Adem\u00e1s, el comportamiento Id.toString (...) vs Id.compact (...) de Opencast, este \u00faltimo tratando de mitigar algunos de los problemas del sistema de archivos, puede causar errores debido a la falta de coincidencia del identificador ya que un identificador puede cambiar involuntariamente. Este problema se soluciona en Opencast 7.6 y 8.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-99"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.6", "matchCriteriaId": "7056094F-6E63-4BFB-B8A3-125746BA882C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A82AABB-ACF6-4017-99E8-4DA90CE416D7"}]}]}], "references": [{"url": "https://github.com/opencast/opencast/commit/bbb473f34ab95497d6c432c81285efb0c739f317", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/opencast/opencast/security/advisories/GHSA-w29m-fjp4-qhmq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencast/opencast/commit/bbb473f34ab95497d6c432c81285efb0c739f317"}}