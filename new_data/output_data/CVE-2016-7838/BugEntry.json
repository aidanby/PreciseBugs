{"buggy_code": ["/*\n *  This file is part of WinSparkle (https://winsparkle.org)\n *\n *  Copyright (C) 2012-2016 Vaclav Slavik\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a\n *  copy of this software and associated documentation files (the \"Software\"),\n *  to deal in the Software without restriction, including without limitation\n *  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n *  and/or sell copies of the Software, and to permit persons to whom the\n *  Software is furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n *  DEALINGS IN THE SOFTWARE.\n *\n */\n\n#include \"updatedownloader.h\"\n#include \"download.h\"\n#include \"settings.h\"\n#include \"ui.h\"\n#include \"error.h\"\n\n#include <wx/string.h>\n\n#include <sstream>\n#include <rpc.h>\n#include <time.h>\n\nnamespace winsparkle\n{\n\n/*--------------------------------------------------------------------------*\n                                  helpers\n *--------------------------------------------------------------------------*/\n\nnamespace\n{\n\nstd::wstring CreateUniqueTempDirectory()\n{\n    // We need to put downloaded updates into a directory of their own, because\n    // if we put it in $TMP, some DLLs could be there and interfere with the\n    // installer.\n    //\n    // This code creates a new randomized directory name and tries to create it;\n    // this process is repeated if the directory already exists.\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}\n\nstruct UpdateDownloadSink : public IDownloadSink\n{\n    UpdateDownloadSink(Thread& thread, const std::wstring& dir)\n        : m_thread(thread),\n          m_dir(dir), m_file(NULL),\n          m_downloaded(0), m_total(0), m_lastUpdate(-1)\n    {}\n\n    ~UpdateDownloadSink() { Close(); }\n\n    void Close()\n    {\n        if ( m_file )\n        {\n            fclose(m_file);\n            m_file = NULL;\n        }\n    }\n\n    std::wstring GetFilePath(void) { return m_path; }\n\n    virtual void SetLength(size_t l) { m_total = l; }\n\n    virtual void SetFilename(const std::wstring& filename)\n    {\n        if ( m_file )\n            throw std::runtime_error(\"Update file already set\");\n\n        m_path = m_dir + L\"\\\\\" + filename;\n        m_file = _wfopen(m_path.c_str(), L\"wb\");\n        if ( !m_file )\n            throw std::runtime_error(\"Cannot save update file\");\n    }\n\n    virtual void Add(const void *data, size_t len)\n    {\n        if ( !m_file )\n            throw std::runtime_error(\"Filename is not net\");\n\n        m_thread.CheckShouldTerminate();\n\n        if ( fwrite(data, len, 1, m_file) != 1 )\n            throw std::runtime_error(\"Cannot save update file\");\n        m_downloaded += len;\n\n        // only update at most 10 times/sec so that we don't flood the UI:\n        clock_t now = clock();\n        if ( now == -1 || m_downloaded == m_total ||\n             ((double(now - m_lastUpdate) / CLOCKS_PER_SEC) >= 0.1) )\n        {\n          UI::NotifyDownloadProgress(m_downloaded, m_total);\n          m_lastUpdate = now;\n        }\n    }\n\n    Thread& m_thread;\n    size_t m_downloaded, m_total;\n    FILE *m_file;\n    std::wstring m_dir;\n    std::wstring m_path;\n    clock_t m_lastUpdate;\n};\n\n} // anonymous namespace\n\n\n/*--------------------------------------------------------------------------*\n                            updater initialization\n *--------------------------------------------------------------------------*/\n\nUpdateDownloader::UpdateDownloader(const Appcast& appcast)\n    : Thread(\"WinSparkle updater\"),\n      m_appcast(appcast)\n{\n}\n\n\n/*--------------------------------------------------------------------------*\n                              downloading\n *--------------------------------------------------------------------------*/\n\nvoid UpdateDownloader::Run()\n{\n    // no initialization to do, so signal readiness immediately\n    SignalReady();\n\n    try\n    {\n      const std::wstring tmpdir = CreateUniqueTempDirectory();\n      Settings::WriteConfigValue(\"UpdateTempDir\", tmpdir);\n\n      UpdateDownloadSink sink(*this, tmpdir);\n      DownloadFile(m_appcast.DownloadURL, &sink, this);\n      sink.Close();\n      UI::NotifyUpdateDownloaded(sink.GetFilePath(), m_appcast);\n    }\n    catch ( ... )\n    {\n        UI::NotifyUpdateError();\n        throw;\n    }\n}\n\n\n/*--------------------------------------------------------------------------*\n                               cleanup\n *--------------------------------------------------------------------------*/\n\nvoid UpdateDownloader::CleanLeftovers()\n{\n    // Note: this is called at startup. Do not use wxWidgets from this code!\n\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n\n    tmpdir.append(1, '\\0'); // double NULL-terminate for SHFileOperation\n\n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | // Vista+-only\n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n    // else: try another time, this is just a \"soft\" error\n}\n\n} // namespace winsparkle\n"], "fixing_code": ["/*\n *  This file is part of WinSparkle (https://winsparkle.org)\n *\n *  Copyright (C) 2012-2016 Vaclav Slavik\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a\n *  copy of this software and associated documentation files (the \"Software\"),\n *  to deal in the Software without restriction, including without limitation\n *  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n *  and/or sell copies of the Software, and to permit persons to whom the\n *  Software is furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n *  DEALINGS IN THE SOFTWARE.\n *\n */\n\n#include \"updatedownloader.h\"\n#include \"download.h\"\n#include \"settings.h\"\n#include \"ui.h\"\n#include \"error.h\"\n\n#include <wx/string.h>\n\n#include <sstream>\n#include <rpc.h>\n#include <time.h>\n\nnamespace winsparkle\n{\n\n/*--------------------------------------------------------------------------*\n                                  helpers\n *--------------------------------------------------------------------------*/\n\nnamespace\n{\n\nstd::wstring GetUniqueTempDirectoryPrefix()\n{\n    wchar_t tmpdir[MAX_PATH + 1];\n    if (GetTempPath(MAX_PATH + 1, tmpdir) == 0)\n        throw Win32Exception(\"Cannot create temporary directory\");\n\n    std::wstring dir(tmpdir);\n    dir += L\"Update-\";\n    return dir;\n}\n\nstd::wstring CreateUniqueTempDirectory()\n{\n    // We need to put downloaded updates into a directory of their own, because\n    // if we put it in $TMP, some DLLs could be there and interfere with the\n    // installer.\n    //\n    // This code creates a new randomized directory name and tries to create it;\n    // this process is repeated if the directory already exists.\n    const std::wstring tmpdir = GetUniqueTempDirectoryPrefix();\n\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}\n\nstruct UpdateDownloadSink : public IDownloadSink\n{\n    UpdateDownloadSink(Thread& thread, const std::wstring& dir)\n        : m_thread(thread),\n          m_dir(dir), m_file(NULL),\n          m_downloaded(0), m_total(0), m_lastUpdate(-1)\n    {}\n\n    ~UpdateDownloadSink() { Close(); }\n\n    void Close()\n    {\n        if ( m_file )\n        {\n            fclose(m_file);\n            m_file = NULL;\n        }\n    }\n\n    std::wstring GetFilePath(void) { return m_path; }\n\n    virtual void SetLength(size_t l) { m_total = l; }\n\n    virtual void SetFilename(const std::wstring& filename)\n    {\n        if ( m_file )\n            throw std::runtime_error(\"Update file already set\");\n\n        m_path = m_dir + L\"\\\\\" + filename;\n        m_file = _wfopen(m_path.c_str(), L\"wb\");\n        if ( !m_file )\n            throw std::runtime_error(\"Cannot save update file\");\n    }\n\n    virtual void Add(const void *data, size_t len)\n    {\n        if ( !m_file )\n            throw std::runtime_error(\"Filename is not net\");\n\n        m_thread.CheckShouldTerminate();\n\n        if ( fwrite(data, len, 1, m_file) != 1 )\n            throw std::runtime_error(\"Cannot save update file\");\n        m_downloaded += len;\n\n        // only update at most 10 times/sec so that we don't flood the UI:\n        clock_t now = clock();\n        if ( now == -1 || m_downloaded == m_total ||\n             ((double(now - m_lastUpdate) / CLOCKS_PER_SEC) >= 0.1) )\n        {\n          UI::NotifyDownloadProgress(m_downloaded, m_total);\n          m_lastUpdate = now;\n        }\n    }\n\n    Thread& m_thread;\n    size_t m_downloaded, m_total;\n    FILE *m_file;\n    std::wstring m_dir;\n    std::wstring m_path;\n    clock_t m_lastUpdate;\n};\n\n} // anonymous namespace\n\n\n/*--------------------------------------------------------------------------*\n                            updater initialization\n *--------------------------------------------------------------------------*/\n\nUpdateDownloader::UpdateDownloader(const Appcast& appcast)\n    : Thread(\"WinSparkle updater\"),\n      m_appcast(appcast)\n{\n}\n\n\n/*--------------------------------------------------------------------------*\n                              downloading\n *--------------------------------------------------------------------------*/\n\nvoid UpdateDownloader::Run()\n{\n    // no initialization to do, so signal readiness immediately\n    SignalReady();\n\n    try\n    {\n      const std::wstring tmpdir = CreateUniqueTempDirectory();\n      Settings::WriteConfigValue(\"UpdateTempDir\", tmpdir);\n\n      UpdateDownloadSink sink(*this, tmpdir);\n      DownloadFile(m_appcast.DownloadURL, &sink, this);\n      sink.Close();\n      UI::NotifyUpdateDownloaded(sink.GetFilePath(), m_appcast);\n    }\n    catch ( ... )\n    {\n        UI::NotifyUpdateError();\n        throw;\n    }\n}\n\n\n/*--------------------------------------------------------------------------*\n                               cleanup\n *--------------------------------------------------------------------------*/\n\nvoid UpdateDownloader::CleanLeftovers()\n{\n    // Note: this is called at startup. Do not use wxWidgets from this code!\n\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n\n    // Check that the directory actually is a valid update temp dir, to prevent\n    // malicious users from forcing us into deleting arbitrary directories:\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) // cannot determine temp directory\n    {\n        return;\n    }\n\n    tmpdir.append(1, '\\0'); // double NULL-terminate for SHFileOperation\n\n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | // Vista+-only\n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n    // else: try another time, this is just a \"soft\" error\n}\n\n} // namespace winsparkle\n"], "filenames": ["src/updatedownloader.cpp"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [194], "fixing_code_start_loc": [48], "fixing_code_end_loc": [217], "type": "CWE-426", "message": "Untrusted search path vulnerability in WinSparkle versions prior to 0.5.3 allows remote attackers to execute arbitrary code via a specially crafted executable file in an unspecified directory.", "other": {"cve": {"id": "CVE-2016-7838", "sourceIdentifier": "vultures@jpcert.or.jp", "published": "2017-06-09T16:29:01.330", "lastModified": "2017-06-20T14:50:26.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Untrusted search path vulnerability in WinSparkle versions prior to 0.5.3 allows remote attackers to execute arbitrary code via a specially crafted executable file in an unspecified directory."}, {"lang": "es", "value": "Vulnerabilidad de ruta de acceso no confiable en las versiones anteriores a 0.5.3 de WinSparkle, permite a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de un archivo ejecutable especialmente modificado en un directorio no especificado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-426"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:winsparkle:winsparkle:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.2", "matchCriteriaId": "AD804FF1-B12E-4BA0-851B-C5323319DD0B"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95099", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/vslavik/winsparkle/commit/bb454857348245a7397f9e4fbb3a902f4ac25913", "source": "vultures@jpcert.or.jp", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jvn.jp/en/jp/JVN90813656/index.html", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://jvn.jp/en/jp/JVN96681653/index.html", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://www.wireshark.org/news/20161214.html", "source": "vultures@jpcert.or.jp", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vslavik/winsparkle/commit/bb454857348245a7397f9e4fbb3a902f4ac25913"}}