{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"index.h\"\n\n#include <stddef.h>\n\n#include \"repository.h\"\n#include \"tree.h\"\n#include \"tree-cache.h\"\n#include \"hash.h\"\n#include \"iterator.h\"\n#include \"pathspec.h\"\n#include \"ignore.h\"\n#include \"blob.h\"\n#include \"idxmap.h\"\n#include \"diff.h\"\n#include \"varint.h\"\n\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/index.h\"\n\n#define INSERT_IN_MAP_EX(idx, map, e, err) do {\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\tgit_idxmap_icase_insert((khash_t(idxicase) *) (map), (e), (e), (err)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tgit_idxmap_insert((map), (e), (e), (err));\t\\\n\t} while (0)\n\n#define INSERT_IN_MAP(idx, e, err) INSERT_IN_MAP_EX(idx, (idx)->entries_map, e, err)\n\n#define LOOKUP_IN_MAP(p, idx, k) do {\t\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\t(p) = git_idxmap_icase_lookup_index((khash_t(idxicase) *) index->entries_map, (k)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\t(p) = git_idxmap_lookup_index(index->entries_map, (k)); \\\n\t} while (0)\n\n#define DELETE_IN_MAP(idx, e) do {\t\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\tgit_idxmap_icase_delete((khash_t(idxicase) *) (idx)->entries_map, (e)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tgit_idxmap_delete((idx)->entries_map, (e));\t\\\n\t} while (0)\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\n\n#define minimal_entry_size (offsetof(struct entry_short, path))\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const size_t INDEX_HEADER_SIZE = 12;\n\nstatic const unsigned int INDEX_VERSION_NUMBER_DEFAULT = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_LB = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_VERSION_NUMBER_COMP = 4;\nstatic const unsigned int INDEX_VERSION_NUMBER_UB = 4;\n\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\n\n#define INDEX_OWNER(idx) ((git_repository *)(GIT_REFCOUNT_OWNER(idx)))\n\nstruct index_header {\n\tuint32_t signature;\n\tuint32_t version;\n\tuint32_t entry_count;\n};\n\nstruct index_extension {\n\tchar signature[4];\n\tuint32_t extension_size;\n};\n\nstruct entry_time {\n\tuint32_t seconds;\n\tuint32_t nanoseconds;\n};\n\nstruct entry_short {\n\tstruct entry_time ctime;\n\tstruct entry_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t file_size;\n\tgit_oid oid;\n\tuint16_t flags;\n\tchar path[1]; /* arbitrary length */\n};\n\nstruct entry_long {\n\tstruct entry_time ctime;\n\tstruct entry_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t file_size;\n\tgit_oid oid;\n\tuint16_t flags;\n\tuint16_t flags_extended;\n\tchar path[1]; /* arbitrary length */\n};\n\nstruct entry_srch_key {\n\tconst char *path;\n\tsize_t pathlen;\n\tint stage;\n};\n\nstruct entry_internal {\n\tgit_index_entry entry;\n\tsize_t pathlen;\n\tchar path[GIT_FLEX_ARRAY];\n};\n\nstruct reuc_entry_internal {\n\tgit_index_reuc_entry entry;\n\tsize_t pathlen;\n\tchar path[GIT_FLEX_ARRAY];\n};\n\n/* local declarations */\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic void index_entry_free(git_index_entry *entry);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_entry_srch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = memcmp(srch_key->path, entry->path, len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}\n\nint git_index_entry_isrch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = strncasecmp(srch_key->path, entry->path, len);\n\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}\n\nstatic int index_entry_srch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcmp((const char *)path, entry->path);\n}\n\nstatic int index_entry_isrch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcasecmp((const char *)path, entry->path);\n}\n\nint git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}\n\nint git_index_entry_icmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcasecmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}\n\nstatic int conflict_name_cmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcmp(name_a->ours, name_b->ours);\n}\n\n/**\n * TODO: enable this when resolving case insensitive conflicts\n */\n#if 0\nstatic int conflict_name_icmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcasecmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcasecmp(name_a->ours, name_b->ours);\n}\n#endif\n\nstatic int reuc_srch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcmp(key, reuc->path);\n}\n\nstatic int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}\n\nstatic int reuc_cmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcmp(info_a->path, info_b->path);\n}\n\nstatic int reuc_icmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcasecmp(info_a->path, info_b->path);\n}\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}\n\nstatic unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}\n\nvoid git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}\n\nint git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\tindex->version = INDEX_VERSION_NUMBER_DEFAULT;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}\n\nint git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}\n\nstatic void index_free(git_index *index)\n{\n\t/* index iterators increment the refcount of the index, so if we\n\t * get here then there should be no outstanding iterators.\n\t */\n\tassert(!git_atomic_get(&index->readers));\n\n\tgit_index_clear(index);\n\tgit_idxmap_free(index->entries_map);\n\tgit_vector_free(&index->entries);\n\tgit_vector_free(&index->names);\n\tgit_vector_free(&index->reuc);\n\tgit_vector_free(&index->deleted);\n\n\tgit__free(index->index_file_path);\n\n\tgit__memzero(index, sizeof(*index));\n\tgit__free(index);\n}\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}\n\n/* call with locked index */\nstatic void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}\n\n/* call with locked index */\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set_str(GITERR_INDEX, msg);\n\treturn error;\n}\n\nint git_index_set_caps(git_index *index, int caps)\n{\n\tunsigned int old_ignore_case;\n\n\tassert(index);\n\n\told_ignore_case = index->ignore_case;\n\n\tif (caps == GIT_INDEXCAP_FROM_OWNER) {\n\t\tgit_repository *repo = INDEX_OWNER(index);\n\t\tint val;\n\n\t\tif (!repo)\n\t\t\treturn create_index_error(\n\t\t\t\t-1, \"cannot access repository to set index caps\");\n\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_IGNORECASE))\n\t\t\tindex->ignore_case = (val != 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_FILEMODE))\n\t\t\tindex->distrust_filemode = (val == 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_SYMLINKS))\n\t\t\tindex->no_symlinks = (val == 0);\n\t}\n\telse {\n\t\tindex->ignore_case = ((caps & GIT_INDEXCAP_IGNORE_CASE) != 0);\n\t\tindex->distrust_filemode = ((caps & GIT_INDEXCAP_NO_FILEMODE) != 0);\n\t\tindex->no_symlinks = ((caps & GIT_INDEXCAP_NO_SYMLINKS) != 0);\n\t}\n\n\tif (old_ignore_case != index->ignore_case) {\n\t\tgit_index__set_ignore_case(index, (bool)index->ignore_case);\n\t}\n\n\treturn 0;\n}\n\nint git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}\n\nconst git_oid *git_index_checksum(git_index *index)\n{\n\treturn &index->checksum;\n}\n\n/**\n * Returns 1 for changed, 0 for not changed and <0 for errors\n */\nstatic int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}\n\nint git_index_read(git_index *index, int force)\n{\n\tint error = 0, updated;\n\tgit_buf buffer = GIT_BUF_INIT;\n\tgit_futils_filestamp stamp = index->stamp;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"failed to read index: The index is in-memory only\");\n\n\tindex->on_disk = git_path_exists(index->index_file_path);\n\n\tif (!index->on_disk) {\n\t\tif (force)\n\t\t\treturn git_index_clear(index);\n\t\treturn 0;\n\t}\n\n\tif ((updated = git_futils_filestamp_check(&stamp, index->index_file_path) < 0) ||\n\t    ((updated = compare_checksum(index)) < 0)) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX,\n\t\t\t\"failed to read index: '%s' no longer exists\",\n\t\t\tindex->index_file_path);\n\t\treturn updated;\n\t}\n\tif (!updated && !force)\n\t\treturn 0;\n\n\terror = git_futils_readbuffer(&buffer, index->index_file_path);\n\tif (error < 0)\n\t\treturn error;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\terror = git_index_clear(index);\n\n\tif (!error)\n\t\terror = parse_index(index, buffer.ptr, buffer.size);\n\n\tif (!error)\n\t\tgit_futils_filestamp_set(&index->stamp, &stamp);\n\n\tgit_buf_free(&buffer);\n\treturn error;\n}\n\nint git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}\n\nstatic bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}\n\n/*\n * Force the next diff to take a look at those entries which have the\n * same timestamp as the current index.\n */\nstatic int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}\n\nunsigned git_index_version(git_index *index)\n{\n\tassert(index);\n\n\treturn index->version;\n}\n\nint git_index_set_version(git_index *index, unsigned int version)\n{\n\tassert(index);\n\n\tif (version < INDEX_VERSION_NUMBER_LB ||\n\t    version > INDEX_VERSION_NUMBER_UB) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid version number\");\n\t\treturn -1;\n\t}\n\n\tindex->version = version;\n\n\treturn 0;\n}\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}\n\nconst char * git_index_path(const git_index *index)\n{\n\tassert(index);\n\treturn index->index_file_path;\n}\n\nint git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"the index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}\n\nint git_index_write_tree_to(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tassert(oid && index && repo);\n\treturn git_tree__write_index(oid, index, repo);\n}\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"index does not contain '%s'\", path);\n\treturn NULL;\n}\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}\n\n/* When `from_workdir` is true, we will validate the paths to avoid placing\n * paths that are invalid for the working directory on the current filesystem\n * (eg, on Windows, we will disallow `GIT~1`, `AUX`, `COM1`, etc).  This\n * function will *always* prevent `.git` and directory traversal `../` from\n * being added to the index.\n */\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}\n\nstatic int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}\n\nstatic git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}\n\nstatic int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}\n\nstatic void index_entry_cpy(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tconst char *tgt_path = tgt->path;\n\tmemcpy(tgt, src, sizeof(*tgt));\n\ttgt->path = tgt_path;\n}\n\nstatic int index_entry_dup(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy(*out, src);\n\treturn 0;\n}\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}\n\nstatic int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/*\n * Do we have another file with a pathname that is a proper\n * subset of the name we're trying to add?\n */\nstatic int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}\n\nstatic int index_no_dups(void **old, void *new)\n{\n\tconst git_index_entry *entry = new;\n\tGIT_UNUSED(old);\n\tgiterr_set(GITERR_INDEX, \"'%s' appears multiple times at stage %d\",\n\t\tentry->path, GIT_IDXENTRY_STAGE(entry));\n\treturn GIT_EEXISTS;\n}\n\nstatic void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* index_insert takes ownership of the new entry - if it can't insert\n * it, then it will return an error **and also free the entry**.  When\n * it replaces an existing entry, it will update the entry_ptr with the\n * actual entry in the index (and free the passed in one).\n *\n * trust_path is whether we use the given path, or whether (on case\n * insensitive systems only) we try to canonicalize the given path to\n * be within an existing directory.\n *\n * trust_mode is whether we trust the mode in entry_ptr.\n *\n * trust_id is whether we trust the id or it should be validated.\n */\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, &error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}\n\nGIT_INLINE(bool) is_file_or_link(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK);\n}\n\nGIT_INLINE(bool) valid_filemode(const int filemode)\n{\n\treturn (is_file_or_link(filemode) || filemode == GIT_FILEMODE_COMMIT);\n}\n\nint git_index_add_frombuffer(\n    git_index *index, const git_index_entry *source_entry,\n    const void *buffer, size_t len)\n{\n\tgit_index_entry *entry = NULL;\n\tint error = 0;\n\tgit_oid id;\n\n\tassert(index && source_entry->path);\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (!is_file_or_link(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif (index_entry_dup(&entry, index, source_entry) < 0)\n\t\treturn -1;\n\n\terror = git_blob_create_frombuffer(&id, INDEX_OWNER(index), buffer, len);\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tgit_oid_cpy(&entry->id, &id);\n\tentry->file_size = len;\n\n\tif ((error = index_insert(index, &entry, 1, true, true, true)) < 0)\n\t\treturn error;\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((error = index_conflict_to_reuc(index, entry->path)) < 0 && error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nstatic int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nint git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}\n\nint git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, &ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}\n\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid entry mode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nint git_index_remove(git_index *index, const char *path, int stage)\n{\n\tint error;\n\tsize_t position;\n\tgit_index_entry remove_key = {{ 0 }};\n\n\tremove_key.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&remove_key, stage);\n\n\tDELETE_IN_MAP(index, &remove_key);\n\n\tif (index_find(&position, index, path, 0, stage) < 0) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX, \"index does not contain %s at stage %d\", path, stage);\n\t\terror = GIT_ENOTFOUND;\n\t} else {\n\t\terror = index_remove_entry(index, position);\n\t}\n\n\treturn error;\n}\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}\n\nint git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)\n{\n\tint error = 0;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tindex_find(&pos, index, prefix, strlen(prefix), GIT_INDEX_STAGE_ANY);\n\tentry = git_vector_get(&index->entries, pos);\n\tif (!entry || git__prefixcmp(entry->path, prefix) != 0)\n\t\terror = GIT_ENOTFOUND;\n\n\tif (!error && at_pos)\n\t\t*at_pos = pos;\n\n\treturn error;\n}\n\nint git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}\n\nint git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}\n\nint git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}\n\nstatic int index_conflict_remove(git_index *index, const char *path)\n{\n\tsize_t pos = 0;\n\tgit_index_entry *conflict_entry;\n\tint error = 0;\n\n\tif (path != NULL && git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\twhile ((conflict_entry = git_vector_get(&index->entries, pos)) != NULL) {\n\n\t\tif (path != NULL &&\n\t\t\tindex->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(conflict_entry) == 0) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = index_remove_entry(index, pos)) < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}\n\nint git_index_conflict_cleanup(git_index *index)\n{\n\tassert(index);\n\treturn index_conflict_remove(index, NULL);\n}\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint git_index_conflict_iterator_new(\n\tgit_index_conflict_iterator **iterator_out,\n\tgit_index *index)\n{\n\tgit_index_conflict_iterator *it = NULL;\n\n\tassert(iterator_out && index);\n\n\tit = git__calloc(1, sizeof(git_index_conflict_iterator));\n\tGITERR_CHECK_ALLOC(it);\n\n\tit->index = index;\n\n\t*iterator_out = it;\n\treturn 0;\n}\n\nint git_index_conflict_next(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index_conflict_iterator *iterator)\n{\n\tconst git_index_entry *entry;\n\tint len;\n\n\tassert(ancestor_out && our_out && their_out && iterator);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\twhile (iterator->cur < iterator->index->entries.length) {\n\t\tentry = git_index_get_byindex(iterator->index, iterator->cur);\n\n\t\tif (git_index_entry_is_conflict(entry)) {\n\t\t\tif ((len = index_conflict__get_byindex(\n\t\t\t\tancestor_out,\n\t\t\t\tour_out,\n\t\t\t\ttheir_out,\n\t\t\t\titerator->index,\n\t\t\t\titerator->cur)) < 0)\n\t\t\t\treturn len;\n\n\t\t\titerator->cur += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\titerator->cur++;\n\t}\n\n\treturn GIT_ITEROVER;\n}\n\nvoid git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)\n{\n\tif (iterator == NULL)\n\t\treturn;\n\n\tgit__free(iterator);\n}\n\nsize_t git_index_name_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->names.length;\n}\n\nconst git_index_name_entry *git_index_name_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\n\tgit_vector_sort(&index->names);\n\treturn git_vector_get(&index->names, n);\n}\n\nstatic void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}\n\nint git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}\n\nsize_t git_index_reuc_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->reuc.length;\n}\n\nstatic int index_reuc_on_dup(void **old, void *new)\n{\n\tindex_entry_reuc_free(*old);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}\n\nstatic int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}\n\nint git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}\n\nint git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}\n\nconst git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}\n\nconst git_index_reuc_entry *git_index_reuc_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treturn git_vector_get(&index->reuc, n);\n}\n\nint git_index_reuc_remove(git_index *index, size_t position)\n{\n\tint error;\n\tgit_index_reuc_entry *reuc;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treuc = git_vector_get(&index->reuc, position);\n\terror = git_vector_remove(&index->reuc, position);\n\n\tif (!error)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}\n\nvoid git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"invalid data in index - %s\", message);\n\treturn -1;\n}\n\nstatic int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0 || tmp > UINT32_MAX) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = (uint32_t)tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}\n\n\nstatic int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}\n\nstatic size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flags)\n{\n\tif (varint_len) {\n\t\tif (flags & GIT_IDXENTRY_EXTENDED)\n\t\t\treturn offsetof(struct entry_long, path) + path_len + 1 + varint_len;\n\t\telse\n\t\t\treturn offsetof(struct entry_short, path) + path_len + 1 + varint_len;\n\t} else {\n#define entry_size(type,len) ((offsetof(type, path) + (len) + 8) & ~7)\n\t\tif (flags & GIT_IDXENTRY_EXTENDED)\n\t\t\treturn entry_size(struct entry_long, path_len);\n\t\telse\n\t\t\treturn entry_size(struct entry_short, path_len);\n#undef entry_size\n\t}\n}\n\nstatic int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}\n\nstatic int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version < INDEX_VERSION_NUMBER_LB ||\n\t\tdest->version > INDEX_VERSION_NUMBER_UB)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}\n\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size;\n\n\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}\n\nstatic bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}\n\nstatic int write_disk_entry(git_filebuf *file, git_index_entry *entry, const char *last)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tint varint_len = 0;\n\tchar *path;\n\tconst char *path_start = entry->path;\n\tsize_t same_len = 0;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (last) {\n\t\tconst char *last_c = last;\n\n\t\twhile (*path_start == *last_c) {\n\t\t\tif (!*path_start || !*last_c)\n\t\t\t\tbreak;\n\t\t\t++path_start;\n\t\t\t++last_c;\n\t\t\t++same_len;\n\t\t}\n\t\tpath_len -= same_len;\n\t\tvarint_len = git_encode_varint(NULL, 0, same_len);\n\t}\n\n\tdisk_size = index_entry_size(path_len, varint_len, entry->flags);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t\tdisk_size -= offsetof(struct entry_long, path);\n\t} else {\n\t\tpath = ondisk->path;\n\t\tdisk_size -= offsetof(struct entry_short, path);\n\t}\n\n\tif (last) {\n\t\tvarint_len = git_encode_varint((unsigned char *) path,\n\t\t\t\t\t  disk_size, same_len);\n\t\tassert(varint_len > 0);\n\t\tpath += varint_len;\n\t\tdisk_size -= varint_len;\n\n\t\t/*\n\t\t * If using path compression, we are not allowed\n\t\t * to have additional trailing NULs.\n\t\t */\n\t\tassert(disk_size == path_len + 1);\n\t} else {\n\t\t/*\n\t\t * If no path compression is used, we do have\n\t\t * NULs as padding. As such, simply assert that\n\t\t * we have enough space left to write the path.\n\t\t */\n\t\tassert(disk_size > path_len);\n\t}\n\n\tmemcpy(path, path_start, path_len + 1);\n\n\treturn 0;\n}\n\nstatic int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\tconst char *last = NULL;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = \"\";\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif ((error = write_disk_entry(file, entry, last)) < 0)\n\t\t\tbreak;\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\t}\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}\n\nstatic int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}\n\nstatic int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}\n\nstatic int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}\n\nstatic int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}\n\nstatic void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tif (index->version <= INDEX_VERSION_NUMBER_EXT)  {\n\t\tis_extended = is_index_extended(index);\n\t\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER_LB;\n\t} else {\n\t\tindex_version_number = index->version;\n\t}\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}\n\nint git_index_entry_stage(const git_index_entry *entry)\n{\n\treturn GIT_IDXENTRY_STAGE(entry);\n}\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}\n\ntypedef struct read_tree_data {\n\tgit_index *index;\n\tgit_vector *old_entries;\n\tgit_vector *new_entries;\n\tgit_vector_cmp entry_cmp;\n\tgit_tree_cache *tree;\n} read_tree_data;\n\nstatic int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tgit_idxmap_resize(entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, &error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}\n\nstatic int git_index_read_iterator(\n\tgit_index *index,\n\tgit_iterator *new_iterator,\n\tsize_t new_length_hint)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tassert((new_iterator->flags & GIT_ITERATOR_DONT_IGNORE_CASE));\n\n\tif ((error = git_vector_init(&new_entries, new_length_hint, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case && new_length_hint)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) new_entries_map, new_length_hint);\n\telse if (new_length_hint)\n\t\tgit_idxmap_resize(new_entries_map, new_length_hint);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\n\tif ((error = git_iterator_for_index(&index_iterator,\n\t\t\tgit_index_owner(index), index, &opts)) < 0 ||\n\t\t((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, &error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\tclear_uptodate(index);\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\treturn error;\n}\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\n\tif ((error = git_iterator_for_index(&new_iterator,\n\t\tgit_index_owner(new_index), (git_index *)new_index, &opts)) < 0 ||\n\t\t(error = git_index_read_iterator(index, new_iterator,\n\t\tnew_index->entries.length)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}\n\nenum {\n\tINDEX_ACTION_NONE = 0,\n\tINDEX_ACTION_UPDATE = 1,\n\tINDEX_ACTION_REMOVE = 2,\n\tINDEX_ACTION_ADDALL = 3,\n};\n\nint git_index_add_all(\n\tgit_index *index,\n\tconst git_strarray *paths,\n\tunsigned int flags,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_repository *repo;\n\tgit_iterator *wditer = NULL;\n\tgit_pathspec ps;\n\tbool no_fnmatch = (flags & GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH) != 0;\n\n\tassert(index);\n\n\trepo = INDEX_OWNER(index);\n\tif ((error = git_repository__ensure_not_bare(repo, \"index add all\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\t/* optionally check that pathspec doesn't mention any ignored files */\n\tif ((flags & GIT_INDEX_ADD_CHECK_PATHSPEC) != 0 &&\n\t\t(flags & GIT_INDEX_ADD_FORCE) == 0 &&\n\t\t(error = git_ignore__check_pathspec_for_exact_ignores(\n\t\t\trepo, &ps.pathspec, no_fnmatch)) < 0)\n\t\tgoto cleanup;\n\n\terror = index_apply_to_wd_diff(index, INDEX_ACTION_ADDALL, paths, flags, cb, payload);\n\n\tif (error)\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_iterator_free(wditer);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}\n\nstruct foreach_diff_data {\n\tgit_index *index;\n\tconst git_pathspec *pathspec;\n\tunsigned int flags;\n\tgit_index_matched_path_cb cb;\n\tvoid *payload;\n};\n\nstatic int apply_each_file(const git_diff_delta *delta, float progress, void *payload)\n{\n\tstruct foreach_diff_data *data = payload;\n\tconst char *match, *path;\n\tint error = 0;\n\n\tGIT_UNUSED(progress);\n\n\tpath = delta->old_file.path;\n\n\t/* We only want those which match the pathspecs */\n\tif (!git_pathspec__match(\n\t\t    &data->pathspec->pathspec, path, false, (bool)data->index->ignore_case,\n\t\t    &match, NULL))\n\t\treturn 0;\n\n\tif (data->cb)\n\t\terror = data->cb(path, match, data->payload);\n\n\tif (error > 0) /* skip this entry */\n\t\treturn 0;\n\tif (error < 0) /* actual error */\n\t\treturn error;\n\n\t/* If the workdir item does not exist, remove it from the index. */\n\tif ((delta->new_file.flags & GIT_DIFF_FLAG_EXISTS) == 0)\n\t\terror = git_index_remove_bypath(data->index, path);\n\telse\n\t\terror = git_index_add_bypath(data->index, delta->new_file.path);\n\n\treturn error;\n}\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}\n\nstatic int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}\n\nint git_index_remove_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_all(\n\t\tindex, INDEX_ACTION_REMOVE, pathspec, cb, payload);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}\n\nint git_index_update_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_wd_diff(index, INDEX_ACTION_UPDATE, pathspec, 0, cb, payload);\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}\n\nint git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}\n\nvoid git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}\n\nint git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}\n\nint git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"the index is locked; this might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}\n\nint git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"index.h\"\n\n#include <stddef.h>\n\n#include \"repository.h\"\n#include \"tree.h\"\n#include \"tree-cache.h\"\n#include \"hash.h\"\n#include \"iterator.h\"\n#include \"pathspec.h\"\n#include \"ignore.h\"\n#include \"blob.h\"\n#include \"idxmap.h\"\n#include \"diff.h\"\n#include \"varint.h\"\n\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/index.h\"\n\n#define INSERT_IN_MAP_EX(idx, map, e, err) do {\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\tgit_idxmap_icase_insert((khash_t(idxicase) *) (map), (e), (e), (err)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tgit_idxmap_insert((map), (e), (e), (err));\t\\\n\t} while (0)\n\n#define INSERT_IN_MAP(idx, e, err) INSERT_IN_MAP_EX(idx, (idx)->entries_map, e, err)\n\n#define LOOKUP_IN_MAP(p, idx, k) do {\t\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\t(p) = git_idxmap_icase_lookup_index((khash_t(idxicase) *) index->entries_map, (k)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\t(p) = git_idxmap_lookup_index(index->entries_map, (k)); \\\n\t} while (0)\n\n#define DELETE_IN_MAP(idx, e) do {\t\t\t\t\t\\\n\t\tif ((idx)->ignore_case)\t\t\t\t\t\\\n\t\t\tgit_idxmap_icase_delete((khash_t(idxicase) *) (idx)->entries_map, (e)); \\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tgit_idxmap_delete((idx)->entries_map, (e));\t\\\n\t} while (0)\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\n\n#define minimal_entry_size (offsetof(struct entry_short, path))\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const size_t INDEX_HEADER_SIZE = 12;\n\nstatic const unsigned int INDEX_VERSION_NUMBER_DEFAULT = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_LB = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_VERSION_NUMBER_COMP = 4;\nstatic const unsigned int INDEX_VERSION_NUMBER_UB = 4;\n\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\n\n#define INDEX_OWNER(idx) ((git_repository *)(GIT_REFCOUNT_OWNER(idx)))\n\nstruct index_header {\n\tuint32_t signature;\n\tuint32_t version;\n\tuint32_t entry_count;\n};\n\nstruct index_extension {\n\tchar signature[4];\n\tuint32_t extension_size;\n};\n\nstruct entry_time {\n\tuint32_t seconds;\n\tuint32_t nanoseconds;\n};\n\nstruct entry_short {\n\tstruct entry_time ctime;\n\tstruct entry_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t file_size;\n\tgit_oid oid;\n\tuint16_t flags;\n\tchar path[1]; /* arbitrary length */\n};\n\nstruct entry_long {\n\tstruct entry_time ctime;\n\tstruct entry_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t file_size;\n\tgit_oid oid;\n\tuint16_t flags;\n\tuint16_t flags_extended;\n\tchar path[1]; /* arbitrary length */\n};\n\nstruct entry_srch_key {\n\tconst char *path;\n\tsize_t pathlen;\n\tint stage;\n};\n\nstruct entry_internal {\n\tgit_index_entry entry;\n\tsize_t pathlen;\n\tchar path[GIT_FLEX_ARRAY];\n};\n\nstruct reuc_entry_internal {\n\tgit_index_reuc_entry entry;\n\tsize_t pathlen;\n\tchar path[GIT_FLEX_ARRAY];\n};\n\n/* local declarations */\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic void index_entry_free(git_index_entry *entry);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_entry_srch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = memcmp(srch_key->path, entry->path, len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}\n\nint git_index_entry_isrch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = strncasecmp(srch_key->path, entry->path, len);\n\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}\n\nstatic int index_entry_srch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcmp((const char *)path, entry->path);\n}\n\nstatic int index_entry_isrch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcasecmp((const char *)path, entry->path);\n}\n\nint git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}\n\nint git_index_entry_icmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcasecmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}\n\nstatic int conflict_name_cmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcmp(name_a->ours, name_b->ours);\n}\n\n/**\n * TODO: enable this when resolving case insensitive conflicts\n */\n#if 0\nstatic int conflict_name_icmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcasecmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcasecmp(name_a->ours, name_b->ours);\n}\n#endif\n\nstatic int reuc_srch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcmp(key, reuc->path);\n}\n\nstatic int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}\n\nstatic int reuc_cmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcmp(info_a->path, info_b->path);\n}\n\nstatic int reuc_icmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcasecmp(info_a->path, info_b->path);\n}\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}\n\nstatic unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}\n\nvoid git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}\n\nint git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\tindex->version = INDEX_VERSION_NUMBER_DEFAULT;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}\n\nint git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}\n\nstatic void index_free(git_index *index)\n{\n\t/* index iterators increment the refcount of the index, so if we\n\t * get here then there should be no outstanding iterators.\n\t */\n\tassert(!git_atomic_get(&index->readers));\n\n\tgit_index_clear(index);\n\tgit_idxmap_free(index->entries_map);\n\tgit_vector_free(&index->entries);\n\tgit_vector_free(&index->names);\n\tgit_vector_free(&index->reuc);\n\tgit_vector_free(&index->deleted);\n\n\tgit__free(index->index_file_path);\n\n\tgit__memzero(index, sizeof(*index));\n\tgit__free(index);\n}\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}\n\n/* call with locked index */\nstatic void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}\n\n/* call with locked index */\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set_str(GITERR_INDEX, msg);\n\treturn error;\n}\n\nint git_index_set_caps(git_index *index, int caps)\n{\n\tunsigned int old_ignore_case;\n\n\tassert(index);\n\n\told_ignore_case = index->ignore_case;\n\n\tif (caps == GIT_INDEXCAP_FROM_OWNER) {\n\t\tgit_repository *repo = INDEX_OWNER(index);\n\t\tint val;\n\n\t\tif (!repo)\n\t\t\treturn create_index_error(\n\t\t\t\t-1, \"cannot access repository to set index caps\");\n\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_IGNORECASE))\n\t\t\tindex->ignore_case = (val != 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_FILEMODE))\n\t\t\tindex->distrust_filemode = (val == 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_SYMLINKS))\n\t\t\tindex->no_symlinks = (val == 0);\n\t}\n\telse {\n\t\tindex->ignore_case = ((caps & GIT_INDEXCAP_IGNORE_CASE) != 0);\n\t\tindex->distrust_filemode = ((caps & GIT_INDEXCAP_NO_FILEMODE) != 0);\n\t\tindex->no_symlinks = ((caps & GIT_INDEXCAP_NO_SYMLINKS) != 0);\n\t}\n\n\tif (old_ignore_case != index->ignore_case) {\n\t\tgit_index__set_ignore_case(index, (bool)index->ignore_case);\n\t}\n\n\treturn 0;\n}\n\nint git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}\n\nconst git_oid *git_index_checksum(git_index *index)\n{\n\treturn &index->checksum;\n}\n\n/**\n * Returns 1 for changed, 0 for not changed and <0 for errors\n */\nstatic int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}\n\nint git_index_read(git_index *index, int force)\n{\n\tint error = 0, updated;\n\tgit_buf buffer = GIT_BUF_INIT;\n\tgit_futils_filestamp stamp = index->stamp;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"failed to read index: The index is in-memory only\");\n\n\tindex->on_disk = git_path_exists(index->index_file_path);\n\n\tif (!index->on_disk) {\n\t\tif (force)\n\t\t\treturn git_index_clear(index);\n\t\treturn 0;\n\t}\n\n\tif ((updated = git_futils_filestamp_check(&stamp, index->index_file_path) < 0) ||\n\t    ((updated = compare_checksum(index)) < 0)) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX,\n\t\t\t\"failed to read index: '%s' no longer exists\",\n\t\t\tindex->index_file_path);\n\t\treturn updated;\n\t}\n\tif (!updated && !force)\n\t\treturn 0;\n\n\terror = git_futils_readbuffer(&buffer, index->index_file_path);\n\tif (error < 0)\n\t\treturn error;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\terror = git_index_clear(index);\n\n\tif (!error)\n\t\terror = parse_index(index, buffer.ptr, buffer.size);\n\n\tif (!error)\n\t\tgit_futils_filestamp_set(&index->stamp, &stamp);\n\n\tgit_buf_free(&buffer);\n\treturn error;\n}\n\nint git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}\n\nstatic bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}\n\n/*\n * Force the next diff to take a look at those entries which have the\n * same timestamp as the current index.\n */\nstatic int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}\n\nunsigned git_index_version(git_index *index)\n{\n\tassert(index);\n\n\treturn index->version;\n}\n\nint git_index_set_version(git_index *index, unsigned int version)\n{\n\tassert(index);\n\n\tif (version < INDEX_VERSION_NUMBER_LB ||\n\t    version > INDEX_VERSION_NUMBER_UB) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid version number\");\n\t\treturn -1;\n\t}\n\n\tindex->version = version;\n\n\treturn 0;\n}\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}\n\nconst char * git_index_path(const git_index *index)\n{\n\tassert(index);\n\treturn index->index_file_path;\n}\n\nint git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"the index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}\n\nint git_index_write_tree_to(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tassert(oid && index && repo);\n\treturn git_tree__write_index(oid, index, repo);\n}\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"index does not contain '%s'\", path);\n\treturn NULL;\n}\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}\n\n/* When `from_workdir` is true, we will validate the paths to avoid placing\n * paths that are invalid for the working directory on the current filesystem\n * (eg, on Windows, we will disallow `GIT~1`, `AUX`, `COM1`, etc).  This\n * function will *always* prevent `.git` and directory traversal `../` from\n * being added to the index.\n */\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}\n\nstatic int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}\n\nstatic git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}\n\nstatic int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}\n\nstatic void index_entry_cpy(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tconst char *tgt_path = tgt->path;\n\tmemcpy(tgt, src, sizeof(*tgt));\n\ttgt->path = tgt_path;\n}\n\nstatic int index_entry_dup(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy(*out, src);\n\treturn 0;\n}\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}\n\nstatic int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/*\n * Do we have another file with a pathname that is a proper\n * subset of the name we're trying to add?\n */\nstatic int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}\n\nstatic int index_no_dups(void **old, void *new)\n{\n\tconst git_index_entry *entry = new;\n\tGIT_UNUSED(old);\n\tgiterr_set(GITERR_INDEX, \"'%s' appears multiple times at stage %d\",\n\t\tentry->path, GIT_IDXENTRY_STAGE(entry));\n\treturn GIT_EEXISTS;\n}\n\nstatic void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* index_insert takes ownership of the new entry - if it can't insert\n * it, then it will return an error **and also free the entry**.  When\n * it replaces an existing entry, it will update the entry_ptr with the\n * actual entry in the index (and free the passed in one).\n *\n * trust_path is whether we use the given path, or whether (on case\n * insensitive systems only) we try to canonicalize the given path to\n * be within an existing directory.\n *\n * trust_mode is whether we trust the mode in entry_ptr.\n *\n * trust_id is whether we trust the id or it should be validated.\n */\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, &error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}\n\nGIT_INLINE(bool) is_file_or_link(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK);\n}\n\nGIT_INLINE(bool) valid_filemode(const int filemode)\n{\n\treturn (is_file_or_link(filemode) || filemode == GIT_FILEMODE_COMMIT);\n}\n\nint git_index_add_frombuffer(\n    git_index *index, const git_index_entry *source_entry,\n    const void *buffer, size_t len)\n{\n\tgit_index_entry *entry = NULL;\n\tint error = 0;\n\tgit_oid id;\n\n\tassert(index && source_entry->path);\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (!is_file_or_link(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif (index_entry_dup(&entry, index, source_entry) < 0)\n\t\treturn -1;\n\n\terror = git_blob_create_frombuffer(&id, INDEX_OWNER(index), buffer, len);\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tgit_oid_cpy(&entry->id, &id);\n\tentry->file_size = len;\n\n\tif ((error = index_insert(index, &entry, 1, true, true, true)) < 0)\n\t\treturn error;\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((error = index_conflict_to_reuc(index, entry->path)) < 0 && error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nstatic int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nint git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}\n\nint git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, &ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}\n\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid entry mode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}\n\nint git_index_remove(git_index *index, const char *path, int stage)\n{\n\tint error;\n\tsize_t position;\n\tgit_index_entry remove_key = {{ 0 }};\n\n\tremove_key.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&remove_key, stage);\n\n\tDELETE_IN_MAP(index, &remove_key);\n\n\tif (index_find(&position, index, path, 0, stage) < 0) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX, \"index does not contain %s at stage %d\", path, stage);\n\t\terror = GIT_ENOTFOUND;\n\t} else {\n\t\terror = index_remove_entry(index, position);\n\t}\n\n\treturn error;\n}\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}\n\nint git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)\n{\n\tint error = 0;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tindex_find(&pos, index, prefix, strlen(prefix), GIT_INDEX_STAGE_ANY);\n\tentry = git_vector_get(&index->entries, pos);\n\tif (!entry || git__prefixcmp(entry->path, prefix) != 0)\n\t\terror = GIT_ENOTFOUND;\n\n\tif (!error && at_pos)\n\t\t*at_pos = pos;\n\n\treturn error;\n}\n\nint git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}\n\nint git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}\n\nint git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}\n\nstatic int index_conflict_remove(git_index *index, const char *path)\n{\n\tsize_t pos = 0;\n\tgit_index_entry *conflict_entry;\n\tint error = 0;\n\n\tif (path != NULL && git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\twhile ((conflict_entry = git_vector_get(&index->entries, pos)) != NULL) {\n\n\t\tif (path != NULL &&\n\t\t\tindex->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(conflict_entry) == 0) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = index_remove_entry(index, pos)) < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}\n\nint git_index_conflict_cleanup(git_index *index)\n{\n\tassert(index);\n\treturn index_conflict_remove(index, NULL);\n}\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint git_index_conflict_iterator_new(\n\tgit_index_conflict_iterator **iterator_out,\n\tgit_index *index)\n{\n\tgit_index_conflict_iterator *it = NULL;\n\n\tassert(iterator_out && index);\n\n\tit = git__calloc(1, sizeof(git_index_conflict_iterator));\n\tGITERR_CHECK_ALLOC(it);\n\n\tit->index = index;\n\n\t*iterator_out = it;\n\treturn 0;\n}\n\nint git_index_conflict_next(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index_conflict_iterator *iterator)\n{\n\tconst git_index_entry *entry;\n\tint len;\n\n\tassert(ancestor_out && our_out && their_out && iterator);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\twhile (iterator->cur < iterator->index->entries.length) {\n\t\tentry = git_index_get_byindex(iterator->index, iterator->cur);\n\n\t\tif (git_index_entry_is_conflict(entry)) {\n\t\t\tif ((len = index_conflict__get_byindex(\n\t\t\t\tancestor_out,\n\t\t\t\tour_out,\n\t\t\t\ttheir_out,\n\t\t\t\titerator->index,\n\t\t\t\titerator->cur)) < 0)\n\t\t\t\treturn len;\n\n\t\t\titerator->cur += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\titerator->cur++;\n\t}\n\n\treturn GIT_ITEROVER;\n}\n\nvoid git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)\n{\n\tif (iterator == NULL)\n\t\treturn;\n\n\tgit__free(iterator);\n}\n\nsize_t git_index_name_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->names.length;\n}\n\nconst git_index_name_entry *git_index_name_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\n\tgit_vector_sort(&index->names);\n\treturn git_vector_get(&index->names, n);\n}\n\nstatic void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}\n\nint git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}\n\nsize_t git_index_reuc_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->reuc.length;\n}\n\nstatic int index_reuc_on_dup(void **old, void *new)\n{\n\tindex_entry_reuc_free(*old);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}\n\nstatic int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}\n\nint git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}\n\nint git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}\n\nconst git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}\n\nconst git_index_reuc_entry *git_index_reuc_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treturn git_vector_get(&index->reuc, n);\n}\n\nint git_index_reuc_remove(git_index *index, size_t position)\n{\n\tint error;\n\tgit_index_reuc_entry *reuc;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treuc = git_vector_get(&index->reuc, position);\n\terror = git_vector_remove(&index->reuc, position);\n\n\tif (!error)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}\n\nvoid git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"invalid data in index - %s\", message);\n\treturn -1;\n}\n\nstatic int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0 || tmp > UINT32_MAX) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = (uint32_t)tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}\n\n\nstatic int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}\n\nstatic size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flags)\n{\n\tif (varint_len) {\n\t\tif (flags & GIT_IDXENTRY_EXTENDED)\n\t\t\treturn offsetof(struct entry_long, path) + path_len + 1 + varint_len;\n\t\telse\n\t\t\treturn offsetof(struct entry_short, path) + path_len + 1 + varint_len;\n\t} else {\n#define entry_size(type,len) ((offsetof(type, path) + (len) + 8) & ~7)\n\t\tif (flags & GIT_IDXENTRY_EXTENDED)\n\t\t\treturn entry_size(struct entry_long, path_len);\n\t\telse\n\t\t\treturn entry_size(struct entry_short, path_len);\n#undef entry_size\n\t}\n}\n\nstatic int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}\n\nstatic int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version < INDEX_VERSION_NUMBER_LB ||\n\t\tdest->version > INDEX_VERSION_NUMBER_UB)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}\n\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size;\n\n\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}\n\nstatic bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}\n\nstatic int write_disk_entry(git_filebuf *file, git_index_entry *entry, const char *last)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tint varint_len = 0;\n\tchar *path;\n\tconst char *path_start = entry->path;\n\tsize_t same_len = 0;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (last) {\n\t\tconst char *last_c = last;\n\n\t\twhile (*path_start == *last_c) {\n\t\t\tif (!*path_start || !*last_c)\n\t\t\t\tbreak;\n\t\t\t++path_start;\n\t\t\t++last_c;\n\t\t\t++same_len;\n\t\t}\n\t\tpath_len -= same_len;\n\t\tvarint_len = git_encode_varint(NULL, 0, same_len);\n\t}\n\n\tdisk_size = index_entry_size(path_len, varint_len, entry->flags);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t\tdisk_size -= offsetof(struct entry_long, path);\n\t} else {\n\t\tpath = ondisk->path;\n\t\tdisk_size -= offsetof(struct entry_short, path);\n\t}\n\n\tif (last) {\n\t\tvarint_len = git_encode_varint((unsigned char *) path,\n\t\t\t\t\t  disk_size, same_len);\n\t\tassert(varint_len > 0);\n\t\tpath += varint_len;\n\t\tdisk_size -= varint_len;\n\n\t\t/*\n\t\t * If using path compression, we are not allowed\n\t\t * to have additional trailing NULs.\n\t\t */\n\t\tassert(disk_size == path_len + 1);\n\t} else {\n\t\t/*\n\t\t * If no path compression is used, we do have\n\t\t * NULs as padding. As such, simply assert that\n\t\t * we have enough space left to write the path.\n\t\t */\n\t\tassert(disk_size > path_len);\n\t}\n\n\tmemcpy(path, path_start, path_len + 1);\n\n\treturn 0;\n}\n\nstatic int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\tconst char *last = NULL;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = \"\";\n\n\tgit_vector_foreach(entries, i, entry) {\n\t\tif ((error = write_disk_entry(file, entry, last)) < 0)\n\t\t\tbreak;\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\t}\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}\n\nstatic int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}\n\nstatic int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}\n\nstatic int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}\n\nstatic int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}\n\nstatic void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tif (index->version <= INDEX_VERSION_NUMBER_EXT)  {\n\t\tis_extended = is_index_extended(index);\n\t\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER_LB;\n\t} else {\n\t\tindex_version_number = index->version;\n\t}\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}\n\nint git_index_entry_stage(const git_index_entry *entry)\n{\n\treturn GIT_IDXENTRY_STAGE(entry);\n}\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}\n\ntypedef struct read_tree_data {\n\tgit_index *index;\n\tgit_vector *old_entries;\n\tgit_vector *new_entries;\n\tgit_vector_cmp entry_cmp;\n\tgit_tree_cache *tree;\n} read_tree_data;\n\nstatic int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tgit_idxmap_resize(entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, &error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}\n\nstatic int git_index_read_iterator(\n\tgit_index *index,\n\tgit_iterator *new_iterator,\n\tsize_t new_length_hint)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tassert((new_iterator->flags & GIT_ITERATOR_DONT_IGNORE_CASE));\n\n\tif ((error = git_vector_init(&new_entries, new_length_hint, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case && new_length_hint)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) new_entries_map, new_length_hint);\n\telse if (new_length_hint)\n\t\tgit_idxmap_resize(new_entries_map, new_length_hint);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\n\tif ((error = git_iterator_for_index(&index_iterator,\n\t\t\tgit_index_owner(index), index, &opts)) < 0 ||\n\t\t((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, &error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\tclear_uptodate(index);\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\treturn error;\n}\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\n\tif ((error = git_iterator_for_index(&new_iterator,\n\t\tgit_index_owner(new_index), (git_index *)new_index, &opts)) < 0 ||\n\t\t(error = git_index_read_iterator(index, new_iterator,\n\t\tnew_index->entries.length)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}\n\nenum {\n\tINDEX_ACTION_NONE = 0,\n\tINDEX_ACTION_UPDATE = 1,\n\tINDEX_ACTION_REMOVE = 2,\n\tINDEX_ACTION_ADDALL = 3,\n};\n\nint git_index_add_all(\n\tgit_index *index,\n\tconst git_strarray *paths,\n\tunsigned int flags,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_repository *repo;\n\tgit_iterator *wditer = NULL;\n\tgit_pathspec ps;\n\tbool no_fnmatch = (flags & GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH) != 0;\n\n\tassert(index);\n\n\trepo = INDEX_OWNER(index);\n\tif ((error = git_repository__ensure_not_bare(repo, \"index add all\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\t/* optionally check that pathspec doesn't mention any ignored files */\n\tif ((flags & GIT_INDEX_ADD_CHECK_PATHSPEC) != 0 &&\n\t\t(flags & GIT_INDEX_ADD_FORCE) == 0 &&\n\t\t(error = git_ignore__check_pathspec_for_exact_ignores(\n\t\t\trepo, &ps.pathspec, no_fnmatch)) < 0)\n\t\tgoto cleanup;\n\n\terror = index_apply_to_wd_diff(index, INDEX_ACTION_ADDALL, paths, flags, cb, payload);\n\n\tif (error)\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_iterator_free(wditer);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}\n\nstruct foreach_diff_data {\n\tgit_index *index;\n\tconst git_pathspec *pathspec;\n\tunsigned int flags;\n\tgit_index_matched_path_cb cb;\n\tvoid *payload;\n};\n\nstatic int apply_each_file(const git_diff_delta *delta, float progress, void *payload)\n{\n\tstruct foreach_diff_data *data = payload;\n\tconst char *match, *path;\n\tint error = 0;\n\n\tGIT_UNUSED(progress);\n\n\tpath = delta->old_file.path;\n\n\t/* We only want those which match the pathspecs */\n\tif (!git_pathspec__match(\n\t\t    &data->pathspec->pathspec, path, false, (bool)data->index->ignore_case,\n\t\t    &match, NULL))\n\t\treturn 0;\n\n\tif (data->cb)\n\t\terror = data->cb(path, match, data->payload);\n\n\tif (error > 0) /* skip this entry */\n\t\treturn 0;\n\tif (error < 0) /* actual error */\n\t\treturn error;\n\n\t/* If the workdir item does not exist, remove it from the index. */\n\tif ((delta->new_file.flags & GIT_DIFF_FLAG_EXISTS) == 0)\n\t\terror = git_index_remove_bypath(data->index, path);\n\telse\n\t\terror = git_index_add_bypath(data->index, delta->new_file.path);\n\n\treturn error;\n}\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}\n\nstatic int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}\n\nint git_index_remove_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_all(\n\t\tindex, INDEX_ACTION_REMOVE, pathspec, cb, payload);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}\n\nint git_index_update_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_wd_diff(index, INDEX_ACTION_UPDATE, pathspec, 0, cb, payload);\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}\n\nint git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}\n\nvoid git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}\n\nint git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}\n\nint git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"the index is locked; this might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}\n\nint git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}\n"], "filenames": ["src/index.c"], "buggy_code_start_loc": [2368], "buggy_code_end_loc": [2377], "fixing_code_start_loc": [2368], "fixing_code_end_loc": [2379], "type": "CWE-190", "message": "Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file.", "other": {"cve": {"id": "CVE-2018-8098", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-14T00:29:00.593", "lastModified": "2022-05-11T21:17:06.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file."}, {"lang": "es", "value": "Desbordamiento de enteros en la funci\u00f3n index.c:read_entry() mientras se descomprime una longitud de prefijo comprimida en libgit2, en versiones anteriores a la v0.26.2, permite que un atacante provoque una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) mediante un archivo de \u00edndice de repositorios manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.26.2", "matchCriteriaId": "1B57F6BF-68C5-4FB6-940E-022FD722FF41"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/libgit2/libgit2/commit/3207ddb0103543da8ad2139ec6539f590f9900c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/3db1af1f370295ad5355b8f64b865a2a357bcac0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://libgit2.github.com/security/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/3207ddb0103543da8ad2139ec6539f590f9900c1"}}