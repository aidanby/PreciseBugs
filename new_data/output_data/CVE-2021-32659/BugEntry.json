{"buggy_code": ["/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport logging from \"./logging\";\nimport { MatrixRoom } from \"../models/rooms/matrix\";\nimport { MatrixUser } from \"../models/users/matrix\";\nimport { RoomBridgeStoreEntry } from \"./room-bridge-store\";\nimport { Bridge } from \"..\";\n\nconst log = logging.get(\"RoomUpgradeHandler\");\n\nexport interface RoomUpgradeHandlerOpts {\n    /**\n     * Should upgrade and invite events be processed after being handled\n     * by the RoomUpgradeHandler. Defaults to `false`.\n     */\n    consumeEvent: boolean;\n    /**\n     * Should ghost users be migrated to the new room. This will leave\n     * any users matching the user regex list in the registration file\n     * from the old room, and join them to the new room.\n     * Defaults to `true`\n     */\n    migrateGhosts: boolean;\n    /**\n     * Migrate room store entries automatically. Defaults to `true`\n     */\n    migrateStoreEntries: boolean;\n\n    /**\n     * Invoked after a room has been upgraded and its entries updated.\n     *\n     * @param oldRoomId The old roomId.\n     * @param newRoomId The new roomId.\n     */\n    onRoomMigrated?: (oldRoomId: string, newRoomId: string) => Promise<void>|void;\n\n    /**\n     * Invoked when iterating around a rooms entries. Should be used to update entries\n     * with a new room id.\n     *\n     * @param entry The existing entry.\n     * @param newRoomId The new roomId.\n     * @return Return the entry to upsert it,\n     * or null to ignore it.\n     */\n    migrateEntry?: (entry: RoomBridgeStoreEntry, newRoomId: string) => Promise<RoomBridgeStoreEntry|null>;\n}\n\n/**\n * Handles migration of rooms when a room upgrade is performed.\n */\nexport class RoomUpgradeHandler {\n    private waitingForInvite = new Map<string, string>(); // newRoomId: oldRoomId\n    /**\n     * @param {RoomUpgradeHandler~Options} opts\n     * @param {Bridge} bridge The parent bridge.\n     */\n    constructor(private readonly opts: RoomUpgradeHandlerOpts, private readonly bridge: Bridge) {\n        if (opts.migrateGhosts !== false) {\n            opts.migrateGhosts = true;\n        }\n        if (opts.migrateStoreEntries !== false) {\n            opts.migrateStoreEntries = true;\n        }\n    }\n\n    /**\n     * Called when the bridge sees a \"m.room.tombstone\" event.\n     * @param ev The m.room.tombstone event.\n     */\n    // eslint-disable-next-line camelcase\n    public async onTombstone(ev: {sender: string, room_id: string, content: {replacement_room: string}}) {\n        const movingTo = ev.content.replacement_room;\n        log.info(`Got tombstone event for ${ev.room_id} -> ${movingTo}`);\n        const joinVia = new MatrixUser(ev.sender).host;\n        // Try to join the new room.\n        try {\n            const couldJoin = await this.joinNewRoom(movingTo, [joinVia]);\n            if (couldJoin) {\n                return this.onJoinedNewRoom(ev.room_id, movingTo);\n            }\n            this.waitingForInvite.set(movingTo, ev.room_id);\n            return true;\n        }\n        catch (err) {\n            log.error(\"Couldn't handle room upgrade: \", err);\n            return false;\n        }\n    }\n\n    private async joinNewRoom(newRoomId: string, joinVia: string[] = []) {\n        const intent = this.bridge.getIntent();\n        try {\n            await intent.join(newRoomId, joinVia);\n            return true;\n        }\n        catch (ex) {\n            if (ex.errcode === \"M_FORBIDDEN\") {\n                return false;\n            }\n            throw Error(\"Failed to handle upgrade\");\n        }\n    }\n\n\n    /**\n     * Called when an invite event reaches the bridge. This function\n     * will check if the invite is from an upgraded room, and will\n     * join the room if so.\n     * @param ev A Matrix m.room.member event of membership=invite\n     *           directed to the bridge bot\n     * @return True if the invite is from an upgraded room and shouldn't\n     * be processed.\n     */\n    // eslint-disable-next-line camelcase\n    public async onInvite(ev: {room_id: string}) {\n        const oldRoomId = this.waitingForInvite.get(ev.room_id);\n        if (!oldRoomId) {\n            return false;\n        }\n        this.waitingForInvite.delete(ev.room_id);\n        log.debug(`Got invite to upgraded room ${ev.room_id}`);\n        try {\n            await this.joinNewRoom(ev.room_id);\n            await this.onJoinedNewRoom(oldRoomId, ev.room_id);\n        }\n        catch (err) {\n            log.error(\"Couldn't handle room upgrade: \", err);\n        }\n        return true;\n    }\n\n    private async onJoinedNewRoom(oldRoomId: string, newRoomId: string) {\n        log.debug(`Joined ${newRoomId}`);\n        const intent = this.bridge.getIntent();\n        const asBot = this.bridge.getBot();\n        if (this.opts.migrateStoreEntries) {\n            const success = await this.migrateStoreEntries(oldRoomId, newRoomId);\n            if (!success) {\n                log.error(\"Failed to migrate room entries. Not continuing with migration.\");\n                return false;\n            }\n        }\n\n        log.debug(`Migrated entries from ${oldRoomId} to ${newRoomId} successfully.`);\n        if (this.opts.onRoomMigrated) {\n            // This may or may not be a promise, so await it.\n            await this.opts.onRoomMigrated(oldRoomId, newRoomId);\n        }\n\n        if (!this.opts.migrateGhosts) {\n            return false;\n        }\n        try {\n            const members = await asBot.getJoinedMembers(oldRoomId);\n            const userIds = Object.keys(members).filter((u) => asBot.isRemoteUser(u));\n            log.debug(`Migrating ${userIds.length} ghosts`);\n            for (const userId of userIds) {\n                const i = this.bridge.getIntent(userId);\n                await i.leave(oldRoomId);\n                await i.join(newRoomId);\n            }\n            intent.leave(oldRoomId);\n        }\n        catch (ex) {\n            log.warn(\"Failed to migrate ghosts\", ex);\n            return false;\n        }\n        return true;\n    }\n\n    private async migrateStoreEntries(oldRoomId: string, newRoomId: string) {\n        const roomStore = this.bridge.getRoomStore();\n        if (!roomStore) {\n            // Do not migrate if we don't have a room store.\n            return true;\n        }\n        const entries = await roomStore.getEntriesByMatrixId(oldRoomId);\n        let success = false;\n        // Upgrades are critical to get right, or a room will be stuck\n        // until someone manaually intervenes. It's important to continue\n        // migrating if at least one entry is successfully migrated.\n        for (const entry of entries) {\n            log.debug(`Migrating room entry ${entry.id}`);\n            const existingId = entry.id;\n            try {\n                const newEntry = await (\n                    this.opts.migrateEntry || this.migrateEntry)(entry, newRoomId);\n\n                if (!newEntry) {\n                    continue;\n                }\n\n                // If migrateEntry changed the id of the room, then ensure\n                // that we remove the old one.\n                if (existingId && existingId !== newEntry.id) {\n                    await roomStore.removeEntryById(existingId);\n                }\n                await roomStore.upsertEntry(newEntry);\n                success = true;\n            }\n            catch (ex) {\n                log.error(`Failed to migrate room entry ${entry.id}.`);\n            }\n        }\n        return success;\n    }\n\n    private migrateEntry(entry: RoomBridgeStoreEntry, newRoomId: string) {\n        entry.matrix = new MatrixRoom(newRoomId, entry.matrix?.serialize());\n        return entry;\n    }\n}\n"], "fixing_code": ["/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport logging from \"./logging\";\nimport { MatrixRoom } from \"../models/rooms/matrix\";\nimport { MatrixUser } from \"../models/users/matrix\";\nimport { RoomBridgeStoreEntry } from \"./room-bridge-store\";\nimport { Bridge } from \"..\";\n\nconst log = logging.get(\"RoomUpgradeHandler\");\n\nexport interface RoomUpgradeHandlerOpts {\n    /**\n     * Should upgrade and invite events be processed after being handled\n     * by the RoomUpgradeHandler. Defaults to `false`.\n     */\n    consumeEvent: boolean;\n    /**\n     * Should ghost users be migrated to the new room. This will leave\n     * any users matching the user regex list in the registration file\n     * from the old room, and join them to the new room.\n     * Defaults to `true`\n     */\n    migrateGhosts: boolean;\n    /**\n     * Migrate room store entries automatically. Defaults to `true`\n     */\n    migrateStoreEntries: boolean;\n\n    /**\n     * Invoked after a room has been upgraded and its entries updated.\n     *\n     * @param oldRoomId The old roomId.\n     * @param newRoomId The new roomId.\n     */\n    onRoomMigrated?: (oldRoomId: string, newRoomId: string) => Promise<void>|void;\n\n    /**\n     * Invoked when iterating around a rooms entries. Should be used to update entries\n     * with a new room id.\n     *\n     * @param entry The existing entry.\n     * @param newRoomId The new roomId.\n     * @return Return the entry to upsert it,\n     * or null to ignore it.\n     */\n    migrateEntry?: (entry: RoomBridgeStoreEntry, newRoomId: string) => Promise<RoomBridgeStoreEntry|null>;\n}\n\n/**\n * Handles migration of rooms when a room upgrade is performed.\n */\nexport class RoomUpgradeHandler {\n    private waitingForInvite = new Map<string, string>(); // newRoomId: oldRoomId\n    /**\n     * @param {RoomUpgradeHandler~Options} opts\n     * @param {Bridge} bridge The parent bridge.\n     */\n    constructor(private readonly opts: RoomUpgradeHandlerOpts, private readonly bridge: Bridge) {\n        if (opts.migrateGhosts !== false) {\n            opts.migrateGhosts = true;\n        }\n        if (opts.migrateStoreEntries !== false) {\n            opts.migrateStoreEntries = true;\n        }\n    }\n\n    /**\n     * Called when the bridge sees a \"m.room.tombstone\" event.\n     * @param ev The m.room.tombstone event.\n     */\n    // eslint-disable-next-line camelcase\n    public async onTombstone(ev: {sender: string, room_id: string, content: {replacement_room: string}}) {\n        const movingTo = ev.content.replacement_room;\n        log.info(`Got tombstone event for ${ev.room_id} -> ${movingTo}`);\n        const joinVia = new MatrixUser(ev.sender).host;\n        // Try to join the new room.\n        try {\n            const couldJoin = await this.joinNewRoom(movingTo, [joinVia]);\n            if (couldJoin) {\n                return this.onJoinedNewRoom(ev.room_id, movingTo);\n            }\n            this.waitingForInvite.set(movingTo, ev.room_id);\n            return true;\n        }\n        catch (err) {\n            log.error(\"Couldn't handle room upgrade: \", err);\n            return false;\n        }\n    }\n\n    private async joinNewRoom(newRoomId: string, joinVia: string[] = []) {\n        const intent = this.bridge.getIntent();\n        try {\n            await intent.join(newRoomId, joinVia);\n            return true;\n        }\n        catch (ex) {\n            if (ex.errcode === \"M_FORBIDDEN\") {\n                return false;\n            }\n            throw Error(\"Failed to handle upgrade\");\n        }\n    }\n\n\n    /**\n     * Called when an invite event reaches the bridge. This function\n     * will check if the invite is from an upgraded room, and will\n     * join the room if so.\n     * @param ev A Matrix m.room.member event of membership=invite\n     *           directed to the bridge bot\n     * @return True if the invite is from an upgraded room and shouldn't\n     * be processed.\n     */\n    // eslint-disable-next-line camelcase\n    public async onInvite(ev: {room_id: string}) {\n        const oldRoomId = this.waitingForInvite.get(ev.room_id);\n        if (!oldRoomId) {\n            return false;\n        }\n        this.waitingForInvite.delete(ev.room_id);\n        log.debug(`Got invite to upgraded room ${ev.room_id}`);\n        try {\n            await this.joinNewRoom(ev.room_id);\n            await this.onJoinedNewRoom(oldRoomId, ev.room_id);\n        }\n        catch (err) {\n            log.error(\"Couldn't handle room upgrade: \", err);\n        }\n        return true;\n    }\n\n    private async onJoinedNewRoom(oldRoomId: string, newRoomId: string) {\n        log.debug(`Joined ${newRoomId}`);\n        const intent = this.bridge.getIntent();\n        const { predecessor } = await intent.getStateEvent(newRoomId, 'm.room.create');\n        if (predecessor.room_id !== oldRoomId) {\n            log.error(\n    `Room doesn't have a matching predecessor (expected: ${oldRoomId}, got: ${predecessor.room_id}), not bridging.`\n            );\n            return false;\n        }\n        const asBot = this.bridge.getBot();\n        if (this.opts.migrateStoreEntries) {\n            const success = await this.migrateStoreEntries(oldRoomId, newRoomId);\n            if (!success) {\n                log.error(\"Failed to migrate room entries. Not continuing with migration.\");\n                return false;\n            }\n        }\n\n        log.debug(`Migrated entries from ${oldRoomId} to ${newRoomId} successfully.`);\n        if (this.opts.onRoomMigrated) {\n            // This may or may not be a promise, so await it.\n            await this.opts.onRoomMigrated(oldRoomId, newRoomId);\n        }\n\n        if (!this.opts.migrateGhosts) {\n            return false;\n        }\n        try {\n            const members = await asBot.getJoinedMembers(oldRoomId);\n            const userIds = Object.keys(members).filter((u) => asBot.isRemoteUser(u));\n            log.debug(`Migrating ${userIds.length} ghosts`);\n            for (const userId of userIds) {\n                const i = this.bridge.getIntent(userId);\n                await i.leave(oldRoomId);\n                await i.join(newRoomId);\n            }\n            intent.leave(oldRoomId);\n        }\n        catch (ex) {\n            log.warn(\"Failed to migrate ghosts\", ex);\n            return false;\n        }\n        return true;\n    }\n\n    private async migrateStoreEntries(oldRoomId: string, newRoomId: string) {\n        const roomStore = this.bridge.getRoomStore();\n        if (!roomStore) {\n            // Do not migrate if we don't have a room store.\n            return true;\n        }\n        const entries = await roomStore.getEntriesByMatrixId(oldRoomId);\n        let success = false;\n        // Upgrades are critical to get right, or a room will be stuck\n        // until someone manaually intervenes. It's important to continue\n        // migrating if at least one entry is successfully migrated.\n        for (const entry of entries) {\n            log.debug(`Migrating room entry ${entry.id}`);\n            const existingId = entry.id;\n            try {\n                const newEntry = await (\n                    this.opts.migrateEntry || this.migrateEntry)(entry, newRoomId);\n\n                if (!newEntry) {\n                    continue;\n                }\n\n                // If migrateEntry changed the id of the room, then ensure\n                // that we remove the old one.\n                if (existingId && existingId !== newEntry.id) {\n                    await roomStore.removeEntryById(existingId);\n                }\n                await roomStore.upsertEntry(newEntry);\n                success = true;\n            }\n            catch (ex) {\n                log.error(`Failed to migrate room entry ${entry.id}.`);\n            }\n        }\n        return success;\n    }\n\n    private migrateEntry(entry: RoomBridgeStoreEntry, newRoomId: string) {\n        entry.matrix = new MatrixRoom(newRoomId, entry.matrix?.serialize());\n        return entry;\n    }\n}\n"], "filenames": ["src/components/room-upgrade-handler.ts"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [147], "fixing_code_start_loc": [148], "fixing_code_end_loc": [155], "type": "CWE-306", "message": "Matrix-appservice-bridge is the bridging service for the Matrix communication program's application services. In versions 2.6.0 and earlier, if a bridge has room upgrade handling turned on in the configuration (the `roomUpgradeOpts` key when instantiating a new `Bridge` instance.), any `m.room.tombstone` event it encounters will be used to unbridge the current room and bridge into the target room. However, the target room `m.room.create` event is not checked to verify if the `predecessor` field contains the previous room. This means that any malicious admin of a bridged room can repoint the traffic to a different room without the new room being aware. Versions 2.6.1 and greater are patched. As a workaround, disabling the automatic room upgrade handling can be done by removing the `roomUpgradeOpts` key from the `Bridge` class options.", "other": {"cve": {"id": "CVE-2021-32659", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-16T19:15:38.830", "lastModified": "2021-07-09T19:46:45.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Matrix-appservice-bridge is the bridging service for the Matrix communication program's application services. In versions 2.6.0 and earlier, if a bridge has room upgrade handling turned on in the configuration (the `roomUpgradeOpts` key when instantiating a new `Bridge` instance.), any `m.room.tombstone` event it encounters will be used to unbridge the current room and bridge into the target room. However, the target room `m.room.create` event is not checked to verify if the `predecessor` field contains the previous room. This means that any malicious admin of a bridged room can repoint the traffic to a different room without the new room being aware. Versions 2.6.1 and greater are patched. As a workaround, disabling the automatic room upgrade handling can be done by removing the `roomUpgradeOpts` key from the `Bridge` class options."}, {"lang": "es", "value": "Matrix-appservice-bridge es el servicio de bridge para los servicios de aplicaci\u00f3n del programa de comunicaci\u00f3n Matrix. En versiones 2.6.0 y anteriores, si un bridge presenta activada la administraci\u00f3n de actualizaci\u00f3n de salas en la configuraci\u00f3n (la clave \"roomUpgradeOpts\" al instanciar una nueva instancia de \"Bridge\"), cualquier evento \"m.room.tombstone\" que encuentre ser\u00e1 usada para deshacer el bridge de la sala actual y pasar a la sala de destino. Sin embargo, el evento \"m.room.create\" de la sala de destino no es comprobado para verificar si el campo \"predecessor\" contiene la sala anterior. Esto significa que cualquier administrador malicioso de una sala bridged puede redirigir el tr\u00e1fico a una sala diferente sin que la nueva sala lo sepa. Las versiones 2.6.1 y superiores est\u00e1n parcheadas. Como soluci\u00f3n, deshabilitando el manejo de la actualizaci\u00f3n autom\u00e1tica de salas eliminando la clave \"roomUpgradeOpts\" de las opciones de la clase \"Bridge\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:matrix-appservice-bridge:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.6.1", "matchCriteriaId": "85F98DF8-5E6B-436E-B20D-FAB50D26DA85"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-appservice-bridge/commit/b69e745584a34fcfd858df33e4631e420da07b9f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-appservice-bridge/releases/tag/2.6.1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/matrix-appservice-bridge/security/advisories/GHSA-35g4-qx3c-vjhx", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-appservice-bridge/commit/b69e745584a34fcfd858df33e4631e420da07b9f"}}