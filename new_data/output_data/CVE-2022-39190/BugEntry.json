{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2007-2009 Patrick McHardy <kaber@trash.net>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/vmalloc.h>\n#include <linux/rhashtable.h>\n#include <linux/audit.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_flow_table.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#define NFT_MODULE_AUTOLOAD_LIMIT (MODULE_NAME_LEN - sizeof(\"nft-expr-255-\"))\n\nunsigned int nf_tables_net_id __read_mostly;\n\nstatic LIST_HEAD(nf_tables_expressions);\nstatic LIST_HEAD(nf_tables_objects);\nstatic LIST_HEAD(nf_tables_flowtables);\nstatic LIST_HEAD(nf_tables_destroy_list);\nstatic DEFINE_SPINLOCK(nf_tables_destroy_list_lock);\n\nenum {\n\tNFT_VALIDATE_SKIP\t= 0,\n\tNFT_VALIDATE_NEED,\n\tNFT_VALIDATE_DO,\n};\n\nstatic struct rhltable nft_objname_ht;\n\nstatic u32 nft_chain_hash(const void *data, u32 len, u32 seed);\nstatic u32 nft_chain_hash_obj(const void *data, u32 len, u32 seed);\nstatic int nft_chain_hash_cmp(struct rhashtable_compare_arg *, const void *);\n\nstatic u32 nft_objname_hash(const void *data, u32 len, u32 seed);\nstatic u32 nft_objname_hash_obj(const void *data, u32 len, u32 seed);\nstatic int nft_objname_hash_cmp(struct rhashtable_compare_arg *, const void *);\n\nstatic const struct rhashtable_params nft_chain_ht_params = {\n\t.head_offset\t\t= offsetof(struct nft_chain, rhlhead),\n\t.key_offset\t\t= offsetof(struct nft_chain, name),\n\t.hashfn\t\t\t= nft_chain_hash,\n\t.obj_hashfn\t\t= nft_chain_hash_obj,\n\t.obj_cmpfn\t\t= nft_chain_hash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nstatic const struct rhashtable_params nft_objname_ht_params = {\n\t.head_offset\t\t= offsetof(struct nft_object, rhlhead),\n\t.key_offset\t\t= offsetof(struct nft_object, key),\n\t.hashfn\t\t\t= nft_objname_hash,\n\t.obj_hashfn\t\t= nft_objname_hash_obj,\n\t.obj_cmpfn\t\t= nft_objname_hash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nstruct nft_audit_data {\n\tstruct nft_table *table;\n\tint entries;\n\tint op;\n\tstruct list_head list;\n};\n\nstatic const u8 nft2audit_op[NFT_MSG_MAX] = { // enum nf_tables_msg_types\n\t[NFT_MSG_NEWTABLE]\t= AUDIT_NFT_OP_TABLE_REGISTER,\n\t[NFT_MSG_GETTABLE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELTABLE]\t= AUDIT_NFT_OP_TABLE_UNREGISTER,\n\t[NFT_MSG_NEWCHAIN]\t= AUDIT_NFT_OP_CHAIN_REGISTER,\n\t[NFT_MSG_GETCHAIN]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELCHAIN]\t= AUDIT_NFT_OP_CHAIN_UNREGISTER,\n\t[NFT_MSG_NEWRULE]\t= AUDIT_NFT_OP_RULE_REGISTER,\n\t[NFT_MSG_GETRULE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELRULE]\t= AUDIT_NFT_OP_RULE_UNREGISTER,\n\t[NFT_MSG_NEWSET]\t= AUDIT_NFT_OP_SET_REGISTER,\n\t[NFT_MSG_GETSET]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELSET]\t= AUDIT_NFT_OP_SET_UNREGISTER,\n\t[NFT_MSG_NEWSETELEM]\t= AUDIT_NFT_OP_SETELEM_REGISTER,\n\t[NFT_MSG_GETSETELEM]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELSETELEM]\t= AUDIT_NFT_OP_SETELEM_UNREGISTER,\n\t[NFT_MSG_NEWGEN]\t= AUDIT_NFT_OP_GEN_REGISTER,\n\t[NFT_MSG_GETGEN]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_TRACE]\t\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_NEWOBJ]\t= AUDIT_NFT_OP_OBJ_REGISTER,\n\t[NFT_MSG_GETOBJ]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELOBJ]\t= AUDIT_NFT_OP_OBJ_UNREGISTER,\n\t[NFT_MSG_GETOBJ_RESET]\t= AUDIT_NFT_OP_OBJ_RESET,\n\t[NFT_MSG_NEWFLOWTABLE]\t= AUDIT_NFT_OP_FLOWTABLE_REGISTER,\n\t[NFT_MSG_GETFLOWTABLE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELFLOWTABLE]\t= AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\n};\n\nstatic void nft_validate_state_update(struct net *net, u8 new_validate_state)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tswitch (nft_net->validate_state) {\n\tcase NFT_VALIDATE_SKIP:\n\t\tWARN_ON_ONCE(new_validate_state == NFT_VALIDATE_DO);\n\t\tbreak;\n\tcase NFT_VALIDATE_NEED:\n\t\tbreak;\n\tcase NFT_VALIDATE_DO:\n\t\tif (new_validate_state == NFT_VALIDATE_NEED)\n\t\t\treturn;\n\t}\n\n\tnft_net->validate_state = new_validate_state;\n}\nstatic void nf_tables_trans_destroy_work(struct work_struct *w);\nstatic DECLARE_WORK(trans_destroy_work, nf_tables_trans_destroy_work);\n\nstatic void nft_ctx_init(struct nft_ctx *ctx,\n\t\t\t struct net *net,\n\t\t\t const struct sk_buff *skb,\n\t\t\t const struct nlmsghdr *nlh,\n\t\t\t u8 family,\n\t\t\t struct nft_table *table,\n\t\t\t struct nft_chain *chain,\n\t\t\t const struct nlattr * const *nla)\n{\n\tctx->net\t= net;\n\tctx->family\t= family;\n\tctx->level\t= 0;\n\tctx->table\t= table;\n\tctx->chain\t= chain;\n\tctx->nla   \t= nla;\n\tctx->portid\t= NETLINK_CB(skb).portid;\n\tctx->report\t= nlmsg_report(nlh);\n\tctx->flags\t= nlh->nlmsg_flags;\n\tctx->seq\t= nlh->nlmsg_seq;\n}\n\nstatic struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\n\treturn trans;\n}\n\nstatic struct nft_trans *nft_trans_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t int msg_type, u32 size)\n{\n\treturn nft_trans_alloc_gfp(ctx, msg_type, size, GFP_KERNEL);\n}\n\nstatic void nft_trans_destroy(struct nft_trans *trans)\n{\n\tlist_del(&trans->list);\n\tkfree(trans);\n}\n\nstatic void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = ctx->net;\n\tstruct nft_trans *trans;\n\n\tif (!nft_set_is_anonymous(set))\n\t\treturn;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry_reverse(trans, &nft_net->commit_list, list) {\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWSET:\n\t\t\tif (nft_trans_set(trans) == set)\n\t\t\t\tnft_trans_set_bound(trans) = true;\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tif (nft_trans_elem_set(trans) == set)\n\t\t\t\tnft_trans_elem_set_bound(trans) = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int nft_netdev_register_hooks(struct net *net,\n\t\t\t\t     struct list_head *hook_list)\n{\n\tstruct nft_hook *hook;\n\tint err, j;\n\n\tj = 0;\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\terr = nf_register_net_hook(net, &hook->ops);\n\t\tif (err < 0)\n\t\t\tgoto err_register;\n\n\t\tj++;\n\t}\n\treturn 0;\n\nerr_register:\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tif (j-- <= 0)\n\t\t\tbreak;\n\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t}\n\treturn err;\n}\n\nstatic void nft_netdev_unregister_hooks(struct net *net,\n\t\t\t\t\tstruct list_head *hook_list,\n\t\t\t\t\tbool release_netdev)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t\tif (release_netdev) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree_rcu(hook, rcu);\n\t\t}\n\t}\n}\n\nstatic int nf_tables_register_hook(struct net *net,\n\t\t\t\t   const struct nft_table *table,\n\t\t\t\t   struct nft_chain *chain)\n{\n\tstruct nft_base_chain *basechain;\n\tconst struct nf_hook_ops *ops;\n\n\tif (table->flags & NFT_TABLE_F_DORMANT ||\n\t    !nft_is_base_chain(chain))\n\t\treturn 0;\n\n\tbasechain = nft_base_chain(chain);\n\tops = &basechain->ops;\n\n\tif (basechain->type->ops_register)\n\t\treturn basechain->type->ops_register(net, ops);\n\n\tif (nft_base_chain_netdev(table->family, basechain->ops.hooknum))\n\t\treturn nft_netdev_register_hooks(net, &basechain->hook_list);\n\n\treturn nf_register_net_hook(net, &basechain->ops);\n}\n\nstatic void __nf_tables_unregister_hook(struct net *net,\n\t\t\t\t\tconst struct nft_table *table,\n\t\t\t\t\tstruct nft_chain *chain,\n\t\t\t\t\tbool release_netdev)\n{\n\tstruct nft_base_chain *basechain;\n\tconst struct nf_hook_ops *ops;\n\n\tif (table->flags & NFT_TABLE_F_DORMANT ||\n\t    !nft_is_base_chain(chain))\n\t\treturn;\n\tbasechain = nft_base_chain(chain);\n\tops = &basechain->ops;\n\n\tif (basechain->type->ops_unregister)\n\t\treturn basechain->type->ops_unregister(net, ops);\n\n\tif (nft_base_chain_netdev(table->family, basechain->ops.hooknum))\n\t\tnft_netdev_unregister_hooks(net, &basechain->hook_list,\n\t\t\t\t\t    release_netdev);\n\telse\n\t\tnf_unregister_net_hook(net, &basechain->ops);\n}\n\nstatic void nf_tables_unregister_hook(struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      struct nft_chain *chain)\n{\n\treturn __nf_tables_unregister_hook(net, table, chain, false);\n}\n\nstatic void nft_trans_commit_list_add_tail(struct net *net, struct nft_trans *trans)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tlist_add_tail(&trans->list, &nft_net->commit_list);\n}\n\nstatic int nft_trans_table_add(struct nft_ctx *ctx, int msg_type)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_table));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWTABLE)\n\t\tnft_activate_next(ctx->net, ctx->table);\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n}\n\nstatic int nft_deltable(struct nft_ctx *ctx)\n{\n\tint err;\n\n\terr = nft_trans_table_add(ctx, NFT_MSG_DELTABLE);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, ctx->table);\n\treturn err;\n}\n\nstatic struct nft_trans *nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_chain));\n\tif (trans == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (msg_type == NFT_MSG_NEWCHAIN) {\n\t\tnft_activate_next(ctx->net, ctx->chain);\n\n\t\tif (ctx->nla[NFTA_CHAIN_ID]) {\n\t\t\tnft_trans_chain_id(trans) =\n\t\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_CHAIN_ID]));\n\t\t}\n\t}\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn trans;\n}\n\nstatic int nft_delchain(struct nft_ctx *ctx)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_chain_add(ctx, NFT_MSG_DELCHAIN);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tctx->table->use--;\n\tnft_deactivate_next(ctx->net, ctx->chain);\n\n\treturn 0;\n}\n\nstatic void nft_rule_expr_activate(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_rule *rule)\n{\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->activate)\n\t\t\texpr->ops->activate(ctx, expr);\n\n\t\texpr = nft_expr_next(expr);\n\t}\n}\n\nstatic void nft_rule_expr_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_rule *rule,\n\t\t\t\t     enum nft_trans_phase phase)\n{\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->deactivate)\n\t\t\texpr->ops->deactivate(ctx, expr, phase);\n\n\t\texpr = nft_expr_next(expr);\n\t}\n}\n\nstatic int\nnf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\t/* You cannot delete the same rule twice */\n\tif (nft_is_active_next(ctx->net, rule)) {\n\t\tnft_deactivate_next(ctx->net, rule);\n\t\tctx->chain->use--;\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\nstatic struct nft_trans *nft_trans_rule_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t\t\t    struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_rule));\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tif (msg_type == NFT_MSG_NEWRULE && ctx->nla[NFTA_RULE_ID] != NULL) {\n\t\tnft_trans_rule_id(trans) =\n\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_RULE_ID]));\n\t}\n\tnft_trans_rule(trans) = rule;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn trans;\n}\n\nstatic int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_flow_rule *flow;\n\tstruct nft_trans *trans;\n\tint err;\n\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ctx->chain->flags & NFT_CHAIN_HW_OFFLOAD) {\n\t\tflow = nft_flow_rule_create(ctx->net, rule);\n\t\tif (IS_ERR(flow)) {\n\t\t\tnft_trans_destroy(trans);\n\t\t\treturn PTR_ERR(flow);\n\t\t}\n\n\t\tnft_trans_flow_rule(trans) = flow;\n\t}\n\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\tnft_rule_expr_deactivate(ctx, rule, NFT_TRANS_PREPARE);\n\n\treturn 0;\n}\n\nstatic int nft_delrule_by_chain(struct nft_ctx *ctx)\n{\n\tstruct nft_rule *rule;\n\tint err;\n\n\tlist_for_each_entry(rule, &ctx->chain->rules, list) {\n\t\tif (!nft_is_active_next(ctx->net, rule))\n\t\t\tcontinue;\n\n\t\terr = nft_delrule(ctx, rule);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int nft_trans_set_add(const struct nft_ctx *ctx, int msg_type,\n\t\t\t     struct nft_set *set)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_set));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWSET && ctx->nla[NFTA_SET_ID] != NULL) {\n\t\tnft_trans_set_id(trans) =\n\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_SET_ID]));\n\t\tnft_activate_next(ctx->net, set);\n\t}\n\tnft_trans_set(trans) = set;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delset(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tint err;\n\n\terr = nft_trans_set_add(ctx, NFT_MSG_DELSET, set);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, set);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic int nft_trans_obj_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t     struct nft_object *obj)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_obj));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWOBJ)\n\t\tnft_activate_next(ctx->net, obj);\n\n\tnft_trans_obj(trans) = obj;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delobj(struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tint err;\n\n\terr = nft_trans_obj_add(ctx, NFT_MSG_DELOBJ, obj);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, obj);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic int nft_trans_flowtable_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t\t   struct nft_flowtable *flowtable)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWFLOWTABLE)\n\t\tnft_activate_next(ctx->net, flowtable);\n\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delflowtable(struct nft_ctx *ctx,\n\t\t\t    struct nft_flowtable *flowtable)\n{\n\tint err;\n\n\terr = nft_trans_flowtable_add(ctx, NFT_MSG_DELFLOWTABLE, flowtable);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, flowtable);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic void __nft_reg_track_clobber(struct nft_regs_track *track, u8 dreg)\n{\n\tint i;\n\n\tfor (i = track->regs[dreg].num_reg; i > 0; i--)\n\t\t__nft_reg_track_cancel(track, dreg - i);\n}\n\nstatic void __nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t\t   const struct nft_expr *expr,\n\t\t\t\t   u8 dreg, u8 num_reg)\n{\n\ttrack->regs[dreg].selector = expr;\n\ttrack->regs[dreg].bitwise = NULL;\n\ttrack->regs[dreg].num_reg = num_reg;\n}\n\nvoid nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len)\n{\n\tunsigned int regcount;\n\tint i;\n\n\t__nft_reg_track_clobber(track, dreg);\n\n\tregcount = DIV_ROUND_UP(len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\t__nft_reg_track_update(track, expr, dreg, i);\n}\nEXPORT_SYMBOL_GPL(nft_reg_track_update);\n\nvoid nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len)\n{\n\tunsigned int regcount;\n\tint i;\n\n\t__nft_reg_track_clobber(track, dreg);\n\n\tregcount = DIV_ROUND_UP(len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\t__nft_reg_track_cancel(track, dreg);\n}\nEXPORT_SYMBOL_GPL(nft_reg_track_cancel);\n\nvoid __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg)\n{\n\ttrack->regs[dreg].selector = NULL;\n\ttrack->regs[dreg].bitwise = NULL;\n\ttrack->regs[dreg].num_reg = 0;\n}\nEXPORT_SYMBOL_GPL(__nft_reg_track_cancel);\n\n/*\n * Tables\n */\n\nstatic struct nft_table *nft_table_lookup(const struct net *net,\n\t\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t\t  u8 family, u8 genmask, u32 nlpid)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list,\n\t\t\t\tlockdep_is_held(&nft_net->commit_mutex)) {\n\t\tif (!nla_strcmp(nla, table->name) &&\n\t\t    table->family == family &&\n\t\t    nft_active_genmask(table, genmask)) {\n\t\t\tif (nft_table_has_owner(table) &&\n\t\t\t    nlpid && table->nlpid != nlpid)\n\t\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t\treturn table;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_table *nft_table_lookup_byhandle(const struct net *net,\n\t\t\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t\t\t   u8 genmask, u32 nlpid)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == table->handle &&\n\t\t    nft_active_genmask(table, genmask)) {\n\t\t\tif (nft_table_has_owner(table) &&\n\t\t\t    nlpid && table->nlpid != nlpid)\n\t\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t\treturn table;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic inline u64 nf_tables_alloc_handle(struct nft_table *table)\n{\n\treturn ++table->hgenerator;\n}\n\nstatic const struct nft_chain_type *chain_type[NFPROTO_NUMPROTO][NFT_CHAIN_T_MAX];\n\nstatic const struct nft_chain_type *\n__nft_chain_type_get(u8 family, enum nft_chain_types type)\n{\n\tif (family >= NFPROTO_NUMPROTO ||\n\t    type >= NFT_CHAIN_T_MAX)\n\t\treturn NULL;\n\n\treturn chain_type[family][type];\n}\n\nstatic const struct nft_chain_type *\n__nf_tables_chain_type_lookup(const struct nlattr *nla, u8 family)\n{\n\tconst struct nft_chain_type *type;\n\tint i;\n\n\tfor (i = 0; i < NFT_CHAIN_T_MAX; i++) {\n\t\ttype = __nft_chain_type_get(family, i);\n\t\tif (!type)\n\t\t\tcontinue;\n\t\tif (!nla_strcmp(nla, type->name))\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstruct nft_module_request {\n\tstruct list_head\tlist;\n\tchar\t\t\tmodule[MODULE_NAME_LEN];\n\tbool\t\t\tdone;\n};\n\n#ifdef CONFIG_MODULES\n__printf(2, 3) int nft_request_module(struct net *net, const char *fmt,\n\t\t\t\t      ...)\n{\n\tchar module_name[MODULE_NAME_LEN];\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_module_request *req;\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);\n\tva_end(args);\n\tif (ret >= MODULE_NAME_LEN)\n\t\treturn 0;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry(req, &nft_net->module_list, list) {\n\t\tif (!strcmp(req->module, module_name)) {\n\t\t\tif (req->done)\n\t\t\t\treturn 0;\n\n\t\t\t/* A request to load this module already exists. */\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->done = false;\n\tstrlcpy(req->module, module_name, MODULE_NAME_LEN);\n\tlist_add_tail(&req->list, &nft_net->module_list);\n\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(nft_request_module);\n#endif\n\nstatic void lockdep_nfnl_nft_mutex_not_held(void)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tif (debug_locks)\n\t\tWARN_ON_ONCE(lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES));\n#endif\n}\n\nstatic const struct nft_chain_type *\nnf_tables_chain_type_lookup(struct net *net, const struct nlattr *nla,\n\t\t\t    u8 family, bool autoload)\n{\n\tconst struct nft_chain_type *type;\n\n\ttype = __nf_tables_chain_type_lookup(nla, family);\n\tif (type != NULL)\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (autoload) {\n\t\tif (nft_request_module(net, \"nft-chain-%u-%.*s\", family,\n\t\t\t\t       nla_len(nla),\n\t\t\t\t       (const char *)nla_data(nla)) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic __be16 nft_base_seq(const struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\treturn htons(nft_net->base_seq & 0xffff);\n}\n\nstatic const struct nla_policy nft_table_policy[NFTA_TABLE_MAX + 1] = {\n\t[NFTA_TABLE_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_TABLE_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_TABLE_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_TABLE_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN }\n};\n\nstatic int nf_tables_fill_table_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t     u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t     int family, const struct nft_table *table)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_TABLE_NAME, table->name) ||\n\t    nla_put_be32(skb, NFTA_TABLE_FLAGS,\n\t\t\t htonl(table->flags & NFT_TABLE_F_MASK)) ||\n\t    nla_put_be32(skb, NFTA_TABLE_USE, htonl(table->use)) ||\n\t    nla_put_be64(skb, NFTA_TABLE_HANDLE, cpu_to_be64(table->handle),\n\t\t\t NFTA_TABLE_PAD))\n\t\tgoto nla_put_failure;\n\tif (nft_table_has_owner(table) &&\n\t    nla_put_be32(skb, NFTA_TABLE_OWNER, htonl(table->nlpid)))\n\t\tgoto nla_put_failure;\n\n\tif (table->udata) {\n\t\tif (nla_put(skb, NFTA_TABLE_USERDATA, table->udlen, table->udata))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nftnl_skb_parms {\n\tbool report;\n};\n#define NFT_CB(skb)\t(*(struct nftnl_skb_parms*)&((skb)->cb))\n\nstatic void nft_notify_enqueue(struct sk_buff *skb, bool report,\n\t\t\t       struct list_head *notify_list)\n{\n\tNFT_CB(skb).report = report;\n\tlist_add_tail(&skb->list, notify_list);\n}\n\nstatic void nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, flags, ctx->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(ctx->net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_tables(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\t\tif (idx > s_idx)\n\t\t\tmemset(&cb->args[1], 0,\n\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\tif (!nft_is_active(net, table))\n\t\t\tcontinue;\n\t\tif (nf_tables_fill_table_info(skb, net,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      NFT_MSG_NEWTABLE, NLM_F_MULTI,\n\t\t\t\t\t      table->family, table) < 0)\n\t\t\tgoto done;\n\n\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\tidx++;\n\t}\ndone:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nft_netlink_dump_start_rcu(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t\t      const struct nlmsghdr *nlh,\n\t\t\t\t      struct netlink_dump_control *c)\n{\n\tint err;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\trcu_read_unlock();\n\terr = netlink_dump_start(nlsk, skb, nlh, c);\n\trcu_read_lock();\n\tmodule_put(THIS_MODULE);\n\n\treturn err;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_gettable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nf_tables_dump_tables,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_TABLE_NAME], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_TABLE_NAME]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_table_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\tinfo->nlh->nlmsg_seq, NFT_MSG_NEWTABLE,\n\t\t\t\t\t0, family, table);\n\tif (err < 0)\n\t\tgoto err_fill_table_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_table_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nft_table_disable(struct net *net, struct nft_table *table, u32 cnt)\n{\n\tstruct nft_chain *chain;\n\tu32 i = 0;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_active_next(net, chain))\n\t\t\tcontinue;\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\tif (cnt && i++ == cnt)\n\t\t\tbreak;\n\n\t\tnf_tables_unregister_hook(net, table, chain);\n\t}\n}\n\nstatic int nf_tables_table_enable(struct net *net, struct nft_table *table)\n{\n\tstruct nft_chain *chain;\n\tint err, i = 0;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_active_next(net, chain))\n\t\t\tcontinue;\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\terr = nf_tables_register_hook(net, table, chain);\n\t\tif (err < 0)\n\t\t\tgoto err_register_hooks;\n\n\t\ti++;\n\t}\n\treturn 0;\n\nerr_register_hooks:\n\tif (i)\n\t\tnft_table_disable(net, table, i);\n\treturn err;\n}\n\nstatic void nf_tables_table_disable(struct net *net, struct nft_table *table)\n{\n\ttable->flags &= ~NFT_TABLE_F_DORMANT;\n\tnft_table_disable(net, table, 0);\n\ttable->flags |= NFT_TABLE_F_DORMANT;\n}\n\n#define __NFT_TABLE_F_INTERNAL\t\t(NFT_TABLE_F_MASK + 1)\n#define __NFT_TABLE_F_WAS_DORMANT\t(__NFT_TABLE_F_INTERNAL << 0)\n#define __NFT_TABLE_F_WAS_AWAKEN\t(__NFT_TABLE_F_INTERNAL << 1)\n#define __NFT_TABLE_F_UPDATE\t\t(__NFT_TABLE_F_WAS_DORMANT | \\\n\t\t\t\t\t __NFT_TABLE_F_WAS_AWAKEN)\n\nstatic int nf_tables_updtable(struct nft_ctx *ctx)\n{\n\tstruct nft_trans *trans;\n\tu32 flags;\n\tint ret;\n\n\tif (!ctx->nla[NFTA_TABLE_FLAGS])\n\t\treturn 0;\n\n\tflags = ntohl(nla_get_be32(ctx->nla[NFTA_TABLE_FLAGS]));\n\tif (flags & ~NFT_TABLE_F_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags == ctx->table->flags)\n\t\treturn 0;\n\n\tif ((nft_table_has_owner(ctx->table) &&\n\t     !(flags & NFT_TABLE_F_OWNER)) ||\n\t    (!nft_table_has_owner(ctx->table) &&\n\t     flags & NFT_TABLE_F_OWNER))\n\t\treturn -EOPNOTSUPP;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE,\n\t\t\t\tsizeof(struct nft_trans_table));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif ((flags & NFT_TABLE_F_DORMANT) &&\n\t    !(ctx->table->flags & NFT_TABLE_F_DORMANT)) {\n\t\tctx->table->flags |= NFT_TABLE_F_DORMANT;\n\t\tif (!(ctx->table->flags & __NFT_TABLE_F_UPDATE))\n\t\t\tctx->table->flags |= __NFT_TABLE_F_WAS_AWAKEN;\n\t} else if (!(flags & NFT_TABLE_F_DORMANT) &&\n\t\t   ctx->table->flags & NFT_TABLE_F_DORMANT) {\n\t\tctx->table->flags &= ~NFT_TABLE_F_DORMANT;\n\t\tif (!(ctx->table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\tret = nf_tables_table_enable(ctx->net, ctx->table);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_register_hooks;\n\n\t\t\tctx->table->flags |= __NFT_TABLE_F_WAS_DORMANT;\n\t\t}\n\t}\n\n\tnft_trans_table_update(trans) = true;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_register_hooks:\n\tnft_trans_destroy(trans);\n\treturn ret;\n}\n\nstatic u32 nft_chain_hash(const void *data, u32 len, u32 seed)\n{\n\tconst char *name = data;\n\n\treturn jhash(name, strlen(name), seed);\n}\n\nstatic u32 nft_chain_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_chain *chain = data;\n\n\treturn nft_chain_hash(chain->name, 0, seed);\n}\n\nstatic int nft_chain_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t      const void *ptr)\n{\n\tconst struct nft_chain *chain = ptr;\n\tconst char *name = arg->key;\n\n\treturn strcmp(chain->name, name);\n}\n\nstatic u32 nft_objname_hash(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_object_hash_key *k = data;\n\n\tseed ^= hash_ptr(k->table, 32);\n\n\treturn jhash(k->name, strlen(k->name), seed);\n}\n\nstatic u32 nft_objname_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_object *obj = data;\n\n\treturn nft_objname_hash(&obj->key, 0, seed);\n}\n\nstatic int nft_objname_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *ptr)\n{\n\tconst struct nft_object_hash_key *k = arg->key;\n\tconst struct nft_object *obj = ptr;\n\n\tif (obj->key.table != k->table)\n\t\treturn -1;\n\n\treturn strcmp(obj->key.name, k->name);\n}\n\nstatic bool nft_supported_family(u8 family)\n{\n\treturn false\n#ifdef CONFIG_NF_TABLES_INET\n\t\t|| family == NFPROTO_INET\n#endif\n#ifdef CONFIG_NF_TABLES_IPV4\n\t\t|| family == NFPROTO_IPV4\n#endif\n#ifdef CONFIG_NF_TABLES_ARP\n\t\t|| family == NFPROTO_ARP\n#endif\n#ifdef CONFIG_NF_TABLES_NETDEV\n\t\t|| family == NFPROTO_NETDEV\n#endif\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE)\n\t\t|| family == NFPROTO_BRIDGE\n#endif\n#ifdef CONFIG_NF_TABLES_IPV6\n\t\t|| family == NFPROTO_IPV6\n#endif\n\t\t;\n}\n\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL_ACCOUNT);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL_ACCOUNT);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL_ACCOUNT);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++nft_net->table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n\nstatic int nft_flush_table(struct nft_ctx *ctx)\n{\n\tstruct nft_flowtable *flowtable, *nft;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_object *obj, *ne;\n\tstruct nft_set *set, *ns;\n\tint err;\n\n\tlist_for_each_entry(chain, &ctx->table->chains, list) {\n\t\tif (!nft_is_active_next(ctx->net, chain))\n\t\t\tcontinue;\n\n\t\tif (nft_chain_is_bound(chain))\n\t\t\tcontinue;\n\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, set))\n\t\t\tcontinue;\n\n\t\tif (nft_set_is_anonymous(set) &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(flowtable, nft, &ctx->table->flowtables, list) {\n\t\tif (!nft_is_active_next(ctx->net, flowtable))\n\t\t\tcontinue;\n\n\t\terr = nft_delflowtable(ctx, flowtable);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(obj, ne, &ctx->table->objects, list) {\n\t\tif (!nft_is_active_next(ctx->net, obj))\n\t\t\tcontinue;\n\n\t\terr = nft_delobj(ctx, obj);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tif (!nft_is_active_next(ctx->net, chain))\n\t\t\tcontinue;\n\n\t\tif (nft_chain_is_bound(chain))\n\t\t\tcontinue;\n\n\t\tctx->chain = chain;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}\n\nstatic int nft_flush(struct nft_ctx *ctx, int family)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_table *table, *nt;\n\tint err = 0;\n\n\tlist_for_each_entry_safe(table, nt, &nft_net->tables, list) {\n\t\tif (family != AF_UNSPEC && table->family != family)\n\t\t\tcontinue;\n\n\t\tctx->family = table->family;\n\n\t\tif (!nft_is_active_next(ctx->net, table))\n\t\t\tcontinue;\n\n\t\tif (nft_table_has_owner(table) && table->nlpid != ctx->portid)\n\t\t\tcontinue;\n\n\t\tif (nla[NFTA_TABLE_NAME] &&\n\t\t    nla_strcmp(nla[NFTA_TABLE_NAME], table->name) != 0)\n\t\t\tcontinue;\n\n\t\tctx->table = table;\n\n\t\terr = nft_flush_table(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\nstatic int nf_tables_deltable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, 0, NULL, NULL, nla);\n\tif (family == AF_UNSPEC ||\n\t    (!nla[NFTA_TABLE_NAME] && !nla[NFTA_TABLE_HANDLE]))\n\t\treturn nft_flush(&ctx, family);\n\n\tif (nla[NFTA_TABLE_HANDLE]) {\n\t\tattr = nla[NFTA_TABLE_HANDLE];\n\t\ttable = nft_table_lookup_byhandle(net, attr, genmask,\n\t\t\t\t\t\t  NETLINK_CB(skb).portid);\n\t} else {\n\t\tattr = nla[NFTA_TABLE_NAME];\n\t\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t\t NETLINK_CB(skb).portid);\n\t}\n\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t    table->use > 0)\n\t\treturn -EBUSY;\n\n\tctx.family = family;\n\tctx.table = table;\n\n\treturn nft_flush_table(&ctx);\n}\n\nstatic void nf_tables_table_destroy(struct nft_ctx *ctx)\n{\n\tif (WARN_ON(ctx->table->use > 0))\n\t\treturn;\n\n\trhltable_destroy(&ctx->table->chains_ht);\n\tkfree(ctx->table->name);\n\tkfree(ctx->table->udata);\n\tkfree(ctx->table);\n}\n\nvoid nft_register_chain_type(const struct nft_chain_type *ctype)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tif (WARN_ON(__nft_chain_type_get(ctype->family, ctype->type))) {\n\t\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\t\treturn;\n\t}\n\tchain_type[ctype->family][ctype->type] = ctype;\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_register_chain_type);\n\nvoid nft_unregister_chain_type(const struct nft_chain_type *ctype)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tchain_type[ctype->family][ctype->type] = NULL;\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_chain_type);\n\n/*\n * Chains\n */\n\nstatic struct nft_chain *\nnft_chain_lookup_byhandle(const struct nft_table *table, u64 handle, u8 genmask)\n{\n\tstruct nft_chain *chain;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (chain->handle == handle &&\n\t\t    nft_active_genmask(chain, genmask))\n\t\t\treturn chain;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic bool lockdep_commit_lock_is_held(const struct net *net)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\treturn lockdep_is_held(&nft_net->commit_mutex);\n#else\n\treturn true;\n#endif\n}\n\nstatic struct nft_chain *nft_chain_lookup(struct net *net,\n\t\t\t\t\t  struct nft_table *table,\n\t\t\t\t\t  const struct nlattr *nla, u8 genmask)\n{\n\tchar search[NFT_CHAIN_MAXNAMELEN + 1];\n\tstruct rhlist_head *tmp, *list;\n\tstruct nft_chain *chain;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnla_strscpy(search, nla, sizeof(search));\n\n\tWARN_ON(!rcu_read_lock_held() &&\n\t\t!lockdep_commit_lock_is_held(net));\n\n\tchain = ERR_PTR(-ENOENT);\n\trcu_read_lock();\n\tlist = rhltable_lookup(&table->chains_ht, search, nft_chain_ht_params);\n\tif (!list)\n\t\tgoto out_unlock;\n\n\trhl_for_each_entry_rcu(chain, tmp, list, rhlhead) {\n\t\tif (nft_active_genmask(chain, genmask))\n\t\t\tgoto out_unlock;\n\t}\n\tchain = ERR_PTR(-ENOENT);\nout_unlock:\n\trcu_read_unlock();\n\treturn chain;\n}\n\nstatic const struct nla_policy nft_chain_policy[NFTA_CHAIN_MAX + 1] = {\n\t[NFTA_CHAIN_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_CHAIN_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_CHAIN_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_CHAIN_HOOK]\t= { .type = NLA_NESTED },\n\t[NFTA_CHAIN_POLICY]\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_TYPE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_MODULE_AUTOLOAD_LIMIT },\n\t[NFTA_CHAIN_COUNTERS]\t= { .type = NLA_NESTED },\n\t[NFTA_CHAIN_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_ID]\t\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n};\n\nstatic const struct nla_policy nft_hook_policy[NFTA_HOOK_MAX + 1] = {\n\t[NFTA_HOOK_HOOKNUM]\t= { .type = NLA_U32 },\n\t[NFTA_HOOK_PRIORITY]\t= { .type = NLA_U32 },\n\t[NFTA_HOOK_DEV]\t\t= { .type = NLA_STRING,\n\t\t\t\t    .len = IFNAMSIZ - 1 },\n};\n\nstatic int nft_dump_stats(struct sk_buff *skb, struct nft_stats __percpu *stats)\n{\n\tstruct nft_stats *cpu_stats, total;\n\tstruct nlattr *nest;\n\tunsigned int seq;\n\tu64 pkts, bytes;\n\tint cpu;\n\n\tif (!stats)\n\t\treturn 0;\n\n\tmemset(&total, 0, sizeof(total));\n\tfor_each_possible_cpu(cpu) {\n\t\tcpu_stats = per_cpu_ptr(stats, cpu);\n\t\tdo {\n\t\t\tseq = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n\t\t\tpkts = cpu_stats->pkts;\n\t\t\tbytes = cpu_stats->bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, seq));\n\t\ttotal.pkts += pkts;\n\t\ttotal.bytes += bytes;\n\t}\n\tnest = nla_nest_start_noflag(skb, NFTA_CHAIN_COUNTERS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.pkts),\n\t\t\t NFTA_COUNTER_PAD) ||\n\t    nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes),\n\t\t\t NFTA_COUNTER_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic int nft_dump_basechain_hook(struct sk_buff *skb, int family,\n\t\t\t\t   const struct nft_base_chain *basechain)\n{\n\tconst struct nf_hook_ops *ops = &basechain->ops;\n\tstruct nft_hook *hook, *first = NULL;\n\tstruct nlattr *nest, *nest_devs;\n\tint n = 0;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_CHAIN_HOOK);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HOOK_HOOKNUM, htonl(ops->hooknum)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HOOK_PRIORITY, htonl(ops->priority)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_base_chain_netdev(family, ops->hooknum)) {\n\t\tnest_devs = nla_nest_start_noflag(skb, NFTA_HOOK_DEVS);\n\t\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\t\tif (!first)\n\t\t\t\tfirst = hook;\n\n\t\t\tif (nla_put_string(skb, NFTA_DEVICE_NAME,\n\t\t\t\t\t   hook->ops.dev->name))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tn++;\n\t\t}\n\t\tnla_nest_end(skb, nest_devs);\n\n\t\tif (n == 1 &&\n\t\t    nla_put_string(skb, NFTA_HOOK_DEV, first->ops.dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nf_tables_fill_chain_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t     u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t     int family, const struct nft_table *table,\n\t\t\t\t     const struct nft_chain *chain)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_CHAIN_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_CHAIN_HANDLE, cpu_to_be64(chain->handle),\n\t\t\t NFTA_CHAIN_PAD))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_CHAIN_NAME, chain->name))\n\t\tgoto nla_put_failure;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tconst struct nft_base_chain *basechain = nft_base_chain(chain);\n\t\tstruct nft_stats __percpu *stats;\n\n\t\tif (nft_dump_basechain_hook(skb, family, basechain))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be32(skb, NFTA_CHAIN_POLICY,\n\t\t\t\t htonl(basechain->policy)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(skb, NFTA_CHAIN_TYPE, basechain->type->name))\n\t\t\tgoto nla_put_failure;\n\n\t\tstats = rcu_dereference_check(basechain->stats,\n\t\t\t\t\t      lockdep_commit_lock_is_held(net));\n\t\tif (nft_dump_stats(skb, stats))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (chain->flags &&\n\t    nla_put_be32(skb, NFTA_CHAIN_FLAGS, htonl(chain->flags)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_CHAIN_USE, htonl(chain->use)))\n\t\tgoto nla_put_failure;\n\n\tif (chain->udata &&\n\t    nla_put(skb, NFTA_CHAIN_USERDATA, chain->udlen, chain->udata))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_chain_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_chain_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, flags, ctx->family, ctx->table,\n\t\t\t\t\tctx->chain);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(ctx->net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_chains(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\tconst struct nft_chain *chain;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(chain, &table->chains, list) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (!nft_is_active(net, chain))\n\t\t\t\tcontinue;\n\t\t\tif (nf_tables_fill_chain_info(skb, net,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      NFT_MSG_NEWCHAIN,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      table->family, table,\n\t\t\t\t\t\t      chain) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_chain *chain;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nf_tables_dump_chains,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = nft_chain_lookup(net, table, nla[NFTA_CHAIN_NAME], genmask);\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_chain_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\tinfo->nlh->nlmsg_seq, NFT_MSG_NEWCHAIN,\n\t\t\t\t\t0, family, table, chain);\n\tif (err < 0)\n\t\tgoto err_fill_chain_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_chain_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nla_policy nft_counter_policy[NFTA_COUNTER_MAX + 1] = {\n\t[NFTA_COUNTER_PACKETS]\t= { .type = NLA_U64 },\n\t[NFTA_COUNTER_BYTES]\t= { .type = NLA_U64 },\n};\n\nstatic struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_COUNTER_MAX, attr,\n\t\t\t\t\t  nft_counter_policy, NULL);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Restore old counters on this cpu, no problem. Per-cpu statistics\n\t * are not exposed to userspace.\n\t */\n\tpreempt_disable();\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\tpreempt_enable();\n\n\treturn newstats;\n}\n\nstatic void nft_chain_stats_replace(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *chain = nft_base_chain(trans->ctx.chain);\n\n\tif (!nft_trans_chain_stats(trans))\n\t\treturn;\n\n\tnft_trans_chain_stats(trans) =\n\t\trcu_replace_pointer(chain->stats, nft_trans_chain_stats(trans),\n\t\t\t\t    lockdep_commit_lock_is_held(trans->ctx.net));\n\n\tif (!nft_trans_chain_stats(trans))\n\t\tstatic_branch_inc(&nft_counters_enabled);\n}\n\nstatic void nf_tables_chain_free_chain_rules(struct nft_chain *chain)\n{\n\tstruct nft_rule_blob *g0 = rcu_dereference_raw(chain->blob_gen_0);\n\tstruct nft_rule_blob *g1 = rcu_dereference_raw(chain->blob_gen_1);\n\n\tif (g0 != g1)\n\t\tkvfree(g1);\n\tkvfree(g0);\n\n\t/* should be NULL either via abort or via successful commit */\n\tWARN_ON_ONCE(chain->blob_next);\n\tkvfree(chain->blob_next);\n}\n\nvoid nf_tables_chain_destroy(struct nft_ctx *ctx)\n{\n\tstruct nft_chain *chain = ctx->chain;\n\tstruct nft_hook *hook, *next;\n\n\tif (WARN_ON(chain->use > 0))\n\t\treturn;\n\n\t/* no concurrent access possible anymore */\n\tnf_tables_chain_free_chain_rules(chain);\n\n\tif (nft_is_base_chain(chain)) {\n\t\tstruct nft_base_chain *basechain = nft_base_chain(chain);\n\n\t\tif (nft_base_chain_netdev(ctx->family, basechain->ops.hooknum)) {\n\t\t\tlist_for_each_entry_safe(hook, next,\n\t\t\t\t\t\t &basechain->hook_list, list) {\n\t\t\t\tlist_del_rcu(&hook->list);\n\t\t\t\tkfree_rcu(hook, rcu);\n\t\t\t}\n\t\t}\n\t\tmodule_put(basechain->type->owner);\n\t\tif (rcu_access_pointer(basechain->stats)) {\n\t\t\tstatic_branch_dec(&nft_counters_enabled);\n\t\t\tfree_percpu(rcu_dereference_raw(basechain->stats));\n\t\t}\n\t\tkfree(chain->name);\n\t\tkfree(chain->udata);\n\t\tkfree(basechain);\n\t} else {\n\t\tkfree(chain->name);\n\t\tkfree(chain->udata);\n\t\tkfree(chain);\n\t}\n}\n\nstatic struct nft_hook *nft_netdev_hook_alloc(struct net *net,\n\t\t\t\t\t      const struct nlattr *attr)\n{\n\tstruct net_device *dev;\n\tchar ifname[IFNAMSIZ];\n\tstruct nft_hook *hook;\n\tint err;\n\n\thook = kmalloc(sizeof(struct nft_hook), GFP_KERNEL_ACCOUNT);\n\tif (!hook) {\n\t\terr = -ENOMEM;\n\t\tgoto err_hook_alloc;\n\t}\n\n\tnla_strscpy(ifname, attr, IFNAMSIZ);\n\t/* nf_tables_netdev_event() is called under rtnl_mutex, this is\n\t * indirectly serializing all the other holders of the commit_mutex with\n\t * the rtnl_mutex.\n\t */\n\tdev = __dev_get_by_name(net, ifname);\n\tif (!dev) {\n\t\terr = -ENOENT;\n\t\tgoto err_hook_dev;\n\t}\n\thook->ops.dev = dev;\n\n\treturn hook;\n\nerr_hook_dev:\n\tkfree(hook);\nerr_hook_alloc:\n\treturn ERR_PTR(err);\n}\n\nstatic struct nft_hook *nft_hook_list_find(struct list_head *hook_list,\n\t\t\t\t\t   const struct nft_hook *this)\n{\n\tstruct nft_hook *hook;\n\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tif (this->ops.dev == hook->ops.dev)\n\t\t\treturn hook;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nf_tables_parse_netdev_hooks(struct net *net,\n\t\t\t\t\tconst struct nlattr *attr,\n\t\t\t\t\tstruct list_head *hook_list)\n{\n\tstruct nft_hook *hook, *next;\n\tconst struct nlattr *tmp;\n\tint rem, n = 0, err;\n\n\tnla_for_each_nested(tmp, attr, rem) {\n\t\tif (nla_type(tmp) != NFTA_DEVICE_NAME) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_hook;\n\t\t}\n\n\t\thook = nft_netdev_hook_alloc(net, tmp);\n\t\tif (IS_ERR(hook)) {\n\t\t\terr = PTR_ERR(hook);\n\t\t\tgoto err_hook;\n\t\t}\n\t\tif (nft_hook_list_find(hook_list, hook)) {\n\t\t\tkfree(hook);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err_hook;\n\t\t}\n\t\tlist_add_tail(&hook->list, hook_list);\n\t\tn++;\n\n\t\tif (n == NFT_NETDEVICE_MAX) {\n\t\t\terr = -EFBIG;\n\t\t\tgoto err_hook;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_hook:\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tlist_del(&hook->list);\n\t\tkfree(hook);\n\t}\n\treturn err;\n}\n\nstruct nft_chain_hook {\n\tu32\t\t\t\tnum;\n\ts32\t\t\t\tpriority;\n\tconst struct nft_chain_type\t*type;\n\tstruct list_head\t\tlist;\n};\n\nstatic int nft_chain_parse_netdev(struct net *net,\n\t\t\t\t  struct nlattr *tb[],\n\t\t\t\t  struct list_head *hook_list)\n{\n\tstruct nft_hook *hook;\n\tint err;\n\n\tif (tb[NFTA_HOOK_DEV]) {\n\t\thook = nft_netdev_hook_alloc(net, tb[NFTA_HOOK_DEV]);\n\t\tif (IS_ERR(hook))\n\t\t\treturn PTR_ERR(hook);\n\n\t\tlist_add_tail(&hook->list, hook_list);\n\t} else if (tb[NFTA_HOOK_DEVS]) {\n\t\terr = nf_tables_parse_netdev_hooks(net, tb[NFTA_HOOK_DEVS],\n\t\t\t\t\t\t   hook_list);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (list_empty(hook_list))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_chain_parse_hook(struct net *net,\n\t\t\t\tconst struct nlattr * const nla[],\n\t\t\t\tstruct nft_chain_hook *hook, u8 family,\n\t\t\t\tstruct netlink_ext_ack *extack, bool autoload)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nlattr *ha[NFTA_HOOK_MAX + 1];\n\tconst struct nft_chain_type *type;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tlockdep_nfnl_nft_mutex_not_held();\n\n\terr = nla_parse_nested_deprecated(ha, NFTA_HOOK_MAX,\n\t\t\t\t\t  nla[NFTA_CHAIN_HOOK],\n\t\t\t\t\t  nft_hook_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ha[NFTA_HOOK_HOOKNUM] == NULL ||\n\t    ha[NFTA_HOOK_PRIORITY] == NULL)\n\t\treturn -EINVAL;\n\n\thook->num = ntohl(nla_get_be32(ha[NFTA_HOOK_HOOKNUM]));\n\thook->priority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));\n\n\ttype = __nft_chain_type_get(family, NFT_CHAIN_T_DEFAULT);\n\tif (!type)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla[NFTA_CHAIN_TYPE]) {\n\t\ttype = nf_tables_chain_type_lookup(net, nla[NFTA_CHAIN_TYPE],\n\t\t\t\t\t\t   family, autoload);\n\t\tif (IS_ERR(type)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TYPE]);\n\t\t\treturn PTR_ERR(type);\n\t\t}\n\t}\n\tif (hook->num >= NFT_MAX_HOOKS || !(type->hook_mask & (1 << hook->num)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (type->type == NFT_CHAIN_T_NAT &&\n\t    hook->priority <= NF_IP_PRI_CONNTRACK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!try_module_get(type->owner)) {\n\t\tif (nla[NFTA_CHAIN_TYPE])\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TYPE]);\n\t\treturn -ENOENT;\n\t}\n\n\thook->type = type;\n\n\tINIT_LIST_HEAD(&hook->list);\n\tif (nft_base_chain_netdev(family, hook->num)) {\n\t\terr = nft_chain_parse_netdev(net, ha, &hook->list);\n\t\tif (err < 0) {\n\t\t\tmodule_put(type->owner);\n\t\t\treturn err;\n\t\t}\n\t} else if (ha[NFTA_HOOK_DEV] || ha[NFTA_HOOK_DEVS]) {\n\t\tmodule_put(type->owner);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_chain_release_hook(struct nft_chain_hook *hook)\n{\n\tstruct nft_hook *h, *next;\n\n\tlist_for_each_entry_safe(h, next, &hook->list, list) {\n\t\tlist_del(&h->list);\n\t\tkfree(h);\n\t}\n\tmodule_put(hook->type->owner);\n}\n\nstruct nft_rules_old {\n\tstruct rcu_head h;\n\tstruct nft_rule_blob *blob;\n};\n\nstatic void nft_last_rule(struct nft_rule_blob *blob, const void *ptr)\n{\n\tstruct nft_rule_dp *prule;\n\n\tprule = (struct nft_rule_dp *)ptr;\n\tprule->is_last = 1;\n\t/* blob size does not include the trailer rule */\n}\n\nstatic struct nft_rule_blob *nf_tables_chain_alloc_rules(unsigned int size)\n{\n\tstruct nft_rule_blob *blob;\n\n\t/* size must include room for the last rule */\n\tif (size < offsetof(struct nft_rule_dp, data))\n\t\treturn NULL;\n\n\tsize += sizeof(struct nft_rule_blob) + sizeof(struct nft_rules_old);\n\tif (size > INT_MAX)\n\t\treturn NULL;\n\n\tblob = kvmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!blob)\n\t\treturn NULL;\n\n\tblob->size = 0;\n\tnft_last_rule(blob, blob->data);\n\n\treturn blob;\n}\n\nstatic void nft_basechain_hook_init(struct nf_hook_ops *ops, u8 family,\n\t\t\t\t    const struct nft_chain_hook *hook,\n\t\t\t\t    struct nft_chain *chain)\n{\n\tops->pf\t\t\t= family;\n\tops->hooknum\t\t= hook->num;\n\tops->priority\t\t= hook->priority;\n\tops->priv\t\t= chain;\n\tops->hook\t\t= hook->type->hooks[ops->hooknum];\n\tops->hook_ops_type\t= NF_HOOK_OP_NF_TABLES;\n}\n\nstatic int nft_basechain_init(struct nft_base_chain *basechain, u8 family,\n\t\t\t      struct nft_chain_hook *hook, u32 flags)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_hook *h;\n\n\tbasechain->type = hook->type;\n\tINIT_LIST_HEAD(&basechain->hook_list);\n\tchain = &basechain->chain;\n\n\tif (nft_base_chain_netdev(family, hook->num)) {\n\t\tlist_splice_init(&hook->list, &basechain->hook_list);\n\t\tlist_for_each_entry(h, &basechain->hook_list, list)\n\t\t\tnft_basechain_hook_init(&h->ops, family, hook, chain);\n\n\t\tbasechain->ops.hooknum\t= hook->num;\n\t\tbasechain->ops.priority\t= hook->priority;\n\t} else {\n\t\tnft_basechain_hook_init(&basechain->ops, family, hook, chain);\n\t}\n\n\tchain->flags |= NFT_CHAIN_BASE | flags;\n\tbasechain->policy = NF_ACCEPT;\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD &&\n\t    !nft_chain_offload_support(basechain))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_block_init(&basechain->flow_block);\n\n\treturn 0;\n}\n\nstatic int nft_chain_add(struct nft_table *table, struct nft_chain *chain)\n{\n\tint err;\n\n\terr = rhltable_insert_key(&table->chains_ht, chain->name,\n\t\t\t\t  &chain->rhlhead, nft_chain_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tlist_add_tail_rcu(&chain->list, &table->chains);\n\n\treturn 0;\n}\n\nstatic u64 chain_id;\n\nstatic int nf_tables_addchain(struct nft_ctx *ctx, u8 family, u8 genmask,\n\t\t\t      u8 policy, u32 flags,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_stats __percpu *stats = NULL;\n\tstruct nft_table *table = ctx->table;\n\tstruct nft_base_chain *basechain;\n\tstruct net *net = ctx->net;\n\tchar name[NFT_NAME_MAXLEN];\n\tstruct nft_rule_blob *blob;\n\tstruct nft_trans *trans;\n\tstruct nft_chain *chain;\n\tunsigned int data_size;\n\tint err;\n\n\tif (table->use == UINT_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (nla[NFTA_CHAIN_HOOK]) {\n\t\tstruct nft_chain_hook hook;\n\n\t\tif (flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_chain_parse_hook(net, nla, &hook, family, extack,\n\t\t\t\t\t   true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbasechain = kzalloc(sizeof(*basechain), GFP_KERNEL_ACCOUNT);\n\t\tif (basechain == NULL) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tchain = &basechain->chain;\n\n\t\tif (nla[NFTA_CHAIN_COUNTERS]) {\n\t\t\tstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\n\t\t\tif (IS_ERR(stats)) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tkfree(basechain);\n\t\t\t\treturn PTR_ERR(stats);\n\t\t\t}\n\t\t\trcu_assign_pointer(basechain->stats, stats);\n\t\t}\n\n\t\terr = nft_basechain_init(basechain, family, &hook, flags);\n\t\tif (err < 0) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\tkfree(basechain);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (flags & NFT_CHAIN_BASE)\n\t\t\treturn -EINVAL;\n\t\tif (flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tchain = kzalloc(sizeof(*chain), GFP_KERNEL_ACCOUNT);\n\t\tif (chain == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tchain->flags = flags;\n\t}\n\tctx->chain = chain;\n\n\tINIT_LIST_HEAD(&chain->rules);\n\tchain->handle = nf_tables_alloc_handle(table);\n\tchain->table = table;\n\n\tif (nla[NFTA_CHAIN_NAME]) {\n\t\tchain->name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL_ACCOUNT);\n\t} else {\n\t\tif (!(flags & NFT_CHAIN_BINDING)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_destroy_chain;\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"__chain%llu\", ++chain_id);\n\t\tchain->name = kstrdup(name, GFP_KERNEL_ACCOUNT);\n\t}\n\n\tif (!chain->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_chain;\n\t}\n\n\tif (nla[NFTA_CHAIN_USERDATA]) {\n\t\tchain->udata = nla_memdup(nla[NFTA_CHAIN_USERDATA], GFP_KERNEL_ACCOUNT);\n\t\tif (chain->udata == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_chain;\n\t\t}\n\t\tchain->udlen = nla_len(nla[NFTA_CHAIN_USERDATA]);\n\t}\n\n\tdata_size = offsetof(struct nft_rule_dp, data);\t/* last rule */\n\tblob = nf_tables_chain_alloc_rules(data_size);\n\tif (!blob) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_chain;\n\t}\n\n\tRCU_INIT_POINTER(chain->blob_gen_0, blob);\n\tRCU_INIT_POINTER(chain->blob_gen_1, blob);\n\n\terr = nf_tables_register_hook(net, table, chain);\n\tif (err < 0)\n\t\tgoto err_destroy_chain;\n\n\ttrans = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto err_unregister_hook;\n\t}\n\n\tnft_trans_chain_policy(trans) = NFT_CHAIN_POLICY_UNSET;\n\tif (nft_is_base_chain(chain))\n\t\tnft_trans_chain_policy(trans) = policy;\n\n\terr = nft_chain_add(table, chain);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\tgoto err_unregister_hook;\n\t}\n\n\tif (stats)\n\t\tstatic_branch_inc(&nft_counters_enabled);\n\n\ttable->use++;\n\n\treturn 0;\nerr_unregister_hook:\n\tnf_tables_unregister_hook(net, table, chain);\nerr_destroy_chain:\n\tnf_tables_chain_destroy(ctx);\n\n\treturn err;\n}\n\nstatic bool nft_hook_list_equal(struct list_head *hook_list1,\n\t\t\t\tstruct list_head *hook_list2)\n{\n\tstruct nft_hook *hook;\n\tint n = 0, m = 0;\n\n\tn = 0;\n\tlist_for_each_entry(hook, hook_list2, list) {\n\t\tif (!nft_hook_list_find(hook_list1, hook))\n\t\t\treturn false;\n\n\t\tn++;\n\t}\n\tlist_for_each_entry(hook, hook_list1, list)\n\t\tm++;\n\n\treturn n == m;\n}\n\nstatic int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,\n\t\t\t      u32 flags, const struct nlattr *attr,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_table *table = ctx->table;\n\tstruct nft_chain *chain = ctx->chain;\n\tstruct nft_base_chain *basechain;\n\tstruct nft_stats *stats = NULL;\n\tstruct nft_chain_hook hook;\n\tstruct nf_hook_ops *ops;\n\tstruct nft_trans *trans;\n\tint err;\n\n\tif (chain->flags ^ flags)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla[NFTA_CHAIN_HOOK]) {\n\t\tif (!nft_is_base_chain(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\terr = nft_chain_parse_hook(ctx->net, nla, &hook, ctx->family,\n\t\t\t\t\t   extack, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type != hook.type) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tif (nft_base_chain_netdev(ctx->family, hook.num)) {\n\t\t\tif (!nft_hook_list_equal(&basechain->hook_list,\n\t\t\t\t\t\t &hook.list)) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t} else {\n\t\t\tops = &basechain->ops;\n\t\t\tif (ops->hooknum != hook.num ||\n\t\t\t    ops->priority != hook.priority) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t}\n\t\tnft_chain_release_hook(&hook);\n\t}\n\n\tif (nla[NFTA_CHAIN_HANDLE] &&\n\t    nla[NFTA_CHAIN_NAME]) {\n\t\tstruct nft_chain *chain2;\n\n\t\tchain2 = nft_chain_lookup(ctx->net, table,\n\t\t\t\t\t  nla[NFTA_CHAIN_NAME], genmask);\n\t\tif (!IS_ERR(chain2)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (nla[NFTA_CHAIN_COUNTERS]) {\n\t\tif (!nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\n\t\tif (IS_ERR(stats))\n\t\t\treturn PTR_ERR(stats);\n\t}\n\n\terr = -ENOMEM;\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWCHAIN,\n\t\t\t\tsizeof(struct nft_trans_chain));\n\tif (trans == NULL)\n\t\tgoto err;\n\n\tnft_trans_chain_stats(trans) = stats;\n\tnft_trans_chain_update(trans) = true;\n\n\tif (nla[NFTA_CHAIN_POLICY])\n\t\tnft_trans_chain_policy(trans) = policy;\n\telse\n\t\tnft_trans_chain_policy(trans) = -1;\n\n\tif (nla[NFTA_CHAIN_HANDLE] &&\n\t    nla[NFTA_CHAIN_NAME]) {\n\t\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\t\tstruct nft_trans *tmp;\n\t\tchar *name;\n\n\t\terr = -ENOMEM;\n\t\tname = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL_ACCOUNT);\n\t\tif (!name)\n\t\t\tgoto err;\n\n\t\terr = -EEXIST;\n\t\tlist_for_each_entry(tmp, &nft_net->commit_list, list) {\n\t\t\tif (tmp->msg_type == NFT_MSG_NEWCHAIN &&\n\t\t\t    tmp->ctx.table == table &&\n\t\t\t    nft_trans_chain_update(tmp) &&\n\t\t\t    nft_trans_chain_name(tmp) &&\n\t\t\t    strcmp(name, nft_trans_chain_name(tmp)) == 0) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\t\t\tkfree(name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tnft_trans_chain_name(trans) = name;\n\t}\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\nerr:\n\tfree_percpu(stats);\n\tkfree(trans);\n\treturn err;\n}\n\nstatic struct nft_chain *nft_chain_lookup_byid(const struct net *net,\n\t\t\t\t\t       const struct nft_table *table,\n\t\t\t\t\t       const struct nlattr *nla)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tstruct nft_chain *chain = trans->ctx.chain;\n\n\t\tif (trans->msg_type == NFT_MSG_NEWCHAIN &&\n\t\t    chain->table == table &&\n\t\t    id == nft_trans_chain_id(trans))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_newchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_chain *chain = NULL;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tu8 policy = NF_ACCEPT;\n\tstruct nft_ctx ctx;\n\tu64 handle = 0;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = NULL;\n\tattr = nla[NFTA_CHAIN_NAME];\n\n\tif (nla[NFTA_CHAIN_HANDLE]) {\n\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));\n\t\tchain = nft_chain_lookup_byhandle(table, handle, genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tattr = nla[NFTA_CHAIN_HANDLE];\n\t} else if (nla[NFTA_CHAIN_NAME]) {\n\t\tchain = nft_chain_lookup(net, table, attr, genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tif (PTR_ERR(chain) != -ENOENT) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn PTR_ERR(chain);\n\t\t\t}\n\t\t\tchain = NULL;\n\t\t}\n\t} else if (!nla[NFTA_CHAIN_ID]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_CHAIN_POLICY]) {\n\t\tif (chain != NULL &&\n\t\t    !nft_is_base_chain(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (chain == NULL &&\n\t\t    nla[NFTA_CHAIN_HOOK] == NULL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));\n\t\tswitch (policy) {\n\t\tcase NF_DROP:\n\t\tcase NF_ACCEPT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (nla[NFTA_CHAIN_FLAGS])\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_CHAIN_FLAGS]));\n\telse if (chain)\n\t\tflags = chain->flags;\n\n\tif (flags & ~NFT_CHAIN_FLAGS)\n\t\treturn -EOPNOTSUPP;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tif (chain != NULL) {\n\t\tif (chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tflags |= chain->flags & NFT_CHAIN_BASE;\n\t\treturn nf_tables_updchain(&ctx, genmask, policy, flags, attr,\n\t\t\t\t\t  extack);\n\t}\n\n\treturn nf_tables_addchain(&ctx, family, genmask, policy, flags, extack);\n}\n\nstatic int nf_tables_delchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\tstruct nft_ctx ctx;\n\tu64 handle;\n\tu32 use;\n\tint err;\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_CHAIN_HANDLE]) {\n\t\tattr = nla[NFTA_CHAIN_HANDLE];\n\t\thandle = be64_to_cpu(nla_get_be64(attr));\n\t\tchain = nft_chain_lookup_byhandle(table, handle, genmask);\n\t} else {\n\t\tattr = nla[NFTA_CHAIN_NAME];\n\t\tchain = nft_chain_lookup(net, table, attr, genmask);\n\t}\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t    chain->use > 0)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tuse = chain->use;\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(net, rule))\n\t\t\tcontinue;\n\t\tuse--;\n\n\t\terr = nft_delrule(&ctx, rule);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* There are rules and elements that are still holding references to us,\n\t * we cannot do a recursive removal in this case.\n\t */\n\tif (use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\treturn nft_delchain(&ctx);\n}\n\n/*\n * Expressions\n */\n\n/**\n *\tnft_register_expr - register nf_tables expr type\n *\t@type: expr type\n *\n *\tRegisters the expr type for use with nf_tables. Returns zero on\n *\tsuccess or a negative errno code otherwise.\n */\nint nft_register_expr(struct nft_expr_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tif (type->family == NFPROTO_UNSPEC)\n\t\tlist_add_tail_rcu(&type->list, &nf_tables_expressions);\n\telse\n\t\tlist_add_rcu(&type->list, &nf_tables_expressions);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_register_expr);\n\n/**\n *\tnft_unregister_expr - unregister nf_tables expr type\n *\t@type: expr type\n *\n * \tUnregisters the expr typefor use with nf_tables.\n */\nvoid nft_unregister_expr(struct nft_expr_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_expr);\n\nstatic const struct nft_expr_type *__nft_expr_type_get(u8 family,\n\t\t\t\t\t\t       struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type, *candidate = NULL;\n\n\tlist_for_each_entry(type, &nf_tables_expressions, list) {\n\t\tif (!nla_strcmp(nla, type->name)) {\n\t\t\tif (!type->family && !candidate)\n\t\t\t\tcandidate = type;\n\t\t\telse if (type->family == family)\n\t\t\t\tcandidate = type;\n\t\t}\n\t}\n\treturn candidate;\n}\n\n#ifdef CONFIG_MODULES\nstatic int nft_expr_type_request_module(struct net *net, u8 family,\n\t\t\t\t\tstruct nlattr *nla)\n{\n\tif (nft_request_module(net, \"nft-expr-%u-%.*s\", family,\n\t\t\t       nla_len(nla), (char *)nla_data(nla)) == -EAGAIN)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n#endif\n\nstatic const struct nft_expr_type *nft_expr_type_get(struct net *net,\n\t\t\t\t\t\t     u8 family,\n\t\t\t\t\t\t     struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttype = __nft_expr_type_get(family, nla);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_expr_type_request_module(net, family, nla) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\n\t\tif (nft_request_module(net, \"nft-expr-%.*s\",\n\t\t\t\t       nla_len(nla),\n\t\t\t\t       (char *)nla_data(nla)) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic const struct nla_policy nft_expr_policy[NFTA_EXPR_MAX + 1] = {\n\t[NFTA_EXPR_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_MODULE_AUTOLOAD_LIMIT },\n\t[NFTA_EXPR_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic int nf_tables_fill_expr_info(struct sk_buff *skb,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tif (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))\n\t\tgoto nla_put_failure;\n\n\tif (expr->ops->dump) {\n\t\tstruct nlattr *data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t    NFTA_EXPR_DATA);\n\t\tif (data == NULL)\n\t\t\tgoto nla_put_failure;\n\t\tif (expr->ops->dump(skb, expr) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, data);\n\t}\n\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -1;\n};\n\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\n\t\t  const struct nft_expr *expr)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (nf_tables_fill_expr_info(skb, expr) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstruct nft_expr_info {\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nlattr\t\t*attr;\n\tstruct nlattr\t\t\t*tb[NFT_EXPR_MAXATTR + 1];\n};\n\nstatic int nf_tables_expr_parse(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr *nla,\n\t\t\t\tstruct nft_expr_info *info)\n{\n\tconst struct nft_expr_type *type;\n\tconst struct nft_expr_ops *ops;\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\ttype = nft_expr_type_get(ctx->net, ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tif (tb[NFTA_EXPR_DATA]) {\n\t\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t\t  type->policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t} else\n\t\tmemset(info->tb, 0, sizeof(info->tb[0]) * (type->maxattr + 1));\n\n\tif (type->select_ops != NULL) {\n\t\tops = type->select_ops(ctx,\n\t\t\t\t       (const struct nlattr * const *)info->tb);\n\t\tif (IS_ERR(ops)) {\n\t\t\terr = PTR_ERR(ops);\n#ifdef CONFIG_MODULES\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tif (nft_expr_type_request_module(ctx->net,\n\t\t\t\t\t\t\t\t ctx->family,\n\t\t\t\t\t\t\t\t tb[NFTA_EXPR_NAME]) != -EAGAIN)\n\t\t\t\t\terr = -ENOENT;\n#endif\n\t\t\tgoto err1;\n\t\t}\n\t} else\n\t\tops = type->ops;\n\n\tinfo->attr = nla;\n\tinfo->ops = ops;\n\n\treturn 0;\n\nerr1:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_newexpr(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr_info *expr_info,\n\t\t\t     struct nft_expr *expr)\n{\n\tconst struct nft_expr_ops *ops = expr_info->ops;\n\tint err;\n\n\texpr->ops = ops;\n\tif (ops->init) {\n\t\terr = ops->init(ctx, expr, (const struct nlattr **)expr_info->tb);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t}\n\n\treturn 0;\nerr1:\n\texpr->ops = NULL;\n\treturn err;\n}\n\nstatic void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tconst struct nft_expr_type *type = expr->ops->type;\n\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(type->owner);\n}\n\nstatic struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nlattr *nla)\n{\n\tstruct nft_expr_info expr_info;\n\tstruct nft_expr *expr;\n\tstruct module *owner;\n\tint err;\n\n\terr = nf_tables_expr_parse(ctx, nla, &expr_info);\n\tif (err < 0)\n\t\tgoto err_expr_parse;\n\n\terr = -EOPNOTSUPP;\n\tif (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))\n\t\tgoto err_expr_stateful;\n\n\terr = -ENOMEM;\n\texpr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);\n\tif (expr == NULL)\n\t\tgoto err_expr_stateful;\n\n\terr = nf_tables_newexpr(ctx, &expr_info, expr);\n\tif (err < 0)\n\t\tgoto err_expr_new;\n\n\treturn expr;\nerr_expr_new:\n\tkfree(expr);\nerr_expr_stateful:\n\towner = expr_info.ops->type->owner;\n\tif (expr_info.ops->type->release_ops)\n\t\texpr_info.ops->type->release_ops(expr_info.ops);\n\n\tmodule_put(owner);\nerr_expr_parse:\n\treturn ERR_PTR(err);\n}\n\nint nft_expr_clone(struct nft_expr *dst, struct nft_expr *src)\n{\n\tint err;\n\n\tif (src->ops->clone) {\n\t\tdst->ops = src->ops;\n\t\terr = src->ops->clone(dst, src);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tmemcpy(dst, src, src->ops->size);\n\t}\n\n\t__module_get(src->ops->type->owner);\n\n\treturn 0;\n}\n\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr)\n{\n\tnf_tables_expr_destroy(ctx, expr);\n\tkfree(expr);\n}\n\n/*\n * Rules\n */\n\nstatic struct nft_rule *__nft_rule_lookup(const struct nft_chain *chain,\n\t\t\t\t\t  u64 handle)\n{\n\tstruct nft_rule *rule;\n\n\t// FIXME: this sucks\n\tlist_for_each_entry_rcu(rule, &chain->rules, list) {\n\t\tif (handle == rule->handle)\n\t\t\treturn rule;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_rule *nft_rule_lookup(const struct nft_chain *chain,\n\t\t\t\t\tconst struct nlattr *nla)\n{\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __nft_rule_lookup(chain, be64_to_cpu(nla_get_be64(nla)));\n}\n\nstatic const struct nla_policy nft_rule_policy[NFTA_RULE_MAX + 1] = {\n\t[NFTA_RULE_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_RULE_CHAIN]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_RULE_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_RULE_EXPRESSIONS]\t= { .type = NLA_NESTED },\n\t[NFTA_RULE_COMPAT]\t= { .type = NLA_NESTED },\n\t[NFTA_RULE_POSITION]\t= { .type = NLA_U64 },\n\t[NFTA_RULE_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n\t[NFTA_RULE_ID]\t\t= { .type = NLA_U32 },\n\t[NFTA_RULE_POSITION_ID]\t= { .type = NLA_U32 },\n\t[NFTA_RULE_CHAIN_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nf_tables_fill_rule_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t    u32 portid, u32 seq, int event,\n\t\t\t\t    u32 flags, int family,\n\t\t\t\t    const struct nft_table *table,\n\t\t\t\t    const struct nft_chain *chain,\n\t\t\t\t    const struct nft_rule *rule, u64 handle)\n{\n\tstruct nlmsghdr *nlh;\n\tconst struct nft_expr *expr, *next;\n\tstruct nlattr *list;\n\tu16 type = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\n\tnlh = nfnl_msg_put(skb, portid, seq, type, flags, family, NFNETLINK_V0,\n\t\t\t   nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_RULE_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_RULE_CHAIN, chain->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_RULE_HANDLE, cpu_to_be64(rule->handle),\n\t\t\t NFTA_RULE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (event != NFT_MSG_DELRULE && handle) {\n\t\tif (nla_put_be64(skb, NFTA_RULE_POSITION, cpu_to_be64(handle),\n\t\t\t\t NFTA_RULE_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\tnft_flow_rule_stats(chain, rule);\n\n\tlist = nla_nest_start_noflag(skb, NFTA_RULE_EXPRESSIONS);\n\tif (list == NULL)\n\t\tgoto nla_put_failure;\n\tnft_rule_for_each_expr(expr, next, rule) {\n\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, list);\n\n\tif (rule->udata) {\n\t\tstruct nft_userdata *udata = nft_userdata(rule);\n\t\tif (nla_put(skb, NFTA_RULE_USERDATA, udata->len + 1,\n\t\t\t    udata->data) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_rule_notify(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_rule *rule, int event)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nft_rule *prule;\n\tstruct sk_buff *skb;\n\tu64 handle = 0;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (event == NFT_MSG_NEWRULE &&\n\t    !list_is_first(&rule->list, &ctx->chain->rules) &&\n\t    !list_is_last(&rule->list, &ctx->chain->rules)) {\n\t\tprule = list_prev_entry(rule, list);\n\t\thandle = prule->handle;\n\t}\n\tif (ctx->flags & (NLM_F_APPEND | NLM_F_REPLACE))\n\t\tflags |= NLM_F_APPEND;\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_rule_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t       event, flags, ctx->family, ctx->table,\n\t\t\t\t       ctx->chain, rule, handle);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstruct nft_rule_dump_ctx {\n\tchar *table;\n\tchar *chain;\n};\n\nstatic int __nf_tables_dump_rules(struct sk_buff *skb,\n\t\t\t\t  unsigned int *idx,\n\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nft_chain *chain)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nft_rule *rule, *prule;\n\tunsigned int s_idx = cb->args[0];\n\tu64 handle;\n\n\tprule = NULL;\n\tlist_for_each_entry_rcu(rule, &chain->rules, list) {\n\t\tif (!nft_is_active(net, rule))\n\t\t\tgoto cont_skip;\n\t\tif (*idx < s_idx)\n\t\t\tgoto cont;\n\t\tif (*idx > s_idx) {\n\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t\tsizeof(cb->args) - sizeof(cb->args[0]));\n\t\t}\n\t\tif (prule)\n\t\t\thandle = prule->handle;\n\t\telse\n\t\t\thandle = 0;\n\n\t\tif (nf_tables_fill_rule_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq,\n\t\t\t\t\tNFT_MSG_NEWRULE,\n\t\t\t\t\tNLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\ttable->family,\n\t\t\t\t\ttable, chain, rule, handle) < 0)\n\t\t\treturn 1;\n\n\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\tprule = rule;\ncont_skip:\n\t\t(*idx)++;\n\t}\n\treturn 0;\n}\n\nstatic int nf_tables_dump_rules(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tconst struct nft_rule_dump_ctx *ctx = cb->data;\n\tstruct nft_table *table;\n\tconst struct nft_chain *chain;\n\tunsigned int idx = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tif (ctx && ctx->table && strcmp(ctx->table, table->name) != 0)\n\t\t\tcontinue;\n\n\t\tif (ctx && ctx->table && ctx->chain) {\n\t\t\tstruct rhlist_head *list, *tmp;\n\n\t\t\tlist = rhltable_lookup(&table->chains_ht, ctx->chain,\n\t\t\t\t\t       nft_chain_ht_params);\n\t\t\tif (!list)\n\t\t\t\tgoto done;\n\n\t\t\trhl_for_each_entry_rcu(chain, tmp, list, rhlhead) {\n\t\t\t\tif (!nft_is_active(net, chain))\n\t\t\t\t\tcontinue;\n\t\t\t\t__nf_tables_dump_rules(skb, &idx,\n\t\t\t\t\t\t       cb, table, chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(chain, &table->chains, list) {\n\t\t\tif (__nf_tables_dump_rules(skb, &idx, cb, table, chain))\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctx && ctx->table)\n\t\t\tbreak;\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_rules_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_rule_dump_ctx *ctx = NULL;\n\n\tif (nla[NFTA_RULE_TABLE] || nla[NFTA_RULE_CHAIN]) {\n\t\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla[NFTA_RULE_TABLE]) {\n\t\t\tctx->table = nla_strdup(nla[NFTA_RULE_TABLE],\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!ctx->table) {\n\t\t\t\tkfree(ctx);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tif (nla[NFTA_RULE_CHAIN]) {\n\t\t\tctx->chain = nla_strdup(nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!ctx->chain) {\n\t\t\t\tkfree(ctx->table);\n\t\t\t\tkfree(ctx);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tcb->data = ctx;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_rules_done(struct netlink_callback *cb)\n{\n\tstruct nft_rule_dump_ctx *ctx = cb->data;\n\n\tif (ctx) {\n\t\tkfree(ctx->table);\n\t\tkfree(ctx->chain);\n\t\tkfree(ctx);\n\t}\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_chain *chain;\n\tconst struct nft_rule *rule;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start= nf_tables_dump_rules_start,\n\t\t\t.dump = nf_tables_dump_rules,\n\t\t\t.done = nf_tables_dump_rules_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\trule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\n\tif (IS_ERR(rule)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\treturn PTR_ERR(rule);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t       info->nlh->nlmsg_seq, NFT_MSG_NEWRULE, 0,\n\t\t\t\t       family, table, chain, rule, 0);\n\tif (err < 0)\n\t\tgoto err_fill_rule_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_rule_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nf_tables_rule_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_rule *rule)\n{\n\tstruct nft_expr *expr, *next;\n\n\t/*\n\t * Careful: some expressions might not be initialized in case this\n\t * is called on error from nf_tables_newrule().\n\t */\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tnext = nft_expr_next(expr);\n\t\tnf_tables_expr_destroy(ctx, expr);\n\t\texpr = next;\n\t}\n\tkfree(rule);\n}\n\nvoid nf_tables_rule_release(const struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tnft_rule_expr_deactivate(ctx, rule, NFT_TRANS_RELEASE);\n\tnf_tables_rule_destroy(ctx, rule);\n}\n\nint nft_chain_validate(const struct nft_ctx *ctx, const struct nft_chain *chain)\n{\n\tstruct nft_expr *expr, *last;\n\tconst struct nft_data *data;\n\tstruct nft_rule *rule;\n\tint err;\n\n\tif (ctx->level == NFT_JUMP_STACK_SIZE)\n\t\treturn -EMLINK;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(ctx->net, rule))\n\t\t\tcontinue;\n\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\tif (!expr->ops->validate)\n\t\t\t\tcontinue;\n\n\t\t\terr = expr->ops->validate(ctx, expr, &data);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate);\n\nstatic int nft_table_validate(struct net *net, const struct nft_table *table)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_ctx ctx = {\n\t\t.net\t= net,\n\t\t.family\t= table->family,\n\t};\n\tint err;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\tctx.chain = chain;\n\t\terr = nft_chain_validate(&ctx, chain);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nft_rule *nft_rule_lookup_byid(const struct net *net,\n\t\t\t\t\t     const struct nft_chain *chain,\n\t\t\t\t\t     const struct nlattr *nla);\n\n#define NFT_RULE_MAXEXPRS\t128\n\nstatic int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tunsigned int size, i, n, ulen = 0, usize = 0;\n\tu8 genmask = nft_genmask_next(info->net);\n\tstruct nft_rule *rule, *old_rule = NULL;\n\tstruct nft_expr_info *expr_info = NULL;\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flow_rule *flow = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_userdata *udata;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain;\n\tstruct nft_trans *trans;\n\tu64 handle, pos_handle;\n\tstruct nft_expr *expr;\n\tstruct nft_ctx ctx;\n\tstruct nlattr *tmp;\n\tint err, rem;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EOPNOTSUPP;\n\n\t} else if (nla[NFTA_RULE_CHAIN_ID]) {\n\t\tchain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID]);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_RULE_HANDLE]) {\n\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));\n\t\trule = __nft_rule_lookup(chain, handle);\n\t\tif (IS_ERR(rule)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn PTR_ERR(rule);\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\told_rule = rule;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE) ||\n\t\t    info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EINVAL;\n\t\thandle = nf_tables_alloc_handle(table);\n\n\t\tif (chain->use == UINT_MAX)\n\t\t\treturn -EOVERFLOW;\n\n\t\tif (nla[NFTA_RULE_POSITION]) {\n\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));\n\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t} else if (nla[NFTA_RULE_POSITION_ID]) {\n\t\t\told_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t}\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tn = 0;\n\tsize = 0;\n\tif (nla[NFTA_RULE_EXPRESSIONS]) {\n\t\texpr_info = kvmalloc_array(NFT_RULE_MAXEXPRS,\n\t\t\t\t\t   sizeof(struct nft_expr_info),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!expr_info)\n\t\t\treturn -ENOMEM;\n\n\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {\n\t\t\terr = -EINVAL;\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)\n\t\t\t\tgoto err_release_expr;\n\t\t\tif (n == NFT_RULE_MAXEXPRS)\n\t\t\t\tgoto err_release_expr;\n\t\t\terr = nf_tables_expr_parse(&ctx, tmp, &expr_info[n]);\n\t\t\tif (err < 0) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, tmp);\n\t\t\t\tgoto err_release_expr;\n\t\t\t}\n\t\t\tsize += expr_info[n].ops->size;\n\t\t\tn++;\n\t\t}\n\t}\n\t/* Check for overflow of dlen field */\n\terr = -EFBIG;\n\tif (size >= 1 << 12)\n\t\tgoto err_release_expr;\n\n\tif (nla[NFTA_RULE_USERDATA]) {\n\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);\n\t\tif (ulen > 0)\n\t\t\tusize = sizeof(struct nft_userdata) + ulen;\n\t}\n\n\terr = -ENOMEM;\n\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL_ACCOUNT);\n\tif (rule == NULL)\n\t\tgoto err_release_expr;\n\n\tnft_activate_next(net, rule);\n\n\trule->handle = handle;\n\trule->dlen   = size;\n\trule->udata  = ulen ? 1 : 0;\n\n\tif (ulen) {\n\t\tudata = nft_userdata(rule);\n\t\tudata->len = ulen - 1;\n\t\tnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);\n\t}\n\n\texpr = nft_expr_first(rule);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nf_tables_newexpr(&ctx, &expr_info[i], expr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, expr_info[i].attr);\n\t\t\tgoto err_release_rule;\n\t\t}\n\n\t\tif (expr_info[i].ops->validate)\n\t\t\tnft_validate_state_update(net, NFT_VALIDATE_NEED);\n\n\t\texpr_info[i].ops = NULL;\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD) {\n\t\tflow = nft_flow_rule_create(net, rule);\n\t\tif (IS_ERR(flow)) {\n\t\t\terr = PTR_ERR(flow);\n\t\t\tgoto err_release_rule;\n\t\t}\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE) {\n\t\terr = nft_delrule(&ctx, old_rule);\n\t\tif (err < 0)\n\t\t\tgoto err_destroy_flow_rule;\n\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (trans == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t} else {\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (!trans) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_APPEND) {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_tail_rcu(&rule->list, &chain->rules);\n\t\t } else {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_rcu(&rule->list, &chain->rules);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\tchain->use++;\n\n\tif (flow)\n\t\tnft_trans_flow_rule(trans) = flow;\n\n\tif (nft_net->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\n\treturn 0;\n\nerr_destroy_flow_rule:\n\tif (flow)\n\t\tnft_flow_rule_destroy(flow);\nerr_release_rule:\n\tnf_tables_rule_release(&ctx, rule);\nerr_release_expr:\n\tfor (i = 0; i < n; i++) {\n\t\tif (expr_info[i].ops) {\n\t\t\tmodule_put(expr_info[i].ops->type->owner);\n\t\t\tif (expr_info[i].ops->type->release_ops)\n\t\t\t\texpr_info[i].ops->type->release_ops(expr_info[i].ops);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\n\treturn err;\n}\n\nstatic struct nft_rule *nft_rule_lookup_byid(const struct net *net,\n\t\t\t\t\t     const struct nft_chain *chain,\n\t\t\t\t\t     const struct nlattr *nla)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tstruct nft_rule *rule = nft_trans_rule(trans);\n\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE &&\n\t\t    trans->ctx.chain == chain &&\n\t\t    id == nft_trans_rule_id(trans))\n\t\t\treturn rule;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_chain *chain = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_rule *rule;\n\tstruct nft_ctx ctx;\n\tint err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tif (chain) {\n\t\tif (nla[NFTA_RULE_HANDLE]) {\n\t\t\trule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\n\t\t\tif (IS_ERR(rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\t\treturn PTR_ERR(rule);\n\t\t\t}\n\n\t\t\terr = nft_delrule(&ctx, rule);\n\t\t} else if (nla[NFTA_RULE_ID]) {\n\t\t\trule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);\n\t\t\tif (IS_ERR(rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);\n\t\t\t\treturn PTR_ERR(rule);\n\t\t\t}\n\n\t\t\terr = nft_delrule(&ctx, rule);\n\t\t} else {\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(chain, &table->chains, list) {\n\t\t\tif (!nft_is_active_next(net, chain))\n\t\t\t\tcontinue;\n\n\t\t\tctx.chain = chain;\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n/*\n * Sets\n */\nstatic const struct nft_set_type *nft_set_types[] = {\n\t&nft_set_hash_fast_type,\n\t&nft_set_hash_type,\n\t&nft_set_rhash_type,\n\t&nft_set_bitmap_type,\n\t&nft_set_rbtree_type,\n#if defined(CONFIG_X86_64) && !defined(CONFIG_UML)\n\t&nft_set_pipapo_avx2_type,\n#endif\n\t&nft_set_pipapo_type,\n};\n\n#define NFT_SET_FEATURES\t(NFT_SET_INTERVAL | NFT_SET_MAP | \\\n\t\t\t\t NFT_SET_TIMEOUT | NFT_SET_OBJECT | \\\n\t\t\t\t NFT_SET_EVAL)\n\nstatic bool nft_set_ops_candidate(const struct nft_set_type *type, u32 flags)\n{\n\treturn (flags & type->features) == (flags & NFT_SET_FEATURES);\n}\n\n/*\n * Select a set implementation based on the data characteristics and the\n * given policy. The total memory use might not be known if no size is\n * given, in that case the amount of memory per element is used.\n */\nstatic const struct nft_set_ops *\nnft_select_set_ops(const struct nft_ctx *ctx,\n\t\t   const struct nlattr * const nla[],\n\t\t   const struct nft_set_desc *desc,\n\t\t   enum nft_set_policies policy)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nft_set_ops *ops, *bops;\n\tstruct nft_set_estimate est, best;\n\tconst struct nft_set_type *type;\n\tu32 flags = 0;\n\tint i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tlockdep_nfnl_nft_mutex_not_held();\n\n\tif (nla[NFTA_SET_FLAGS] != NULL)\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\n\tbops\t    = NULL;\n\tbest.size   = ~0;\n\tbest.lookup = ~0;\n\tbest.space  = ~0;\n\n\tfor (i = 0; i < ARRAY_SIZE(nft_set_types); i++) {\n\t\ttype = nft_set_types[i];\n\t\tops = &type->ops;\n\n\t\tif (!nft_set_ops_candidate(type, flags))\n\t\t\tcontinue;\n\t\tif (!ops->estimate(desc, flags, &est))\n\t\t\tcontinue;\n\n\t\tswitch (policy) {\n\t\tcase NFT_SET_POL_PERFORMANCE:\n\t\t\tif (est.lookup < best.lookup)\n\t\t\t\tbreak;\n\t\t\tif (est.lookup == best.lookup &&\n\t\t\t    est.space < best.space)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase NFT_SET_POL_MEMORY:\n\t\t\tif (!desc->size) {\n\t\t\t\tif (est.space < best.space)\n\t\t\t\t\tbreak;\n\t\t\t\tif (est.space == best.space &&\n\t\t\t\t    est.lookup < best.lookup)\n\t\t\t\t\tbreak;\n\t\t\t} else if (est.size < best.size || !bops) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbops = ops;\n\t\tbest = est;\n\t}\n\n\tif (bops != NULL)\n\t\treturn bops;\n\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic const struct nla_policy nft_set_policy[NFTA_SET_MAX + 1] = {\n\t[NFTA_SET_TABLE]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_SET_NAME]\t\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_SET_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_KEY_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_KEY_LEN]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DATA_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DATA_LEN]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_POLICY]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DESC]\t\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ID]\t\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_TIMEOUT]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_GC_INTERVAL]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_USERDATA]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len  = NFT_USERDATA_MAXLEN },\n\t[NFTA_SET_OBJ_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_HANDLE]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_EXPR]\t\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_EXPRESSIONS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy nft_set_desc_policy[NFTA_SET_DESC_MAX + 1] = {\n\t[NFTA_SET_DESC_SIZE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DESC_CONCAT]\t\t= { .type = NLA_NESTED },\n};\n\nstatic struct nft_set *nft_set_lookup(const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla, u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\tif (!nla_strcmp(nla, set->name) &&\n\t\t    nft_active_genmask(set, genmask))\n\t\t\treturn set;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_set *nft_set_lookup_byhandle(const struct nft_table *table,\n\t\t\t\t\t       const struct nlattr *nla,\n\t\t\t\t\t       u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tlist_for_each_entry(set, &table->sets, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == set->handle &&\n\t\t    nft_active_genmask(set, genmask))\n\t\t\treturn set;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_set *nft_set_lookup_byid(const struct net *net,\n\t\t\t\t\t   const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla, u8 genmask)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tif (trans->msg_type == NFT_MSG_NEWSET) {\n\t\t\tstruct nft_set *set = nft_trans_set(trans);\n\n\t\t\tif (id == nft_trans_set_id(trans) &&\n\t\t\t    set->table == table &&\n\t\t\t    nft_active_genmask(set, genmask))\n\t\t\t\treturn set;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstruct nft_set *nft_set_lookup_global(const struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla_set_name,\n\t\t\t\t      const struct nlattr *nla_set_id,\n\t\t\t\t      u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tset = nft_set_lookup(table, nla_set_name, genmask);\n\tif (IS_ERR(set)) {\n\t\tif (!nla_set_id)\n\t\t\treturn set;\n\n\t\tset = nft_set_lookup_byid(net, table, nla_set_id, genmask);\n\t}\n\treturn set;\n}\nEXPORT_SYMBOL_GPL(nft_set_lookup_global);\n\nstatic int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\n\tp = strchr(name, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\n\t\t\tif (!nft_is_active_next(ctx->net, i))\n\t\t\t\tcontinue;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\n\tset->name = kasprintf(GFP_KERNEL_ACCOUNT, name, min + n);\n\tif (!set->name)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, i))\n\t\t\tcontinue;\n\t\tif (!strcmp(set->name, i->name)) {\n\t\t\tkfree(set->name);\n\t\t\tset->name = NULL;\n\t\t\treturn -ENFILE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nf_msecs_to_jiffies64(const struct nlattr *nla, u64 *result)\n{\n\tu64 ms = be64_to_cpu(nla_get_be64(nla));\n\tu64 max = (u64)(~((u64)0));\n\n\tmax = div_u64(max, NSEC_PER_MSEC);\n\tif (ms >= max)\n\t\treturn -ERANGE;\n\n\tms *= NSEC_PER_MSEC;\n\t*result = nsecs_to_jiffies64(ms);\n\treturn 0;\n}\n\n__be64 nf_jiffies64_to_msecs(u64 input)\n{\n\treturn cpu_to_be64(jiffies64_to_msecs(input));\n}\n\nstatic int nf_tables_fill_set_concat(struct sk_buff *skb,\n\t\t\t\t     const struct nft_set *set)\n{\n\tstruct nlattr *concat, *field;\n\tint i;\n\n\tconcat = nla_nest_start_noflag(skb, NFTA_SET_DESC_CONCAT);\n\tif (!concat)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < set->field_count; i++) {\n\t\tfield = nla_nest_start_noflag(skb, NFTA_LIST_ELEM);\n\t\tif (!field)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla_put_be32(skb, NFTA_SET_FIELD_LEN,\n\t\t\t\t htonl(set->field_len[i])))\n\t\t\treturn -ENOMEM;\n\n\t\tnla_nest_end(skb, field);\n\t}\n\n\tnla_nest_end(skb, concat);\n\n\treturn 0;\n}\n\nstatic int nf_tables_fill_set(struct sk_buff *skb, const struct nft_ctx *ctx,\n\t\t\t      const struct nft_set *set, u16 event, u16 flags)\n{\n\tstruct nlmsghdr *nlh;\n\tu32 portid = ctx->portid;\n\tstruct nlattr *nest;\n\tu32 seq = ctx->seq;\n\tint i;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, ctx->family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(ctx->net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_NAME, set->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_SET_HANDLE, cpu_to_be64(set->handle),\n\t\t\t NFTA_SET_PAD))\n\t\tgoto nla_put_failure;\n\tif (set->flags != 0)\n\t\tif (nla_put_be32(skb, NFTA_SET_FLAGS, htonl(set->flags)))\n\t\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_SET_KEY_TYPE, htonl(set->ktype)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_SET_KEY_LEN, htonl(set->klen)))\n\t\tgoto nla_put_failure;\n\tif (set->flags & NFT_SET_MAP) {\n\t\tif (nla_put_be32(skb, NFTA_SET_DATA_TYPE, htonl(set->dtype)))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_be32(skb, NFTA_SET_DATA_LEN, htonl(set->dlen)))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (set->flags & NFT_SET_OBJECT &&\n\t    nla_put_be32(skb, NFTA_SET_OBJ_TYPE, htonl(set->objtype)))\n\t\tgoto nla_put_failure;\n\n\tif (set->timeout &&\n\t    nla_put_be64(skb, NFTA_SET_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(set->timeout),\n\t\t\t NFTA_SET_PAD))\n\t\tgoto nla_put_failure;\n\tif (set->gc_int &&\n\t    nla_put_be32(skb, NFTA_SET_GC_INTERVAL, htonl(set->gc_int)))\n\t\tgoto nla_put_failure;\n\n\tif (set->policy != NFT_SET_POL_PERFORMANCE) {\n\t\tif (nla_put_be32(skb, NFTA_SET_POLICY, htonl(set->policy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (set->udata &&\n\t    nla_put(skb, NFTA_SET_USERDATA, set->udlen, set->udata))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_DESC);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (set->size &&\n\t    nla_put_be32(skb, NFTA_SET_DESC_SIZE, htonl(set->size)))\n\t\tgoto nla_put_failure;\n\n\tif (set->field_count > 1 &&\n\t    nf_tables_fill_set_concat(skb, set))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (set->num_exprs == 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_EXPR);\n\t\tif (nf_tables_fill_expr_info(skb, set->exprs[0]) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, nest);\n\t} else if (set->num_exprs > 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_EXPRESSIONS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < set->num_exprs; i++) {\n\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM,\n\t\t\t\t\t  set->exprs[i]) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_set *set, int event,\n\t\t\t         gfp_t gfp_flags)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tu32 portid = ctx->portid;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_set(skb, ctx, set, event, flags);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_sets(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nft_set *set;\n\tunsigned int idx, s_idx = cb->args[0];\n\tstruct nft_table *table, *cur_table = (struct nft_table *)cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nft_ctx *ctx = cb->data, ctx_set;\n\tstruct nftables_pernet *nft_net;\n\n\tif (cb->args[1])\n\t\treturn skb->len;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (ctx->family != NFPROTO_UNSPEC &&\n\t\t    ctx->family != table->family)\n\t\t\tcontinue;\n\n\t\tif (ctx->table && ctx->table != table)\n\t\t\tcontinue;\n\n\t\tif (cur_table) {\n\t\t\tif (cur_table != table)\n\t\t\t\tcontinue;\n\n\t\t\tcur_table = NULL;\n\t\t}\n\t\tidx = 0;\n\t\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (!nft_is_active(net, set))\n\t\t\t\tgoto cont;\n\n\t\t\tctx_set = *ctx;\n\t\t\tctx_set.table = table;\n\t\t\tctx_set.family = table->family;\n\n\t\t\tif (nf_tables_fill_set(skb, &ctx_set, set,\n\t\t\t\t\t       NFT_MSG_NEWSET,\n\t\t\t\t\t       NLM_F_MULTI) < 0) {\n\t\t\t\tcb->args[0] = idx;\n\t\t\t\tcb->args[2] = (unsigned long) table;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\tif (s_idx)\n\t\t\ts_idx = 0;\n\t}\n\tcb->args[1] = 1;\ndone:\n\trcu_read_unlock();\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_sets_start(struct netlink_callback *cb)\n{\n\tstruct nft_ctx *ctx_dump = NULL;\n\n\tctx_dump = kmemdup(cb->data, sizeof(*ctx_dump), GFP_ATOMIC);\n\tif (ctx_dump == NULL)\n\t\treturn -ENOMEM;\n\n\tcb->data = ctx_dump;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_sets_done(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_table *table = NULL;\n\tstruct net *net = info->net;\n\tconst struct nft_set *set;\n\tstruct sk_buff *skb2;\n\tstruct nft_ctx ctx;\n\tint err;\n\n\tif (nla[NFTA_SET_TABLE]) {\n\t\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family,\n\t\t\t\t\t genmask, 0);\n\t\tif (IS_ERR(table)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\t\treturn PTR_ERR(table);\n\t\t}\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_sets_start,\n\t\t\t.dump = nf_tables_dump_sets,\n\t\t\t.done = nf_tables_dump_sets_done,\n\t\t\t.data = &ctx,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\t/* Only accept unspec with dump */\n\tif (info->nfmsg->nfgen_family == NFPROTO_UNSPEC)\n\t\treturn -EAFNOSUPPORT;\n\tif (!nla[NFTA_SET_TABLE])\n\t\treturn -EINVAL;\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_set(skb2, &ctx, set, NFT_MSG_NEWSET, 0);\n\tif (err < 0)\n\t\tgoto err_fill_set_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_set_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nla_policy nft_concat_policy[NFTA_SET_FIELD_MAX + 1] = {\n\t[NFTA_SET_FIELD_LEN]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\n\tif (desc->field_count >= ARRAY_SIZE(desc->field_len))\n\t\treturn -E2BIG;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (!len || len > U8_MAX)\n\t\treturn -EINVAL;\n\n\tdesc->field_len[desc->field_count++] = len;\n\n\treturn 0;\n}\n\nstatic int nft_set_desc_concat(struct nft_set_desc *desc,\n\t\t\t       const struct nlattr *nla)\n{\n\tstruct nlattr *attr;\n\tu32 num_regs = 0;\n\tint rem, err, i;\n\n\tnla_for_each_nested(attr, nla, rem) {\n\t\tif (nla_type(attr) != NFTA_LIST_ELEM)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_set_desc_concat_parse(attr, desc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < desc->field_count; i++)\n\t\tnum_regs += DIV_ROUND_UP(desc->field_len[i], sizeof(u32));\n\n\tif (num_regs > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}\n\nstatic int nf_tables_set_desc_parse(struct nft_set_desc *desc,\n\t\t\t\t    const struct nlattr *nla)\n{\n\tstruct nlattr *da[NFTA_SET_DESC_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(da, NFTA_SET_DESC_MAX, nla,\n\t\t\t\t\t  nft_set_desc_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (da[NFTA_SET_DESC_SIZE] != NULL)\n\t\tdesc->size = ntohl(nla_get_be32(da[NFTA_SET_DESC_SIZE]));\n\tif (da[NFTA_SET_DESC_CONCAT])\n\t\terr = nft_set_desc_concat(desc, da[NFTA_SET_DESC_CONCAT]);\n\n\treturn err;\n}\n\nstatic int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tu32 ktype, dtype, flags, policy, gc_int, objtype;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_set_ops *ops;\n\tstruct nft_expr *expr = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_set_desc desc;\n\tstruct nft_table *table;\n\tunsigned char *udata;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tsize_t alloc_size;\n\tu64 timeout;\n\tchar *name;\n\tint err, i;\n\tu16 udlen;\n\tu64 size;\n\n\tif (nla[NFTA_SET_TABLE] == NULL ||\n\t    nla[NFTA_SET_NAME] == NULL ||\n\t    nla[NFTA_SET_KEY_LEN] == NULL ||\n\t    nla[NFTA_SET_ID] == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(&desc, 0, sizeof(desc));\n\n\tktype = NFT_DATA_VALUE;\n\tif (nla[NFTA_SET_KEY_TYPE] != NULL) {\n\t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\n\t\tif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n\tif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\n\t\treturn -EINVAL;\n\n\tflags = 0;\n\tif (nla[NFTA_SET_FLAGS] != NULL) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\t\tif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\n\t\t\t      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |\n\t\t\t      NFT_SET_MAP | NFT_SET_EVAL |\n\t\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* Only one of these operations is supported */\n\t\tif ((flags & (NFT_SET_MAP | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_MAP | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((flags & (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_EVAL | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdtype = 0;\n\tif (nla[NFTA_SET_DATA_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_MAP))\n\t\t\treturn -EINVAL;\n\n\t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\n\t\tif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\n\t\t    dtype != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (dtype != NFT_DATA_VERDICT) {\n\t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\n\t\t\tif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tdesc.dlen = sizeof(struct nft_verdict);\n\t} else if (flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_OBJ_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_OBJECT))\n\t\t\treturn -EINVAL;\n\n\t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\n\t\tif (objtype == NFT_OBJECT_UNSPEC ||\n\t\t    objtype > NFT_OBJECT_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (flags & NFT_SET_OBJECT)\n\t\treturn -EINVAL;\n\telse\n\t\tobjtype = NFT_OBJECT_UNSPEC;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_TIMEOUT] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tgc_int = 0;\n\tif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\n\t}\n\n\tpolicy = NFT_SET_POL_PERFORMANCE;\n\tif (nla[NFTA_SET_POLICY] != NULL)\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\n\n\tif (nla[NFTA_SET_DESC] != NULL) {\n\t\terr = nf_tables_set_desc_parse(&desc, nla[NFTA_SET_DESC]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (desc.field_count > 1 && !(flags & NFT_SET_CONCAT))\n\t\t\treturn -EINVAL;\n\t} else if (flags & NFT_SET_CONCAT) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\n\t\tdesc.expr = true;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set)) {\n\t\tif (PTR_ERR(set) != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn PTR_ERR(set);\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\treturn -ENOENT;\n\n\tops = nft_select_set_ops(&ctx, nla, &desc, policy);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tudlen = 0;\n\tif (nla[NFTA_SET_USERDATA])\n\t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\n\n\tsize = 0;\n\tif (ops->privsize != NULL)\n\t\tsize = ops->privsize(nla, &desc);\n\talloc_size = sizeof(*set) + size + udlen;\n\tif (alloc_size < size || alloc_size > INT_MAX)\n\t\treturn -ENOMEM;\n\tset = kvzalloc(alloc_size, GFP_KERNEL_ACCOUNT);\n\tif (!set)\n\t\treturn -ENOMEM;\n\n\tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_set_name;\n\t}\n\n\terr = nf_tables_set_alloc_name(&ctx, set, name);\n\tkfree(name);\n\tif (err < 0)\n\t\tgoto err_set_name;\n\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops = ops;\n\tset->ktype = ktype;\n\tset->klen = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen = desc.dlen;\n\tset->flags = flags;\n\tset->size = desc.size;\n\tset->policy = policy;\n\tset->udlen = udlen;\n\tset->udata = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n\n\tif (nla[NFTA_SET_EXPR]) {\n\t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n\t\tif (IS_ERR(expr)) {\n\t\t\terr = PTR_ERR(expr);\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\tset->exprs[0] = expr;\n\t\tset->num_exprs++;\n\t} else if (nla[NFTA_SET_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!(flags & NFT_SET_EXPR)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tset->exprs[i++] = expr;\n\t\t\tset->num_exprs++;\n\t\t}\n\t}\n\n\tset->handle = nf_tables_alloc_handle(table);\n\n\terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n\tif (err < 0)\n\t\tgoto err_set_expr_alloc;\n\n\tlist_add_tail_rcu(&set->list, &table->sets);\n\ttable->use++;\n\treturn 0;\n\nerr_set_expr_alloc:\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n\n\tops->destroy(set);\nerr_set_init:\n\tkfree(set->name);\nerr_set_name:\n\tkvfree(set);\n\treturn err;\n}\n\nstruct nft_set_elem_catchall {\n\tstruct list_head\tlist;\n\tstruct rcu_head\t\trcu;\n\tvoid\t\t\t*elem;\n};\n\nstatic void nft_set_catchall_destroy(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *next, *catchall;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\tlist_del_rcu(&catchall->list);\n\t\tnft_set_elem_destroy(set, catchall->elem, true);\n\t\tkfree_rcu(catchall, rcu);\n\t}\n}\n\nstatic void nft_set_destroy(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tint i;\n\n\tif (WARN_ON(set->use > 0))\n\t\treturn;\n\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, set->exprs[i]);\n\n\tset->ops->destroy(set);\n\tnft_set_catchall_destroy(ctx, set);\n\tkfree(set->name);\n\tkvfree(set);\n}\n\nstatic int nf_tables_delset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\n\tif (info->nfmsg->nfgen_family == NFPROTO_UNSPEC)\n\t\treturn -EAFNOSUPPORT;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_SET_HANDLE]) {\n\t\tattr = nla[NFTA_SET_HANDLE];\n\t\tset = nft_set_lookup_byhandle(table, attr, genmask);\n\t} else {\n\t\tattr = nla[NFTA_SET_NAME];\n\t\tset = nft_set_lookup(table, attr, genmask);\n\t}\n\n\tif (IS_ERR(set)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(set);\n\t}\n\tif (set->use ||\n\t    (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t     atomic_read(&set->nelems) > 0)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\treturn nft_delset(&ctx, set);\n}\n\nstatic int nft_validate_register_store(const struct nft_ctx *ctx,\n\t\t\t\t       enum nft_registers reg,\n\t\t\t\t       const struct nft_data *data,\n\t\t\t\t       enum nft_data_types type,\n\t\t\t\t       unsigned int len);\n\nstatic int nft_setelem_data_validate(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_set *set,\n\t\t\t\t     struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\tenum nft_registers dreg;\n\n\tdreg = nft_type_to_reg(set->dtype);\n\treturn nft_validate_register_store(ctx, dreg, nft_set_ext_data(ext),\n\t\t\t\t\t   set->dtype == NFT_DATA_VERDICT ?\n\t\t\t\t\t   NFT_DATA_VERDICT : NFT_DATA_VALUE,\n\t\t\t\t\t   set->dlen);\n}\n\nstatic int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\tconst struct nft_set_iter *iter,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\treturn nft_setelem_data_validate(ctx, set, elem);\n}\n\nstatic int nft_set_catchall_bind_check(const struct nft_ctx *ctx,\n\t\t\t\t       struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = nft_setelem_data_validate(ctx, set, &elem);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t       struct nft_set_binding *binding)\n{\n\tstruct nft_set_binding *i;\n\tstruct nft_set_iter iter;\n\n\tif (set->use == UINT_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (!list_empty(&set->bindings) && nft_set_is_anonymous(set))\n\t\treturn -EBUSY;\n\n\tif (binding->flags & NFT_SET_MAP) {\n\t\t/* If the set is already bound to the same chain all\n\t\t * jumps are already validated for that chain.\n\t\t */\n\t\tlist_for_each_entry(i, &set->bindings, list) {\n\t\t\tif (i->flags & NFT_SET_MAP &&\n\t\t\t    i->chain == binding->chain)\n\t\t\t\tgoto bind;\n\t\t}\n\n\t\titer.genmask\t= nft_genmask_next(ctx->net);\n\t\titer.skip \t= 0;\n\t\titer.count\t= 0;\n\t\titer.err\t= 0;\n\t\titer.fn\t\t= nf_tables_bind_check_setelem;\n\n\t\tset->ops->walk(ctx, set, &iter);\n\t\tif (!iter.err)\n\t\t\titer.err = nft_set_catchall_bind_check(ctx, set);\n\n\t\tif (iter.err < 0)\n\t\t\treturn iter.err;\n\t}\nbind:\n\tbinding->chain = ctx->chain;\n\tlist_add_tail_rcu(&binding->list, &set->bindings);\n\tnft_set_trans_bind(ctx, set);\n\tset->use++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_tables_bind_set);\n\nstatic void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t struct nft_set_binding *binding, bool event)\n{\n\tlist_del_rcu(&binding->list);\n\n\tif (list_empty(&set->bindings) && nft_set_is_anonymous(set)) {\n\t\tlist_del_rcu(&set->list);\n\t\tif (event)\n\t\t\tnf_tables_set_notify(ctx, set, NFT_MSG_DELSET,\n\t\t\t\t\t     GFP_KERNEL);\n\t}\n}\n\nvoid nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_tables_deactivate_set);\n\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (list_empty(&set->bindings) && nft_set_is_anonymous(set))\n\t\tnft_set_destroy(ctx, set);\n}\nEXPORT_SYMBOL_GPL(nf_tables_destroy_set);\n\nconst struct nft_set_ext_type nft_set_ext_types[] = {\n\t[NFT_SET_EXT_KEY]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n\t[NFT_SET_EXT_DATA]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n\t[NFT_SET_EXT_EXPRESSIONS]\t= {\n\t\t.align\t= __alignof__(struct nft_set_elem_expr),\n\t},\n\t[NFT_SET_EXT_OBJREF]\t\t= {\n\t\t.len\t= sizeof(struct nft_object *),\n\t\t.align\t= __alignof__(struct nft_object *),\n\t},\n\t[NFT_SET_EXT_FLAGS]\t\t= {\n\t\t.len\t= sizeof(u8),\n\t\t.align\t= __alignof__(u8),\n\t},\n\t[NFT_SET_EXT_TIMEOUT]\t\t= {\n\t\t.len\t= sizeof(u64),\n\t\t.align\t= __alignof__(u64),\n\t},\n\t[NFT_SET_EXT_EXPIRATION]\t= {\n\t\t.len\t= sizeof(u64),\n\t\t.align\t= __alignof__(u64),\n\t},\n\t[NFT_SET_EXT_USERDATA]\t\t= {\n\t\t.len\t= sizeof(struct nft_userdata),\n\t\t.align\t= __alignof__(struct nft_userdata),\n\t},\n\t[NFT_SET_EXT_KEY_END]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n};\n\n/*\n * Set elements\n */\n\nstatic const struct nla_policy nft_set_elem_policy[NFTA_SET_ELEM_MAX + 1] = {\n\t[NFTA_SET_ELEM_KEY]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_DATA]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_ELEM_TIMEOUT]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_ELEM_EXPIRATION]\t= { .type = NLA_U64 },\n\t[NFTA_SET_ELEM_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n\t[NFTA_SET_ELEM_EXPR]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_OBJREF]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_OBJ_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_KEY_END]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_EXPRESSIONS]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy nft_set_elem_list_policy[NFTA_SET_ELEM_LIST_MAX + 1] = {\n\t[NFTA_SET_ELEM_LIST_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_LIST_SET]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_LIST_ELEMENTS]\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_LIST_SET_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_set_elem_expr_dump(struct sk_buff *skb,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr;\n\tu32 size, num_exprs = 0;\n\tstruct nft_expr *expr;\n\tstruct nlattr *nest;\n\n\telem_expr = nft_set_ext_expr(ext);\n\tnft_setelem_expr_foreach(expr, elem_expr, size)\n\t\tnum_exprs++;\n\n\tif (num_exprs == 1) {\n\t\texpr = nft_setelem_expr_at(elem_expr, 0);\n\t\tif (nft_expr_dump(skb, NFTA_SET_ELEM_EXPR, expr) < 0)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t} else if (num_exprs > 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_EXPRESSIONS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\t\texpr = nft_setelem_expr_at(elem_expr, size);\n\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nf_tables_fill_setelem(struct sk_buff *skb,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_LIST_ELEM);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_KEY, nft_set_ext_key(ext),\n\t\t\t  NFT_DATA_VALUE, set->klen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_KEY_END, nft_set_ext_key_end(ext),\n\t\t\t  NFT_DATA_VALUE, set->klen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_DATA, nft_set_ext_data(ext),\n\t\t\t  set->dtype == NFT_DATA_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE,\n\t\t\t  set->dlen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS) &&\n\t    nft_set_elem_expr_dump(skb, set, ext))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&\n\t    nla_put_string(skb, NFTA_SET_ELEM_OBJREF,\n\t\t\t   (*nft_set_ext_obj(ext))->key.name) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    nla_put_be32(skb, NFTA_SET_ELEM_FLAGS,\n\t\t         htonl(*nft_set_ext_flags(ext))))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT) &&\n\t    nla_put_be64(skb, NFTA_SET_ELEM_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(*nft_set_ext_timeout(ext)),\n\t\t\t NFTA_SET_ELEM_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\tu64 expires, now = get_jiffies_64();\n\n\t\texpires = *nft_set_ext_expiration(ext);\n\t\tif (time_before64(now, expires))\n\t\t\texpires -= now;\n\t\telse\n\t\t\texpires = 0;\n\n\t\tif (nla_put_be64(skb, NFTA_SET_ELEM_EXPIRATION,\n\t\t\t\t nf_jiffies64_to_msecs(expires),\n\t\t\t\t NFTA_SET_ELEM_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {\n\t\tstruct nft_userdata *udata;\n\n\t\tudata = nft_set_ext_userdata(ext);\n\t\tif (nla_put(skb, NFTA_SET_ELEM_USERDATA,\n\t\t\t    udata->len + 1, udata->data))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -EMSGSIZE;\n}\n\nstruct nft_set_dump_args {\n\tconst struct netlink_callback\t*cb;\n\tstruct nft_set_iter\t\titer;\n\tstruct sk_buff\t\t\t*skb;\n};\n\nstatic int nf_tables_dump_setelem(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set,\n\t\t\t\t  const struct nft_set_iter *iter,\n\t\t\t\t  struct nft_set_elem *elem)\n{\n\tstruct nft_set_dump_args *args;\n\n\targs = container_of(iter, struct nft_set_dump_args, iter);\n\treturn nf_tables_fill_setelem(args->skb, set, elem);\n}\n\nstruct nft_set_dump_ctx {\n\tconst struct nft_set\t*set;\n\tstruct nft_ctx\t\tctx;\n};\n\nstatic int nft_set_catchall_dump(struct net *net, struct sk_buff *skb,\n\t\t\t\t const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_expired(ext))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = nf_tables_fill_setelem(skb, set, &elem);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nft_set_dump_ctx *dump_ctx = cb->data;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_set_dump_args args;\n\tbool set_found = false;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tu32 portid, seq;\n\tint event;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (dump_ctx->ctx.family != NFPROTO_UNSPEC &&\n\t\t    dump_ctx->ctx.family != table->family)\n\t\t\tcontinue;\n\n\t\tif (table != dump_ctx->ctx.table)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\t\tif (set == dump_ctx->set) {\n\t\t\t\tset_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!set_found) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tevent  = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_NEWSETELEM);\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq    = cb->nlh->nlmsg_seq;\n\n\tnlh = nfnl_msg_put(skb, portid, seq, event, NLM_F_MULTI,\n\t\t\t   table->family, NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\targs.cb\t\t\t= cb;\n\targs.skb\t\t= skb;\n\targs.iter.genmask\t= nft_genmask_cur(net);\n\targs.iter.skip\t\t= cb->args[0];\n\targs.iter.count\t\t= 0;\n\targs.iter.err\t\t= 0;\n\targs.iter.fn\t\t= nf_tables_dump_setelem;\n\tset->ops->walk(&dump_ctx->ctx, set, &args.iter);\n\n\tif (!args.iter.err && args.iter.count == cb->args[0])\n\t\targs.iter.err = nft_set_catchall_dump(net, skb, set);\n\trcu_read_unlock();\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\n\tif (args.iter.err && args.iter.err != -EMSGSIZE)\n\t\treturn args.iter.err;\n\tif (args.iter.count == cb->args[0])\n\t\treturn 0;\n\n\tcb->args[0] = args.iter.count;\n\treturn skb->len;\n\nnla_put_failure:\n\trcu_read_unlock();\n\treturn -ENOSPC;\n}\n\nstatic int nf_tables_dump_set_start(struct netlink_callback *cb)\n{\n\tstruct nft_set_dump_ctx *dump_ctx = cb->data;\n\n\tcb->data = kmemdup(dump_ctx, sizeof(*dump_ctx), GFP_ATOMIC);\n\n\treturn cb->data ? 0 : -ENOMEM;\n}\n\nstatic int nf_tables_dump_set_done(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\nstatic int nf_tables_fill_setelem_info(struct sk_buff *skb,\n\t\t\t\t       const struct nft_ctx *ctx, u32 seq,\n\t\t\t\t       u32 portid, int event, u16 flags,\n\t\t\t\t       const struct nft_set *set,\n\t\t\t\t       const struct nft_set_elem *elem)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tint err;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, ctx->family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(ctx->net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_NAME, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\terr = nf_tables_fill_setelem(skb, set, elem);\n\tif (err < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic int nft_setelem_parse_flags(const struct nft_set *set,\n\t\t\t\t   const struct nlattr *attr, u32 *flags)\n{\n\tif (attr == NULL)\n\t\treturn 0;\n\n\t*flags = ntohl(nla_get_be32(attr));\n\tif (*flags & ~(NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL))\n\t\treturn -EOPNOTSUPP;\n\tif (!(set->flags & NFT_SET_INTERVAL) &&\n\t    *flags & NFT_SET_ELEM_INTERVAL_END)\n\t\treturn -EINVAL;\n\tif ((*flags & (NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL)) ==\n\t    (NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nft_setelem_parse_key(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t struct nft_data *key, struct nlattr *attr)\n{\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= NFT_DATA_VALUE_MAXLEN,\n\t\t.len\t= set->klen,\n\t};\n\n\treturn nft_data_init(ctx, key, &desc, attr);\n}\n\nstatic int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t  struct nft_data_desc *desc,\n\t\t\t\t  struct nft_data *data,\n\t\t\t\t  struct nlattr *attr)\n{\n\tu32 dtype;\n\n\tif (set->dtype == NFT_DATA_VERDICT)\n\t\tdtype = NFT_DATA_VERDICT;\n\telse\n\t\tdtype = NFT_DATA_VALUE;\n\n\tdesc->type = dtype;\n\tdesc->size = NFT_DATA_VALUE_MAXLEN;\n\tdesc->len = set->dlen;\n\tdesc->flags = NFT_DATA_DESC_SETELEM;\n\n\treturn nft_data_init(ctx, data, desc, attr);\n}\n\nstatic void *nft_setelem_catchall_get(const struct net *net,\n\t\t\t\t      const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_ext *ext;\n\tvoid *priv = NULL;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_expired(ext))\n\t\t\tcontinue;\n\n\t\tpriv = catchall->elem;\n\t\tbreak;\n\t}\n\n\treturn priv;\n}\n\nstatic int nft_setelem_get(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   struct nft_set_elem *elem, u32 flags)\n{\n\tvoid *priv;\n\n\tif (!(flags & NFT_SET_ELEM_CATCHALL)) {\n\t\tpriv = set->ops->get(ctx->net, set, elem, flags);\n\t\tif (IS_ERR(priv))\n\t\t\treturn PTR_ERR(priv);\n\t} else {\n\t\tpriv = nft_setelem_catchall_get(ctx->net, set);\n\t\tif (!priv)\n\t\t\treturn -ENOENT;\n\t}\n\telem->priv = priv;\n\n\treturn 0;\n}\n\nstatic int nft_get_set_elem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_set_elem elem;\n\tstruct sk_buff *skb;\n\tuint32_t flags = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = nft_setelem_get(ctx, set, &elem, flags);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn err;\n\n\terr = nf_tables_fill_setelem_info(skb, ctx, ctx->seq, ctx->portid,\n\t\t\t\t\t  NFT_MSG_NEWSETELEM, 0, set, &elem);\n\tif (err < 0)\n\t\tgoto err_fill_setelem;\n\n\treturn nfnetlink_unicast(skb, ctx->net, ctx->portid);\n\nerr_fill_setelem:\n\tkfree_skb(skb);\n\treturn err;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nlattr *attr;\n\tstruct nft_ctx ctx;\n\tint rem, err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_set_start,\n\t\t\t.dump = nf_tables_dump_set,\n\t\t\t.done = nf_tables_dump_set_done,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\t\tstruct nft_set_dump_ctx dump_ctx = {\n\t\t\t.set = set,\n\t\t\t.ctx = ctx,\n\t\t};\n\n\t\tc.data = &dump_ctx;\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_get_set_elem(&ctx, set, attr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void nf_tables_setelem_notify(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_set *set,\n\t\t\t\t     const struct nft_set_elem *elem,\n\t\t\t\t     int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = ctx->net;\n\tu32 portid = ctx->portid;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report && !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_setelem_info(skb, ctx, 0, portid, event, flags,\n\t\t\t\t\t  set, elem);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic struct nft_trans *nft_trans_elem_alloc(struct nft_ctx *ctx,\n\t\t\t\t\t      int msg_type,\n\t\t\t\t\t      struct nft_set *set)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_elem));\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tnft_trans_elem_set(trans) = set;\n\treturn trans;\n}\n\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t const struct nlattr *attr)\n{\n\tstruct nft_expr *expr;\n\tint err;\n\n\texpr = nft_expr_init(ctx, attr);\n\tif (IS_ERR(expr))\n\t\treturn expr;\n\n\terr = -EOPNOTSUPP;\n\tif (expr->ops->type->flags & NFT_EXPR_GC) {\n\t\tif (set->flags & NFT_SET_TIMEOUT)\n\t\t\tgoto err_set_elem_expr;\n\t\tif (!set->ops->gc_init)\n\t\t\tgoto err_set_elem_expr;\n\t\tset->ops->gc_init(set);\n\t}\n\n\treturn expr;\n\nerr_set_elem_expr:\n\tnft_expr_destroy(ctx, expr);\n\treturn ERR_PTR(err);\n}\n\nstatic int nft_set_ext_check(const struct nft_set_ext_tmpl *tmpl, u8 id, u32 len)\n{\n\tlen += nft_set_ext_types[id].len;\n\tif (len > tmpl->ext_len[id] ||\n\t    len > U8_MAX)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_set_ext_memcpy(const struct nft_set_ext_tmpl *tmpl, u8 id,\n\t\t\t      void *to, const void *from, u32 len)\n{\n\tif (nft_set_ext_check(tmpl, id, len) < 0)\n\t\treturn -1;\n\n\tmemcpy(to, from, len);\n\n\treturn 0;\n}\n\nvoid *nft_set_elem_init(const struct nft_set *set,\n\t\t\tconst struct nft_set_ext_tmpl *tmpl,\n\t\t\tconst u32 *key, const u32 *key_end,\n\t\t\tconst u32 *data, u64 timeout, u64 expiration, gfp_t gfp)\n{\n\tstruct nft_set_ext *ext;\n\tvoid *elem;\n\n\telem = kzalloc(set->ops->elemsize + tmpl->len, gfp);\n\tif (elem == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\text = nft_set_elem_ext(set, elem);\n\tnft_set_ext_init(ext, tmpl);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY,\n\t\t\t       nft_set_ext_key(ext), key, set->klen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY_END,\n\t\t\t       nft_set_ext_key_end(ext), key_end, set->klen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_DATA,\n\t\t\t       nft_set_ext_data(ext), data, set->dlen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\t*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;\n\t\tif (expiration == 0)\n\t\t\t*nft_set_ext_expiration(ext) += timeout;\n\t}\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))\n\t\t*nft_set_ext_timeout(ext) = timeout;\n\n\treturn elem;\n\nerr_ext_check:\n\tkfree(elem);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void __nft_set_elem_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_expr *expr)\n{\n\tif (expr->ops->destroy_clone) {\n\t\texpr->ops->destroy_clone(ctx, expr);\n\t\tmodule_put(expr->ops->type->owner);\n\t} else {\n\t\tnf_tables_expr_destroy(ctx, expr);\n\t}\n}\n\nstatic void nft_set_elem_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t      struct nft_set_elem_expr *elem_expr)\n{\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tnft_setelem_expr_foreach(expr, elem_expr, size)\n\t\t__nft_set_elem_expr_destroy(ctx, expr);\n}\n\nvoid nft_set_elem_destroy(const struct nft_set *set, void *elem,\n\t\t\t  bool destroy_expr)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem);\n\tstruct nft_ctx ctx = {\n\t\t.net\t= read_pnet(&set->net),\n\t\t.family\t= set->table->family,\n\t};\n\n\tnft_data_release(nft_set_ext_key(ext), NFT_DATA_VALUE);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_release(nft_set_ext_data(ext), set->dtype);\n\tif (destroy_expr && nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))\n\t\tnft_set_elem_expr_destroy(&ctx, nft_set_ext_expr(ext));\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use--;\n\tkfree(elem);\n}\nEXPORT_SYMBOL_GPL(nft_set_elem_destroy);\n\n/* Only called from commit path, nft_setelem_data_deactivate() already deals\n * with the refcounting from the preparation phase.\n */\nstatic void nf_tables_set_elem_destroy(const struct nft_ctx *ctx,\n\t\t\t\t       const struct nft_set *set, void *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))\n\t\tnft_set_elem_expr_destroy(ctx, nft_set_ext_expr(ext));\n\n\tkfree(elem);\n}\n\nint nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[])\n{\n\tstruct nft_expr *expr;\n\tint err, i, k;\n\n\tfor (i = 0; i < set->num_exprs; i++) {\n\t\texpr = kzalloc(set->exprs[i]->ops->size, GFP_KERNEL_ACCOUNT);\n\t\tif (!expr)\n\t\t\tgoto err_expr;\n\n\t\terr = nft_expr_clone(expr, set->exprs[i]);\n\t\tif (err < 0) {\n\t\t\tkfree(expr);\n\t\t\tgoto err_expr;\n\t\t}\n\t\texpr_array[i] = expr;\n\t}\n\n\treturn 0;\n\nerr_expr:\n\tfor (k = i - 1; k >= 0; k--)\n\t\tnft_expr_destroy(ctx, expr_array[k]);\n\n\treturn -ENOMEM;\n}\n\nstatic int nft_set_elem_expr_setup(struct nft_ctx *ctx,\n\t\t\t\t   const struct nft_set_ext_tmpl *tmpl,\n\t\t\t\t   const struct nft_set_ext *ext,\n\t\t\t\t   struct nft_expr *expr_array[],\n\t\t\t\t   u32 num_exprs)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tu32 len = sizeof(struct nft_set_elem_expr);\n\tstruct nft_expr *expr;\n\tint i, err;\n\n\tif (num_exprs == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_exprs; i++)\n\t\tlen += expr_array[i]->ops->size;\n\n\tif (nft_set_ext_check(tmpl, NFT_SET_EXT_EXPRESSIONS, len) < 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_exprs; i++) {\n\t\texpr = nft_setelem_expr_at(elem_expr, elem_expr->size);\n\t\terr = nft_expr_clone(expr, expr_array[i]);\n\t\tif (err < 0)\n\t\t\tgoto err_elem_expr_setup;\n\n\t\telem_expr->size += expr_array[i]->ops->size;\n\t\tnft_expr_destroy(ctx, expr_array[i]);\n\t\texpr_array[i] = NULL;\n\t}\n\n\treturn 0;\n\nerr_elem_expr_setup:\n\tfor (; i < num_exprs; i++) {\n\t\tnft_expr_destroy(ctx, expr_array[i]);\n\t\texpr_array[i] = NULL;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstruct nft_set_ext *nft_set_catchall_lookup(const struct net *net,\n\t\t\t\t\t    const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (nft_set_elem_active(ext, genmask) &&\n\t\t    !nft_set_elem_expired(ext))\n\t\t\treturn ext;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(nft_set_catchall_lookup);\n\nvoid *nft_set_catchall_gc(const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall, *next;\n\tstruct nft_set_ext *ext;\n\tvoid *elem = NULL;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\n\t\tif (!nft_set_elem_expired(ext) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\telem = catchall->elem;\n\t\tlist_del_rcu(&catchall->list);\n\t\tkfree_rcu(catchall, rcu);\n\t\tbreak;\n\t}\n\n\treturn elem;\n}\nEXPORT_SYMBOL_GPL(nft_set_catchall_gc);\n\nstatic int nft_setelem_catchall_insert(const struct net *net,\n\t\t\t\t       struct nft_set *set,\n\t\t\t\t       const struct nft_set_elem *elem,\n\t\t\t\t       struct nft_set_ext **pext)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_next(net);\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (nft_set_elem_active(ext, genmask)) {\n\t\t\t*pext = ext;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tcatchall = kmalloc(sizeof(*catchall), GFP_KERNEL);\n\tif (!catchall)\n\t\treturn -ENOMEM;\n\n\tcatchall->elem = elem->priv;\n\tlist_add_tail_rcu(&catchall->list, &set->catchall_list);\n\n\treturn 0;\n}\n\nstatic int nft_setelem_insert(const struct net *net,\n\t\t\t      struct nft_set *set,\n\t\t\t      const struct nft_set_elem *elem,\n\t\t\t      struct nft_set_ext **ext, unsigned int flags)\n{\n\tint ret;\n\n\tif (flags & NFT_SET_ELEM_CATCHALL)\n\t\tret = nft_setelem_catchall_insert(net, set, elem, ext);\n\telse\n\t\tret = set->ops->insert(net, set, elem, ext);\n\n\treturn ret;\n}\n\nstatic bool nft_setelem_is_catchall(const struct nft_set *set,\n\t\t\t\t    const struct nft_set_elem *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    *nft_set_ext_flags(ext) & NFT_SET_ELEM_CATCHALL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void nft_setelem_activate(struct net *net, struct nft_set *set,\n\t\t\t\t struct nft_set_elem *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_setelem_is_catchall(set, elem)) {\n\t\tnft_set_elem_change_active(net, set, ext);\n\t\tnft_set_elem_clear_busy(ext);\n\t} else {\n\t\tset->ops->activate(net, set, elem);\n\t}\n}\n\nstatic int nft_setelem_catchall_deactivate(const struct net *net,\n\t\t\t\t\t   struct nft_set *set,\n\t\t\t\t\t   struct nft_set_elem *elem)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_is_active(net, ext) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\tkfree(elem->priv);\n\t\telem->priv = catchall->elem;\n\t\tnft_set_elem_change_active(net, set, ext);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int __nft_setelem_deactivate(const struct net *net,\n\t\t\t\t    struct nft_set *set,\n\t\t\t\t    struct nft_set_elem *elem)\n{\n\tvoid *priv;\n\n\tpriv = set->ops->deactivate(net, set, elem);\n\tif (!priv)\n\t\treturn -ENOENT;\n\n\tkfree(elem->priv);\n\telem->priv = priv;\n\tset->ndeact++;\n\n\treturn 0;\n}\n\nstatic int nft_setelem_deactivate(const struct net *net,\n\t\t\t\t  struct nft_set *set,\n\t\t\t\t  struct nft_set_elem *elem, u32 flags)\n{\n\tint ret;\n\n\tif (flags & NFT_SET_ELEM_CATCHALL)\n\t\tret = nft_setelem_catchall_deactivate(net, set, elem);\n\telse\n\t\tret = __nft_setelem_deactivate(net, set, elem);\n\n\treturn ret;\n}\n\nstatic void nft_setelem_catchall_remove(const struct net *net,\n\t\t\t\t\tconst struct nft_set *set,\n\t\t\t\t\tconst struct nft_set_elem *elem)\n{\n\tstruct nft_set_elem_catchall *catchall, *next;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\tif (catchall->elem == elem->priv) {\n\t\t\tlist_del_rcu(&catchall->list);\n\t\t\tkfree_rcu(catchall, rcu);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void nft_setelem_remove(const struct net *net,\n\t\t\t       const struct nft_set *set,\n\t\t\t       const struct nft_set_elem *elem)\n{\n\tif (nft_setelem_is_catchall(set, elem))\n\t\tnft_setelem_catchall_remove(net, set, elem);\n\telse\n\t\tset->ops->remove(net, set, elem);\n}\n\nstatic bool nft_setelem_valid_key_end(const struct nft_set *set,\n\t\t\t\t      struct nlattr **nla, u32 flags)\n{\n\tif ((set->flags & (NFT_SET_CONCAT | NFT_SET_INTERVAL)) ==\n\t\t\t  (NFT_SET_CONCAT | NFT_SET_INTERVAL)) {\n\t\tif (flags & NFT_SET_ELEM_INTERVAL_END)\n\t\t\treturn false;\n\t\tif (!nla[NFTA_SET_ELEM_KEY_END] &&\n\t\t    !(flags & NFT_SET_ELEM_CATCHALL))\n\t\t\treturn false;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_KEY_END])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    const struct nlattr *attr, u32 nlmsg_flags)\n{\n\tstruct nft_expr *expr_array[NFT_SET_EXPR_MAX] = {};\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tu32 flags = 0, size = 0, num_exprs = 0;\n\tstruct nft_set_ext_tmpl tmpl;\n\tstruct nft_set_ext *ext, *ext2;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_binding *binding;\n\tstruct nft_object *obj = NULL;\n\tstruct nft_userdata *udata;\n\tstruct nft_data_desc desc;\n\tenum nft_registers dreg;\n\tstruct nft_trans *trans;\n\tu64 timeout;\n\tu64 expiration;\n\tint err, i;\n\tu8 ulen;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_set_ext_prepare(&tmpl);\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (flags != 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (set->flags & NFT_SET_MAP) {\n\t\tif (nla[NFTA_SET_ELEM_DATA] == NULL &&\n\t\t    !(flags & NFT_SET_ELEM_INTERVAL_END))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_DATA] != NULL)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (set->flags & NFT_SET_OBJECT) {\n\t\tif (!nla[NFTA_SET_ELEM_OBJREF] &&\n\t\t    !(flags & NFT_SET_ELEM_INTERVAL_END))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_OBJREF])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!nft_setelem_valid_key_end(set, nla, flags))\n\t\treturn -EINVAL;\n\n\tif ((flags & NFT_SET_ELEM_INTERVAL_END) &&\n\t     (nla[NFTA_SET_ELEM_DATA] ||\n\t      nla[NFTA_SET_ELEM_OBJREF] ||\n\t      nla[NFTA_SET_ELEM_TIMEOUT] ||\n\t      nla[NFTA_SET_ELEM_EXPIRATION] ||\n\t      nla[NFTA_SET_ELEM_USERDATA] ||\n\t      nla[NFTA_SET_ELEM_EXPR] ||\n\t      nla[NFTA_SET_ELEM_KEY_END] ||\n\t      nla[NFTA_SET_ELEM_EXPRESSIONS]))\n\t\treturn -EINVAL;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_ELEM_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_TIMEOUT],\n\t\t\t\t\t    &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_TIMEOUT) {\n\t\ttimeout = set->timeout;\n\t}\n\n\texpiration = 0;\n\tif (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],\n\t\t\t\t\t    &expiration);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_EXPR]) {\n\t\tstruct nft_expr *expr;\n\n\t\tif (set->num_exprs && set->num_exprs != 1)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\texpr = nft_set_elem_expr_alloc(ctx, set,\n\t\t\t\t\t       nla[NFTA_SET_ELEM_EXPR]);\n\t\tif (IS_ERR(expr))\n\t\t\treturn PTR_ERR(expr);\n\n\t\texpr_array[0] = expr;\n\t\tnum_exprs = 1;\n\n\t\tif (set->num_exprs && set->exprs[0]->ops != expr->ops) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_set_elem_expr;\n\t\t}\n\t} else if (nla[NFTA_SET_ELEM_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_ELEM_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX ||\n\t\t\t    (set->num_exprs && set->num_exprs == i)) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\texpr_array[i] = expr;\n\t\t\tnum_exprs++;\n\n\t\t\tif (set->num_exprs && expr->ops != set->exprs[i]->ops) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_set_elem_expr;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, expr_array);\n\t\tif (err < 0)\n\t\t\tgoto err_set_elem_expr_clone;\n\n\t\tnum_exprs = set->num_exprs;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\tgoto err_set_elem_expr;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (timeout > 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\n\t\tif (timeout != set->timeout) {\n\t\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_key_end;\n\t\t}\n\t}\n\n\tif (num_exprs) {\n\t\tfor (i = 0; i < num_exprs; i++)\n\t\t\tsize += expr_array[i]->ops->size;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_EXPRESSIONS,\n\t\t\t\t\t     sizeof(struct nft_set_elem_expr) + size);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_OBJREF] != NULL) {\n\t\tobj = nft_obj_lookup(ctx->net, ctx->table,\n\t\t\t\t     nla[NFTA_SET_ELEM_OBJREF],\n\t\t\t\t     set->objtype, genmask);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto err_parse_key_end;\n\t\t}\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_OBJREF);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_DATA] != NULL) {\n\t\terr = nft_setelem_parse_data(ctx, set, &desc, &elem.data.val,\n\t\t\t\t\t     nla[NFTA_SET_ELEM_DATA]);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\n\t\tdreg = nft_type_to_reg(set->dtype);\n\t\tlist_for_each_entry(binding, &set->bindings, list) {\n\t\t\tstruct nft_ctx bind_ctx = {\n\t\t\t\t.net\t= ctx->net,\n\t\t\t\t.family\t= ctx->family,\n\t\t\t\t.table\t= ctx->table,\n\t\t\t\t.chain\t= (struct nft_chain *)binding->chain,\n\t\t\t};\n\n\t\t\tif (!(binding->flags & NFT_SET_MAP))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_validate_register_store(&bind_ctx, dreg,\n\t\t\t\t\t\t\t  &elem.data.val,\n\t\t\t\t\t\t\t  desc.type, desc.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_data;\n\n\t\t\tif (desc.type == NFT_DATA_VERDICT &&\n\t\t\t    (elem.data.val.verdict.code == NFT_GOTO ||\n\t\t\t     elem.data.val.verdict.code == NFT_JUMP))\n\t\t\t\tnft_validate_state_update(ctx->net,\n\t\t\t\t\t\t\t  NFT_VALIDATE_NEED);\n\t\t}\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_DATA, desc.len);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_data;\n\t}\n\n\t/* The full maximum length of userdata can exceed the maximum\n\t * offset value (U8_MAX) for following extensions, therefor it\n\t * must be the last extension added.\n\t */\n\tulen = 0;\n\tif (nla[NFTA_SET_ELEM_USERDATA] != NULL) {\n\t\tulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);\n\t\tif (ulen > 0) {\n\t\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_USERDATA,\n\t\t\t\t\t\t     ulen);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_data;\n\t\t}\n\t}\n\n\telem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,\n\t\t\t\t      elem.key_end.val.data, elem.data.val.data,\n\t\t\t\t      timeout, expiration, GFP_KERNEL_ACCOUNT);\n\tif (IS_ERR(elem.priv)) {\n\t\terr = PTR_ERR(elem.priv);\n\t\tgoto err_parse_data;\n\t}\n\n\text = nft_set_elem_ext(set, elem.priv);\n\tif (flags)\n\t\t*nft_set_ext_flags(ext) = flags;\n\n\tif (ulen > 0) {\n\t\tif (nft_set_ext_check(&tmpl, NFT_SET_EXT_USERDATA, ulen) < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_elem_userdata;\n\t\t}\n\t\tudata = nft_set_ext_userdata(ext);\n\t\tudata->len = ulen - 1;\n\t\tnla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);\n\t}\n\tif (obj) {\n\t\t*nft_set_ext_obj(ext) = obj;\n\t\tobj->use++;\n\t}\n\terr = nft_set_elem_expr_setup(ctx, &tmpl, ext, expr_array, num_exprs);\n\tif (err < 0)\n\t\tgoto err_elem_free;\n\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);\n\tif (trans == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_elem_free;\n\t}\n\n\text->genmask = nft_genmask_cur(ctx->net) | NFT_SET_ELEM_BUSY_MASK;\n\n\terr = nft_setelem_insert(ctx->net, set, &elem, &ext2, flags);\n\tif (err) {\n\t\tif (err == -EEXIST) {\n\t\t\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) ^\n\t\t\t    nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) ||\n\t\t\t    nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) ^\n\t\t\t    nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF))\n\t\t\t\tgoto err_element_clash;\n\t\t\tif ((nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t\t\t     nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) &&\n\t\t\t     memcmp(nft_set_ext_data(ext),\n\t\t\t\t    nft_set_ext_data(ext2), set->dlen) != 0) ||\n\t\t\t    (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&\n\t\t\t     nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF) &&\n\t\t\t     *nft_set_ext_obj(ext) != *nft_set_ext_obj(ext2)))\n\t\t\t\tgoto err_element_clash;\n\t\t\telse if (!(nlmsg_flags & NLM_F_EXCL))\n\t\t\t\terr = 0;\n\t\t} else if (err == -ENOTEMPTY) {\n\t\t\t/* ENOTEMPTY reports overlapping between this element\n\t\t\t * and an existing one.\n\t\t\t */\n\t\t\terr = -EEXIST;\n\t\t}\n\t\tgoto err_element_clash;\n\t}\n\n\tif (!(flags & NFT_SET_ELEM_CATCHALL) && set->size &&\n\t    !atomic_add_unless(&set->nelems, 1, set->size + set->ndeact)) {\n\t\terr = -ENFILE;\n\t\tgoto err_set_full;\n\t}\n\n\tnft_trans_elem(trans) = elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n\nerr_set_full:\n\tnft_setelem_remove(ctx->net, set, &elem);\nerr_element_clash:\n\tkfree(trans);\nerr_elem_free:\n\tif (obj)\n\t\tobj->use--;\nerr_elem_userdata:\n\tnf_tables_set_elem_destroy(ctx, set, elem.priv);\nerr_parse_data:\n\tif (nla[NFTA_SET_ELEM_DATA] != NULL)\n\t\tnft_data_release(&elem.data.val, desc.type);\nerr_parse_key_end:\n\tnft_data_release(&elem.key_end.val, NFT_DATA_VALUE);\nerr_parse_key:\n\tnft_data_release(&elem.key.val, NFT_DATA_VALUE);\nerr_set_elem_expr:\n\tfor (i = 0; i < num_exprs && expr_array[i]; i++)\n\t\tnft_expr_destroy(ctx, expr_array[i]);\nerr_set_elem_expr_clone:\n\treturn err;\n}\n\nstatic int nf_tables_newsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err;\n\n\tif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup_global(net, table, nla[NFTA_SET_ELEM_LIST_SET],\n\t\t\t\t    nla[NFTA_SET_ELEM_LIST_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_add_set_elem(&ctx, set, attr, info->nlh->nlmsg_flags);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (nft_net->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\n\treturn 0;\n}\n\n/**\n *\tnft_data_hold - hold a nft_data item\n *\n *\t@data: struct nft_data to release\n *\t@type: type of data\n *\n *\tHold a nft_data item. NFT_DATA_VALUE types can be silently discarded,\n *\tNFT_DATA_VERDICT bumps the reference to chains in case of NFT_JUMP and\n *\tNFT_GOTO verdicts. This function must be called on active data objects\n *\tfrom the second phase of the commit protocol.\n */\nvoid nft_data_hold(const struct nft_data *data, enum nft_data_types type)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tif (type == NFT_DATA_VERDICT) {\n\t\tswitch (data->verdict.code) {\n\t\tcase NFT_JUMP:\n\t\tcase NFT_GOTO:\n\t\t\tchain = data->verdict.chain;\n\t\t\tchain->use++;\n\n\t\t\tif (!nft_chain_is_bound(chain))\n\t\t\t\tbreak;\n\n\t\t\tchain->table->use++;\n\t\t\tlist_for_each_entry(rule, &chain->rules, list)\n\t\t\t\tchain->use++;\n\n\t\t\tnft_chain_add(chain->table, chain);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void nft_setelem_data_activate(const struct net *net,\n\t\t\t\t      const struct nft_set *set,\n\t\t\t\t      struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_hold(nft_set_ext_data(ext), set->dtype);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use++;\n}\n\nstatic void nft_setelem_data_deactivate(const struct net *net,\n\t\t\t\t\tconst struct nft_set *set,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_release(nft_set_ext_data(ext), set->dtype);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use--;\n}\n\nstatic int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_set_ext_tmpl tmpl;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tstruct nft_trans *trans;\n\tu32 flags = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (!nft_setelem_valid_key_end(set, nla, flags))\n\t\treturn -EINVAL;\n\n\tnft_set_ext_prepare(&tmpl);\n\n\tif (flags != 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem_key_end;\n\t}\n\n\terr = -ENOMEM;\n\telem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,\n\t\t\t\t      elem.key_end.val.data, NULL, 0, 0,\n\t\t\t\t      GFP_KERNEL_ACCOUNT);\n\tif (IS_ERR(elem.priv)) {\n\t\terr = PTR_ERR(elem.priv);\n\t\tgoto fail_elem_key_end;\n\t}\n\n\text = nft_set_elem_ext(set, elem.priv);\n\tif (flags)\n\t\t*nft_set_ext_flags(ext) = flags;\n\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\n\tif (trans == NULL)\n\t\tgoto fail_trans;\n\n\terr = nft_setelem_deactivate(ctx->net, set, &elem, flags);\n\tif (err < 0)\n\t\tgoto fail_ops;\n\n\tnft_setelem_data_deactivate(ctx->net, set, &elem);\n\n\tnft_trans_elem(trans) = elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n\nfail_ops:\n\tkfree(trans);\nfail_trans:\n\tkfree(elem.priv);\nfail_elem_key_end:\n\tnft_data_release(&elem.key_end.val, NFT_DATA_VALUE);\nfail_elem:\n\tnft_data_release(&elem.key.val, NFT_DATA_VALUE);\n\treturn err;\n}\n\nstatic int nft_setelem_flush(const struct nft_ctx *ctx,\n\t\t\t     struct nft_set *set,\n\t\t\t     const struct nft_set_iter *iter,\n\t\t\t     struct nft_set_elem *elem)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\n\ttrans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,\n\t\t\t\t    sizeof(struct nft_trans_elem), GFP_ATOMIC);\n\tif (!trans)\n\t\treturn -ENOMEM;\n\n\tif (!set->ops->flush(ctx->net, set, elem->priv)) {\n\t\terr = -ENOENT;\n\t\tgoto err1;\n\t}\n\tset->ndeact++;\n\n\tnft_setelem_data_deactivate(ctx->net, set, elem);\n\tnft_trans_elem_set(trans) = set;\n\tnft_trans_elem(trans) = *elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\nerr1:\n\tkfree(trans);\n\treturn err;\n}\n\nstatic int __nft_set_catchall_flush(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_set *set,\n\t\t\t\t    struct nft_set_elem *elem)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,\n\t\t\t\t    sizeof(struct nft_trans_elem), GFP_KERNEL);\n\tif (!trans)\n\t\treturn -ENOMEM;\n\n\tnft_setelem_data_deactivate(ctx->net, set, elem);\n\tnft_trans_elem_set(trans) = set;\n\tnft_trans_elem(trans) = *elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_set_catchall_flush(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = __nft_set_catchall_flush(ctx, set, &elem);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nft_set_flush(struct nft_ctx *ctx, struct nft_set *set, u8 genmask)\n{\n\tstruct nft_set_iter iter = {\n\t\t.genmask\t= genmask,\n\t\t.fn\t\t= nft_setelem_flush,\n\t};\n\n\tset->ops->walk(ctx, set, &iter);\n\tif (!iter.err)\n\t\titer.err = nft_set_catchall_flush(ctx, set);\n\n\treturn iter.err;\n}\n\nstatic int nf_tables_delsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])\n\t\treturn nft_set_flush(&ctx, set, genmask);\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_del_setelem(&ctx, set, attr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nvoid nft_set_gc_batch_release(struct rcu_head *rcu)\n{\n\tstruct nft_set_gc_batch *gcb;\n\tunsigned int i;\n\n\tgcb = container_of(rcu, struct nft_set_gc_batch, head.rcu);\n\tfor (i = 0; i < gcb->head.cnt; i++)\n\t\tnft_set_elem_destroy(gcb->head.set, gcb->elems[i], true);\n\tkfree(gcb);\n}\n\nstruct nft_set_gc_batch *nft_set_gc_batch_alloc(const struct nft_set *set,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct nft_set_gc_batch *gcb;\n\n\tgcb = kzalloc(sizeof(*gcb), gfp);\n\tif (gcb == NULL)\n\t\treturn gcb;\n\tgcb->head.set = set;\n\treturn gcb;\n}\n\n/*\n * Stateful objects\n */\n\n/**\n *\tnft_register_obj- register nf_tables stateful object type\n *\t@obj_type: object type\n *\n *\tRegisters the object type for use with nf_tables. Returns zero on\n *\tsuccess or a negative errno code otherwise.\n */\nint nft_register_obj(struct nft_object_type *obj_type)\n{\n\tif (obj_type->type == NFT_OBJECT_UNSPEC)\n\t\treturn -EINVAL;\n\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_add_rcu(&obj_type->list, &nf_tables_objects);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_register_obj);\n\n/**\n *\tnft_unregister_obj - unregister nf_tables object type\n *\t@obj_type: object type\n *\n * \tUnregisters the object type for use with nf_tables.\n */\nvoid nft_unregister_obj(struct nft_object_type *obj_type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&obj_type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_obj);\n\nstruct nft_object *nft_obj_lookup(const struct net *net,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nlattr *nla, u32 objtype,\n\t\t\t\t  u8 genmask)\n{\n\tstruct nft_object_hash_key k = { .table = table };\n\tchar search[NFT_OBJ_MAXNAMELEN];\n\tstruct rhlist_head *tmp, *list;\n\tstruct nft_object *obj;\n\n\tnla_strscpy(search, nla, sizeof(search));\n\tk.name = search;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held() &&\n\t\t     !lockdep_commit_lock_is_held(net));\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&nft_objname_ht, &k, nft_objname_ht_params);\n\tif (!list)\n\t\tgoto out;\n\n\trhl_for_each_entry_rcu(obj, tmp, list, rhlhead) {\n\t\tif (objtype == obj->ops->type->type &&\n\t\t    nft_active_genmask(obj, genmask)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn obj;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\nEXPORT_SYMBOL_GPL(nft_obj_lookup);\n\nstatic struct nft_object *nft_obj_lookup_byhandle(const struct nft_table *table,\n\t\t\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t\t\t  u32 objtype, u8 genmask)\n{\n\tstruct nft_object *obj;\n\n\tlist_for_each_entry(obj, &table->objects, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == obj->handle &&\n\t\t    objtype == obj->ops->type->type &&\n\t\t    nft_active_genmask(obj, genmask))\n\t\t\treturn obj;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic const struct nla_policy nft_obj_policy[NFTA_OBJ_MAX + 1] = {\n\t[NFTA_OBJ_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_OBJ_NAME]\t\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_OBJ_MAXNAMELEN - 1 },\n\t[NFTA_OBJ_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_OBJ_DATA]\t\t= { .type = NLA_NESTED },\n\t[NFTA_OBJ_HANDLE]\t= { .type = NLA_U64},\n\t[NFTA_OBJ_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n};\n\nstatic struct nft_object *nft_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t       const struct nft_object_type *type,\n\t\t\t\t       const struct nlattr *attr)\n{\n\tstruct nlattr **tb;\n\tconst struct nft_object_ops *ops;\n\tstruct nft_object *obj;\n\tint err = -ENOMEM;\n\n\ttb = kmalloc_array(type->maxattr + 1, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\tgoto err1;\n\n\tif (attr) {\n\t\terr = nla_parse_nested_deprecated(tb, type->maxattr, attr,\n\t\t\t\t\t\t  type->policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t} else {\n\t\tmemset(tb, 0, sizeof(tb[0]) * (type->maxattr + 1));\n\t}\n\n\tif (type->select_ops) {\n\t\tops = type->select_ops(ctx, (const struct nlattr * const *)tb);\n\t\tif (IS_ERR(ops)) {\n\t\t\terr = PTR_ERR(ops);\n\t\t\tgoto err2;\n\t\t}\n\t} else {\n\t\tops = type->ops;\n\t}\n\n\terr = -ENOMEM;\n\tobj = kzalloc(sizeof(*obj) + ops->size, GFP_KERNEL_ACCOUNT);\n\tif (!obj)\n\t\tgoto err2;\n\n\terr = ops->init(ctx, (const struct nlattr * const *)tb, obj);\n\tif (err < 0)\n\t\tgoto err3;\n\n\tobj->ops = ops;\n\n\tkfree(tb);\n\treturn obj;\nerr3:\n\tkfree(obj);\nerr2:\n\tkfree(tb);\nerr1:\n\treturn ERR_PTR(err);\n}\n\nstatic int nft_object_dump(struct sk_buff *skb, unsigned int attr,\n\t\t\t   struct nft_object *obj, bool reset)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (obj->ops->dump(skb, obj, reset) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_object_type *__nft_obj_type_get(u32 objtype)\n{\n\tconst struct nft_object_type *type;\n\n\tlist_for_each_entry(type, &nf_tables_objects, list) {\n\t\tif (objtype == type->type)\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstatic const struct nft_object_type *\nnft_obj_type_get(struct net *net, u32 objtype)\n{\n\tconst struct nft_object_type *type;\n\n\ttype = __nft_obj_type_get(objtype);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nft-obj-%u\", objtype) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_updobj(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_object_type *type,\n\t\t\t    const struct nlattr *attr,\n\t\t\t    struct nft_object *obj)\n{\n\tstruct nft_object *newobj;\n\tstruct nft_trans *trans;\n\tint err = -ENOMEM;\n\n\tif (!try_module_get(type->owner))\n\t\treturn -ENOENT;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWOBJ,\n\t\t\t\tsizeof(struct nft_trans_obj));\n\tif (!trans)\n\t\tgoto err_trans;\n\n\tnewobj = nft_obj_init(ctx, type, attr);\n\tif (IS_ERR(newobj)) {\n\t\terr = PTR_ERR(newobj);\n\t\tgoto err_free_trans;\n\t}\n\n\tnft_trans_obj(trans) = obj;\n\tnft_trans_obj_update(trans) = true;\n\tnft_trans_obj_newobj(trans) = newobj;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_free_trans:\n\tkfree(trans);\nerr_trans:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_newobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_object_type *type;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_object *obj;\n\tstruct nft_ctx ctx;\n\tu32 objtype;\n\tint err;\n\n\tif (!nla[NFTA_OBJ_TYPE] ||\n\t    !nla[NFTA_OBJ_NAME] ||\n\t    !nla[NFTA_OBJ_DATA])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tobj = nft_obj_lookup(net, table, nla[NFTA_OBJ_NAME], objtype, genmask);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tif (err != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttype = __nft_obj_type_get(objtype);\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updobj(&ctx, type, nla[NFTA_OBJ_DATA], obj);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\ttype = nft_obj_type_get(net, objtype);\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tobj = nft_obj_init(&ctx, type, nla[NFTA_OBJ_DATA]);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto err_init;\n\t}\n\tobj->key.table = table;\n\tobj->handle = nf_tables_alloc_handle(table);\n\n\tobj->key.name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!obj->key.name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_strdup;\n\t}\n\n\tif (nla[NFTA_OBJ_USERDATA]) {\n\t\tobj->udata = nla_memdup(nla[NFTA_OBJ_USERDATA], GFP_KERNEL);\n\t\tif (obj->udata == NULL)\n\t\t\tgoto err_userdata;\n\n\t\tobj->udlen = nla_len(nla[NFTA_OBJ_USERDATA]);\n\t}\n\n\terr = nft_trans_obj_add(&ctx, NFT_MSG_NEWOBJ, obj);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\terr = rhltable_insert(&nft_objname_ht, &obj->rhlhead,\n\t\t\t      nft_objname_ht_params);\n\tif (err < 0)\n\t\tgoto err_obj_ht;\n\n\tlist_add_tail_rcu(&obj->list, &table->objects);\n\ttable->use++;\n\treturn 0;\nerr_obj_ht:\n\t/* queued in transaction log */\n\tINIT_LIST_HEAD(&obj->list);\n\treturn err;\nerr_trans:\n\tkfree(obj->udata);\nerr_userdata:\n\tkfree(obj->key.name);\nerr_strdup:\n\tif (obj->ops->destroy)\n\t\tobj->ops->destroy(&ctx, obj);\n\tkfree(obj);\nerr_init:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_fill_obj_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t   u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t   int family, const struct nft_table *table,\n\t\t\t\t   struct nft_object *obj, bool reset)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_OBJ_TABLE, table->name) ||\n\t    nla_put_string(skb, NFTA_OBJ_NAME, obj->key.name) ||\n\t    nla_put_be32(skb, NFTA_OBJ_TYPE, htonl(obj->ops->type->type)) ||\n\t    nla_put_be32(skb, NFTA_OBJ_USE, htonl(obj->use)) ||\n\t    nft_object_dump(skb, NFTA_OBJ_DATA, obj, reset) ||\n\t    nla_put_be64(skb, NFTA_OBJ_HANDLE, cpu_to_be64(obj->handle),\n\t\t\t NFTA_OBJ_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (obj->udata &&\n\t    nla_put(skb, NFTA_OBJ_USERDATA, obj->udlen, obj->udata))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nft_obj_filter {\n\tchar\t\t*table;\n\tu32\t\ttype;\n};\n\nstatic int nf_tables_dump_obj(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tconst struct nft_table *table;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct nft_obj_filter *filter = cb->data;\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_object *obj;\n\tbool reset = false;\n\n\tif (NFNL_MSG_TYPE(cb->nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)\n\t\treset = true;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(obj, &table->objects, list) {\n\t\t\tif (!nft_is_active(net, obj))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (filter && filter->table &&\n\t\t\t    strcmp(filter->table, table->name))\n\t\t\t\tgoto cont;\n\t\t\tif (filter &&\n\t\t\t    filter->type != NFT_OBJECT_UNSPEC &&\n\t\t\t    obj->ops->type->type != filter->type)\n\t\t\t\tgoto cont;\n\t\t\tif (reset) {\n\t\t\t\tchar *buf = kasprintf(GFP_ATOMIC,\n\t\t\t\t\t\t      \"%s:%u\",\n\t\t\t\t\t\t      table->name,\n\t\t\t\t\t\t      nft_net->base_seq);\n\n\t\t\t\taudit_log_nfcfg(buf,\n\t\t\t\t\t\tfamily,\n\t\t\t\t\t\tobj->handle,\n\t\t\t\t\t\tAUDIT_NFT_OP_OBJ_RESET,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tkfree(buf);\n\t\t\t}\n\n\t\t\tif (nf_tables_fill_obj_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t    NFT_MSG_NEWOBJ,\n\t\t\t\t\t\t    NLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\t\t    table->family, table,\n\t\t\t\t\t\t    obj, reset) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_obj_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_obj_filter *filter = NULL;\n\n\tif (nla[NFTA_OBJ_TABLE] || nla[NFTA_OBJ_TYPE]) {\n\t\tfilter = kzalloc(sizeof(*filter), GFP_ATOMIC);\n\t\tif (!filter)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla[NFTA_OBJ_TABLE]) {\n\t\t\tfilter->table = nla_strdup(nla[NFTA_OBJ_TABLE], GFP_ATOMIC);\n\t\t\tif (!filter->table) {\n\t\t\t\tkfree(filter);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (nla[NFTA_OBJ_TYPE])\n\t\t\tfilter->type = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\t}\n\n\tcb->data = filter;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_obj_done(struct netlink_callback *cb)\n{\n\tstruct nft_obj_filter *filter = cb->data;\n\n\tif (filter) {\n\t\tkfree(filter->table);\n\t\tkfree(filter);\n\t}\n\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct nft_object *obj;\n\tstruct sk_buff *skb2;\n\tbool reset = false;\n\tu32 objtype;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_obj_start,\n\t\t\t.dump = nf_tables_dump_obj,\n\t\t\t.done = nf_tables_dump_obj_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_OBJ_NAME] ||\n\t    !nla[NFTA_OBJ_TYPE])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tobj = nft_obj_lookup(net, table, nla[NFTA_OBJ_NAME], objtype, genmask);\n\tif (IS_ERR(obj)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\treturn PTR_ERR(obj);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tif (NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)\n\t\treset = true;\n\n\tif (reset) {\n\t\tconst struct nftables_pernet *nft_net;\n\t\tchar *buf;\n\n\t\tnft_net = nft_pernet(net);\n\t\tbuf = kasprintf(GFP_ATOMIC, \"%s:%u\", table->name, nft_net->base_seq);\n\n\t\taudit_log_nfcfg(buf,\n\t\t\t\tfamily,\n\t\t\t\tobj->handle,\n\t\t\t\tAUDIT_NFT_OP_OBJ_RESET,\n\t\t\t\tGFP_ATOMIC);\n\t\tkfree(buf);\n\t}\n\n\terr = nf_tables_fill_obj_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t      info->nlh->nlmsg_seq, NFT_MSG_NEWOBJ, 0,\n\t\t\t\t      family, table, obj, reset);\n\tif (err < 0)\n\t\tgoto err_fill_obj_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_obj_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nft_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tif (obj->ops->destroy)\n\t\tobj->ops->destroy(ctx, obj);\n\n\tmodule_put(obj->ops->type->owner);\n\tkfree(obj->key.name);\n\tkfree(obj->udata);\n\tkfree(obj);\n}\n\nstatic int nf_tables_delobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_object *obj;\n\tstruct nft_ctx ctx;\n\tu32 objtype;\n\n\tif (!nla[NFTA_OBJ_TYPE] ||\n\t    (!nla[NFTA_OBJ_NAME] && !nla[NFTA_OBJ_HANDLE]))\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tif (nla[NFTA_OBJ_HANDLE]) {\n\t\tattr = nla[NFTA_OBJ_HANDLE];\n\t\tobj = nft_obj_lookup_byhandle(table, attr, objtype, genmask);\n\t} else {\n\t\tattr = nla[NFTA_OBJ_NAME];\n\t\tobj = nft_obj_lookup(net, table, attr, objtype, genmask);\n\t}\n\n\tif (IS_ERR(obj)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(obj);\n\t}\n\tif (obj->use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\treturn nft_delobj(&ctx, obj);\n}\n\nvoid nft_obj_notify(struct net *net, const struct nft_table *table,\n\t\t    struct nft_object *obj, u32 portid, u32 seq, int event,\n\t\t    u16 flags, int family, int report, gfp_t gfp)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct sk_buff *skb;\n\tint err;\n\tchar *buf = kasprintf(gfp, \"%s:%u\",\n\t\t\t      table->name, nft_net->base_seq);\n\n\taudit_log_nfcfg(buf,\n\t\t\tfamily,\n\t\t\tobj->handle,\n\t\t\tevent == NFT_MSG_NEWOBJ ?\n\t\t\t\t AUDIT_NFT_OP_OBJ_REGISTER :\n\t\t\t\t AUDIT_NFT_OP_OBJ_UNREGISTER,\n\t\t\tgfp);\n\tkfree(buf);\n\n\tif (!report &&\n\t    !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\terr = nf_tables_fill_obj_info(skb, net, portid, seq, event,\n\t\t\t\t      flags & (NLM_F_CREATE | NLM_F_EXCL),\n\t\t\t\t      family, table, obj, false);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\nEXPORT_SYMBOL_GPL(nft_obj_notify);\n\nstatic void nf_tables_obj_notify(const struct nft_ctx *ctx,\n\t\t\t\t struct nft_object *obj, int event)\n{\n\tnft_obj_notify(ctx->net, ctx->table, obj, ctx->portid, ctx->seq, event,\n\t\t       ctx->flags, ctx->family, ctx->report, GFP_KERNEL);\n}\n\n/*\n * Flow tables\n */\nvoid nft_register_flowtable_type(struct nf_flowtable_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_add_tail_rcu(&type->list, &nf_tables_flowtables);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_register_flowtable_type);\n\nvoid nft_unregister_flowtable_type(struct nf_flowtable_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_flowtable_type);\n\nstatic const struct nla_policy nft_flowtable_policy[NFTA_FLOWTABLE_MAX + 1] = {\n\t[NFTA_FLOWTABLE_TABLE]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_NAME_MAXLEN - 1 },\n\t[NFTA_FLOWTABLE_NAME]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_NAME_MAXLEN - 1 },\n\t[NFTA_FLOWTABLE_HOOK]\t\t= { .type = NLA_NESTED },\n\t[NFTA_FLOWTABLE_HANDLE]\t\t= { .type = NLA_U64 },\n\t[NFTA_FLOWTABLE_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\nstruct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla, u8 genmask)\n{\n\tstruct nft_flowtable *flowtable;\n\n\tlist_for_each_entry_rcu(flowtable, &table->flowtables, list) {\n\t\tif (!nla_strcmp(nla, flowtable->name) &&\n\t\t    nft_active_genmask(flowtable, genmask))\n\t\t\treturn flowtable;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\nEXPORT_SYMBOL_GPL(nft_flowtable_lookup);\n\nvoid nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_flowtable *flowtable,\n\t\t\t\t    enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tflowtable->use--;\n\t\tfallthrough;\n\tdefault:\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_tables_deactivate_flowtable);\n\nstatic struct nft_flowtable *\nnft_flowtable_lookup_byhandle(const struct nft_table *table,\n\t\t\t      const struct nlattr *nla, u8 genmask)\n{\n       struct nft_flowtable *flowtable;\n\n       list_for_each_entry(flowtable, &table->flowtables, list) {\n               if (be64_to_cpu(nla_get_be64(nla)) == flowtable->handle &&\n                   nft_active_genmask(flowtable, genmask))\n                       return flowtable;\n       }\n       return ERR_PTR(-ENOENT);\n}\n\nstruct nft_flowtable_hook {\n\tu32\t\t\tnum;\n\tint\t\t\tpriority;\n\tstruct list_head\tlist;\n};\n\nstatic const struct nla_policy nft_flowtable_hook_policy[NFTA_FLOWTABLE_HOOK_MAX + 1] = {\n\t[NFTA_FLOWTABLE_HOOK_NUM]\t= { .type = NLA_U32 },\n\t[NFTA_FLOWTABLE_HOOK_PRIORITY]\t= { .type = NLA_U32 },\n\t[NFTA_FLOWTABLE_HOOK_DEVS]\t= { .type = NLA_NESTED },\n};\n\nstatic int nft_flowtable_parse_hook(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nlattr *attr,\n\t\t\t\t    struct nft_flowtable_hook *flowtable_hook,\n\t\t\t\t    struct nft_flowtable *flowtable, bool add)\n{\n\tstruct nlattr *tb[NFTA_FLOWTABLE_HOOK_MAX + 1];\n\tstruct nft_hook *hook;\n\tint hooknum, priority;\n\tint err;\n\n\tINIT_LIST_HEAD(&flowtable_hook->list);\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_FLOWTABLE_HOOK_MAX, attr,\n\t\t\t\t\t  nft_flowtable_hook_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (add) {\n\t\tif (!tb[NFTA_FLOWTABLE_HOOK_NUM] ||\n\t\t    !tb[NFTA_FLOWTABLE_HOOK_PRIORITY])\n\t\t\treturn -EINVAL;\n\n\t\thooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));\n\t\tif (hooknum != NF_NETDEV_INGRESS)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tpriority = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_PRIORITY]));\n\n\t\tflowtable_hook->priority\t= priority;\n\t\tflowtable_hook->num\t\t= hooknum;\n\t} else {\n\t\tif (tb[NFTA_FLOWTABLE_HOOK_NUM]) {\n\t\t\thooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));\n\t\t\tif (hooknum != flowtable->hooknum)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (tb[NFTA_FLOWTABLE_HOOK_PRIORITY]) {\n\t\t\tpriority = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_PRIORITY]));\n\t\t\tif (priority != flowtable->data.priority)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tflowtable_hook->priority\t= flowtable->data.priority;\n\t\tflowtable_hook->num\t\t= flowtable->hooknum;\n\t}\n\n\tif (tb[NFTA_FLOWTABLE_HOOK_DEVS]) {\n\t\terr = nf_tables_parse_netdev_hooks(ctx->net,\n\t\t\t\t\t\t   tb[NFTA_FLOWTABLE_HOOK_DEVS],\n\t\t\t\t\t\t   &flowtable_hook->list);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tlist_for_each_entry(hook, &flowtable_hook->list, list) {\n\t\thook->ops.pf\t\t= NFPROTO_NETDEV;\n\t\thook->ops.hooknum\t= flowtable_hook->num;\n\t\thook->ops.priority\t= flowtable_hook->priority;\n\t\thook->ops.priv\t\t= &flowtable->data;\n\t\thook->ops.hook\t\t= flowtable->data.type->hook;\n\t}\n\n\treturn err;\n}\n\nstatic const struct nf_flowtable_type *__nft_flowtable_type_get(u8 family)\n{\n\tconst struct nf_flowtable_type *type;\n\n\tlist_for_each_entry(type, &nf_tables_flowtables, list) {\n\t\tif (family == type->family)\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstatic const struct nf_flowtable_type *\nnft_flowtable_type_get(struct net *net, u8 family)\n{\n\tconst struct nf_flowtable_type *type;\n\n\ttype = __nft_flowtable_type_get(family);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nf-flowtable-%u\", family) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\n/* Only called from error and netdev event paths. */\nstatic void nft_unregister_flowtable_hook(struct net *net,\n\t\t\t\t\t  struct nft_flowtable *flowtable,\n\t\t\t\t\t  struct nft_hook *hook)\n{\n\tnf_unregister_net_hook(net, &hook->ops);\n\tflowtable->data.type->setup(&flowtable->data, hook->ops.dev,\n\t\t\t\t    FLOW_BLOCK_UNBIND);\n}\n\nstatic void __nft_unregister_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t\t struct list_head *hook_list,\n\t\t\t\t\t         bool release_netdev)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t\tif (release_netdev) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree_rcu(hook, rcu);\n\t\t}\n\t}\n}\n\nstatic void nft_unregister_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t       struct list_head *hook_list)\n{\n\t__nft_unregister_flowtable_net_hooks(net, hook_list, false);\n}\n\nstatic int nft_register_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t    struct nft_table *table,\n\t\t\t\t\t    struct list_head *hook_list,\n\t\t\t\t\t    struct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook, *hook2, *next;\n\tstruct nft_flowtable *ft;\n\tint err, i = 0;\n\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tlist_for_each_entry(ft, &table->flowtables, list) {\n\t\t\tif (!nft_is_active_next(net, ft))\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(hook2, &ft->hook_list, list) {\n\t\t\t\tif (hook->ops.dev == hook2->ops.dev &&\n\t\t\t\t    hook->ops.pf == hook2->ops.pf) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tgoto err_unregister_net_hooks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\terr = flowtable->data.type->setup(&flowtable->data,\n\t\t\t\t\t\t  hook->ops.dev,\n\t\t\t\t\t\t  FLOW_BLOCK_BIND);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_net_hooks;\n\n\t\terr = nf_register_net_hook(net, &hook->ops);\n\t\tif (err < 0) {\n\t\t\tflowtable->data.type->setup(&flowtable->data,\n\t\t\t\t\t\t    hook->ops.dev,\n\t\t\t\t\t\t    FLOW_BLOCK_UNBIND);\n\t\t\tgoto err_unregister_net_hooks;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n\nerr_unregister_net_hooks:\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tif (i-- <= 0)\n\t\t\tbreak;\n\n\t\tnft_unregister_flowtable_hook(net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n\n\treturn err;\n}\n\nstatic void nft_flowtable_hooks_destroy(struct list_head *hook_list)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n}\n\nstatic int nft_flowtable_update(struct nft_ctx *ctx, const struct nlmsghdr *nlh,\n\t\t\t\tstruct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tstruct nft_hook *hook, *next;\n\tstruct nft_trans *trans;\n\tbool unregister = false;\n\tu32 flags;\n\tint err;\n\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tlist_for_each_entry_safe(hook, next, &flowtable_hook.list, list) {\n\t\tif (nft_hook_list_find(&flowtable->hook_list, hook)) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree(hook);\n\t\t}\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_FLOWTABLE_FLAGS]));\n\t\tif (flags & ~NFT_FLOWTABLE_MASK) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_flowtable_update_hook;\n\t\t}\n\t\tif ((flowtable->data.flags & NFT_FLOWTABLE_HW_OFFLOAD) ^\n\t\t    (flags & NFT_FLOWTABLE_HW_OFFLOAD)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_flowtable_update_hook;\n\t\t}\n\t} else {\n\t\tflags = flowtable->data.flags;\n\t}\n\n\terr = nft_register_flowtable_net_hooks(ctx->net, ctx->table,\n\t\t\t\t\t       &flowtable_hook.list, flowtable);\n\tif (err < 0)\n\t\tgoto err_flowtable_update_hook;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\tunregister = true;\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_update_hook;\n\t}\n\n\tnft_trans_flowtable_flags(trans) = flags;\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_hook.list, &nft_trans_flowtable_hooks(trans));\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_flowtable_update_hook:\n\tlist_for_each_entry_safe(hook, next, &flowtable_hook.list, list) {\n\t\tif (unregister)\n\t\t\tnft_unregister_flowtable_hook(ctx->net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n\n\treturn err;\n\n}\n\nstatic int nf_tables_newflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nf_flowtable_type *type;\n\tstruct nft_flowtable *flowtable;\n\tstruct nft_hook *hook, *next;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tint err;\n\n\tif (!nla[NFTA_FLOWTABLE_TABLE] ||\n\t    !nla[NFTA_FLOWTABLE_NAME] ||\n\t    !nla[NFTA_FLOWTABLE_HOOK])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tflowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],\n\t\t\t\t\t genmask);\n\tif (IS_ERR(flowtable)) {\n\t\terr = PTR_ERR(flowtable);\n\t\tif (err != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nft_flowtable_update(&ctx, info->nlh, flowtable);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tflowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL_ACCOUNT);\n\tif (!flowtable)\n\t\treturn -ENOMEM;\n\n\tflowtable->table = table;\n\tflowtable->handle = nf_tables_alloc_handle(table);\n\tINIT_LIST_HEAD(&flowtable->hook_list);\n\n\tflowtable->name = nla_strdup(nla[NFTA_FLOWTABLE_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!flowtable->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\ttype = nft_flowtable_type_get(net, family);\n\tif (IS_ERR(type)) {\n\t\terr = PTR_ERR(type);\n\t\tgoto err2;\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_FLAGS]) {\n\t\tflowtable->data.flags =\n\t\t\tntohl(nla_get_be32(nla[NFTA_FLOWTABLE_FLAGS]));\n\t\tif (flowtable->data.flags & ~NFT_FLOWTABLE_MASK) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\twrite_pnet(&flowtable->data.net, net);\n\tflowtable->data.type = type;\n\terr = type->init(&flowtable->data);\n\tif (err < 0)\n\t\tgoto err3;\n\n\terr = nft_flowtable_parse_hook(&ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, true);\n\tif (err < 0)\n\t\tgoto err4;\n\n\tlist_splice(&flowtable_hook.list, &flowtable->hook_list);\n\tflowtable->data.priority = flowtable_hook.priority;\n\tflowtable->hooknum = flowtable_hook.num;\n\n\terr = nft_register_flowtable_net_hooks(ctx.net, table,\n\t\t\t\t\t       &flowtable->hook_list,\n\t\t\t\t\t       flowtable);\n\tif (err < 0) {\n\t\tnft_flowtable_hooks_destroy(&flowtable->hook_list);\n\t\tgoto err4;\n\t}\n\n\terr = nft_trans_flowtable_add(&ctx, NFT_MSG_NEWFLOWTABLE, flowtable);\n\tif (err < 0)\n\t\tgoto err5;\n\n\tlist_add_tail_rcu(&flowtable->list, &table->flowtables);\n\ttable->use++;\n\n\treturn 0;\nerr5:\n\tlist_for_each_entry_safe(hook, next, &flowtable->hook_list, list) {\n\t\tnft_unregister_flowtable_hook(net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\nerr4:\n\tflowtable->data.type->free(&flowtable->data);\nerr3:\n\tmodule_put(type->owner);\nerr2:\n\tkfree(flowtable->name);\nerr1:\n\tkfree(flowtable);\n\treturn err;\n}\n\nstatic void nft_flowtable_hook_release(struct nft_flowtable_hook *flowtable_hook)\n{\n\tstruct nft_hook *this, *next;\n\n\tlist_for_each_entry_safe(this, next, &flowtable_hook->list, list) {\n\t\tlist_del(&this->list);\n\t\tkfree(this);\n\t}\n}\n\nstatic int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\n\treturn err;\n}\n\nstatic int nf_tables_delflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\n\tif (!nla[NFTA_FLOWTABLE_TABLE] ||\n\t    (!nla[NFTA_FLOWTABLE_NAME] &&\n\t     !nla[NFTA_FLOWTABLE_HANDLE]))\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_HANDLE]) {\n\t\tattr = nla[NFTA_FLOWTABLE_HANDLE];\n\t\tflowtable = nft_flowtable_lookup_byhandle(table, attr, genmask);\n\t} else {\n\t\tattr = nla[NFTA_FLOWTABLE_NAME];\n\t\tflowtable = nft_flowtable_lookup(table, attr, genmask);\n\t}\n\n\tif (IS_ERR(flowtable)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(flowtable);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (nla[NFTA_FLOWTABLE_HOOK])\n\t\treturn nft_delflowtable_hook(&ctx, flowtable);\n\n\tif (flowtable->use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\treturn nft_delflowtable(&ctx, flowtable);\n}\n\nstatic int nf_tables_fill_flowtable_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t\t u32 portid, u32 seq, int event,\n\t\t\t\t\t u32 flags, int family,\n\t\t\t\t\t struct nft_flowtable *flowtable,\n\t\t\t\t\t struct list_head *hook_list)\n{\n\tstruct nlattr *nest, *nest_devs;\n\tstruct nft_hook *hook;\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_FLOWTABLE_TABLE, flowtable->table->name) ||\n\t    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_USE, htonl(flowtable->use)) ||\n\t    nla_put_be64(skb, NFTA_FLOWTABLE_HANDLE, cpu_to_be64(flowtable->handle),\n\t\t\t NFTA_FLOWTABLE_PAD) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_FLAGS, htonl(flowtable->data.flags)))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_FLOWTABLE_HOOK);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_NUM, htonl(flowtable->hooknum)) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_PRIORITY, htonl(flowtable->data.priority)))\n\t\tgoto nla_put_failure;\n\n\tnest_devs = nla_nest_start_noflag(skb, NFTA_FLOWTABLE_HOOK_DEVS);\n\tif (!nest_devs)\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry_rcu(hook, hook_list, list) {\n\t\tif (nla_put_string(skb, NFTA_DEVICE_NAME, hook->ops.dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest_devs);\n\tnla_nest_end(skb, nest);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nft_flowtable_filter {\n\tchar\t\t*table;\n};\n\nstatic int nf_tables_dump_flowtable(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nft_flowtable_filter *filter = cb->data;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(flowtable, &table->flowtables, list) {\n\t\t\tif (!nft_is_active(net, flowtable))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (filter && filter->table &&\n\t\t\t    strcmp(filter->table, table->name))\n\t\t\t\tgoto cont;\n\n\t\t\tif (nf_tables_fill_flowtable_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t\t  cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t\t  NFT_MSG_NEWFLOWTABLE,\n\t\t\t\t\t\t\t  NLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\t\t\t  table->family,\n\t\t\t\t\t\t\t  flowtable,\n\t\t\t\t\t\t\t  &flowtable->hook_list) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_flowtable_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_flowtable_filter *filter = NULL;\n\n\tif (nla[NFTA_FLOWTABLE_TABLE]) {\n\t\tfilter = kzalloc(sizeof(*filter), GFP_ATOMIC);\n\t\tif (!filter)\n\t\t\treturn -ENOMEM;\n\n\t\tfilter->table = nla_strdup(nla[NFTA_FLOWTABLE_TABLE],\n\t\t\t\t\t   GFP_ATOMIC);\n\t\tif (!filter->table) {\n\t\t\tkfree(filter);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tcb->data = filter;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_flowtable_done(struct netlink_callback *cb)\n{\n\tstruct nft_flowtable_filter *filter = cb->data;\n\n\tif (!filter)\n\t\treturn 0;\n\n\tkfree(filter->table);\n\tkfree(filter);\n\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_flowtable_start,\n\t\t\t.dump = nf_tables_dump_flowtable,\n\t\t\t.done = nf_tables_dump_flowtable_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_FLOWTABLE_NAME])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, 0);\n\tif (IS_ERR(table))\n\t\treturn PTR_ERR(table);\n\n\tflowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],\n\t\t\t\t\t genmask);\n\tif (IS_ERR(flowtable))\n\t\treturn PTR_ERR(flowtable);\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_flowtable_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\t    info->nlh->nlmsg_seq,\n\t\t\t\t\t    NFT_MSG_NEWFLOWTABLE, 0, family,\n\t\t\t\t\t    flowtable, &flowtable->hook_list);\n\tif (err < 0)\n\t\tgoto err_fill_flowtable_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_flowtable_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nf_tables_flowtable_notify(struct nft_ctx *ctx,\n\t\t\t\t       struct nft_flowtable *flowtable,\n\t\t\t\t       struct list_head *hook_list,\n\t\t\t\t       int event)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_flowtable_info(skb, ctx->net, ctx->portid,\n\t\t\t\t\t    ctx->seq, event, flags,\n\t\t\t\t\t    ctx->family, flowtable, hook_list);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic void nf_tables_flowtable_destroy(struct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook, *next;\n\n\tflowtable->data.type->free(&flowtable->data);\n\tlist_for_each_entry_safe(hook, next, &flowtable->hook_list, list) {\n\t\tflowtable->data.type->setup(&flowtable->data, hook->ops.dev,\n\t\t\t\t\t    FLOW_BLOCK_UNBIND);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree(hook);\n\t}\n\tkfree(flowtable->name);\n\tmodule_put(flowtable->data.type->owner);\n\tkfree(flowtable);\n}\n\nstatic int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t   u32 portid, u32 seq)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nlmsghdr *nlh;\n\tchar buf[TASK_COMM_LEN];\n\tint event = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_NEWGEN);\n\n\tnlh = nfnl_msg_put(skb, portid, seq, event, 0, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_GEN_ID, htonl(nft_net->base_seq)) ||\n\t    nla_put_be32(skb, NFTA_GEN_PROC_PID, htonl(task_pid_nr(current))) ||\n\t    nla_put_string(skb, NFTA_GEN_PROC_NAME, get_task_comm(buf, current)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void nft_flowtable_event(unsigned long event, struct net_device *dev,\n\t\t\t\tstruct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook;\n\n\tlist_for_each_entry(hook, &flowtable->hook_list, list) {\n\t\tif (hook->ops.dev != dev)\n\t\t\tcontinue;\n\n\t\t/* flow_offload_netdev_event() cleans up entries for us. */\n\t\tnft_unregister_flowtable_hook(dev_net(dev), flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t\tbreak;\n\t}\n}\n\nstatic int nf_tables_flowtable_event(struct notifier_block *this,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct nft_flowtable *flowtable;\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\tstruct net *net;\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn 0;\n\n\tnet = dev_net(dev);\n\tnft_net = nft_pernet(net);\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tlist_for_each_entry(flowtable, &table->flowtables, list) {\n\t\t\tnft_flowtable_event(event, dev, flowtable);\n\t\t}\n\t}\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nf_tables_flowtable_notifier = {\n\t.notifier_call\t= nf_tables_flowtable_event,\n};\n\nstatic void nf_tables_gen_notify(struct net *net, struct sk_buff *skb,\n\t\t\t\t int event)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (!nlmsg_report(nlh) &&\n\t    !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb2 = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb2 == NULL)\n\t\tgoto err;\n\n\terr = nf_tables_fill_gen_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t      nlh->nlmsg_seq);\n\tif (err < 0) {\n\t\tkfree_skb(skb2);\n\t\tgoto err;\n\t}\n\n\tnfnetlink_send(skb2, net, NETLINK_CB(skb).portid, NFNLGRP_NFTABLES,\n\t\t       nlmsg_report(nlh), GFP_KERNEL);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, NETLINK_CB(skb).portid, NFNLGRP_NFTABLES,\n\t\t\t  -ENOBUFS);\n}\n\nstatic int nf_tables_getgen(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_gen_info(skb2, info->net, NETLINK_CB(skb).portid,\n\t\t\t\t      info->nlh->nlmsg_seq);\n\tif (err < 0)\n\t\tgoto err_fill_gen_info;\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nerr_fill_gen_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nfnl_callback nf_tables_cb[NFT_MSG_MAX] = {\n\t[NFT_MSG_NEWTABLE] = {\n\t\t.call\t\t= nf_tables_newtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_GETTABLE] = {\n\t\t.call\t\t= nf_tables_gettable,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_DELTABLE] = {\n\t\t.call\t\t= nf_tables_deltable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_NEWCHAIN] = {\n\t\t.call\t\t= nf_tables_newchain,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_GETCHAIN] = {\n\t\t.call\t\t= nf_tables_getchain,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_DELCHAIN] = {\n\t\t.call\t\t= nf_tables_delchain,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_NEWRULE] = {\n\t\t.call\t\t= nf_tables_newrule,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_GETRULE] = {\n\t\t.call\t\t= nf_tables_getrule,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_DELRULE] = {\n\t\t.call\t\t= nf_tables_delrule,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_NEWSET] = {\n\t\t.call\t\t= nf_tables_newset,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_GETSET] = {\n\t\t.call\t\t= nf_tables_getset,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_DELSET] = {\n\t\t.call\t\t= nf_tables_delset,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_NEWSETELEM] = {\n\t\t.call\t\t= nf_tables_newsetelem,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_GETSETELEM] = {\n\t\t.call\t\t= nf_tables_getsetelem,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_DELSETELEM] = {\n\t\t.call\t\t= nf_tables_delsetelem,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_GETGEN] = {\n\t\t.call\t\t= nf_tables_getgen,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t},\n\t[NFT_MSG_NEWOBJ] = {\n\t\t.call\t\t= nf_tables_newobj,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_GETOBJ] = {\n\t\t.call\t\t= nf_tables_getobj,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_DELOBJ] = {\n\t\t.call\t\t= nf_tables_delobj,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_GETOBJ_RESET] = {\n\t\t.call\t\t= nf_tables_getobj,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_NEWFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_newflowtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n\t[NFT_MSG_GETFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_getflowtable,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n\t[NFT_MSG_DELFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_delflowtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n};\n\nstatic int nf_tables_validate(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table;\n\n\tswitch (nft_net->validate_state) {\n\tcase NFT_VALIDATE_SKIP:\n\t\tbreak;\n\tcase NFT_VALIDATE_NEED:\n\t\tnft_validate_state_update(net, NFT_VALIDATE_DO);\n\t\tfallthrough;\n\tcase NFT_VALIDATE_DO:\n\t\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\t\tif (nft_table_validate(net, table) < 0)\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* a drop policy has to be deferred until all rules have been activated,\n * otherwise a large ruleset that contains a drop-policy base chain will\n * cause all packets to get dropped until the full transaction has been\n * processed.\n *\n * We defer the drop policy until the transaction has been finalized.\n */\nstatic void nft_chain_commit_drop_policy(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_trans_chain_policy(trans) != NF_DROP)\n\t\treturn;\n\n\tif (!nft_is_base_chain(trans->ctx.chain))\n\t\treturn;\n\n\tbasechain = nft_base_chain(trans->ctx.chain);\n\tbasechain->policy = NF_DROP;\n}\n\nstatic void nft_chain_commit_update(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_trans_chain_name(trans)) {\n\t\trhltable_remove(&trans->ctx.table->chains_ht,\n\t\t\t\t&trans->ctx.chain->rhlhead,\n\t\t\t\tnft_chain_ht_params);\n\t\tswap(trans->ctx.chain->name, nft_trans_chain_name(trans));\n\t\trhltable_insert_key(&trans->ctx.table->chains_ht,\n\t\t\t\t    trans->ctx.chain->name,\n\t\t\t\t    &trans->ctx.chain->rhlhead,\n\t\t\t\t    nft_chain_ht_params);\n\t}\n\n\tif (!nft_is_base_chain(trans->ctx.chain))\n\t\treturn;\n\n\tnft_chain_stats_replace(trans);\n\n\tbasechain = nft_base_chain(trans->ctx.chain);\n\n\tswitch (nft_trans_chain_policy(trans)) {\n\tcase NF_DROP:\n\tcase NF_ACCEPT:\n\t\tbasechain->policy = nft_trans_chain_policy(trans);\n\t\tbreak;\n\t}\n}\n\nstatic void nft_obj_commit_update(struct nft_trans *trans)\n{\n\tstruct nft_object *newobj;\n\tstruct nft_object *obj;\n\n\tobj = nft_trans_obj(trans);\n\tnewobj = nft_trans_obj_newobj(trans);\n\n\tif (obj->ops->update)\n\t\tobj->ops->update(obj, newobj);\n\n\tnft_obj_destroy(&trans->ctx, newobj);\n}\n\nstatic void nft_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWCHAIN:\n\t\tfree_percpu(nft_trans_chain_stats(trans));\n\t\tkfree(nft_trans_chain_name(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(&trans->ctx, nft_trans_set(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSETELEM:\n\t\tnf_tables_set_elem_destroy(&trans->ctx,\n\t\t\t\t\t   nft_trans_elem_set(trans),\n\t\t\t\t\t   nft_trans_elem(trans).priv);\n\t\tbreak;\n\tcase NFT_MSG_DELOBJ:\n\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELFLOWTABLE:\n\t\tif (nft_trans_flowtable_update(trans))\n\t\t\tnft_flowtable_hooks_destroy(&nft_trans_flowtable_hooks(trans));\n\t\telse\n\t\t\tnf_tables_flowtable_destroy(nft_trans_flowtable(trans));\n\t\tbreak;\n\t}\n\n\tif (trans->put_net)\n\t\tput_net(trans->ctx.net);\n\n\tkfree(trans);\n}\n\nstatic void nf_tables_trans_destroy_work(struct work_struct *w)\n{\n\tstruct nft_trans *trans, *next;\n\tLIST_HEAD(head);\n\n\tspin_lock(&nf_tables_destroy_list_lock);\n\tlist_splice_init(&nf_tables_destroy_list, &head);\n\tspin_unlock(&nf_tables_destroy_list_lock);\n\n\tif (list_empty(&head))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(trans, next, &head, list) {\n\t\tlist_del(&trans->list);\n\t\tnft_commit_release(trans);\n\t}\n}\n\nvoid nf_tables_trans_destroy_flush_work(void)\n{\n\tflush_work(&trans_destroy_work);\n}\nEXPORT_SYMBOL_GPL(nf_tables_trans_destroy_flush_work);\n\nstatic bool nft_expr_reduce(struct nft_regs_track *track,\n\t\t\t    const struct nft_expr *expr)\n{\n\treturn false;\n}\n\nstatic int nf_tables_commit_chain_prepare(struct net *net, struct nft_chain *chain)\n{\n\tconst struct nft_expr *expr, *last;\n\tstruct nft_regs_track track = {};\n\tunsigned int size, data_size;\n\tvoid *data, *data_boundary;\n\tstruct nft_rule_dp *prule;\n\tstruct nft_rule *rule;\n\n\t/* already handled or inactive chain? */\n\tif (chain->blob_next || !nft_is_active_next(net, chain))\n\t\treturn 0;\n\n\tdata_size = 0;\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (nft_is_active_next(net, rule)) {\n\t\t\tdata_size += sizeof(*prule) + rule->dlen;\n\t\t\tif (data_size > INT_MAX)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tdata_size += offsetof(struct nft_rule_dp, data);\t/* last rule */\n\n\tchain->blob_next = nf_tables_chain_alloc_rules(data_size);\n\tif (!chain->blob_next)\n\t\treturn -ENOMEM;\n\n\tdata = (void *)chain->blob_next->data;\n\tdata_boundary = data + data_size;\n\tsize = 0;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(net, rule))\n\t\t\tcontinue;\n\n\t\tprule = (struct nft_rule_dp *)data;\n\t\tdata += offsetof(struct nft_rule_dp, data);\n\t\tif (WARN_ON_ONCE(data > data_boundary))\n\t\t\treturn -ENOMEM;\n\n\t\tsize = 0;\n\t\ttrack.last = nft_expr_last(rule);\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\ttrack.cur = expr;\n\n\t\t\tif (nft_expr_reduce(&track, expr)) {\n\t\t\t\texpr = track.cur;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON_ONCE(data + expr->ops->size > data_boundary))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(data + size, expr, expr->ops->size);\n\t\t\tsize += expr->ops->size;\n\t\t}\n\t\tif (WARN_ON_ONCE(size >= 1 << 12))\n\t\t\treturn -ENOMEM;\n\n\t\tprule->handle = rule->handle;\n\t\tprule->dlen = size;\n\t\tprule->is_last = 0;\n\n\t\tdata += size;\n\t\tsize = 0;\n\t\tchain->blob_next->size += (unsigned long)(data - (void *)prule);\n\t}\n\n\tprule = (struct nft_rule_dp *)data;\n\tdata += offsetof(struct nft_rule_dp, data);\n\tif (WARN_ON_ONCE(data > data_boundary))\n\t\treturn -ENOMEM;\n\n\tnft_last_rule(chain->blob_next, prule);\n\n\treturn 0;\n}\n\nstatic void nf_tables_commit_chain_prepare_cancel(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tstruct nft_chain *chain = trans->ctx.chain;\n\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE ||\n\t\t    trans->msg_type == NFT_MSG_DELRULE) {\n\t\t\tkvfree(chain->blob_next);\n\t\t\tchain->blob_next = NULL;\n\t\t}\n\t}\n}\n\nstatic void __nf_tables_commit_chain_free_rules_old(struct rcu_head *h)\n{\n\tstruct nft_rules_old *o = container_of(h, struct nft_rules_old, h);\n\n\tkvfree(o->blob);\n}\n\nstatic void nf_tables_commit_chain_free_rules_old(struct nft_rule_blob *blob)\n{\n\tstruct nft_rules_old *old;\n\n\t/* rcu_head is after end marker */\n\told = (void *)blob + sizeof(*blob) + blob->size;\n\told->blob = blob;\n\n\tcall_rcu(&old->h, __nf_tables_commit_chain_free_rules_old);\n}\n\nstatic void nf_tables_commit_chain(struct net *net, struct nft_chain *chain)\n{\n\tstruct nft_rule_blob *g0, *g1;\n\tbool next_genbit;\n\n\tnext_genbit = nft_gencursor_next(net);\n\n\tg0 = rcu_dereference_protected(chain->blob_gen_0,\n\t\t\t\t       lockdep_commit_lock_is_held(net));\n\tg1 = rcu_dereference_protected(chain->blob_gen_1,\n\t\t\t\t       lockdep_commit_lock_is_held(net));\n\n\t/* No changes to this chain? */\n\tif (chain->blob_next == NULL) {\n\t\t/* chain had no change in last or next generation */\n\t\tif (g0 == g1)\n\t\t\treturn;\n\t\t/*\n\t\t * chain had no change in this generation; make sure next\n\t\t * one uses same rules as current generation.\n\t\t */\n\t\tif (next_genbit) {\n\t\t\trcu_assign_pointer(chain->blob_gen_1, g0);\n\t\t\tnf_tables_commit_chain_free_rules_old(g1);\n\t\t} else {\n\t\t\trcu_assign_pointer(chain->blob_gen_0, g1);\n\t\t\tnf_tables_commit_chain_free_rules_old(g0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (next_genbit)\n\t\trcu_assign_pointer(chain->blob_gen_1, chain->blob_next);\n\telse\n\t\trcu_assign_pointer(chain->blob_gen_0, chain->blob_next);\n\n\tchain->blob_next = NULL;\n\n\tif (g0 == g1)\n\t\treturn;\n\n\tif (next_genbit)\n\t\tnf_tables_commit_chain_free_rules_old(g1);\n\telse\n\t\tnf_tables_commit_chain_free_rules_old(g0);\n}\n\nstatic void nft_obj_del(struct nft_object *obj)\n{\n\trhltable_remove(&nft_objname_ht, &obj->rhlhead, nft_objname_ht_params);\n\tlist_del_rcu(&obj->list);\n}\n\nvoid nft_chain_del(struct nft_chain *chain)\n{\n\tstruct nft_table *table = chain->table;\n\n\tWARN_ON_ONCE(rhltable_remove(&table->chains_ht, &chain->rhlhead,\n\t\t\t\t     nft_chain_ht_params));\n\tlist_del_rcu(&chain->list);\n}\n\nstatic void nf_tables_module_autoload_cleanup(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_module_request *req, *next;\n\n\tWARN_ON_ONCE(!list_empty(&nft_net->commit_list));\n\tlist_for_each_entry_safe(req, next, &nft_net->module_list, list) {\n\t\tWARN_ON_ONCE(!req->done);\n\t\tlist_del(&req->list);\n\t\tkfree(req);\n\t}\n}\n\nstatic void nf_tables_commit_release(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans;\n\n\t/* all side effects have to be made visible.\n\t * For example, if a chain named 'foo' has been deleted, a\n\t * new transaction must not find it anymore.\n\t *\n\t * Memory reclaim happens asynchronously from work queue\n\t * to prevent expensive synchronize_rcu() in commit phase.\n\t */\n\tif (list_empty(&nft_net->commit_list)) {\n\t\tnf_tables_module_autoload_cleanup(net);\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\t\treturn;\n\t}\n\n\ttrans = list_last_entry(&nft_net->commit_list,\n\t\t\t\tstruct nft_trans, list);\n\tget_net(trans->ctx.net);\n\tWARN_ON_ONCE(trans->put_net);\n\n\ttrans->put_net = true;\n\tspin_lock(&nf_tables_destroy_list_lock);\n\tlist_splice_tail_init(&nft_net->commit_list, &nf_tables_destroy_list);\n\tspin_unlock(&nf_tables_destroy_list_lock);\n\n\tnf_tables_module_autoload_cleanup(net);\n\tschedule_work(&trans_destroy_work);\n\n\tmutex_unlock(&nft_net->commit_mutex);\n}\n\nstatic void nft_commit_notify(struct net *net, u32 portid)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct sk_buff *batch_skb = NULL, *nskb, *skb;\n\tunsigned char *data;\n\tint len;\n\n\tlist_for_each_entry_safe(skb, nskb, &nft_net->notify_list, list) {\n\t\tif (!batch_skb) {\nnew_batch:\n\t\t\tbatch_skb = skb;\n\t\t\tlen = NLMSG_GOODSIZE - skb->len;\n\t\t\tlist_del(&skb->list);\n\t\t\tcontinue;\n\t\t}\n\t\tlen -= skb->len;\n\t\tif (len > 0 && NFT_CB(skb).report == NFT_CB(batch_skb).report) {\n\t\t\tdata = skb_put(batch_skb, skb->len);\n\t\t\tmemcpy(data, skb->data, skb->len);\n\t\t\tlist_del(&skb->list);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tnfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,\n\t\t\t       NFT_CB(batch_skb).report, GFP_KERNEL);\n\t\tgoto new_batch;\n\t}\n\n\tif (batch_skb) {\n\t\tnfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,\n\t\t\t       NFT_CB(batch_skb).report, GFP_KERNEL);\n\t}\n\n\tWARN_ON_ONCE(!list_empty(&nft_net->notify_list));\n}\n\nstatic int nf_tables_commit_audit_alloc(struct list_head *adl,\n\t\t\t\t\tstruct nft_table *table)\n{\n\tstruct nft_audit_data *adp;\n\n\tlist_for_each_entry(adp, adl, list) {\n\t\tif (adp->table == table)\n\t\t\treturn 0;\n\t}\n\tadp = kzalloc(sizeof(*adp), GFP_KERNEL);\n\tif (!adp)\n\t\treturn -ENOMEM;\n\tadp->table = table;\n\tlist_add(&adp->list, adl);\n\treturn 0;\n}\n\nstatic void nf_tables_commit_audit_free(struct list_head *adl)\n{\n\tstruct nft_audit_data *adp, *adn;\n\n\tlist_for_each_entry_safe(adp, adn, adl, list) {\n\t\tlist_del(&adp->list);\n\t\tkfree(adp);\n\t}\n}\n\nstatic void nf_tables_commit_audit_collect(struct list_head *adl,\n\t\t\t\t\t   struct nft_table *table, u32 op)\n{\n\tstruct nft_audit_data *adp;\n\n\tlist_for_each_entry(adp, adl, list) {\n\t\tif (adp->table == table)\n\t\t\tgoto found;\n\t}\n\tWARN_ONCE(1, \"table=%s not expected in commit list\", table->name);\n\treturn;\nfound:\n\tadp->entries++;\n\tif (!adp->op || adp->op > op)\n\t\tadp->op = op;\n}\n\n#define AUNFTABLENAMELEN (NFT_TABLE_MAXNAMELEN + 22)\n\nstatic void nf_tables_commit_audit_log(struct list_head *adl, u32 generation)\n{\n\tstruct nft_audit_data *adp, *adn;\n\tchar aubuf[AUNFTABLENAMELEN];\n\n\tlist_for_each_entry_safe(adp, adn, adl, list) {\n\t\tsnprintf(aubuf, AUNFTABLENAMELEN, \"%s:%u\", adp->table->name,\n\t\t\t generation);\n\t\taudit_log_nfcfg(aubuf, adp->table->family, adp->entries,\n\t\t\t\tnft2audit_op[adp->op], GFP_KERNEL);\n\t\tlist_del(&adp->list);\n\t\tkfree(adp);\n\t}\n}\n\nstatic int nf_tables_commit(struct net *net, struct sk_buff *skb)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\tstruct nft_trans_elem *te;\n\tstruct nft_chain *chain;\n\tstruct nft_table *table;\n\tunsigned int base_seq;\n\tLIST_HEAD(adl);\n\tint err;\n\n\tif (list_empty(&nft_net->commit_list)) {\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\t\treturn 0;\n\t}\n\n\t/* 0. Validate ruleset, otherwise roll back for error reporting. */\n\tif (nf_tables_validate(net) < 0)\n\t\treturn -EAGAIN;\n\n\terr = nft_flow_rule_offload_commit(net);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* 1.  Allocate space for next generation rules_gen_X[] */\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tint ret;\n\n\t\tret = nf_tables_commit_audit_alloc(&adl, trans->ctx.table);\n\t\tif (ret) {\n\t\t\tnf_tables_commit_chain_prepare_cancel(net);\n\t\t\tnf_tables_commit_audit_free(&adl);\n\t\t\treturn ret;\n\t\t}\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE ||\n\t\t    trans->msg_type == NFT_MSG_DELRULE) {\n\t\t\tchain = trans->ctx.chain;\n\n\t\t\tret = nf_tables_commit_chain_prepare(net, chain);\n\t\t\tif (ret < 0) {\n\t\t\t\tnf_tables_commit_chain_prepare_cancel(net);\n\t\t\t\tnf_tables_commit_audit_free(&adl);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* step 2.  Make rules_gen_X visible to packet path */\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tlist_for_each_entry(chain, &table->chains, list)\n\t\t\tnf_tables_commit_chain(net, chain);\n\t}\n\n\t/*\n\t * Bump generation counter, invalidate any dump in progress.\n\t * Cannot fail after this point.\n\t */\n\tbase_seq = READ_ONCE(nft_net->base_seq);\n\twhile (++base_seq == 0)\n\t\t;\n\n\tWRITE_ONCE(nft_net->base_seq, base_seq);\n\n\t/* step 3. Start new generation, rules_gen_X now in use. */\n\tnet->nft.gencursor = nft_gencursor_next(net);\n\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tnf_tables_commit_audit_collect(&adl, trans->ctx.table,\n\t\t\t\t\t       trans->msg_type);\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWTABLE:\n\t\t\tif (nft_trans_table_update(trans)) {\n\t\t\t\tif (!(trans->ctx.table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trans->ctx.table->flags & NFT_TABLE_F_DORMANT)\n\t\t\t\t\tnf_tables_table_disable(net, trans->ctx.table);\n\n\t\t\t\ttrans->ctx.table->flags &= ~__NFT_TABLE_F_UPDATE;\n\t\t\t} else {\n\t\t\t\tnft_clear(net, trans->ctx.table);\n\t\t\t}\n\t\t\tnf_tables_table_notify(&trans->ctx, NFT_MSG_NEWTABLE);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELTABLE:\n\t\t\tlist_del_rcu(&trans->ctx.table->list);\n\t\t\tnf_tables_table_notify(&trans->ctx, NFT_MSG_DELTABLE);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (nft_trans_chain_update(trans)) {\n\t\t\t\tnft_chain_commit_update(trans);\n\t\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN);\n\t\t\t\t/* trans destroyed after rcu grace period */\n\t\t\t} else {\n\t\t\t\tnft_chain_commit_drop_policy(trans);\n\t\t\t\tnft_clear(net, trans->ctx.chain);\n\t\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN);\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\tnft_chain_del(trans->ctx.chain);\n\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN);\n\t\t\tnf_tables_unregister_hook(trans->ctx.net,\n\t\t\t\t\t\t  trans->ctx.table,\n\t\t\t\t\t\t  trans->ctx.chain);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\tnft_clear(trans->ctx.net, nft_trans_rule(trans));\n\t\t\tnf_tables_rule_notify(&trans->ctx,\n\t\t\t\t\t      nft_trans_rule(trans),\n\t\t\t\t\t      NFT_MSG_NEWRULE);\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\tlist_del_rcu(&nft_trans_rule(trans)->list);\n\t\t\tnf_tables_rule_notify(&trans->ctx,\n\t\t\t\t\t      nft_trans_rule(trans),\n\t\t\t\t\t      NFT_MSG_DELRULE);\n\t\t\tnft_rule_expr_deactivate(&trans->ctx,\n\t\t\t\t\t\t nft_trans_rule(trans),\n\t\t\t\t\t\t NFT_TRANS_COMMIT);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSET:\n\t\t\tnft_clear(net, nft_trans_set(trans));\n\t\t\t/* This avoids hitting -EBUSY when deleting the table\n\t\t\t * from the transaction.\n\t\t\t */\n\t\t\tif (nft_set_is_anonymous(nft_trans_set(trans)) &&\n\t\t\t    !list_empty(&nft_trans_set(trans)->bindings))\n\t\t\t\ttrans->ctx.table->use--;\n\n\t\t\tnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\n\t\t\t\t\t     NFT_MSG_NEWSET, GFP_KERNEL);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSET:\n\t\t\tlist_del_rcu(&nft_trans_set(trans)->list);\n\t\t\tnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\n\t\t\t\t\t     NFT_MSG_DELSET, GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnft_setelem_activate(net, te->set, &te->elem);\n\t\t\tnf_tables_setelem_notify(&trans->ctx, te->set,\n\t\t\t\t\t\t &te->elem,\n\t\t\t\t\t\t NFT_MSG_NEWSETELEM);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnf_tables_setelem_notify(&trans->ctx, te->set,\n\t\t\t\t\t\t &te->elem,\n\t\t\t\t\t\t NFT_MSG_DELSETELEM);\n\t\t\tnft_setelem_remove(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem)) {\n\t\t\t\tatomic_dec(&te->set->nelems);\n\t\t\t\tte->set->ndeact--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWOBJ:\n\t\t\tif (nft_trans_obj_update(trans)) {\n\t\t\t\tnft_obj_commit_update(trans);\n\t\t\t\tnf_tables_obj_notify(&trans->ctx,\n\t\t\t\t\t\t     nft_trans_obj(trans),\n\t\t\t\t\t\t     NFT_MSG_NEWOBJ);\n\t\t\t} else {\n\t\t\t\tnft_clear(net, nft_trans_obj(trans));\n\t\t\t\tnf_tables_obj_notify(&trans->ctx,\n\t\t\t\t\t\t     nft_trans_obj(trans),\n\t\t\t\t\t\t     NFT_MSG_NEWOBJ);\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELOBJ:\n\t\t\tnft_obj_del(nft_trans_obj(trans));\n\t\t\tnf_tables_obj_notify(&trans->ctx, nft_trans_obj(trans),\n\t\t\t\t\t     NFT_MSG_DELOBJ);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnft_trans_flowtable(trans)->data.flags =\n\t\t\t\t\tnft_trans_flowtable_flags(trans);\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t\t\t   NFT_MSG_NEWFLOWTABLE);\n\t\t\t\tlist_splice(&nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t    &nft_trans_flowtable(trans)->hook_list);\n\t\t\t} else {\n\t\t\t\tnft_clear(net, nft_trans_flowtable(trans));\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable(trans)->hook_list,\n\t\t\t\t\t\t\t   NFT_MSG_NEWFLOWTABLE);\n\t\t\t}\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t\t\t   NFT_MSG_DELFLOWTABLE);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans));\n\t\t\t} else {\n\t\t\t\tlist_del_rcu(&nft_trans_flowtable(trans)->list);\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable(trans)->hook_list,\n\t\t\t\t\t\t\t   NFT_MSG_DELFLOWTABLE);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable(trans)->hook_list);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnft_commit_notify(net, NETLINK_CB(skb).portid);\n\tnf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);\n\tnf_tables_commit_audit_log(&adl, nft_net->base_seq);\n\tnf_tables_commit_release(net);\n\n\treturn 0;\n}\n\nstatic void nf_tables_module_autoload(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_module_request *req, *next;\n\tLIST_HEAD(module_list);\n\n\tlist_splice_init(&nft_net->module_list, &module_list);\n\tmutex_unlock(&nft_net->commit_mutex);\n\tlist_for_each_entry_safe(req, next, &module_list, list) {\n\t\trequest_module(\"%s\", req->module);\n\t\treq->done = true;\n\t}\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_splice(&module_list, &nft_net->module_list);\n}\n\nstatic void nf_tables_abort_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_NEWTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWCHAIN:\n\t\tnf_tables_chain_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWSET:\n\t\tnft_set_destroy(&trans->ctx, nft_trans_set(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWSETELEM:\n\t\tnft_set_elem_destroy(nft_trans_elem_set(trans),\n\t\t\t\t     nft_trans_elem(trans).priv, true);\n\t\tbreak;\n\tcase NFT_MSG_NEWOBJ:\n\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWFLOWTABLE:\n\t\tif (nft_trans_flowtable_update(trans))\n\t\t\tnft_flowtable_hooks_destroy(&nft_trans_flowtable_hooks(trans));\n\t\telse\n\t\t\tnf_tables_flowtable_destroy(nft_trans_flowtable(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}\n\nstatic int __nf_tables_abort(struct net *net, enum nfnl_abort_action action)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\tstruct nft_trans_elem *te;\n\n\tif (action == NFNL_ABORT_VALIDATE &&\n\t    nf_tables_validate(net) < 0)\n\t\treturn -EAGAIN;\n\n\tlist_for_each_entry_safe_reverse(trans, next, &nft_net->commit_list,\n\t\t\t\t\t list) {\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWTABLE:\n\t\t\tif (nft_trans_table_update(trans)) {\n\t\t\t\tif (!(trans->ctx.table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trans->ctx.table->flags & __NFT_TABLE_F_WAS_DORMANT) {\n\t\t\t\t\tnf_tables_table_disable(net, trans->ctx.table);\n\t\t\t\t\ttrans->ctx.table->flags |= NFT_TABLE_F_DORMANT;\n\t\t\t\t} else if (trans->ctx.table->flags & __NFT_TABLE_F_WAS_AWAKEN) {\n\t\t\t\t\ttrans->ctx.table->flags &= ~NFT_TABLE_F_DORMANT;\n\t\t\t\t}\n\t\t\t\ttrans->ctx.table->flags &= ~__NFT_TABLE_F_UPDATE;\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\tlist_del_rcu(&trans->ctx.table->list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELTABLE:\n\t\t\tnft_clear(trans->ctx.net, trans->ctx.table);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (nft_trans_chain_update(trans)) {\n\t\t\t\tfree_percpu(nft_trans_chain_stats(trans));\n\t\t\t\tkfree(nft_trans_chain_name(trans));\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\tif (nft_chain_is_bound(trans->ctx.chain)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tnft_chain_del(trans->ctx.chain);\n\t\t\t\tnf_tables_unregister_hook(trans->ctx.net,\n\t\t\t\t\t\t\t  trans->ctx.table,\n\t\t\t\t\t\t\t  trans->ctx.chain);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, trans->ctx.chain);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\ttrans->ctx.chain->use--;\n\t\t\tlist_del_rcu(&nft_trans_rule(trans)->list);\n\t\t\tnft_rule_expr_deactivate(&trans->ctx,\n\t\t\t\t\t\t nft_trans_rule(trans),\n\t\t\t\t\t\t NFT_TRANS_ABORT);\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\ttrans->ctx.chain->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_rule(trans));\n\t\t\tnft_rule_expr_activate(&trans->ctx, nft_trans_rule(trans));\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSET:\n\t\t\ttrans->ctx.table->use--;\n\t\t\tif (nft_trans_set_bound(trans)) {\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_del_rcu(&nft_trans_set(trans)->list);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSET:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_set(trans));\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tif (nft_trans_elem_set_bound(trans)) {\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\t\t\tnft_setelem_remove(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem))\n\t\t\t\tatomic_dec(&te->set->nelems);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnft_setelem_data_activate(net, te->set, &te->elem);\n\t\t\tnft_setelem_activate(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem))\n\t\t\t\tte->set->ndeact--;\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWOBJ:\n\t\t\tif (nft_trans_obj_update(trans)) {\n\t\t\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj_newobj(trans));\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tnft_obj_del(nft_trans_obj(trans));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELOBJ:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_obj(trans));\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable_hooks(trans));\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tlist_del_rcu(&nft_trans_flowtable(trans)->list);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable(trans)->hook_list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tlist_splice(&nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t    &nft_trans_flowtable(trans)->hook_list);\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use++;\n\t\t\t\tnft_clear(trans->ctx.net, nft_trans_flowtable(trans));\n\t\t\t}\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe_reverse(trans, next,\n\t\t\t\t\t &nft_net->commit_list, list) {\n\t\tlist_del(&trans->list);\n\t\tnf_tables_abort_release(trans);\n\t}\n\n\tif (action == NFNL_ABORT_AUTOLOAD)\n\t\tnf_tables_module_autoload(net);\n\telse\n\t\tnf_tables_module_autoload_cleanup(net);\n\n\treturn 0;\n}\n\nstatic void nf_tables_cleanup(struct net *net)\n{\n\tnft_validate_state_update(net, NFT_VALIDATE_SKIP);\n}\n\nstatic int nf_tables_abort(struct net *net, struct sk_buff *skb,\n\t\t\t   enum nfnl_abort_action action)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tint ret = __nf_tables_abort(net, action);\n\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn ret;\n}\n\nstatic bool nf_tables_valid_genid(struct net *net, u32 genid)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tbool genid_ok;\n\n\tmutex_lock(&nft_net->commit_mutex);\n\n\tgenid_ok = genid == 0 || nft_net->base_seq == genid;\n\tif (!genid_ok)\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\n\t/* else, commit mutex has to be released by commit or abort function */\n\treturn genid_ok;\n}\n\nstatic const struct nfnetlink_subsystem nf_tables_subsys = {\n\t.name\t\t= \"nf_tables\",\n\t.subsys_id\t= NFNL_SUBSYS_NFTABLES,\n\t.cb_count\t= NFT_MSG_MAX,\n\t.cb\t\t= nf_tables_cb,\n\t.commit\t\t= nf_tables_commit,\n\t.abort\t\t= nf_tables_abort,\n\t.cleanup\t= nf_tables_cleanup,\n\t.valid_genid\t= nf_tables_valid_genid,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_types type)\n{\n\tconst struct nft_base_chain *basechain;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate_dependency);\n\nint nft_chain_validate_hooks(const struct nft_chain *chain,\n\t\t\t     unsigned int hook_flags)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tbasechain = nft_base_chain(chain);\n\n\t\tif ((1 << basechain->ops.hooknum) & hook_flags)\n\t\t\treturn 0;\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate_hooks);\n\n/*\n * Loop detection - walk through the ruleset beginning at the destination chain\n * of a new jump until either the source chain is reached (loop) or all\n * reachable chains have been traversed.\n *\n * The loop check is performed whenever a new jump verdict is added to an\n * expression or verdict map or a verdict map is bound to a new chain.\n */\n\nstatic int nf_tables_check_loops(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_chain *chain);\n\nstatic int nft_check_loops(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_set_ext *ext)\n{\n\tconst struct nft_data *data;\n\tint ret;\n\n\tdata = nft_set_ext_data(ext);\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tret = nf_tables_check_loops(ctx, data->verdict.chain);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_loop_check_setelem(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\tconst struct nft_set_iter *iter,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    *nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)\n\t\treturn 0;\n\n\treturn nft_check_loops(ctx, ext);\n}\n\nstatic int nft_set_catchall_loops(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask))\n\t\t\tcontinue;\n\n\t\tret = nft_check_loops(ctx, ext);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_check_loops(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_chain *chain)\n{\n\tconst struct nft_rule *rule;\n\tconst struct nft_expr *expr, *last;\n\tstruct nft_set *set;\n\tstruct nft_set_binding *binding;\n\tstruct nft_set_iter iter;\n\n\tif (ctx->chain == chain)\n\t\treturn -ELOOP;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\tstruct nft_immediate_expr *priv;\n\t\t\tconst struct nft_data *data;\n\t\t\tint err;\n\n\t\t\tif (strcmp(expr->ops->type->name, \"immediate\"))\n\t\t\t\tcontinue;\n\n\t\t\tpriv = nft_expr_priv(expr);\n\t\t\tif (priv->dreg != NFT_REG_VERDICT)\n\t\t\t\tcontinue;\n\n\t\t\tdata = &priv->data;\n\t\t\tswitch (data->verdict.code) {\n\t\t\tcase NFT_JUMP:\n\t\t\tcase NFT_GOTO:\n\t\t\t\terr = nf_tables_check_loops(ctx,\n\t\t\t\t\t\t\tdata->verdict.chain);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(set, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, set))\n\t\t\tcontinue;\n\t\tif (!(set->flags & NFT_SET_MAP) ||\n\t\t    set->dtype != NFT_DATA_VERDICT)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(binding, &set->bindings, list) {\n\t\t\tif (!(binding->flags & NFT_SET_MAP) ||\n\t\t\t    binding->chain != chain)\n\t\t\t\tcontinue;\n\n\t\t\titer.genmask\t= nft_genmask_next(ctx->net);\n\t\t\titer.skip \t= 0;\n\t\t\titer.count\t= 0;\n\t\t\titer.err\t= 0;\n\t\t\titer.fn\t\t= nf_tables_loop_check_setelem;\n\n\t\t\tset->ops->walk(ctx, set, &iter);\n\t\t\tif (!iter.err)\n\t\t\t\titer.err = nft_set_catchall_loops(ctx, set);\n\n\t\t\tif (iter.err < 0)\n\t\t\t\treturn iter.err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tnft_parse_u32_check - fetch u32 attribute and check for maximum value\n *\n *\t@attr: netlink attribute to fetch value from\n *\t@max: maximum value to be stored in dest\n *\t@dest: pointer to the variable\n *\n *\tParse, check and store a given u32 netlink attribute into variable.\n *\tThis function returns -ERANGE if the value goes over maximum value.\n *\tOtherwise a 0 is returned and the attribute value is stored in the\n *\tdestination variable.\n */\nint nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest)\n{\n\tu32 val;\n\n\tval = ntohl(nla_get_be32(attr));\n\tif (val > max)\n\t\treturn -ERANGE;\n\n\t*dest = val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_u32_check);\n\nstatic int nft_parse_register(const struct nlattr *attr, u32 *preg)\n{\n\tunsigned int reg;\n\n\treg = ntohl(nla_get_be32(attr));\n\tswitch (reg) {\n\tcase NFT_REG_VERDICT...NFT_REG_4:\n\t\t*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE;\n\t\tbreak;\n\tcase NFT_REG32_00...NFT_REG32_15:\n\t\t*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tnft_dump_register - dump a register value to a netlink attribute\n *\n *\t@skb: socket buffer\n *\t@attr: attribute number\n *\t@reg: register number\n *\n *\tConstruct a netlink attribute containing the register number. For\n *\tcompatibility reasons, register numbers being a multiple of 4 are\n *\ttranslated to the corresponding 128 bit register numbers.\n */\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg)\n{\n\tif (reg % (NFT_REG_SIZE / NFT_REG32_SIZE) == 0)\n\t\treg = reg / (NFT_REG_SIZE / NFT_REG32_SIZE);\n\telse\n\t\treg = reg - NFT_REG_SIZE / NFT_REG32_SIZE + NFT_REG32_00;\n\n\treturn nla_put_be32(skb, attr, htonl(reg));\n}\nEXPORT_SYMBOL_GPL(nft_dump_register);\n\nstatic int nft_validate_register_load(enum nft_registers reg, unsigned int len)\n{\n\tif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\n\t\treturn -EINVAL;\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (reg * NFT_REG32_SIZE + len > sizeof_field(struct nft_regs, data))\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)\n{\n\tu32 reg;\n\tint err;\n\n\terr = nft_parse_register(attr, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_validate_register_load(reg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*sreg = reg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_register_load);\n\nstatic int nft_validate_register_store(const struct nft_ctx *ctx,\n\t\t\t\t       enum nft_registers reg,\n\t\t\t\t       const struct nft_data *data,\n\t\t\t\t       enum nft_data_types type,\n\t\t\t\t       unsigned int len)\n{\n\tint err;\n\n\tswitch (reg) {\n\tcase NFT_REG_VERDICT:\n\t\tif (type != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (data != NULL &&\n\t\t    (data->verdict.code == NFT_GOTO ||\n\t\t     data->verdict.code == NFT_JUMP)) {\n\t\t\terr = nf_tables_check_loops(ctx, data->verdict.chain);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (len == 0)\n\t\t\treturn -EINVAL;\n\t\tif (reg * NFT_REG32_SIZE + len >\n\t\t    sizeof_field(struct nft_regs, data))\n\t\t\treturn -ERANGE;\n\n\t\tif (data != NULL && type != NFT_DATA_VALUE)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n}\n\nint nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len)\n{\n\tint err;\n\tu32 reg;\n\n\terr = nft_parse_register(attr, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_validate_register_store(ctx, reg, data, type, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*dreg = reg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_register_store);\n\nstatic const struct nla_policy nft_verdict_policy[NFTA_VERDICT_MAX + 1] = {\n\t[NFTA_VERDICT_CODE]\t= { .type = NLA_U32 },\n\t[NFTA_VERDICT_CHAIN]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_VERDICT_CHAIN_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}\n\nstatic void nft_verdict_uninit(const struct nft_data *data)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tchain = data->verdict.chain;\n\t\tchain->use--;\n\n\t\tif (!nft_chain_is_bound(chain))\n\t\t\tbreak;\n\n\t\tchain->table->use--;\n\t\tlist_for_each_entry(rule, &chain->rules, list)\n\t\t\tchain->use--;\n\n\t\tnft_chain_del(chain);\n\t\tbreak;\n\t}\n}\n\nint nft_verdict_dump(struct sk_buff *skb, int type, const struct nft_verdict *v)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, type);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_VERDICT_CODE, htonl(v->code)))\n\t\tgoto nla_put_failure;\n\n\tswitch (v->code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (nla_put_string(skb, NFTA_VERDICT_CHAIN,\n\t\t\t\t   v->chain->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_value_init(const struct nft_ctx *ctx,\n\t\t\t  struct nft_data *data, struct nft_data_desc *desc,\n\t\t\t  const struct nlattr *nla)\n{\n\tunsigned int len;\n\n\tlen = nla_len(nla);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > desc->size)\n\t\treturn -EOVERFLOW;\n\tif (desc->len) {\n\t\tif (len != desc->len)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdesc->len = len;\n\t}\n\n\tnla_memcpy(data->data, nla, len);\n\n\treturn 0;\n}\n\nstatic int nft_value_dump(struct sk_buff *skb, const struct nft_data *data,\n\t\t\t  unsigned int len)\n{\n\treturn nla_put(skb, NFTA_DATA_VALUE, len, data->data);\n}\n\nstatic const struct nla_policy nft_data_policy[NFTA_DATA_MAX + 1] = {\n\t[NFTA_DATA_VALUE]\t= { .type = NLA_BINARY },\n\t[NFTA_DATA_VERDICT]\t= { .type = NLA_NESTED },\n};\n\n/**\n *\tnft_data_init - parse nf_tables data netlink attributes\n *\n *\t@ctx: context of the expression using the data\n *\t@data: destination struct nft_data\n *\t@desc: data description\n *\t@nla: netlink attribute containing data\n *\n *\tParse the netlink data attributes and initialize a struct nft_data.\n *\tThe type and length of data are returned in the data description.\n *\n *\tThe caller can indicate that it only wants to accept data of type\n *\tNFT_DATA_VALUE by passing NULL for the ctx argument.\n */\nint nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t  struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tstruct nlattr *tb[NFTA_DATA_MAX + 1];\n\tint err;\n\n\tif (WARN_ON_ONCE(!desc->size))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,\n\t\t\t\t\t  nft_data_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DATA_VALUE]) {\n\t\tif (desc->type != NFT_DATA_VALUE)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);\n\t} else if (tb[NFTA_DATA_VERDICT] && ctx != NULL) {\n\t\tif (desc->type != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nft_data_init);\n\n/**\n *\tnft_data_release - release a nft_data item\n *\n *\t@data: struct nft_data to release\n *\t@type: type of data\n *\n *\tRelease a nft_data item. NFT_DATA_VALUE types can be silently discarded,\n *\tall others need to be released by calling this function.\n */\nvoid nft_data_release(const struct nft_data *data, enum nft_data_types type)\n{\n\tif (type < NFT_DATA_VERDICT)\n\t\treturn;\n\tswitch (type) {\n\tcase NFT_DATA_VERDICT:\n\t\treturn nft_verdict_uninit(data);\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_data_release);\n\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\n\t\t  enum nft_data_types type, unsigned int len)\n{\n\tstruct nlattr *nest;\n\tint err;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (nest == NULL)\n\t\treturn -1;\n\n\tswitch (type) {\n\tcase NFT_DATA_VALUE:\n\t\terr = nft_value_dump(skb, data, len);\n\t\tbreak;\n\tcase NFT_DATA_VERDICT:\n\t\terr = nft_verdict_dump(skb, NFTA_DATA_VERDICT, &data->verdict);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nft_data_dump);\n\nint __nft_release_basechain(struct nft_ctx *ctx)\n{\n\tstruct nft_rule *rule, *nr;\n\n\tif (WARN_ON(!nft_is_base_chain(ctx->chain)))\n\t\treturn 0;\n\n\tnf_tables_unregister_hook(ctx->net, ctx->chain->table, ctx->chain);\n\tlist_for_each_entry_safe(rule, nr, &ctx->chain->rules, list) {\n\t\tlist_del(&rule->list);\n\t\tctx->chain->use--;\n\t\tnf_tables_rule_release(ctx, rule);\n\t}\n\tnft_chain_del(ctx->chain);\n\tctx->table->use--;\n\tnf_tables_chain_destroy(ctx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__nft_release_basechain);\n\nstatic void __nft_release_hook(struct net *net, struct nft_table *table)\n{\n\tstruct nft_flowtable *flowtable;\n\tstruct nft_chain *chain;\n\n\tlist_for_each_entry(chain, &table->chains, list)\n\t\t__nf_tables_unregister_hook(net, table, chain, true);\n\tlist_for_each_entry(flowtable, &table->flowtables, list)\n\t\t__nft_unregister_flowtable_net_hooks(net, &flowtable->hook_list,\n\t\t\t\t\t\t     true);\n}\n\nstatic void __nft_release_hooks(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table;\n\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table))\n\t\t\tcontinue;\n\n\t\t__nft_release_hook(net, table);\n\t}\n}\n\nstatic void __nft_release_table(struct net *net, struct nft_table *table)\n{\n\tstruct nft_flowtable *flowtable, *nf;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_object *obj, *ne;\n\tstruct nft_rule *rule, *nr;\n\tstruct nft_set *set, *ns;\n\tstruct nft_ctx ctx = {\n\t\t.net\t= net,\n\t\t.family\t= NFPROTO_NETDEV,\n\t};\n\n\tctx.family = table->family;\n\tctx.table = table;\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tctx.chain = chain;\n\t\tlist_for_each_entry_safe(rule, nr, &chain->rules, list) {\n\t\t\tlist_del(&rule->list);\n\t\t\tchain->use--;\n\t\t\tnf_tables_rule_release(&ctx, rule);\n\t\t}\n\t}\n\tlist_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {\n\t\tlist_del(&flowtable->list);\n\t\ttable->use--;\n\t\tnf_tables_flowtable_destroy(flowtable);\n\t}\n\tlist_for_each_entry_safe(set, ns, &table->sets, list) {\n\t\tlist_del(&set->list);\n\t\ttable->use--;\n\t\tnft_set_destroy(&ctx, set);\n\t}\n\tlist_for_each_entry_safe(obj, ne, &table->objects, list) {\n\t\tnft_obj_del(obj);\n\t\ttable->use--;\n\t\tnft_obj_destroy(&ctx, obj);\n\t}\n\tlist_for_each_entry_safe(chain, nc, &table->chains, list) {\n\t\tctx.chain = chain;\n\t\tnft_chain_del(chain);\n\t\ttable->use--;\n\t\tnf_tables_chain_destroy(&ctx);\n\t}\n\tnf_tables_table_destroy(&ctx);\n}\n\nstatic void __nft_release_tables(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table, *nt;\n\n\tlist_for_each_entry_safe(table, nt, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table))\n\t\t\tcontinue;\n\n\t\tlist_del(&table->list);\n\n\t\t__nft_release_table(net, table);\n\t}\n}\n\nstatic int nft_rcv_nl_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct nft_table *table, *to_delete[8];\n\tstruct nftables_pernet *nft_net;\n\tstruct netlink_notify *n = ptr;\n\tstruct net *net = n->net;\n\tunsigned int deleted;\n\tbool restart = false;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_NETFILTER)\n\t\treturn NOTIFY_DONE;\n\n\tnft_net = nft_pernet(net);\n\tdeleted = 0;\n\tmutex_lock(&nft_net->commit_mutex);\nagain:\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table) &&\n\t\t    n->portid == table->nlpid) {\n\t\t\t__nft_release_hook(net, table);\n\t\t\tlist_del_rcu(&table->list);\n\t\t\tto_delete[deleted++] = table;\n\t\t\tif (deleted >= ARRAY_SIZE(to_delete))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (deleted) {\n\t\trestart = deleted >= ARRAY_SIZE(to_delete);\n\t\tsynchronize_rcu();\n\t\twhile (deleted)\n\t\t\t__nft_release_table(net, to_delete[--deleted]);\n\n\t\tif (restart)\n\t\t\tgoto again;\n\t}\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nft_nl_notifier = {\n\t.notifier_call  = nft_rcv_nl_event,\n};\n\nstatic int __net_init nf_tables_init_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tINIT_LIST_HEAD(&nft_net->tables);\n\tINIT_LIST_HEAD(&nft_net->commit_list);\n\tINIT_LIST_HEAD(&nft_net->module_list);\n\tINIT_LIST_HEAD(&nft_net->notify_list);\n\tmutex_init(&nft_net->commit_mutex);\n\tnft_net->base_seq = 1;\n\tnft_net->validate_state = NFT_VALIDATE_SKIP;\n\n\treturn 0;\n}\n\nstatic void __net_exit nf_tables_pre_exit_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tmutex_lock(&nft_net->commit_mutex);\n\t__nft_release_hooks(net);\n\tmutex_unlock(&nft_net->commit_mutex);\n}\n\nstatic void __net_exit nf_tables_exit_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tmutex_lock(&nft_net->commit_mutex);\n\tif (!list_empty(&nft_net->commit_list))\n\t\t__nf_tables_abort(net, NFNL_ABORT_NONE);\n\t__nft_release_tables(net);\n\tmutex_unlock(&nft_net->commit_mutex);\n\tWARN_ON_ONCE(!list_empty(&nft_net->tables));\n\tWARN_ON_ONCE(!list_empty(&nft_net->module_list));\n\tWARN_ON_ONCE(!list_empty(&nft_net->notify_list));\n}\n\nstatic struct pernet_operations nf_tables_net_ops = {\n\t.init\t\t= nf_tables_init_net,\n\t.pre_exit\t= nf_tables_pre_exit_net,\n\t.exit\t\t= nf_tables_exit_net,\n\t.id\t\t= &nf_tables_net_id,\n\t.size\t\t= sizeof(struct nftables_pernet),\n};\n\nstatic int __init nf_tables_module_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&nf_tables_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_chain_filter_init();\n\tif (err < 0)\n\t\tgoto err_chain_filter;\n\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err_core_module;\n\n\terr = register_netdevice_notifier(&nf_tables_flowtable_notifier);\n\tif (err < 0)\n\t\tgoto err_netdev_notifier;\n\n\terr = rhltable_init(&nft_objname_ht, &nft_objname_ht_params);\n\tif (err < 0)\n\t\tgoto err_rht_objname;\n\n\terr = nft_offload_init();\n\tif (err < 0)\n\t\tgoto err_offload;\n\n\terr = netlink_register_notifier(&nft_nl_notifier);\n\tif (err < 0)\n\t\tgoto err_netlink_notifier;\n\n\t/* must be last */\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err_nfnl_subsys;\n\n\tnft_chain_route_init();\n\n\treturn err;\n\nerr_nfnl_subsys:\n\tnetlink_unregister_notifier(&nft_nl_notifier);\nerr_netlink_notifier:\n\tnft_offload_exit();\nerr_offload:\n\trhltable_destroy(&nft_objname_ht);\nerr_rht_objname:\n\tunregister_netdevice_notifier(&nf_tables_flowtable_notifier);\nerr_netdev_notifier:\n\tnf_tables_core_module_exit();\nerr_core_module:\n\tnft_chain_filter_fini();\nerr_chain_filter:\n\tunregister_pernet_subsys(&nf_tables_net_ops);\n\treturn err;\n}\n\nstatic void __exit nf_tables_module_exit(void)\n{\n\tnfnetlink_subsys_unregister(&nf_tables_subsys);\n\tnetlink_unregister_notifier(&nft_nl_notifier);\n\tnft_offload_exit();\n\tunregister_netdevice_notifier(&nf_tables_flowtable_notifier);\n\tnft_chain_filter_fini();\n\tnft_chain_route_fini();\n\tunregister_pernet_subsys(&nf_tables_net_ops);\n\tcancel_work_sync(&trans_destroy_work);\n\trcu_barrier();\n\trhltable_destroy(&nft_objname_ht);\n\tnf_tables_core_module_exit();\n}\n\nmodule_init(nf_tables_module_init);\nmodule_exit(nf_tables_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_NFTABLES);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2007-2009 Patrick McHardy <kaber@trash.net>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/vmalloc.h>\n#include <linux/rhashtable.h>\n#include <linux/audit.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_flow_table.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#define NFT_MODULE_AUTOLOAD_LIMIT (MODULE_NAME_LEN - sizeof(\"nft-expr-255-\"))\n\nunsigned int nf_tables_net_id __read_mostly;\n\nstatic LIST_HEAD(nf_tables_expressions);\nstatic LIST_HEAD(nf_tables_objects);\nstatic LIST_HEAD(nf_tables_flowtables);\nstatic LIST_HEAD(nf_tables_destroy_list);\nstatic DEFINE_SPINLOCK(nf_tables_destroy_list_lock);\n\nenum {\n\tNFT_VALIDATE_SKIP\t= 0,\n\tNFT_VALIDATE_NEED,\n\tNFT_VALIDATE_DO,\n};\n\nstatic struct rhltable nft_objname_ht;\n\nstatic u32 nft_chain_hash(const void *data, u32 len, u32 seed);\nstatic u32 nft_chain_hash_obj(const void *data, u32 len, u32 seed);\nstatic int nft_chain_hash_cmp(struct rhashtable_compare_arg *, const void *);\n\nstatic u32 nft_objname_hash(const void *data, u32 len, u32 seed);\nstatic u32 nft_objname_hash_obj(const void *data, u32 len, u32 seed);\nstatic int nft_objname_hash_cmp(struct rhashtable_compare_arg *, const void *);\n\nstatic const struct rhashtable_params nft_chain_ht_params = {\n\t.head_offset\t\t= offsetof(struct nft_chain, rhlhead),\n\t.key_offset\t\t= offsetof(struct nft_chain, name),\n\t.hashfn\t\t\t= nft_chain_hash,\n\t.obj_hashfn\t\t= nft_chain_hash_obj,\n\t.obj_cmpfn\t\t= nft_chain_hash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nstatic const struct rhashtable_params nft_objname_ht_params = {\n\t.head_offset\t\t= offsetof(struct nft_object, rhlhead),\n\t.key_offset\t\t= offsetof(struct nft_object, key),\n\t.hashfn\t\t\t= nft_objname_hash,\n\t.obj_hashfn\t\t= nft_objname_hash_obj,\n\t.obj_cmpfn\t\t= nft_objname_hash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nstruct nft_audit_data {\n\tstruct nft_table *table;\n\tint entries;\n\tint op;\n\tstruct list_head list;\n};\n\nstatic const u8 nft2audit_op[NFT_MSG_MAX] = { // enum nf_tables_msg_types\n\t[NFT_MSG_NEWTABLE]\t= AUDIT_NFT_OP_TABLE_REGISTER,\n\t[NFT_MSG_GETTABLE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELTABLE]\t= AUDIT_NFT_OP_TABLE_UNREGISTER,\n\t[NFT_MSG_NEWCHAIN]\t= AUDIT_NFT_OP_CHAIN_REGISTER,\n\t[NFT_MSG_GETCHAIN]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELCHAIN]\t= AUDIT_NFT_OP_CHAIN_UNREGISTER,\n\t[NFT_MSG_NEWRULE]\t= AUDIT_NFT_OP_RULE_REGISTER,\n\t[NFT_MSG_GETRULE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELRULE]\t= AUDIT_NFT_OP_RULE_UNREGISTER,\n\t[NFT_MSG_NEWSET]\t= AUDIT_NFT_OP_SET_REGISTER,\n\t[NFT_MSG_GETSET]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELSET]\t= AUDIT_NFT_OP_SET_UNREGISTER,\n\t[NFT_MSG_NEWSETELEM]\t= AUDIT_NFT_OP_SETELEM_REGISTER,\n\t[NFT_MSG_GETSETELEM]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELSETELEM]\t= AUDIT_NFT_OP_SETELEM_UNREGISTER,\n\t[NFT_MSG_NEWGEN]\t= AUDIT_NFT_OP_GEN_REGISTER,\n\t[NFT_MSG_GETGEN]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_TRACE]\t\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_NEWOBJ]\t= AUDIT_NFT_OP_OBJ_REGISTER,\n\t[NFT_MSG_GETOBJ]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELOBJ]\t= AUDIT_NFT_OP_OBJ_UNREGISTER,\n\t[NFT_MSG_GETOBJ_RESET]\t= AUDIT_NFT_OP_OBJ_RESET,\n\t[NFT_MSG_NEWFLOWTABLE]\t= AUDIT_NFT_OP_FLOWTABLE_REGISTER,\n\t[NFT_MSG_GETFLOWTABLE]\t= AUDIT_NFT_OP_INVALID,\n\t[NFT_MSG_DELFLOWTABLE]\t= AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\n};\n\nstatic void nft_validate_state_update(struct net *net, u8 new_validate_state)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tswitch (nft_net->validate_state) {\n\tcase NFT_VALIDATE_SKIP:\n\t\tWARN_ON_ONCE(new_validate_state == NFT_VALIDATE_DO);\n\t\tbreak;\n\tcase NFT_VALIDATE_NEED:\n\t\tbreak;\n\tcase NFT_VALIDATE_DO:\n\t\tif (new_validate_state == NFT_VALIDATE_NEED)\n\t\t\treturn;\n\t}\n\n\tnft_net->validate_state = new_validate_state;\n}\nstatic void nf_tables_trans_destroy_work(struct work_struct *w);\nstatic DECLARE_WORK(trans_destroy_work, nf_tables_trans_destroy_work);\n\nstatic void nft_ctx_init(struct nft_ctx *ctx,\n\t\t\t struct net *net,\n\t\t\t const struct sk_buff *skb,\n\t\t\t const struct nlmsghdr *nlh,\n\t\t\t u8 family,\n\t\t\t struct nft_table *table,\n\t\t\t struct nft_chain *chain,\n\t\t\t const struct nlattr * const *nla)\n{\n\tctx->net\t= net;\n\tctx->family\t= family;\n\tctx->level\t= 0;\n\tctx->table\t= table;\n\tctx->chain\t= chain;\n\tctx->nla   \t= nla;\n\tctx->portid\t= NETLINK_CB(skb).portid;\n\tctx->report\t= nlmsg_report(nlh);\n\tctx->flags\t= nlh->nlmsg_flags;\n\tctx->seq\t= nlh->nlmsg_seq;\n}\n\nstatic struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\n\treturn trans;\n}\n\nstatic struct nft_trans *nft_trans_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t int msg_type, u32 size)\n{\n\treturn nft_trans_alloc_gfp(ctx, msg_type, size, GFP_KERNEL);\n}\n\nstatic void nft_trans_destroy(struct nft_trans *trans)\n{\n\tlist_del(&trans->list);\n\tkfree(trans);\n}\n\nstatic void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = ctx->net;\n\tstruct nft_trans *trans;\n\n\tif (!nft_set_is_anonymous(set))\n\t\treturn;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry_reverse(trans, &nft_net->commit_list, list) {\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWSET:\n\t\t\tif (nft_trans_set(trans) == set)\n\t\t\t\tnft_trans_set_bound(trans) = true;\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tif (nft_trans_elem_set(trans) == set)\n\t\t\t\tnft_trans_elem_set_bound(trans) = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int nft_netdev_register_hooks(struct net *net,\n\t\t\t\t     struct list_head *hook_list)\n{\n\tstruct nft_hook *hook;\n\tint err, j;\n\n\tj = 0;\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\terr = nf_register_net_hook(net, &hook->ops);\n\t\tif (err < 0)\n\t\t\tgoto err_register;\n\n\t\tj++;\n\t}\n\treturn 0;\n\nerr_register:\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tif (j-- <= 0)\n\t\t\tbreak;\n\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t}\n\treturn err;\n}\n\nstatic void nft_netdev_unregister_hooks(struct net *net,\n\t\t\t\t\tstruct list_head *hook_list,\n\t\t\t\t\tbool release_netdev)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t\tif (release_netdev) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree_rcu(hook, rcu);\n\t\t}\n\t}\n}\n\nstatic int nf_tables_register_hook(struct net *net,\n\t\t\t\t   const struct nft_table *table,\n\t\t\t\t   struct nft_chain *chain)\n{\n\tstruct nft_base_chain *basechain;\n\tconst struct nf_hook_ops *ops;\n\n\tif (table->flags & NFT_TABLE_F_DORMANT ||\n\t    !nft_is_base_chain(chain))\n\t\treturn 0;\n\n\tbasechain = nft_base_chain(chain);\n\tops = &basechain->ops;\n\n\tif (basechain->type->ops_register)\n\t\treturn basechain->type->ops_register(net, ops);\n\n\tif (nft_base_chain_netdev(table->family, basechain->ops.hooknum))\n\t\treturn nft_netdev_register_hooks(net, &basechain->hook_list);\n\n\treturn nf_register_net_hook(net, &basechain->ops);\n}\n\nstatic void __nf_tables_unregister_hook(struct net *net,\n\t\t\t\t\tconst struct nft_table *table,\n\t\t\t\t\tstruct nft_chain *chain,\n\t\t\t\t\tbool release_netdev)\n{\n\tstruct nft_base_chain *basechain;\n\tconst struct nf_hook_ops *ops;\n\n\tif (table->flags & NFT_TABLE_F_DORMANT ||\n\t    !nft_is_base_chain(chain))\n\t\treturn;\n\tbasechain = nft_base_chain(chain);\n\tops = &basechain->ops;\n\n\tif (basechain->type->ops_unregister)\n\t\treturn basechain->type->ops_unregister(net, ops);\n\n\tif (nft_base_chain_netdev(table->family, basechain->ops.hooknum))\n\t\tnft_netdev_unregister_hooks(net, &basechain->hook_list,\n\t\t\t\t\t    release_netdev);\n\telse\n\t\tnf_unregister_net_hook(net, &basechain->ops);\n}\n\nstatic void nf_tables_unregister_hook(struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      struct nft_chain *chain)\n{\n\treturn __nf_tables_unregister_hook(net, table, chain, false);\n}\n\nstatic void nft_trans_commit_list_add_tail(struct net *net, struct nft_trans *trans)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tlist_add_tail(&trans->list, &nft_net->commit_list);\n}\n\nstatic int nft_trans_table_add(struct nft_ctx *ctx, int msg_type)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_table));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWTABLE)\n\t\tnft_activate_next(ctx->net, ctx->table);\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n}\n\nstatic int nft_deltable(struct nft_ctx *ctx)\n{\n\tint err;\n\n\terr = nft_trans_table_add(ctx, NFT_MSG_DELTABLE);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, ctx->table);\n\treturn err;\n}\n\nstatic struct nft_trans *nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_chain));\n\tif (trans == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (msg_type == NFT_MSG_NEWCHAIN) {\n\t\tnft_activate_next(ctx->net, ctx->chain);\n\n\t\tif (ctx->nla[NFTA_CHAIN_ID]) {\n\t\t\tnft_trans_chain_id(trans) =\n\t\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_CHAIN_ID]));\n\t\t}\n\t}\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn trans;\n}\n\nstatic int nft_delchain(struct nft_ctx *ctx)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_chain_add(ctx, NFT_MSG_DELCHAIN);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tctx->table->use--;\n\tnft_deactivate_next(ctx->net, ctx->chain);\n\n\treturn 0;\n}\n\nstatic void nft_rule_expr_activate(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_rule *rule)\n{\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->activate)\n\t\t\texpr->ops->activate(ctx, expr);\n\n\t\texpr = nft_expr_next(expr);\n\t}\n}\n\nstatic void nft_rule_expr_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_rule *rule,\n\t\t\t\t     enum nft_trans_phase phase)\n{\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->deactivate)\n\t\t\texpr->ops->deactivate(ctx, expr, phase);\n\n\t\texpr = nft_expr_next(expr);\n\t}\n}\n\nstatic int\nnf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\t/* You cannot delete the same rule twice */\n\tif (nft_is_active_next(ctx->net, rule)) {\n\t\tnft_deactivate_next(ctx->net, rule);\n\t\tctx->chain->use--;\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\nstatic struct nft_trans *nft_trans_rule_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t\t\t    struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_rule));\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tif (msg_type == NFT_MSG_NEWRULE && ctx->nla[NFTA_RULE_ID] != NULL) {\n\t\tnft_trans_rule_id(trans) =\n\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_RULE_ID]));\n\t}\n\tnft_trans_rule(trans) = rule;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn trans;\n}\n\nstatic int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_flow_rule *flow;\n\tstruct nft_trans *trans;\n\tint err;\n\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ctx->chain->flags & NFT_CHAIN_HW_OFFLOAD) {\n\t\tflow = nft_flow_rule_create(ctx->net, rule);\n\t\tif (IS_ERR(flow)) {\n\t\t\tnft_trans_destroy(trans);\n\t\t\treturn PTR_ERR(flow);\n\t\t}\n\n\t\tnft_trans_flow_rule(trans) = flow;\n\t}\n\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\tnft_rule_expr_deactivate(ctx, rule, NFT_TRANS_PREPARE);\n\n\treturn 0;\n}\n\nstatic int nft_delrule_by_chain(struct nft_ctx *ctx)\n{\n\tstruct nft_rule *rule;\n\tint err;\n\n\tlist_for_each_entry(rule, &ctx->chain->rules, list) {\n\t\tif (!nft_is_active_next(ctx->net, rule))\n\t\t\tcontinue;\n\n\t\terr = nft_delrule(ctx, rule);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int nft_trans_set_add(const struct nft_ctx *ctx, int msg_type,\n\t\t\t     struct nft_set *set)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_set));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWSET && ctx->nla[NFTA_SET_ID] != NULL) {\n\t\tnft_trans_set_id(trans) =\n\t\t\tntohl(nla_get_be32(ctx->nla[NFTA_SET_ID]));\n\t\tnft_activate_next(ctx->net, set);\n\t}\n\tnft_trans_set(trans) = set;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delset(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tint err;\n\n\terr = nft_trans_set_add(ctx, NFT_MSG_DELSET, set);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, set);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic int nft_trans_obj_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t     struct nft_object *obj)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_obj));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWOBJ)\n\t\tnft_activate_next(ctx->net, obj);\n\n\tnft_trans_obj(trans) = obj;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delobj(struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tint err;\n\n\terr = nft_trans_obj_add(ctx, NFT_MSG_DELOBJ, obj);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, obj);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic int nft_trans_flowtable_add(struct nft_ctx *ctx, int msg_type,\n\t\t\t\t   struct nft_flowtable *flowtable)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif (msg_type == NFT_MSG_NEWFLOWTABLE)\n\t\tnft_activate_next(ctx->net, flowtable);\n\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_delflowtable(struct nft_ctx *ctx,\n\t\t\t    struct nft_flowtable *flowtable)\n{\n\tint err;\n\n\terr = nft_trans_flowtable_add(ctx, NFT_MSG_DELFLOWTABLE, flowtable);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_deactivate_next(ctx->net, flowtable);\n\tctx->table->use--;\n\n\treturn err;\n}\n\nstatic void __nft_reg_track_clobber(struct nft_regs_track *track, u8 dreg)\n{\n\tint i;\n\n\tfor (i = track->regs[dreg].num_reg; i > 0; i--)\n\t\t__nft_reg_track_cancel(track, dreg - i);\n}\n\nstatic void __nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t\t   const struct nft_expr *expr,\n\t\t\t\t   u8 dreg, u8 num_reg)\n{\n\ttrack->regs[dreg].selector = expr;\n\ttrack->regs[dreg].bitwise = NULL;\n\ttrack->regs[dreg].num_reg = num_reg;\n}\n\nvoid nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len)\n{\n\tunsigned int regcount;\n\tint i;\n\n\t__nft_reg_track_clobber(track, dreg);\n\n\tregcount = DIV_ROUND_UP(len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\t__nft_reg_track_update(track, expr, dreg, i);\n}\nEXPORT_SYMBOL_GPL(nft_reg_track_update);\n\nvoid nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len)\n{\n\tunsigned int regcount;\n\tint i;\n\n\t__nft_reg_track_clobber(track, dreg);\n\n\tregcount = DIV_ROUND_UP(len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\t__nft_reg_track_cancel(track, dreg);\n}\nEXPORT_SYMBOL_GPL(nft_reg_track_cancel);\n\nvoid __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg)\n{\n\ttrack->regs[dreg].selector = NULL;\n\ttrack->regs[dreg].bitwise = NULL;\n\ttrack->regs[dreg].num_reg = 0;\n}\nEXPORT_SYMBOL_GPL(__nft_reg_track_cancel);\n\n/*\n * Tables\n */\n\nstatic struct nft_table *nft_table_lookup(const struct net *net,\n\t\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t\t  u8 family, u8 genmask, u32 nlpid)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list,\n\t\t\t\tlockdep_is_held(&nft_net->commit_mutex)) {\n\t\tif (!nla_strcmp(nla, table->name) &&\n\t\t    table->family == family &&\n\t\t    nft_active_genmask(table, genmask)) {\n\t\t\tif (nft_table_has_owner(table) &&\n\t\t\t    nlpid && table->nlpid != nlpid)\n\t\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t\treturn table;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_table *nft_table_lookup_byhandle(const struct net *net,\n\t\t\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t\t\t   u8 genmask, u32 nlpid)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == table->handle &&\n\t\t    nft_active_genmask(table, genmask)) {\n\t\t\tif (nft_table_has_owner(table) &&\n\t\t\t    nlpid && table->nlpid != nlpid)\n\t\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t\treturn table;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic inline u64 nf_tables_alloc_handle(struct nft_table *table)\n{\n\treturn ++table->hgenerator;\n}\n\nstatic const struct nft_chain_type *chain_type[NFPROTO_NUMPROTO][NFT_CHAIN_T_MAX];\n\nstatic const struct nft_chain_type *\n__nft_chain_type_get(u8 family, enum nft_chain_types type)\n{\n\tif (family >= NFPROTO_NUMPROTO ||\n\t    type >= NFT_CHAIN_T_MAX)\n\t\treturn NULL;\n\n\treturn chain_type[family][type];\n}\n\nstatic const struct nft_chain_type *\n__nf_tables_chain_type_lookup(const struct nlattr *nla, u8 family)\n{\n\tconst struct nft_chain_type *type;\n\tint i;\n\n\tfor (i = 0; i < NFT_CHAIN_T_MAX; i++) {\n\t\ttype = __nft_chain_type_get(family, i);\n\t\tif (!type)\n\t\t\tcontinue;\n\t\tif (!nla_strcmp(nla, type->name))\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstruct nft_module_request {\n\tstruct list_head\tlist;\n\tchar\t\t\tmodule[MODULE_NAME_LEN];\n\tbool\t\t\tdone;\n};\n\n#ifdef CONFIG_MODULES\n__printf(2, 3) int nft_request_module(struct net *net, const char *fmt,\n\t\t\t\t      ...)\n{\n\tchar module_name[MODULE_NAME_LEN];\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_module_request *req;\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);\n\tva_end(args);\n\tif (ret >= MODULE_NAME_LEN)\n\t\treturn 0;\n\n\tnft_net = nft_pernet(net);\n\tlist_for_each_entry(req, &nft_net->module_list, list) {\n\t\tif (!strcmp(req->module, module_name)) {\n\t\t\tif (req->done)\n\t\t\t\treturn 0;\n\n\t\t\t/* A request to load this module already exists. */\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->done = false;\n\tstrlcpy(req->module, module_name, MODULE_NAME_LEN);\n\tlist_add_tail(&req->list, &nft_net->module_list);\n\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(nft_request_module);\n#endif\n\nstatic void lockdep_nfnl_nft_mutex_not_held(void)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tif (debug_locks)\n\t\tWARN_ON_ONCE(lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES));\n#endif\n}\n\nstatic const struct nft_chain_type *\nnf_tables_chain_type_lookup(struct net *net, const struct nlattr *nla,\n\t\t\t    u8 family, bool autoload)\n{\n\tconst struct nft_chain_type *type;\n\n\ttype = __nf_tables_chain_type_lookup(nla, family);\n\tif (type != NULL)\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (autoload) {\n\t\tif (nft_request_module(net, \"nft-chain-%u-%.*s\", family,\n\t\t\t\t       nla_len(nla),\n\t\t\t\t       (const char *)nla_data(nla)) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic __be16 nft_base_seq(const struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\treturn htons(nft_net->base_seq & 0xffff);\n}\n\nstatic const struct nla_policy nft_table_policy[NFTA_TABLE_MAX + 1] = {\n\t[NFTA_TABLE_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_TABLE_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_TABLE_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_TABLE_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN }\n};\n\nstatic int nf_tables_fill_table_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t     u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t     int family, const struct nft_table *table)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_TABLE_NAME, table->name) ||\n\t    nla_put_be32(skb, NFTA_TABLE_FLAGS,\n\t\t\t htonl(table->flags & NFT_TABLE_F_MASK)) ||\n\t    nla_put_be32(skb, NFTA_TABLE_USE, htonl(table->use)) ||\n\t    nla_put_be64(skb, NFTA_TABLE_HANDLE, cpu_to_be64(table->handle),\n\t\t\t NFTA_TABLE_PAD))\n\t\tgoto nla_put_failure;\n\tif (nft_table_has_owner(table) &&\n\t    nla_put_be32(skb, NFTA_TABLE_OWNER, htonl(table->nlpid)))\n\t\tgoto nla_put_failure;\n\n\tif (table->udata) {\n\t\tif (nla_put(skb, NFTA_TABLE_USERDATA, table->udlen, table->udata))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nftnl_skb_parms {\n\tbool report;\n};\n#define NFT_CB(skb)\t(*(struct nftnl_skb_parms*)&((skb)->cb))\n\nstatic void nft_notify_enqueue(struct sk_buff *skb, bool report,\n\t\t\t       struct list_head *notify_list)\n{\n\tNFT_CB(skb).report = report;\n\tlist_add_tail(&skb->list, notify_list);\n}\n\nstatic void nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, flags, ctx->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(ctx->net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_tables(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\t\tif (idx > s_idx)\n\t\t\tmemset(&cb->args[1], 0,\n\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\tif (!nft_is_active(net, table))\n\t\t\tcontinue;\n\t\tif (nf_tables_fill_table_info(skb, net,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      NFT_MSG_NEWTABLE, NLM_F_MULTI,\n\t\t\t\t\t      table->family, table) < 0)\n\t\t\tgoto done;\n\n\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\tidx++;\n\t}\ndone:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nft_netlink_dump_start_rcu(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t\t      const struct nlmsghdr *nlh,\n\t\t\t\t      struct netlink_dump_control *c)\n{\n\tint err;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\trcu_read_unlock();\n\terr = netlink_dump_start(nlsk, skb, nlh, c);\n\trcu_read_lock();\n\tmodule_put(THIS_MODULE);\n\n\treturn err;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_gettable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nf_tables_dump_tables,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_TABLE_NAME], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_TABLE_NAME]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_table_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\tinfo->nlh->nlmsg_seq, NFT_MSG_NEWTABLE,\n\t\t\t\t\t0, family, table);\n\tif (err < 0)\n\t\tgoto err_fill_table_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_table_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nft_table_disable(struct net *net, struct nft_table *table, u32 cnt)\n{\n\tstruct nft_chain *chain;\n\tu32 i = 0;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_active_next(net, chain))\n\t\t\tcontinue;\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\tif (cnt && i++ == cnt)\n\t\t\tbreak;\n\n\t\tnf_tables_unregister_hook(net, table, chain);\n\t}\n}\n\nstatic int nf_tables_table_enable(struct net *net, struct nft_table *table)\n{\n\tstruct nft_chain *chain;\n\tint err, i = 0;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_active_next(net, chain))\n\t\t\tcontinue;\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\terr = nf_tables_register_hook(net, table, chain);\n\t\tif (err < 0)\n\t\t\tgoto err_register_hooks;\n\n\t\ti++;\n\t}\n\treturn 0;\n\nerr_register_hooks:\n\tif (i)\n\t\tnft_table_disable(net, table, i);\n\treturn err;\n}\n\nstatic void nf_tables_table_disable(struct net *net, struct nft_table *table)\n{\n\ttable->flags &= ~NFT_TABLE_F_DORMANT;\n\tnft_table_disable(net, table, 0);\n\ttable->flags |= NFT_TABLE_F_DORMANT;\n}\n\n#define __NFT_TABLE_F_INTERNAL\t\t(NFT_TABLE_F_MASK + 1)\n#define __NFT_TABLE_F_WAS_DORMANT\t(__NFT_TABLE_F_INTERNAL << 0)\n#define __NFT_TABLE_F_WAS_AWAKEN\t(__NFT_TABLE_F_INTERNAL << 1)\n#define __NFT_TABLE_F_UPDATE\t\t(__NFT_TABLE_F_WAS_DORMANT | \\\n\t\t\t\t\t __NFT_TABLE_F_WAS_AWAKEN)\n\nstatic int nf_tables_updtable(struct nft_ctx *ctx)\n{\n\tstruct nft_trans *trans;\n\tu32 flags;\n\tint ret;\n\n\tif (!ctx->nla[NFTA_TABLE_FLAGS])\n\t\treturn 0;\n\n\tflags = ntohl(nla_get_be32(ctx->nla[NFTA_TABLE_FLAGS]));\n\tif (flags & ~NFT_TABLE_F_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags == ctx->table->flags)\n\t\treturn 0;\n\n\tif ((nft_table_has_owner(ctx->table) &&\n\t     !(flags & NFT_TABLE_F_OWNER)) ||\n\t    (!nft_table_has_owner(ctx->table) &&\n\t     flags & NFT_TABLE_F_OWNER))\n\t\treturn -EOPNOTSUPP;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE,\n\t\t\t\tsizeof(struct nft_trans_table));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\tif ((flags & NFT_TABLE_F_DORMANT) &&\n\t    !(ctx->table->flags & NFT_TABLE_F_DORMANT)) {\n\t\tctx->table->flags |= NFT_TABLE_F_DORMANT;\n\t\tif (!(ctx->table->flags & __NFT_TABLE_F_UPDATE))\n\t\t\tctx->table->flags |= __NFT_TABLE_F_WAS_AWAKEN;\n\t} else if (!(flags & NFT_TABLE_F_DORMANT) &&\n\t\t   ctx->table->flags & NFT_TABLE_F_DORMANT) {\n\t\tctx->table->flags &= ~NFT_TABLE_F_DORMANT;\n\t\tif (!(ctx->table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\tret = nf_tables_table_enable(ctx->net, ctx->table);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_register_hooks;\n\n\t\t\tctx->table->flags |= __NFT_TABLE_F_WAS_DORMANT;\n\t\t}\n\t}\n\n\tnft_trans_table_update(trans) = true;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_register_hooks:\n\tnft_trans_destroy(trans);\n\treturn ret;\n}\n\nstatic u32 nft_chain_hash(const void *data, u32 len, u32 seed)\n{\n\tconst char *name = data;\n\n\treturn jhash(name, strlen(name), seed);\n}\n\nstatic u32 nft_chain_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_chain *chain = data;\n\n\treturn nft_chain_hash(chain->name, 0, seed);\n}\n\nstatic int nft_chain_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t      const void *ptr)\n{\n\tconst struct nft_chain *chain = ptr;\n\tconst char *name = arg->key;\n\n\treturn strcmp(chain->name, name);\n}\n\nstatic u32 nft_objname_hash(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_object_hash_key *k = data;\n\n\tseed ^= hash_ptr(k->table, 32);\n\n\treturn jhash(k->name, strlen(k->name), seed);\n}\n\nstatic u32 nft_objname_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_object *obj = data;\n\n\treturn nft_objname_hash(&obj->key, 0, seed);\n}\n\nstatic int nft_objname_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *ptr)\n{\n\tconst struct nft_object_hash_key *k = arg->key;\n\tconst struct nft_object *obj = ptr;\n\n\tif (obj->key.table != k->table)\n\t\treturn -1;\n\n\treturn strcmp(obj->key.name, k->name);\n}\n\nstatic bool nft_supported_family(u8 family)\n{\n\treturn false\n#ifdef CONFIG_NF_TABLES_INET\n\t\t|| family == NFPROTO_INET\n#endif\n#ifdef CONFIG_NF_TABLES_IPV4\n\t\t|| family == NFPROTO_IPV4\n#endif\n#ifdef CONFIG_NF_TABLES_ARP\n\t\t|| family == NFPROTO_ARP\n#endif\n#ifdef CONFIG_NF_TABLES_NETDEV\n\t\t|| family == NFPROTO_NETDEV\n#endif\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE)\n\t\t|| family == NFPROTO_BRIDGE\n#endif\n#ifdef CONFIG_NF_TABLES_IPV6\n\t\t|| family == NFPROTO_IPV6\n#endif\n\t\t;\n}\n\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL_ACCOUNT);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL_ACCOUNT);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL_ACCOUNT);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++nft_net->table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n\nstatic int nft_flush_table(struct nft_ctx *ctx)\n{\n\tstruct nft_flowtable *flowtable, *nft;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_object *obj, *ne;\n\tstruct nft_set *set, *ns;\n\tint err;\n\n\tlist_for_each_entry(chain, &ctx->table->chains, list) {\n\t\tif (!nft_is_active_next(ctx->net, chain))\n\t\t\tcontinue;\n\n\t\tif (nft_chain_is_bound(chain))\n\t\t\tcontinue;\n\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, set))\n\t\t\tcontinue;\n\n\t\tif (nft_set_is_anonymous(set) &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(flowtable, nft, &ctx->table->flowtables, list) {\n\t\tif (!nft_is_active_next(ctx->net, flowtable))\n\t\t\tcontinue;\n\n\t\terr = nft_delflowtable(ctx, flowtable);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(obj, ne, &ctx->table->objects, list) {\n\t\tif (!nft_is_active_next(ctx->net, obj))\n\t\t\tcontinue;\n\n\t\terr = nft_delobj(ctx, obj);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tif (!nft_is_active_next(ctx->net, chain))\n\t\t\tcontinue;\n\n\t\tif (nft_chain_is_bound(chain))\n\t\t\tcontinue;\n\n\t\tctx->chain = chain;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}\n\nstatic int nft_flush(struct nft_ctx *ctx, int family)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_table *table, *nt;\n\tint err = 0;\n\n\tlist_for_each_entry_safe(table, nt, &nft_net->tables, list) {\n\t\tif (family != AF_UNSPEC && table->family != family)\n\t\t\tcontinue;\n\n\t\tctx->family = table->family;\n\n\t\tif (!nft_is_active_next(ctx->net, table))\n\t\t\tcontinue;\n\n\t\tif (nft_table_has_owner(table) && table->nlpid != ctx->portid)\n\t\t\tcontinue;\n\n\t\tif (nla[NFTA_TABLE_NAME] &&\n\t\t    nla_strcmp(nla[NFTA_TABLE_NAME], table->name) != 0)\n\t\t\tcontinue;\n\n\t\tctx->table = table;\n\n\t\terr = nft_flush_table(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\nstatic int nf_tables_deltable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, 0, NULL, NULL, nla);\n\tif (family == AF_UNSPEC ||\n\t    (!nla[NFTA_TABLE_NAME] && !nla[NFTA_TABLE_HANDLE]))\n\t\treturn nft_flush(&ctx, family);\n\n\tif (nla[NFTA_TABLE_HANDLE]) {\n\t\tattr = nla[NFTA_TABLE_HANDLE];\n\t\ttable = nft_table_lookup_byhandle(net, attr, genmask,\n\t\t\t\t\t\t  NETLINK_CB(skb).portid);\n\t} else {\n\t\tattr = nla[NFTA_TABLE_NAME];\n\t\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t\t NETLINK_CB(skb).portid);\n\t}\n\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t    table->use > 0)\n\t\treturn -EBUSY;\n\n\tctx.family = family;\n\tctx.table = table;\n\n\treturn nft_flush_table(&ctx);\n}\n\nstatic void nf_tables_table_destroy(struct nft_ctx *ctx)\n{\n\tif (WARN_ON(ctx->table->use > 0))\n\t\treturn;\n\n\trhltable_destroy(&ctx->table->chains_ht);\n\tkfree(ctx->table->name);\n\tkfree(ctx->table->udata);\n\tkfree(ctx->table);\n}\n\nvoid nft_register_chain_type(const struct nft_chain_type *ctype)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tif (WARN_ON(__nft_chain_type_get(ctype->family, ctype->type))) {\n\t\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\t\treturn;\n\t}\n\tchain_type[ctype->family][ctype->type] = ctype;\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_register_chain_type);\n\nvoid nft_unregister_chain_type(const struct nft_chain_type *ctype)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tchain_type[ctype->family][ctype->type] = NULL;\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_chain_type);\n\n/*\n * Chains\n */\n\nstatic struct nft_chain *\nnft_chain_lookup_byhandle(const struct nft_table *table, u64 handle, u8 genmask)\n{\n\tstruct nft_chain *chain;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (chain->handle == handle &&\n\t\t    nft_active_genmask(chain, genmask))\n\t\t\treturn chain;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic bool lockdep_commit_lock_is_held(const struct net *net)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\treturn lockdep_is_held(&nft_net->commit_mutex);\n#else\n\treturn true;\n#endif\n}\n\nstatic struct nft_chain *nft_chain_lookup(struct net *net,\n\t\t\t\t\t  struct nft_table *table,\n\t\t\t\t\t  const struct nlattr *nla, u8 genmask)\n{\n\tchar search[NFT_CHAIN_MAXNAMELEN + 1];\n\tstruct rhlist_head *tmp, *list;\n\tstruct nft_chain *chain;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnla_strscpy(search, nla, sizeof(search));\n\n\tWARN_ON(!rcu_read_lock_held() &&\n\t\t!lockdep_commit_lock_is_held(net));\n\n\tchain = ERR_PTR(-ENOENT);\n\trcu_read_lock();\n\tlist = rhltable_lookup(&table->chains_ht, search, nft_chain_ht_params);\n\tif (!list)\n\t\tgoto out_unlock;\n\n\trhl_for_each_entry_rcu(chain, tmp, list, rhlhead) {\n\t\tif (nft_active_genmask(chain, genmask))\n\t\t\tgoto out_unlock;\n\t}\n\tchain = ERR_PTR(-ENOENT);\nout_unlock:\n\trcu_read_unlock();\n\treturn chain;\n}\n\nstatic const struct nla_policy nft_chain_policy[NFTA_CHAIN_MAX + 1] = {\n\t[NFTA_CHAIN_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_CHAIN_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_CHAIN_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_CHAIN_HOOK]\t= { .type = NLA_NESTED },\n\t[NFTA_CHAIN_POLICY]\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_TYPE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_MODULE_AUTOLOAD_LIMIT },\n\t[NFTA_CHAIN_COUNTERS]\t= { .type = NLA_NESTED },\n\t[NFTA_CHAIN_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_ID]\t\t= { .type = NLA_U32 },\n\t[NFTA_CHAIN_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n};\n\nstatic const struct nla_policy nft_hook_policy[NFTA_HOOK_MAX + 1] = {\n\t[NFTA_HOOK_HOOKNUM]\t= { .type = NLA_U32 },\n\t[NFTA_HOOK_PRIORITY]\t= { .type = NLA_U32 },\n\t[NFTA_HOOK_DEV]\t\t= { .type = NLA_STRING,\n\t\t\t\t    .len = IFNAMSIZ - 1 },\n};\n\nstatic int nft_dump_stats(struct sk_buff *skb, struct nft_stats __percpu *stats)\n{\n\tstruct nft_stats *cpu_stats, total;\n\tstruct nlattr *nest;\n\tunsigned int seq;\n\tu64 pkts, bytes;\n\tint cpu;\n\n\tif (!stats)\n\t\treturn 0;\n\n\tmemset(&total, 0, sizeof(total));\n\tfor_each_possible_cpu(cpu) {\n\t\tcpu_stats = per_cpu_ptr(stats, cpu);\n\t\tdo {\n\t\t\tseq = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n\t\t\tpkts = cpu_stats->pkts;\n\t\t\tbytes = cpu_stats->bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, seq));\n\t\ttotal.pkts += pkts;\n\t\ttotal.bytes += bytes;\n\t}\n\tnest = nla_nest_start_noflag(skb, NFTA_CHAIN_COUNTERS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.pkts),\n\t\t\t NFTA_COUNTER_PAD) ||\n\t    nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes),\n\t\t\t NFTA_COUNTER_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic int nft_dump_basechain_hook(struct sk_buff *skb, int family,\n\t\t\t\t   const struct nft_base_chain *basechain)\n{\n\tconst struct nf_hook_ops *ops = &basechain->ops;\n\tstruct nft_hook *hook, *first = NULL;\n\tstruct nlattr *nest, *nest_devs;\n\tint n = 0;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_CHAIN_HOOK);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HOOK_HOOKNUM, htonl(ops->hooknum)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HOOK_PRIORITY, htonl(ops->priority)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_base_chain_netdev(family, ops->hooknum)) {\n\t\tnest_devs = nla_nest_start_noflag(skb, NFTA_HOOK_DEVS);\n\t\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\t\tif (!first)\n\t\t\t\tfirst = hook;\n\n\t\t\tif (nla_put_string(skb, NFTA_DEVICE_NAME,\n\t\t\t\t\t   hook->ops.dev->name))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tn++;\n\t\t}\n\t\tnla_nest_end(skb, nest_devs);\n\n\t\tif (n == 1 &&\n\t\t    nla_put_string(skb, NFTA_HOOK_DEV, first->ops.dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nf_tables_fill_chain_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t     u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t     int family, const struct nft_table *table,\n\t\t\t\t     const struct nft_chain *chain)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_CHAIN_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_CHAIN_HANDLE, cpu_to_be64(chain->handle),\n\t\t\t NFTA_CHAIN_PAD))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_CHAIN_NAME, chain->name))\n\t\tgoto nla_put_failure;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tconst struct nft_base_chain *basechain = nft_base_chain(chain);\n\t\tstruct nft_stats __percpu *stats;\n\n\t\tif (nft_dump_basechain_hook(skb, family, basechain))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be32(skb, NFTA_CHAIN_POLICY,\n\t\t\t\t htonl(basechain->policy)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(skb, NFTA_CHAIN_TYPE, basechain->type->name))\n\t\t\tgoto nla_put_failure;\n\n\t\tstats = rcu_dereference_check(basechain->stats,\n\t\t\t\t\t      lockdep_commit_lock_is_held(net));\n\t\tif (nft_dump_stats(skb, stats))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (chain->flags &&\n\t    nla_put_be32(skb, NFTA_CHAIN_FLAGS, htonl(chain->flags)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_CHAIN_USE, htonl(chain->use)))\n\t\tgoto nla_put_failure;\n\n\tif (chain->udata &&\n\t    nla_put(skb, NFTA_CHAIN_USERDATA, chain->udlen, chain->udata))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_chain_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_chain_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, flags, ctx->family, ctx->table,\n\t\t\t\t\tctx->chain);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(ctx->net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_chains(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\tconst struct nft_chain *chain;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(chain, &table->chains, list) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (!nft_is_active(net, chain))\n\t\t\t\tcontinue;\n\t\t\tif (nf_tables_fill_chain_info(skb, net,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      NFT_MSG_NEWCHAIN,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      table->family, table,\n\t\t\t\t\t\t      chain) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_chain *chain;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nf_tables_dump_chains,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = nft_chain_lookup(net, table, nla[NFTA_CHAIN_NAME], genmask);\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_chain_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\tinfo->nlh->nlmsg_seq, NFT_MSG_NEWCHAIN,\n\t\t\t\t\t0, family, table, chain);\n\tif (err < 0)\n\t\tgoto err_fill_chain_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_chain_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nla_policy nft_counter_policy[NFTA_COUNTER_MAX + 1] = {\n\t[NFTA_COUNTER_PACKETS]\t= { .type = NLA_U64 },\n\t[NFTA_COUNTER_BYTES]\t= { .type = NLA_U64 },\n};\n\nstatic struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_COUNTER_MAX, attr,\n\t\t\t\t\t  nft_counter_policy, NULL);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Restore old counters on this cpu, no problem. Per-cpu statistics\n\t * are not exposed to userspace.\n\t */\n\tpreempt_disable();\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\tpreempt_enable();\n\n\treturn newstats;\n}\n\nstatic void nft_chain_stats_replace(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *chain = nft_base_chain(trans->ctx.chain);\n\n\tif (!nft_trans_chain_stats(trans))\n\t\treturn;\n\n\tnft_trans_chain_stats(trans) =\n\t\trcu_replace_pointer(chain->stats, nft_trans_chain_stats(trans),\n\t\t\t\t    lockdep_commit_lock_is_held(trans->ctx.net));\n\n\tif (!nft_trans_chain_stats(trans))\n\t\tstatic_branch_inc(&nft_counters_enabled);\n}\n\nstatic void nf_tables_chain_free_chain_rules(struct nft_chain *chain)\n{\n\tstruct nft_rule_blob *g0 = rcu_dereference_raw(chain->blob_gen_0);\n\tstruct nft_rule_blob *g1 = rcu_dereference_raw(chain->blob_gen_1);\n\n\tif (g0 != g1)\n\t\tkvfree(g1);\n\tkvfree(g0);\n\n\t/* should be NULL either via abort or via successful commit */\n\tWARN_ON_ONCE(chain->blob_next);\n\tkvfree(chain->blob_next);\n}\n\nvoid nf_tables_chain_destroy(struct nft_ctx *ctx)\n{\n\tstruct nft_chain *chain = ctx->chain;\n\tstruct nft_hook *hook, *next;\n\n\tif (WARN_ON(chain->use > 0))\n\t\treturn;\n\n\t/* no concurrent access possible anymore */\n\tnf_tables_chain_free_chain_rules(chain);\n\n\tif (nft_is_base_chain(chain)) {\n\t\tstruct nft_base_chain *basechain = nft_base_chain(chain);\n\n\t\tif (nft_base_chain_netdev(ctx->family, basechain->ops.hooknum)) {\n\t\t\tlist_for_each_entry_safe(hook, next,\n\t\t\t\t\t\t &basechain->hook_list, list) {\n\t\t\t\tlist_del_rcu(&hook->list);\n\t\t\t\tkfree_rcu(hook, rcu);\n\t\t\t}\n\t\t}\n\t\tmodule_put(basechain->type->owner);\n\t\tif (rcu_access_pointer(basechain->stats)) {\n\t\t\tstatic_branch_dec(&nft_counters_enabled);\n\t\t\tfree_percpu(rcu_dereference_raw(basechain->stats));\n\t\t}\n\t\tkfree(chain->name);\n\t\tkfree(chain->udata);\n\t\tkfree(basechain);\n\t} else {\n\t\tkfree(chain->name);\n\t\tkfree(chain->udata);\n\t\tkfree(chain);\n\t}\n}\n\nstatic struct nft_hook *nft_netdev_hook_alloc(struct net *net,\n\t\t\t\t\t      const struct nlattr *attr)\n{\n\tstruct net_device *dev;\n\tchar ifname[IFNAMSIZ];\n\tstruct nft_hook *hook;\n\tint err;\n\n\thook = kmalloc(sizeof(struct nft_hook), GFP_KERNEL_ACCOUNT);\n\tif (!hook) {\n\t\terr = -ENOMEM;\n\t\tgoto err_hook_alloc;\n\t}\n\n\tnla_strscpy(ifname, attr, IFNAMSIZ);\n\t/* nf_tables_netdev_event() is called under rtnl_mutex, this is\n\t * indirectly serializing all the other holders of the commit_mutex with\n\t * the rtnl_mutex.\n\t */\n\tdev = __dev_get_by_name(net, ifname);\n\tif (!dev) {\n\t\terr = -ENOENT;\n\t\tgoto err_hook_dev;\n\t}\n\thook->ops.dev = dev;\n\n\treturn hook;\n\nerr_hook_dev:\n\tkfree(hook);\nerr_hook_alloc:\n\treturn ERR_PTR(err);\n}\n\nstatic struct nft_hook *nft_hook_list_find(struct list_head *hook_list,\n\t\t\t\t\t   const struct nft_hook *this)\n{\n\tstruct nft_hook *hook;\n\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tif (this->ops.dev == hook->ops.dev)\n\t\t\treturn hook;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nf_tables_parse_netdev_hooks(struct net *net,\n\t\t\t\t\tconst struct nlattr *attr,\n\t\t\t\t\tstruct list_head *hook_list)\n{\n\tstruct nft_hook *hook, *next;\n\tconst struct nlattr *tmp;\n\tint rem, n = 0, err;\n\n\tnla_for_each_nested(tmp, attr, rem) {\n\t\tif (nla_type(tmp) != NFTA_DEVICE_NAME) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_hook;\n\t\t}\n\n\t\thook = nft_netdev_hook_alloc(net, tmp);\n\t\tif (IS_ERR(hook)) {\n\t\t\terr = PTR_ERR(hook);\n\t\t\tgoto err_hook;\n\t\t}\n\t\tif (nft_hook_list_find(hook_list, hook)) {\n\t\t\tkfree(hook);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err_hook;\n\t\t}\n\t\tlist_add_tail(&hook->list, hook_list);\n\t\tn++;\n\n\t\tif (n == NFT_NETDEVICE_MAX) {\n\t\t\terr = -EFBIG;\n\t\t\tgoto err_hook;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_hook:\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tlist_del(&hook->list);\n\t\tkfree(hook);\n\t}\n\treturn err;\n}\n\nstruct nft_chain_hook {\n\tu32\t\t\t\tnum;\n\ts32\t\t\t\tpriority;\n\tconst struct nft_chain_type\t*type;\n\tstruct list_head\t\tlist;\n};\n\nstatic int nft_chain_parse_netdev(struct net *net,\n\t\t\t\t  struct nlattr *tb[],\n\t\t\t\t  struct list_head *hook_list)\n{\n\tstruct nft_hook *hook;\n\tint err;\n\n\tif (tb[NFTA_HOOK_DEV]) {\n\t\thook = nft_netdev_hook_alloc(net, tb[NFTA_HOOK_DEV]);\n\t\tif (IS_ERR(hook))\n\t\t\treturn PTR_ERR(hook);\n\n\t\tlist_add_tail(&hook->list, hook_list);\n\t} else if (tb[NFTA_HOOK_DEVS]) {\n\t\terr = nf_tables_parse_netdev_hooks(net, tb[NFTA_HOOK_DEVS],\n\t\t\t\t\t\t   hook_list);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (list_empty(hook_list))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_chain_parse_hook(struct net *net,\n\t\t\t\tconst struct nlattr * const nla[],\n\t\t\t\tstruct nft_chain_hook *hook, u8 family,\n\t\t\t\tstruct netlink_ext_ack *extack, bool autoload)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nlattr *ha[NFTA_HOOK_MAX + 1];\n\tconst struct nft_chain_type *type;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tlockdep_nfnl_nft_mutex_not_held();\n\n\terr = nla_parse_nested_deprecated(ha, NFTA_HOOK_MAX,\n\t\t\t\t\t  nla[NFTA_CHAIN_HOOK],\n\t\t\t\t\t  nft_hook_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ha[NFTA_HOOK_HOOKNUM] == NULL ||\n\t    ha[NFTA_HOOK_PRIORITY] == NULL)\n\t\treturn -EINVAL;\n\n\thook->num = ntohl(nla_get_be32(ha[NFTA_HOOK_HOOKNUM]));\n\thook->priority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));\n\n\ttype = __nft_chain_type_get(family, NFT_CHAIN_T_DEFAULT);\n\tif (!type)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla[NFTA_CHAIN_TYPE]) {\n\t\ttype = nf_tables_chain_type_lookup(net, nla[NFTA_CHAIN_TYPE],\n\t\t\t\t\t\t   family, autoload);\n\t\tif (IS_ERR(type)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TYPE]);\n\t\t\treturn PTR_ERR(type);\n\t\t}\n\t}\n\tif (hook->num >= NFT_MAX_HOOKS || !(type->hook_mask & (1 << hook->num)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (type->type == NFT_CHAIN_T_NAT &&\n\t    hook->priority <= NF_IP_PRI_CONNTRACK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!try_module_get(type->owner)) {\n\t\tif (nla[NFTA_CHAIN_TYPE])\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TYPE]);\n\t\treturn -ENOENT;\n\t}\n\n\thook->type = type;\n\n\tINIT_LIST_HEAD(&hook->list);\n\tif (nft_base_chain_netdev(family, hook->num)) {\n\t\terr = nft_chain_parse_netdev(net, ha, &hook->list);\n\t\tif (err < 0) {\n\t\t\tmodule_put(type->owner);\n\t\t\treturn err;\n\t\t}\n\t} else if (ha[NFTA_HOOK_DEV] || ha[NFTA_HOOK_DEVS]) {\n\t\tmodule_put(type->owner);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_chain_release_hook(struct nft_chain_hook *hook)\n{\n\tstruct nft_hook *h, *next;\n\n\tlist_for_each_entry_safe(h, next, &hook->list, list) {\n\t\tlist_del(&h->list);\n\t\tkfree(h);\n\t}\n\tmodule_put(hook->type->owner);\n}\n\nstruct nft_rules_old {\n\tstruct rcu_head h;\n\tstruct nft_rule_blob *blob;\n};\n\nstatic void nft_last_rule(struct nft_rule_blob *blob, const void *ptr)\n{\n\tstruct nft_rule_dp *prule;\n\n\tprule = (struct nft_rule_dp *)ptr;\n\tprule->is_last = 1;\n\t/* blob size does not include the trailer rule */\n}\n\nstatic struct nft_rule_blob *nf_tables_chain_alloc_rules(unsigned int size)\n{\n\tstruct nft_rule_blob *blob;\n\n\t/* size must include room for the last rule */\n\tif (size < offsetof(struct nft_rule_dp, data))\n\t\treturn NULL;\n\n\tsize += sizeof(struct nft_rule_blob) + sizeof(struct nft_rules_old);\n\tif (size > INT_MAX)\n\t\treturn NULL;\n\n\tblob = kvmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!blob)\n\t\treturn NULL;\n\n\tblob->size = 0;\n\tnft_last_rule(blob, blob->data);\n\n\treturn blob;\n}\n\nstatic void nft_basechain_hook_init(struct nf_hook_ops *ops, u8 family,\n\t\t\t\t    const struct nft_chain_hook *hook,\n\t\t\t\t    struct nft_chain *chain)\n{\n\tops->pf\t\t\t= family;\n\tops->hooknum\t\t= hook->num;\n\tops->priority\t\t= hook->priority;\n\tops->priv\t\t= chain;\n\tops->hook\t\t= hook->type->hooks[ops->hooknum];\n\tops->hook_ops_type\t= NF_HOOK_OP_NF_TABLES;\n}\n\nstatic int nft_basechain_init(struct nft_base_chain *basechain, u8 family,\n\t\t\t      struct nft_chain_hook *hook, u32 flags)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_hook *h;\n\n\tbasechain->type = hook->type;\n\tINIT_LIST_HEAD(&basechain->hook_list);\n\tchain = &basechain->chain;\n\n\tif (nft_base_chain_netdev(family, hook->num)) {\n\t\tlist_splice_init(&hook->list, &basechain->hook_list);\n\t\tlist_for_each_entry(h, &basechain->hook_list, list)\n\t\t\tnft_basechain_hook_init(&h->ops, family, hook, chain);\n\n\t\tbasechain->ops.hooknum\t= hook->num;\n\t\tbasechain->ops.priority\t= hook->priority;\n\t} else {\n\t\tnft_basechain_hook_init(&basechain->ops, family, hook, chain);\n\t}\n\n\tchain->flags |= NFT_CHAIN_BASE | flags;\n\tbasechain->policy = NF_ACCEPT;\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD &&\n\t    !nft_chain_offload_support(basechain))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_block_init(&basechain->flow_block);\n\n\treturn 0;\n}\n\nstatic int nft_chain_add(struct nft_table *table, struct nft_chain *chain)\n{\n\tint err;\n\n\terr = rhltable_insert_key(&table->chains_ht, chain->name,\n\t\t\t\t  &chain->rhlhead, nft_chain_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tlist_add_tail_rcu(&chain->list, &table->chains);\n\n\treturn 0;\n}\n\nstatic u64 chain_id;\n\nstatic int nf_tables_addchain(struct nft_ctx *ctx, u8 family, u8 genmask,\n\t\t\t      u8 policy, u32 flags,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_stats __percpu *stats = NULL;\n\tstruct nft_table *table = ctx->table;\n\tstruct nft_base_chain *basechain;\n\tstruct net *net = ctx->net;\n\tchar name[NFT_NAME_MAXLEN];\n\tstruct nft_rule_blob *blob;\n\tstruct nft_trans *trans;\n\tstruct nft_chain *chain;\n\tunsigned int data_size;\n\tint err;\n\n\tif (table->use == UINT_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (nla[NFTA_CHAIN_HOOK]) {\n\t\tstruct nft_chain_hook hook;\n\n\t\tif (flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_chain_parse_hook(net, nla, &hook, family, extack,\n\t\t\t\t\t   true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbasechain = kzalloc(sizeof(*basechain), GFP_KERNEL_ACCOUNT);\n\t\tif (basechain == NULL) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tchain = &basechain->chain;\n\n\t\tif (nla[NFTA_CHAIN_COUNTERS]) {\n\t\t\tstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\n\t\t\tif (IS_ERR(stats)) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tkfree(basechain);\n\t\t\t\treturn PTR_ERR(stats);\n\t\t\t}\n\t\t\trcu_assign_pointer(basechain->stats, stats);\n\t\t}\n\n\t\terr = nft_basechain_init(basechain, family, &hook, flags);\n\t\tif (err < 0) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\tkfree(basechain);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (flags & NFT_CHAIN_BASE)\n\t\t\treturn -EINVAL;\n\t\tif (flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tchain = kzalloc(sizeof(*chain), GFP_KERNEL_ACCOUNT);\n\t\tif (chain == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tchain->flags = flags;\n\t}\n\tctx->chain = chain;\n\n\tINIT_LIST_HEAD(&chain->rules);\n\tchain->handle = nf_tables_alloc_handle(table);\n\tchain->table = table;\n\n\tif (nla[NFTA_CHAIN_NAME]) {\n\t\tchain->name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL_ACCOUNT);\n\t} else {\n\t\tif (!(flags & NFT_CHAIN_BINDING)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_destroy_chain;\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"__chain%llu\", ++chain_id);\n\t\tchain->name = kstrdup(name, GFP_KERNEL_ACCOUNT);\n\t}\n\n\tif (!chain->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_chain;\n\t}\n\n\tif (nla[NFTA_CHAIN_USERDATA]) {\n\t\tchain->udata = nla_memdup(nla[NFTA_CHAIN_USERDATA], GFP_KERNEL_ACCOUNT);\n\t\tif (chain->udata == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_chain;\n\t\t}\n\t\tchain->udlen = nla_len(nla[NFTA_CHAIN_USERDATA]);\n\t}\n\n\tdata_size = offsetof(struct nft_rule_dp, data);\t/* last rule */\n\tblob = nf_tables_chain_alloc_rules(data_size);\n\tif (!blob) {\n\t\terr = -ENOMEM;\n\t\tgoto err_destroy_chain;\n\t}\n\n\tRCU_INIT_POINTER(chain->blob_gen_0, blob);\n\tRCU_INIT_POINTER(chain->blob_gen_1, blob);\n\n\terr = nf_tables_register_hook(net, table, chain);\n\tif (err < 0)\n\t\tgoto err_destroy_chain;\n\n\ttrans = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto err_unregister_hook;\n\t}\n\n\tnft_trans_chain_policy(trans) = NFT_CHAIN_POLICY_UNSET;\n\tif (nft_is_base_chain(chain))\n\t\tnft_trans_chain_policy(trans) = policy;\n\n\terr = nft_chain_add(table, chain);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\tgoto err_unregister_hook;\n\t}\n\n\tif (stats)\n\t\tstatic_branch_inc(&nft_counters_enabled);\n\n\ttable->use++;\n\n\treturn 0;\nerr_unregister_hook:\n\tnf_tables_unregister_hook(net, table, chain);\nerr_destroy_chain:\n\tnf_tables_chain_destroy(ctx);\n\n\treturn err;\n}\n\nstatic bool nft_hook_list_equal(struct list_head *hook_list1,\n\t\t\t\tstruct list_head *hook_list2)\n{\n\tstruct nft_hook *hook;\n\tint n = 0, m = 0;\n\n\tn = 0;\n\tlist_for_each_entry(hook, hook_list2, list) {\n\t\tif (!nft_hook_list_find(hook_list1, hook))\n\t\t\treturn false;\n\n\t\tn++;\n\t}\n\tlist_for_each_entry(hook, hook_list1, list)\n\t\tm++;\n\n\treturn n == m;\n}\n\nstatic int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,\n\t\t\t      u32 flags, const struct nlattr *attr,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_table *table = ctx->table;\n\tstruct nft_chain *chain = ctx->chain;\n\tstruct nft_base_chain *basechain;\n\tstruct nft_stats *stats = NULL;\n\tstruct nft_chain_hook hook;\n\tstruct nf_hook_ops *ops;\n\tstruct nft_trans *trans;\n\tint err;\n\n\tif (chain->flags ^ flags)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla[NFTA_CHAIN_HOOK]) {\n\t\tif (!nft_is_base_chain(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\terr = nft_chain_parse_hook(ctx->net, nla, &hook, ctx->family,\n\t\t\t\t\t   extack, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type != hook.type) {\n\t\t\tnft_chain_release_hook(&hook);\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tif (nft_base_chain_netdev(ctx->family, hook.num)) {\n\t\t\tif (!nft_hook_list_equal(&basechain->hook_list,\n\t\t\t\t\t\t &hook.list)) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t} else {\n\t\t\tops = &basechain->ops;\n\t\t\tif (ops->hooknum != hook.num ||\n\t\t\t    ops->priority != hook.priority) {\n\t\t\t\tnft_chain_release_hook(&hook);\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t}\n\t\tnft_chain_release_hook(&hook);\n\t}\n\n\tif (nla[NFTA_CHAIN_HANDLE] &&\n\t    nla[NFTA_CHAIN_NAME]) {\n\t\tstruct nft_chain *chain2;\n\n\t\tchain2 = nft_chain_lookup(ctx->net, table,\n\t\t\t\t\t  nla[NFTA_CHAIN_NAME], genmask);\n\t\tif (!IS_ERR(chain2)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (nla[NFTA_CHAIN_COUNTERS]) {\n\t\tif (!nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\n\t\tif (IS_ERR(stats))\n\t\t\treturn PTR_ERR(stats);\n\t}\n\n\terr = -ENOMEM;\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWCHAIN,\n\t\t\t\tsizeof(struct nft_trans_chain));\n\tif (trans == NULL)\n\t\tgoto err;\n\n\tnft_trans_chain_stats(trans) = stats;\n\tnft_trans_chain_update(trans) = true;\n\n\tif (nla[NFTA_CHAIN_POLICY])\n\t\tnft_trans_chain_policy(trans) = policy;\n\telse\n\t\tnft_trans_chain_policy(trans) = -1;\n\n\tif (nla[NFTA_CHAIN_HANDLE] &&\n\t    nla[NFTA_CHAIN_NAME]) {\n\t\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\t\tstruct nft_trans *tmp;\n\t\tchar *name;\n\n\t\terr = -ENOMEM;\n\t\tname = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL_ACCOUNT);\n\t\tif (!name)\n\t\t\tgoto err;\n\n\t\terr = -EEXIST;\n\t\tlist_for_each_entry(tmp, &nft_net->commit_list, list) {\n\t\t\tif (tmp->msg_type == NFT_MSG_NEWCHAIN &&\n\t\t\t    tmp->ctx.table == table &&\n\t\t\t    nft_trans_chain_update(tmp) &&\n\t\t\t    nft_trans_chain_name(tmp) &&\n\t\t\t    strcmp(name, nft_trans_chain_name(tmp)) == 0) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);\n\t\t\t\tkfree(name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tnft_trans_chain_name(trans) = name;\n\t}\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\nerr:\n\tfree_percpu(stats);\n\tkfree(trans);\n\treturn err;\n}\n\nstatic struct nft_chain *nft_chain_lookup_byid(const struct net *net,\n\t\t\t\t\t       const struct nft_table *table,\n\t\t\t\t\t       const struct nlattr *nla)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tstruct nft_chain *chain = trans->ctx.chain;\n\n\t\tif (trans->msg_type == NFT_MSG_NEWCHAIN &&\n\t\t    chain->table == table &&\n\t\t    id == nft_trans_chain_id(trans))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_newchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_chain *chain = NULL;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tu8 policy = NF_ACCEPT;\n\tstruct nft_ctx ctx;\n\tu64 handle = 0;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = NULL;\n\tattr = nla[NFTA_CHAIN_NAME];\n\n\tif (nla[NFTA_CHAIN_HANDLE]) {\n\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));\n\t\tchain = nft_chain_lookup_byhandle(table, handle, genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tattr = nla[NFTA_CHAIN_HANDLE];\n\t} else if (nla[NFTA_CHAIN_NAME]) {\n\t\tchain = nft_chain_lookup(net, table, attr, genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tif (PTR_ERR(chain) != -ENOENT) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\t\treturn PTR_ERR(chain);\n\t\t\t}\n\t\t\tchain = NULL;\n\t\t}\n\t} else if (!nla[NFTA_CHAIN_ID]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_CHAIN_POLICY]) {\n\t\tif (chain != NULL &&\n\t\t    !nft_is_base_chain(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (chain == NULL &&\n\t\t    nla[NFTA_CHAIN_HOOK] == NULL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));\n\t\tswitch (policy) {\n\t\tcase NF_DROP:\n\t\tcase NF_ACCEPT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (nla[NFTA_CHAIN_FLAGS])\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_CHAIN_FLAGS]));\n\telse if (chain)\n\t\tflags = chain->flags;\n\n\tif (flags & ~NFT_CHAIN_FLAGS)\n\t\treturn -EOPNOTSUPP;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tif (chain != NULL) {\n\t\tif (chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tflags |= chain->flags & NFT_CHAIN_BASE;\n\t\treturn nf_tables_updchain(&ctx, genmask, policy, flags, attr,\n\t\t\t\t\t  extack);\n\t}\n\n\treturn nf_tables_addchain(&ctx, family, genmask, policy, flags, extack);\n}\n\nstatic int nf_tables_delchain(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\tstruct nft_ctx ctx;\n\tu64 handle;\n\tu32 use;\n\tint err;\n\n\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_CHAIN_HANDLE]) {\n\t\tattr = nla[NFTA_CHAIN_HANDLE];\n\t\thandle = be64_to_cpu(nla_get_be64(attr));\n\t\tchain = nft_chain_lookup_byhandle(table, handle, genmask);\n\t} else {\n\t\tattr = nla[NFTA_CHAIN_NAME];\n\t\tchain = nft_chain_lookup(net, table, attr, genmask);\n\t}\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t    chain->use > 0)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tuse = chain->use;\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(net, rule))\n\t\t\tcontinue;\n\t\tuse--;\n\n\t\terr = nft_delrule(&ctx, rule);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* There are rules and elements that are still holding references to us,\n\t * we cannot do a recursive removal in this case.\n\t */\n\tif (use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\treturn nft_delchain(&ctx);\n}\n\n/*\n * Expressions\n */\n\n/**\n *\tnft_register_expr - register nf_tables expr type\n *\t@type: expr type\n *\n *\tRegisters the expr type for use with nf_tables. Returns zero on\n *\tsuccess or a negative errno code otherwise.\n */\nint nft_register_expr(struct nft_expr_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tif (type->family == NFPROTO_UNSPEC)\n\t\tlist_add_tail_rcu(&type->list, &nf_tables_expressions);\n\telse\n\t\tlist_add_rcu(&type->list, &nf_tables_expressions);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_register_expr);\n\n/**\n *\tnft_unregister_expr - unregister nf_tables expr type\n *\t@type: expr type\n *\n * \tUnregisters the expr typefor use with nf_tables.\n */\nvoid nft_unregister_expr(struct nft_expr_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_expr);\n\nstatic const struct nft_expr_type *__nft_expr_type_get(u8 family,\n\t\t\t\t\t\t       struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type, *candidate = NULL;\n\n\tlist_for_each_entry(type, &nf_tables_expressions, list) {\n\t\tif (!nla_strcmp(nla, type->name)) {\n\t\t\tif (!type->family && !candidate)\n\t\t\t\tcandidate = type;\n\t\t\telse if (type->family == family)\n\t\t\t\tcandidate = type;\n\t\t}\n\t}\n\treturn candidate;\n}\n\n#ifdef CONFIG_MODULES\nstatic int nft_expr_type_request_module(struct net *net, u8 family,\n\t\t\t\t\tstruct nlattr *nla)\n{\n\tif (nft_request_module(net, \"nft-expr-%u-%.*s\", family,\n\t\t\t       nla_len(nla), (char *)nla_data(nla)) == -EAGAIN)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n#endif\n\nstatic const struct nft_expr_type *nft_expr_type_get(struct net *net,\n\t\t\t\t\t\t     u8 family,\n\t\t\t\t\t\t     struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttype = __nft_expr_type_get(family, nla);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_expr_type_request_module(net, family, nla) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\n\t\tif (nft_request_module(net, \"nft-expr-%.*s\",\n\t\t\t\t       nla_len(nla),\n\t\t\t\t       (char *)nla_data(nla)) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic const struct nla_policy nft_expr_policy[NFTA_EXPR_MAX + 1] = {\n\t[NFTA_EXPR_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_MODULE_AUTOLOAD_LIMIT },\n\t[NFTA_EXPR_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic int nf_tables_fill_expr_info(struct sk_buff *skb,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tif (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))\n\t\tgoto nla_put_failure;\n\n\tif (expr->ops->dump) {\n\t\tstruct nlattr *data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t    NFTA_EXPR_DATA);\n\t\tif (data == NULL)\n\t\t\tgoto nla_put_failure;\n\t\tif (expr->ops->dump(skb, expr) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, data);\n\t}\n\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -1;\n};\n\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\n\t\t  const struct nft_expr *expr)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (nf_tables_fill_expr_info(skb, expr) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstruct nft_expr_info {\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nlattr\t\t*attr;\n\tstruct nlattr\t\t\t*tb[NFT_EXPR_MAXATTR + 1];\n};\n\nstatic int nf_tables_expr_parse(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr *nla,\n\t\t\t\tstruct nft_expr_info *info)\n{\n\tconst struct nft_expr_type *type;\n\tconst struct nft_expr_ops *ops;\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\ttype = nft_expr_type_get(ctx->net, ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tif (tb[NFTA_EXPR_DATA]) {\n\t\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t\t  type->policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t} else\n\t\tmemset(info->tb, 0, sizeof(info->tb[0]) * (type->maxattr + 1));\n\n\tif (type->select_ops != NULL) {\n\t\tops = type->select_ops(ctx,\n\t\t\t\t       (const struct nlattr * const *)info->tb);\n\t\tif (IS_ERR(ops)) {\n\t\t\terr = PTR_ERR(ops);\n#ifdef CONFIG_MODULES\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tif (nft_expr_type_request_module(ctx->net,\n\t\t\t\t\t\t\t\t ctx->family,\n\t\t\t\t\t\t\t\t tb[NFTA_EXPR_NAME]) != -EAGAIN)\n\t\t\t\t\terr = -ENOENT;\n#endif\n\t\t\tgoto err1;\n\t\t}\n\t} else\n\t\tops = type->ops;\n\n\tinfo->attr = nla;\n\tinfo->ops = ops;\n\n\treturn 0;\n\nerr1:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_newexpr(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr_info *expr_info,\n\t\t\t     struct nft_expr *expr)\n{\n\tconst struct nft_expr_ops *ops = expr_info->ops;\n\tint err;\n\n\texpr->ops = ops;\n\tif (ops->init) {\n\t\terr = ops->init(ctx, expr, (const struct nlattr **)expr_info->tb);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t}\n\n\treturn 0;\nerr1:\n\texpr->ops = NULL;\n\treturn err;\n}\n\nstatic void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tconst struct nft_expr_type *type = expr->ops->type;\n\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(type->owner);\n}\n\nstatic struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nlattr *nla)\n{\n\tstruct nft_expr_info expr_info;\n\tstruct nft_expr *expr;\n\tstruct module *owner;\n\tint err;\n\n\terr = nf_tables_expr_parse(ctx, nla, &expr_info);\n\tif (err < 0)\n\t\tgoto err_expr_parse;\n\n\terr = -EOPNOTSUPP;\n\tif (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))\n\t\tgoto err_expr_stateful;\n\n\terr = -ENOMEM;\n\texpr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);\n\tif (expr == NULL)\n\t\tgoto err_expr_stateful;\n\n\terr = nf_tables_newexpr(ctx, &expr_info, expr);\n\tif (err < 0)\n\t\tgoto err_expr_new;\n\n\treturn expr;\nerr_expr_new:\n\tkfree(expr);\nerr_expr_stateful:\n\towner = expr_info.ops->type->owner;\n\tif (expr_info.ops->type->release_ops)\n\t\texpr_info.ops->type->release_ops(expr_info.ops);\n\n\tmodule_put(owner);\nerr_expr_parse:\n\treturn ERR_PTR(err);\n}\n\nint nft_expr_clone(struct nft_expr *dst, struct nft_expr *src)\n{\n\tint err;\n\n\tif (src->ops->clone) {\n\t\tdst->ops = src->ops;\n\t\terr = src->ops->clone(dst, src);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tmemcpy(dst, src, src->ops->size);\n\t}\n\n\t__module_get(src->ops->type->owner);\n\n\treturn 0;\n}\n\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr)\n{\n\tnf_tables_expr_destroy(ctx, expr);\n\tkfree(expr);\n}\n\n/*\n * Rules\n */\n\nstatic struct nft_rule *__nft_rule_lookup(const struct nft_chain *chain,\n\t\t\t\t\t  u64 handle)\n{\n\tstruct nft_rule *rule;\n\n\t// FIXME: this sucks\n\tlist_for_each_entry_rcu(rule, &chain->rules, list) {\n\t\tif (handle == rule->handle)\n\t\t\treturn rule;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_rule *nft_rule_lookup(const struct nft_chain *chain,\n\t\t\t\t\tconst struct nlattr *nla)\n{\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __nft_rule_lookup(chain, be64_to_cpu(nla_get_be64(nla)));\n}\n\nstatic const struct nla_policy nft_rule_policy[NFTA_RULE_MAX + 1] = {\n\t[NFTA_RULE_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_RULE_CHAIN]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_RULE_HANDLE]\t= { .type = NLA_U64 },\n\t[NFTA_RULE_EXPRESSIONS]\t= { .type = NLA_NESTED },\n\t[NFTA_RULE_COMPAT]\t= { .type = NLA_NESTED },\n\t[NFTA_RULE_POSITION]\t= { .type = NLA_U64 },\n\t[NFTA_RULE_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n\t[NFTA_RULE_ID]\t\t= { .type = NLA_U32 },\n\t[NFTA_RULE_POSITION_ID]\t= { .type = NLA_U32 },\n\t[NFTA_RULE_CHAIN_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nf_tables_fill_rule_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t    u32 portid, u32 seq, int event,\n\t\t\t\t    u32 flags, int family,\n\t\t\t\t    const struct nft_table *table,\n\t\t\t\t    const struct nft_chain *chain,\n\t\t\t\t    const struct nft_rule *rule, u64 handle)\n{\n\tstruct nlmsghdr *nlh;\n\tconst struct nft_expr *expr, *next;\n\tstruct nlattr *list;\n\tu16 type = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\n\tnlh = nfnl_msg_put(skb, portid, seq, type, flags, family, NFNETLINK_V0,\n\t\t\t   nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_RULE_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_RULE_CHAIN, chain->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_RULE_HANDLE, cpu_to_be64(rule->handle),\n\t\t\t NFTA_RULE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (event != NFT_MSG_DELRULE && handle) {\n\t\tif (nla_put_be64(skb, NFTA_RULE_POSITION, cpu_to_be64(handle),\n\t\t\t\t NFTA_RULE_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\tnft_flow_rule_stats(chain, rule);\n\n\tlist = nla_nest_start_noflag(skb, NFTA_RULE_EXPRESSIONS);\n\tif (list == NULL)\n\t\tgoto nla_put_failure;\n\tnft_rule_for_each_expr(expr, next, rule) {\n\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, list);\n\n\tif (rule->udata) {\n\t\tstruct nft_userdata *udata = nft_userdata(rule);\n\t\tif (nla_put(skb, NFTA_RULE_USERDATA, udata->len + 1,\n\t\t\t    udata->data) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_rule_notify(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_rule *rule, int event)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nft_rule *prule;\n\tstruct sk_buff *skb;\n\tu64 handle = 0;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (event == NFT_MSG_NEWRULE &&\n\t    !list_is_first(&rule->list, &ctx->chain->rules) &&\n\t    !list_is_last(&rule->list, &ctx->chain->rules)) {\n\t\tprule = list_prev_entry(rule, list);\n\t\thandle = prule->handle;\n\t}\n\tif (ctx->flags & (NLM_F_APPEND | NLM_F_REPLACE))\n\t\tflags |= NLM_F_APPEND;\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_rule_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t       event, flags, ctx->family, ctx->table,\n\t\t\t\t       ctx->chain, rule, handle);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstruct nft_rule_dump_ctx {\n\tchar *table;\n\tchar *chain;\n};\n\nstatic int __nf_tables_dump_rules(struct sk_buff *skb,\n\t\t\t\t  unsigned int *idx,\n\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nft_chain *chain)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nft_rule *rule, *prule;\n\tunsigned int s_idx = cb->args[0];\n\tu64 handle;\n\n\tprule = NULL;\n\tlist_for_each_entry_rcu(rule, &chain->rules, list) {\n\t\tif (!nft_is_active(net, rule))\n\t\t\tgoto cont_skip;\n\t\tif (*idx < s_idx)\n\t\t\tgoto cont;\n\t\tif (*idx > s_idx) {\n\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t\tsizeof(cb->args) - sizeof(cb->args[0]));\n\t\t}\n\t\tif (prule)\n\t\t\thandle = prule->handle;\n\t\telse\n\t\t\thandle = 0;\n\n\t\tif (nf_tables_fill_rule_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq,\n\t\t\t\t\tNFT_MSG_NEWRULE,\n\t\t\t\t\tNLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\ttable->family,\n\t\t\t\t\ttable, chain, rule, handle) < 0)\n\t\t\treturn 1;\n\n\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\tprule = rule;\ncont_skip:\n\t\t(*idx)++;\n\t}\n\treturn 0;\n}\n\nstatic int nf_tables_dump_rules(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tconst struct nft_rule_dump_ctx *ctx = cb->data;\n\tstruct nft_table *table;\n\tconst struct nft_chain *chain;\n\tunsigned int idx = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tif (ctx && ctx->table && strcmp(ctx->table, table->name) != 0)\n\t\t\tcontinue;\n\n\t\tif (ctx && ctx->table && ctx->chain) {\n\t\t\tstruct rhlist_head *list, *tmp;\n\n\t\t\tlist = rhltable_lookup(&table->chains_ht, ctx->chain,\n\t\t\t\t\t       nft_chain_ht_params);\n\t\t\tif (!list)\n\t\t\t\tgoto done;\n\n\t\t\trhl_for_each_entry_rcu(chain, tmp, list, rhlhead) {\n\t\t\t\tif (!nft_is_active(net, chain))\n\t\t\t\t\tcontinue;\n\t\t\t\t__nf_tables_dump_rules(skb, &idx,\n\t\t\t\t\t\t       cb, table, chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(chain, &table->chains, list) {\n\t\t\tif (__nf_tables_dump_rules(skb, &idx, cb, table, chain))\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctx && ctx->table)\n\t\t\tbreak;\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_rules_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_rule_dump_ctx *ctx = NULL;\n\n\tif (nla[NFTA_RULE_TABLE] || nla[NFTA_RULE_CHAIN]) {\n\t\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla[NFTA_RULE_TABLE]) {\n\t\t\tctx->table = nla_strdup(nla[NFTA_RULE_TABLE],\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!ctx->table) {\n\t\t\t\tkfree(ctx);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tif (nla[NFTA_RULE_CHAIN]) {\n\t\t\tctx->chain = nla_strdup(nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!ctx->chain) {\n\t\t\t\tkfree(ctx->table);\n\t\t\t\tkfree(ctx);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tcb->data = ctx;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_rules_done(struct netlink_callback *cb)\n{\n\tstruct nft_rule_dump_ctx *ctx = cb->data;\n\n\tif (ctx) {\n\t\tkfree(ctx->table);\n\t\tkfree(ctx->chain);\n\t\tkfree(ctx);\n\t}\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_chain *chain;\n\tconst struct nft_rule *rule;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start= nf_tables_dump_rules_start,\n\t\t\t.dump = nf_tables_dump_rules,\n\t\t\t.done = nf_tables_dump_rules_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);\n\tif (IS_ERR(chain)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\treturn PTR_ERR(chain);\n\t}\n\n\trule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\n\tif (IS_ERR(rule)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\treturn PTR_ERR(rule);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t       info->nlh->nlmsg_seq, NFT_MSG_NEWRULE, 0,\n\t\t\t\t       family, table, chain, rule, 0);\n\tif (err < 0)\n\t\tgoto err_fill_rule_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_rule_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nf_tables_rule_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_rule *rule)\n{\n\tstruct nft_expr *expr, *next;\n\n\t/*\n\t * Careful: some expressions might not be initialized in case this\n\t * is called on error from nf_tables_newrule().\n\t */\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tnext = nft_expr_next(expr);\n\t\tnf_tables_expr_destroy(ctx, expr);\n\t\texpr = next;\n\t}\n\tkfree(rule);\n}\n\nvoid nf_tables_rule_release(const struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tnft_rule_expr_deactivate(ctx, rule, NFT_TRANS_RELEASE);\n\tnf_tables_rule_destroy(ctx, rule);\n}\n\nint nft_chain_validate(const struct nft_ctx *ctx, const struct nft_chain *chain)\n{\n\tstruct nft_expr *expr, *last;\n\tconst struct nft_data *data;\n\tstruct nft_rule *rule;\n\tint err;\n\n\tif (ctx->level == NFT_JUMP_STACK_SIZE)\n\t\treturn -EMLINK;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(ctx->net, rule))\n\t\t\tcontinue;\n\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\tif (!expr->ops->validate)\n\t\t\t\tcontinue;\n\n\t\t\terr = expr->ops->validate(ctx, expr, &data);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate);\n\nstatic int nft_table_validate(struct net *net, const struct nft_table *table)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_ctx ctx = {\n\t\t.net\t= net,\n\t\t.family\t= table->family,\n\t};\n\tint err;\n\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nft_is_base_chain(chain))\n\t\t\tcontinue;\n\n\t\tctx.chain = chain;\n\t\terr = nft_chain_validate(&ctx, chain);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nft_rule *nft_rule_lookup_byid(const struct net *net,\n\t\t\t\t\t     const struct nft_chain *chain,\n\t\t\t\t\t     const struct nlattr *nla);\n\n#define NFT_RULE_MAXEXPRS\t128\n\nstatic int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tunsigned int size, i, n, ulen = 0, usize = 0;\n\tu8 genmask = nft_genmask_next(info->net);\n\tstruct nft_rule *rule, *old_rule = NULL;\n\tstruct nft_expr_info *expr_info = NULL;\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flow_rule *flow = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_userdata *udata;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain;\n\tstruct nft_trans *trans;\n\tu64 handle, pos_handle;\n\tstruct nft_expr *expr;\n\tstruct nft_ctx ctx;\n\tstruct nlattr *tmp;\n\tint err, rem;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EOPNOTSUPP;\n\n\t} else if (nla[NFTA_RULE_CHAIN_ID]) {\n\t\tchain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID]);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_RULE_HANDLE]) {\n\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));\n\t\trule = __nft_rule_lookup(chain, handle);\n\t\tif (IS_ERR(rule)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn PTR_ERR(rule);\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\told_rule = rule;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE) ||\n\t\t    info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EINVAL;\n\t\thandle = nf_tables_alloc_handle(table);\n\n\t\tif (chain->use == UINT_MAX)\n\t\t\treturn -EOVERFLOW;\n\n\t\tif (nla[NFTA_RULE_POSITION]) {\n\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));\n\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t} else if (nla[NFTA_RULE_POSITION_ID]) {\n\t\t\told_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t}\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tn = 0;\n\tsize = 0;\n\tif (nla[NFTA_RULE_EXPRESSIONS]) {\n\t\texpr_info = kvmalloc_array(NFT_RULE_MAXEXPRS,\n\t\t\t\t\t   sizeof(struct nft_expr_info),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!expr_info)\n\t\t\treturn -ENOMEM;\n\n\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {\n\t\t\terr = -EINVAL;\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)\n\t\t\t\tgoto err_release_expr;\n\t\t\tif (n == NFT_RULE_MAXEXPRS)\n\t\t\t\tgoto err_release_expr;\n\t\t\terr = nf_tables_expr_parse(&ctx, tmp, &expr_info[n]);\n\t\t\tif (err < 0) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, tmp);\n\t\t\t\tgoto err_release_expr;\n\t\t\t}\n\t\t\tsize += expr_info[n].ops->size;\n\t\t\tn++;\n\t\t}\n\t}\n\t/* Check for overflow of dlen field */\n\terr = -EFBIG;\n\tif (size >= 1 << 12)\n\t\tgoto err_release_expr;\n\n\tif (nla[NFTA_RULE_USERDATA]) {\n\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);\n\t\tif (ulen > 0)\n\t\t\tusize = sizeof(struct nft_userdata) + ulen;\n\t}\n\n\terr = -ENOMEM;\n\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL_ACCOUNT);\n\tif (rule == NULL)\n\t\tgoto err_release_expr;\n\n\tnft_activate_next(net, rule);\n\n\trule->handle = handle;\n\trule->dlen   = size;\n\trule->udata  = ulen ? 1 : 0;\n\n\tif (ulen) {\n\t\tudata = nft_userdata(rule);\n\t\tudata->len = ulen - 1;\n\t\tnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);\n\t}\n\n\texpr = nft_expr_first(rule);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nf_tables_newexpr(&ctx, &expr_info[i], expr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, expr_info[i].attr);\n\t\t\tgoto err_release_rule;\n\t\t}\n\n\t\tif (expr_info[i].ops->validate)\n\t\t\tnft_validate_state_update(net, NFT_VALIDATE_NEED);\n\n\t\texpr_info[i].ops = NULL;\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD) {\n\t\tflow = nft_flow_rule_create(net, rule);\n\t\tif (IS_ERR(flow)) {\n\t\t\terr = PTR_ERR(flow);\n\t\t\tgoto err_release_rule;\n\t\t}\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE) {\n\t\terr = nft_delrule(&ctx, old_rule);\n\t\tif (err < 0)\n\t\t\tgoto err_destroy_flow_rule;\n\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (trans == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t} else {\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (!trans) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_APPEND) {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_tail_rcu(&rule->list, &chain->rules);\n\t\t } else {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_rcu(&rule->list, &chain->rules);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\tchain->use++;\n\n\tif (flow)\n\t\tnft_trans_flow_rule(trans) = flow;\n\n\tif (nft_net->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\n\treturn 0;\n\nerr_destroy_flow_rule:\n\tif (flow)\n\t\tnft_flow_rule_destroy(flow);\nerr_release_rule:\n\tnf_tables_rule_release(&ctx, rule);\nerr_release_expr:\n\tfor (i = 0; i < n; i++) {\n\t\tif (expr_info[i].ops) {\n\t\t\tmodule_put(expr_info[i].ops->type->owner);\n\t\t\tif (expr_info[i].ops->type->release_ops)\n\t\t\t\texpr_info[i].ops->type->release_ops(expr_info[i].ops);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\n\treturn err;\n}\n\nstatic struct nft_rule *nft_rule_lookup_byid(const struct net *net,\n\t\t\t\t\t     const struct nft_chain *chain,\n\t\t\t\t\t     const struct nlattr *nla)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tstruct nft_rule *rule = nft_trans_rule(trans);\n\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE &&\n\t\t    trans->ctx.chain == chain &&\n\t\t    id == nft_trans_rule_id(trans))\n\t\t\treturn rule;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_chain *chain = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_rule *rule;\n\tstruct nft_ctx ctx;\n\tint err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tif (chain) {\n\t\tif (nla[NFTA_RULE_HANDLE]) {\n\t\t\trule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\n\t\t\tif (IS_ERR(rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\t\treturn PTR_ERR(rule);\n\t\t\t}\n\n\t\t\terr = nft_delrule(&ctx, rule);\n\t\t} else if (nla[NFTA_RULE_ID]) {\n\t\t\trule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);\n\t\t\tif (IS_ERR(rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);\n\t\t\t\treturn PTR_ERR(rule);\n\t\t\t}\n\n\t\t\terr = nft_delrule(&ctx, rule);\n\t\t} else {\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(chain, &table->chains, list) {\n\t\t\tif (!nft_is_active_next(net, chain))\n\t\t\t\tcontinue;\n\n\t\t\tctx.chain = chain;\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n/*\n * Sets\n */\nstatic const struct nft_set_type *nft_set_types[] = {\n\t&nft_set_hash_fast_type,\n\t&nft_set_hash_type,\n\t&nft_set_rhash_type,\n\t&nft_set_bitmap_type,\n\t&nft_set_rbtree_type,\n#if defined(CONFIG_X86_64) && !defined(CONFIG_UML)\n\t&nft_set_pipapo_avx2_type,\n#endif\n\t&nft_set_pipapo_type,\n};\n\n#define NFT_SET_FEATURES\t(NFT_SET_INTERVAL | NFT_SET_MAP | \\\n\t\t\t\t NFT_SET_TIMEOUT | NFT_SET_OBJECT | \\\n\t\t\t\t NFT_SET_EVAL)\n\nstatic bool nft_set_ops_candidate(const struct nft_set_type *type, u32 flags)\n{\n\treturn (flags & type->features) == (flags & NFT_SET_FEATURES);\n}\n\n/*\n * Select a set implementation based on the data characteristics and the\n * given policy. The total memory use might not be known if no size is\n * given, in that case the amount of memory per element is used.\n */\nstatic const struct nft_set_ops *\nnft_select_set_ops(const struct nft_ctx *ctx,\n\t\t   const struct nlattr * const nla[],\n\t\t   const struct nft_set_desc *desc,\n\t\t   enum nft_set_policies policy)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tconst struct nft_set_ops *ops, *bops;\n\tstruct nft_set_estimate est, best;\n\tconst struct nft_set_type *type;\n\tu32 flags = 0;\n\tint i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tlockdep_nfnl_nft_mutex_not_held();\n\n\tif (nla[NFTA_SET_FLAGS] != NULL)\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\n\tbops\t    = NULL;\n\tbest.size   = ~0;\n\tbest.lookup = ~0;\n\tbest.space  = ~0;\n\n\tfor (i = 0; i < ARRAY_SIZE(nft_set_types); i++) {\n\t\ttype = nft_set_types[i];\n\t\tops = &type->ops;\n\n\t\tif (!nft_set_ops_candidate(type, flags))\n\t\t\tcontinue;\n\t\tif (!ops->estimate(desc, flags, &est))\n\t\t\tcontinue;\n\n\t\tswitch (policy) {\n\t\tcase NFT_SET_POL_PERFORMANCE:\n\t\t\tif (est.lookup < best.lookup)\n\t\t\t\tbreak;\n\t\t\tif (est.lookup == best.lookup &&\n\t\t\t    est.space < best.space)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase NFT_SET_POL_MEMORY:\n\t\t\tif (!desc->size) {\n\t\t\t\tif (est.space < best.space)\n\t\t\t\t\tbreak;\n\t\t\t\tif (est.space == best.space &&\n\t\t\t\t    est.lookup < best.lookup)\n\t\t\t\t\tbreak;\n\t\t\t} else if (est.size < best.size || !bops) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbops = ops;\n\t\tbest = est;\n\t}\n\n\tif (bops != NULL)\n\t\treturn bops;\n\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic const struct nla_policy nft_set_policy[NFTA_SET_MAX + 1] = {\n\t[NFTA_SET_TABLE]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_SET_NAME]\t\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_SET_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_KEY_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_KEY_LEN]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DATA_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DATA_LEN]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_POLICY]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DESC]\t\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ID]\t\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_TIMEOUT]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_GC_INTERVAL]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_USERDATA]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len  = NFT_USERDATA_MAXLEN },\n\t[NFTA_SET_OBJ_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_HANDLE]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_EXPR]\t\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_EXPRESSIONS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy nft_set_desc_policy[NFTA_SET_DESC_MAX + 1] = {\n\t[NFTA_SET_DESC_SIZE]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_DESC_CONCAT]\t\t= { .type = NLA_NESTED },\n};\n\nstatic struct nft_set *nft_set_lookup(const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla, u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\tif (!nla_strcmp(nla, set->name) &&\n\t\t    nft_active_genmask(set, genmask))\n\t\t\treturn set;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_set *nft_set_lookup_byhandle(const struct nft_table *table,\n\t\t\t\t\t       const struct nlattr *nla,\n\t\t\t\t\t       u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tlist_for_each_entry(set, &table->sets, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == set->handle &&\n\t\t    nft_active_genmask(set, genmask))\n\t\t\treturn set;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nft_set *nft_set_lookup_byid(const struct net *net,\n\t\t\t\t\t   const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla, u8 genmask)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tu32 id = ntohl(nla_get_be32(nla));\n\tstruct nft_trans *trans;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tif (trans->msg_type == NFT_MSG_NEWSET) {\n\t\t\tstruct nft_set *set = nft_trans_set(trans);\n\n\t\t\tif (id == nft_trans_set_id(trans) &&\n\t\t\t    set->table == table &&\n\t\t\t    nft_active_genmask(set, genmask))\n\t\t\t\treturn set;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstruct nft_set *nft_set_lookup_global(const struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla_set_name,\n\t\t\t\t      const struct nlattr *nla_set_id,\n\t\t\t\t      u8 genmask)\n{\n\tstruct nft_set *set;\n\n\tset = nft_set_lookup(table, nla_set_name, genmask);\n\tif (IS_ERR(set)) {\n\t\tif (!nla_set_id)\n\t\t\treturn set;\n\n\t\tset = nft_set_lookup_byid(net, table, nla_set_id, genmask);\n\t}\n\treturn set;\n}\nEXPORT_SYMBOL_GPL(nft_set_lookup_global);\n\nstatic int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\n\tp = strchr(name, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\n\t\t\tif (!nft_is_active_next(ctx->net, i))\n\t\t\t\tcontinue;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\n\tset->name = kasprintf(GFP_KERNEL_ACCOUNT, name, min + n);\n\tif (!set->name)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, i))\n\t\t\tcontinue;\n\t\tif (!strcmp(set->name, i->name)) {\n\t\t\tkfree(set->name);\n\t\t\tset->name = NULL;\n\t\t\treturn -ENFILE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nf_msecs_to_jiffies64(const struct nlattr *nla, u64 *result)\n{\n\tu64 ms = be64_to_cpu(nla_get_be64(nla));\n\tu64 max = (u64)(~((u64)0));\n\n\tmax = div_u64(max, NSEC_PER_MSEC);\n\tif (ms >= max)\n\t\treturn -ERANGE;\n\n\tms *= NSEC_PER_MSEC;\n\t*result = nsecs_to_jiffies64(ms);\n\treturn 0;\n}\n\n__be64 nf_jiffies64_to_msecs(u64 input)\n{\n\treturn cpu_to_be64(jiffies64_to_msecs(input));\n}\n\nstatic int nf_tables_fill_set_concat(struct sk_buff *skb,\n\t\t\t\t     const struct nft_set *set)\n{\n\tstruct nlattr *concat, *field;\n\tint i;\n\n\tconcat = nla_nest_start_noflag(skb, NFTA_SET_DESC_CONCAT);\n\tif (!concat)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < set->field_count; i++) {\n\t\tfield = nla_nest_start_noflag(skb, NFTA_LIST_ELEM);\n\t\tif (!field)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla_put_be32(skb, NFTA_SET_FIELD_LEN,\n\t\t\t\t htonl(set->field_len[i])))\n\t\t\treturn -ENOMEM;\n\n\t\tnla_nest_end(skb, field);\n\t}\n\n\tnla_nest_end(skb, concat);\n\n\treturn 0;\n}\n\nstatic int nf_tables_fill_set(struct sk_buff *skb, const struct nft_ctx *ctx,\n\t\t\t      const struct nft_set *set, u16 event, u16 flags)\n{\n\tstruct nlmsghdr *nlh;\n\tu32 portid = ctx->portid;\n\tstruct nlattr *nest;\n\tu32 seq = ctx->seq;\n\tint i;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, ctx->family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(ctx->net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_NAME, set->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_SET_HANDLE, cpu_to_be64(set->handle),\n\t\t\t NFTA_SET_PAD))\n\t\tgoto nla_put_failure;\n\tif (set->flags != 0)\n\t\tif (nla_put_be32(skb, NFTA_SET_FLAGS, htonl(set->flags)))\n\t\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_SET_KEY_TYPE, htonl(set->ktype)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_SET_KEY_LEN, htonl(set->klen)))\n\t\tgoto nla_put_failure;\n\tif (set->flags & NFT_SET_MAP) {\n\t\tif (nla_put_be32(skb, NFTA_SET_DATA_TYPE, htonl(set->dtype)))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_be32(skb, NFTA_SET_DATA_LEN, htonl(set->dlen)))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (set->flags & NFT_SET_OBJECT &&\n\t    nla_put_be32(skb, NFTA_SET_OBJ_TYPE, htonl(set->objtype)))\n\t\tgoto nla_put_failure;\n\n\tif (set->timeout &&\n\t    nla_put_be64(skb, NFTA_SET_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(set->timeout),\n\t\t\t NFTA_SET_PAD))\n\t\tgoto nla_put_failure;\n\tif (set->gc_int &&\n\t    nla_put_be32(skb, NFTA_SET_GC_INTERVAL, htonl(set->gc_int)))\n\t\tgoto nla_put_failure;\n\n\tif (set->policy != NFT_SET_POL_PERFORMANCE) {\n\t\tif (nla_put_be32(skb, NFTA_SET_POLICY, htonl(set->policy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (set->udata &&\n\t    nla_put(skb, NFTA_SET_USERDATA, set->udlen, set->udata))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_DESC);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (set->size &&\n\t    nla_put_be32(skb, NFTA_SET_DESC_SIZE, htonl(set->size)))\n\t\tgoto nla_put_failure;\n\n\tif (set->field_count > 1 &&\n\t    nf_tables_fill_set_concat(skb, set))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (set->num_exprs == 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_EXPR);\n\t\tif (nf_tables_fill_expr_info(skb, set->exprs[0]) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, nest);\n\t} else if (set->num_exprs > 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_EXPRESSIONS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < set->num_exprs; i++) {\n\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM,\n\t\t\t\t\t  set->exprs[i]) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic void nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_set *set, int event,\n\t\t\t         gfp_t gfp_flags)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tu32 portid = ctx->portid;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_set(skb, ctx, set, event, flags);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic int nf_tables_dump_sets(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nft_set *set;\n\tunsigned int idx, s_idx = cb->args[0];\n\tstruct nft_table *table, *cur_table = (struct nft_table *)cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nft_ctx *ctx = cb->data, ctx_set;\n\tstruct nftables_pernet *nft_net;\n\n\tif (cb->args[1])\n\t\treturn skb->len;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (ctx->family != NFPROTO_UNSPEC &&\n\t\t    ctx->family != table->family)\n\t\t\tcontinue;\n\n\t\tif (ctx->table && ctx->table != table)\n\t\t\tcontinue;\n\n\t\tif (cur_table) {\n\t\t\tif (cur_table != table)\n\t\t\t\tcontinue;\n\n\t\t\tcur_table = NULL;\n\t\t}\n\t\tidx = 0;\n\t\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (!nft_is_active(net, set))\n\t\t\t\tgoto cont;\n\n\t\t\tctx_set = *ctx;\n\t\t\tctx_set.table = table;\n\t\t\tctx_set.family = table->family;\n\n\t\t\tif (nf_tables_fill_set(skb, &ctx_set, set,\n\t\t\t\t\t       NFT_MSG_NEWSET,\n\t\t\t\t\t       NLM_F_MULTI) < 0) {\n\t\t\t\tcb->args[0] = idx;\n\t\t\t\tcb->args[2] = (unsigned long) table;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\tif (s_idx)\n\t\t\ts_idx = 0;\n\t}\n\tcb->args[1] = 1;\ndone:\n\trcu_read_unlock();\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_sets_start(struct netlink_callback *cb)\n{\n\tstruct nft_ctx *ctx_dump = NULL;\n\n\tctx_dump = kmemdup(cb->data, sizeof(*ctx_dump), GFP_ATOMIC);\n\tif (ctx_dump == NULL)\n\t\treturn -ENOMEM;\n\n\tcb->data = ctx_dump;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_sets_done(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_table *table = NULL;\n\tstruct net *net = info->net;\n\tconst struct nft_set *set;\n\tstruct sk_buff *skb2;\n\tstruct nft_ctx ctx;\n\tint err;\n\n\tif (nla[NFTA_SET_TABLE]) {\n\t\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family,\n\t\t\t\t\t genmask, 0);\n\t\tif (IS_ERR(table)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\t\treturn PTR_ERR(table);\n\t\t}\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_sets_start,\n\t\t\t.dump = nf_tables_dump_sets,\n\t\t\t.done = nf_tables_dump_sets_done,\n\t\t\t.data = &ctx,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\t/* Only accept unspec with dump */\n\tif (info->nfmsg->nfgen_family == NFPROTO_UNSPEC)\n\t\treturn -EAFNOSUPPORT;\n\tif (!nla[NFTA_SET_TABLE])\n\t\treturn -EINVAL;\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_set(skb2, &ctx, set, NFT_MSG_NEWSET, 0);\n\tif (err < 0)\n\t\tgoto err_fill_set_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_set_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nla_policy nft_concat_policy[NFTA_SET_FIELD_MAX + 1] = {\n\t[NFTA_SET_FIELD_LEN]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\n\tif (desc->field_count >= ARRAY_SIZE(desc->field_len))\n\t\treturn -E2BIG;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (!len || len > U8_MAX)\n\t\treturn -EINVAL;\n\n\tdesc->field_len[desc->field_count++] = len;\n\n\treturn 0;\n}\n\nstatic int nft_set_desc_concat(struct nft_set_desc *desc,\n\t\t\t       const struct nlattr *nla)\n{\n\tstruct nlattr *attr;\n\tu32 num_regs = 0;\n\tint rem, err, i;\n\n\tnla_for_each_nested(attr, nla, rem) {\n\t\tif (nla_type(attr) != NFTA_LIST_ELEM)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_set_desc_concat_parse(attr, desc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < desc->field_count; i++)\n\t\tnum_regs += DIV_ROUND_UP(desc->field_len[i], sizeof(u32));\n\n\tif (num_regs > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}\n\nstatic int nf_tables_set_desc_parse(struct nft_set_desc *desc,\n\t\t\t\t    const struct nlattr *nla)\n{\n\tstruct nlattr *da[NFTA_SET_DESC_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(da, NFTA_SET_DESC_MAX, nla,\n\t\t\t\t\t  nft_set_desc_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (da[NFTA_SET_DESC_SIZE] != NULL)\n\t\tdesc->size = ntohl(nla_get_be32(da[NFTA_SET_DESC_SIZE]));\n\tif (da[NFTA_SET_DESC_CONCAT])\n\t\terr = nft_set_desc_concat(desc, da[NFTA_SET_DESC_CONCAT]);\n\n\treturn err;\n}\n\nstatic int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tu32 ktype, dtype, flags, policy, gc_int, objtype;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_set_ops *ops;\n\tstruct nft_expr *expr = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_set_desc desc;\n\tstruct nft_table *table;\n\tunsigned char *udata;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tsize_t alloc_size;\n\tu64 timeout;\n\tchar *name;\n\tint err, i;\n\tu16 udlen;\n\tu64 size;\n\n\tif (nla[NFTA_SET_TABLE] == NULL ||\n\t    nla[NFTA_SET_NAME] == NULL ||\n\t    nla[NFTA_SET_KEY_LEN] == NULL ||\n\t    nla[NFTA_SET_ID] == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(&desc, 0, sizeof(desc));\n\n\tktype = NFT_DATA_VALUE;\n\tif (nla[NFTA_SET_KEY_TYPE] != NULL) {\n\t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\n\t\tif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n\tif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\n\t\treturn -EINVAL;\n\n\tflags = 0;\n\tif (nla[NFTA_SET_FLAGS] != NULL) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\t\tif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\n\t\t\t      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |\n\t\t\t      NFT_SET_MAP | NFT_SET_EVAL |\n\t\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* Only one of these operations is supported */\n\t\tif ((flags & (NFT_SET_MAP | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_MAP | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((flags & (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_EVAL | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdtype = 0;\n\tif (nla[NFTA_SET_DATA_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_MAP))\n\t\t\treturn -EINVAL;\n\n\t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\n\t\tif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\n\t\t    dtype != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (dtype != NFT_DATA_VERDICT) {\n\t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\n\t\t\tif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tdesc.dlen = sizeof(struct nft_verdict);\n\t} else if (flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_OBJ_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_OBJECT))\n\t\t\treturn -EINVAL;\n\n\t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\n\t\tif (objtype == NFT_OBJECT_UNSPEC ||\n\t\t    objtype > NFT_OBJECT_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (flags & NFT_SET_OBJECT)\n\t\treturn -EINVAL;\n\telse\n\t\tobjtype = NFT_OBJECT_UNSPEC;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_TIMEOUT] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tgc_int = 0;\n\tif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\n\t}\n\n\tpolicy = NFT_SET_POL_PERFORMANCE;\n\tif (nla[NFTA_SET_POLICY] != NULL)\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\n\n\tif (nla[NFTA_SET_DESC] != NULL) {\n\t\terr = nf_tables_set_desc_parse(&desc, nla[NFTA_SET_DESC]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (desc.field_count > 1 && !(flags & NFT_SET_CONCAT))\n\t\t\treturn -EINVAL;\n\t} else if (flags & NFT_SET_CONCAT) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\n\t\tdesc.expr = true;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set)) {\n\t\tif (PTR_ERR(set) != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn PTR_ERR(set);\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\treturn -ENOENT;\n\n\tops = nft_select_set_ops(&ctx, nla, &desc, policy);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tudlen = 0;\n\tif (nla[NFTA_SET_USERDATA])\n\t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\n\n\tsize = 0;\n\tif (ops->privsize != NULL)\n\t\tsize = ops->privsize(nla, &desc);\n\talloc_size = sizeof(*set) + size + udlen;\n\tif (alloc_size < size || alloc_size > INT_MAX)\n\t\treturn -ENOMEM;\n\tset = kvzalloc(alloc_size, GFP_KERNEL_ACCOUNT);\n\tif (!set)\n\t\treturn -ENOMEM;\n\n\tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_set_name;\n\t}\n\n\terr = nf_tables_set_alloc_name(&ctx, set, name);\n\tkfree(name);\n\tif (err < 0)\n\t\tgoto err_set_name;\n\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops = ops;\n\tset->ktype = ktype;\n\tset->klen = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen = desc.dlen;\n\tset->flags = flags;\n\tset->size = desc.size;\n\tset->policy = policy;\n\tset->udlen = udlen;\n\tset->udata = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n\n\tif (nla[NFTA_SET_EXPR]) {\n\t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n\t\tif (IS_ERR(expr)) {\n\t\t\terr = PTR_ERR(expr);\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\tset->exprs[0] = expr;\n\t\tset->num_exprs++;\n\t} else if (nla[NFTA_SET_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!(flags & NFT_SET_EXPR)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tset->exprs[i++] = expr;\n\t\t\tset->num_exprs++;\n\t\t}\n\t}\n\n\tset->handle = nf_tables_alloc_handle(table);\n\n\terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n\tif (err < 0)\n\t\tgoto err_set_expr_alloc;\n\n\tlist_add_tail_rcu(&set->list, &table->sets);\n\ttable->use++;\n\treturn 0;\n\nerr_set_expr_alloc:\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n\n\tops->destroy(set);\nerr_set_init:\n\tkfree(set->name);\nerr_set_name:\n\tkvfree(set);\n\treturn err;\n}\n\nstruct nft_set_elem_catchall {\n\tstruct list_head\tlist;\n\tstruct rcu_head\t\trcu;\n\tvoid\t\t\t*elem;\n};\n\nstatic void nft_set_catchall_destroy(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *next, *catchall;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\tlist_del_rcu(&catchall->list);\n\t\tnft_set_elem_destroy(set, catchall->elem, true);\n\t\tkfree_rcu(catchall, rcu);\n\t}\n}\n\nstatic void nft_set_destroy(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tint i;\n\n\tif (WARN_ON(set->use > 0))\n\t\treturn;\n\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, set->exprs[i]);\n\n\tset->ops->destroy(set);\n\tnft_set_catchall_destroy(ctx, set);\n\tkfree(set->name);\n\tkvfree(set);\n}\n\nstatic int nf_tables_delset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\n\tif (info->nfmsg->nfgen_family == NFPROTO_UNSPEC)\n\t\treturn -EAFNOSUPPORT;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_SET_HANDLE]) {\n\t\tattr = nla[NFTA_SET_HANDLE];\n\t\tset = nft_set_lookup_byhandle(table, attr, genmask);\n\t} else {\n\t\tattr = nla[NFTA_SET_NAME];\n\t\tset = nft_set_lookup(table, attr, genmask);\n\t}\n\n\tif (IS_ERR(set)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(set);\n\t}\n\tif (set->use ||\n\t    (info->nlh->nlmsg_flags & NLM_F_NONREC &&\n\t     atomic_read(&set->nelems) > 0)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\treturn nft_delset(&ctx, set);\n}\n\nstatic int nft_validate_register_store(const struct nft_ctx *ctx,\n\t\t\t\t       enum nft_registers reg,\n\t\t\t\t       const struct nft_data *data,\n\t\t\t\t       enum nft_data_types type,\n\t\t\t\t       unsigned int len);\n\nstatic int nft_setelem_data_validate(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_set *set,\n\t\t\t\t     struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\tenum nft_registers dreg;\n\n\tdreg = nft_type_to_reg(set->dtype);\n\treturn nft_validate_register_store(ctx, dreg, nft_set_ext_data(ext),\n\t\t\t\t\t   set->dtype == NFT_DATA_VERDICT ?\n\t\t\t\t\t   NFT_DATA_VERDICT : NFT_DATA_VALUE,\n\t\t\t\t\t   set->dlen);\n}\n\nstatic int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\tconst struct nft_set_iter *iter,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\treturn nft_setelem_data_validate(ctx, set, elem);\n}\n\nstatic int nft_set_catchall_bind_check(const struct nft_ctx *ctx,\n\t\t\t\t       struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = nft_setelem_data_validate(ctx, set, &elem);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t       struct nft_set_binding *binding)\n{\n\tstruct nft_set_binding *i;\n\tstruct nft_set_iter iter;\n\n\tif (set->use == UINT_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (!list_empty(&set->bindings) && nft_set_is_anonymous(set))\n\t\treturn -EBUSY;\n\n\tif (binding->flags & NFT_SET_MAP) {\n\t\t/* If the set is already bound to the same chain all\n\t\t * jumps are already validated for that chain.\n\t\t */\n\t\tlist_for_each_entry(i, &set->bindings, list) {\n\t\t\tif (i->flags & NFT_SET_MAP &&\n\t\t\t    i->chain == binding->chain)\n\t\t\t\tgoto bind;\n\t\t}\n\n\t\titer.genmask\t= nft_genmask_next(ctx->net);\n\t\titer.skip \t= 0;\n\t\titer.count\t= 0;\n\t\titer.err\t= 0;\n\t\titer.fn\t\t= nf_tables_bind_check_setelem;\n\n\t\tset->ops->walk(ctx, set, &iter);\n\t\tif (!iter.err)\n\t\t\titer.err = nft_set_catchall_bind_check(ctx, set);\n\n\t\tif (iter.err < 0)\n\t\t\treturn iter.err;\n\t}\nbind:\n\tbinding->chain = ctx->chain;\n\tlist_add_tail_rcu(&binding->list, &set->bindings);\n\tnft_set_trans_bind(ctx, set);\n\tset->use++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_tables_bind_set);\n\nstatic void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t struct nft_set_binding *binding, bool event)\n{\n\tlist_del_rcu(&binding->list);\n\n\tif (list_empty(&set->bindings) && nft_set_is_anonymous(set)) {\n\t\tlist_del_rcu(&set->list);\n\t\tif (event)\n\t\t\tnf_tables_set_notify(ctx, set, NFT_MSG_DELSET,\n\t\t\t\t\t     GFP_KERNEL);\n\t}\n}\n\nvoid nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_tables_deactivate_set);\n\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (list_empty(&set->bindings) && nft_set_is_anonymous(set))\n\t\tnft_set_destroy(ctx, set);\n}\nEXPORT_SYMBOL_GPL(nf_tables_destroy_set);\n\nconst struct nft_set_ext_type nft_set_ext_types[] = {\n\t[NFT_SET_EXT_KEY]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n\t[NFT_SET_EXT_DATA]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n\t[NFT_SET_EXT_EXPRESSIONS]\t= {\n\t\t.align\t= __alignof__(struct nft_set_elem_expr),\n\t},\n\t[NFT_SET_EXT_OBJREF]\t\t= {\n\t\t.len\t= sizeof(struct nft_object *),\n\t\t.align\t= __alignof__(struct nft_object *),\n\t},\n\t[NFT_SET_EXT_FLAGS]\t\t= {\n\t\t.len\t= sizeof(u8),\n\t\t.align\t= __alignof__(u8),\n\t},\n\t[NFT_SET_EXT_TIMEOUT]\t\t= {\n\t\t.len\t= sizeof(u64),\n\t\t.align\t= __alignof__(u64),\n\t},\n\t[NFT_SET_EXT_EXPIRATION]\t= {\n\t\t.len\t= sizeof(u64),\n\t\t.align\t= __alignof__(u64),\n\t},\n\t[NFT_SET_EXT_USERDATA]\t\t= {\n\t\t.len\t= sizeof(struct nft_userdata),\n\t\t.align\t= __alignof__(struct nft_userdata),\n\t},\n\t[NFT_SET_EXT_KEY_END]\t\t= {\n\t\t.align\t= __alignof__(u32),\n\t},\n};\n\n/*\n * Set elements\n */\n\nstatic const struct nla_policy nft_set_elem_policy[NFTA_SET_ELEM_MAX + 1] = {\n\t[NFTA_SET_ELEM_KEY]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_DATA]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NFTA_SET_ELEM_TIMEOUT]\t\t= { .type = NLA_U64 },\n\t[NFTA_SET_ELEM_EXPIRATION]\t= { .type = NLA_U64 },\n\t[NFTA_SET_ELEM_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n\t[NFTA_SET_ELEM_EXPR]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_OBJREF]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_OBJ_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_KEY_END]\t\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_EXPRESSIONS]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy nft_set_elem_list_policy[NFTA_SET_ELEM_LIST_MAX + 1] = {\n\t[NFTA_SET_ELEM_LIST_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_LIST_SET]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_SET_ELEM_LIST_ELEMENTS]\t= { .type = NLA_NESTED },\n\t[NFTA_SET_ELEM_LIST_SET_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_set_elem_expr_dump(struct sk_buff *skb,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr;\n\tu32 size, num_exprs = 0;\n\tstruct nft_expr *expr;\n\tstruct nlattr *nest;\n\n\telem_expr = nft_set_ext_expr(ext);\n\tnft_setelem_expr_foreach(expr, elem_expr, size)\n\t\tnum_exprs++;\n\n\tif (num_exprs == 1) {\n\t\texpr = nft_setelem_expr_at(elem_expr, 0);\n\t\tif (nft_expr_dump(skb, NFTA_SET_ELEM_EXPR, expr) < 0)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t} else if (num_exprs > 1) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_EXPRESSIONS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\t\texpr = nft_setelem_expr_at(elem_expr, size);\n\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nf_tables_fill_setelem(struct sk_buff *skb,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_LIST_ELEM);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_KEY, nft_set_ext_key(ext),\n\t\t\t  NFT_DATA_VALUE, set->klen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_KEY_END, nft_set_ext_key_end(ext),\n\t\t\t  NFT_DATA_VALUE, set->klen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_DATA, nft_set_ext_data(ext),\n\t\t\t  set->dtype == NFT_DATA_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE,\n\t\t\t  set->dlen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS) &&\n\t    nft_set_elem_expr_dump(skb, set, ext))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&\n\t    nla_put_string(skb, NFTA_SET_ELEM_OBJREF,\n\t\t\t   (*nft_set_ext_obj(ext))->key.name) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    nla_put_be32(skb, NFTA_SET_ELEM_FLAGS,\n\t\t         htonl(*nft_set_ext_flags(ext))))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT) &&\n\t    nla_put_be64(skb, NFTA_SET_ELEM_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(*nft_set_ext_timeout(ext)),\n\t\t\t NFTA_SET_ELEM_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\tu64 expires, now = get_jiffies_64();\n\n\t\texpires = *nft_set_ext_expiration(ext);\n\t\tif (time_before64(now, expires))\n\t\t\texpires -= now;\n\t\telse\n\t\t\texpires = 0;\n\n\t\tif (nla_put_be64(skb, NFTA_SET_ELEM_EXPIRATION,\n\t\t\t\t nf_jiffies64_to_msecs(expires),\n\t\t\t\t NFTA_SET_ELEM_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {\n\t\tstruct nft_userdata *udata;\n\n\t\tudata = nft_set_ext_userdata(ext);\n\t\tif (nla_put(skb, NFTA_SET_ELEM_USERDATA,\n\t\t\t    udata->len + 1, udata->data))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -EMSGSIZE;\n}\n\nstruct nft_set_dump_args {\n\tconst struct netlink_callback\t*cb;\n\tstruct nft_set_iter\t\titer;\n\tstruct sk_buff\t\t\t*skb;\n};\n\nstatic int nf_tables_dump_setelem(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set,\n\t\t\t\t  const struct nft_set_iter *iter,\n\t\t\t\t  struct nft_set_elem *elem)\n{\n\tstruct nft_set_dump_args *args;\n\n\targs = container_of(iter, struct nft_set_dump_args, iter);\n\treturn nf_tables_fill_setelem(args->skb, set, elem);\n}\n\nstruct nft_set_dump_ctx {\n\tconst struct nft_set\t*set;\n\tstruct nft_ctx\t\tctx;\n};\n\nstatic int nft_set_catchall_dump(struct net *net, struct sk_buff *skb,\n\t\t\t\t const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_expired(ext))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = nf_tables_fill_setelem(skb, set, &elem);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nft_set_dump_ctx *dump_ctx = cb->data;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_set_dump_args args;\n\tbool set_found = false;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tu32 portid, seq;\n\tint event;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (dump_ctx->ctx.family != NFPROTO_UNSPEC &&\n\t\t    dump_ctx->ctx.family != table->family)\n\t\t\tcontinue;\n\n\t\tif (table != dump_ctx->ctx.table)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(set, &table->sets, list) {\n\t\t\tif (set == dump_ctx->set) {\n\t\t\t\tset_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!set_found) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tevent  = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_NEWSETELEM);\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq    = cb->nlh->nlmsg_seq;\n\n\tnlh = nfnl_msg_put(skb, portid, seq, event, NLM_F_MULTI,\n\t\t\t   table->family, NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\targs.cb\t\t\t= cb;\n\targs.skb\t\t= skb;\n\targs.iter.genmask\t= nft_genmask_cur(net);\n\targs.iter.skip\t\t= cb->args[0];\n\targs.iter.count\t\t= 0;\n\targs.iter.err\t\t= 0;\n\targs.iter.fn\t\t= nf_tables_dump_setelem;\n\tset->ops->walk(&dump_ctx->ctx, set, &args.iter);\n\n\tif (!args.iter.err && args.iter.count == cb->args[0])\n\t\targs.iter.err = nft_set_catchall_dump(net, skb, set);\n\trcu_read_unlock();\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\n\tif (args.iter.err && args.iter.err != -EMSGSIZE)\n\t\treturn args.iter.err;\n\tif (args.iter.count == cb->args[0])\n\t\treturn 0;\n\n\tcb->args[0] = args.iter.count;\n\treturn skb->len;\n\nnla_put_failure:\n\trcu_read_unlock();\n\treturn -ENOSPC;\n}\n\nstatic int nf_tables_dump_set_start(struct netlink_callback *cb)\n{\n\tstruct nft_set_dump_ctx *dump_ctx = cb->data;\n\n\tcb->data = kmemdup(dump_ctx, sizeof(*dump_ctx), GFP_ATOMIC);\n\n\treturn cb->data ? 0 : -ENOMEM;\n}\n\nstatic int nf_tables_dump_set_done(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\nstatic int nf_tables_fill_setelem_info(struct sk_buff *skb,\n\t\t\t\t       const struct nft_ctx *ctx, u32 seq,\n\t\t\t\t       u32 portid, int event, u16 flags,\n\t\t\t\t       const struct nft_set *set,\n\t\t\t\t       const struct nft_set_elem *elem)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tint err;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, ctx->family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(ctx->net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_NAME, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\terr = nf_tables_fill_setelem(skb, set, elem);\n\tif (err < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstatic int nft_setelem_parse_flags(const struct nft_set *set,\n\t\t\t\t   const struct nlattr *attr, u32 *flags)\n{\n\tif (attr == NULL)\n\t\treturn 0;\n\n\t*flags = ntohl(nla_get_be32(attr));\n\tif (*flags & ~(NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL))\n\t\treturn -EOPNOTSUPP;\n\tif (!(set->flags & NFT_SET_INTERVAL) &&\n\t    *flags & NFT_SET_ELEM_INTERVAL_END)\n\t\treturn -EINVAL;\n\tif ((*flags & (NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL)) ==\n\t    (NFT_SET_ELEM_INTERVAL_END | NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nft_setelem_parse_key(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t struct nft_data *key, struct nlattr *attr)\n{\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= NFT_DATA_VALUE_MAXLEN,\n\t\t.len\t= set->klen,\n\t};\n\n\treturn nft_data_init(ctx, key, &desc, attr);\n}\n\nstatic int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t  struct nft_data_desc *desc,\n\t\t\t\t  struct nft_data *data,\n\t\t\t\t  struct nlattr *attr)\n{\n\tu32 dtype;\n\n\tif (set->dtype == NFT_DATA_VERDICT)\n\t\tdtype = NFT_DATA_VERDICT;\n\telse\n\t\tdtype = NFT_DATA_VALUE;\n\n\tdesc->type = dtype;\n\tdesc->size = NFT_DATA_VALUE_MAXLEN;\n\tdesc->len = set->dlen;\n\tdesc->flags = NFT_DATA_DESC_SETELEM;\n\n\treturn nft_data_init(ctx, data, desc, attr);\n}\n\nstatic void *nft_setelem_catchall_get(const struct net *net,\n\t\t\t\t      const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_ext *ext;\n\tvoid *priv = NULL;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_expired(ext))\n\t\t\tcontinue;\n\n\t\tpriv = catchall->elem;\n\t\tbreak;\n\t}\n\n\treturn priv;\n}\n\nstatic int nft_setelem_get(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   struct nft_set_elem *elem, u32 flags)\n{\n\tvoid *priv;\n\n\tif (!(flags & NFT_SET_ELEM_CATCHALL)) {\n\t\tpriv = set->ops->get(ctx->net, set, elem, flags);\n\t\tif (IS_ERR(priv))\n\t\t\treturn PTR_ERR(priv);\n\t} else {\n\t\tpriv = nft_setelem_catchall_get(ctx->net, set);\n\t\tif (!priv)\n\t\t\treturn -ENOENT;\n\t}\n\telem->priv = priv;\n\n\treturn 0;\n}\n\nstatic int nft_get_set_elem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_set_elem elem;\n\tstruct sk_buff *skb;\n\tuint32_t flags = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = nft_setelem_get(ctx, set, &elem, flags);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn err;\n\n\terr = nf_tables_fill_setelem_info(skb, ctx, ctx->seq, ctx->portid,\n\t\t\t\t\t  NFT_MSG_NEWSETELEM, 0, set, &elem);\n\tif (err < 0)\n\t\tgoto err_fill_setelem;\n\n\treturn nfnetlink_unicast(skb, ctx->net, ctx->portid);\n\nerr_fill_setelem:\n\tkfree_skb(skb);\n\treturn err;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nlattr *attr;\n\tstruct nft_ctx ctx;\n\tint rem, err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_set_start,\n\t\t\t.dump = nf_tables_dump_set,\n\t\t\t.done = nf_tables_dump_set_done,\n\t\t\t.module = THIS_MODULE,\n\t\t};\n\t\tstruct nft_set_dump_ctx dump_ctx = {\n\t\t\t.set = set,\n\t\t\t.ctx = ctx,\n\t\t};\n\n\t\tc.data = &dump_ctx;\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_get_set_elem(&ctx, set, attr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void nf_tables_setelem_notify(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_set *set,\n\t\t\t\t     const struct nft_set_elem *elem,\n\t\t\t\t     int event)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = ctx->net;\n\tu32 portid = ctx->portid;\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report && !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_setelem_info(skb, ctx, 0, portid, event, flags,\n\t\t\t\t\t  set, elem);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_net = nft_pernet(net);\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic struct nft_trans *nft_trans_elem_alloc(struct nft_ctx *ctx,\n\t\t\t\t\t      int msg_type,\n\t\t\t\t\t      struct nft_set *set)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_elem));\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tnft_trans_elem_set(trans) = set;\n\treturn trans;\n}\n\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t const struct nlattr *attr)\n{\n\tstruct nft_expr *expr;\n\tint err;\n\n\texpr = nft_expr_init(ctx, attr);\n\tif (IS_ERR(expr))\n\t\treturn expr;\n\n\terr = -EOPNOTSUPP;\n\tif (expr->ops->type->flags & NFT_EXPR_GC) {\n\t\tif (set->flags & NFT_SET_TIMEOUT)\n\t\t\tgoto err_set_elem_expr;\n\t\tif (!set->ops->gc_init)\n\t\t\tgoto err_set_elem_expr;\n\t\tset->ops->gc_init(set);\n\t}\n\n\treturn expr;\n\nerr_set_elem_expr:\n\tnft_expr_destroy(ctx, expr);\n\treturn ERR_PTR(err);\n}\n\nstatic int nft_set_ext_check(const struct nft_set_ext_tmpl *tmpl, u8 id, u32 len)\n{\n\tlen += nft_set_ext_types[id].len;\n\tif (len > tmpl->ext_len[id] ||\n\t    len > U8_MAX)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_set_ext_memcpy(const struct nft_set_ext_tmpl *tmpl, u8 id,\n\t\t\t      void *to, const void *from, u32 len)\n{\n\tif (nft_set_ext_check(tmpl, id, len) < 0)\n\t\treturn -1;\n\n\tmemcpy(to, from, len);\n\n\treturn 0;\n}\n\nvoid *nft_set_elem_init(const struct nft_set *set,\n\t\t\tconst struct nft_set_ext_tmpl *tmpl,\n\t\t\tconst u32 *key, const u32 *key_end,\n\t\t\tconst u32 *data, u64 timeout, u64 expiration, gfp_t gfp)\n{\n\tstruct nft_set_ext *ext;\n\tvoid *elem;\n\n\telem = kzalloc(set->ops->elemsize + tmpl->len, gfp);\n\tif (elem == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\text = nft_set_elem_ext(set, elem);\n\tnft_set_ext_init(ext, tmpl);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY,\n\t\t\t       nft_set_ext_key(ext), key, set->klen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY_END,\n\t\t\t       nft_set_ext_key_end(ext), key_end, set->klen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_DATA,\n\t\t\t       nft_set_ext_data(ext), data, set->dlen) < 0)\n\t\tgoto err_ext_check;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\t*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;\n\t\tif (expiration == 0)\n\t\t\t*nft_set_ext_expiration(ext) += timeout;\n\t}\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))\n\t\t*nft_set_ext_timeout(ext) = timeout;\n\n\treturn elem;\n\nerr_ext_check:\n\tkfree(elem);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void __nft_set_elem_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_expr *expr)\n{\n\tif (expr->ops->destroy_clone) {\n\t\texpr->ops->destroy_clone(ctx, expr);\n\t\tmodule_put(expr->ops->type->owner);\n\t} else {\n\t\tnf_tables_expr_destroy(ctx, expr);\n\t}\n}\n\nstatic void nft_set_elem_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t      struct nft_set_elem_expr *elem_expr)\n{\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tnft_setelem_expr_foreach(expr, elem_expr, size)\n\t\t__nft_set_elem_expr_destroy(ctx, expr);\n}\n\nvoid nft_set_elem_destroy(const struct nft_set *set, void *elem,\n\t\t\t  bool destroy_expr)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem);\n\tstruct nft_ctx ctx = {\n\t\t.net\t= read_pnet(&set->net),\n\t\t.family\t= set->table->family,\n\t};\n\n\tnft_data_release(nft_set_ext_key(ext), NFT_DATA_VALUE);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_release(nft_set_ext_data(ext), set->dtype);\n\tif (destroy_expr && nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))\n\t\tnft_set_elem_expr_destroy(&ctx, nft_set_ext_expr(ext));\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use--;\n\tkfree(elem);\n}\nEXPORT_SYMBOL_GPL(nft_set_elem_destroy);\n\n/* Only called from commit path, nft_setelem_data_deactivate() already deals\n * with the refcounting from the preparation phase.\n */\nstatic void nf_tables_set_elem_destroy(const struct nft_ctx *ctx,\n\t\t\t\t       const struct nft_set *set, void *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))\n\t\tnft_set_elem_expr_destroy(ctx, nft_set_ext_expr(ext));\n\n\tkfree(elem);\n}\n\nint nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[])\n{\n\tstruct nft_expr *expr;\n\tint err, i, k;\n\n\tfor (i = 0; i < set->num_exprs; i++) {\n\t\texpr = kzalloc(set->exprs[i]->ops->size, GFP_KERNEL_ACCOUNT);\n\t\tif (!expr)\n\t\t\tgoto err_expr;\n\n\t\terr = nft_expr_clone(expr, set->exprs[i]);\n\t\tif (err < 0) {\n\t\t\tkfree(expr);\n\t\t\tgoto err_expr;\n\t\t}\n\t\texpr_array[i] = expr;\n\t}\n\n\treturn 0;\n\nerr_expr:\n\tfor (k = i - 1; k >= 0; k--)\n\t\tnft_expr_destroy(ctx, expr_array[k]);\n\n\treturn -ENOMEM;\n}\n\nstatic int nft_set_elem_expr_setup(struct nft_ctx *ctx,\n\t\t\t\t   const struct nft_set_ext_tmpl *tmpl,\n\t\t\t\t   const struct nft_set_ext *ext,\n\t\t\t\t   struct nft_expr *expr_array[],\n\t\t\t\t   u32 num_exprs)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tu32 len = sizeof(struct nft_set_elem_expr);\n\tstruct nft_expr *expr;\n\tint i, err;\n\n\tif (num_exprs == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_exprs; i++)\n\t\tlen += expr_array[i]->ops->size;\n\n\tif (nft_set_ext_check(tmpl, NFT_SET_EXT_EXPRESSIONS, len) < 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_exprs; i++) {\n\t\texpr = nft_setelem_expr_at(elem_expr, elem_expr->size);\n\t\terr = nft_expr_clone(expr, expr_array[i]);\n\t\tif (err < 0)\n\t\t\tgoto err_elem_expr_setup;\n\n\t\telem_expr->size += expr_array[i]->ops->size;\n\t\tnft_expr_destroy(ctx, expr_array[i]);\n\t\texpr_array[i] = NULL;\n\t}\n\n\treturn 0;\n\nerr_elem_expr_setup:\n\tfor (; i < num_exprs; i++) {\n\t\tnft_expr_destroy(ctx, expr_array[i]);\n\t\texpr_array[i] = NULL;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstruct nft_set_ext *nft_set_catchall_lookup(const struct net *net,\n\t\t\t\t\t    const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (nft_set_elem_active(ext, genmask) &&\n\t\t    !nft_set_elem_expired(ext))\n\t\t\treturn ext;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(nft_set_catchall_lookup);\n\nvoid *nft_set_catchall_gc(const struct nft_set *set)\n{\n\tstruct nft_set_elem_catchall *catchall, *next;\n\tstruct nft_set_ext *ext;\n\tvoid *elem = NULL;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\n\t\tif (!nft_set_elem_expired(ext) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\telem = catchall->elem;\n\t\tlist_del_rcu(&catchall->list);\n\t\tkfree_rcu(catchall, rcu);\n\t\tbreak;\n\t}\n\n\treturn elem;\n}\nEXPORT_SYMBOL_GPL(nft_set_catchall_gc);\n\nstatic int nft_setelem_catchall_insert(const struct net *net,\n\t\t\t\t       struct nft_set *set,\n\t\t\t\t       const struct nft_set_elem *elem,\n\t\t\t\t       struct nft_set_ext **pext)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tu8 genmask = nft_genmask_next(net);\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (nft_set_elem_active(ext, genmask)) {\n\t\t\t*pext = ext;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tcatchall = kmalloc(sizeof(*catchall), GFP_KERNEL);\n\tif (!catchall)\n\t\treturn -ENOMEM;\n\n\tcatchall->elem = elem->priv;\n\tlist_add_tail_rcu(&catchall->list, &set->catchall_list);\n\n\treturn 0;\n}\n\nstatic int nft_setelem_insert(const struct net *net,\n\t\t\t      struct nft_set *set,\n\t\t\t      const struct nft_set_elem *elem,\n\t\t\t      struct nft_set_ext **ext, unsigned int flags)\n{\n\tint ret;\n\n\tif (flags & NFT_SET_ELEM_CATCHALL)\n\t\tret = nft_setelem_catchall_insert(net, set, elem, ext);\n\telse\n\t\tret = set->ops->insert(net, set, elem, ext);\n\n\treturn ret;\n}\n\nstatic bool nft_setelem_is_catchall(const struct nft_set *set,\n\t\t\t\t    const struct nft_set_elem *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    *nft_set_ext_flags(ext) & NFT_SET_ELEM_CATCHALL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void nft_setelem_activate(struct net *net, struct nft_set *set,\n\t\t\t\t struct nft_set_elem *elem)\n{\n\tstruct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_setelem_is_catchall(set, elem)) {\n\t\tnft_set_elem_change_active(net, set, ext);\n\t\tnft_set_elem_clear_busy(ext);\n\t} else {\n\t\tset->ops->activate(net, set, elem);\n\t}\n}\n\nstatic int nft_setelem_catchall_deactivate(const struct net *net,\n\t\t\t\t\t   struct nft_set *set,\n\t\t\t\t\t   struct nft_set_elem *elem)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_is_active(net, ext) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\tkfree(elem->priv);\n\t\telem->priv = catchall->elem;\n\t\tnft_set_elem_change_active(net, set, ext);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int __nft_setelem_deactivate(const struct net *net,\n\t\t\t\t    struct nft_set *set,\n\t\t\t\t    struct nft_set_elem *elem)\n{\n\tvoid *priv;\n\n\tpriv = set->ops->deactivate(net, set, elem);\n\tif (!priv)\n\t\treturn -ENOENT;\n\n\tkfree(elem->priv);\n\telem->priv = priv;\n\tset->ndeact++;\n\n\treturn 0;\n}\n\nstatic int nft_setelem_deactivate(const struct net *net,\n\t\t\t\t  struct nft_set *set,\n\t\t\t\t  struct nft_set_elem *elem, u32 flags)\n{\n\tint ret;\n\n\tif (flags & NFT_SET_ELEM_CATCHALL)\n\t\tret = nft_setelem_catchall_deactivate(net, set, elem);\n\telse\n\t\tret = __nft_setelem_deactivate(net, set, elem);\n\n\treturn ret;\n}\n\nstatic void nft_setelem_catchall_remove(const struct net *net,\n\t\t\t\t\tconst struct nft_set *set,\n\t\t\t\t\tconst struct nft_set_elem *elem)\n{\n\tstruct nft_set_elem_catchall *catchall, *next;\n\n\tlist_for_each_entry_safe(catchall, next, &set->catchall_list, list) {\n\t\tif (catchall->elem == elem->priv) {\n\t\t\tlist_del_rcu(&catchall->list);\n\t\t\tkfree_rcu(catchall, rcu);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void nft_setelem_remove(const struct net *net,\n\t\t\t       const struct nft_set *set,\n\t\t\t       const struct nft_set_elem *elem)\n{\n\tif (nft_setelem_is_catchall(set, elem))\n\t\tnft_setelem_catchall_remove(net, set, elem);\n\telse\n\t\tset->ops->remove(net, set, elem);\n}\n\nstatic bool nft_setelem_valid_key_end(const struct nft_set *set,\n\t\t\t\t      struct nlattr **nla, u32 flags)\n{\n\tif ((set->flags & (NFT_SET_CONCAT | NFT_SET_INTERVAL)) ==\n\t\t\t  (NFT_SET_CONCAT | NFT_SET_INTERVAL)) {\n\t\tif (flags & NFT_SET_ELEM_INTERVAL_END)\n\t\t\treturn false;\n\t\tif (!nla[NFTA_SET_ELEM_KEY_END] &&\n\t\t    !(flags & NFT_SET_ELEM_CATCHALL))\n\t\t\treturn false;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_KEY_END])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    const struct nlattr *attr, u32 nlmsg_flags)\n{\n\tstruct nft_expr *expr_array[NFT_SET_EXPR_MAX] = {};\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tu32 flags = 0, size = 0, num_exprs = 0;\n\tstruct nft_set_ext_tmpl tmpl;\n\tstruct nft_set_ext *ext, *ext2;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_binding *binding;\n\tstruct nft_object *obj = NULL;\n\tstruct nft_userdata *udata;\n\tstruct nft_data_desc desc;\n\tenum nft_registers dreg;\n\tstruct nft_trans *trans;\n\tu64 timeout;\n\tu64 expiration;\n\tint err, i;\n\tu8 ulen;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_set_ext_prepare(&tmpl);\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (flags != 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (set->flags & NFT_SET_MAP) {\n\t\tif (nla[NFTA_SET_ELEM_DATA] == NULL &&\n\t\t    !(flags & NFT_SET_ELEM_INTERVAL_END))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_DATA] != NULL)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (set->flags & NFT_SET_OBJECT) {\n\t\tif (!nla[NFTA_SET_ELEM_OBJREF] &&\n\t\t    !(flags & NFT_SET_ELEM_INTERVAL_END))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (nla[NFTA_SET_ELEM_OBJREF])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!nft_setelem_valid_key_end(set, nla, flags))\n\t\treturn -EINVAL;\n\n\tif ((flags & NFT_SET_ELEM_INTERVAL_END) &&\n\t     (nla[NFTA_SET_ELEM_DATA] ||\n\t      nla[NFTA_SET_ELEM_OBJREF] ||\n\t      nla[NFTA_SET_ELEM_TIMEOUT] ||\n\t      nla[NFTA_SET_ELEM_EXPIRATION] ||\n\t      nla[NFTA_SET_ELEM_USERDATA] ||\n\t      nla[NFTA_SET_ELEM_EXPR] ||\n\t      nla[NFTA_SET_ELEM_KEY_END] ||\n\t      nla[NFTA_SET_ELEM_EXPRESSIONS]))\n\t\treturn -EINVAL;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_ELEM_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_TIMEOUT],\n\t\t\t\t\t    &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_TIMEOUT) {\n\t\ttimeout = set->timeout;\n\t}\n\n\texpiration = 0;\n\tif (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],\n\t\t\t\t\t    &expiration);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_EXPR]) {\n\t\tstruct nft_expr *expr;\n\n\t\tif (set->num_exprs && set->num_exprs != 1)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\texpr = nft_set_elem_expr_alloc(ctx, set,\n\t\t\t\t\t       nla[NFTA_SET_ELEM_EXPR]);\n\t\tif (IS_ERR(expr))\n\t\t\treturn PTR_ERR(expr);\n\n\t\texpr_array[0] = expr;\n\t\tnum_exprs = 1;\n\n\t\tif (set->num_exprs && set->exprs[0]->ops != expr->ops) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_set_elem_expr;\n\t\t}\n\t} else if (nla[NFTA_SET_ELEM_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_ELEM_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX ||\n\t\t\t    (set->num_exprs && set->num_exprs == i)) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\texpr_array[i] = expr;\n\t\t\tnum_exprs++;\n\n\t\t\tif (set->num_exprs && expr->ops != set->exprs[i]->ops) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_set_elem_expr;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_set_elem_expr;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, expr_array);\n\t\tif (err < 0)\n\t\t\tgoto err_set_elem_expr_clone;\n\n\t\tnum_exprs = set->num_exprs;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\tgoto err_set_elem_expr;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (timeout > 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\n\t\tif (timeout != set->timeout) {\n\t\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_key_end;\n\t\t}\n\t}\n\n\tif (num_exprs) {\n\t\tfor (i = 0; i < num_exprs; i++)\n\t\t\tsize += expr_array[i]->ops->size;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_EXPRESSIONS,\n\t\t\t\t\t     sizeof(struct nft_set_elem_expr) + size);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_OBJREF] != NULL) {\n\t\tobj = nft_obj_lookup(ctx->net, ctx->table,\n\t\t\t\t     nla[NFTA_SET_ELEM_OBJREF],\n\t\t\t\t     set->objtype, genmask);\n\t\tif (IS_ERR(obj)) {\n\t\t\terr = PTR_ERR(obj);\n\t\t\tgoto err_parse_key_end;\n\t\t}\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_OBJREF);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_DATA] != NULL) {\n\t\terr = nft_setelem_parse_data(ctx, set, &desc, &elem.data.val,\n\t\t\t\t\t     nla[NFTA_SET_ELEM_DATA]);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_key_end;\n\n\t\tdreg = nft_type_to_reg(set->dtype);\n\t\tlist_for_each_entry(binding, &set->bindings, list) {\n\t\t\tstruct nft_ctx bind_ctx = {\n\t\t\t\t.net\t= ctx->net,\n\t\t\t\t.family\t= ctx->family,\n\t\t\t\t.table\t= ctx->table,\n\t\t\t\t.chain\t= (struct nft_chain *)binding->chain,\n\t\t\t};\n\n\t\t\tif (!(binding->flags & NFT_SET_MAP))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_validate_register_store(&bind_ctx, dreg,\n\t\t\t\t\t\t\t  &elem.data.val,\n\t\t\t\t\t\t\t  desc.type, desc.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_data;\n\n\t\t\tif (desc.type == NFT_DATA_VERDICT &&\n\t\t\t    (elem.data.val.verdict.code == NFT_GOTO ||\n\t\t\t     elem.data.val.verdict.code == NFT_JUMP))\n\t\t\t\tnft_validate_state_update(ctx->net,\n\t\t\t\t\t\t\t  NFT_VALIDATE_NEED);\n\t\t}\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_DATA, desc.len);\n\t\tif (err < 0)\n\t\t\tgoto err_parse_data;\n\t}\n\n\t/* The full maximum length of userdata can exceed the maximum\n\t * offset value (U8_MAX) for following extensions, therefor it\n\t * must be the last extension added.\n\t */\n\tulen = 0;\n\tif (nla[NFTA_SET_ELEM_USERDATA] != NULL) {\n\t\tulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);\n\t\tif (ulen > 0) {\n\t\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_USERDATA,\n\t\t\t\t\t\t     ulen);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_parse_data;\n\t\t}\n\t}\n\n\telem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,\n\t\t\t\t      elem.key_end.val.data, elem.data.val.data,\n\t\t\t\t      timeout, expiration, GFP_KERNEL_ACCOUNT);\n\tif (IS_ERR(elem.priv)) {\n\t\terr = PTR_ERR(elem.priv);\n\t\tgoto err_parse_data;\n\t}\n\n\text = nft_set_elem_ext(set, elem.priv);\n\tif (flags)\n\t\t*nft_set_ext_flags(ext) = flags;\n\n\tif (ulen > 0) {\n\t\tif (nft_set_ext_check(&tmpl, NFT_SET_EXT_USERDATA, ulen) < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_elem_userdata;\n\t\t}\n\t\tudata = nft_set_ext_userdata(ext);\n\t\tudata->len = ulen - 1;\n\t\tnla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);\n\t}\n\tif (obj) {\n\t\t*nft_set_ext_obj(ext) = obj;\n\t\tobj->use++;\n\t}\n\terr = nft_set_elem_expr_setup(ctx, &tmpl, ext, expr_array, num_exprs);\n\tif (err < 0)\n\t\tgoto err_elem_free;\n\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);\n\tif (trans == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_elem_free;\n\t}\n\n\text->genmask = nft_genmask_cur(ctx->net) | NFT_SET_ELEM_BUSY_MASK;\n\n\terr = nft_setelem_insert(ctx->net, set, &elem, &ext2, flags);\n\tif (err) {\n\t\tif (err == -EEXIST) {\n\t\t\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) ^\n\t\t\t    nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) ||\n\t\t\t    nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) ^\n\t\t\t    nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF))\n\t\t\t\tgoto err_element_clash;\n\t\t\tif ((nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\n\t\t\t     nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) &&\n\t\t\t     memcmp(nft_set_ext_data(ext),\n\t\t\t\t    nft_set_ext_data(ext2), set->dlen) != 0) ||\n\t\t\t    (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&\n\t\t\t     nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF) &&\n\t\t\t     *nft_set_ext_obj(ext) != *nft_set_ext_obj(ext2)))\n\t\t\t\tgoto err_element_clash;\n\t\t\telse if (!(nlmsg_flags & NLM_F_EXCL))\n\t\t\t\terr = 0;\n\t\t} else if (err == -ENOTEMPTY) {\n\t\t\t/* ENOTEMPTY reports overlapping between this element\n\t\t\t * and an existing one.\n\t\t\t */\n\t\t\terr = -EEXIST;\n\t\t}\n\t\tgoto err_element_clash;\n\t}\n\n\tif (!(flags & NFT_SET_ELEM_CATCHALL) && set->size &&\n\t    !atomic_add_unless(&set->nelems, 1, set->size + set->ndeact)) {\n\t\terr = -ENFILE;\n\t\tgoto err_set_full;\n\t}\n\n\tnft_trans_elem(trans) = elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n\nerr_set_full:\n\tnft_setelem_remove(ctx->net, set, &elem);\nerr_element_clash:\n\tkfree(trans);\nerr_elem_free:\n\tif (obj)\n\t\tobj->use--;\nerr_elem_userdata:\n\tnf_tables_set_elem_destroy(ctx, set, elem.priv);\nerr_parse_data:\n\tif (nla[NFTA_SET_ELEM_DATA] != NULL)\n\t\tnft_data_release(&elem.data.val, desc.type);\nerr_parse_key_end:\n\tnft_data_release(&elem.key_end.val, NFT_DATA_VALUE);\nerr_parse_key:\n\tnft_data_release(&elem.key.val, NFT_DATA_VALUE);\nerr_set_elem_expr:\n\tfor (i = 0; i < num_exprs && expr_array[i]; i++)\n\t\tnft_expr_destroy(ctx, expr_array[i]);\nerr_set_elem_expr_clone:\n\treturn err;\n}\n\nstatic int nf_tables_newsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err;\n\n\tif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup_global(net, table, nla[NFTA_SET_ELEM_LIST_SET],\n\t\t\t\t    nla[NFTA_SET_ELEM_LIST_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_add_set_elem(&ctx, set, attr, info->nlh->nlmsg_flags);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (nft_net->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\n\treturn 0;\n}\n\n/**\n *\tnft_data_hold - hold a nft_data item\n *\n *\t@data: struct nft_data to release\n *\t@type: type of data\n *\n *\tHold a nft_data item. NFT_DATA_VALUE types can be silently discarded,\n *\tNFT_DATA_VERDICT bumps the reference to chains in case of NFT_JUMP and\n *\tNFT_GOTO verdicts. This function must be called on active data objects\n *\tfrom the second phase of the commit protocol.\n */\nvoid nft_data_hold(const struct nft_data *data, enum nft_data_types type)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tif (type == NFT_DATA_VERDICT) {\n\t\tswitch (data->verdict.code) {\n\t\tcase NFT_JUMP:\n\t\tcase NFT_GOTO:\n\t\t\tchain = data->verdict.chain;\n\t\t\tchain->use++;\n\n\t\t\tif (!nft_chain_is_bound(chain))\n\t\t\t\tbreak;\n\n\t\t\tchain->table->use++;\n\t\t\tlist_for_each_entry(rule, &chain->rules, list)\n\t\t\t\tchain->use++;\n\n\t\t\tnft_chain_add(chain->table, chain);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void nft_setelem_data_activate(const struct net *net,\n\t\t\t\t      const struct nft_set *set,\n\t\t\t\t      struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_hold(nft_set_ext_data(ext), set->dtype);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use++;\n}\n\nstatic void nft_setelem_data_deactivate(const struct net *net,\n\t\t\t\t\tconst struct nft_set *set,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\n\t\tnft_data_release(nft_set_ext_data(ext), set->dtype);\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))\n\t\t(*nft_set_ext_obj(ext))->use--;\n}\n\nstatic int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_set_ext_tmpl tmpl;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tstruct nft_trans *trans;\n\tu32 flags = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t\t\t  nft_set_elem_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))\n\t\treturn -EINVAL;\n\n\tif (!nft_setelem_valid_key_end(set, nla, flags))\n\t\treturn -EINVAL;\n\n\tnft_set_ext_prepare(&tmpl);\n\n\tif (flags != 0) {\n\t\terr = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem;\n\t}\n\n\tif (nla[NFTA_SET_ELEM_KEY_END]) {\n\t\terr = nft_setelem_parse_key(ctx, set, &elem.key_end.val,\n\t\t\t\t\t    nla[NFTA_SET_ELEM_KEY_END]);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem;\n\n\t\terr = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);\n\t\tif (err < 0)\n\t\t\tgoto fail_elem_key_end;\n\t}\n\n\terr = -ENOMEM;\n\telem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,\n\t\t\t\t      elem.key_end.val.data, NULL, 0, 0,\n\t\t\t\t      GFP_KERNEL_ACCOUNT);\n\tif (IS_ERR(elem.priv)) {\n\t\terr = PTR_ERR(elem.priv);\n\t\tgoto fail_elem_key_end;\n\t}\n\n\text = nft_set_elem_ext(set, elem.priv);\n\tif (flags)\n\t\t*nft_set_ext_flags(ext) = flags;\n\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\n\tif (trans == NULL)\n\t\tgoto fail_trans;\n\n\terr = nft_setelem_deactivate(ctx->net, set, &elem, flags);\n\tif (err < 0)\n\t\tgoto fail_ops;\n\n\tnft_setelem_data_deactivate(ctx->net, set, &elem);\n\n\tnft_trans_elem(trans) = elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\n\nfail_ops:\n\tkfree(trans);\nfail_trans:\n\tkfree(elem.priv);\nfail_elem_key_end:\n\tnft_data_release(&elem.key_end.val, NFT_DATA_VALUE);\nfail_elem:\n\tnft_data_release(&elem.key.val, NFT_DATA_VALUE);\n\treturn err;\n}\n\nstatic int nft_setelem_flush(const struct nft_ctx *ctx,\n\t\t\t     struct nft_set *set,\n\t\t\t     const struct nft_set_iter *iter,\n\t\t\t     struct nft_set_elem *elem)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\n\ttrans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,\n\t\t\t\t    sizeof(struct nft_trans_elem), GFP_ATOMIC);\n\tif (!trans)\n\t\treturn -ENOMEM;\n\n\tif (!set->ops->flush(ctx->net, set, elem->priv)) {\n\t\terr = -ENOENT;\n\t\tgoto err1;\n\t}\n\tset->ndeact++;\n\n\tnft_setelem_data_deactivate(ctx->net, set, elem);\n\tnft_trans_elem_set(trans) = set;\n\tnft_trans_elem(trans) = *elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\nerr1:\n\tkfree(trans);\n\treturn err;\n}\n\nstatic int __nft_set_catchall_flush(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_set *set,\n\t\t\t\t    struct nft_set_elem *elem)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,\n\t\t\t\t    sizeof(struct nft_trans_elem), GFP_KERNEL);\n\tif (!trans)\n\t\treturn -ENOMEM;\n\n\tnft_setelem_data_deactivate(ctx->net, set, elem);\n\tnft_trans_elem_set(trans) = set;\n\tnft_trans_elem(trans) = *elem;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n}\n\nstatic int nft_set_catchall_flush(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_elem elem;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask) ||\n\t\t    nft_set_elem_mark_busy(ext))\n\t\t\tcontinue;\n\n\t\telem.priv = catchall->elem;\n\t\tret = __nft_set_catchall_flush(ctx, set, &elem);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nft_set_flush(struct nft_ctx *ctx, struct nft_set *set, u8 genmask)\n{\n\tstruct nft_set_iter iter = {\n\t\t.genmask\t= genmask,\n\t\t.fn\t\t= nft_setelem_flush,\n\t};\n\n\tset->ops->walk(ctx, set, &iter);\n\tif (!iter.err)\n\t\titer.err = nft_set_catchall_flush(ctx, set);\n\n\treturn iter.err;\n}\n\nstatic int nf_tables_delsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err = 0;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])\n\t\treturn nft_set_flush(&ctx, set, genmask);\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_del_setelem(&ctx, set, attr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nvoid nft_set_gc_batch_release(struct rcu_head *rcu)\n{\n\tstruct nft_set_gc_batch *gcb;\n\tunsigned int i;\n\n\tgcb = container_of(rcu, struct nft_set_gc_batch, head.rcu);\n\tfor (i = 0; i < gcb->head.cnt; i++)\n\t\tnft_set_elem_destroy(gcb->head.set, gcb->elems[i], true);\n\tkfree(gcb);\n}\n\nstruct nft_set_gc_batch *nft_set_gc_batch_alloc(const struct nft_set *set,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct nft_set_gc_batch *gcb;\n\n\tgcb = kzalloc(sizeof(*gcb), gfp);\n\tif (gcb == NULL)\n\t\treturn gcb;\n\tgcb->head.set = set;\n\treturn gcb;\n}\n\n/*\n * Stateful objects\n */\n\n/**\n *\tnft_register_obj- register nf_tables stateful object type\n *\t@obj_type: object type\n *\n *\tRegisters the object type for use with nf_tables. Returns zero on\n *\tsuccess or a negative errno code otherwise.\n */\nint nft_register_obj(struct nft_object_type *obj_type)\n{\n\tif (obj_type->type == NFT_OBJECT_UNSPEC)\n\t\treturn -EINVAL;\n\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_add_rcu(&obj_type->list, &nf_tables_objects);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_register_obj);\n\n/**\n *\tnft_unregister_obj - unregister nf_tables object type\n *\t@obj_type: object type\n *\n * \tUnregisters the object type for use with nf_tables.\n */\nvoid nft_unregister_obj(struct nft_object_type *obj_type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&obj_type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_obj);\n\nstruct nft_object *nft_obj_lookup(const struct net *net,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nlattr *nla, u32 objtype,\n\t\t\t\t  u8 genmask)\n{\n\tstruct nft_object_hash_key k = { .table = table };\n\tchar search[NFT_OBJ_MAXNAMELEN];\n\tstruct rhlist_head *tmp, *list;\n\tstruct nft_object *obj;\n\n\tnla_strscpy(search, nla, sizeof(search));\n\tk.name = search;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held() &&\n\t\t     !lockdep_commit_lock_is_held(net));\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&nft_objname_ht, &k, nft_objname_ht_params);\n\tif (!list)\n\t\tgoto out;\n\n\trhl_for_each_entry_rcu(obj, tmp, list, rhlhead) {\n\t\tif (objtype == obj->ops->type->type &&\n\t\t    nft_active_genmask(obj, genmask)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn obj;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\nEXPORT_SYMBOL_GPL(nft_obj_lookup);\n\nstatic struct nft_object *nft_obj_lookup_byhandle(const struct nft_table *table,\n\t\t\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t\t\t  u32 objtype, u8 genmask)\n{\n\tstruct nft_object *obj;\n\n\tlist_for_each_entry(obj, &table->objects, list) {\n\t\tif (be64_to_cpu(nla_get_be64(nla)) == obj->handle &&\n\t\t    objtype == obj->ops->type->type &&\n\t\t    nft_active_genmask(obj, genmask))\n\t\t\treturn obj;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic const struct nla_policy nft_obj_policy[NFTA_OBJ_MAX + 1] = {\n\t[NFTA_OBJ_TABLE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_TABLE_MAXNAMELEN - 1 },\n\t[NFTA_OBJ_NAME]\t\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_OBJ_MAXNAMELEN - 1 },\n\t[NFTA_OBJ_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_OBJ_DATA]\t\t= { .type = NLA_NESTED },\n\t[NFTA_OBJ_HANDLE]\t= { .type = NLA_U64},\n\t[NFTA_OBJ_USERDATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NFT_USERDATA_MAXLEN },\n};\n\nstatic struct nft_object *nft_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t       const struct nft_object_type *type,\n\t\t\t\t       const struct nlattr *attr)\n{\n\tstruct nlattr **tb;\n\tconst struct nft_object_ops *ops;\n\tstruct nft_object *obj;\n\tint err = -ENOMEM;\n\n\ttb = kmalloc_array(type->maxattr + 1, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\tgoto err1;\n\n\tif (attr) {\n\t\terr = nla_parse_nested_deprecated(tb, type->maxattr, attr,\n\t\t\t\t\t\t  type->policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t} else {\n\t\tmemset(tb, 0, sizeof(tb[0]) * (type->maxattr + 1));\n\t}\n\n\tif (type->select_ops) {\n\t\tops = type->select_ops(ctx, (const struct nlattr * const *)tb);\n\t\tif (IS_ERR(ops)) {\n\t\t\terr = PTR_ERR(ops);\n\t\t\tgoto err2;\n\t\t}\n\t} else {\n\t\tops = type->ops;\n\t}\n\n\terr = -ENOMEM;\n\tobj = kzalloc(sizeof(*obj) + ops->size, GFP_KERNEL_ACCOUNT);\n\tif (!obj)\n\t\tgoto err2;\n\n\terr = ops->init(ctx, (const struct nlattr * const *)tb, obj);\n\tif (err < 0)\n\t\tgoto err3;\n\n\tobj->ops = ops;\n\n\tkfree(tb);\n\treturn obj;\nerr3:\n\tkfree(obj);\nerr2:\n\tkfree(tb);\nerr1:\n\treturn ERR_PTR(err);\n}\n\nstatic int nft_object_dump(struct sk_buff *skb, unsigned int attr,\n\t\t\t   struct nft_object *obj, bool reset)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (obj->ops->dump(skb, obj, reset) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_object_type *__nft_obj_type_get(u32 objtype)\n{\n\tconst struct nft_object_type *type;\n\n\tlist_for_each_entry(type, &nf_tables_objects, list) {\n\t\tif (objtype == type->type)\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstatic const struct nft_object_type *\nnft_obj_type_get(struct net *net, u32 objtype)\n{\n\tconst struct nft_object_type *type;\n\n\ttype = __nft_obj_type_get(objtype);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nft-obj-%u\", objtype) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nf_tables_updobj(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_object_type *type,\n\t\t\t    const struct nlattr *attr,\n\t\t\t    struct nft_object *obj)\n{\n\tstruct nft_object *newobj;\n\tstruct nft_trans *trans;\n\tint err = -ENOMEM;\n\n\tif (!try_module_get(type->owner))\n\t\treturn -ENOENT;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWOBJ,\n\t\t\t\tsizeof(struct nft_trans_obj));\n\tif (!trans)\n\t\tgoto err_trans;\n\n\tnewobj = nft_obj_init(ctx, type, attr);\n\tif (IS_ERR(newobj)) {\n\t\terr = PTR_ERR(newobj);\n\t\tgoto err_free_trans;\n\t}\n\n\tnft_trans_obj(trans) = obj;\n\tnft_trans_obj_update(trans) = true;\n\tnft_trans_obj_newobj(trans) = newobj;\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_free_trans:\n\tkfree(trans);\nerr_trans:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_newobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_object_type *type;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_object *obj;\n\tstruct nft_ctx ctx;\n\tu32 objtype;\n\tint err;\n\n\tif (!nla[NFTA_OBJ_TYPE] ||\n\t    !nla[NFTA_OBJ_NAME] ||\n\t    !nla[NFTA_OBJ_DATA])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tobj = nft_obj_lookup(net, table, nla[NFTA_OBJ_NAME], objtype, genmask);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tif (err != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttype = __nft_obj_type_get(objtype);\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updobj(&ctx, type, nla[NFTA_OBJ_DATA], obj);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\ttype = nft_obj_type_get(net, objtype);\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tobj = nft_obj_init(&ctx, type, nla[NFTA_OBJ_DATA]);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto err_init;\n\t}\n\tobj->key.table = table;\n\tobj->handle = nf_tables_alloc_handle(table);\n\n\tobj->key.name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!obj->key.name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_strdup;\n\t}\n\n\tif (nla[NFTA_OBJ_USERDATA]) {\n\t\tobj->udata = nla_memdup(nla[NFTA_OBJ_USERDATA], GFP_KERNEL);\n\t\tif (obj->udata == NULL)\n\t\t\tgoto err_userdata;\n\n\t\tobj->udlen = nla_len(nla[NFTA_OBJ_USERDATA]);\n\t}\n\n\terr = nft_trans_obj_add(&ctx, NFT_MSG_NEWOBJ, obj);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\terr = rhltable_insert(&nft_objname_ht, &obj->rhlhead,\n\t\t\t      nft_objname_ht_params);\n\tif (err < 0)\n\t\tgoto err_obj_ht;\n\n\tlist_add_tail_rcu(&obj->list, &table->objects);\n\ttable->use++;\n\treturn 0;\nerr_obj_ht:\n\t/* queued in transaction log */\n\tINIT_LIST_HEAD(&obj->list);\n\treturn err;\nerr_trans:\n\tkfree(obj->udata);\nerr_userdata:\n\tkfree(obj->key.name);\nerr_strdup:\n\tif (obj->ops->destroy)\n\t\tobj->ops->destroy(&ctx, obj);\n\tkfree(obj);\nerr_init:\n\tmodule_put(type->owner);\n\treturn err;\n}\n\nstatic int nf_tables_fill_obj_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t   u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t   int family, const struct nft_table *table,\n\t\t\t\t   struct nft_object *obj, bool reset)\n{\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_OBJ_TABLE, table->name) ||\n\t    nla_put_string(skb, NFTA_OBJ_NAME, obj->key.name) ||\n\t    nla_put_be32(skb, NFTA_OBJ_TYPE, htonl(obj->ops->type->type)) ||\n\t    nla_put_be32(skb, NFTA_OBJ_USE, htonl(obj->use)) ||\n\t    nft_object_dump(skb, NFTA_OBJ_DATA, obj, reset) ||\n\t    nla_put_be64(skb, NFTA_OBJ_HANDLE, cpu_to_be64(obj->handle),\n\t\t\t NFTA_OBJ_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (obj->udata &&\n\t    nla_put(skb, NFTA_OBJ_USERDATA, obj->udlen, obj->udata))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nft_obj_filter {\n\tchar\t\t*table;\n\tu32\t\ttype;\n};\n\nstatic int nf_tables_dump_obj(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tconst struct nft_table *table;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct nft_obj_filter *filter = cb->data;\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_object *obj;\n\tbool reset = false;\n\n\tif (NFNL_MSG_TYPE(cb->nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)\n\t\treset = true;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(obj, &table->objects, list) {\n\t\t\tif (!nft_is_active(net, obj))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (filter && filter->table &&\n\t\t\t    strcmp(filter->table, table->name))\n\t\t\t\tgoto cont;\n\t\t\tif (filter &&\n\t\t\t    filter->type != NFT_OBJECT_UNSPEC &&\n\t\t\t    obj->ops->type->type != filter->type)\n\t\t\t\tgoto cont;\n\t\t\tif (reset) {\n\t\t\t\tchar *buf = kasprintf(GFP_ATOMIC,\n\t\t\t\t\t\t      \"%s:%u\",\n\t\t\t\t\t\t      table->name,\n\t\t\t\t\t\t      nft_net->base_seq);\n\n\t\t\t\taudit_log_nfcfg(buf,\n\t\t\t\t\t\tfamily,\n\t\t\t\t\t\tobj->handle,\n\t\t\t\t\t\tAUDIT_NFT_OP_OBJ_RESET,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tkfree(buf);\n\t\t\t}\n\n\t\t\tif (nf_tables_fill_obj_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t    NFT_MSG_NEWOBJ,\n\t\t\t\t\t\t    NLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\t\t    table->family, table,\n\t\t\t\t\t\t    obj, reset) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_obj_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_obj_filter *filter = NULL;\n\n\tif (nla[NFTA_OBJ_TABLE] || nla[NFTA_OBJ_TYPE]) {\n\t\tfilter = kzalloc(sizeof(*filter), GFP_ATOMIC);\n\t\tif (!filter)\n\t\t\treturn -ENOMEM;\n\n\t\tif (nla[NFTA_OBJ_TABLE]) {\n\t\t\tfilter->table = nla_strdup(nla[NFTA_OBJ_TABLE], GFP_ATOMIC);\n\t\t\tif (!filter->table) {\n\t\t\t\tkfree(filter);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (nla[NFTA_OBJ_TYPE])\n\t\t\tfilter->type = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\t}\n\n\tcb->data = filter;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_obj_done(struct netlink_callback *cb)\n{\n\tstruct nft_obj_filter *filter = cb->data;\n\n\tif (filter) {\n\t\tkfree(filter->table);\n\t\tkfree(filter);\n\t}\n\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct nft_object *obj;\n\tstruct sk_buff *skb2;\n\tbool reset = false;\n\tu32 objtype;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_obj_start,\n\t\t\t.dump = nf_tables_dump_obj,\n\t\t\t.done = nf_tables_dump_obj_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_OBJ_NAME] ||\n\t    !nla[NFTA_OBJ_TYPE])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask, 0);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tobj = nft_obj_lookup(net, table, nla[NFTA_OBJ_NAME], objtype, genmask);\n\tif (IS_ERR(obj)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);\n\t\treturn PTR_ERR(obj);\n\t}\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tif (NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)\n\t\treset = true;\n\n\tif (reset) {\n\t\tconst struct nftables_pernet *nft_net;\n\t\tchar *buf;\n\n\t\tnft_net = nft_pernet(net);\n\t\tbuf = kasprintf(GFP_ATOMIC, \"%s:%u\", table->name, nft_net->base_seq);\n\n\t\taudit_log_nfcfg(buf,\n\t\t\t\tfamily,\n\t\t\t\tobj->handle,\n\t\t\t\tAUDIT_NFT_OP_OBJ_RESET,\n\t\t\t\tGFP_ATOMIC);\n\t\tkfree(buf);\n\t}\n\n\terr = nf_tables_fill_obj_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t      info->nlh->nlmsg_seq, NFT_MSG_NEWOBJ, 0,\n\t\t\t\t      family, table, obj, reset);\n\tif (err < 0)\n\t\tgoto err_fill_obj_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_obj_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nft_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tif (obj->ops->destroy)\n\t\tobj->ops->destroy(ctx, obj);\n\n\tmodule_put(obj->ops->type->owner);\n\tkfree(obj->key.name);\n\tkfree(obj->udata);\n\tkfree(obj);\n}\n\nstatic int nf_tables_delobj(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_object *obj;\n\tstruct nft_ctx ctx;\n\tu32 objtype;\n\n\tif (!nla[NFTA_OBJ_TYPE] ||\n\t    (!nla[NFTA_OBJ_NAME] && !nla[NFTA_OBJ_HANDLE]))\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tobjtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));\n\tif (nla[NFTA_OBJ_HANDLE]) {\n\t\tattr = nla[NFTA_OBJ_HANDLE];\n\t\tobj = nft_obj_lookup_byhandle(table, attr, objtype, genmask);\n\t} else {\n\t\tattr = nla[NFTA_OBJ_NAME];\n\t\tobj = nft_obj_lookup(net, table, attr, objtype, genmask);\n\t}\n\n\tif (IS_ERR(obj)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(obj);\n\t}\n\tif (obj->use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\treturn nft_delobj(&ctx, obj);\n}\n\nvoid nft_obj_notify(struct net *net, const struct nft_table *table,\n\t\t    struct nft_object *obj, u32 portid, u32 seq, int event,\n\t\t    u16 flags, int family, int report, gfp_t gfp)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct sk_buff *skb;\n\tint err;\n\tchar *buf = kasprintf(gfp, \"%s:%u\",\n\t\t\t      table->name, nft_net->base_seq);\n\n\taudit_log_nfcfg(buf,\n\t\t\tfamily,\n\t\t\tobj->handle,\n\t\t\tevent == NFT_MSG_NEWOBJ ?\n\t\t\t\t AUDIT_NFT_OP_OBJ_REGISTER :\n\t\t\t\t AUDIT_NFT_OP_OBJ_UNREGISTER,\n\t\t\tgfp);\n\tkfree(buf);\n\n\tif (!report &&\n\t    !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\terr = nf_tables_fill_obj_info(skb, net, portid, seq, event,\n\t\t\t\t      flags & (NLM_F_CREATE | NLM_F_EXCL),\n\t\t\t\t      family, table, obj, false);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\nEXPORT_SYMBOL_GPL(nft_obj_notify);\n\nstatic void nf_tables_obj_notify(const struct nft_ctx *ctx,\n\t\t\t\t struct nft_object *obj, int event)\n{\n\tnft_obj_notify(ctx->net, ctx->table, obj, ctx->portid, ctx->seq, event,\n\t\t       ctx->flags, ctx->family, ctx->report, GFP_KERNEL);\n}\n\n/*\n * Flow tables\n */\nvoid nft_register_flowtable_type(struct nf_flowtable_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_add_tail_rcu(&type->list, &nf_tables_flowtables);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_register_flowtable_type);\n\nvoid nft_unregister_flowtable_type(struct nf_flowtable_type *type)\n{\n\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\tlist_del_rcu(&type->list);\n\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n}\nEXPORT_SYMBOL_GPL(nft_unregister_flowtable_type);\n\nstatic const struct nla_policy nft_flowtable_policy[NFTA_FLOWTABLE_MAX + 1] = {\n\t[NFTA_FLOWTABLE_TABLE]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_NAME_MAXLEN - 1 },\n\t[NFTA_FLOWTABLE_NAME]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = NFT_NAME_MAXLEN - 1 },\n\t[NFTA_FLOWTABLE_HOOK]\t\t= { .type = NLA_NESTED },\n\t[NFTA_FLOWTABLE_HANDLE]\t\t= { .type = NLA_U64 },\n\t[NFTA_FLOWTABLE_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\nstruct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla, u8 genmask)\n{\n\tstruct nft_flowtable *flowtable;\n\n\tlist_for_each_entry_rcu(flowtable, &table->flowtables, list) {\n\t\tif (!nla_strcmp(nla, flowtable->name) &&\n\t\t    nft_active_genmask(flowtable, genmask))\n\t\t\treturn flowtable;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\nEXPORT_SYMBOL_GPL(nft_flowtable_lookup);\n\nvoid nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_flowtable *flowtable,\n\t\t\t\t    enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tflowtable->use--;\n\t\tfallthrough;\n\tdefault:\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_tables_deactivate_flowtable);\n\nstatic struct nft_flowtable *\nnft_flowtable_lookup_byhandle(const struct nft_table *table,\n\t\t\t      const struct nlattr *nla, u8 genmask)\n{\n       struct nft_flowtable *flowtable;\n\n       list_for_each_entry(flowtable, &table->flowtables, list) {\n               if (be64_to_cpu(nla_get_be64(nla)) == flowtable->handle &&\n                   nft_active_genmask(flowtable, genmask))\n                       return flowtable;\n       }\n       return ERR_PTR(-ENOENT);\n}\n\nstruct nft_flowtable_hook {\n\tu32\t\t\tnum;\n\tint\t\t\tpriority;\n\tstruct list_head\tlist;\n};\n\nstatic const struct nla_policy nft_flowtable_hook_policy[NFTA_FLOWTABLE_HOOK_MAX + 1] = {\n\t[NFTA_FLOWTABLE_HOOK_NUM]\t= { .type = NLA_U32 },\n\t[NFTA_FLOWTABLE_HOOK_PRIORITY]\t= { .type = NLA_U32 },\n\t[NFTA_FLOWTABLE_HOOK_DEVS]\t= { .type = NLA_NESTED },\n};\n\nstatic int nft_flowtable_parse_hook(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nlattr *attr,\n\t\t\t\t    struct nft_flowtable_hook *flowtable_hook,\n\t\t\t\t    struct nft_flowtable *flowtable, bool add)\n{\n\tstruct nlattr *tb[NFTA_FLOWTABLE_HOOK_MAX + 1];\n\tstruct nft_hook *hook;\n\tint hooknum, priority;\n\tint err;\n\n\tINIT_LIST_HEAD(&flowtable_hook->list);\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_FLOWTABLE_HOOK_MAX, attr,\n\t\t\t\t\t  nft_flowtable_hook_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (add) {\n\t\tif (!tb[NFTA_FLOWTABLE_HOOK_NUM] ||\n\t\t    !tb[NFTA_FLOWTABLE_HOOK_PRIORITY])\n\t\t\treturn -EINVAL;\n\n\t\thooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));\n\t\tif (hooknum != NF_NETDEV_INGRESS)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tpriority = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_PRIORITY]));\n\n\t\tflowtable_hook->priority\t= priority;\n\t\tflowtable_hook->num\t\t= hooknum;\n\t} else {\n\t\tif (tb[NFTA_FLOWTABLE_HOOK_NUM]) {\n\t\t\thooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));\n\t\t\tif (hooknum != flowtable->hooknum)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (tb[NFTA_FLOWTABLE_HOOK_PRIORITY]) {\n\t\t\tpriority = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_PRIORITY]));\n\t\t\tif (priority != flowtable->data.priority)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tflowtable_hook->priority\t= flowtable->data.priority;\n\t\tflowtable_hook->num\t\t= flowtable->hooknum;\n\t}\n\n\tif (tb[NFTA_FLOWTABLE_HOOK_DEVS]) {\n\t\terr = nf_tables_parse_netdev_hooks(ctx->net,\n\t\t\t\t\t\t   tb[NFTA_FLOWTABLE_HOOK_DEVS],\n\t\t\t\t\t\t   &flowtable_hook->list);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tlist_for_each_entry(hook, &flowtable_hook->list, list) {\n\t\thook->ops.pf\t\t= NFPROTO_NETDEV;\n\t\thook->ops.hooknum\t= flowtable_hook->num;\n\t\thook->ops.priority\t= flowtable_hook->priority;\n\t\thook->ops.priv\t\t= &flowtable->data;\n\t\thook->ops.hook\t\t= flowtable->data.type->hook;\n\t}\n\n\treturn err;\n}\n\nstatic const struct nf_flowtable_type *__nft_flowtable_type_get(u8 family)\n{\n\tconst struct nf_flowtable_type *type;\n\n\tlist_for_each_entry(type, &nf_tables_flowtables, list) {\n\t\tif (family == type->family)\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n\nstatic const struct nf_flowtable_type *\nnft_flowtable_type_get(struct net *net, u8 family)\n{\n\tconst struct nf_flowtable_type *type;\n\n\ttype = __nft_flowtable_type_get(family);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n#ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nf-flowtable-%u\", family) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n\n/* Only called from error and netdev event paths. */\nstatic void nft_unregister_flowtable_hook(struct net *net,\n\t\t\t\t\t  struct nft_flowtable *flowtable,\n\t\t\t\t\t  struct nft_hook *hook)\n{\n\tnf_unregister_net_hook(net, &hook->ops);\n\tflowtable->data.type->setup(&flowtable->data, hook->ops.dev,\n\t\t\t\t    FLOW_BLOCK_UNBIND);\n}\n\nstatic void __nft_unregister_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t\t struct list_head *hook_list,\n\t\t\t\t\t         bool release_netdev)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t\tif (release_netdev) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree_rcu(hook, rcu);\n\t\t}\n\t}\n}\n\nstatic void nft_unregister_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t       struct list_head *hook_list)\n{\n\t__nft_unregister_flowtable_net_hooks(net, hook_list, false);\n}\n\nstatic int nft_register_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t    struct nft_table *table,\n\t\t\t\t\t    struct list_head *hook_list,\n\t\t\t\t\t    struct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook, *hook2, *next;\n\tstruct nft_flowtable *ft;\n\tint err, i = 0;\n\n\tlist_for_each_entry(hook, hook_list, list) {\n\t\tlist_for_each_entry(ft, &table->flowtables, list) {\n\t\t\tif (!nft_is_active_next(net, ft))\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(hook2, &ft->hook_list, list) {\n\t\t\t\tif (hook->ops.dev == hook2->ops.dev &&\n\t\t\t\t    hook->ops.pf == hook2->ops.pf) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tgoto err_unregister_net_hooks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\terr = flowtable->data.type->setup(&flowtable->data,\n\t\t\t\t\t\t  hook->ops.dev,\n\t\t\t\t\t\t  FLOW_BLOCK_BIND);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_net_hooks;\n\n\t\terr = nf_register_net_hook(net, &hook->ops);\n\t\tif (err < 0) {\n\t\t\tflowtable->data.type->setup(&flowtable->data,\n\t\t\t\t\t\t    hook->ops.dev,\n\t\t\t\t\t\t    FLOW_BLOCK_UNBIND);\n\t\t\tgoto err_unregister_net_hooks;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n\nerr_unregister_net_hooks:\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tif (i-- <= 0)\n\t\t\tbreak;\n\n\t\tnft_unregister_flowtable_hook(net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n\n\treturn err;\n}\n\nstatic void nft_flowtable_hooks_destroy(struct list_head *hook_list)\n{\n\tstruct nft_hook *hook, *next;\n\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n}\n\nstatic int nft_flowtable_update(struct nft_ctx *ctx, const struct nlmsghdr *nlh,\n\t\t\t\tstruct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tstruct nft_hook *hook, *next;\n\tstruct nft_trans *trans;\n\tbool unregister = false;\n\tu32 flags;\n\tint err;\n\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tlist_for_each_entry_safe(hook, next, &flowtable_hook.list, list) {\n\t\tif (nft_hook_list_find(&flowtable->hook_list, hook)) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree(hook);\n\t\t}\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_FLOWTABLE_FLAGS]));\n\t\tif (flags & ~NFT_FLOWTABLE_MASK) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_flowtable_update_hook;\n\t\t}\n\t\tif ((flowtable->data.flags & NFT_FLOWTABLE_HW_OFFLOAD) ^\n\t\t    (flags & NFT_FLOWTABLE_HW_OFFLOAD)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_flowtable_update_hook;\n\t\t}\n\t} else {\n\t\tflags = flowtable->data.flags;\n\t}\n\n\terr = nft_register_flowtable_net_hooks(ctx->net, ctx->table,\n\t\t\t\t\t       &flowtable_hook.list, flowtable);\n\tif (err < 0)\n\t\tgoto err_flowtable_update_hook;\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_NEWFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\tunregister = true;\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_update_hook;\n\t}\n\n\tnft_trans_flowtable_flags(trans) = flags;\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_hook.list, &nft_trans_flowtable_hooks(trans));\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_flowtable_update_hook:\n\tlist_for_each_entry_safe(hook, next, &flowtable_hook.list, list) {\n\t\tif (unregister)\n\t\t\tnft_unregister_flowtable_hook(ctx->net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\n\n\treturn err;\n\n}\n\nstatic int nf_tables_newflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst struct nf_flowtable_type *type;\n\tstruct nft_flowtable *flowtable;\n\tstruct nft_hook *hook, *next;\n\tstruct net *net = info->net;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tint err;\n\n\tif (!nla[NFTA_FLOWTABLE_TABLE] ||\n\t    !nla[NFTA_FLOWTABLE_NAME] ||\n\t    !nla[NFTA_FLOWTABLE_HOOK])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tflowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],\n\t\t\t\t\t genmask);\n\tif (IS_ERR(flowtable)) {\n\t\terr = PTR_ERR(flowtable);\n\t\tif (err != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nft_flowtable_update(&ctx, info->nlh, flowtable);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tflowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL_ACCOUNT);\n\tif (!flowtable)\n\t\treturn -ENOMEM;\n\n\tflowtable->table = table;\n\tflowtable->handle = nf_tables_alloc_handle(table);\n\tINIT_LIST_HEAD(&flowtable->hook_list);\n\n\tflowtable->name = nla_strdup(nla[NFTA_FLOWTABLE_NAME], GFP_KERNEL_ACCOUNT);\n\tif (!flowtable->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\ttype = nft_flowtable_type_get(net, family);\n\tif (IS_ERR(type)) {\n\t\terr = PTR_ERR(type);\n\t\tgoto err2;\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_FLAGS]) {\n\t\tflowtable->data.flags =\n\t\t\tntohl(nla_get_be32(nla[NFTA_FLOWTABLE_FLAGS]));\n\t\tif (flowtable->data.flags & ~NFT_FLOWTABLE_MASK) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\twrite_pnet(&flowtable->data.net, net);\n\tflowtable->data.type = type;\n\terr = type->init(&flowtable->data);\n\tif (err < 0)\n\t\tgoto err3;\n\n\terr = nft_flowtable_parse_hook(&ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, true);\n\tif (err < 0)\n\t\tgoto err4;\n\n\tlist_splice(&flowtable_hook.list, &flowtable->hook_list);\n\tflowtable->data.priority = flowtable_hook.priority;\n\tflowtable->hooknum = flowtable_hook.num;\n\n\terr = nft_register_flowtable_net_hooks(ctx.net, table,\n\t\t\t\t\t       &flowtable->hook_list,\n\t\t\t\t\t       flowtable);\n\tif (err < 0) {\n\t\tnft_flowtable_hooks_destroy(&flowtable->hook_list);\n\t\tgoto err4;\n\t}\n\n\terr = nft_trans_flowtable_add(&ctx, NFT_MSG_NEWFLOWTABLE, flowtable);\n\tif (err < 0)\n\t\tgoto err5;\n\n\tlist_add_tail_rcu(&flowtable->list, &table->flowtables);\n\ttable->use++;\n\n\treturn 0;\nerr5:\n\tlist_for_each_entry_safe(hook, next, &flowtable->hook_list, list) {\n\t\tnft_unregister_flowtable_hook(net, flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t}\nerr4:\n\tflowtable->data.type->free(&flowtable->data);\nerr3:\n\tmodule_put(type->owner);\nerr2:\n\tkfree(flowtable->name);\nerr1:\n\tkfree(flowtable);\n\treturn err;\n}\n\nstatic void nft_flowtable_hook_release(struct nft_flowtable_hook *flowtable_hook)\n{\n\tstruct nft_hook *this, *next;\n\n\tlist_for_each_entry_safe(this, next, &flowtable_hook->list, list) {\n\t\tlist_del(&this->list);\n\t\tkfree(this);\n\t}\n}\n\nstatic int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\n\treturn 0;\n\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\n\treturn err;\n}\n\nstatic int nf_tables_delflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\n\tif (!nla[NFTA_FLOWTABLE_TABLE] ||\n\t    (!nla[NFTA_FLOWTABLE_NAME] &&\n\t     !nla[NFTA_FLOWTABLE_HANDLE]))\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_FLOWTABLE_HANDLE]) {\n\t\tattr = nla[NFTA_FLOWTABLE_HANDLE];\n\t\tflowtable = nft_flowtable_lookup_byhandle(table, attr, genmask);\n\t} else {\n\t\tattr = nla[NFTA_FLOWTABLE_NAME];\n\t\tflowtable = nft_flowtable_lookup(table, attr, genmask);\n\t}\n\n\tif (IS_ERR(flowtable)) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn PTR_ERR(flowtable);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tif (nla[NFTA_FLOWTABLE_HOOK])\n\t\treturn nft_delflowtable_hook(&ctx, flowtable);\n\n\tif (flowtable->use > 0) {\n\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\treturn -EBUSY;\n\t}\n\n\treturn nft_delflowtable(&ctx, flowtable);\n}\n\nstatic int nf_tables_fill_flowtable_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t\t u32 portid, u32 seq, int event,\n\t\t\t\t\t u32 flags, int family,\n\t\t\t\t\t struct nft_flowtable *flowtable,\n\t\t\t\t\t struct list_head *hook_list)\n{\n\tstruct nlattr *nest, *nest_devs;\n\tstruct nft_hook *hook;\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_FLOWTABLE_TABLE, flowtable->table->name) ||\n\t    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_USE, htonl(flowtable->use)) ||\n\t    nla_put_be64(skb, NFTA_FLOWTABLE_HANDLE, cpu_to_be64(flowtable->handle),\n\t\t\t NFTA_FLOWTABLE_PAD) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_FLAGS, htonl(flowtable->data.flags)))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_FLOWTABLE_HOOK);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_NUM, htonl(flowtable->hooknum)) ||\n\t    nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_PRIORITY, htonl(flowtable->data.priority)))\n\t\tgoto nla_put_failure;\n\n\tnest_devs = nla_nest_start_noflag(skb, NFTA_FLOWTABLE_HOOK_DEVS);\n\tif (!nest_devs)\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry_rcu(hook, hook_list, list) {\n\t\tif (nla_put_string(skb, NFTA_DEVICE_NAME, hook->ops.dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest_devs);\n\tnla_nest_end(skb, nest);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}\n\nstruct nft_flowtable_filter {\n\tchar\t\t*table;\n};\n\nstatic int nf_tables_dump_flowtable(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nft_flowtable_filter *filter = cb->data;\n\tunsigned int idx = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tstruct nftables_pernet *nft_net;\n\tconst struct nft_table *table;\n\n\trcu_read_lock();\n\tnft_net = nft_pernet(net);\n\tcb->seq = READ_ONCE(nft_net->base_seq);\n\n\tlist_for_each_entry_rcu(table, &nft_net->tables, list) {\n\t\tif (family != NFPROTO_UNSPEC && family != table->family)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(flowtable, &table->flowtables, list) {\n\t\t\tif (!nft_is_active(net, flowtable))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (idx > s_idx)\n\t\t\t\tmemset(&cb->args[1], 0,\n\t\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\t\tif (filter && filter->table &&\n\t\t\t    strcmp(filter->table, table->name))\n\t\t\t\tgoto cont;\n\n\t\t\tif (nf_tables_fill_flowtable_info(skb, net, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t\t  cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t\t  NFT_MSG_NEWFLOWTABLE,\n\t\t\t\t\t\t\t  NLM_F_MULTI | NLM_F_APPEND,\n\t\t\t\t\t\t\t  table->family,\n\t\t\t\t\t\t\t  flowtable,\n\t\t\t\t\t\t\t  &flowtable->hook_list) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nf_tables_dump_flowtable_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nft_flowtable_filter *filter = NULL;\n\n\tif (nla[NFTA_FLOWTABLE_TABLE]) {\n\t\tfilter = kzalloc(sizeof(*filter), GFP_ATOMIC);\n\t\tif (!filter)\n\t\t\treturn -ENOMEM;\n\n\t\tfilter->table = nla_strdup(nla[NFTA_FLOWTABLE_TABLE],\n\t\t\t\t\t   GFP_ATOMIC);\n\t\tif (!filter->table) {\n\t\t\tkfree(filter);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tcb->data = filter;\n\treturn 0;\n}\n\nstatic int nf_tables_dump_flowtable_done(struct netlink_callback *cb)\n{\n\tstruct nft_flowtable_filter *filter = cb->data;\n\n\tif (!filter)\n\t\treturn 0;\n\n\tkfree(filter->table);\n\tkfree(filter);\n\n\treturn 0;\n}\n\n/* called with rcu_read_lock held */\nstatic int nf_tables_getflowtable(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const nla[])\n{\n\tu8 genmask = nft_genmask_cur(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flowtable *flowtable;\n\tconst struct nft_table *table;\n\tstruct net *net = info->net;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nf_tables_dump_flowtable_start,\n\t\t\t.dump = nf_tables_dump_flowtable,\n\t\t\t.done = nf_tables_dump_flowtable_done,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nft_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!nla[NFTA_FLOWTABLE_NAME])\n\t\treturn -EINVAL;\n\n\ttable = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,\n\t\t\t\t genmask, 0);\n\tif (IS_ERR(table))\n\t\treturn PTR_ERR(table);\n\n\tflowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],\n\t\t\t\t\t genmask);\n\tif (IS_ERR(flowtable))\n\t\treturn PTR_ERR(flowtable);\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_flowtable_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t\t    info->nlh->nlmsg_seq,\n\t\t\t\t\t    NFT_MSG_NEWFLOWTABLE, 0, family,\n\t\t\t\t\t    flowtable, &flowtable->hook_list);\n\tif (err < 0)\n\t\tgoto err_fill_flowtable_info;\n\n\treturn nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\nerr_fill_flowtable_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic void nf_tables_flowtable_notify(struct nft_ctx *ctx,\n\t\t\t\t       struct nft_flowtable *flowtable,\n\t\t\t\t       struct list_head *hook_list,\n\t\t\t\t       int event)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct sk_buff *skb;\n\tu16 flags = 0;\n\tint err;\n\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))\n\t\tflags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);\n\n\terr = nf_tables_fill_flowtable_info(skb, ctx->net, ctx->portid,\n\t\t\t\t\t    ctx->seq, event, flags,\n\t\t\t\t\t    ctx->family, flowtable, hook_list);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\n\tnft_notify_enqueue(skb, ctx->report, &nft_net->notify_list);\n\treturn;\nerr:\n\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);\n}\n\nstatic void nf_tables_flowtable_destroy(struct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook, *next;\n\n\tflowtable->data.type->free(&flowtable->data);\n\tlist_for_each_entry_safe(hook, next, &flowtable->hook_list, list) {\n\t\tflowtable->data.type->setup(&flowtable->data, hook->ops.dev,\n\t\t\t\t\t    FLOW_BLOCK_UNBIND);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree(hook);\n\t}\n\tkfree(flowtable->name);\n\tmodule_put(flowtable->data.type->owner);\n\tkfree(flowtable);\n}\n\nstatic int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t   u32 portid, u32 seq)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nlmsghdr *nlh;\n\tchar buf[TASK_COMM_LEN];\n\tint event = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_NEWGEN);\n\n\tnlh = nfnl_msg_put(skb, portid, seq, event, 0, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, nft_base_seq(net));\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_GEN_ID, htonl(nft_net->base_seq)) ||\n\t    nla_put_be32(skb, NFTA_GEN_PROC_PID, htonl(task_pid_nr(current))) ||\n\t    nla_put_string(skb, NFTA_GEN_PROC_NAME, get_task_comm(buf, current)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void nft_flowtable_event(unsigned long event, struct net_device *dev,\n\t\t\t\tstruct nft_flowtable *flowtable)\n{\n\tstruct nft_hook *hook;\n\n\tlist_for_each_entry(hook, &flowtable->hook_list, list) {\n\t\tif (hook->ops.dev != dev)\n\t\t\tcontinue;\n\n\t\t/* flow_offload_netdev_event() cleans up entries for us. */\n\t\tnft_unregister_flowtable_hook(dev_net(dev), flowtable, hook);\n\t\tlist_del_rcu(&hook->list);\n\t\tkfree_rcu(hook, rcu);\n\t\tbreak;\n\t}\n}\n\nstatic int nf_tables_flowtable_event(struct notifier_block *this,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct nft_flowtable *flowtable;\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\tstruct net *net;\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn 0;\n\n\tnet = dev_net(dev);\n\tnft_net = nft_pernet(net);\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tlist_for_each_entry(flowtable, &table->flowtables, list) {\n\t\t\tnft_flowtable_event(event, dev, flowtable);\n\t\t}\n\t}\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nf_tables_flowtable_notifier = {\n\t.notifier_call\t= nf_tables_flowtable_event,\n};\n\nstatic void nf_tables_gen_notify(struct net *net, struct sk_buff *skb,\n\t\t\t\t int event)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (!nlmsg_report(nlh) &&\n\t    !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\n\t\treturn;\n\n\tskb2 = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb2 == NULL)\n\t\tgoto err;\n\n\terr = nf_tables_fill_gen_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t      nlh->nlmsg_seq);\n\tif (err < 0) {\n\t\tkfree_skb(skb2);\n\t\tgoto err;\n\t}\n\n\tnfnetlink_send(skb2, net, NETLINK_CB(skb).portid, NFNLGRP_NFTABLES,\n\t\t       nlmsg_report(nlh), GFP_KERNEL);\n\treturn;\nerr:\n\tnfnetlink_set_err(net, NETLINK_CB(skb).portid, NFNLGRP_NFTABLES,\n\t\t\t  -ENOBUFS);\n}\n\nstatic int nf_tables_getgen(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_gen_info(skb2, info->net, NETLINK_CB(skb).portid,\n\t\t\t\t      info->nlh->nlmsg_seq);\n\tif (err < 0)\n\t\tgoto err_fill_gen_info;\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nerr_fill_gen_info:\n\tkfree_skb(skb2);\n\treturn err;\n}\n\nstatic const struct nfnl_callback nf_tables_cb[NFT_MSG_MAX] = {\n\t[NFT_MSG_NEWTABLE] = {\n\t\t.call\t\t= nf_tables_newtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_GETTABLE] = {\n\t\t.call\t\t= nf_tables_gettable,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_DELTABLE] = {\n\t\t.call\t\t= nf_tables_deltable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_TABLE_MAX,\n\t\t.policy\t\t= nft_table_policy,\n\t},\n\t[NFT_MSG_NEWCHAIN] = {\n\t\t.call\t\t= nf_tables_newchain,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_GETCHAIN] = {\n\t\t.call\t\t= nf_tables_getchain,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_DELCHAIN] = {\n\t\t.call\t\t= nf_tables_delchain,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_CHAIN_MAX,\n\t\t.policy\t\t= nft_chain_policy,\n\t},\n\t[NFT_MSG_NEWRULE] = {\n\t\t.call\t\t= nf_tables_newrule,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_GETRULE] = {\n\t\t.call\t\t= nf_tables_getrule,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_DELRULE] = {\n\t\t.call\t\t= nf_tables_delrule,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_RULE_MAX,\n\t\t.policy\t\t= nft_rule_policy,\n\t},\n\t[NFT_MSG_NEWSET] = {\n\t\t.call\t\t= nf_tables_newset,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_GETSET] = {\n\t\t.call\t\t= nf_tables_getset,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_DELSET] = {\n\t\t.call\t\t= nf_tables_delset,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_MAX,\n\t\t.policy\t\t= nft_set_policy,\n\t},\n\t[NFT_MSG_NEWSETELEM] = {\n\t\t.call\t\t= nf_tables_newsetelem,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_GETSETELEM] = {\n\t\t.call\t\t= nf_tables_getsetelem,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_DELSETELEM] = {\n\t\t.call\t\t= nf_tables_delsetelem,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\n\t\t.policy\t\t= nft_set_elem_list_policy,\n\t},\n\t[NFT_MSG_GETGEN] = {\n\t\t.call\t\t= nf_tables_getgen,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t},\n\t[NFT_MSG_NEWOBJ] = {\n\t\t.call\t\t= nf_tables_newobj,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_GETOBJ] = {\n\t\t.call\t\t= nf_tables_getobj,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_DELOBJ] = {\n\t\t.call\t\t= nf_tables_delobj,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_GETOBJ_RESET] = {\n\t\t.call\t\t= nf_tables_getobj,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_OBJ_MAX,\n\t\t.policy\t\t= nft_obj_policy,\n\t},\n\t[NFT_MSG_NEWFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_newflowtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n\t[NFT_MSG_GETFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_getflowtable,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n\t[NFT_MSG_DELFLOWTABLE] = {\n\t\t.call\t\t= nf_tables_delflowtable,\n\t\t.type\t\t= NFNL_CB_BATCH,\n\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\n\t\t.policy\t\t= nft_flowtable_policy,\n\t},\n};\n\nstatic int nf_tables_validate(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table;\n\n\tswitch (nft_net->validate_state) {\n\tcase NFT_VALIDATE_SKIP:\n\t\tbreak;\n\tcase NFT_VALIDATE_NEED:\n\t\tnft_validate_state_update(net, NFT_VALIDATE_DO);\n\t\tfallthrough;\n\tcase NFT_VALIDATE_DO:\n\t\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\t\tif (nft_table_validate(net, table) < 0)\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* a drop policy has to be deferred until all rules have been activated,\n * otherwise a large ruleset that contains a drop-policy base chain will\n * cause all packets to get dropped until the full transaction has been\n * processed.\n *\n * We defer the drop policy until the transaction has been finalized.\n */\nstatic void nft_chain_commit_drop_policy(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_trans_chain_policy(trans) != NF_DROP)\n\t\treturn;\n\n\tif (!nft_is_base_chain(trans->ctx.chain))\n\t\treturn;\n\n\tbasechain = nft_base_chain(trans->ctx.chain);\n\tbasechain->policy = NF_DROP;\n}\n\nstatic void nft_chain_commit_update(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_trans_chain_name(trans)) {\n\t\trhltable_remove(&trans->ctx.table->chains_ht,\n\t\t\t\t&trans->ctx.chain->rhlhead,\n\t\t\t\tnft_chain_ht_params);\n\t\tswap(trans->ctx.chain->name, nft_trans_chain_name(trans));\n\t\trhltable_insert_key(&trans->ctx.table->chains_ht,\n\t\t\t\t    trans->ctx.chain->name,\n\t\t\t\t    &trans->ctx.chain->rhlhead,\n\t\t\t\t    nft_chain_ht_params);\n\t}\n\n\tif (!nft_is_base_chain(trans->ctx.chain))\n\t\treturn;\n\n\tnft_chain_stats_replace(trans);\n\n\tbasechain = nft_base_chain(trans->ctx.chain);\n\n\tswitch (nft_trans_chain_policy(trans)) {\n\tcase NF_DROP:\n\tcase NF_ACCEPT:\n\t\tbasechain->policy = nft_trans_chain_policy(trans);\n\t\tbreak;\n\t}\n}\n\nstatic void nft_obj_commit_update(struct nft_trans *trans)\n{\n\tstruct nft_object *newobj;\n\tstruct nft_object *obj;\n\n\tobj = nft_trans_obj(trans);\n\tnewobj = nft_trans_obj_newobj(trans);\n\n\tif (obj->ops->update)\n\t\tobj->ops->update(obj, newobj);\n\n\tnft_obj_destroy(&trans->ctx, newobj);\n}\n\nstatic void nft_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWCHAIN:\n\t\tfree_percpu(nft_trans_chain_stats(trans));\n\t\tkfree(nft_trans_chain_name(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(&trans->ctx, nft_trans_set(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSETELEM:\n\t\tnf_tables_set_elem_destroy(&trans->ctx,\n\t\t\t\t\t   nft_trans_elem_set(trans),\n\t\t\t\t\t   nft_trans_elem(trans).priv);\n\t\tbreak;\n\tcase NFT_MSG_DELOBJ:\n\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELFLOWTABLE:\n\t\tif (nft_trans_flowtable_update(trans))\n\t\t\tnft_flowtable_hooks_destroy(&nft_trans_flowtable_hooks(trans));\n\t\telse\n\t\t\tnf_tables_flowtable_destroy(nft_trans_flowtable(trans));\n\t\tbreak;\n\t}\n\n\tif (trans->put_net)\n\t\tput_net(trans->ctx.net);\n\n\tkfree(trans);\n}\n\nstatic void nf_tables_trans_destroy_work(struct work_struct *w)\n{\n\tstruct nft_trans *trans, *next;\n\tLIST_HEAD(head);\n\n\tspin_lock(&nf_tables_destroy_list_lock);\n\tlist_splice_init(&nf_tables_destroy_list, &head);\n\tspin_unlock(&nf_tables_destroy_list_lock);\n\n\tif (list_empty(&head))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(trans, next, &head, list) {\n\t\tlist_del(&trans->list);\n\t\tnft_commit_release(trans);\n\t}\n}\n\nvoid nf_tables_trans_destroy_flush_work(void)\n{\n\tflush_work(&trans_destroy_work);\n}\nEXPORT_SYMBOL_GPL(nf_tables_trans_destroy_flush_work);\n\nstatic bool nft_expr_reduce(struct nft_regs_track *track,\n\t\t\t    const struct nft_expr *expr)\n{\n\treturn false;\n}\n\nstatic int nf_tables_commit_chain_prepare(struct net *net, struct nft_chain *chain)\n{\n\tconst struct nft_expr *expr, *last;\n\tstruct nft_regs_track track = {};\n\tunsigned int size, data_size;\n\tvoid *data, *data_boundary;\n\tstruct nft_rule_dp *prule;\n\tstruct nft_rule *rule;\n\n\t/* already handled or inactive chain? */\n\tif (chain->blob_next || !nft_is_active_next(net, chain))\n\t\treturn 0;\n\n\tdata_size = 0;\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (nft_is_active_next(net, rule)) {\n\t\t\tdata_size += sizeof(*prule) + rule->dlen;\n\t\t\tif (data_size > INT_MAX)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tdata_size += offsetof(struct nft_rule_dp, data);\t/* last rule */\n\n\tchain->blob_next = nf_tables_chain_alloc_rules(data_size);\n\tif (!chain->blob_next)\n\t\treturn -ENOMEM;\n\n\tdata = (void *)chain->blob_next->data;\n\tdata_boundary = data + data_size;\n\tsize = 0;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tif (!nft_is_active_next(net, rule))\n\t\t\tcontinue;\n\n\t\tprule = (struct nft_rule_dp *)data;\n\t\tdata += offsetof(struct nft_rule_dp, data);\n\t\tif (WARN_ON_ONCE(data > data_boundary))\n\t\t\treturn -ENOMEM;\n\n\t\tsize = 0;\n\t\ttrack.last = nft_expr_last(rule);\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\ttrack.cur = expr;\n\n\t\t\tif (nft_expr_reduce(&track, expr)) {\n\t\t\t\texpr = track.cur;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON_ONCE(data + expr->ops->size > data_boundary))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(data + size, expr, expr->ops->size);\n\t\t\tsize += expr->ops->size;\n\t\t}\n\t\tif (WARN_ON_ONCE(size >= 1 << 12))\n\t\t\treturn -ENOMEM;\n\n\t\tprule->handle = rule->handle;\n\t\tprule->dlen = size;\n\t\tprule->is_last = 0;\n\n\t\tdata += size;\n\t\tsize = 0;\n\t\tchain->blob_next->size += (unsigned long)(data - (void *)prule);\n\t}\n\n\tprule = (struct nft_rule_dp *)data;\n\tdata += offsetof(struct nft_rule_dp, data);\n\tif (WARN_ON_ONCE(data > data_boundary))\n\t\treturn -ENOMEM;\n\n\tnft_last_rule(chain->blob_next, prule);\n\n\treturn 0;\n}\n\nstatic void nf_tables_commit_chain_prepare_cancel(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tstruct nft_chain *chain = trans->ctx.chain;\n\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE ||\n\t\t    trans->msg_type == NFT_MSG_DELRULE) {\n\t\t\tkvfree(chain->blob_next);\n\t\t\tchain->blob_next = NULL;\n\t\t}\n\t}\n}\n\nstatic void __nf_tables_commit_chain_free_rules_old(struct rcu_head *h)\n{\n\tstruct nft_rules_old *o = container_of(h, struct nft_rules_old, h);\n\n\tkvfree(o->blob);\n}\n\nstatic void nf_tables_commit_chain_free_rules_old(struct nft_rule_blob *blob)\n{\n\tstruct nft_rules_old *old;\n\n\t/* rcu_head is after end marker */\n\told = (void *)blob + sizeof(*blob) + blob->size;\n\told->blob = blob;\n\n\tcall_rcu(&old->h, __nf_tables_commit_chain_free_rules_old);\n}\n\nstatic void nf_tables_commit_chain(struct net *net, struct nft_chain *chain)\n{\n\tstruct nft_rule_blob *g0, *g1;\n\tbool next_genbit;\n\n\tnext_genbit = nft_gencursor_next(net);\n\n\tg0 = rcu_dereference_protected(chain->blob_gen_0,\n\t\t\t\t       lockdep_commit_lock_is_held(net));\n\tg1 = rcu_dereference_protected(chain->blob_gen_1,\n\t\t\t\t       lockdep_commit_lock_is_held(net));\n\n\t/* No changes to this chain? */\n\tif (chain->blob_next == NULL) {\n\t\t/* chain had no change in last or next generation */\n\t\tif (g0 == g1)\n\t\t\treturn;\n\t\t/*\n\t\t * chain had no change in this generation; make sure next\n\t\t * one uses same rules as current generation.\n\t\t */\n\t\tif (next_genbit) {\n\t\t\trcu_assign_pointer(chain->blob_gen_1, g0);\n\t\t\tnf_tables_commit_chain_free_rules_old(g1);\n\t\t} else {\n\t\t\trcu_assign_pointer(chain->blob_gen_0, g1);\n\t\t\tnf_tables_commit_chain_free_rules_old(g0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (next_genbit)\n\t\trcu_assign_pointer(chain->blob_gen_1, chain->blob_next);\n\telse\n\t\trcu_assign_pointer(chain->blob_gen_0, chain->blob_next);\n\n\tchain->blob_next = NULL;\n\n\tif (g0 == g1)\n\t\treturn;\n\n\tif (next_genbit)\n\t\tnf_tables_commit_chain_free_rules_old(g1);\n\telse\n\t\tnf_tables_commit_chain_free_rules_old(g0);\n}\n\nstatic void nft_obj_del(struct nft_object *obj)\n{\n\trhltable_remove(&nft_objname_ht, &obj->rhlhead, nft_objname_ht_params);\n\tlist_del_rcu(&obj->list);\n}\n\nvoid nft_chain_del(struct nft_chain *chain)\n{\n\tstruct nft_table *table = chain->table;\n\n\tWARN_ON_ONCE(rhltable_remove(&table->chains_ht, &chain->rhlhead,\n\t\t\t\t     nft_chain_ht_params));\n\tlist_del_rcu(&chain->list);\n}\n\nstatic void nf_tables_module_autoload_cleanup(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_module_request *req, *next;\n\n\tWARN_ON_ONCE(!list_empty(&nft_net->commit_list));\n\tlist_for_each_entry_safe(req, next, &nft_net->module_list, list) {\n\t\tWARN_ON_ONCE(!req->done);\n\t\tlist_del(&req->list);\n\t\tkfree(req);\n\t}\n}\n\nstatic void nf_tables_commit_release(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans;\n\n\t/* all side effects have to be made visible.\n\t * For example, if a chain named 'foo' has been deleted, a\n\t * new transaction must not find it anymore.\n\t *\n\t * Memory reclaim happens asynchronously from work queue\n\t * to prevent expensive synchronize_rcu() in commit phase.\n\t */\n\tif (list_empty(&nft_net->commit_list)) {\n\t\tnf_tables_module_autoload_cleanup(net);\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\t\treturn;\n\t}\n\n\ttrans = list_last_entry(&nft_net->commit_list,\n\t\t\t\tstruct nft_trans, list);\n\tget_net(trans->ctx.net);\n\tWARN_ON_ONCE(trans->put_net);\n\n\ttrans->put_net = true;\n\tspin_lock(&nf_tables_destroy_list_lock);\n\tlist_splice_tail_init(&nft_net->commit_list, &nf_tables_destroy_list);\n\tspin_unlock(&nf_tables_destroy_list_lock);\n\n\tnf_tables_module_autoload_cleanup(net);\n\tschedule_work(&trans_destroy_work);\n\n\tmutex_unlock(&nft_net->commit_mutex);\n}\n\nstatic void nft_commit_notify(struct net *net, u32 portid)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct sk_buff *batch_skb = NULL, *nskb, *skb;\n\tunsigned char *data;\n\tint len;\n\n\tlist_for_each_entry_safe(skb, nskb, &nft_net->notify_list, list) {\n\t\tif (!batch_skb) {\nnew_batch:\n\t\t\tbatch_skb = skb;\n\t\t\tlen = NLMSG_GOODSIZE - skb->len;\n\t\t\tlist_del(&skb->list);\n\t\t\tcontinue;\n\t\t}\n\t\tlen -= skb->len;\n\t\tif (len > 0 && NFT_CB(skb).report == NFT_CB(batch_skb).report) {\n\t\t\tdata = skb_put(batch_skb, skb->len);\n\t\t\tmemcpy(data, skb->data, skb->len);\n\t\t\tlist_del(&skb->list);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tnfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,\n\t\t\t       NFT_CB(batch_skb).report, GFP_KERNEL);\n\t\tgoto new_batch;\n\t}\n\n\tif (batch_skb) {\n\t\tnfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,\n\t\t\t       NFT_CB(batch_skb).report, GFP_KERNEL);\n\t}\n\n\tWARN_ON_ONCE(!list_empty(&nft_net->notify_list));\n}\n\nstatic int nf_tables_commit_audit_alloc(struct list_head *adl,\n\t\t\t\t\tstruct nft_table *table)\n{\n\tstruct nft_audit_data *adp;\n\n\tlist_for_each_entry(adp, adl, list) {\n\t\tif (adp->table == table)\n\t\t\treturn 0;\n\t}\n\tadp = kzalloc(sizeof(*adp), GFP_KERNEL);\n\tif (!adp)\n\t\treturn -ENOMEM;\n\tadp->table = table;\n\tlist_add(&adp->list, adl);\n\treturn 0;\n}\n\nstatic void nf_tables_commit_audit_free(struct list_head *adl)\n{\n\tstruct nft_audit_data *adp, *adn;\n\n\tlist_for_each_entry_safe(adp, adn, adl, list) {\n\t\tlist_del(&adp->list);\n\t\tkfree(adp);\n\t}\n}\n\nstatic void nf_tables_commit_audit_collect(struct list_head *adl,\n\t\t\t\t\t   struct nft_table *table, u32 op)\n{\n\tstruct nft_audit_data *adp;\n\n\tlist_for_each_entry(adp, adl, list) {\n\t\tif (adp->table == table)\n\t\t\tgoto found;\n\t}\n\tWARN_ONCE(1, \"table=%s not expected in commit list\", table->name);\n\treturn;\nfound:\n\tadp->entries++;\n\tif (!adp->op || adp->op > op)\n\t\tadp->op = op;\n}\n\n#define AUNFTABLENAMELEN (NFT_TABLE_MAXNAMELEN + 22)\n\nstatic void nf_tables_commit_audit_log(struct list_head *adl, u32 generation)\n{\n\tstruct nft_audit_data *adp, *adn;\n\tchar aubuf[AUNFTABLENAMELEN];\n\n\tlist_for_each_entry_safe(adp, adn, adl, list) {\n\t\tsnprintf(aubuf, AUNFTABLENAMELEN, \"%s:%u\", adp->table->name,\n\t\t\t generation);\n\t\taudit_log_nfcfg(aubuf, adp->table->family, adp->entries,\n\t\t\t\tnft2audit_op[adp->op], GFP_KERNEL);\n\t\tlist_del(&adp->list);\n\t\tkfree(adp);\n\t}\n}\n\nstatic int nf_tables_commit(struct net *net, struct sk_buff *skb)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\tstruct nft_trans_elem *te;\n\tstruct nft_chain *chain;\n\tstruct nft_table *table;\n\tunsigned int base_seq;\n\tLIST_HEAD(adl);\n\tint err;\n\n\tif (list_empty(&nft_net->commit_list)) {\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\t\treturn 0;\n\t}\n\n\t/* 0. Validate ruleset, otherwise roll back for error reporting. */\n\tif (nf_tables_validate(net) < 0)\n\t\treturn -EAGAIN;\n\n\terr = nft_flow_rule_offload_commit(net);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* 1.  Allocate space for next generation rules_gen_X[] */\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tint ret;\n\n\t\tret = nf_tables_commit_audit_alloc(&adl, trans->ctx.table);\n\t\tif (ret) {\n\t\t\tnf_tables_commit_chain_prepare_cancel(net);\n\t\t\tnf_tables_commit_audit_free(&adl);\n\t\t\treturn ret;\n\t\t}\n\t\tif (trans->msg_type == NFT_MSG_NEWRULE ||\n\t\t    trans->msg_type == NFT_MSG_DELRULE) {\n\t\t\tchain = trans->ctx.chain;\n\n\t\t\tret = nf_tables_commit_chain_prepare(net, chain);\n\t\t\tif (ret < 0) {\n\t\t\t\tnf_tables_commit_chain_prepare_cancel(net);\n\t\t\t\tnf_tables_commit_audit_free(&adl);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* step 2.  Make rules_gen_X visible to packet path */\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tlist_for_each_entry(chain, &table->chains, list)\n\t\t\tnf_tables_commit_chain(net, chain);\n\t}\n\n\t/*\n\t * Bump generation counter, invalidate any dump in progress.\n\t * Cannot fail after this point.\n\t */\n\tbase_seq = READ_ONCE(nft_net->base_seq);\n\twhile (++base_seq == 0)\n\t\t;\n\n\tWRITE_ONCE(nft_net->base_seq, base_seq);\n\n\t/* step 3. Start new generation, rules_gen_X now in use. */\n\tnet->nft.gencursor = nft_gencursor_next(net);\n\n\tlist_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {\n\t\tnf_tables_commit_audit_collect(&adl, trans->ctx.table,\n\t\t\t\t\t       trans->msg_type);\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWTABLE:\n\t\t\tif (nft_trans_table_update(trans)) {\n\t\t\t\tif (!(trans->ctx.table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trans->ctx.table->flags & NFT_TABLE_F_DORMANT)\n\t\t\t\t\tnf_tables_table_disable(net, trans->ctx.table);\n\n\t\t\t\ttrans->ctx.table->flags &= ~__NFT_TABLE_F_UPDATE;\n\t\t\t} else {\n\t\t\t\tnft_clear(net, trans->ctx.table);\n\t\t\t}\n\t\t\tnf_tables_table_notify(&trans->ctx, NFT_MSG_NEWTABLE);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELTABLE:\n\t\t\tlist_del_rcu(&trans->ctx.table->list);\n\t\t\tnf_tables_table_notify(&trans->ctx, NFT_MSG_DELTABLE);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (nft_trans_chain_update(trans)) {\n\t\t\t\tnft_chain_commit_update(trans);\n\t\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN);\n\t\t\t\t/* trans destroyed after rcu grace period */\n\t\t\t} else {\n\t\t\t\tnft_chain_commit_drop_policy(trans);\n\t\t\t\tnft_clear(net, trans->ctx.chain);\n\t\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN);\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\tnft_chain_del(trans->ctx.chain);\n\t\t\tnf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN);\n\t\t\tnf_tables_unregister_hook(trans->ctx.net,\n\t\t\t\t\t\t  trans->ctx.table,\n\t\t\t\t\t\t  trans->ctx.chain);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\tnft_clear(trans->ctx.net, nft_trans_rule(trans));\n\t\t\tnf_tables_rule_notify(&trans->ctx,\n\t\t\t\t\t      nft_trans_rule(trans),\n\t\t\t\t\t      NFT_MSG_NEWRULE);\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\tlist_del_rcu(&nft_trans_rule(trans)->list);\n\t\t\tnf_tables_rule_notify(&trans->ctx,\n\t\t\t\t\t      nft_trans_rule(trans),\n\t\t\t\t\t      NFT_MSG_DELRULE);\n\t\t\tnft_rule_expr_deactivate(&trans->ctx,\n\t\t\t\t\t\t nft_trans_rule(trans),\n\t\t\t\t\t\t NFT_TRANS_COMMIT);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSET:\n\t\t\tnft_clear(net, nft_trans_set(trans));\n\t\t\t/* This avoids hitting -EBUSY when deleting the table\n\t\t\t * from the transaction.\n\t\t\t */\n\t\t\tif (nft_set_is_anonymous(nft_trans_set(trans)) &&\n\t\t\t    !list_empty(&nft_trans_set(trans)->bindings))\n\t\t\t\ttrans->ctx.table->use--;\n\n\t\t\tnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\n\t\t\t\t\t     NFT_MSG_NEWSET, GFP_KERNEL);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSET:\n\t\t\tlist_del_rcu(&nft_trans_set(trans)->list);\n\t\t\tnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\n\t\t\t\t\t     NFT_MSG_DELSET, GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnft_setelem_activate(net, te->set, &te->elem);\n\t\t\tnf_tables_setelem_notify(&trans->ctx, te->set,\n\t\t\t\t\t\t &te->elem,\n\t\t\t\t\t\t NFT_MSG_NEWSETELEM);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnf_tables_setelem_notify(&trans->ctx, te->set,\n\t\t\t\t\t\t &te->elem,\n\t\t\t\t\t\t NFT_MSG_DELSETELEM);\n\t\t\tnft_setelem_remove(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem)) {\n\t\t\t\tatomic_dec(&te->set->nelems);\n\t\t\t\tte->set->ndeact--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWOBJ:\n\t\t\tif (nft_trans_obj_update(trans)) {\n\t\t\t\tnft_obj_commit_update(trans);\n\t\t\t\tnf_tables_obj_notify(&trans->ctx,\n\t\t\t\t\t\t     nft_trans_obj(trans),\n\t\t\t\t\t\t     NFT_MSG_NEWOBJ);\n\t\t\t} else {\n\t\t\t\tnft_clear(net, nft_trans_obj(trans));\n\t\t\t\tnf_tables_obj_notify(&trans->ctx,\n\t\t\t\t\t\t     nft_trans_obj(trans),\n\t\t\t\t\t\t     NFT_MSG_NEWOBJ);\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELOBJ:\n\t\t\tnft_obj_del(nft_trans_obj(trans));\n\t\t\tnf_tables_obj_notify(&trans->ctx, nft_trans_obj(trans),\n\t\t\t\t\t     NFT_MSG_DELOBJ);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnft_trans_flowtable(trans)->data.flags =\n\t\t\t\t\tnft_trans_flowtable_flags(trans);\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t\t\t   NFT_MSG_NEWFLOWTABLE);\n\t\t\t\tlist_splice(&nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t    &nft_trans_flowtable(trans)->hook_list);\n\t\t\t} else {\n\t\t\t\tnft_clear(net, nft_trans_flowtable(trans));\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable(trans)->hook_list,\n\t\t\t\t\t\t\t   NFT_MSG_NEWFLOWTABLE);\n\t\t\t}\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t\t\t   NFT_MSG_DELFLOWTABLE);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t\t\t   &nft_trans_flowtable_hooks(trans));\n\t\t\t} else {\n\t\t\t\tlist_del_rcu(&nft_trans_flowtable(trans)->list);\n\t\t\t\tnf_tables_flowtable_notify(&trans->ctx,\n\t\t\t\t\t\t\t   nft_trans_flowtable(trans),\n\t\t\t\t\t\t\t   &nft_trans_flowtable(trans)->hook_list,\n\t\t\t\t\t\t\t   NFT_MSG_DELFLOWTABLE);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable(trans)->hook_list);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnft_commit_notify(net, NETLINK_CB(skb).portid);\n\tnf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);\n\tnf_tables_commit_audit_log(&adl, nft_net->base_seq);\n\tnf_tables_commit_release(net);\n\n\treturn 0;\n}\n\nstatic void nf_tables_module_autoload(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_module_request *req, *next;\n\tLIST_HEAD(module_list);\n\n\tlist_splice_init(&nft_net->module_list, &module_list);\n\tmutex_unlock(&nft_net->commit_mutex);\n\tlist_for_each_entry_safe(req, next, &module_list, list) {\n\t\trequest_module(\"%s\", req->module);\n\t\treq->done = true;\n\t}\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_splice(&module_list, &nft_net->module_list);\n}\n\nstatic void nf_tables_abort_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_NEWTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWCHAIN:\n\t\tnf_tables_chain_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_NEWRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWSET:\n\t\tnft_set_destroy(&trans->ctx, nft_trans_set(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWSETELEM:\n\t\tnft_set_elem_destroy(nft_trans_elem_set(trans),\n\t\t\t\t     nft_trans_elem(trans).priv, true);\n\t\tbreak;\n\tcase NFT_MSG_NEWOBJ:\n\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj(trans));\n\t\tbreak;\n\tcase NFT_MSG_NEWFLOWTABLE:\n\t\tif (nft_trans_flowtable_update(trans))\n\t\t\tnft_flowtable_hooks_destroy(&nft_trans_flowtable_hooks(trans));\n\t\telse\n\t\t\tnf_tables_flowtable_destroy(nft_trans_flowtable(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}\n\nstatic int __nf_tables_abort(struct net *net, enum nfnl_abort_action action)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans, *next;\n\tstruct nft_trans_elem *te;\n\n\tif (action == NFNL_ABORT_VALIDATE &&\n\t    nf_tables_validate(net) < 0)\n\t\treturn -EAGAIN;\n\n\tlist_for_each_entry_safe_reverse(trans, next, &nft_net->commit_list,\n\t\t\t\t\t list) {\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWTABLE:\n\t\t\tif (nft_trans_table_update(trans)) {\n\t\t\t\tif (!(trans->ctx.table->flags & __NFT_TABLE_F_UPDATE)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trans->ctx.table->flags & __NFT_TABLE_F_WAS_DORMANT) {\n\t\t\t\t\tnf_tables_table_disable(net, trans->ctx.table);\n\t\t\t\t\ttrans->ctx.table->flags |= NFT_TABLE_F_DORMANT;\n\t\t\t\t} else if (trans->ctx.table->flags & __NFT_TABLE_F_WAS_AWAKEN) {\n\t\t\t\t\ttrans->ctx.table->flags &= ~NFT_TABLE_F_DORMANT;\n\t\t\t\t}\n\t\t\t\ttrans->ctx.table->flags &= ~__NFT_TABLE_F_UPDATE;\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\tlist_del_rcu(&trans->ctx.table->list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELTABLE:\n\t\t\tnft_clear(trans->ctx.net, trans->ctx.table);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (nft_trans_chain_update(trans)) {\n\t\t\t\tfree_percpu(nft_trans_chain_stats(trans));\n\t\t\t\tkfree(nft_trans_chain_name(trans));\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\tif (nft_chain_is_bound(trans->ctx.chain)) {\n\t\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tnft_chain_del(trans->ctx.chain);\n\t\t\t\tnf_tables_unregister_hook(trans->ctx.net,\n\t\t\t\t\t\t\t  trans->ctx.table,\n\t\t\t\t\t\t\t  trans->ctx.chain);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, trans->ctx.chain);\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\ttrans->ctx.chain->use--;\n\t\t\tlist_del_rcu(&nft_trans_rule(trans)->list);\n\t\t\tnft_rule_expr_deactivate(&trans->ctx,\n\t\t\t\t\t\t nft_trans_rule(trans),\n\t\t\t\t\t\t NFT_TRANS_ABORT);\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\ttrans->ctx.chain->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_rule(trans));\n\t\t\tnft_rule_expr_activate(&trans->ctx, nft_trans_rule(trans));\n\t\t\tif (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)\n\t\t\t\tnft_flow_rule_destroy(nft_trans_flow_rule(trans));\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSET:\n\t\t\ttrans->ctx.table->use--;\n\t\t\tif (nft_trans_set_bound(trans)) {\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_del_rcu(&nft_trans_set(trans)->list);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSET:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_set(trans));\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWSETELEM:\n\t\t\tif (nft_trans_elem_set_bound(trans)) {\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\t\t\tnft_setelem_remove(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem))\n\t\t\t\tatomic_dec(&te->set->nelems);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELSETELEM:\n\t\t\tte = (struct nft_trans_elem *)trans->data;\n\n\t\t\tnft_setelem_data_activate(net, te->set, &te->elem);\n\t\t\tnft_setelem_activate(net, te->set, &te->elem);\n\t\t\tif (!nft_setelem_is_catchall(te->set, &te->elem))\n\t\t\t\tte->set->ndeact--;\n\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWOBJ:\n\t\t\tif (nft_trans_obj_update(trans)) {\n\t\t\t\tnft_obj_destroy(&trans->ctx, nft_trans_obj_newobj(trans));\n\t\t\t\tnft_trans_destroy(trans);\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tnft_obj_del(nft_trans_obj(trans));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELOBJ:\n\t\t\ttrans->ctx.table->use++;\n\t\t\tnft_clear(trans->ctx.net, nft_trans_obj(trans));\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable_hooks(trans));\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use--;\n\t\t\t\tlist_del_rcu(&nft_trans_flowtable(trans)->list);\n\t\t\t\tnft_unregister_flowtable_net_hooks(net,\n\t\t\t\t\t\t&nft_trans_flowtable(trans)->hook_list);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELFLOWTABLE:\n\t\t\tif (nft_trans_flowtable_update(trans)) {\n\t\t\t\tlist_splice(&nft_trans_flowtable_hooks(trans),\n\t\t\t\t\t    &nft_trans_flowtable(trans)->hook_list);\n\t\t\t} else {\n\t\t\t\ttrans->ctx.table->use++;\n\t\t\t\tnft_clear(trans->ctx.net, nft_trans_flowtable(trans));\n\t\t\t}\n\t\t\tnft_trans_destroy(trans);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe_reverse(trans, next,\n\t\t\t\t\t &nft_net->commit_list, list) {\n\t\tlist_del(&trans->list);\n\t\tnf_tables_abort_release(trans);\n\t}\n\n\tif (action == NFNL_ABORT_AUTOLOAD)\n\t\tnf_tables_module_autoload(net);\n\telse\n\t\tnf_tables_module_autoload_cleanup(net);\n\n\treturn 0;\n}\n\nstatic void nf_tables_cleanup(struct net *net)\n{\n\tnft_validate_state_update(net, NFT_VALIDATE_SKIP);\n}\n\nstatic int nf_tables_abort(struct net *net, struct sk_buff *skb,\n\t\t\t   enum nfnl_abort_action action)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tint ret = __nf_tables_abort(net, action);\n\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn ret;\n}\n\nstatic bool nf_tables_valid_genid(struct net *net, u32 genid)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tbool genid_ok;\n\n\tmutex_lock(&nft_net->commit_mutex);\n\n\tgenid_ok = genid == 0 || nft_net->base_seq == genid;\n\tif (!genid_ok)\n\t\tmutex_unlock(&nft_net->commit_mutex);\n\n\t/* else, commit mutex has to be released by commit or abort function */\n\treturn genid_ok;\n}\n\nstatic const struct nfnetlink_subsystem nf_tables_subsys = {\n\t.name\t\t= \"nf_tables\",\n\t.subsys_id\t= NFNL_SUBSYS_NFTABLES,\n\t.cb_count\t= NFT_MSG_MAX,\n\t.cb\t\t= nf_tables_cb,\n\t.commit\t\t= nf_tables_commit,\n\t.abort\t\t= nf_tables_abort,\n\t.cleanup\t= nf_tables_cleanup,\n\t.valid_genid\t= nf_tables_valid_genid,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_types type)\n{\n\tconst struct nft_base_chain *basechain;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate_dependency);\n\nint nft_chain_validate_hooks(const struct nft_chain *chain,\n\t\t\t     unsigned int hook_flags)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_is_base_chain(chain)) {\n\t\tbasechain = nft_base_chain(chain);\n\n\t\tif ((1 << basechain->ops.hooknum) & hook_flags)\n\t\t\treturn 0;\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_chain_validate_hooks);\n\n/*\n * Loop detection - walk through the ruleset beginning at the destination chain\n * of a new jump until either the source chain is reached (loop) or all\n * reachable chains have been traversed.\n *\n * The loop check is performed whenever a new jump verdict is added to an\n * expression or verdict map or a verdict map is bound to a new chain.\n */\n\nstatic int nf_tables_check_loops(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_chain *chain);\n\nstatic int nft_check_loops(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_set_ext *ext)\n{\n\tconst struct nft_data *data;\n\tint ret;\n\n\tdata = nft_set_ext_data(ext);\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tret = nf_tables_check_loops(ctx, data->verdict.chain);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_loop_check_setelem(const struct nft_ctx *ctx,\n\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\tconst struct nft_set_iter *iter,\n\t\t\t\t\tstruct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\n\t    *nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)\n\t\treturn 0;\n\n\treturn nft_check_loops(ctx, ext);\n}\n\nstatic int nft_set_catchall_loops(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_set *set)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_ext *ext;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_set_elem_active(ext, genmask))\n\t\t\tcontinue;\n\n\t\tret = nft_check_loops(ctx, ext);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int nf_tables_check_loops(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_chain *chain)\n{\n\tconst struct nft_rule *rule;\n\tconst struct nft_expr *expr, *last;\n\tstruct nft_set *set;\n\tstruct nft_set_binding *binding;\n\tstruct nft_set_iter iter;\n\n\tif (ctx->chain == chain)\n\t\treturn -ELOOP;\n\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tnft_rule_for_each_expr(expr, last, rule) {\n\t\t\tstruct nft_immediate_expr *priv;\n\t\t\tconst struct nft_data *data;\n\t\t\tint err;\n\n\t\t\tif (strcmp(expr->ops->type->name, \"immediate\"))\n\t\t\t\tcontinue;\n\n\t\t\tpriv = nft_expr_priv(expr);\n\t\t\tif (priv->dreg != NFT_REG_VERDICT)\n\t\t\t\tcontinue;\n\n\t\t\tdata = &priv->data;\n\t\t\tswitch (data->verdict.code) {\n\t\t\tcase NFT_JUMP:\n\t\t\tcase NFT_GOTO:\n\t\t\t\terr = nf_tables_check_loops(ctx,\n\t\t\t\t\t\t\tdata->verdict.chain);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(set, &ctx->table->sets, list) {\n\t\tif (!nft_is_active_next(ctx->net, set))\n\t\t\tcontinue;\n\t\tif (!(set->flags & NFT_SET_MAP) ||\n\t\t    set->dtype != NFT_DATA_VERDICT)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(binding, &set->bindings, list) {\n\t\t\tif (!(binding->flags & NFT_SET_MAP) ||\n\t\t\t    binding->chain != chain)\n\t\t\t\tcontinue;\n\n\t\t\titer.genmask\t= nft_genmask_next(ctx->net);\n\t\t\titer.skip \t= 0;\n\t\t\titer.count\t= 0;\n\t\t\titer.err\t= 0;\n\t\t\titer.fn\t\t= nf_tables_loop_check_setelem;\n\n\t\t\tset->ops->walk(ctx, set, &iter);\n\t\t\tif (!iter.err)\n\t\t\t\titer.err = nft_set_catchall_loops(ctx, set);\n\n\t\t\tif (iter.err < 0)\n\t\t\t\treturn iter.err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tnft_parse_u32_check - fetch u32 attribute and check for maximum value\n *\n *\t@attr: netlink attribute to fetch value from\n *\t@max: maximum value to be stored in dest\n *\t@dest: pointer to the variable\n *\n *\tParse, check and store a given u32 netlink attribute into variable.\n *\tThis function returns -ERANGE if the value goes over maximum value.\n *\tOtherwise a 0 is returned and the attribute value is stored in the\n *\tdestination variable.\n */\nint nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest)\n{\n\tu32 val;\n\n\tval = ntohl(nla_get_be32(attr));\n\tif (val > max)\n\t\treturn -ERANGE;\n\n\t*dest = val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_u32_check);\n\nstatic int nft_parse_register(const struct nlattr *attr, u32 *preg)\n{\n\tunsigned int reg;\n\n\treg = ntohl(nla_get_be32(attr));\n\tswitch (reg) {\n\tcase NFT_REG_VERDICT...NFT_REG_4:\n\t\t*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE;\n\t\tbreak;\n\tcase NFT_REG32_00...NFT_REG32_15:\n\t\t*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tnft_dump_register - dump a register value to a netlink attribute\n *\n *\t@skb: socket buffer\n *\t@attr: attribute number\n *\t@reg: register number\n *\n *\tConstruct a netlink attribute containing the register number. For\n *\tcompatibility reasons, register numbers being a multiple of 4 are\n *\ttranslated to the corresponding 128 bit register numbers.\n */\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg)\n{\n\tif (reg % (NFT_REG_SIZE / NFT_REG32_SIZE) == 0)\n\t\treg = reg / (NFT_REG_SIZE / NFT_REG32_SIZE);\n\telse\n\t\treg = reg - NFT_REG_SIZE / NFT_REG32_SIZE + NFT_REG32_00;\n\n\treturn nla_put_be32(skb, attr, htonl(reg));\n}\nEXPORT_SYMBOL_GPL(nft_dump_register);\n\nstatic int nft_validate_register_load(enum nft_registers reg, unsigned int len)\n{\n\tif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\n\t\treturn -EINVAL;\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (reg * NFT_REG32_SIZE + len > sizeof_field(struct nft_regs, data))\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)\n{\n\tu32 reg;\n\tint err;\n\n\terr = nft_parse_register(attr, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_validate_register_load(reg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*sreg = reg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_register_load);\n\nstatic int nft_validate_register_store(const struct nft_ctx *ctx,\n\t\t\t\t       enum nft_registers reg,\n\t\t\t\t       const struct nft_data *data,\n\t\t\t\t       enum nft_data_types type,\n\t\t\t\t       unsigned int len)\n{\n\tint err;\n\n\tswitch (reg) {\n\tcase NFT_REG_VERDICT:\n\t\tif (type != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (data != NULL &&\n\t\t    (data->verdict.code == NFT_GOTO ||\n\t\t     data->verdict.code == NFT_JUMP)) {\n\t\t\terr = nf_tables_check_loops(ctx, data->verdict.chain);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (len == 0)\n\t\t\treturn -EINVAL;\n\t\tif (reg * NFT_REG32_SIZE + len >\n\t\t    sizeof_field(struct nft_regs, data))\n\t\t\treturn -ERANGE;\n\n\t\tif (data != NULL && type != NFT_DATA_VALUE)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n}\n\nint nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len)\n{\n\tint err;\n\tu32 reg;\n\n\terr = nft_parse_register(attr, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_validate_register_store(ctx, reg, data, type, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*dreg = reg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_parse_register_store);\n\nstatic const struct nla_policy nft_verdict_policy[NFTA_VERDICT_MAX + 1] = {\n\t[NFTA_VERDICT_CODE]\t= { .type = NLA_U32 },\n\t[NFTA_VERDICT_CHAIN]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_CHAIN_MAXNAMELEN - 1 },\n\t[NFTA_VERDICT_CHAIN_ID]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}\n\nstatic void nft_verdict_uninit(const struct nft_data *data)\n{\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tchain = data->verdict.chain;\n\t\tchain->use--;\n\n\t\tif (!nft_chain_is_bound(chain))\n\t\t\tbreak;\n\n\t\tchain->table->use--;\n\t\tlist_for_each_entry(rule, &chain->rules, list)\n\t\t\tchain->use--;\n\n\t\tnft_chain_del(chain);\n\t\tbreak;\n\t}\n}\n\nint nft_verdict_dump(struct sk_buff *skb, int type, const struct nft_verdict *v)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, type);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_VERDICT_CODE, htonl(v->code)))\n\t\tgoto nla_put_failure;\n\n\tswitch (v->code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (nla_put_string(skb, NFTA_VERDICT_CHAIN,\n\t\t\t\t   v->chain->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_value_init(const struct nft_ctx *ctx,\n\t\t\t  struct nft_data *data, struct nft_data_desc *desc,\n\t\t\t  const struct nlattr *nla)\n{\n\tunsigned int len;\n\n\tlen = nla_len(nla);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > desc->size)\n\t\treturn -EOVERFLOW;\n\tif (desc->len) {\n\t\tif (len != desc->len)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdesc->len = len;\n\t}\n\n\tnla_memcpy(data->data, nla, len);\n\n\treturn 0;\n}\n\nstatic int nft_value_dump(struct sk_buff *skb, const struct nft_data *data,\n\t\t\t  unsigned int len)\n{\n\treturn nla_put(skb, NFTA_DATA_VALUE, len, data->data);\n}\n\nstatic const struct nla_policy nft_data_policy[NFTA_DATA_MAX + 1] = {\n\t[NFTA_DATA_VALUE]\t= { .type = NLA_BINARY },\n\t[NFTA_DATA_VERDICT]\t= { .type = NLA_NESTED },\n};\n\n/**\n *\tnft_data_init - parse nf_tables data netlink attributes\n *\n *\t@ctx: context of the expression using the data\n *\t@data: destination struct nft_data\n *\t@desc: data description\n *\t@nla: netlink attribute containing data\n *\n *\tParse the netlink data attributes and initialize a struct nft_data.\n *\tThe type and length of data are returned in the data description.\n *\n *\tThe caller can indicate that it only wants to accept data of type\n *\tNFT_DATA_VALUE by passing NULL for the ctx argument.\n */\nint nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t  struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tstruct nlattr *tb[NFTA_DATA_MAX + 1];\n\tint err;\n\n\tif (WARN_ON_ONCE(!desc->size))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,\n\t\t\t\t\t  nft_data_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DATA_VALUE]) {\n\t\tif (desc->type != NFT_DATA_VALUE)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);\n\t} else if (tb[NFTA_DATA_VERDICT] && ctx != NULL) {\n\t\tif (desc->type != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nft_data_init);\n\n/**\n *\tnft_data_release - release a nft_data item\n *\n *\t@data: struct nft_data to release\n *\t@type: type of data\n *\n *\tRelease a nft_data item. NFT_DATA_VALUE types can be silently discarded,\n *\tall others need to be released by calling this function.\n */\nvoid nft_data_release(const struct nft_data *data, enum nft_data_types type)\n{\n\tif (type < NFT_DATA_VERDICT)\n\t\treturn;\n\tswitch (type) {\n\tcase NFT_DATA_VERDICT:\n\t\treturn nft_verdict_uninit(data);\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_data_release);\n\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\n\t\t  enum nft_data_types type, unsigned int len)\n{\n\tstruct nlattr *nest;\n\tint err;\n\n\tnest = nla_nest_start_noflag(skb, attr);\n\tif (nest == NULL)\n\t\treturn -1;\n\n\tswitch (type) {\n\tcase NFT_DATA_VALUE:\n\t\terr = nft_value_dump(skb, data, len);\n\t\tbreak;\n\tcase NFT_DATA_VERDICT:\n\t\terr = nft_verdict_dump(skb, NFTA_DATA_VERDICT, &data->verdict);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nft_data_dump);\n\nint __nft_release_basechain(struct nft_ctx *ctx)\n{\n\tstruct nft_rule *rule, *nr;\n\n\tif (WARN_ON(!nft_is_base_chain(ctx->chain)))\n\t\treturn 0;\n\n\tnf_tables_unregister_hook(ctx->net, ctx->chain->table, ctx->chain);\n\tlist_for_each_entry_safe(rule, nr, &ctx->chain->rules, list) {\n\t\tlist_del(&rule->list);\n\t\tctx->chain->use--;\n\t\tnf_tables_rule_release(ctx, rule);\n\t}\n\tnft_chain_del(ctx->chain);\n\tctx->table->use--;\n\tnf_tables_chain_destroy(ctx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__nft_release_basechain);\n\nstatic void __nft_release_hook(struct net *net, struct nft_table *table)\n{\n\tstruct nft_flowtable *flowtable;\n\tstruct nft_chain *chain;\n\n\tlist_for_each_entry(chain, &table->chains, list)\n\t\t__nf_tables_unregister_hook(net, table, chain, true);\n\tlist_for_each_entry(flowtable, &table->flowtables, list)\n\t\t__nft_unregister_flowtable_net_hooks(net, &flowtable->hook_list,\n\t\t\t\t\t\t     true);\n}\n\nstatic void __nft_release_hooks(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table;\n\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table))\n\t\t\tcontinue;\n\n\t\t__nft_release_hook(net, table);\n\t}\n}\n\nstatic void __nft_release_table(struct net *net, struct nft_table *table)\n{\n\tstruct nft_flowtable *flowtable, *nf;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_object *obj, *ne;\n\tstruct nft_rule *rule, *nr;\n\tstruct nft_set *set, *ns;\n\tstruct nft_ctx ctx = {\n\t\t.net\t= net,\n\t\t.family\t= NFPROTO_NETDEV,\n\t};\n\n\tctx.family = table->family;\n\tctx.table = table;\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tctx.chain = chain;\n\t\tlist_for_each_entry_safe(rule, nr, &chain->rules, list) {\n\t\t\tlist_del(&rule->list);\n\t\t\tchain->use--;\n\t\t\tnf_tables_rule_release(&ctx, rule);\n\t\t}\n\t}\n\tlist_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {\n\t\tlist_del(&flowtable->list);\n\t\ttable->use--;\n\t\tnf_tables_flowtable_destroy(flowtable);\n\t}\n\tlist_for_each_entry_safe(set, ns, &table->sets, list) {\n\t\tlist_del(&set->list);\n\t\ttable->use--;\n\t\tnft_set_destroy(&ctx, set);\n\t}\n\tlist_for_each_entry_safe(obj, ne, &table->objects, list) {\n\t\tnft_obj_del(obj);\n\t\ttable->use--;\n\t\tnft_obj_destroy(&ctx, obj);\n\t}\n\tlist_for_each_entry_safe(chain, nc, &table->chains, list) {\n\t\tctx.chain = chain;\n\t\tnft_chain_del(chain);\n\t\ttable->use--;\n\t\tnf_tables_chain_destroy(&ctx);\n\t}\n\tnf_tables_table_destroy(&ctx);\n}\n\nstatic void __nft_release_tables(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_table *table, *nt;\n\n\tlist_for_each_entry_safe(table, nt, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table))\n\t\t\tcontinue;\n\n\t\tlist_del(&table->list);\n\n\t\t__nft_release_table(net, table);\n\t}\n}\n\nstatic int nft_rcv_nl_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct nft_table *table, *to_delete[8];\n\tstruct nftables_pernet *nft_net;\n\tstruct netlink_notify *n = ptr;\n\tstruct net *net = n->net;\n\tunsigned int deleted;\n\tbool restart = false;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_NETFILTER)\n\t\treturn NOTIFY_DONE;\n\n\tnft_net = nft_pernet(net);\n\tdeleted = 0;\n\tmutex_lock(&nft_net->commit_mutex);\nagain:\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (nft_table_has_owner(table) &&\n\t\t    n->portid == table->nlpid) {\n\t\t\t__nft_release_hook(net, table);\n\t\t\tlist_del_rcu(&table->list);\n\t\t\tto_delete[deleted++] = table;\n\t\t\tif (deleted >= ARRAY_SIZE(to_delete))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (deleted) {\n\t\trestart = deleted >= ARRAY_SIZE(to_delete);\n\t\tsynchronize_rcu();\n\t\twhile (deleted)\n\t\t\t__nft_release_table(net, to_delete[--deleted]);\n\n\t\tif (restart)\n\t\t\tgoto again;\n\t}\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nft_nl_notifier = {\n\t.notifier_call  = nft_rcv_nl_event,\n};\n\nstatic int __net_init nf_tables_init_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tINIT_LIST_HEAD(&nft_net->tables);\n\tINIT_LIST_HEAD(&nft_net->commit_list);\n\tINIT_LIST_HEAD(&nft_net->module_list);\n\tINIT_LIST_HEAD(&nft_net->notify_list);\n\tmutex_init(&nft_net->commit_mutex);\n\tnft_net->base_seq = 1;\n\tnft_net->validate_state = NFT_VALIDATE_SKIP;\n\n\treturn 0;\n}\n\nstatic void __net_exit nf_tables_pre_exit_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tmutex_lock(&nft_net->commit_mutex);\n\t__nft_release_hooks(net);\n\tmutex_unlock(&nft_net->commit_mutex);\n}\n\nstatic void __net_exit nf_tables_exit_net(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\n\tmutex_lock(&nft_net->commit_mutex);\n\tif (!list_empty(&nft_net->commit_list))\n\t\t__nf_tables_abort(net, NFNL_ABORT_NONE);\n\t__nft_release_tables(net);\n\tmutex_unlock(&nft_net->commit_mutex);\n\tWARN_ON_ONCE(!list_empty(&nft_net->tables));\n\tWARN_ON_ONCE(!list_empty(&nft_net->module_list));\n\tWARN_ON_ONCE(!list_empty(&nft_net->notify_list));\n}\n\nstatic struct pernet_operations nf_tables_net_ops = {\n\t.init\t\t= nf_tables_init_net,\n\t.pre_exit\t= nf_tables_pre_exit_net,\n\t.exit\t\t= nf_tables_exit_net,\n\t.id\t\t= &nf_tables_net_id,\n\t.size\t\t= sizeof(struct nftables_pernet),\n};\n\nstatic int __init nf_tables_module_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&nf_tables_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_chain_filter_init();\n\tif (err < 0)\n\t\tgoto err_chain_filter;\n\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err_core_module;\n\n\terr = register_netdevice_notifier(&nf_tables_flowtable_notifier);\n\tif (err < 0)\n\t\tgoto err_netdev_notifier;\n\n\terr = rhltable_init(&nft_objname_ht, &nft_objname_ht_params);\n\tif (err < 0)\n\t\tgoto err_rht_objname;\n\n\terr = nft_offload_init();\n\tif (err < 0)\n\t\tgoto err_offload;\n\n\terr = netlink_register_notifier(&nft_nl_notifier);\n\tif (err < 0)\n\t\tgoto err_netlink_notifier;\n\n\t/* must be last */\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err_nfnl_subsys;\n\n\tnft_chain_route_init();\n\n\treturn err;\n\nerr_nfnl_subsys:\n\tnetlink_unregister_notifier(&nft_nl_notifier);\nerr_netlink_notifier:\n\tnft_offload_exit();\nerr_offload:\n\trhltable_destroy(&nft_objname_ht);\nerr_rht_objname:\n\tunregister_netdevice_notifier(&nf_tables_flowtable_notifier);\nerr_netdev_notifier:\n\tnf_tables_core_module_exit();\nerr_core_module:\n\tnft_chain_filter_fini();\nerr_chain_filter:\n\tunregister_pernet_subsys(&nf_tables_net_ops);\n\treturn err;\n}\n\nstatic void __exit nf_tables_module_exit(void)\n{\n\tnfnetlink_subsys_unregister(&nf_tables_subsys);\n\tnetlink_unregister_notifier(&nft_nl_notifier);\n\tnft_offload_exit();\n\tunregister_netdevice_notifier(&nf_tables_flowtable_notifier);\n\tnft_chain_filter_fini();\n\tnft_chain_route_fini();\n\tunregister_pernet_subsys(&nf_tables_net_ops);\n\tcancel_work_sync(&trans_destroy_work);\n\trcu_barrier();\n\trhltable_destroy(&nft_objname_ht);\n\tnf_tables_core_module_exit();\n}\n\nmodule_init(nf_tables_module_init);\nmodule_exit(nf_tables_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_NFTABLES);\n"], "filenames": ["net/netfilter/nf_tables_api.c"], "buggy_code_start_loc": [9713], "buggy_code_end_loc": [9713], "fixing_code_start_loc": [9714], "fixing_code_end_loc": [9716], "type": "CWE-400", "message": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.", "other": {"cve": {"id": "CVE-2022-39190", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-02T05:15:07.737", "lastModified": "2022-11-21T19:45:07.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain."}, {"lang": "es", "value": "Se ha detectado un problema en el archivo net/netfilter/nf_tables_api.c en el kernel de Linux versiones anteriores a 5.19.6. Puede producirse una denegaci\u00f3n de servicio al vincularse a una cadena ya vinculada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19.6", "matchCriteriaId": "1E441584-F164-4965-A3FB-387CBF4C76F2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.6", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/all/20220824220330.64283-12-pablo@netfilter.org/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://twitter.com/pr0Ln", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b"}}