{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * seq_buf.c\n *\n * Copyright (C) 2014 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>\n *\n * The seq_buf is a handy tool that allows you to pass a descriptor around\n * to a buffer that other functions can write to. It is similar to the\n * seq_file functionality but has some differences.\n *\n * To use it, the seq_buf must be initialized with seq_buf_init().\n * This will set up the counters within the descriptor. You can call\n * seq_buf_init() more than once to reset the seq_buf to start\n * from scratch.\n */\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/seq_buf.h>\n\n/**\n * seq_buf_can_fit - can the new data fit in the current buffer?\n * @s: the seq_buf descriptor\n * @len: The length to see if it can fit in the current buffer\n *\n * Returns true if there's enough unused space in the seq_buf buffer\n * to fit the amount of new data according to @len.\n */\nstatic bool seq_buf_can_fit(struct seq_buf *s, size_t len)\n{\n\treturn s->len + len <= s->size;\n}\n\n/**\n * seq_buf_print_seq - move the contents of seq_buf into a seq_file\n * @m: the seq_file descriptor that is the destination\n * @s: the seq_buf descriptor that is the source.\n *\n * Returns zero on success, non zero otherwise\n */\nint seq_buf_print_seq(struct seq_file *m, struct seq_buf *s)\n{\n\tunsigned int len = seq_buf_used(s);\n\n\treturn seq_write(m, s->buffer, len);\n}\n\n/**\n * seq_buf_vprintf - sequence printing of information.\n * @s: seq_buf descriptor\n * @fmt: printf format string\n * @args: va_list of arguments from a printf() type function\n *\n * Writes a vnprintf() format into the sequencce buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_vprintf(struct seq_buf *s, const char *fmt, va_list args)\n{\n\tint len;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tlen = vsnprintf(s->buffer + s->len, s->size - s->len, fmt, args);\n\t\tif (s->len + len < s->size) {\n\t\t\ts->len += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_printf - sequence printing of information\n * @s: seq_buf descriptor\n * @fmt: printf format string\n *\n * Writes a printf() format into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_printf(struct seq_buf *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = seq_buf_vprintf(s, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(seq_buf_printf);\n\n#ifdef CONFIG_BINARY_PRINTF\n/**\n * seq_buf_bprintf - Write the printf string from binary arguments\n * @s: seq_buf descriptor\n * @fmt: The format string for the @binary arguments\n * @binary: The binary arguments for @fmt.\n *\n * When recording in a fast path, a printf may be recorded with just\n * saving the format and the arguments as they were passed to the\n * function, instead of wasting cycles converting the arguments into\n * ASCII characters. Instead, the arguments are saved in a 32 bit\n * word array that is defined by the format string constraints.\n *\n * This function will take the format and the binary array and finish\n * the conversion into the ASCII string within the buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_bprintf(struct seq_buf *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int len = seq_buf_buffer_left(s);\n\tint ret;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tret = bstr_printf(s->buffer + s->len, len, fmt, binary);\n\t\tif (s->len + ret < s->size) {\n\t\t\ts->len += ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n#endif /* CONFIG_BINARY_PRINTF */\n\n/**\n * seq_buf_puts - sequence printing of simple string\n * @s: seq_buf descriptor\n * @str: simple string to record\n *\n * Copy a simple string into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_puts(struct seq_buf *s, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tWARN_ON(s->size == 0);\n\n\t/* Add 1 to len for the trailing null byte which must be there */\n\tlen += 1;\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, str, len);\n\t\t/* Don't count the trailing null byte against the capacity */\n\t\ts->len += len - 1;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_putc - sequence printing of simple character\n * @s: seq_buf descriptor\n * @c: simple character to record\n *\n * Copy a single character into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putc(struct seq_buf *s, unsigned char c)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, 1)) {\n\t\ts->buffer[s->len++] = c;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_putmem - write raw data into the sequenc buffer\n * @s: seq_buf descriptor\n * @mem: The raw memory to copy into the buffer\n * @len: The length of the raw memory to copy (in bytes)\n *\n * There may be cases where raw memory needs to be written into the\n * buffer and a strcpy() would not work. Using this function allows\n * for such cases.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putmem(struct seq_buf *s, const void *mem, unsigned int len)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, mem, len);\n\t\ts->len += len;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n#define MAX_MEMHEX_BYTES\t8U\n#define HEX_CHARS\t\t(MAX_MEMHEX_BYTES*2 + 1)\n\n/**\n * seq_buf_putmem_hex - write raw memory into the buffer in ASCII hex\n * @s: seq_buf descriptor\n * @mem: The raw memory to write its hex ASCII representation of\n * @len: The length of the raw memory to copy (in bytes)\n *\n * This is similar to seq_buf_putmem() except instead of just copying the\n * raw memory into the buffer it writes its ASCII representation of it\n * in hex characters.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putmem_hex(struct seq_buf *s, const void *mem,\n\t\t       unsigned int len)\n{\n\tunsigned char hex[HEX_CHARS];\n\tconst unsigned char *data = mem;\n\tunsigned int start_len;\n\tint i, j;\n\n\tWARN_ON(s->size == 0);\n\n\twhile (len) {\n\t\tstart_len = min(len, HEX_CHARS - 1);\n#ifdef __BIG_ENDIAN\n\t\tfor (i = 0, j = 0; i < start_len; i++) {\n#else\n\t\tfor (i = start_len-1, j = 0; i >= 0; i--) {\n#endif\n\t\t\thex[j++] = hex_asc_hi(data[i]);\n\t\t\thex[j++] = hex_asc_lo(data[i]);\n\t\t}\n\t\tif (WARN_ON_ONCE(j == 0 || j/2 > len))\n\t\t\tbreak;\n\n\t\t/* j increments twice per loop */\n\t\tlen -= j / 2;\n\t\thex[j++] = ' ';\n\n\t\tseq_buf_putmem(s, hex, j);\n\t\tif (seq_buf_has_overflowed(s))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n * seq_buf_path - copy a path into the sequence buffer\n * @s: seq_buf descriptor\n * @path: path to write into the sequence buffer.\n * @esc: set of characters to escape in the output\n *\n * Write a path name into the sequence buffer.\n *\n * Returns the number of written bytes on success, -1 on overflow\n */\nint seq_buf_path(struct seq_buf *s, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_buf_get_buf(s, &buf);\n\tint res = -1;\n\n\tWARN_ON(s->size == 0);\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_buf_commit(s, res);\n\n\treturn res;\n}\n\n/**\n * seq_buf_to_user - copy the squence buffer to user space\n * @s: seq_buf descriptor\n * @ubuf: The userspace memory location to copy to\n * @cnt: The amount to copy\n *\n * Copies the sequence buffer into the userspace memory pointed to\n * by @ubuf. It starts from the last read position (@s->readpos)\n * and writes up to @cnt characters or till it reaches the end of\n * the content in the buffer (@s->len), which ever comes first.\n *\n * On success, it returns a positive number of the number of bytes\n * it copied.\n *\n * On failure it returns -EBUSY if all of the content in the\n * sequence has been already read, which includes nothing in the\n * sequence (@s->len == @s->readpos).\n *\n * Returns -EFAULT if the copy to userspace fails.\n */\nint seq_buf_to_user(struct seq_buf *s, char __user *ubuf, int cnt)\n{\n\tint len;\n\tint ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tlen = seq_buf_used(s);\n\n\tif (len <= s->readpos)\n\t\treturn -EBUSY;\n\n\tlen -= s->readpos;\n\tif (cnt > len)\n\t\tcnt = len;\n\tret = copy_to_user(ubuf, s->buffer + s->readpos, cnt);\n\tif (ret == cnt)\n\t\treturn -EFAULT;\n\n\tcnt -= ret;\n\n\ts->readpos += cnt;\n\treturn cnt;\n}\n\n/**\n * seq_buf_hex_dump - print formatted hex dump into the sequence buffer\n * @s: seq_buf descriptor\n * @prefix_str: string to prefix each line with;\n *  caller supplies trailing spaces for alignment if desired\n * @prefix_type: controls whether prefix of an offset, address, or none\n *  is printed (%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE)\n * @rowsize: number of bytes to print per line; must be 16 or 32\n * @groupsize: number of bytes to print at a time (1, 2, 4, 8; default = 1)\n * @buf: data blob to dump\n * @len: number of bytes in the @buf\n * @ascii: include ASCII after the hex output\n *\n * Function is an analogue of print_hex_dump() and thus has similar interface.\n *\n * linebuf size is maximal length for one line.\n * 32 * 3 - maximum bytes per line, each printed into 2 chars + 1 for\n *\tseparating space\n * 2 - spaces separating hex dump and ascii representation\n * 32 - ascii representation\n * 1 - terminating '\\0'\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_hex_dump(struct seq_buf *s, const char *prefix_str, int prefix_type,\n\t\t     int rowsize, int groupsize,\n\t\t     const void *buf, size_t len, bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tunsigned char linebuf[32 * 3 + 2 + 32 + 1];\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tret = seq_buf_printf(s, \"%s%p: %s\\n\",\n\t\t\t       prefix_str, ptr + i, linebuf);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tret = seq_buf_printf(s, \"%s%.8x: %s\\n\",\n\t\t\t\t\t     prefix_str, i, linebuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = seq_buf_printf(s, \"%s%s\\n\", prefix_str, linebuf);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * seq_buf.c\n *\n * Copyright (C) 2014 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>\n *\n * The seq_buf is a handy tool that allows you to pass a descriptor around\n * to a buffer that other functions can write to. It is similar to the\n * seq_file functionality but has some differences.\n *\n * To use it, the seq_buf must be initialized with seq_buf_init().\n * This will set up the counters within the descriptor. You can call\n * seq_buf_init() more than once to reset the seq_buf to start\n * from scratch.\n */\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/seq_buf.h>\n\n/**\n * seq_buf_can_fit - can the new data fit in the current buffer?\n * @s: the seq_buf descriptor\n * @len: The length to see if it can fit in the current buffer\n *\n * Returns true if there's enough unused space in the seq_buf buffer\n * to fit the amount of new data according to @len.\n */\nstatic bool seq_buf_can_fit(struct seq_buf *s, size_t len)\n{\n\treturn s->len + len <= s->size;\n}\n\n/**\n * seq_buf_print_seq - move the contents of seq_buf into a seq_file\n * @m: the seq_file descriptor that is the destination\n * @s: the seq_buf descriptor that is the source.\n *\n * Returns zero on success, non zero otherwise\n */\nint seq_buf_print_seq(struct seq_file *m, struct seq_buf *s)\n{\n\tunsigned int len = seq_buf_used(s);\n\n\treturn seq_write(m, s->buffer, len);\n}\n\n/**\n * seq_buf_vprintf - sequence printing of information.\n * @s: seq_buf descriptor\n * @fmt: printf format string\n * @args: va_list of arguments from a printf() type function\n *\n * Writes a vnprintf() format into the sequencce buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_vprintf(struct seq_buf *s, const char *fmt, va_list args)\n{\n\tint len;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tlen = vsnprintf(s->buffer + s->len, s->size - s->len, fmt, args);\n\t\tif (s->len + len < s->size) {\n\t\t\ts->len += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_printf - sequence printing of information\n * @s: seq_buf descriptor\n * @fmt: printf format string\n *\n * Writes a printf() format into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_printf(struct seq_buf *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = seq_buf_vprintf(s, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(seq_buf_printf);\n\n#ifdef CONFIG_BINARY_PRINTF\n/**\n * seq_buf_bprintf - Write the printf string from binary arguments\n * @s: seq_buf descriptor\n * @fmt: The format string for the @binary arguments\n * @binary: The binary arguments for @fmt.\n *\n * When recording in a fast path, a printf may be recorded with just\n * saving the format and the arguments as they were passed to the\n * function, instead of wasting cycles converting the arguments into\n * ASCII characters. Instead, the arguments are saved in a 32 bit\n * word array that is defined by the format string constraints.\n *\n * This function will take the format and the binary array and finish\n * the conversion into the ASCII string within the buffer.\n *\n * Returns zero on success, -1 on overflow.\n */\nint seq_buf_bprintf(struct seq_buf *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int len = seq_buf_buffer_left(s);\n\tint ret;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tret = bstr_printf(s->buffer + s->len, len, fmt, binary);\n\t\tif (s->len + ret < s->size) {\n\t\t\ts->len += ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n#endif /* CONFIG_BINARY_PRINTF */\n\n/**\n * seq_buf_puts - sequence printing of simple string\n * @s: seq_buf descriptor\n * @str: simple string to record\n *\n * Copy a simple string into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_puts(struct seq_buf *s, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tWARN_ON(s->size == 0);\n\n\t/* Add 1 to len for the trailing null byte which must be there */\n\tlen += 1;\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, str, len);\n\t\t/* Don't count the trailing null byte against the capacity */\n\t\ts->len += len - 1;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_putc - sequence printing of simple character\n * @s: seq_buf descriptor\n * @c: simple character to record\n *\n * Copy a single character into the sequence buffer.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putc(struct seq_buf *s, unsigned char c)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, 1)) {\n\t\ts->buffer[s->len++] = c;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n/**\n * seq_buf_putmem - write raw data into the sequenc buffer\n * @s: seq_buf descriptor\n * @mem: The raw memory to copy into the buffer\n * @len: The length of the raw memory to copy (in bytes)\n *\n * There may be cases where raw memory needs to be written into the\n * buffer and a strcpy() would not work. Using this function allows\n * for such cases.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putmem(struct seq_buf *s, const void *mem, unsigned int len)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, mem, len);\n\t\ts->len += len;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n#define MAX_MEMHEX_BYTES\t8U\n#define HEX_CHARS\t\t(MAX_MEMHEX_BYTES*2 + 1)\n\n/**\n * seq_buf_putmem_hex - write raw memory into the buffer in ASCII hex\n * @s: seq_buf descriptor\n * @mem: The raw memory to write its hex ASCII representation of\n * @len: The length of the raw memory to copy (in bytes)\n *\n * This is similar to seq_buf_putmem() except instead of just copying the\n * raw memory into the buffer it writes its ASCII representation of it\n * in hex characters.\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_putmem_hex(struct seq_buf *s, const void *mem,\n\t\t       unsigned int len)\n{\n\tunsigned char hex[HEX_CHARS];\n\tconst unsigned char *data = mem;\n\tunsigned int start_len;\n\tint i, j;\n\n\tWARN_ON(s->size == 0);\n\n\tBUILD_BUG_ON(MAX_MEMHEX_BYTES * 2 >= HEX_CHARS);\n\n\twhile (len) {\n\t\tstart_len = min(len, MAX_MEMHEX_BYTES);\n#ifdef __BIG_ENDIAN\n\t\tfor (i = 0, j = 0; i < start_len; i++) {\n#else\n\t\tfor (i = start_len-1, j = 0; i >= 0; i--) {\n#endif\n\t\t\thex[j++] = hex_asc_hi(data[i]);\n\t\t\thex[j++] = hex_asc_lo(data[i]);\n\t\t}\n\t\tif (WARN_ON_ONCE(j == 0 || j/2 > len))\n\t\t\tbreak;\n\n\t\t/* j increments twice per loop */\n\t\tlen -= j / 2;\n\t\thex[j++] = ' ';\n\n\t\tseq_buf_putmem(s, hex, j);\n\t\tif (seq_buf_has_overflowed(s))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n * seq_buf_path - copy a path into the sequence buffer\n * @s: seq_buf descriptor\n * @path: path to write into the sequence buffer.\n * @esc: set of characters to escape in the output\n *\n * Write a path name into the sequence buffer.\n *\n * Returns the number of written bytes on success, -1 on overflow\n */\nint seq_buf_path(struct seq_buf *s, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_buf_get_buf(s, &buf);\n\tint res = -1;\n\n\tWARN_ON(s->size == 0);\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_buf_commit(s, res);\n\n\treturn res;\n}\n\n/**\n * seq_buf_to_user - copy the squence buffer to user space\n * @s: seq_buf descriptor\n * @ubuf: The userspace memory location to copy to\n * @cnt: The amount to copy\n *\n * Copies the sequence buffer into the userspace memory pointed to\n * by @ubuf. It starts from the last read position (@s->readpos)\n * and writes up to @cnt characters or till it reaches the end of\n * the content in the buffer (@s->len), which ever comes first.\n *\n * On success, it returns a positive number of the number of bytes\n * it copied.\n *\n * On failure it returns -EBUSY if all of the content in the\n * sequence has been already read, which includes nothing in the\n * sequence (@s->len == @s->readpos).\n *\n * Returns -EFAULT if the copy to userspace fails.\n */\nint seq_buf_to_user(struct seq_buf *s, char __user *ubuf, int cnt)\n{\n\tint len;\n\tint ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tlen = seq_buf_used(s);\n\n\tif (len <= s->readpos)\n\t\treturn -EBUSY;\n\n\tlen -= s->readpos;\n\tif (cnt > len)\n\t\tcnt = len;\n\tret = copy_to_user(ubuf, s->buffer + s->readpos, cnt);\n\tif (ret == cnt)\n\t\treturn -EFAULT;\n\n\tcnt -= ret;\n\n\ts->readpos += cnt;\n\treturn cnt;\n}\n\n/**\n * seq_buf_hex_dump - print formatted hex dump into the sequence buffer\n * @s: seq_buf descriptor\n * @prefix_str: string to prefix each line with;\n *  caller supplies trailing spaces for alignment if desired\n * @prefix_type: controls whether prefix of an offset, address, or none\n *  is printed (%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE)\n * @rowsize: number of bytes to print per line; must be 16 or 32\n * @groupsize: number of bytes to print at a time (1, 2, 4, 8; default = 1)\n * @buf: data blob to dump\n * @len: number of bytes in the @buf\n * @ascii: include ASCII after the hex output\n *\n * Function is an analogue of print_hex_dump() and thus has similar interface.\n *\n * linebuf size is maximal length for one line.\n * 32 * 3 - maximum bytes per line, each printed into 2 chars + 1 for\n *\tseparating space\n * 2 - spaces separating hex dump and ascii representation\n * 32 - ascii representation\n * 1 - terminating '\\0'\n *\n * Returns zero on success, -1 on overflow\n */\nint seq_buf_hex_dump(struct seq_buf *s, const char *prefix_str, int prefix_type,\n\t\t     int rowsize, int groupsize,\n\t\t     const void *buf, size_t len, bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tunsigned char linebuf[32 * 3 + 2 + 32 + 1];\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tret = seq_buf_printf(s, \"%s%p: %s\\n\",\n\t\t\t       prefix_str, ptr + i, linebuf);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tret = seq_buf_printf(s, \"%s%.8x: %s\\n\",\n\t\t\t\t\t     prefix_str, i, linebuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = seq_buf_printf(s, \"%s%s\\n\", prefix_str, linebuf);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n"], "filenames": ["lib/seq_buf.c"], "buggy_code_start_loc": [231], "buggy_code_end_loc": [234], "fixing_code_start_loc": [232], "fixing_code_end_loc": [236], "type": "CWE-120", "message": "An issue was discovered in the Linux kernel before 5.13.3. lib/seq_buf.c has a seq_buf_putmem_hex buffer overflow.", "other": {"cve": {"id": "CVE-2023-28772", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-23T15:15:12.177", "lastModified": "2023-06-06T18:34:31.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.13.3. lib/seq_buf.c has a seq_buf_putmem_hex buffer overflow."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.27", "versionEndExcluding": "4.4.276", "matchCriteriaId": "AC46ADF4-F65E-4A9C-8AFA-1C349FACCCC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.276", "matchCriteriaId": "C79FFC06-9530-4CD7-B651-01D786CC925E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.240", "matchCriteriaId": "FB359B2E-773D-4D52-9915-E07A47ABE72B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.198", "matchCriteriaId": "B93AEDB9-C52B-4222-8F9A-882DAD9EF5B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.133", "matchCriteriaId": "65A8F1FF-5639-455A-8BF4-9FF529240505"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.51", "matchCriteriaId": "93289127-DFB3-4515-89DD-50521FF8B7FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.11", "versionEndExcluding": "5.12.18", "matchCriteriaId": "79D13C82-E06F-4A70-A3D1-C09494FBC94D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.13", "versionEndExcluding": "5.13.3", "matchCriteriaId": "853187F6-707A-487B-95C0-621B5211B43C"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d3b16034a24a112bb83aeb669ac5b9b01f744bb7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lkml.kernel.org/r/20210626032156.47889-1-yun.zhou@windriver.com", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://lore.kernel.org/lkml/20210625122453.5e2fe304@oasis.local.home/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230427-0005/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d3b16034a24a112bb83aeb669ac5b9b01f744bb7"}}