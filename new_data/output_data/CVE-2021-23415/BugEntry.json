{"buggy_code": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing elFinder.AspNet.Drawing;\nusing elFinder.AspNet.Helpers;\nusing elFinder.AspNet.Models;\nusing elFinder.AspNet.Models.Commands;\n\nnamespace elFinder.AspNet.Drivers.FileSystem\n{\n    /// <summary>\n    /// Represents a driver for local file system\n    /// </summary>\n    public class FileSystemDriver : BaseDriver, IDriver\n    {\n        private const string _volumePrefix = \"v\";\n\n        #region Constructor\n\n        /// <summary>\n        /// Initialize new instance of class ElFinder.FileSystemDriver\n        /// </summary>\n        public FileSystemDriver()\n        {\n            VolumePrefix = _volumePrefix;\n            Roots = new List<RootVolume>();\n        }\n\n        #endregion Constructor\n\n        #region IDriver Members\n\n        public async Task<ConnectorResult> ArchiveAsync(FullPath parentPath, IEnumerable<FullPath> paths, string filename, string mimeType)\n        {\n            var response = new AddResponseModel();\n\n            if (paths == null)\n            {\n                throw new NotSupportedException();\n            }\n\n            if (mimeType != \"application/zip\")\n            {\n                throw new NotSupportedException(\"Only .zip files are currently supported.\");\n            }\n\n            // Parse target path\n\n            var directoryInfo = parentPath.Directory;\n\n            if (directoryInfo != null)\n            {\n                if (filename is null)\n                {\n                    filename = \"newfile\";\n                }\n\n                if (filename.EndsWith(\".zip\"))\n                {\n                    filename = filename.Replace(\".zip\", \"\");\n                }\n\n                string newPath = Path.Combine(directoryInfo.FullName, filename + \".zip\");\n\n                if (File.Exists(newPath))\n                {\n                    File.Delete(newPath);\n                }\n\n                using (var newFile = ZipFile.Open(newPath, ZipArchiveMode.Create))\n                {\n                    foreach (var tg in paths)\n                    {\n                        if (tg.IsDirectory)\n                        {\n                            await AddDirectoryToArchiveAsync(newFile, tg.Directory, \"\");\n                        }\n                        else\n                        {\n                            newFile.CreateEntryFromFile(tg.File.FullName, tg.File.Name);\n                        }\n                    }\n                }\n\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newPath), parentPath.RootVolume));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> CropAsync(FullPath path, int x, int y, int width, int height)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Crop Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Crop(stream, x, y, width, height);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public Task<ConnectorResult> DimAsync(FullPath path)\n        {\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                var response = new DimResponseModel(path.RootVolume.PictureEditor.ImageSize(stream));\n                return Task.FromResult(new ConnectorResult(response));\n            }\n        }\n\n        public async Task<ConnectorResult> DuplicateAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new AddResponseModel();\n            foreach (var path in paths)\n            {\n                if (path.IsDirectory)\n                {\n                    string parentPath = path.Directory.Parent.FullName;\n                    string name = path.Directory.Name;\n                    string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy\";\n\n                    if (!Directory.Exists(newName))\n                    {\n                        DirectoryCopy(path.Directory.FullName, newName, true);\n                    }\n                    else\n                    {\n                        bool foundNewName = false;\n                        for (int i = 1; i < 100; i++)\n                        {\n                            newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy {i}\";\n                            if (!Directory.Exists(newName))\n                            {\n                                DirectoryCopy(path.Directory.FullName, newName, true);\n                                foundNewName = true;\n                                break;\n                            }\n                        }\n\n                        if (!foundNewName)\n                        {\n                            return new ConnectorResult($\"Unable to create new file with name {parentPath}{Path.DirectorySeparatorChar}{name} copy\");\n                        }\n                    }\n\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemDirectory(newName), path.RootVolume));\n                }\n                else\n                {\n                    string parentPath = path.File.Directory.FullName;\n                    string name = path.File.Name.Substring(0, path.File.Name.Length - path.File.Extension.Length);\n                    string ext = path.File.Extension;\n\n                    string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy{ext}\";\n\n                    if (!File.Exists(newName))\n                    {\n                        File.Copy(path.File.FullName, newName);\n                    }\n                    else\n                    {\n                        bool foundNewName = false;\n                        for (int i = 1; i < 100; i++)\n                        {\n                            newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy {i}{ext}\";\n                            if (!File.Exists(newName))\n                            {\n                                File.Copy(path.File.FullName, newName);\n                                foundNewName = true;\n                                break;\n                            }\n                        }\n\n                        if (!foundNewName)\n                        {\n                            return new ConnectorResult($\"Unable to create new file with name {parentPath}{Path.DirectorySeparatorChar}{name} copy{ext}\");\n                        }\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newName), path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ExtractAsync(FullPath fullPath, bool newFolder)\n        {\n            var response = new AddResponseModel();\n\n            if (fullPath.IsDirectory || fullPath.File.Extension.ToLower() != \".zip\")\n            {\n                throw new NotSupportedException(\"Only .zip files are currently supported.\");\n            }\n\n            string rootPath = fullPath.File.Directory.FullName;\n\n            if (newFolder)\n            {\n                rootPath = Path.Combine(rootPath, Path.GetFileNameWithoutExtension(fullPath.File.Name));\n                var rootDir = new FileSystemDirectory(rootPath);\n                if (!await rootDir.ExistsAsync)\n                {\n                    await rootDir.CreateAsync();\n                }\n                response.Added.Add(await BaseModel.CreateAsync(rootDir, fullPath.RootVolume));\n            }\n\n            using (var archive = ZipFile.OpenRead(fullPath.File.FullName))\n            {\n                string separator = Path.DirectorySeparatorChar.ToString();\n                foreach (ZipArchiveEntry entry in archive.Entries)\n                {\n                    try\n                    {\n                        //Replce zip entry path separator by system path separator\n                        string file = Path.Combine(rootPath, entry.FullName)\n                             .Replace(\"/\", separator).Replace(\"\\\\\", separator);\n\n                        if (file.EndsWith(separator)) //directory\n                        {\n                            var dir = new FileSystemDirectory(file);\n\n                            if (!await dir.ExistsAsync)\n                            {\n                                await dir.CreateAsync();\n                            }\n                            if (!newFolder)\n                            {\n                                response.Added.Add(await BaseModel.CreateAsync(dir, fullPath.RootVolume));\n                            }\n                        }\n                        else\n                        {\n                            entry.ExtractToFile(file, true);\n                            if (!newFolder)\n                            {\n                                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(file), fullPath.RootVolume));\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Trace.TraceError(\"{0} - {1}\", entry.FullName, ex.Message);\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> FileAsync(FullPath path, bool download)\n        {\n            FileContent result;\n\n            if (path.IsDirectory)\n            {\n                return new ConnectorResult(\"errNotFile\");\n            }\n\n            if (!await path.File.ExistsAsync)\n            {\n                return new ConnectorResult(\"errFileNotFound\");\n            }\n\n            if (path.RootVolume.IsShowOnly)\n            {\n                return new ConnectorResult(\"errPerm\");\n            }\n\n            result = new FileContent {\n                FileName = path.File.FullName,\n                Length = await path.File.LengthAsync,\n                ContentStream = File.OpenRead(path.File.FullName),\n                ContentType = download ? \"application/octet-stream\" : MimeHelper.GetMimeType(path.File.Extension)\n            };\n\n            return new ConnectorResult(result);\n        }\n\n        public async Task<ConnectorResult> GetAsync(FullPath path)\n        {\n            var response = new GetResponseModel();\n            using (var reader = new StreamReader(await path.File.OpenReadAsync()))\n            {\n                response.Content = reader.ReadToEnd();\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> InitAsync(FullPath path, IEnumerable<string> mimeTypes)\n        {\n            if (path == null)\n            {\n                var root = Roots.FirstOrDefault(r => r.StartDirectory != null);\n                if (root == null)\n                {\n                    root = Roots.First();\n                }\n\n                path = new FullPath(root, new FileSystemDirectory(root.StartDirectory ?? root.RootDirectory), null);\n            }\n\n            var response = new InitResponseModel(await BaseModel.CreateAsync(path.Directory, path.RootVolume), new Options(path));\n\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n\n            foreach (var item in Roots)\n            {\n                response.Files.Add(await BaseModel.CreateAsync(new FileSystemDirectory(item.RootDirectory), item));\n            }\n\n            if (path.RootVolume.RootDirectory != path.Directory.FullName)\n            {\n                var dirInfo = new DirectoryInfo(path.RootVolume.RootDirectory);\n                foreach (var item in dirInfo.GetDirectories())\n                {\n                    var attributes = item.Attributes;\n                    if (!attributes.HasFlag(FileAttributes.Hidden))\n                    {\n                        response.Files.Add(await BaseModel.CreateAsync(new FileSystemDirectory(item), path.RootVolume));\n                    }\n                }\n            }\n\n            if (path.RootVolume.MaxUploadSize.HasValue)\n            {\n                response.Options.UploadMaxSize = $\"{path.RootVolume.MaxUploadSizeInKb.Value}K\";\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ListAsync(FullPath path, IEnumerable<string> intersect, IEnumerable<string> mimeTypes)\n        {\n            var response = new ListResponseModel();\n\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.List.Add(item.Name);\n                }\n            }\n\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.List.Add(item.Name);\n                }\n            }\n\n            if (intersect.Any())\n            {\n                response.List.RemoveAll(x => !intersect.Contains(x));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> MakeDirAsync(FullPath path, string name, IEnumerable<string> dirs)\n        {\n            var response = new AddResponseModel();\n\n            if (!string.IsNullOrEmpty(name))\n            {\n                var newDir = new FileSystemDirectory(Path.Combine(path.Directory.FullName, name));\n                await newDir.CreateAsync();\n                response.Added.Add(await BaseModel.CreateAsync(newDir, path.RootVolume));\n            }\n\n            foreach (string dir in dirs)\n            {\n                string dirName = dir.StartsWith(\"/\") ? dir.Substring(1) : dir;\n                var newDir = new FileSystemDirectory(Path.Combine(path.Directory.FullName, dirName));\n                await newDir.CreateAsync();\n\n                response.Added.Add(await BaseModel.CreateAsync(newDir, path.RootVolume));\n\n                string relativePath = newDir.FullName.Substring(path.RootVolume.RootDirectory.Length);\n                response.Hashes.Add($\"/{dirName}\", path.RootVolume.VolumeId + HttpEncoder.EncodePath(relativePath));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> MakeFileAsync(FullPath path, string name)\n        {\n            var newFile = new FileSystemFile(Path.Combine(path.Directory.FullName, name));\n            await newFile.CreateAsync();\n\n            var response = new AddResponseModel();\n            response.Added.Add(await BaseModel.CreateAsync(newFile, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> OpenAsync(FullPath path, bool tree, IEnumerable<string> mimeTypes)\n        {\n            var response = new OpenResponse(await BaseModel.CreateAsync(path.Directory, path.RootVolume), path);\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n\n            // Add parents\n            if (tree)\n            {\n                var parent = path.Directory;\n\n                var rootDirectory = new DirectoryInfo(path.RootVolume.RootDirectory);\n                while (parent != null && parent.Name != rootDirectory.Name)\n                {\n                    // Update parent\n                    parent = parent.Parent;\n\n                    // Ensure it's a child of the root\n                    if (parent != null && path.RootVolume.RootDirectory.Contains(parent.Name))\n                    {\n                        response.Files.Insert(0, await BaseModel.CreateAsync(parent, path.RootVolume));\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ParentsAsync(FullPath path)\n        {\n            var response = new TreeResponseModel();\n            if (path.Directory.FullName == path.RootVolume.RootDirectory)\n            {\n                response.Tree.Add(await BaseModel.CreateAsync(path.Directory, path.RootVolume));\n            }\n            else\n            {\n                var parent = path.Directory;\n                foreach (var item in await parent.Parent.GetDirectoriesAsync())\n                {\n                    response.Tree.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n                while (parent.FullName != path.RootVolume.RootDirectory)\n                {\n                    parent = parent.Parent;\n                    response.Tree.Add(await BaseModel.CreateAsync(parent, path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<FullPath> ParsePathAsync(string target)\n        {\n            if (string.IsNullOrEmpty(target))\n            {\n                return null;\n            }\n\n            string volumePrefix = null;\n            string pathHash = null;\n            for (int i = 0; i < target.Length; i++)\n            {\n                if (target[i] == '_')\n                {\n                    pathHash = target.Substring(i + 1);\n                    volumePrefix = target.Substring(0, i + 1);\n                    break;\n                }\n            }\n\n            var root = Roots.First(r => r.VolumeId == volumePrefix);\n            var rootDirectory = new DirectoryInfo(root.RootDirectory);\n            string path = HttpEncoder.DecodePath(pathHash);\n            string dirUrl = path != rootDirectory.Name ? path : string.Empty;\n            var dir = new FileSystemDirectory(root.RootDirectory + dirUrl);\n\n            if (await dir.ExistsAsync)\n            {\n                return new FullPath(root, dir, target);\n            }\n            else\n            {\n                var file = new FileSystemFile(root.RootDirectory + dirUrl);\n                return new FullPath(root, file, target);\n            }\n        }\n\n        public async Task<ConnectorResult> PasteAsync(FullPath dest, IEnumerable<FullPath> paths, bool isCut, IEnumerable<string> renames, string suffix)\n        {\n            var response = new ReplaceResponseModel();\n\n            foreach (string rename in renames)\n            {\n                var fileInfo = new FileInfo(Path.Combine(dest.Directory.FullName, rename));\n                string destination = Path.Combine(dest.Directory.FullName, $\"{Path.GetFileNameWithoutExtension(rename)}{suffix}{Path.GetExtension(rename)}\");\n                fileInfo.MoveTo(destination);\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(destination), dest.RootVolume));\n            }\n\n            foreach (var src in paths)\n            {\n                if (src.IsDirectory)\n                {\n                    var newDir = new FileSystemDirectory(Path.Combine(dest.Directory.FullName, src.Directory.Name));\n                    if (await newDir.ExistsAsync)\n                    {\n                        Directory.Delete(newDir.FullName, true);\n                    }\n\n                    if (isCut)\n                    {\n                        await RemoveThumbsAsync(src);\n                        Directory.Move(src.Directory.FullName, newDir.FullName);\n                        response.Removed.Add(src.HashedTarget);\n                    }\n                    else\n                    {\n                        DirectoryCopy(src.Directory.FullName, newDir.FullName, true);\n                    }\n\n                    response.Added.Add(await BaseModel.CreateAsync(newDir, dest.RootVolume));\n                }\n                else\n                {\n                    var newFile = new FileSystemFile(Path.Combine(dest.Directory.FullName, src.File.Name));\n                    if (await newFile.ExistsAsync)\n                    {\n                        await newFile.DeleteAsync();\n                    }\n\n                    if (isCut)\n                    {\n                        await RemoveThumbsAsync(src);\n                        File.Move(src.File.FullName, newFile.FullName);\n                        response.Removed.Add(src.HashedTarget);\n                    }\n                    else\n                    {\n                        File.Copy(src.File.FullName, newFile.FullName);\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(newFile, dest.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> PutAsync(FullPath path, string content)\n        {\n            var response = new ChangedResponseModel();\n            using (var fileStream = new FileStream(path.File.FullName, FileMode.Create))\n            using (var writer = new StreamWriter(fileStream))\n            {\n                writer.Write(content);\n            }\n            response.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> PutAsync(FullPath path, byte[] content)\n        {\n            var response = new ChangedResponseModel();\n            using (var fileStream = new FileStream(path.File.FullName, FileMode.Create))\n            using (var writer = new BinaryWriter(fileStream))\n            {\n                writer.Write(content);\n            }\n            response.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> RemoveAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new RemoveResponseModel();\n            foreach (var path in paths)\n            {\n                await RemoveThumbsAsync(path);\n                try\n                {\n                    if (path.IsDirectory)\n                    {\n                        Directory.Delete(path.Directory.FullName, true);\n                    }\n                    else\n                    {\n                        File.Delete(path.File.FullName);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(ex.Message);\n                }\n                response.Removed.Add(path.HashedTarget);\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> RenameAsync(FullPath path, string name)\n        {\n            var response = new ReplaceResponseModel();\n            response.Removed.Add(path.HashedTarget);\n            await RemoveThumbsAsync(path);\n\n            if (path.IsDirectory)\n            {\n                var newPath = new FileSystemDirectory(Path.Combine(path.Directory.Parent.FullName, name));\n                Directory.Move(path.Directory.FullName, newPath.FullName);\n                response.Added.Add(await BaseModel.CreateAsync(newPath, path.RootVolume));\n            }\n            else\n            {\n                var newPath = new FileSystemFile(Path.Combine(path.File.DirectoryName, name));\n                File.Move(path.File.FullName, newPath.FullName);\n                response.Added.Add(await BaseModel.CreateAsync(newPath, path.RootVolume));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ResizeAsync(FullPath path, int width, int height)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Resize Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Resize(stream, width, height);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public async Task<ConnectorResult> RotateAsync(FullPath path, int degree)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Rotate Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Rotate(stream, degree);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public async Task<ConnectorResult> SearchAsync(FullPath path, string query, IEnumerable<string> mimeTypes)\n        {\n            var response = new SearchResponseModel();\n\n            if (!query.Any(Path.GetInvalidFileNameChars().Contains))\n            {\n                foreach (var item in await path.Directory.GetFilesAsync(mimeTypes, string.Concat(\"*\", query, \"*\")))\n                {\n                    if (!item.Attributes.HasFlag(FileAttributes.Hidden) && !item.Directory.Attributes.HasFlag(FileAttributes.Hidden))\n                    {\n                        response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                    }\n                }\n\n                if (query != \".\")\n                {\n                    foreach (var item in await path.Directory.GetDirectoriesAsync(string.Concat(\"*\", query, \"*\")))\n                    {\n                        if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                        {\n                            response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                        }\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> SizeAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new SizeResponseModel();\n\n            foreach (var path in paths)\n            {\n                if (path.IsDirectory)\n                {\n                    response.DirectoryCount++; // API counts the current directory in the total\n\n                    var sizeAndCount = DirectorySizeAndCount(new DirectoryInfo(path.Directory.FullName));\n\n                    response.DirectoryCount += sizeAndCount.DirectoryCount;\n                    response.FileCount += sizeAndCount.FileCount;\n                    response.Size += sizeAndCount.Size;\n                }\n                else\n                {\n                    response.FileCount++;\n                    response.Size += await path.File.LengthAsync;\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ThumbsAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new ThumbsResponseModel();\n            foreach (var path in paths)\n            {\n                response.Images.Add(path.HashedTarget, await path.RootVolume.GenerateThumbHashAsync(path.File));\n                //response.Images.Add(target, path.Root.GenerateThumbHash(path.File) + path.File.Extension); // 2018.02.23: Fix\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> TreeAsync(FullPath path)\n        {\n            var response = new TreeResponseModel();\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Tree.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> UploadAsync(FullPath path, IList<FileContent> files, bool? overwrite, IEnumerable<FullPath> uploadPaths, IEnumerable<string> renames, string suffix)\n        {\n            var response = new AddResponseModel();\n\n            if (path.RootVolume.MaxUploadSize.HasValue)\n            {\n                foreach (var file in files)\n                {\n                    if (file.Length > path.RootVolume.MaxUploadSize.Value)\n                    {\n                        return new ConnectorResult(\"errFileMaxSize\");\n                    }\n                }\n            }\n\n            foreach (string rename in renames)\n            {\n                var fileInfo = new FileInfo(Path.Combine(path.Directory.FullName, rename));\n                string destination = Path.Combine(path.Directory.FullName, $\"{Path.GetFileNameWithoutExtension(rename)}{suffix}{Path.GetExtension(rename)}\");\n                fileInfo.MoveTo(destination);\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(destination), path.RootVolume));\n            }\n\n            foreach (var uploadPath in uploadPaths)\n            {\n                var directory = uploadPath.Directory;\n                while (directory.FullName != path.RootVolume.RootDirectory)\n                {\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemDirectory(directory.FullName), path.RootVolume));\n                    directory = directory.Parent;\n                }\n            }\n\n            int i = 0;\n            foreach (var file in files)\n            {\n                string destination = uploadPaths.Count() > i ? uploadPaths.ElementAt(i).Directory.FullName : path.Directory.FullName;\n                var fileInfo = new FileInfo(Path.Combine(destination, Path.GetFileName(file.FileName)));\n\n                if (fileInfo.Exists)\n                {\n                    if (overwrite ?? path.RootVolume.UploadOverwrite)\n                    {\n                        fileInfo.Delete();\n                        using (var fileStream = File.OpenWrite(fileInfo.FullName))\n                        {\n                            await file.ContentStream.CopyToAsync(fileStream);\n                        }\n                        response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(fileInfo.FullName), path.RootVolume));\n                    }\n                    else\n                    {\n                        string newName = CreateNameForCopy(fileInfo, suffix);\n                        using (var fileStream = File.OpenWrite(Path.Combine(fileInfo.DirectoryName, newName)))\n                        {\n                            await file.ContentStream.CopyToAsync(fileStream);\n                        }\n                        response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newName), path.RootVolume));\n                    }\n                }\n                else\n                {\n                    using (var fileStream = File.OpenWrite(fileInfo.FullName))\n                    {\n                        await file.ContentStream.CopyToAsync(fileStream);\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(fileInfo.FullName), path.RootVolume));\n                }\n\n                i++;\n            }\n            return new ConnectorResult(response);\n        }\n\n        #endregion IDriver Members\n\n        private static string CreateNameForCopy(FileInfo file, string suffix)\n        {\n            string parentPath = file.DirectoryName;\n            string name = Path.GetFileNameWithoutExtension(file.Name);\n            string extension = file.Extension;\n\n            if (string.IsNullOrEmpty(suffix))\n            {\n                suffix = \"copy\";\n            }\n\n            string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix}{extension}\";\n            if (!File.Exists(newName))\n            {\n                return newName;\n            }\n            else\n            {\n                for (int i = 1; i < 10; i++)\n                {\n                    newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix} {i}{extension}\";\n                    if (!File.Exists(newName))\n                    {\n                        return newName;\n                    }\n                }\n            }\n\n            return $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix} {Guid.NewGuid()}{extension}\";\n        }\n\n        private void DirectoryCopy(string sourceDirName, string destDirName, bool copySubDirs)\n        {\n            DirectoryInfo sourceDir = new DirectoryInfo(sourceDirName);\n            DirectoryInfo[] dirs = sourceDir.GetDirectories();\n\n            // If the source directory does not exist, throw an exception.\n            if (!sourceDir.Exists)\n            {\n                throw new DirectoryNotFoundException(\"Source directory does not exist or could not be found: \" + sourceDir.FullName);\n            }\n\n            // If the destination directory does not exist, create it.\n            if (!Directory.Exists(destDirName))\n            {\n                Directory.CreateDirectory(destDirName);\n            }\n\n            // Get the file contents of the directory to copy.\n            FileInfo[] files = sourceDir.GetFiles();\n\n            foreach (FileInfo file in files)\n            {\n                // Create the path to the new copy of the file.\n                string temppath = Path.Combine(destDirName, file.Name);\n\n                // Copy the file.\n                file.CopyTo(temppath, false);\n            }\n\n            // If copySubDirs is true, copy the subdirectories.\n            if (copySubDirs)\n            {\n                foreach (DirectoryInfo subdir in dirs)\n                {\n                    // Create the subdirectory.\n                    string temppath = Path.Combine(destDirName, subdir.Name);\n\n                    // Copy the subdirectories.\n                    DirectoryCopy(subdir.FullName, temppath, copySubDirs);\n                }\n            }\n        }\n\n        private SizeResponseModel DirectorySizeAndCount(DirectoryInfo d)\n        {\n            var response = new SizeResponseModel();\n\n            // Add file sizes.\n            foreach (var file in d.GetFiles())\n            {\n                response.FileCount++;\n                response.Size += file.Length;\n            }\n\n            // Add subdirectory sizes.\n            foreach (var directory in d.GetDirectories())\n            {\n                response.DirectoryCount++;\n\n                var subdir = DirectorySizeAndCount(directory);\n                response.DirectoryCount += subdir.DirectoryCount;\n                response.FileCount += subdir.FileCount;\n                response.Size += subdir.Size;\n            }\n\n            return response;\n        }\n\n        private async Task RemoveThumbsAsync(FullPath path)\n        {\n            if (path.IsDirectory)\n            {\n                string thumbPath = path.RootVolume.GetExistingThumbPath(path.Directory);\n                if (!string.IsNullOrEmpty(thumbPath) && Directory.Exists(thumbPath))\n                {\n                    Directory.Delete(thumbPath, true);\n                }\n            }\n            else\n            {\n                string thumbPath = await path.RootVolume.GetExistingThumbPathAsync(path.File);\n                if (!string.IsNullOrEmpty(thumbPath) && File.Exists(thumbPath))\n                {\n                    File.Delete(thumbPath);\n                }\n            }\n        }\n    }\n}"], "fixing_code": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing elFinder.AspNet.Drawing;\nusing elFinder.AspNet.Helpers;\nusing elFinder.AspNet.Models;\nusing elFinder.AspNet.Models.Commands;\n\nnamespace elFinder.AspNet.Drivers.FileSystem\n{\n    /// <summary>\n    /// Represents a driver for local file system\n    /// </summary>\n    public class FileSystemDriver : BaseDriver, IDriver\n    {\n        private const string _volumePrefix = \"v\";\n\n        #region Constructor\n\n        /// <summary>\n        /// Initialize new instance of class ElFinder.FileSystemDriver\n        /// </summary>\n        public FileSystemDriver()\n        {\n            VolumePrefix = _volumePrefix;\n            Roots = new List<RootVolume>();\n        }\n\n        #endregion Constructor\n\n        #region IDriver Members\n\n        public async Task<ConnectorResult> ArchiveAsync(FullPath parentPath, IEnumerable<FullPath> paths, string filename, string mimeType)\n        {\n            var response = new AddResponseModel();\n\n            if (paths == null)\n            {\n                throw new NotSupportedException();\n            }\n\n            if (mimeType != \"application/zip\")\n            {\n                throw new NotSupportedException(\"Only .zip files are currently supported.\");\n            }\n\n            // Parse target path\n\n            var directoryInfo = parentPath.Directory;\n\n            if (directoryInfo != null)\n            {\n                if (filename is null)\n                {\n                    filename = \"newfile\";\n                }\n\n                if (filename.EndsWith(\".zip\"))\n                {\n                    filename = filename.Replace(\".zip\", \"\");\n                }\n\n                string newPath = Path.Combine(directoryInfo.FullName, filename + \".zip\");\n\n                if (File.Exists(newPath))\n                {\n                    File.Delete(newPath);\n                }\n\n                using (var newFile = ZipFile.Open(newPath, ZipArchiveMode.Create))\n                {\n                    foreach (var tg in paths)\n                    {\n                        if (tg.IsDirectory)\n                        {\n                            await AddDirectoryToArchiveAsync(newFile, tg.Directory, \"\");\n                        }\n                        else\n                        {\n                            newFile.CreateEntryFromFile(tg.File.FullName, tg.File.Name);\n                        }\n                    }\n                }\n\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newPath), parentPath.RootVolume));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> CropAsync(FullPath path, int x, int y, int width, int height)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Crop Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Crop(stream, x, y, width, height);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public Task<ConnectorResult> DimAsync(FullPath path)\n        {\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                var response = new DimResponseModel(path.RootVolume.PictureEditor.ImageSize(stream));\n                return Task.FromResult(new ConnectorResult(response));\n            }\n        }\n\n        public async Task<ConnectorResult> DuplicateAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new AddResponseModel();\n            foreach (var path in paths)\n            {\n                if (path.IsDirectory)\n                {\n                    string parentPath = path.Directory.Parent.FullName;\n                    string name = path.Directory.Name;\n                    string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy\";\n\n                    if (!Directory.Exists(newName))\n                    {\n                        DirectoryCopy(path.Directory.FullName, newName, true);\n                    }\n                    else\n                    {\n                        bool foundNewName = false;\n                        for (int i = 1; i < 100; i++)\n                        {\n                            newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy {i}\";\n                            if (!Directory.Exists(newName))\n                            {\n                                DirectoryCopy(path.Directory.FullName, newName, true);\n                                foundNewName = true;\n                                break;\n                            }\n                        }\n\n                        if (!foundNewName)\n                        {\n                            return new ConnectorResult($\"Unable to create new file with name {parentPath}{Path.DirectorySeparatorChar}{name} copy\");\n                        }\n                    }\n\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemDirectory(newName), path.RootVolume));\n                }\n                else\n                {\n                    string parentPath = path.File.Directory.FullName;\n                    string name = path.File.Name.Substring(0, path.File.Name.Length - path.File.Extension.Length);\n                    string ext = path.File.Extension;\n\n                    string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy{ext}\";\n\n                    if (!File.Exists(newName))\n                    {\n                        File.Copy(path.File.FullName, newName);\n                    }\n                    else\n                    {\n                        bool foundNewName = false;\n                        for (int i = 1; i < 100; i++)\n                        {\n                            newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} copy {i}{ext}\";\n                            if (!File.Exists(newName))\n                            {\n                                File.Copy(path.File.FullName, newName);\n                                foundNewName = true;\n                                break;\n                            }\n                        }\n\n                        if (!foundNewName)\n                        {\n                            return new ConnectorResult($\"Unable to create new file with name {parentPath}{Path.DirectorySeparatorChar}{name} copy{ext}\");\n                        }\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newName), path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ExtractAsync(FullPath fullPath, bool newFolder)\n        {\n            var response = new AddResponseModel();\n\n            if (fullPath.IsDirectory || fullPath.File.Extension.ToLower() != \".zip\")\n            {\n                throw new NotSupportedException(\"Only .zip files are currently supported.\");\n            }\n\n            string rootPath = fullPath.File.Directory.FullName;\n\n            if (newFolder)\n            {\n                rootPath = Path.Combine(rootPath, Path.GetFileNameWithoutExtension(fullPath.File.Name));\n                var rootDir = new FileSystemDirectory(rootPath);\n                if (!await rootDir.ExistsAsync)\n                {\n                    await rootDir.CreateAsync();\n                }\n                response.Added.Add(await BaseModel.CreateAsync(rootDir, fullPath.RootVolume));\n            }\n\n            using (var archive = ZipFile.OpenRead(fullPath.File.FullName))\n            {\n                string separator = Path.DirectorySeparatorChar.ToString();\n                foreach (ZipArchiveEntry entry in archive.Entries)\n                {\n                    try\n                    {\n                        //Replce zip entry path separator by system path separator\n                        string file = Path.Combine(rootPath, entry.FullName)\n                             .Replace(\"/\", separator).Replace(\"\\\\\", separator);\n\n                        string destPath = Path.GetFullPath(file);\n                        if (!destPath.StartsWith(rootPath, StringComparison.OrdinalIgnoreCase))\n                        {\n                            throw new NotSupportedException($\"Entry '{entry.FullName}' is outside of the destination directory.\");\n                        }\n\n                        if (file.EndsWith(separator)) //directory\n                        {\n                            var dir = new FileSystemDirectory(file);\n\n                            if (!await dir.ExistsAsync)\n                            {\n                                await dir.CreateAsync();\n                            }\n                            if (!newFolder)\n                            {\n                                response.Added.Add(await BaseModel.CreateAsync(dir, fullPath.RootVolume));\n                            }\n                        }\n                        else\n                        {\n                            entry.ExtractToFile(file, true);\n                            if (!newFolder)\n                            {\n                                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(file), fullPath.RootVolume));\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Trace.TraceError(\"{0} - {1}\", entry.FullName, ex.Message);\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> FileAsync(FullPath path, bool download)\n        {\n            FileContent result;\n\n            if (path.IsDirectory)\n            {\n                return new ConnectorResult(\"errNotFile\");\n            }\n\n            if (!await path.File.ExistsAsync)\n            {\n                return new ConnectorResult(\"errFileNotFound\");\n            }\n\n            if (path.RootVolume.IsShowOnly)\n            {\n                return new ConnectorResult(\"errPerm\");\n            }\n\n            result = new FileContent {\n                FileName = path.File.FullName,\n                Length = await path.File.LengthAsync,\n                ContentStream = File.OpenRead(path.File.FullName),\n                ContentType = download ? \"application/octet-stream\" : MimeHelper.GetMimeType(path.File.Extension)\n            };\n\n            return new ConnectorResult(result);\n        }\n\n        public async Task<ConnectorResult> GetAsync(FullPath path)\n        {\n            var response = new GetResponseModel();\n            using (var reader = new StreamReader(await path.File.OpenReadAsync()))\n            {\n                response.Content = reader.ReadToEnd();\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> InitAsync(FullPath path, IEnumerable<string> mimeTypes)\n        {\n            if (path == null)\n            {\n                var root = Roots.FirstOrDefault(r => r.StartDirectory != null);\n                if (root == null)\n                {\n                    root = Roots.First();\n                }\n\n                path = new FullPath(root, new FileSystemDirectory(root.StartDirectory ?? root.RootDirectory), null);\n            }\n\n            var response = new InitResponseModel(await BaseModel.CreateAsync(path.Directory, path.RootVolume), new Options(path));\n\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n\n            foreach (var item in Roots)\n            {\n                response.Files.Add(await BaseModel.CreateAsync(new FileSystemDirectory(item.RootDirectory), item));\n            }\n\n            if (path.RootVolume.RootDirectory != path.Directory.FullName)\n            {\n                var dirInfo = new DirectoryInfo(path.RootVolume.RootDirectory);\n                foreach (var item in dirInfo.GetDirectories())\n                {\n                    var attributes = item.Attributes;\n                    if (!attributes.HasFlag(FileAttributes.Hidden))\n                    {\n                        response.Files.Add(await BaseModel.CreateAsync(new FileSystemDirectory(item), path.RootVolume));\n                    }\n                }\n            }\n\n            if (path.RootVolume.MaxUploadSize.HasValue)\n            {\n                response.Options.UploadMaxSize = $\"{path.RootVolume.MaxUploadSizeInKb.Value}K\";\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ListAsync(FullPath path, IEnumerable<string> intersect, IEnumerable<string> mimeTypes)\n        {\n            var response = new ListResponseModel();\n\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.List.Add(item.Name);\n                }\n            }\n\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.List.Add(item.Name);\n                }\n            }\n\n            if (intersect.Any())\n            {\n                response.List.RemoveAll(x => !intersect.Contains(x));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> MakeDirAsync(FullPath path, string name, IEnumerable<string> dirs)\n        {\n            var response = new AddResponseModel();\n\n            if (!string.IsNullOrEmpty(name))\n            {\n                var newDir = new FileSystemDirectory(Path.Combine(path.Directory.FullName, name));\n                await newDir.CreateAsync();\n                response.Added.Add(await BaseModel.CreateAsync(newDir, path.RootVolume));\n            }\n\n            foreach (string dir in dirs)\n            {\n                string dirName = dir.StartsWith(\"/\") ? dir.Substring(1) : dir;\n                var newDir = new FileSystemDirectory(Path.Combine(path.Directory.FullName, dirName));\n                await newDir.CreateAsync();\n\n                response.Added.Add(await BaseModel.CreateAsync(newDir, path.RootVolume));\n\n                string relativePath = newDir.FullName.Substring(path.RootVolume.RootDirectory.Length);\n                response.Hashes.Add($\"/{dirName}\", path.RootVolume.VolumeId + HttpEncoder.EncodePath(relativePath));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> MakeFileAsync(FullPath path, string name)\n        {\n            var newFile = new FileSystemFile(Path.Combine(path.Directory.FullName, name));\n            await newFile.CreateAsync();\n\n            var response = new AddResponseModel();\n            response.Added.Add(await BaseModel.CreateAsync(newFile, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> OpenAsync(FullPath path, bool tree, IEnumerable<string> mimeTypes)\n        {\n            var response = new OpenResponse(await BaseModel.CreateAsync(path.Directory, path.RootVolume), path);\n            foreach (var item in await path.Directory.GetFilesAsync(mimeTypes))\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n\n            // Add parents\n            if (tree)\n            {\n                var parent = path.Directory;\n\n                var rootDirectory = new DirectoryInfo(path.RootVolume.RootDirectory);\n                while (parent != null && parent.Name != rootDirectory.Name)\n                {\n                    // Update parent\n                    parent = parent.Parent;\n\n                    // Ensure it's a child of the root\n                    if (parent != null && path.RootVolume.RootDirectory.Contains(parent.Name))\n                    {\n                        response.Files.Insert(0, await BaseModel.CreateAsync(parent, path.RootVolume));\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ParentsAsync(FullPath path)\n        {\n            var response = new TreeResponseModel();\n            if (path.Directory.FullName == path.RootVolume.RootDirectory)\n            {\n                response.Tree.Add(await BaseModel.CreateAsync(path.Directory, path.RootVolume));\n            }\n            else\n            {\n                var parent = path.Directory;\n                foreach (var item in await parent.Parent.GetDirectoriesAsync())\n                {\n                    response.Tree.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n                while (parent.FullName != path.RootVolume.RootDirectory)\n                {\n                    parent = parent.Parent;\n                    response.Tree.Add(await BaseModel.CreateAsync(parent, path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<FullPath> ParsePathAsync(string target)\n        {\n            if (string.IsNullOrEmpty(target))\n            {\n                return null;\n            }\n\n            string volumePrefix = null;\n            string pathHash = null;\n            for (int i = 0; i < target.Length; i++)\n            {\n                if (target[i] == '_')\n                {\n                    pathHash = target.Substring(i + 1);\n                    volumePrefix = target.Substring(0, i + 1);\n                    break;\n                }\n            }\n\n            var root = Roots.First(r => r.VolumeId == volumePrefix);\n            var rootDirectory = new DirectoryInfo(root.RootDirectory);\n            string path = HttpEncoder.DecodePath(pathHash);\n            string dirUrl = path != rootDirectory.Name ? path : string.Empty;\n            var dir = new FileSystemDirectory(root.RootDirectory + dirUrl);\n\n            if (await dir.ExistsAsync)\n            {\n                return new FullPath(root, dir, target);\n            }\n            else\n            {\n                var file = new FileSystemFile(root.RootDirectory + dirUrl);\n                return new FullPath(root, file, target);\n            }\n        }\n\n        public async Task<ConnectorResult> PasteAsync(FullPath dest, IEnumerable<FullPath> paths, bool isCut, IEnumerable<string> renames, string suffix)\n        {\n            var response = new ReplaceResponseModel();\n\n            foreach (string rename in renames)\n            {\n                var fileInfo = new FileInfo(Path.Combine(dest.Directory.FullName, rename));\n                string destination = Path.Combine(dest.Directory.FullName, $\"{Path.GetFileNameWithoutExtension(rename)}{suffix}{Path.GetExtension(rename)}\");\n                fileInfo.MoveTo(destination);\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(destination), dest.RootVolume));\n            }\n\n            foreach (var src in paths)\n            {\n                if (src.IsDirectory)\n                {\n                    var newDir = new FileSystemDirectory(Path.Combine(dest.Directory.FullName, src.Directory.Name));\n                    if (await newDir.ExistsAsync)\n                    {\n                        Directory.Delete(newDir.FullName, true);\n                    }\n\n                    if (isCut)\n                    {\n                        await RemoveThumbsAsync(src);\n                        Directory.Move(src.Directory.FullName, newDir.FullName);\n                        response.Removed.Add(src.HashedTarget);\n                    }\n                    else\n                    {\n                        DirectoryCopy(src.Directory.FullName, newDir.FullName, true);\n                    }\n\n                    response.Added.Add(await BaseModel.CreateAsync(newDir, dest.RootVolume));\n                }\n                else\n                {\n                    var newFile = new FileSystemFile(Path.Combine(dest.Directory.FullName, src.File.Name));\n                    if (await newFile.ExistsAsync)\n                    {\n                        await newFile.DeleteAsync();\n                    }\n\n                    if (isCut)\n                    {\n                        await RemoveThumbsAsync(src);\n                        File.Move(src.File.FullName, newFile.FullName);\n                        response.Removed.Add(src.HashedTarget);\n                    }\n                    else\n                    {\n                        File.Copy(src.File.FullName, newFile.FullName);\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(newFile, dest.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> PutAsync(FullPath path, string content)\n        {\n            var response = new ChangedResponseModel();\n            using (var fileStream = new FileStream(path.File.FullName, FileMode.Create))\n            using (var writer = new StreamWriter(fileStream))\n            {\n                writer.Write(content);\n            }\n            response.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> PutAsync(FullPath path, byte[] content)\n        {\n            var response = new ChangedResponseModel();\n            using (var fileStream = new FileStream(path.File.FullName, FileMode.Create))\n            using (var writer = new BinaryWriter(fileStream))\n            {\n                writer.Write(content);\n            }\n            response.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> RemoveAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new RemoveResponseModel();\n            foreach (var path in paths)\n            {\n                await RemoveThumbsAsync(path);\n                try\n                {\n                    if (path.IsDirectory)\n                    {\n                        Directory.Delete(path.Directory.FullName, true);\n                    }\n                    else\n                    {\n                        File.Delete(path.File.FullName);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(ex.Message);\n                }\n                response.Removed.Add(path.HashedTarget);\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> RenameAsync(FullPath path, string name)\n        {\n            var response = new ReplaceResponseModel();\n            response.Removed.Add(path.HashedTarget);\n            await RemoveThumbsAsync(path);\n\n            if (path.IsDirectory)\n            {\n                var newPath = new FileSystemDirectory(Path.Combine(path.Directory.Parent.FullName, name));\n                string destPath = Path.GetFullPath(newPath.FullName);\n                if (!destPath.StartsWith(path.RootVolume.RootDirectory, StringComparison.OrdinalIgnoreCase))\n                {\n                    throw new NotSupportedException($\"Entry '{name}' is outside of the home directory.\");\n                }\n                Directory.Move(path.Directory.FullName, newPath.FullName);\n                response.Added.Add(await BaseModel.CreateAsync(newPath, path.RootVolume));\n            }\n            else\n            {\n                var newPath = new FileSystemFile(Path.Combine(path.File.DirectoryName, name));\n                string destPath = Path.GetFullPath(newPath.FullName);\n                if (!destPath.StartsWith(path.RootVolume.RootDirectory, StringComparison.OrdinalIgnoreCase))\n                {\n                    throw new NotSupportedException($\"Entry '{name}' is outside of the home directory.\");\n                }\n                File.Move(path.File.FullName, newPath.FullName);\n                response.Added.Add(await BaseModel.CreateAsync(newPath, path.RootVolume));\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ResizeAsync(FullPath path, int width, int height)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Resize Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Resize(stream, width, height);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public async Task<ConnectorResult> RotateAsync(FullPath path, int degree)\n        {\n            await RemoveThumbsAsync(path);\n\n            // Rotate Image\n            ImageWithMimeType image;\n            using (var stream = new FileStream(path.File.FullName, FileMode.Open))\n            {\n                image = path.RootVolume.PictureEditor.Rotate(stream, degree);\n            }\n\n            using (var fileStream = File.Create(path.File.FullName))\n            {\n                await image.ImageStream.CopyToAsync(fileStream);\n            }\n\n            var output = new ChangedResponseModel();\n            output.Changed.Add(await BaseModel.CreateAsync(path.File, path.RootVolume));\n            return new ConnectorResult(output);\n        }\n\n        public async Task<ConnectorResult> SearchAsync(FullPath path, string query, IEnumerable<string> mimeTypes)\n        {\n            var response = new SearchResponseModel();\n\n            if (!query.Any(Path.GetInvalidFileNameChars().Contains))\n            {\n                foreach (var item in await path.Directory.GetFilesAsync(mimeTypes, string.Concat(\"*\", query, \"*\")))\n                {\n                    if (!item.Attributes.HasFlag(FileAttributes.Hidden) && !item.Directory.Attributes.HasFlag(FileAttributes.Hidden))\n                    {\n                        response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                    }\n                }\n\n                if (query != \".\")\n                {\n                    foreach (var item in await path.Directory.GetDirectoriesAsync(string.Concat(\"*\", query, \"*\")))\n                    {\n                        if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                        {\n                            response.Files.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                        }\n                    }\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> SizeAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new SizeResponseModel();\n\n            foreach (var path in paths)\n            {\n                if (path.IsDirectory)\n                {\n                    response.DirectoryCount++; // API counts the current directory in the total\n\n                    var sizeAndCount = DirectorySizeAndCount(new DirectoryInfo(path.Directory.FullName));\n\n                    response.DirectoryCount += sizeAndCount.DirectoryCount;\n                    response.FileCount += sizeAndCount.FileCount;\n                    response.Size += sizeAndCount.Size;\n                }\n                else\n                {\n                    response.FileCount++;\n                    response.Size += await path.File.LengthAsync;\n                }\n            }\n\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> ThumbsAsync(IEnumerable<FullPath> paths)\n        {\n            var response = new ThumbsResponseModel();\n            foreach (var path in paths)\n            {\n                response.Images.Add(path.HashedTarget, await path.RootVolume.GenerateThumbHashAsync(path.File));\n                //response.Images.Add(target, path.Root.GenerateThumbHash(path.File) + path.File.Extension); // 2018.02.23: Fix\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> TreeAsync(FullPath path)\n        {\n            var response = new TreeResponseModel();\n            foreach (var item in await path.Directory.GetDirectoriesAsync())\n            {\n                if (!item.Attributes.HasFlag(FileAttributes.Hidden))\n                {\n                    response.Tree.Add(await BaseModel.CreateAsync(item, path.RootVolume));\n                }\n            }\n            return new ConnectorResult(response);\n        }\n\n        public async Task<ConnectorResult> UploadAsync(FullPath path, IList<FileContent> files, bool? overwrite, IEnumerable<FullPath> uploadPaths, IEnumerable<string> renames, string suffix)\n        {\n            var response = new AddResponseModel();\n\n            if (path.RootVolume.MaxUploadSize.HasValue)\n            {\n                foreach (var file in files)\n                {\n                    if (file.Length > path.RootVolume.MaxUploadSize.Value)\n                    {\n                        return new ConnectorResult(\"errFileMaxSize\");\n                    }\n                }\n            }\n\n            foreach (string rename in renames)\n            {\n                var fileInfo = new FileInfo(Path.Combine(path.Directory.FullName, rename));\n                string destination = Path.Combine(path.Directory.FullName, $\"{Path.GetFileNameWithoutExtension(rename)}{suffix}{Path.GetExtension(rename)}\");\n                fileInfo.MoveTo(destination);\n                response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(destination), path.RootVolume));\n            }\n\n            foreach (var uploadPath in uploadPaths)\n            {\n                var directory = uploadPath.Directory;\n                while (directory.FullName != path.RootVolume.RootDirectory)\n                {\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemDirectory(directory.FullName), path.RootVolume));\n                    directory = directory.Parent;\n                }\n            }\n\n            int i = 0;\n            foreach (var file in files)\n            {\n                string destination = uploadPaths.Count() > i ? uploadPaths.ElementAt(i).Directory.FullName : path.Directory.FullName;\n                var fileInfo = new FileInfo(Path.Combine(destination, Path.GetFileName(file.FileName)));\n\n                if (fileInfo.Exists)\n                {\n                    if (overwrite ?? path.RootVolume.UploadOverwrite)\n                    {\n                        fileInfo.Delete();\n                        using (var fileStream = File.OpenWrite(fileInfo.FullName))\n                        {\n                            await file.ContentStream.CopyToAsync(fileStream);\n                        }\n                        response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(fileInfo.FullName), path.RootVolume));\n                    }\n                    else\n                    {\n                        string newName = CreateNameForCopy(fileInfo, suffix);\n                        using (var fileStream = File.OpenWrite(Path.Combine(fileInfo.DirectoryName, newName)))\n                        {\n                            await file.ContentStream.CopyToAsync(fileStream);\n                        }\n                        response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(newName), path.RootVolume));\n                    }\n                }\n                else\n                {\n                    using (var fileStream = File.OpenWrite(fileInfo.FullName))\n                    {\n                        await file.ContentStream.CopyToAsync(fileStream);\n                    }\n                    response.Added.Add(await BaseModel.CreateAsync(new FileSystemFile(fileInfo.FullName), path.RootVolume));\n                }\n\n                i++;\n            }\n            return new ConnectorResult(response);\n        }\n\n        #endregion IDriver Members\n\n        private static string CreateNameForCopy(FileInfo file, string suffix)\n        {\n            string parentPath = file.DirectoryName;\n            string name = Path.GetFileNameWithoutExtension(file.Name);\n            string extension = file.Extension;\n\n            if (string.IsNullOrEmpty(suffix))\n            {\n                suffix = \"copy\";\n            }\n\n            string newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix}{extension}\";\n            if (!File.Exists(newName))\n            {\n                return newName;\n            }\n            else\n            {\n                for (int i = 1; i < 10; i++)\n                {\n                    newName = $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix} {i}{extension}\";\n                    if (!File.Exists(newName))\n                    {\n                        return newName;\n                    }\n                }\n            }\n\n            return $\"{parentPath}{Path.DirectorySeparatorChar}{name} {suffix} {Guid.NewGuid()}{extension}\";\n        }\n\n        private void DirectoryCopy(string sourceDirName, string destDirName, bool copySubDirs)\n        {\n            DirectoryInfo sourceDir = new DirectoryInfo(sourceDirName);\n            DirectoryInfo[] dirs = sourceDir.GetDirectories();\n\n            // If the source directory does not exist, throw an exception.\n            if (!sourceDir.Exists)\n            {\n                throw new DirectoryNotFoundException(\"Source directory does not exist or could not be found: \" + sourceDir.FullName);\n            }\n\n            // If the destination directory does not exist, create it.\n            if (!Directory.Exists(destDirName))\n            {\n                Directory.CreateDirectory(destDirName);\n            }\n\n            // Get the file contents of the directory to copy.\n            FileInfo[] files = sourceDir.GetFiles();\n\n            foreach (FileInfo file in files)\n            {\n                // Create the path to the new copy of the file.\n                string temppath = Path.Combine(destDirName, file.Name);\n\n                // Copy the file.\n                file.CopyTo(temppath, false);\n            }\n\n            // If copySubDirs is true, copy the subdirectories.\n            if (copySubDirs)\n            {\n                foreach (DirectoryInfo subdir in dirs)\n                {\n                    // Create the subdirectory.\n                    string temppath = Path.Combine(destDirName, subdir.Name);\n\n                    // Copy the subdirectories.\n                    DirectoryCopy(subdir.FullName, temppath, copySubDirs);\n                }\n            }\n        }\n\n        private SizeResponseModel DirectorySizeAndCount(DirectoryInfo d)\n        {\n            var response = new SizeResponseModel();\n\n            // Add file sizes.\n            foreach (var file in d.GetFiles())\n            {\n                response.FileCount++;\n                response.Size += file.Length;\n            }\n\n            // Add subdirectory sizes.\n            foreach (var directory in d.GetDirectories())\n            {\n                response.DirectoryCount++;\n\n                var subdir = DirectorySizeAndCount(directory);\n                response.DirectoryCount += subdir.DirectoryCount;\n                response.FileCount += subdir.FileCount;\n                response.Size += subdir.Size;\n            }\n\n            return response;\n        }\n\n        private async Task RemoveThumbsAsync(FullPath path)\n        {\n            if (path.IsDirectory)\n            {\n                string thumbPath = path.RootVolume.GetExistingThumbPath(path.Directory);\n                if (!string.IsNullOrEmpty(thumbPath) && Directory.Exists(thumbPath))\n                {\n                    Directory.Delete(thumbPath, true);\n                }\n            }\n            else\n            {\n                string thumbPath = await path.RootVolume.GetExistingThumbPathAsync(path.File);\n                if (!string.IsNullOrEmpty(thumbPath) && File.Exists(thumbPath))\n                {\n                    File.Delete(thumbPath);\n                }\n            }\n        }\n    }\n}"], "filenames": ["elFinder.AspNet/Drivers/FileSystem/FileSystemDriver.cs"], "buggy_code_start_loc": [231], "buggy_code_end_loc": [644], "fixing_code_start_loc": [232], "fixing_code_end_loc": [661], "type": "CWE-22", "message": "This affects the package elFinder.AspNet before 1.1.1. The user-controlled file name is not properly sanitized before it is used to create a file system path.", "other": {"cve": {"id": "CVE-2021-23415", "sourceIdentifier": "report@snyk.io", "published": "2021-07-28T16:15:07.953", "lastModified": "2021-08-04T20:13:14.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package elFinder.AspNet before 1.1.1. The user-controlled file name is not properly sanitized before it is used to create a file system path."}, {"lang": "es", "value": "Esto afecta al paquete elFinder.AspNet anterior a la versi\u00f3n 1.1.1. El nombre de archivo controlado por el usuario no se sanea correctamente antes de ser utilizado para crear una ruta del sistema de archivos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:elfinder.aspnet_project:elfinder.aspnet:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "6D35213D-AB51-4891-AF70-B3BBC9C9BACA"}]}]}], "references": [{"url": "https://github.com/mguinness/elFinder.AspNet/commit/675049b39284a9e84f0915c71d688da8ebc7d720", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-DOTNET-ELFINDERASPNET-1315153", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mguinness/elFinder.AspNet/commit/675049b39284a9e84f0915c71d688da8ebc7d720"}}