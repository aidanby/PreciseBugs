{"buggy_code": ["<?php\n/**\n * TestLink Open Source Project - http://testlink.sourceforge.net/ \n * This script is distributed under the GNU General Public License 2 or later. \n *\n * @filesource  tree.class.php\n * @package     TestLink\n * @author      Francisco Mancardi\n * @copyright   2005-2020, TestLink community \n * @link        http://www.testlink.org/\n *\n */\n\n/**\n * @package TestLink\n */\nclass tree extends tlObject\n{\n\n  // ORDER IS CRITIC\n  // configurable values - pseudoconstants\n  // VERBOSE description do not map 100% contents of node_types table\n  // Now contains also PSEUDO NODES => build\n  var $node_types = array( 1 => 'testproject','testsuite',\n                                'testcase','tcversion','testplan',\n                                'requirement_spec','requirement','req_version',\n                                'testcase_step','req_revision','requirement_spec_revision',\n                                'build');\n\n  // key: node type id, value: class name\n  var $class_name = array( 1 => 'testproject','testsuite',\n                                'testcase',null,'testplan',\n                                'requirement_spec_mgr','requirement_mgr',null,\n                                null,null,null,null);\n\n  var $nodeWithoutClass = null;\n                                \n  var $node_descr_id = array();\n  \n\n  // Order here means NOTHING\n  var $node_tables_by = array('id' => array(),\n                'name' =>\n                  array('testproject' => 'testprojects',\n                        'testsuite' => 'testsuites',\n                        'testplan' => 'testplans',\n                        'testcase' => 'testcases',\n                        'tcversion' => 'tcversions',\n                        'requirement_spec' =>'req_specs',\n                        'requirement' => 'requirements',  \n                        'req_version' => 'req_versions',\n                        'req_revision' => 'req_versions',\n                        'requirement_spec_revision' => 'req_specs_revisions'));\n  \n  var $node_tables;\n    \n  var $ROOT_NODE_TYPE_ID = 1;\n  var $ROOT_NODE_PARENT_ID = NULL;\n\n  /** @var resource database handler */\n  var $db;\n\n  /**\n   * Class costructor\n   * @param resource &$db reference to database handler\n   */\n  function __construct(&$db) \n  {\n    if( !is_object($db) )\n    {\n      $msg = __METHOD__ . ' :: FATAL Error $db IS NOT AN Object';\n      throw new Exception($msg);\n    }\n    \n    parent::__construct();\n    $this->db = &$db;\n    $this->object_table = $this->tables['nodes_hierarchy'];\n\n    $this->node_tables = $this->node_tables_by['name'];\n    $this->node_descr_id = array_flip($this->node_types);\n    foreach($this->node_tables_by['name'] as $key => $tbl)\n    {\n      $this->node_tables_by['id'][$this->node_descr_id[$key]] = $tbl;\n    }\n\n    $nodeCodeId = array_flip($this->node_types);  \n    $this->nodeWithoutClass[$nodeCodeId['requirement_spec_revision']] = 'deleted when reqspec is deleted';\n\n    \n  }\n\n  /**\n   * get info from node_types table, regarding node types that can be used in a tree. \n   * \n   * @return array map\n   *         key: description: single human friendly string describing node type\n   *             value: numeric code used to identify a node type\n   *\n   */\n  function get_available_node_types() {\n    static $nodeTypes;\n    if( !$nodeTypes ) {\n      $sql = \" SELECT * FROM {$this->tables['node_types']} \"; \n      $nodeTypes = $this->db->fetchColumnsIntoMap($sql,'description','id');\n    }\n    return $nodeTypes;\n  }\n\n  /**\n   * creates a new root node in the hierarchy table.\n   *        root node is tree starting point.\n   * \n   * @param string $name node name; default=''\n   * @return integer node ID\n   */\n  function new_root_node($name = '') \n  {\n    $this->new_node(null,$this->ROOT_NODE_TYPE_ID,$name,1);\n    return $this->db->insert_id($this->object_table);\n  }\n\n  /*\n    function: new_node\n              creates a new node in the hierarchy table.\n              root node is tree starting point.\n\n    args : parent_id: node id of new node parent\n           node_type_id: node type\n           [name]: node name. default=''\n           [node_order]= order on tree structure. default=0\n           [node_id]= id to assign to new node, if you don't want\n                      id bein created automatically.\n                      default=0 -> id must be created automatically.\n    \n    returns: node_id of the new node created\n\n  */\n  function new_node($parent_id,$node_type_id,$name='',$node_order=0,$node_id=0) \n  {\n    $sql = \"INSERT INTO {$this->object_table} \" .\n           \"(name,node_type_id,node_order\";\n\n    $values=\" VALUES('\" . $this->db->prepare_string($name). \"',\" .\n            \" {$node_type_id},\" . intval($node_order);\n    if ($node_id)\n    {\n      $sql .= \",id\";\n      $values .= \",{$node_id}\";\n    }\n    \n    if(is_null($parent_id))\n    {\n      $sql .= \") {$values} )\";\n    }\n    else\n    {\n      $sql .= \",parent_id) {$values},{$parent_id})\";\n    }\n\n    $this->db->exec_query($sql);\n    return ($this->db->insert_id($this->object_table));\n   }\n\n  /*\n  get all node hierarchy info from hierarchy table\n  returns: node_id of the new node created\n  \n  \n  */\n  /*\n    function: get_node_hierarchy_info\n              returns the row from nodes_hierarchy table that has\n              node_id as id.\n              \n              get all node hierarchy info from hierarchy table\n\n    args : node_id: node id\n                    can be an array\n           [parent_id]         \n    \n    returns: \n\n  */\n  function get_node_hierarchy_info($node_id,$parent_id = null,$options=null)\n  {\n\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    $opt = array('nodeTypeID' => null, 'nodeType' => null, \n                 'fields' => 'id,name,parent_id,node_type_id,node_order');\n    $opt = array_merge($opt, (array)$options);\n    $sql = \"SELECT {$opt['fields']} \" . \n           \"FROM {$this->object_table} WHERE id\";\n      \n    $result=null;\n      \n    if( is_array($node_id) )\n    {\n      $sql .= \" IN (\" . implode(\",\",$node_id) . \") \";\n      $result=$this->db->fetchRowsIntoMap($sql,'id');    \n    }\n    else\n    {\n      $sql .= \"= \" . intval($node_id);\n      if( !is_null($parent_id) )\n      {\n        $sql .= \" AND parent_id=\" . intval($parent_id);  \n      }\n\n      if( !is_null($opt['nodeTypeID']) )\n      {\n        $sql .= \" AND node_type_id=\" . intval($opt['nodeTypeID']);  \n      }  \n\n      if( !is_null($opt['nodeType']) )\n      {\n        $sql .= \" AND node_type_id=\" . intval($this->node_descr_id[$opt['nodeType']]);  \n      }  \n\n      $rs = $this->db->get_recordset($sql);\n      $result = !is_null($rs) ? $rs[0] : null;\n    } \n    return $result;\n  }\n\n  /*\n    function: get_subtree_list()\n              get a string representing a list, where elements are separated\n              by comma, with all nodes in tree starting on node_id.\n              node is can be considered as root of subtree.\n              \n    args : node_id: root of subtree\n           node_type_id: null => no filter\n                   if present ONLY NODES OF this type will be ANALIZED and traversed\n                   Example:\n                   TREE\n                     |__ TSUITE_1\n                         |\n                         |__TSUITE_2\n                         |     |__TC_XZ\n                         |\n                         |__TC1\n                         |__TC2\n                         \n                   node_type_id = TC and ROOT=Tree => output=NULL      \n                   node_type_id = TC and ROOT=TSUITE_1 => output=TC1,TC2\n\n                   \n           output: null => list, not null => array\n\n    \n    returns: output=null => list (string with nodes_id, using ',' as list separator).\n             output != null => array\n\n  */\n  function get_subtree_list($node_id,$node_type_id=null,$output=null) {\n    $nodes = array();\n    $this->_get_subtree_list($node_id,$nodes,$node_type_id);\n    $node_list = is_null($output) ? implode(',',$nodes) : $nodes;\n    return($node_list);\n  }\n  \n  \n  /*\n    function: _get_subtree_list()\n              private function (name start with _), that using recursion\n              get an array with all nodes in tree starting on node_id.\n              node is can be considered as root of subtree.\n\n\n    args : node_id: root of subtree\n    \n    returns: array with nodes_id\n\n  */\n  function _get_subtree_list($node_id,&$node_list,$node_type_id=null)\n  {\n    $sql = \"SELECT id from {$this->object_table} WHERE parent_id = {$node_id}\";\n    if( !is_null($node_type_id) )\n    {\n      $sql .=  \" AND node_type_id = {$node_type_id} \"; \n    }\n    $result = $this->db->exec_query($sql);\n    \n    if (!$result || !$this->db->num_rows($result))\n    {\n      return;\n    }\n    \n    while($row = $this->db->fetch_array($result))\n    {\n      $node_list[] = $row['id'];\n      $this->_get_subtree_list($row['id'],$node_list,$node_type_id);  \n    }\n  }\n\n  /*\n    function: delete_subtree\n              delete all element on tree structure that forms a subtree\n              that has as root or starting point node_id.\n\n    args : node_id: root of subtree\n    \n    returns: array with nodes_id\n\n  */\n  function delete_subtree($node_id)\n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $children = $this->get_subtree_list($node_id);\n    $id2del = $node_id;\n    if($children != \"\")\n    {\n      $id2del .= \",{$children}\";  \n    }\n    $sql = \"/* $debugMsg */ DELETE FROM {$this->object_table} WHERE id IN ({$id2del})\";\n  \n    $result = $this->db->exec_query($sql);\n  }\n\n\n  /*\n    function: get_path\n              get list of nodes to traverse when you want to move \n              from node A (node at level N) to node B (node at level M),\n              where MUST BE ALLWAYS M < N, and remembering that level for root node is the minimun.\n              This means path on tree backwards (to the upper levels).\n              An array is used to represent list.\n              Last array element contains data regarding Node A, first element (element with index 0) \n              is data regarding child of node B.\n              What data is returned depends on value of optional argument 'format'.\n              \n              Attention:\n              1 - destination node (node B) will be NOT INCLUDED in result.\n              2 - This is refactoring of original get_path method.\n\n    args : node_id: start of path\n           [to_node_id]: destination node. default null -> path to tree root.\n           [format]: default 'full' \n                     defines type of elements of result array.\n                     \n                     format='full'\n                     Element is a map with following keys:\n                     id\n                     parent_id\n                     node_type_id\n                     node_order\n                     node_table\n                     name\n                     \n                     Example\n                     Is tree is :\n                                \n                              null \n                                \\\n                               id=1   <--- Tree Root\n                                 |\n                                 + ------+\n                               /   \\      \\\n                            id=9   id=2   id=8\n                                    \\\n                                     id=3\n                                      \\\n                                       id=4     \n                    \n                    \n                    get_path(4), returns:\n                          \n                    (\n                     [0] => Array([id] => 2\n                                  [parent_id] => 1\n                                  [node_type_id] => 2\n                                  [node_order] => 1\n                                  [node_table] => testsuites\n                                  [name] => TS1)\n        \n                     [1] => Array([id] => 3\n                                  [parent_id] => 2\n                                  [node_type_id] => 2\n                                  [node_order] => 1\n                                  [node_table] => testsuites\n                                  [name] => TS2)\n        \n                     [2] => Array([id] => 4\n                                  [parent_id] => 3\n                                  [node_type_id] => 3\n                                  [node_order] => 0\n                                  [node_table] => testcases\n                                  [name] => TC1)\n                    )\n                  \n                    \n                    \n                    format='simple'\n                    every element is a number=PARENT ID, array index = value\n                    For the above example result will be:\n                    (\n                     [1] => 1\n                     [2] => 2\n                     [3] => 3\n                    )\n                    \n                    \n\n    returns: array\n\n  */\n  function get_path($node_id,$to_node_id = null,$format = 'full')  {\n    $the_path = array();\n    $this->_get_path($node_id,$the_path,$to_node_id,$format); \n    if( !is_null($the_path) && count($the_path) > 0 ) {\n      $the_path = array_reverse($the_path);  \n    }\n    return $the_path;\n  }\n\n  /**\n   *\n   */\n  function get_path_new($node_id,$to_node_id = null,$format = 'full')  {\n    $the_path = array();\n    $trip='';\n    $matrioska = array();\n    $this->_get_path($node_id,$the_path,$to_node_id,$format); \n    \n    if( !is_null($the_path) && ($loop2do=count($the_path)) > 0 ) {\n      $the_path=array_reverse($the_path);  \n      $matrioska = $the_path[0];\n      $matrioska['childNodes']=array();\n      $target = &$matrioska['childNodes'];\n\n      $trip = '';\n      for($idx=0; $idx < ($loop2do-1); $idx++)\n      {\n        $trip[] = $the_path[$idx]['id']; // . \"({$idx})\";\n        $target[0] = $the_path[$idx+1];\n        if($the_path[$idx+1]['node_table'] != 'testcases')\n        {\n          $target = &$target[0]['childNodes'];\n        }  \n      }\n    }\n\n    return array($trip,$the_path);\n  }\n\n\n\n  /*\n    function: _get_path\n              This is refactoring of original get_path method.\n              Attention:\n              returns node in inverse order, that was done for original get_path\n  \n    args : node_id: start of path\n           node_list: passed by reference, to build the result.\n           [to_node_id]: destination node. default null -> path to tree root.\n           [format]: default 'full' \n    \n    returns: array\n  */\n  function _get_path($node_id,&$node_list,$to_node_id=null,$format='full') \n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n\n    // look up the parent of this node\n    $sql = \"/* $debugMsg */ \" . \n           \" SELECT id,name,parent_id,node_type_id,node_order \" .\n           \" FROM {$this->object_table} WHERE id = \" . intval($node_id);\n    \n    $result = $this->db->exec_query($sql);\n    if( $this->db->num_rows($result) == 0 ) {\n      $node_list=null;\n      return;   \n    }\n    \n    while ( $row = $this->db->fetch_array($result) ) {\n      // check & abort\n      if ($row['parent_id'] == $row['id']) {\n        throw new Exception(\"id = parent_id = \" . $row['id'], 1);\n      } \n\n      // only continue if this $node isn't the root node\n      // (that's the node with no parent)\n      if ($row['parent_id'] != '' && $row['id'] != $to_node_id) {\n        // the last part of the path to $node, is the name\n        // of the parent of $node\n        switch($format) {\n          case 'full':\n            $row['node_table'] = $this->node_tables_by['id'][$row['node_type_id']];\n            $node_list[] = $row;\n          break;    \n            \n          case 'simple':\n            // Warning: starting node is NOT INCLUDED in node_list\n            $node_list[$row['parent_id']] = $row['parent_id'];\n          break;    \n            \n          case 'points':\n            $node_list[] = $row['id'];\n          break;    \n\n          case 'simple_me':\n            if( is_null($node_list) ) {\n              $node_list[$row['id']] = $row['id'];\n            } else {\n              $node_list[$row['parent_id']] = $row['parent_id'];\n            }            \n          break;    \n\n          case 'name':\n            $node_list[] = $row['name'];\n          break;    \n\n        }\n        \n        // we should add the path to the parent of this node to the path\n        $this->_get_path($row['parent_id'],$node_list,$to_node_id,$format);\n      }\n    }\n  }\n  \n  \n  \n  \n  /*\n    function: change_parent\n              change node parent, using this method you implement move operation.\n  \n    args : node_id: node/nodes that need(s) to changed.\n                    mixed type: single id or array containing set of id.\n                    \n           parent_id: new parent\n    \n    returns: 1 -> operation OK\n    \n  */\n  function change_parent($node_id, $parent_id) \n  {\n    $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n    if( is_array($node_id) )\n    {\n      $id_list = implode(\",\",$node_id);\n      $where_clause = \" WHERE id IN ($id_list) \";\n    }\n    else\n    {\n      $where_clause=\" WHERE id = {$node_id}\";\n    }\n    $sql = \"/* $debugMsg */ UPDATE {$this->object_table} \" .\n           \" SET parent_id = \" . $this->db->prepare_int($parent_id) . \" {$where_clause}\";\n    \n    $result = $this->db->exec_query($sql);\n    \n    return $result ? 1 : 0;\n  }\n   \n   \n  /*\n    function: get_children\n              get nodes that have id as parent node.\n              Children can be filtering according to node type.\n              \n    args : id: node \n           [exclude_node_types]: map \n                                 key: verbose description of node type to exclude.\n                                      see get_available_node_types.\n                                 value: anything is ok\n    \n    returns: array of maps that contain children nodes.\n             map structure:\n             id \n             name\n             parent_id\n             node_type_id\n             node_order\n             node_table\n            \n             \n  */\n  function get_children($id,$exclude_node_types=null,$opt=null) {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $my['opt'] = array('accessKey' => null);\n    $my['opt'] = array_merge($my['opt'], (array)$opt);\n  \n    $sql = \"/* $debugMsg */ \" .\n           \" SELECT id,name,parent_id,node_type_id,node_order FROM {$this->object_table} \" .\n           \" WHERE parent_id = \" . $this->db->prepare_int($id) . \" ORDER BY node_order,id\";\n      \n    $node_list=array();  \n    $result = $this->db->exec_query($sql);\n      \n    if( $this->db->num_rows($result) == 0 )\n    {\n      return(null);   \n    }\n      \n    $xdx = 0;  \n    while ( $row = $this->db->fetch_array($result) )\n    {\n      if( !isset($exclude_node_types[$this->node_types[$row['node_type_id']]]))\n      {\n        $node_table = $this->node_tables_by['id'][$row['node_type_id']];\n\n        $ak = is_null($my['opt']['accessKey']) ? $xdx : $row[$my['opt']['accessKey']];\n        $node_list[$ak] = array('id' => $row['id'], 'parent_id' => $row['parent_id'],\n                                'node_type_id' => $row['node_type_id'],\n                                'node_order' => $row['node_order'],\n                                'node_table' => $node_table,'name' => $row['name']);\n        $xdx++;      \n      }\n    }\n    return $node_list;\n  }\n  \n   \n  /*\n    function: change_order_bulk\n              change order for all nodes is present in nodes array.\n              Order of node in tree, is set to position node has in nodes array.\n  \n    args :\n           nodes: array where value is node_id. Node order = node position on array\n     \n    returns: -\n  \n  */\n  function change_order_bulk($nodes) \n  {\n    foreach($nodes as $order => $node_id)\n    {\n      $order = abs(intval($order));\n      $node_id = intval($node_id);\n        $sql = \"UPDATE {$this->object_table} SET node_order = {$order} WHERE id = {$node_id}\";\n        $result = $this->db->exec_query($sql);\n    }\n  }\n  \n  \n  /*\n    function: change_child_order\n              will change order of children of parent id, to position\n              choosen node on top or bottom of children.             \n  \n    args:\n          parent_id: node used as root of a tree.\n          node_id: node which we want to reposition\n          $top_bottom: possible values 'top', 'bottom'\n          [exclude_node_types]: map \n                                key: verbose description of node type to exclude.\n                                     see get_available_node_types.\n                                value: anything is ok\n  \n     \n    returns: -\n  \n  */\n  function change_child_order($parent_id,$node_id,$top_bottom,$exclude_node_types=null)\n  {\n      $node_type_filter='';\n      if( !is_null($exclude_node_types) )\n      {\n         $types=implode(\"','\",array_keys($exclude_node_types));  \n         $node_type_filter=\" AND NT.description NOT IN ('{$types}') \";\n      }\n      \n      $sql = \" SELECT NH.id, NH.node_order, NH.name \" .\n             \" FROM {$this->object_table} NH, {$this->tables['node_types']} NT \" .\n             \" WHERE NH.node_type_id=NT.id \" .\n             \" AND NH.parent_id = {$parent_id} AND NH.id <> {$node_id} \" . \n             $node_type_filter .\n             \" ORDER BY NH.node_order,NH.id\";\n      $children=$this->db->get_recordset($sql);\n      \n      switch ($top_bottom)\n      {\n          case 'top':\n          $no[]=$node_id;\n          if( !is_null($children) )\n          {\n              foreach($children as $key => $value)\n              {\n                $no[]=$value['id'];     \n              }\n          }\n          break;\n            \n          case 'bottom':  \n          $new_order=$this->getBottomOrder($parent_id)+1;\n          $no[$new_order]=$node_id;\n          break;\n      }\n      $this->change_order_bulk($no);    \n  } \n  \n  /*\n    function: getBottomOrder\n              given a node id to be used as parent, returns  the max(node_order) from the children nodes.\n              We consider this bottom order.\n  \n    args: parentID: \n    \n    returns: order\n  \n  */\n  function getBottomOrder($parentID,$opt=null) {\n    $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n    \n    $my['opt'] = array();\n    $my['opt'] = array_merge(array('node_type' => null),(array)$opt);\n\n    \n    $sql = \"SELECT MAX(node_order) AS max_order\" .\n           \" FROM {$this->object_table} \" . \n           \" WHERE parent_id={$parentID} \";\n\n    if(!is_null($my['opt']['node_type'])) {\n      $sql .= \" AND node_type_id = \" . $this->node_descr_id[$my['opt']['node_type']];\n    }       \n\n    $sql .= \" GROUP BY parent_id \";\n    $rs=$this->db->get_recordset($sql);\n      \n    return $rs[0]['max_order'];     \n  }\n  \n  \n  \n  \n  /*\n    function: get_subtree\n              Giving a node_id, get the nodes that forma s subtree that \n              has node_id as root or starting point.\n  \n              Is possible to exclude:\n              branches that has as staring node, node of certain types.\n              children of some node types.\n              full branches.\n              \n  \n    args :\n      [filters] map with following keys  \n  \n          [exclude_node_types]: map/hash. \n                                default: null -> no exclusion filter will be applied.\n                                Branches starting with nodes of type detailed, will not be\n                                visited => no information will be returned.\n                                key: verbose description of node type to exclude.\n                                     (see get_available_node_types).\n                                value: can be any value, because is not used,anyway is suggested \n                                       to use 'exclude_me' as value.\n                                \n                                Example:\n                                array('testplan' => 'exclude_me')\n                                Node of type tesplan, will be excluded. \n                               \n                               \n          \n          [exclude_children_of]: map/hash\n                                default: null -> no exclusion filter will be applied.\n                                When traversing tree if the type of a node child, of node under analisys,\n                                is contained in this map, traversing of branch starting with this child node\n                                will not be done.\n                                key: verbose description of node type to exclude.\n                                     (see get_available_node_types).\n                                value: can be any value, because is not used,anyway is suggested \n                                       to use 'exclude_my_children' as value.\n                                \n                                Example:        \n                                array('testcase' => 'exclude_my_children')                               \n                                Children of testcase nodes, (tcversion nodes) will be EXCLUDED.         \n          \n          [exclude_branches]: map/hash. \n                              default: null -> no exclusion filter will be applied.\n                              key: node id.\n                              value: anything is ok.\n                              \n                              When traversing tree branches that have these node is, will\n                              not be visited => no information will be retrieved.\n          \n          \n          [additionalWhereClause]: sql filter to include in sql sentence used to retrieve nodes.\n                                   default: null -> no action taken.\n                                \n          [family]: used to include guide the tree traversal.\n                    map where key = node_id TO INCLUDE ON traversal\n                          value = map where each key is a CHILD that HAS TO BE INCLUDED in return set.                      \n                                \n          [options]: map with following keys\n                                \n          [recursive]: changes structure of returned structure.\n                        default: false -> a flat array will be generated\n                                 true  -> a map with recursive structure will be generated.\n                        \n                        false returns array, every element is a map with following keys:\n                        \n                        id\n                        parent_id\n                        node_type_id\n                        node_order\n                        node_table\n                        name\n                        \n                        \n                        true returns a map, with only one element\n                        key: childNodes.\n                        value: array, that represents a tree branch.\n                               Array elements are maps with following keys:\n                        \n                               id\n                               parent_id\n                               node_type_id\n                               node_order\n                               node_table\n                               name\n                               childNodes -> (array)\n                        \n            \n    returns: array or map\n    \n  \n  */\n  function get_subtree($node_id,$filters=null,$options=null) {\n    $my['filters'] = array('exclude_node_types' => null, 'exclude_children_of' => null,\n                           'exclude_branches' => null,'additionalWhereClause' => '', 'family' => null);\n                               \n    $my['options'] = array('recursive' => false, 'order_cfg' => array(\"type\" =>'spec_order'), \n                           'output' => 'essential', 'key_type' => 'std', 'addJoin' => '', 'addFields' => '');\n  \n    // Cast to array to handle $options = null\n    $my['filters'] = array_merge($my['filters'], (array)$filters);\n    $my['options'] = array_merge($my['options'], (array)$options);\n  \n    $the_subtree = array();\n       \n    // Generate NOT IN CLAUSE to exclude some node types\n    // $not_in_clause = $my['filters']['additionalWhereClause'];\n    if(!is_null($my['filters']['exclude_node_types']))\n    {\n      $exclude = array();\n      foreach($my['filters']['exclude_node_types'] as $the_key => $elem)\n      {\n        $exclude[] = $this->node_descr_id[$the_key];\n      }\n      $my['filters']['additionalWhereClause'] .= \" AND node_type_id NOT IN (\" . implode(\",\",$exclude) . \")\";\n    }\n  \n    $method2call = $my['options']['recursive'] ? '_get_subtree_rec' : '_get_subtree';\n    $qnum = $this->$method2call($node_id,$the_subtree,$my['filters'],$my['options']);\n    return $the_subtree;\n  }\n  \n  /**\n   *\n   */  \n  function _get_subtree($node_id,&$node_list,$filters = null, $options = null)\n  {\n    static $my;\n    if(!$my)\n    {\n      $my['filters'] = array('exclude_children_of' => null,'exclude_branches' => null,\n                             'additionalWhereClause' => '', 'family' => null);\n                                 \n      $my['options'] = array('order_cfg' => array(\"type\" =>'spec_order'),\n                             'output' => 'full', 'key_type' => 'std',\n                             'addJoin' => '', 'addFields' => '');\n  \n    }\n\n    $my['filters'] = array_merge($my['filters'], (array)$filters);\n    $my['options'] = array_merge($my['options'], (array)$options);\n       \n    switch($my['options']['order_cfg']['type'])\n    {\n      case 'spec_order':\n        $sql = \" SELECT id,name,parent_id,node_type_id,node_order \" .\n               $my['options']['addFields'] .\n               \" FROM {$this->object_table} {$my['options']['addJoin']} \" .\n               \" WHERE parent_id = {$node_id} \" .\n               \" {$my['filters']['additionalWhereClause']}\" .\n               \" ORDER BY node_order,id\";\n      break;\n\n      case 'rspec':\n        $sql = \" SELECT OBT.id,name,parent_id,node_type_id,node_order,\" .\n               \" RSPEC.doc_id \" .\n               \" FROM {$this->object_table} AS OBT \" .\n               \" JOIN {$this->tables['req_specs']} AS RSPEC \" .\n               \" ON RSPEC.id = OBT.id \" .\n               \" WHERE parent_id = {$node_id} \" .\n               \" {$my['filters']['additionalWhereClause']}\" .\n               \" ORDER BY node_order,OBT.id\";\n      break;\n\n      case 'exec_order':\n        // REMEMBER THAT DISTINCT IS NOT NEEDED when you does UNION WITHOUT ALL\n        //\n        // First query get Nodes that ARE NOT test case => test suites\n        // Second query get the TEST CASES\n        //\n        $sql = \"SELECT * FROM ( SELECT NH.node_order AS spec_order,\" . \n               \"                NH.node_order AS node_order, NH.id, NH.parent_id,\" . \n               \"                NH.name, NH.node_type_id, 0 AS tcversion_id\" .\n               \"                FROM {$this->object_table} NH, {$this->tables['node_types']} NT\" .\n               \"                WHERE parent_id = {$node_id}\" .\n               \"                AND NH.node_type_id=NT.id\" .\n               \"                AND NT.description <> 'testcase' {$my['filters']['additionalWhereClause']}\" .\n               \"                UNION\" .\n               \"                SELECT NHA.node_order AS spec_order, \" .\n               \"                       T.node_order AS node_order, NHA.id, NHA.parent_id, \" .\n               \"                       NHA.name, NHA.node_type_id, T.tcversion_id\" .\n               \"                FROM {$this->object_table} NHA, {$this->object_table} NHB,\" .\n               \"                     {$this->tables['testplan_tcversions']}  T,{$this->tables['node_types']} NT\" .\n               \"                WHERE NHA.id=NHB.parent_id \" .\n               \"                AND NHA.node_type_id=NT.id\" .\n               \"                AND NHB.id=T.tcversion_id \" .\n               \"                AND NT.description = 'testcase'\" .\n               \"                AND NHA.parent_id = {$node_id}\" .\n               \"                AND T.testplan_id = {$my['options']['order_cfg']['tplan_id']}) AC\" .\n               \"                ORDER BY node_order,spec_order,id\";\n        break;\n\n        case 'req_order':\n          $sql = \" SELECT NH_TC.id,NH_TC.name,NH_TC.parent_id,\" .\n                 \" NH_TC.node_type_id,NH_TC.node_order \" .\n                 \" {$my['options']['addFields']}\" .\n                 \" FROM {$this->object_table} AS NH_TC \" .\n                 \" {$my['options']['addJoin']} \" .\n                 \" JOIN {$this->tables['req_coverage']} RC \" .\n                 \" ON RC.testcase_id = NH_TC.id \" .\n                 \" WHERE RC.req_id = {$node_id} \" .\n                 \" {$my['filters']['additionalWhereClause']}\" .\n                 \" ORDER BY NH_TC.node_order,NH_TC.id\";\n        break;\n\n      }\n\n      $result = $this->db->exec_query($sql);\n    \n      if( $this->db->num_rows($result) == 0 )\n      {\n         return;   \n      }\n    \n      while ( $row = $this->db->fetch_array($result) )\n      {\n        if( !isset($my['filters']['exclude_branches'][$row['id']]) )\n        {  \n            \n        $node_table = $this->node_tables[$this->node_types[$row['node_type_id']]];\n\n        \n        switch($my['options']['output'])\n        {\n          case 'id':\n            $node_list[] = $row['id'];\n          break;  \n          \n          case 'essential':\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n\n          case 'rspec':\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'doc_id' => $row['doc_id'],\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n          \n\n          case 'full':\n          default:\n            // this choice\n            // 'tcversion_id' => (isset($row['parent_id']) ? $row['parent_id'] : -1),\n            // need to be documented and REVIEWED, because can generate confusion\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'tcversion_id' => (isset($row['parent_id']) ? $row['parent_id'] : -1),\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n              }\n        // Basically we use this because:\n        // 1. Sometimes we don't want the children if the parent is a testcase,\n        //    due to the version management\n        //\n        // 2. Sometime we want to exclude all descendants (branch) of a node.\n        //\n        // [franciscom]: \n        // I think ( but I have no figures to backup my thoughts) doing this check and \n        // avoiding the function call is better that passing a condition that will result\n        // in a null result set.\n        //\n        //\n        if( !isset($my['filters']['exclude_children_of'][$this->node_types[$row['node_type_id']]]) && \n            !isset($my['filters']['exclude_branches'][$row['id']]) )\n        {\n          $this->_get_subtree($row['id'],$node_list,$filters,$options);\n        }\n        }\n      }\n  } // function end\n   \n  /**\n   *\n   */   \n  function _get_subtree_rec($node_id,&$pnode,$filters = null, $options = null)\n  {\n    static $tcNodeTypeID;\n    static $qnum;\n    static $my;\n    static $platform_filter;\n    static $fclause;\n    static $exclude_branches;\n    static $exclude_children_of;\n    \n    if (!$tcNodeTypeID)\n    {\n      $tcNodeTypeID = $this->node_descr_id['testcase'];\n\n      $qnum=0;\n\n      $my['filters'] = array('exclude_children_of' => null,'exclude_branches' => null,\n                          'additionalWhereClause' => '', 'family' => null);\n                               \n      $my['options'] = array('order_cfg' => array(\"type\" =>'spec_order'),'key_type' => 'std',\n                          'remove_empty_nodes_of_type' => null);\n\n      // Cast to array to handle $options = null\n      $my['filters'] = array_merge($my['filters'], (array)$filters);\n      $my['options'] = array_merge($my['options'], (array)$options);\n\n      $platform_filter = \"\";\n      if( isset($my['options']['order_cfg']['platform_id']) && \n        ($safe_pid = intval($my['options']['order_cfg']['platform_id']) ) > 0 )\n      {\n        $platform_filter = \" /* Platform filter */ \" . \n                   \" AND T.platform_id = \" . $safe_pid;\n      }\n      \n      $fclause = \" AND node_type_id <> {$tcNodeTypeID} {$my['filters']['additionalWhereClause']} \";\n      \n\n      if( !is_null($my['options']['remove_empty_nodes_of_type']) )\n      {\n        // this way I can manage code or description      \n        if( !is_numeric($my['options']['remove_empty_nodes_of_type']) )\n        {\n          $my['options']['remove_empty_nodes_of_type'] = \n                  $this->node_descr_id[$my['options']['remove_empty_nodes_of_type']];\n        }\n      }\n      \n\n      $exclude_branches = $my['filters']['exclude_branches'];\n      $exclude_children_of = $my['filters']['exclude_children_of'];  \n    }\n      \n      switch($my['options']['order_cfg']['type'])\n      {\n          case 'spec_order':\n            $sql = \" SELECT id,name,parent_id,node_type_id,node_order FROM {$this->object_table} \" .\n                      \" WHERE parent_id = {$node_id} {$my['filters']['additionalWhereClause']}\" .\n                 \" ORDER BY node_order,id\";\n        break;\n          \n        case 'exec_order':\n      // Hmmm, no action regarding platforms. is OK ??\n      //\n      // REMEMBER THAT DISTINCT IS NOT NEEDED when you does UNION\n      //\n      // Important Notice:\n      // Second part of UNION, allows to get from nodes hierarchy,\n      // only test cases that has a version linked to test plan.\n      //\n      $sql=\"SELECT * FROM ( SELECT NH.node_order AS spec_order,\" . \n           \"                NH.node_order AS node_order, NH.id, NH.parent_id,\" . \n           \"                NH.name, NH.node_type_id, 0 AS tcversion_id \" .\n           \"                FROM {$this->tables['nodes_hierarchy']}  NH\" .\n           \"                WHERE parent_id = {$node_id} {$fclause} \" .\n           \"                UNION\" .\n           \"                SELECT NHA.node_order AS spec_order, \" .\n           \"                       T.node_order AS node_order, NHA.id, NHA.parent_id, \" .\n           \"                       NHA.name, NHA.node_type_id, T.tcversion_id \" .\n           \"                FROM {$this->tables['nodes_hierarchy']} NHA, \" .\n           \"                     {$this->tables['nodes_hierarchy']} NHB,\" .\n           \"                     {$this->tables['testplan_tcversions']} T\" .\n           \"                WHERE NHA.id=NHB.parent_id \" .\n           \"                AND NHA.node_type_id = {$tcNodeTypeID}\" .\n           \"                AND NHB.id=T.tcversion_id \" .\n           \"                AND NHA.parent_id = {$node_id} {$platform_filter} \" .  \n           \"                AND T.testplan_id = {$my['options']['order_cfg']['tplan_id']}) AC\" .\n           \"                ORDER BY node_order,spec_order,id\";\n      break;\n          \n      }\n    \n      $result = $this->db->exec_query($sql);\n      $qnum++;\n      while($row = $this->db->fetch_array($result))\n      {\n        if(!isset($exclude_branches[$row['id']]))\n        {  \n            switch($my['options']['key_type'])\n            {\n                  case 'std':\n                      $node =  array('parent_id' => $row['parent_id'],\n                               'id' => $row['id'],\n                                         'name' => $row['name'],\n                                         'childNodes' => null,\n                                         'node_table' => $this->node_tables_by['id'][$row['node_type_id']],\n                                         'node_type_id' => $row['node_type_id'],\n                                         'node_order' => $row['node_order']);\n                                  \n                      if( isset($row['tcversion_id']) && $row['tcversion_id'] > 0)\n                      {\n                        $node['tcversion_id'] = $row['tcversion_id'];\n                      }             \n                    break;\n                  \n                 case 'extjs':\n                      $node =  array('text' => $row['name'],\n                                     'id' => $row['id'],\n                                         'parent_id' => $row['parent_id'],\n                                         'node_type_id' => $row['node_type_id'],\n                                         'position' => $row['node_order'],\n                                  'childNodes' => null,\n                                         'leaf' => false);\n            \n                        switch($this->node_types[$row['node_type_id']])\n                        {\n                            case 'testproject':\n                            case 'testsuite':\n                                $node['childNodes'] = null;\n                              break;  \n            \n                            case 'testcase':\n                                $node['leaf'] = true;\n                              break;\n                        } \n                    break;\n            }  \n              \n            // Basically we use this because:\n            // 1. Sometimes we don't want the children if the parent is a testcase,\n            //    due to the version management\n            //\n            // 2. Sometime we want to exclude all descendants (branch) of a node.\n            //\n            // [franciscom]: \n            // I think ( but I have no figures to backup my thoughts) doing this check and \n            // avoiding the function call is better that passing a condition that will result\n            // in a null result set.\n            //\n            //\n            if(!isset($exclude_children_of[$this->node_types[$row['node_type_id']]]) && \n               !isset($exclude_branches[$row['id']]))\n          {\n              $this->_get_subtree_rec($row['id'],$node,$my['filters'],$my['options']);\n            }\n\n        // Have added this logic, because when export test plan will be developed\n        // having a test spec tree where test suites that do not contribute to test plan\n        // are pruned/removed is very important, to avoid additional processing\n        //            \n            $doRemove = is_null($node['childNodes']) && \n                      $node['node_type_id'] == $my['options']['remove_empty_nodes_of_type'];\n            \n            if(!$doRemove)\n            {\n            $pnode['childNodes'][] = $node;\n          }  \n        } // if(!isset($exclude_branches[$rowID]))\n      } //while\n      return $qnum;\n  }\n\n  /**\n   * function: get_full_path_verbose\n   * when path can not be found instead of null, anyway a map will be returned, with key=itemID value=NULL\n   * @internal revisions\n   **/\n  function get_full_path_verbose(&$items,$options=null) {\n      $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n      $goto_root=null;\n      $path_to=null;\n      $all_nodes=array();\n      $path_format = 'simple';\n      $output_format = 'simple';\n      \n      if( !is_null($options) )\n      {\n        // not a good solution, but Quick & Dirty\n        $path_format = isset($options['path_format']) ? $options['path_format'] : $path_format;\n        if(  !isset($options['path_format']) )\n        {\n          $path_format = isset($options['include_starting_point']) ? 'points' : $path_format;\n        }\n        $output_format = isset($options['output_format']) ? $options['output_format'] : $output_format;\n      }\n      \n      // according to count($items) we will try to optimize, sorry for magic number\n      if( count((array)$items) > 200)\n      {\n        $xitems = array_flip((array)$items);\n        $xsql = \" SELECT parent_id,id \" . \n                \" FROM {$this->tables['nodes_hierarchy']} \" . \n                \" WHERE id IN (\" . implode(',',array_keys($xitems)) . \")\";\n\n        $xmen = $this->db->fetchRowsIntoMap($xsql,'parent_id',database::CUMULATIVE);\n        $all_nodes = array();      \n        foreach($xmen as $parent_id => &$children)\n        {\n          $paty = $this->get_path($parent_id,$goto_root,$path_format);\n          $paty[] = $parent_id;\n        \n          $all_nodes = array_merge($all_nodes,$paty);\n          foreach($children as &$item)\n          {\n             $path_to[$item['id']]['name'] = $stairway2heaven[$item['id']] = $paty;\n             $all_nodes[] = $item['id'];  \n          }\n        }\n        unset($xmen);\n      }\n      else\n      {\n        foreach((array)$items as $item_id)\n        {\n          $stairway2heaven[$item_id] = $this->get_path($item_id,$goto_root,$path_format);\n          $path_to[$item_id]['name'] = $stairway2heaven[$item_id];\n          $all_nodes = array_merge($all_nodes,(array)$path_to[$item_id]['name']);\n        }\n      }\n      \n      $status_ok = (!is_null($all_nodes) && count($all_nodes) > 0);\n      if( $status_ok )\n      { \n        // get only different items, to get descriptions\n        $unique_nodes=implode(',',array_unique($all_nodes));\n\n        $sql=\"/* $debugMsg */ \" . \n             \" SELECT id,name FROM {$this->tables['nodes_hierarchy']}  WHERE id IN ({$unique_nodes})\"; \n        $decode=$this->db->fetchRowsIntoMap($sql,'id');\n        \n        foreach($path_to as $key => $elem)\n        {\n          foreach($elem['name'] as $idx => $node_id)\n          {\n            $path_to[$key]['name'][$idx]=$decode[$node_id]['name'];\n             $path_to[$key]['node_id'][$idx]=$node_id;\n          }\n        }\n        unset($decode);\n      }  \n      else\n      {\n        $path_to=null;\n      } \n        \n        if( !is_null($path_to) )\n        {\n          switch ($output_format)\n          {\n            case 'path_as_string':\n            case 'stairway2heaven':\n        $flat_path=null;\n        foreach($path_to as $item_id => $pieces)\n        {\n          // remove root node\n          unset($pieces['name'][0]);\n          $flat_path[$item_id]=implode('/',$pieces['name']);\n        }\n        if($output_format == 'path_as_string')\n        {\n          $path_to = $flat_path;\n            }\n            else\n            {\n              $path_to = null;\n              $path_to['flat'] = $flat_path;\n              $path_to['staircase'] = $stairway2heaven;\n            }\n            break;\n            \n            case 'id_name':\n            break;\n            \n            case 'simple':  \n            default:\n            $keySet = array_keys($path_to);\n            foreach($keySet as $key)\n            {\n              $path_to[$key] = $path_to[$key]['name'];\n            }\n            break;\n          }  \n        }\n        unset($stairway2heaven);\n      return $path_to; \n  }\n\n\n  /**\n   * check if there is a sibbling node of same type that has same name\n   *\n   * @param string name: name to check\n   * @param int node_type_id: node types to check.\n   * @param int id: optional. exclude this node id from result set\n   *                this is useful when you want to check for name\n   *                existence during an update operation.\n   *                Using id you get node parent, to get sibblings.\n   *                If null parent_id argument must be present\n   *\n   * @param int parent_id: optional. Mandatory if id is null\n   *                       Used to get children nodes to check for\n   *                       name existence.\n   *\n   *                          \n   * @return map ret: ret['status']=1 if name exists\n   *                                0 if name does not exist\n   *                  ret['msg']= localized message\n   *                                \n   */\n  function nodeNameExists($name,$node_type_id,$id=null,$parent_id=null)\n  {\n    $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n    $ret['status'] = 0;\n    $ret['msg'] = '';\n    if( is_null($id) && is_null($parent_id) )\n    {\n      $msg = $debugMsg . 'Error on call $id and $parent_id can not be both null';\n      throw new Exception($msg);\n    }          \n        \n        \n    $additionalFilters = '';\n    $parentNodeID = intval($parent_id);\n    if( !is_null($id) )\n    {\n      // Try to get parent id if not provided on method call.\n      if( is_null($parentNodeID) || $parentNodeID <= 0)\n      {\n        $sql = \"/* {$debugMsg} */ \" . \n               \" SELECT parent_id FROM {$this->object_table} NHA \" .\n               \" WHERE NHA.id = \" . $this->db->prepare_int($id);\n        $rs = $this->db->get_recordset($sql);\n        $parentNodeID = intval($rs[0]['parent_id']);     \n            \n      }\n      $additionalFilters = \" AND NHA.id <> \" . $this->db->prepare_int($id);\n    }    \n\n    if( $parentNodeID <= 0)\n    {\n      $msg = $debugMsg . ' FATAL Error $parentNodeID can not be <= 0';\n      throw new Exception($msg);\n    }          \n        \n        \n    $sql = \"/* {$debugMsg} */ \" . \n           \" SELECT count(0) AS qty FROM {$this->object_table} NHA \" .\n           \" WHERE NHA.node_type_id  = {$node_type_id} \" .\n           \" AND NHA.name = '\" . $this->db->prepare_string($name) . \"'\" .\n           \" AND NHA.parent_id = \" . $this->db->prepare_int($parentNodeID) . \" {$additionalFilters} \"; \n \n    $rs = $this->db->get_recordset($sql);\n    if( $rs[0]['qty'] > 0)\n    {\n      $ret['status'] = 1;\n      $ret['msg'] = sprintf(lang_get('name_already_exists'),$name);\n    }\n      \n    return $ret;\n  }\n\n  /**\n   * getTreeRoot()\n   *\n   */\n  function getTreeRoot($node_id) {\n    $path = (array)$this->get_path($node_id);\n    $path_len = count($path);\n    $root_node_id = ($path_len > 0)? $path[0]['parent_id'] : $node_id;\n    return $root_node_id;\n  }\n\n\n  /**\n   * delete_subtree_objects()\n   * \n   * ATTENTION: subtree root node ($node_id?? or root_id?) IS NOT DELETED.\n   *\n   */\n  function delete_subtree_objects($root_id,$node_id,$additionalWhereClause = '',$exclude_children_of = null,\n                                  $exclude_branches = null)\n  {\n    static $debugMsg;\n    if( is_null($debugMsg) )\n    {\n      $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    }\n    \n    $sql = \"/* $debugMsg */ SELECT NH.* FROM {$this->object_table} NH \" .\n           \" WHERE NH.parent_id = \" . $this->db->prepare_int($node_id) . \" {$additionalWhereClause} \";\n    $rs = $this->db->get_recordset($sql);\n    if( !is_null($rs) )\n    {\n      foreach($rs as $row)\n      {  \n        $rowID = $row['id'];\n        $nodeTypeID = $row['node_type_id'];\n        $nodeType = $this->node_types[$nodeTypeID];\n        $nodeClassName = $this->class_name[$nodeTypeID];\n        if(!isset($exclude_branches[$rowID]))\n        {  \n          // Basically we use this because:\n          // 1. Sometimes we don't want the children if the parent is a testcase,\n          //    due to the version management\n          //\n          // 2. Sometime we want to exclude all descendants (branch) of a node.\n          //\n          if(!isset($exclude_children_of[$nodeType]) && !isset($exclude_branches[$rowID]))\n          {\n            // I'm paying not having commented this well\n            // Why I've set root_id to null ?\n            // doing this when traversing a tree, containers under level of subtree root\n            // will not be deleted => and this seems to be wrong.\n            $this->delete_subtree_objects($root_id,$rowID,$additionalWhereClause,$exclude_children_of,$exclude_branches);\n          }\n          else\n          {\n            // For us in this method context this node is a leaf => just delete\n            if( !is_null($nodeClassName) )\n            { \n              $item_mgr = new $nodeClassName($this->db);\n              $item_mgr->delete($rowID);        \n            }\n            else if (isset($this->nodeWithoutClass[$nodeTypeID]))\n            {\n            }  \n            else\n            {\n              // need to signal error - TO BE DONE\n              // echo '<br>AUCH!!!';\n            } \n          }\n        } // if(!isset($exclude_branches[$rowID]))\n      } //while\n    }\n    \n    // Must delete myself if I'm empty, only if I'm not subtree root.\n    // Done this way to avoid infinte recursion for some type of nodes\n    // that use this method as it's delete method. (example testproject).\n    \n    // Hmmm, need to recheck if this condition is ok\n    // \n    if( !is_null($root_id) && ($node_id != $root_id) )\n    {\n      $children = (array)$this->db->get_recordset($sql);\n      if( count($children) == 0 )\n      {\n        $sql2 = \"/* $debugMsg */ SELECT NH.* FROM {$this->object_table} NH \" .\n                \" WHERE NH.id = \" . $this->db->prepare_int($node_id);\n        $node_info = $this->db->get_recordset($sql2);\n        if( isset($this->class_name[$node_info[0]['node_type_id']]) )\n        {\n          $className = $this->class_name[$node_info[0]['node_type_id']];\n          if( !is_null($className) )\n          { \n            $item_mgr = new $className($this->db);\n            $item_mgr->delete($node_id);        \n          }\n        }   \n        else if (isset($this->nodeWithoutClass[$node_info[0]['node_type_id']]))\n        {\n        }  \n        else \n        {\n          // need to signal error - TO BE DONE\n          // echo '<br>AUCH!!!';\n        }\n      }        \n    }  // if( $node_id != $root_id )\n  }\n \n\n  /*\n  \n              [$mode]: dotted -> $level number of dot characters are appended to\n                               the left of item name to create an indent effect.\n                               Level indicates on what tree layer item is positioned.\n                               Example:\n\n                                null\n                                \\\n                               id=1   <--- Tree Root = Level 0\n                                 |\n                                 + ------+\n                               /   \\      \\\n                            id=9   id=2   id=8  <----- Level 1\n                                    \\\n                                     id=3       <----- Level 2\n                                      \\\n                                       id=4     <----- Level 3\n\n\n                               key: item id (= node id on tree).\n                               value: every array element is an string, containing item name.\n\n                               Result example:\n\n                                2  .TS1\n                                3   ..TS2\n                                9   .20071014-16:22:07 TS1\n                               10   ..TS2\n\n\n                     array  -> key: item id (= node id on tree).\n                               value: every array element is a map with the following keys\n                               'name', 'level'\n\n                                2    array(name => 'TS1',level =>  1)\n                                3   array(name => 'TS2',level =>  2)\n                                9    array(name => '20071014-16:22:07 TS1',level =>1)\n                               10   array(name =>  'TS2', level   => 2)\n\n  */\n  function createHierarchyMap($array2map,$mode='dotted',$field2add=null)\n  {\n    $hmap=array();\n    $the_level = 1;\n    $level = array();\n    $pivot = $array2map[0];\n    $addField = !is_null($field2add);\n    $mode = is_null($mode) ? 'dotted' : $mode;\n\n    foreach($array2map as $elem)\n    {\n      $current = $elem;\n      if ($pivot['id'] == $current['parent_id'])\n      {\n        $the_level++;\n        $level[$current['parent_id']]=$the_level;\n      }\n      else if ($pivot['parent_id'] != $current['parent_id'])\n      {\n        $the_level = $level[$current['parent_id']];\n      }\n\n      switch($mode)\n      {\n        case 'dotted':\n          $hmap[$current['id']] = str_repeat('.',$the_level);\n          if($addField)\n          {\n            $hmap[$current['id']] .= sprintf($field2add['format'],$current[$field2add['field']]);\n          }  \n          $hmap[$current['id']] .= $current['name'];\n        break;\n\n          case 'array':\n            $str = ($addField ? $current[$field2add] : '') . $current['name']; \n            $hmap[$current['id']] = array('name' => $str, 'level' => $the_level);\n          break;\n      }\n\n      // update pivot\n      $level[$current['parent_id']]= $the_level;\n      $pivot=$elem;\n    }\n    \n    return $hmap;\n  }\n\n  /**\n   * getAllItemsID\n    *\n    * @internal revisions\n    * based on code from testproject->get_all_testcases_id\n    *\n    */\n  function getAllItemsID($parentList,&$itemSet,$coupleTypes)\n  {\n    static $debugMsg;\n    if (!$debugMsg)\n    {\n    }\n    $sql = \"/* $debugMsg */  \" .\n           \" SELECT id,node_type_id from {$this->tables['nodes_hierarchy']} \" .\n           \" WHERE parent_id IN ({$parentList})\";\n    $sql .= \" AND node_type_id IN ({$coupleTypes['target']},{$coupleTypes['container']}) \"; \n    \n    $result = $this->db->exec_query($sql);\n    if ($result)\n    {\n      $containerSet = array();\n      while($row = $this->db->fetch_array($result))\n      {\n        if ($row['node_type_id'] == $coupleTypes['target'])\n        {\n          $itemSet[] = $row['id'];\n        }\n        else\n        {\n            $containerSet[] = $row['id'];\n        }\n      }\n      if (sizeof($containerSet))\n      {\n        $containerSet  = implode(\",\",$containerSet);\n        $this->getAllItemsID($containerSet,$itemSet,$coupleTypes);\n      }\n    }  \n  }\n\n  /**\n   *\n   */  \n  function getNodeByAttributes($attr)\n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $addJoin = '';\n    $sql = \"/* $debugMsg */ \";\n    $sql .= \" SELECT NH_MAIN.id,NH_MAIN.parent_id,NH_MAIN.name,NH_MAIN.node_type_id \" .\n            \" FROM {$this->object_table} AS NH_MAIN \" .\n            \" JOIN {$this->tables['node_types']} AS NT ON NT.id = NH_MAIN.node_type_id \";\n            \n    $where = \" WHERE 1=1 \";\n    foreach($attr as $key => $value)\n    {\n      switch($key)\n      {\n        case 'type':\n          $where .= \" AND NT.description = '\" . $this->db->prepare_string($value) . \"'\";\n        break;  \n        \n        case 'id':\n          $where .= \" AND NH_MAIN.is = \" . $this->db->prepare_int($value);\n        break; \n\n        case 'name':\n          $where .= \" AND NH_MAIN.name = '\" . $this->db->prepare_string($value) . \"'\";\n        break; \n         \n        case 'parent_id':\n          $where .= \" AND NH_MAIN.parent_id = \" . $this->db->prepare_int($value);\n          $addJoin = \" JOIN {$this->object_table} AS NH_PARENT ON NH_PARENT.id = NH_MAIN.parent_id \"; \n        break;\n      }\n    }\n    \n    $sql .= $addJoin . $where;\n    $rs = $this->db->fetchRowsIntoMap($sql,'id');\n    return $rs;  \n  }\n\n  /**\n   *\n   */\n  function getNodeType($id) {\n    $sql = \" SELECT node_type_id, NT.description AS node_type \n             FROM {$this->tables['nodes_hierarchy']} NH\n             JOIN {$this->tables['node_types']} NT \n             ON NT.id = NH.node_type_id \n             WHERE NH.id = \" . intval($id);\n    $rs = $this->db->get_recordset($sql);\n    \n    return null != $rs ? current($rs) : null;         \n  }\n  \n  /**\n   *\n   */\n  function getNameL2($node_id,$opt=null)\n  {\n    $options = array('l2CutFirst' => 0);\n\n    $options = array_merge($options,(array)$opt);\n\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n\n    $concat = \" CONCAT(NHL1.name,':',NHL2.name) \";\n    if ($options['l2CutFirst'] > 0) {\n      $where2cut = $options['l2CutFirst'];\n      $concat = \" CONCAT(NHL1.name,':',\" .\n                \" SUBSTRING(NHL2.name,{$where2cut}) )\";\n    }\n    $sql = \"SELECT $concat AS name\n            FROM {$this->tables['nodes_hierarchy']} NHL2\n            JOIN {$this->tables['nodes_hierarchy']} NHL1\n            ON NHL1.id = NHL2.parent_id\n            WHERE NHL2.id = \" . intval($node_id);\n    $rs = $this->db->get_recordset($sql);\n    $result = !is_null($rs) ? $rs[0]['name'] : '';\n    return $result;\n  }\n}// end class"], "fixing_code": ["<?php\n/**\n * TestLink Open Source Project - http://testlink.sourceforge.net/ \n * This script is distributed under the GNU General Public License 2 or later. \n *\n * @filesource  tree.class.php\n * @package     TestLink\n * @author      Francisco Mancardi\n * @copyright   2005-2020, TestLink community \n * @link        http://www.testlink.org/\n *\n */\n\n/**\n * @package TestLink\n */\nclass tree extends tlObject\n{\n\n  // ORDER IS CRITIC\n  // configurable values - pseudoconstants\n  // VERBOSE description do not map 100% contents of node_types table\n  // Now contains also PSEUDO NODES => build\n  var $node_types = array( 1 => 'testproject','testsuite',\n                                'testcase','tcversion','testplan',\n                                'requirement_spec','requirement','req_version',\n                                'testcase_step','req_revision','requirement_spec_revision',\n                                'build');\n\n  // key: node type id, value: class name\n  var $class_name = array( 1 => 'testproject','testsuite',\n                                'testcase',null,'testplan',\n                                'requirement_spec_mgr','requirement_mgr',null,\n                                null,null,null,null);\n\n  var $nodeWithoutClass = null;\n                                \n  var $node_descr_id = array();\n  \n\n  // Order here means NOTHING\n  var $node_tables_by = array('id' => array(),\n                'name' =>\n                  array('testproject' => 'testprojects',\n                        'testsuite' => 'testsuites',\n                        'testplan' => 'testplans',\n                        'testcase' => 'testcases',\n                        'tcversion' => 'tcversions',\n                        'requirement_spec' =>'req_specs',\n                        'requirement' => 'requirements',  \n                        'req_version' => 'req_versions',\n                        'req_revision' => 'req_versions',\n                        'requirement_spec_revision' => 'req_specs_revisions'));\n  \n  var $node_tables;\n    \n  var $ROOT_NODE_TYPE_ID = 1;\n  var $ROOT_NODE_PARENT_ID = NULL;\n\n  /** @var resource database handler */\n  var $db;\n\n  /**\n   * Class costructor\n   * @param resource &$db reference to database handler\n   */\n  function __construct(&$db) \n  {\n    if( !is_object($db) )\n    {\n      $msg = __METHOD__ . ' :: FATAL Error $db IS NOT AN Object';\n      throw new Exception($msg);\n    }\n    \n    parent::__construct();\n    $this->db = &$db;\n    $this->object_table = $this->tables['nodes_hierarchy'];\n\n    $this->node_tables = $this->node_tables_by['name'];\n    $this->node_descr_id = array_flip($this->node_types);\n    foreach($this->node_tables_by['name'] as $key => $tbl)\n    {\n      $this->node_tables_by['id'][$this->node_descr_id[$key]] = $tbl;\n    }\n\n    $nodeCodeId = array_flip($this->node_types);  \n    $this->nodeWithoutClass[$nodeCodeId['requirement_spec_revision']] = 'deleted when reqspec is deleted';\n\n    \n  }\n\n  /**\n   * get info from node_types table, regarding node types that can be used in a tree. \n   * \n   * @return array map\n   *         key: description: single human friendly string describing node type\n   *             value: numeric code used to identify a node type\n   *\n   */\n  function get_available_node_types() {\n    static $nodeTypes;\n    if( !$nodeTypes ) {\n      $sql = \" SELECT * FROM {$this->tables['node_types']} \"; \n      $nodeTypes = $this->db->fetchColumnsIntoMap($sql,'description','id');\n    }\n    return $nodeTypes;\n  }\n\n  /**\n   * creates a new root node in the hierarchy table.\n   *        root node is tree starting point.\n   * \n   * @param string $name node name; default=''\n   * @return integer node ID\n   */\n  function new_root_node($name = '') \n  {\n    $this->new_node(null,$this->ROOT_NODE_TYPE_ID,$name,1);\n    return $this->db->insert_id($this->object_table);\n  }\n\n  /*\n    function: new_node\n              creates a new node in the hierarchy table.\n              root node is tree starting point.\n\n    args : parent_id: node id of new node parent\n           node_type_id: node type\n           [name]: node name. default=''\n           [node_order]= order on tree structure. default=0\n           [node_id]= id to assign to new node, if you don't want\n                      id bein created automatically.\n                      default=0 -> id must be created automatically.\n    \n    returns: node_id of the new node created\n\n  */\n  function new_node($parent_id,$node_type_id,$name='',$node_order=0,$node_id=0) \n  {\n    $sql = \"INSERT INTO {$this->object_table} \" .\n           \"(name,node_type_id,node_order\";\n\n    $values=\" VALUES('\" . $this->db->prepare_string($name). \"',\" .\n            \" {$node_type_id},\" . intval($node_order);\n    if ($node_id)\n    {\n      $sql .= \",id\";\n      $values .= \",{$node_id}\";\n    }\n    \n    if(is_null($parent_id))\n    {\n      $sql .= \") {$values} )\";\n    }\n    else\n    {\n      $sql .= \",parent_id) {$values},{$parent_id})\";\n    }\n\n    $this->db->exec_query($sql);\n    return ($this->db->insert_id($this->object_table));\n   }\n\n  /*\n  get all node hierarchy info from hierarchy table\n  returns: node_id of the new node created\n  \n  \n  */\n  /*\n    function: get_node_hierarchy_info\n              returns the row from nodes_hierarchy table that has\n              node_id as id.\n              \n              get all node hierarchy info from hierarchy table\n\n    args : node_id: node id\n                    can be an array\n           [parent_id]         \n    \n    returns: \n\n  */\n  function get_node_hierarchy_info($node_id,$parent_id = null,$options=null)\n  {\n\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    $opt = array('nodeTypeID' => null, 'nodeType' => null, \n                 'fields' => 'id,name,parent_id,node_type_id,node_order');\n    $opt = array_merge($opt, (array)$options);\n    $sql = \"SELECT {$opt['fields']} \" . \n           \"FROM {$this->object_table} WHERE id\";\n      \n    $result=null;\n      \n    if( is_array($node_id) )\n    {\n      $sql .= \" IN (\" . implode(\",\",$node_id) . \") \";\n      $result=$this->db->fetchRowsIntoMap($sql,'id');    \n    }\n    else\n    {\n      $sql .= \"= \" . intval($node_id);\n      if( !is_null($parent_id) )\n      {\n        $sql .= \" AND parent_id=\" . intval($parent_id);  \n      }\n\n      if( !is_null($opt['nodeTypeID']) )\n      {\n        $sql .= \" AND node_type_id=\" . intval($opt['nodeTypeID']);  \n      }  \n\n      if( !is_null($opt['nodeType']) )\n      {\n        $sql .= \" AND node_type_id=\" . intval($this->node_descr_id[$opt['nodeType']]);  \n      }  \n\n      $rs = $this->db->get_recordset($sql);\n      $result = !is_null($rs) ? $rs[0] : null;\n    } \n    return $result;\n  }\n\n  /*\n    function: get_subtree_list()\n              get a string representing a list, where elements are separated\n              by comma, with all nodes in tree starting on node_id.\n              node is can be considered as root of subtree.\n              \n    args : node_id: root of subtree\n           node_type_id: null => no filter\n                   if present ONLY NODES OF this type will be ANALIZED and traversed\n                   Example:\n                   TREE\n                     |__ TSUITE_1\n                         |\n                         |__TSUITE_2\n                         |     |__TC_XZ\n                         |\n                         |__TC1\n                         |__TC2\n                         \n                   node_type_id = TC and ROOT=Tree => output=NULL      \n                   node_type_id = TC and ROOT=TSUITE_1 => output=TC1,TC2\n\n                   \n           output: null => list, not null => array\n\n    \n    returns: output=null => list (string with nodes_id, using ',' as list separator).\n             output != null => array\n\n  */\n  function get_subtree_list($node_id,$node_type_id=null,$output=null) {\n    $nodes = array();\n    $this->_get_subtree_list($node_id,$nodes,$node_type_id);\n    $node_list = is_null($output) ? implode(',',$nodes) : $nodes;\n    return($node_list);\n  }\n  \n  \n  /*\n    function: _get_subtree_list()\n              private function (name start with _), that using recursion\n              get an array with all nodes in tree starting on node_id.\n              node is can be considered as root of subtree.\n\n\n    args : node_id: root of subtree\n    \n    returns: array with nodes_id\n\n  */\n  function _get_subtree_list($node_id,&$node_list,$node_type_id=null)\n  {\n    $sql = \"SELECT id from {$this->object_table} WHERE parent_id = {$node_id}\";\n    if( !is_null($node_type_id) )\n    {\n      $sql .=  \" AND node_type_id = {$node_type_id} \"; \n    }\n    $result = $this->db->exec_query($sql);\n    \n    if (!$result || !$this->db->num_rows($result))\n    {\n      return;\n    }\n    \n    while($row = $this->db->fetch_array($result))\n    {\n      $node_list[] = $row['id'];\n      $this->_get_subtree_list($row['id'],$node_list,$node_type_id);  \n    }\n  }\n\n  /*\n    function: delete_subtree\n              delete all element on tree structure that forms a subtree\n              that has as root or starting point node_id.\n\n    args : node_id: root of subtree\n    \n    returns: array with nodes_id\n\n  */\n  function delete_subtree($node_id)\n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $children = $this->get_subtree_list($node_id);\n    $id2del = $node_id;\n    if($children != \"\")\n    {\n      $id2del .= \",{$children}\";  \n    }\n    $sql = \"/* $debugMsg */ DELETE FROM {$this->object_table} WHERE id IN ({$id2del})\";\n  \n    $result = $this->db->exec_query($sql);\n  }\n\n\n  /*\n    function: get_path\n              get list of nodes to traverse when you want to move \n              from node A (node at level N) to node B (node at level M),\n              where MUST BE ALLWAYS M < N, and remembering that level for root node is the minimun.\n              This means path on tree backwards (to the upper levels).\n              An array is used to represent list.\n              Last array element contains data regarding Node A, first element (element with index 0) \n              is data regarding child of node B.\n              What data is returned depends on value of optional argument 'format'.\n              \n              Attention:\n              1 - destination node (node B) will be NOT INCLUDED in result.\n              2 - This is refactoring of original get_path method.\n\n    args : node_id: start of path\n           [to_node_id]: destination node. default null -> path to tree root.\n           [format]: default 'full' \n                     defines type of elements of result array.\n                     \n                     format='full'\n                     Element is a map with following keys:\n                     id\n                     parent_id\n                     node_type_id\n                     node_order\n                     node_table\n                     name\n                     \n                     Example\n                     Is tree is :\n                                \n                              null \n                                \\\n                               id=1   <--- Tree Root\n                                 |\n                                 + ------+\n                               /   \\      \\\n                            id=9   id=2   id=8\n                                    \\\n                                     id=3\n                                      \\\n                                       id=4     \n                    \n                    \n                    get_path(4), returns:\n                          \n                    (\n                     [0] => Array([id] => 2\n                                  [parent_id] => 1\n                                  [node_type_id] => 2\n                                  [node_order] => 1\n                                  [node_table] => testsuites\n                                  [name] => TS1)\n        \n                     [1] => Array([id] => 3\n                                  [parent_id] => 2\n                                  [node_type_id] => 2\n                                  [node_order] => 1\n                                  [node_table] => testsuites\n                                  [name] => TS2)\n        \n                     [2] => Array([id] => 4\n                                  [parent_id] => 3\n                                  [node_type_id] => 3\n                                  [node_order] => 0\n                                  [node_table] => testcases\n                                  [name] => TC1)\n                    )\n                  \n                    \n                    \n                    format='simple'\n                    every element is a number=PARENT ID, array index = value\n                    For the above example result will be:\n                    (\n                     [1] => 1\n                     [2] => 2\n                     [3] => 3\n                    )\n                    \n                    \n\n    returns: array\n\n  */\n  function get_path($node_id,$to_node_id = null,$format = 'full')  {\n    $the_path = array();\n    $this->_get_path($node_id,$the_path,$to_node_id,$format); \n    if( !is_null($the_path) && count($the_path) > 0 ) {\n      $the_path = array_reverse($the_path);  \n    }\n    return $the_path;\n  }\n\n  /**\n   *\n   */\n  function get_path_new($node_id,$to_node_id = null,$format = 'full')  {\n    $the_path = array();\n    $trip='';\n    $matrioska = array();\n    $this->_get_path($node_id,$the_path,$to_node_id,$format); \n    \n    if( !is_null($the_path) && ($loop2do=count($the_path)) > 0 ) {\n      $the_path=array_reverse($the_path);  \n      $matrioska = $the_path[0];\n      $matrioska['childNodes']=array();\n      $target = &$matrioska['childNodes'];\n\n      $trip = '';\n      for($idx=0; $idx < ($loop2do-1); $idx++)\n      {\n        $trip[] = $the_path[$idx]['id']; // . \"({$idx})\";\n        $target[0] = $the_path[$idx+1];\n        if($the_path[$idx+1]['node_table'] != 'testcases')\n        {\n          $target = &$target[0]['childNodes'];\n        }  \n      }\n    }\n\n    return array($trip,$the_path);\n  }\n\n\n\n  /*\n    function: _get_path\n              This is refactoring of original get_path method.\n              Attention:\n              returns node in inverse order, that was done for original get_path\n  \n    args : node_id: start of path\n           node_list: passed by reference, to build the result.\n           [to_node_id]: destination node. default null -> path to tree root.\n           [format]: default 'full' \n    \n    returns: array\n  */\n  function _get_path($node_id,&$node_list,$to_node_id=null,$format='full') \n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n\n    // look up the parent of this node\n    $sql = \"/* $debugMsg */ \" . \n           \" SELECT id,name,parent_id,node_type_id,node_order \" .\n           \" FROM {$this->object_table} WHERE id = \" . intval($node_id);\n    \n    $result = $this->db->exec_query($sql);\n    if( $this->db->num_rows($result) == 0 ) {\n      $node_list=null;\n      return;   \n    }\n    \n    while ( $row = $this->db->fetch_array($result) ) {\n      // check & abort\n      if ($row['parent_id'] == $row['id']) {\n        throw new Exception(\"id = parent_id = \" . $row['id'], 1);\n      } \n\n      // only continue if this $node isn't the root node\n      // (that's the node with no parent)\n      if ($row['parent_id'] != '' && $row['id'] != $to_node_id) {\n        // the last part of the path to $node, is the name\n        // of the parent of $node\n        switch($format) {\n          case 'full':\n            $row['node_table'] = $this->node_tables_by['id'][$row['node_type_id']];\n            $node_list[] = $row;\n          break;    \n            \n          case 'simple':\n            // Warning: starting node is NOT INCLUDED in node_list\n            $node_list[$row['parent_id']] = $row['parent_id'];\n          break;    \n            \n          case 'points':\n            $node_list[] = $row['id'];\n          break;    \n\n          case 'simple_me':\n            if( is_null($node_list) ) {\n              $node_list[$row['id']] = $row['id'];\n            } else {\n              $node_list[$row['parent_id']] = $row['parent_id'];\n            }            \n          break;    \n\n          case 'name':\n            $node_list[] = $row['name'];\n          break;    \n\n        }\n        \n        // we should add the path to the parent of this node to the path\n        $this->_get_path($row['parent_id'],$node_list,$to_node_id,$format);\n      }\n    }\n  }\n  \n  \n  \n  \n  /*\n    function: change_parent\n              change node parent, using this method you implement move operation.\n  \n    args : node_id: node/nodes that need(s) to changed.\n                    mixed type: single id or array containing set of id.\n                    \n           parent_id: new parent\n    \n    returns: 1 -> operation OK\n    \n  */\n  function change_parent($node_id, $parent_id) \n  {\n    $debugMsg = 'Class:' .__CLASS__ . ' - Method:' \n                         . __FUNCTION__ . ' :: ';\n\n    if (is_array($node_id)) {\n      $safeSet = array_map('intval',$node_id);\n      $id_list = implode(\",\",$safeSet);\n      $where_clause = \" WHERE id IN ($id_list) \";\n    } else {    \n      $safe = intval($node_id);\n      if ($safe <= 0) {\n        throw new Exception(\"BAD node_id\", 1);\n      }\n      $where_clause=\" WHERE id = $safe\";\n    }\n\n    $safeP = $this->db->prepare_int($parent_id);\n    $sql = \"/* $debugMsg */ \n            UPDATE {$this->object_table}\n            SET parent_id = $safeP \n            $where_clause \";\n    \n    $result = $this->db->exec_query($sql);\n    \n    return $result ? 1 : 0;\n  }\n   \n   \n  /*\n    function: get_children\n              get nodes that have id as parent node.\n              Children can be filtering according to node type.\n              \n    args : id: node \n           [exclude_node_types]: map \n                                 key: verbose description of node type to exclude.\n                                      see get_available_node_types.\n                                 value: anything is ok\n    \n    returns: array of maps that contain children nodes.\n             map structure:\n             id \n             name\n             parent_id\n             node_type_id\n             node_order\n             node_table\n            \n             \n  */\n  function get_children($id,$exclude_node_types=null,$opt=null) {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $my['opt'] = array('accessKey' => null);\n    $my['opt'] = array_merge($my['opt'], (array)$opt);\n  \n    $sql = \"/* $debugMsg */ \" .\n           \" SELECT id,name,parent_id,node_type_id,node_order FROM {$this->object_table} \" .\n           \" WHERE parent_id = \" . $this->db->prepare_int($id) . \" ORDER BY node_order,id\";\n      \n    $node_list=array();  \n    $result = $this->db->exec_query($sql);\n      \n    if( $this->db->num_rows($result) == 0 )\n    {\n      return(null);   \n    }\n      \n    $xdx = 0;  \n    while ( $row = $this->db->fetch_array($result) )\n    {\n      if( !isset($exclude_node_types[$this->node_types[$row['node_type_id']]]))\n      {\n        $node_table = $this->node_tables_by['id'][$row['node_type_id']];\n\n        $ak = is_null($my['opt']['accessKey']) ? $xdx : $row[$my['opt']['accessKey']];\n        $node_list[$ak] = array('id' => $row['id'], 'parent_id' => $row['parent_id'],\n                                'node_type_id' => $row['node_type_id'],\n                                'node_order' => $row['node_order'],\n                                'node_table' => $node_table,'name' => $row['name']);\n        $xdx++;      \n      }\n    }\n    return $node_list;\n  }\n  \n   \n  /*\n    function: change_order_bulk\n              change order for all nodes is present in nodes array.\n              Order of node in tree, is set to position node has in nodes array.\n  \n    args :\n           nodes: array where value is node_id. Node order = node position on array\n     \n    returns: -\n  \n  */\n  function change_order_bulk($nodes) \n  {\n    foreach($nodes as $order => $node_id)\n    {\n      $order = abs(intval($order));\n      $node_id = intval($node_id);\n        $sql = \"UPDATE {$this->object_table} SET node_order = {$order} WHERE id = {$node_id}\";\n        $result = $this->db->exec_query($sql);\n    }\n  }\n  \n  \n  /*\n    function: change_child_order\n              will change order of children of parent id, to position\n              choosen node on top or bottom of children.             \n  \n    args:\n          parent_id: node used as root of a tree.\n          node_id: node which we want to reposition\n          $top_bottom: possible values 'top', 'bottom'\n          [exclude_node_types]: map \n                                key: verbose description of node type to exclude.\n                                     see get_available_node_types.\n                                value: anything is ok\n  \n     \n    returns: -\n  \n  */\n  function change_child_order($parent_id,$node_id,$top_bottom,$exclude_node_types=null)\n  {\n      $node_type_filter='';\n      if( !is_null($exclude_node_types) )\n      {\n         $types=implode(\"','\",array_keys($exclude_node_types));  \n         $node_type_filter=\" AND NT.description NOT IN ('{$types}') \";\n      }\n      \n      $sql = \" SELECT NH.id, NH.node_order, NH.name \" .\n             \" FROM {$this->object_table} NH, {$this->tables['node_types']} NT \" .\n             \" WHERE NH.node_type_id=NT.id \" .\n             \" AND NH.parent_id = {$parent_id} AND NH.id <> {$node_id} \" . \n             $node_type_filter .\n             \" ORDER BY NH.node_order,NH.id\";\n      $children=$this->db->get_recordset($sql);\n      \n      switch ($top_bottom)\n      {\n          case 'top':\n          $no[]=$node_id;\n          if( !is_null($children) )\n          {\n              foreach($children as $key => $value)\n              {\n                $no[]=$value['id'];     \n              }\n          }\n          break;\n            \n          case 'bottom':  \n          $new_order=$this->getBottomOrder($parent_id)+1;\n          $no[$new_order]=$node_id;\n          break;\n      }\n      $this->change_order_bulk($no);    \n  } \n  \n  /*\n    function: getBottomOrder\n              given a node id to be used as parent, returns  the max(node_order) from the children nodes.\n              We consider this bottom order.\n  \n    args: parentID: \n    \n    returns: order\n  \n  */\n  function getBottomOrder($parentID,$opt=null) {\n    $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n    \n    $my['opt'] = array();\n    $my['opt'] = array_merge(array('node_type' => null),(array)$opt);\n\n    \n    $sql = \"SELECT MAX(node_order) AS max_order\" .\n           \" FROM {$this->object_table} \" . \n           \" WHERE parent_id={$parentID} \";\n\n    if(!is_null($my['opt']['node_type'])) {\n      $sql .= \" AND node_type_id = \" . $this->node_descr_id[$my['opt']['node_type']];\n    }       \n\n    $sql .= \" GROUP BY parent_id \";\n    $rs=$this->db->get_recordset($sql);\n      \n    return $rs[0]['max_order'];     \n  }\n  \n  \n  \n  \n  /*\n    function: get_subtree\n              Giving a node_id, get the nodes that forma s subtree that \n              has node_id as root or starting point.\n  \n              Is possible to exclude:\n              branches that has as staring node, node of certain types.\n              children of some node types.\n              full branches.\n              \n  \n    args :\n      [filters] map with following keys  \n  \n          [exclude_node_types]: map/hash. \n                                default: null -> no exclusion filter will be applied.\n                                Branches starting with nodes of type detailed, will not be\n                                visited => no information will be returned.\n                                key: verbose description of node type to exclude.\n                                     (see get_available_node_types).\n                                value: can be any value, because is not used,anyway is suggested \n                                       to use 'exclude_me' as value.\n                                \n                                Example:\n                                array('testplan' => 'exclude_me')\n                                Node of type tesplan, will be excluded. \n                               \n                               \n          \n          [exclude_children_of]: map/hash\n                                default: null -> no exclusion filter will be applied.\n                                When traversing tree if the type of a node child, of node under analisys,\n                                is contained in this map, traversing of branch starting with this child node\n                                will not be done.\n                                key: verbose description of node type to exclude.\n                                     (see get_available_node_types).\n                                value: can be any value, because is not used,anyway is suggested \n                                       to use 'exclude_my_children' as value.\n                                \n                                Example:        \n                                array('testcase' => 'exclude_my_children')                               \n                                Children of testcase nodes, (tcversion nodes) will be EXCLUDED.         \n          \n          [exclude_branches]: map/hash. \n                              default: null -> no exclusion filter will be applied.\n                              key: node id.\n                              value: anything is ok.\n                              \n                              When traversing tree branches that have these node is, will\n                              not be visited => no information will be retrieved.\n          \n          \n          [additionalWhereClause]: sql filter to include in sql sentence used to retrieve nodes.\n                                   default: null -> no action taken.\n                                \n          [family]: used to include guide the tree traversal.\n                    map where key = node_id TO INCLUDE ON traversal\n                          value = map where each key is a CHILD that HAS TO BE INCLUDED in return set.                      \n                                \n          [options]: map with following keys\n                                \n          [recursive]: changes structure of returned structure.\n                        default: false -> a flat array will be generated\n                                 true  -> a map with recursive structure will be generated.\n                        \n                        false returns array, every element is a map with following keys:\n                        \n                        id\n                        parent_id\n                        node_type_id\n                        node_order\n                        node_table\n                        name\n                        \n                        \n                        true returns a map, with only one element\n                        key: childNodes.\n                        value: array, that represents a tree branch.\n                               Array elements are maps with following keys:\n                        \n                               id\n                               parent_id\n                               node_type_id\n                               node_order\n                               node_table\n                               name\n                               childNodes -> (array)\n                        \n            \n    returns: array or map\n    \n  \n  */\n  function get_subtree($node_id,$filters=null,$options=null) {\n    $my['filters'] = array('exclude_node_types' => null, 'exclude_children_of' => null,\n                           'exclude_branches' => null,'additionalWhereClause' => '', 'family' => null);\n                               \n    $my['options'] = array('recursive' => false, 'order_cfg' => array(\"type\" =>'spec_order'), \n                           'output' => 'essential', 'key_type' => 'std', 'addJoin' => '', 'addFields' => '');\n  \n    // Cast to array to handle $options = null\n    $my['filters'] = array_merge($my['filters'], (array)$filters);\n    $my['options'] = array_merge($my['options'], (array)$options);\n  \n    $the_subtree = array();\n       \n    // Generate NOT IN CLAUSE to exclude some node types\n    // $not_in_clause = $my['filters']['additionalWhereClause'];\n    if(!is_null($my['filters']['exclude_node_types']))\n    {\n      $exclude = array();\n      foreach($my['filters']['exclude_node_types'] as $the_key => $elem)\n      {\n        $exclude[] = $this->node_descr_id[$the_key];\n      }\n      $my['filters']['additionalWhereClause'] .= \" AND node_type_id NOT IN (\" . implode(\",\",$exclude) . \")\";\n    }\n  \n    $method2call = $my['options']['recursive'] ? '_get_subtree_rec' : '_get_subtree';\n    $qnum = $this->$method2call($node_id,$the_subtree,$my['filters'],$my['options']);\n    return $the_subtree;\n  }\n  \n  /**\n   *\n   */  \n  function _get_subtree($node_id,&$node_list,$filters = null, $options = null)\n  {\n    static $my;\n    if(!$my)\n    {\n      $my['filters'] = array('exclude_children_of' => null,'exclude_branches' => null,\n                             'additionalWhereClause' => '', 'family' => null);\n                                 \n      $my['options'] = array('order_cfg' => array(\"type\" =>'spec_order'),\n                             'output' => 'full', 'key_type' => 'std',\n                             'addJoin' => '', 'addFields' => '');\n  \n    }\n\n    $my['filters'] = array_merge($my['filters'], (array)$filters);\n    $my['options'] = array_merge($my['options'], (array)$options);\n       \n    switch($my['options']['order_cfg']['type'])\n    {\n      case 'spec_order':\n        $sql = \" SELECT id,name,parent_id,node_type_id,node_order \" .\n               $my['options']['addFields'] .\n               \" FROM {$this->object_table} {$my['options']['addJoin']} \" .\n               \" WHERE parent_id = {$node_id} \" .\n               \" {$my['filters']['additionalWhereClause']}\" .\n               \" ORDER BY node_order,id\";\n      break;\n\n      case 'rspec':\n        $sql = \" SELECT OBT.id,name,parent_id,node_type_id,node_order,\" .\n               \" RSPEC.doc_id \" .\n               \" FROM {$this->object_table} AS OBT \" .\n               \" JOIN {$this->tables['req_specs']} AS RSPEC \" .\n               \" ON RSPEC.id = OBT.id \" .\n               \" WHERE parent_id = {$node_id} \" .\n               \" {$my['filters']['additionalWhereClause']}\" .\n               \" ORDER BY node_order,OBT.id\";\n      break;\n\n      case 'exec_order':\n        // REMEMBER THAT DISTINCT IS NOT NEEDED when you does UNION WITHOUT ALL\n        //\n        // First query get Nodes that ARE NOT test case => test suites\n        // Second query get the TEST CASES\n        //\n        $sql = \"SELECT * FROM ( SELECT NH.node_order AS spec_order,\" . \n               \"                NH.node_order AS node_order, NH.id, NH.parent_id,\" . \n               \"                NH.name, NH.node_type_id, 0 AS tcversion_id\" .\n               \"                FROM {$this->object_table} NH, {$this->tables['node_types']} NT\" .\n               \"                WHERE parent_id = {$node_id}\" .\n               \"                AND NH.node_type_id=NT.id\" .\n               \"                AND NT.description <> 'testcase' {$my['filters']['additionalWhereClause']}\" .\n               \"                UNION\" .\n               \"                SELECT NHA.node_order AS spec_order, \" .\n               \"                       T.node_order AS node_order, NHA.id, NHA.parent_id, \" .\n               \"                       NHA.name, NHA.node_type_id, T.tcversion_id\" .\n               \"                FROM {$this->object_table} NHA, {$this->object_table} NHB,\" .\n               \"                     {$this->tables['testplan_tcversions']}  T,{$this->tables['node_types']} NT\" .\n               \"                WHERE NHA.id=NHB.parent_id \" .\n               \"                AND NHA.node_type_id=NT.id\" .\n               \"                AND NHB.id=T.tcversion_id \" .\n               \"                AND NT.description = 'testcase'\" .\n               \"                AND NHA.parent_id = {$node_id}\" .\n               \"                AND T.testplan_id = {$my['options']['order_cfg']['tplan_id']}) AC\" .\n               \"                ORDER BY node_order,spec_order,id\";\n        break;\n\n        case 'req_order':\n          $sql = \" SELECT NH_TC.id,NH_TC.name,NH_TC.parent_id,\" .\n                 \" NH_TC.node_type_id,NH_TC.node_order \" .\n                 \" {$my['options']['addFields']}\" .\n                 \" FROM {$this->object_table} AS NH_TC \" .\n                 \" {$my['options']['addJoin']} \" .\n                 \" JOIN {$this->tables['req_coverage']} RC \" .\n                 \" ON RC.testcase_id = NH_TC.id \" .\n                 \" WHERE RC.req_id = {$node_id} \" .\n                 \" {$my['filters']['additionalWhereClause']}\" .\n                 \" ORDER BY NH_TC.node_order,NH_TC.id\";\n        break;\n\n      }\n\n      $result = $this->db->exec_query($sql);\n    \n      if( $this->db->num_rows($result) == 0 )\n      {\n         return;   \n      }\n    \n      while ( $row = $this->db->fetch_array($result) )\n      {\n        if( !isset($my['filters']['exclude_branches'][$row['id']]) )\n        {  \n            \n        $node_table = $this->node_tables[$this->node_types[$row['node_type_id']]];\n\n        \n        switch($my['options']['output'])\n        {\n          case 'id':\n            $node_list[] = $row['id'];\n          break;  \n          \n          case 'essential':\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n\n          case 'rspec':\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'doc_id' => $row['doc_id'],\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n          \n\n          case 'full':\n          default:\n            // this choice\n            // 'tcversion_id' => (isset($row['parent_id']) ? $row['parent_id'] : -1),\n            // need to be documented and REVIEWED, because can generate confusion\n            $node_list[] = array('id' => $row['id'],\n                                 'parent_id' => $row['parent_id'],\n                                 'tcversion_id' => (isset($row['parent_id']) ? $row['parent_id'] : -1),\n                                 'node_type_id' => $row['node_type_id'],\n                                 'node_order' => $row['node_order'],\n                                 'node_table' => $node_table,\n                                 'name' => $row['name']);\n          break;                     \n              }\n        // Basically we use this because:\n        // 1. Sometimes we don't want the children if the parent is a testcase,\n        //    due to the version management\n        //\n        // 2. Sometime we want to exclude all descendants (branch) of a node.\n        //\n        // [franciscom]: \n        // I think ( but I have no figures to backup my thoughts) doing this check and \n        // avoiding the function call is better that passing a condition that will result\n        // in a null result set.\n        //\n        //\n        if( !isset($my['filters']['exclude_children_of'][$this->node_types[$row['node_type_id']]]) && \n            !isset($my['filters']['exclude_branches'][$row['id']]) )\n        {\n          $this->_get_subtree($row['id'],$node_list,$filters,$options);\n        }\n        }\n      }\n  } // function end\n   \n  /**\n   *\n   */   \n  function _get_subtree_rec($node_id,&$pnode,$filters = null, $options = null)\n  {\n    static $tcNodeTypeID;\n    static $qnum;\n    static $my;\n    static $platform_filter;\n    static $fclause;\n    static $exclude_branches;\n    static $exclude_children_of;\n    \n    if (!$tcNodeTypeID)\n    {\n      $tcNodeTypeID = $this->node_descr_id['testcase'];\n\n      $qnum=0;\n\n      $my['filters'] = array('exclude_children_of' => null,'exclude_branches' => null,\n                          'additionalWhereClause' => '', 'family' => null);\n                               \n      $my['options'] = array('order_cfg' => array(\"type\" =>'spec_order'),'key_type' => 'std',\n                          'remove_empty_nodes_of_type' => null);\n\n      // Cast to array to handle $options = null\n      $my['filters'] = array_merge($my['filters'], (array)$filters);\n      $my['options'] = array_merge($my['options'], (array)$options);\n\n      $platform_filter = \"\";\n      if( isset($my['options']['order_cfg']['platform_id']) && \n        ($safe_pid = intval($my['options']['order_cfg']['platform_id']) ) > 0 )\n      {\n        $platform_filter = \" /* Platform filter */ \" . \n                   \" AND T.platform_id = \" . $safe_pid;\n      }\n      \n      $fclause = \" AND node_type_id <> {$tcNodeTypeID} {$my['filters']['additionalWhereClause']} \";\n      \n\n      if( !is_null($my['options']['remove_empty_nodes_of_type']) )\n      {\n        // this way I can manage code or description      \n        if( !is_numeric($my['options']['remove_empty_nodes_of_type']) )\n        {\n          $my['options']['remove_empty_nodes_of_type'] = \n                  $this->node_descr_id[$my['options']['remove_empty_nodes_of_type']];\n        }\n      }\n      \n\n      $exclude_branches = $my['filters']['exclude_branches'];\n      $exclude_children_of = $my['filters']['exclude_children_of'];  \n    }\n      \n      switch($my['options']['order_cfg']['type'])\n      {\n          case 'spec_order':\n            $sql = \" SELECT id,name,parent_id,node_type_id,node_order FROM {$this->object_table} \" .\n                      \" WHERE parent_id = {$node_id} {$my['filters']['additionalWhereClause']}\" .\n                 \" ORDER BY node_order,id\";\n        break;\n          \n        case 'exec_order':\n      // Hmmm, no action regarding platforms. is OK ??\n      //\n      // REMEMBER THAT DISTINCT IS NOT NEEDED when you does UNION\n      //\n      // Important Notice:\n      // Second part of UNION, allows to get from nodes hierarchy,\n      // only test cases that has a version linked to test plan.\n      //\n      $sql=\"SELECT * FROM ( SELECT NH.node_order AS spec_order,\" . \n           \"                NH.node_order AS node_order, NH.id, NH.parent_id,\" . \n           \"                NH.name, NH.node_type_id, 0 AS tcversion_id \" .\n           \"                FROM {$this->tables['nodes_hierarchy']}  NH\" .\n           \"                WHERE parent_id = {$node_id} {$fclause} \" .\n           \"                UNION\" .\n           \"                SELECT NHA.node_order AS spec_order, \" .\n           \"                       T.node_order AS node_order, NHA.id, NHA.parent_id, \" .\n           \"                       NHA.name, NHA.node_type_id, T.tcversion_id \" .\n           \"                FROM {$this->tables['nodes_hierarchy']} NHA, \" .\n           \"                     {$this->tables['nodes_hierarchy']} NHB,\" .\n           \"                     {$this->tables['testplan_tcversions']} T\" .\n           \"                WHERE NHA.id=NHB.parent_id \" .\n           \"                AND NHA.node_type_id = {$tcNodeTypeID}\" .\n           \"                AND NHB.id=T.tcversion_id \" .\n           \"                AND NHA.parent_id = {$node_id} {$platform_filter} \" .  \n           \"                AND T.testplan_id = {$my['options']['order_cfg']['tplan_id']}) AC\" .\n           \"                ORDER BY node_order,spec_order,id\";\n      break;\n          \n      }\n    \n      $result = $this->db->exec_query($sql);\n      $qnum++;\n      while($row = $this->db->fetch_array($result))\n      {\n        if(!isset($exclude_branches[$row['id']]))\n        {  \n            switch($my['options']['key_type'])\n            {\n                  case 'std':\n                      $node =  array('parent_id' => $row['parent_id'],\n                               'id' => $row['id'],\n                                         'name' => $row['name'],\n                                         'childNodes' => null,\n                                         'node_table' => $this->node_tables_by['id'][$row['node_type_id']],\n                                         'node_type_id' => $row['node_type_id'],\n                                         'node_order' => $row['node_order']);\n                                  \n                      if( isset($row['tcversion_id']) && $row['tcversion_id'] > 0)\n                      {\n                        $node['tcversion_id'] = $row['tcversion_id'];\n                      }             \n                    break;\n                  \n                 case 'extjs':\n                      $node =  array('text' => $row['name'],\n                                     'id' => $row['id'],\n                                         'parent_id' => $row['parent_id'],\n                                         'node_type_id' => $row['node_type_id'],\n                                         'position' => $row['node_order'],\n                                  'childNodes' => null,\n                                         'leaf' => false);\n            \n                        switch($this->node_types[$row['node_type_id']])\n                        {\n                            case 'testproject':\n                            case 'testsuite':\n                                $node['childNodes'] = null;\n                              break;  \n            \n                            case 'testcase':\n                                $node['leaf'] = true;\n                              break;\n                        } \n                    break;\n            }  \n              \n            // Basically we use this because:\n            // 1. Sometimes we don't want the children if the parent is a testcase,\n            //    due to the version management\n            //\n            // 2. Sometime we want to exclude all descendants (branch) of a node.\n            //\n            // [franciscom]: \n            // I think ( but I have no figures to backup my thoughts) doing this check and \n            // avoiding the function call is better that passing a condition that will result\n            // in a null result set.\n            //\n            //\n            if(!isset($exclude_children_of[$this->node_types[$row['node_type_id']]]) && \n               !isset($exclude_branches[$row['id']]))\n          {\n              $this->_get_subtree_rec($row['id'],$node,$my['filters'],$my['options']);\n            }\n\n        // Have added this logic, because when export test plan will be developed\n        // having a test spec tree where test suites that do not contribute to test plan\n        // are pruned/removed is very important, to avoid additional processing\n        //            \n            $doRemove = is_null($node['childNodes']) && \n                      $node['node_type_id'] == $my['options']['remove_empty_nodes_of_type'];\n            \n            if(!$doRemove)\n            {\n            $pnode['childNodes'][] = $node;\n          }  \n        } // if(!isset($exclude_branches[$rowID]))\n      } //while\n      return $qnum;\n  }\n\n  /**\n   * function: get_full_path_verbose\n   * when path can not be found instead of null, anyway a map will be returned, with key=itemID value=NULL\n   * @internal revisions\n   **/\n  function get_full_path_verbose(&$items,$options=null) {\n      $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n      $goto_root=null;\n      $path_to=null;\n      $all_nodes=array();\n      $path_format = 'simple';\n      $output_format = 'simple';\n      \n      if( !is_null($options) )\n      {\n        // not a good solution, but Quick & Dirty\n        $path_format = isset($options['path_format']) ? $options['path_format'] : $path_format;\n        if(  !isset($options['path_format']) )\n        {\n          $path_format = isset($options['include_starting_point']) ? 'points' : $path_format;\n        }\n        $output_format = isset($options['output_format']) ? $options['output_format'] : $output_format;\n      }\n      \n      // according to count($items) we will try to optimize, sorry for magic number\n      if( count((array)$items) > 200)\n      {\n        $xitems = array_flip((array)$items);\n        $xsql = \" SELECT parent_id,id \" . \n                \" FROM {$this->tables['nodes_hierarchy']} \" . \n                \" WHERE id IN (\" . implode(',',array_keys($xitems)) . \")\";\n\n        $xmen = $this->db->fetchRowsIntoMap($xsql,'parent_id',database::CUMULATIVE);\n        $all_nodes = array();      \n        foreach($xmen as $parent_id => &$children)\n        {\n          $paty = $this->get_path($parent_id,$goto_root,$path_format);\n          $paty[] = $parent_id;\n        \n          $all_nodes = array_merge($all_nodes,$paty);\n          foreach($children as &$item)\n          {\n             $path_to[$item['id']]['name'] = $stairway2heaven[$item['id']] = $paty;\n             $all_nodes[] = $item['id'];  \n          }\n        }\n        unset($xmen);\n      }\n      else\n      {\n        foreach((array)$items as $item_id)\n        {\n          $stairway2heaven[$item_id] = $this->get_path($item_id,$goto_root,$path_format);\n          $path_to[$item_id]['name'] = $stairway2heaven[$item_id];\n          $all_nodes = array_merge($all_nodes,(array)$path_to[$item_id]['name']);\n        }\n      }\n      \n      $status_ok = (!is_null($all_nodes) && count($all_nodes) > 0);\n      if( $status_ok )\n      { \n        // get only different items, to get descriptions\n        $unique_nodes=implode(',',array_unique($all_nodes));\n\n        $sql=\"/* $debugMsg */ \" . \n             \" SELECT id,name FROM {$this->tables['nodes_hierarchy']}  WHERE id IN ({$unique_nodes})\"; \n        $decode=$this->db->fetchRowsIntoMap($sql,'id');\n        \n        foreach($path_to as $key => $elem)\n        {\n          foreach($elem['name'] as $idx => $node_id)\n          {\n            $path_to[$key]['name'][$idx]=$decode[$node_id]['name'];\n             $path_to[$key]['node_id'][$idx]=$node_id;\n          }\n        }\n        unset($decode);\n      }  \n      else\n      {\n        $path_to=null;\n      } \n        \n        if( !is_null($path_to) )\n        {\n          switch ($output_format)\n          {\n            case 'path_as_string':\n            case 'stairway2heaven':\n        $flat_path=null;\n        foreach($path_to as $item_id => $pieces)\n        {\n          // remove root node\n          unset($pieces['name'][0]);\n          $flat_path[$item_id]=implode('/',$pieces['name']);\n        }\n        if($output_format == 'path_as_string')\n        {\n          $path_to = $flat_path;\n            }\n            else\n            {\n              $path_to = null;\n              $path_to['flat'] = $flat_path;\n              $path_to['staircase'] = $stairway2heaven;\n            }\n            break;\n            \n            case 'id_name':\n            break;\n            \n            case 'simple':  \n            default:\n            $keySet = array_keys($path_to);\n            foreach($keySet as $key)\n            {\n              $path_to[$key] = $path_to[$key]['name'];\n            }\n            break;\n          }  \n        }\n        unset($stairway2heaven);\n      return $path_to; \n  }\n\n\n  /**\n   * check if there is a sibbling node of same type that has same name\n   *\n   * @param string name: name to check\n   * @param int node_type_id: node types to check.\n   * @param int id: optional. exclude this node id from result set\n   *                this is useful when you want to check for name\n   *                existence during an update operation.\n   *                Using id you get node parent, to get sibblings.\n   *                If null parent_id argument must be present\n   *\n   * @param int parent_id: optional. Mandatory if id is null\n   *                       Used to get children nodes to check for\n   *                       name existence.\n   *\n   *                          \n   * @return map ret: ret['status']=1 if name exists\n   *                                0 if name does not exist\n   *                  ret['msg']= localized message\n   *                                \n   */\n  function nodeNameExists($name,$node_type_id,$id=null,$parent_id=null)\n  {\n    $debugMsg='Class:' .__CLASS__ . ' - Method:' . __FUNCTION__ . ' :: ';\n    $ret['status'] = 0;\n    $ret['msg'] = '';\n    if( is_null($id) && is_null($parent_id) )\n    {\n      $msg = $debugMsg . 'Error on call $id and $parent_id can not be both null';\n      throw new Exception($msg);\n    }          \n        \n        \n    $additionalFilters = '';\n    $parentNodeID = intval($parent_id);\n    if( !is_null($id) )\n    {\n      // Try to get parent id if not provided on method call.\n      if( is_null($parentNodeID) || $parentNodeID <= 0)\n      {\n        $sql = \"/* {$debugMsg} */ \" . \n               \" SELECT parent_id FROM {$this->object_table} NHA \" .\n               \" WHERE NHA.id = \" . $this->db->prepare_int($id);\n        $rs = $this->db->get_recordset($sql);\n        $parentNodeID = intval($rs[0]['parent_id']);     \n            \n      }\n      $additionalFilters = \" AND NHA.id <> \" . $this->db->prepare_int($id);\n    }    \n\n    if( $parentNodeID <= 0)\n    {\n      $msg = $debugMsg . ' FATAL Error $parentNodeID can not be <= 0';\n      throw new Exception($msg);\n    }          \n        \n        \n    $sql = \"/* {$debugMsg} */ \" . \n           \" SELECT count(0) AS qty FROM {$this->object_table} NHA \" .\n           \" WHERE NHA.node_type_id  = {$node_type_id} \" .\n           \" AND NHA.name = '\" . $this->db->prepare_string($name) . \"'\" .\n           \" AND NHA.parent_id = \" . $this->db->prepare_int($parentNodeID) . \" {$additionalFilters} \"; \n \n    $rs = $this->db->get_recordset($sql);\n    if( $rs[0]['qty'] > 0)\n    {\n      $ret['status'] = 1;\n      $ret['msg'] = sprintf(lang_get('name_already_exists'),$name);\n    }\n      \n    return $ret;\n  }\n\n  /**\n   * getTreeRoot()\n   *\n   */\n  function getTreeRoot($node_id) {\n    $path = (array)$this->get_path($node_id);\n    $path_len = count($path);\n    $root_node_id = ($path_len > 0)? $path[0]['parent_id'] : $node_id;\n    return $root_node_id;\n  }\n\n\n  /**\n   * delete_subtree_objects()\n   * \n   * ATTENTION: subtree root node ($node_id?? or root_id?) IS NOT DELETED.\n   *\n   */\n  function delete_subtree_objects($root_id,$node_id,$additionalWhereClause = '',$exclude_children_of = null,\n                                  $exclude_branches = null)\n  {\n    static $debugMsg;\n    if( is_null($debugMsg) )\n    {\n      $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    }\n    \n    $sql = \"/* $debugMsg */ SELECT NH.* FROM {$this->object_table} NH \" .\n           \" WHERE NH.parent_id = \" . $this->db->prepare_int($node_id) . \" {$additionalWhereClause} \";\n    $rs = $this->db->get_recordset($sql);\n    if( !is_null($rs) )\n    {\n      foreach($rs as $row)\n      {  \n        $rowID = $row['id'];\n        $nodeTypeID = $row['node_type_id'];\n        $nodeType = $this->node_types[$nodeTypeID];\n        $nodeClassName = $this->class_name[$nodeTypeID];\n        if(!isset($exclude_branches[$rowID]))\n        {  \n          // Basically we use this because:\n          // 1. Sometimes we don't want the children if the parent is a testcase,\n          //    due to the version management\n          //\n          // 2. Sometime we want to exclude all descendants (branch) of a node.\n          //\n          if(!isset($exclude_children_of[$nodeType]) && !isset($exclude_branches[$rowID]))\n          {\n            // I'm paying not having commented this well\n            // Why I've set root_id to null ?\n            // doing this when traversing a tree, containers under level of subtree root\n            // will not be deleted => and this seems to be wrong.\n            $this->delete_subtree_objects($root_id,$rowID,$additionalWhereClause,$exclude_children_of,$exclude_branches);\n          }\n          else\n          {\n            // For us in this method context this node is a leaf => just delete\n            if( !is_null($nodeClassName) )\n            { \n              $item_mgr = new $nodeClassName($this->db);\n              $item_mgr->delete($rowID);        \n            }\n            else if (isset($this->nodeWithoutClass[$nodeTypeID]))\n            {\n            }  \n            else\n            {\n              // need to signal error - TO BE DONE\n              // echo '<br>AUCH!!!';\n            } \n          }\n        } // if(!isset($exclude_branches[$rowID]))\n      } //while\n    }\n    \n    // Must delete myself if I'm empty, only if I'm not subtree root.\n    // Done this way to avoid infinte recursion for some type of nodes\n    // that use this method as it's delete method. (example testproject).\n    \n    // Hmmm, need to recheck if this condition is ok\n    // \n    if( !is_null($root_id) && ($node_id != $root_id) )\n    {\n      $children = (array)$this->db->get_recordset($sql);\n      if( count($children) == 0 )\n      {\n        $sql2 = \"/* $debugMsg */ SELECT NH.* FROM {$this->object_table} NH \" .\n                \" WHERE NH.id = \" . $this->db->prepare_int($node_id);\n        $node_info = $this->db->get_recordset($sql2);\n        if( isset($this->class_name[$node_info[0]['node_type_id']]) )\n        {\n          $className = $this->class_name[$node_info[0]['node_type_id']];\n          if( !is_null($className) )\n          { \n            $item_mgr = new $className($this->db);\n            $item_mgr->delete($node_id);        \n          }\n        }   \n        else if (isset($this->nodeWithoutClass[$node_info[0]['node_type_id']]))\n        {\n        }  \n        else \n        {\n          // need to signal error - TO BE DONE\n          // echo '<br>AUCH!!!';\n        }\n      }        \n    }  // if( $node_id != $root_id )\n  }\n \n\n  /*\n  \n              [$mode]: dotted -> $level number of dot characters are appended to\n                               the left of item name to create an indent effect.\n                               Level indicates on what tree layer item is positioned.\n                               Example:\n\n                                null\n                                \\\n                               id=1   <--- Tree Root = Level 0\n                                 |\n                                 + ------+\n                               /   \\      \\\n                            id=9   id=2   id=8  <----- Level 1\n                                    \\\n                                     id=3       <----- Level 2\n                                      \\\n                                       id=4     <----- Level 3\n\n\n                               key: item id (= node id on tree).\n                               value: every array element is an string, containing item name.\n\n                               Result example:\n\n                                2  .TS1\n                                3   ..TS2\n                                9   .20071014-16:22:07 TS1\n                               10   ..TS2\n\n\n                     array  -> key: item id (= node id on tree).\n                               value: every array element is a map with the following keys\n                               'name', 'level'\n\n                                2    array(name => 'TS1',level =>  1)\n                                3   array(name => 'TS2',level =>  2)\n                                9    array(name => '20071014-16:22:07 TS1',level =>1)\n                               10   array(name =>  'TS2', level   => 2)\n\n  */\n  function createHierarchyMap($array2map,$mode='dotted',$field2add=null)\n  {\n    $hmap=array();\n    $the_level = 1;\n    $level = array();\n    $pivot = $array2map[0];\n    $addField = !is_null($field2add);\n    $mode = is_null($mode) ? 'dotted' : $mode;\n\n    foreach($array2map as $elem)\n    {\n      $current = $elem;\n      if ($pivot['id'] == $current['parent_id'])\n      {\n        $the_level++;\n        $level[$current['parent_id']]=$the_level;\n      }\n      else if ($pivot['parent_id'] != $current['parent_id'])\n      {\n        $the_level = $level[$current['parent_id']];\n      }\n\n      switch($mode)\n      {\n        case 'dotted':\n          $hmap[$current['id']] = str_repeat('.',$the_level);\n          if($addField)\n          {\n            $hmap[$current['id']] .= sprintf($field2add['format'],$current[$field2add['field']]);\n          }  \n          $hmap[$current['id']] .= $current['name'];\n        break;\n\n          case 'array':\n            $str = ($addField ? $current[$field2add] : '') . $current['name']; \n            $hmap[$current['id']] = array('name' => $str, 'level' => $the_level);\n          break;\n      }\n\n      // update pivot\n      $level[$current['parent_id']]= $the_level;\n      $pivot=$elem;\n    }\n    \n    return $hmap;\n  }\n\n  /**\n   * getAllItemsID\n    *\n    * @internal revisions\n    * based on code from testproject->get_all_testcases_id\n    *\n    */\n  function getAllItemsID($parentList,&$itemSet,$coupleTypes)\n  {\n    static $debugMsg;\n    if (!$debugMsg)\n    {\n    }\n    $sql = \"/* $debugMsg */  \" .\n           \" SELECT id,node_type_id from {$this->tables['nodes_hierarchy']} \" .\n           \" WHERE parent_id IN ({$parentList})\";\n    $sql .= \" AND node_type_id IN ({$coupleTypes['target']},{$coupleTypes['container']}) \"; \n    \n    $result = $this->db->exec_query($sql);\n    if ($result)\n    {\n      $containerSet = array();\n      while($row = $this->db->fetch_array($result))\n      {\n        if ($row['node_type_id'] == $coupleTypes['target'])\n        {\n          $itemSet[] = $row['id'];\n        }\n        else\n        {\n            $containerSet[] = $row['id'];\n        }\n      }\n      if (sizeof($containerSet))\n      {\n        $containerSet  = implode(\",\",$containerSet);\n        $this->getAllItemsID($containerSet,$itemSet,$coupleTypes);\n      }\n    }  \n  }\n\n  /**\n   *\n   */  \n  function getNodeByAttributes($attr)\n  {\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n    \n    $addJoin = '';\n    $sql = \"/* $debugMsg */ \";\n    $sql .= \" SELECT NH_MAIN.id,NH_MAIN.parent_id,NH_MAIN.name,NH_MAIN.node_type_id \" .\n            \" FROM {$this->object_table} AS NH_MAIN \" .\n            \" JOIN {$this->tables['node_types']} AS NT ON NT.id = NH_MAIN.node_type_id \";\n            \n    $where = \" WHERE 1=1 \";\n    foreach($attr as $key => $value)\n    {\n      switch($key)\n      {\n        case 'type':\n          $where .= \" AND NT.description = '\" . $this->db->prepare_string($value) . \"'\";\n        break;  \n        \n        case 'id':\n          $where .= \" AND NH_MAIN.is = \" . $this->db->prepare_int($value);\n        break; \n\n        case 'name':\n          $where .= \" AND NH_MAIN.name = '\" . $this->db->prepare_string($value) . \"'\";\n        break; \n         \n        case 'parent_id':\n          $where .= \" AND NH_MAIN.parent_id = \" . $this->db->prepare_int($value);\n          $addJoin = \" JOIN {$this->object_table} AS NH_PARENT ON NH_PARENT.id = NH_MAIN.parent_id \"; \n        break;\n      }\n    }\n    \n    $sql .= $addJoin . $where;\n    $rs = $this->db->fetchRowsIntoMap($sql,'id');\n    return $rs;  \n  }\n\n  /**\n   *\n   */\n  function getNodeType($id) {\n    $sql = \" SELECT node_type_id, NT.description AS node_type \n             FROM {$this->tables['nodes_hierarchy']} NH\n             JOIN {$this->tables['node_types']} NT \n             ON NT.id = NH.node_type_id \n             WHERE NH.id = \" . intval($id);\n    $rs = $this->db->get_recordset($sql);\n    \n    return null != $rs ? current($rs) : null;         \n  }\n  \n  /**\n   *\n   */\n  function getNameL2($node_id,$opt=null)\n  {\n    $options = array('l2CutFirst' => 0);\n\n    $options = array_merge($options,(array)$opt);\n\n    $debugMsg = 'Class:' . __CLASS__ . ' - Method: ' . __FUNCTION__;\n\n    $concat = \" CONCAT(NHL1.name,':',NHL2.name) \";\n    if ($options['l2CutFirst'] > 0) {\n      $where2cut = $options['l2CutFirst'];\n      $concat = \" CONCAT(NHL1.name,':',\" .\n                \" SUBSTRING(NHL2.name,{$where2cut}) )\";\n    }\n    $sql = \"SELECT $concat AS name\n            FROM {$this->tables['nodes_hierarchy']} NHL2\n            JOIN {$this->tables['nodes_hierarchy']} NHL1\n            ON NHL1.id = NHL2.parent_id\n            WHERE NHL2.id = \" . intval($node_id);\n    $rs = $this->db->get_recordset($sql);\n    $result = !is_null($rs) ? $rs[0]['name'] : '';\n    return $result;\n  }\n}// end class"], "filenames": ["lib/functions/tree.class.php"], "buggy_code_start_loc": [540], "buggy_code_end_loc": [552], "fixing_code_start_loc": [540], "fixing_code_end_loc": [560], "type": "CWE-89", "message": "A SQL injection vulnerability in TestLink 1.9.20 allows attackers to execute arbitrary SQL commands in dragdroptreenodes.php via the node_id parameter.", "other": {"cve": {"id": "CVE-2020-8637", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-03T19:15:13.500", "lastModified": "2020-04-06T12:34:08.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A SQL injection vulnerability in TestLink 1.9.20 allows attackers to execute arbitrary SQL commands in dragdroptreenodes.php via the node_id parameter."}, {"lang": "es", "value": "Una vulnerabilidad de inyecci\u00f3n SQL en TestLink versi\u00f3n 1.9.20, permite a atacantes ejecutar comandos SQL arbitrarios en el archivo dragdroptreenodes.php por medio del par\u00e1metro node_id."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:testlink:testlink:1.9.20:*:*:*:*:*:*:*", "matchCriteriaId": "1007C963-3BC2-41CF-9C5F-C8F54EAAAF8A"}]}]}], "references": [{"url": "https://ackcent.com/blog/testlink-1.9.20-unrestricted-file-upload-and-sql-injection/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/TestLinkOpenSourceTRMS/testlink-code/commit/d99bd8277d384f3417e917ce20bef5d061110343", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TestLinkOpenSourceTRMS/testlink-code/commit/d99bd8277d384f3417e917ce20bef5d061110343"}}