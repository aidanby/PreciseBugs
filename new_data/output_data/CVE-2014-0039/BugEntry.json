{"buggy_code": ["Thomas Bullinger\n    - Contributed patches for the --no-jumps option\n    - Wrote the makefwsnort.sh script to download the latest stable snort\n      rules.\n    - Bugfix for correct IP protocol number.\n    - Bugfix for missed --ipt-script option.\n    - Suggested the ability to specify multiple sid's with the --snort-sids\n      option.\n\nPaul O'Neil\n    - Discovered missed DMZ interface code bug.\n\nAhmad Almulhem\n    - Suggested --ipt-tos and --ipt-mark options\n    - Suggested ability to manually specify interface networks instead of\n      automatically parsing the output of ifconfig.  This allows fwsnort to be\n      run on a system where no IP is assigned to an interface such as a linux\n      box that is acting as a bridge.\n\nHank Leininger\n    - Suggested the combination of the QUEUE target and string matching as a\n      way to speed up inline Snort implementations.  This suggestion was made\n      at a talk I gave about Linux Firewalls at ShmooCon 2007, and the\n      --NFQUEUE and --QUEUE command line arguements were the result.\n\nGrant Ferley\n    - Submitted patch to exclude loopback interfaces from iptables allow rules\n      parsing.  This behavior can be reversed with the existing\n      --no-exclude-loopback command line argument.\n    - Submitted patch to IPTables::Parse to take into account iptables policy\n      output that contains \"0\" instead of \"all\" to represent any protocol.\n    - Suggested bugfix to allow negated networks to be specified within\n      iptables allow rules or within the fwsnort.conf file.\n\nFranck Joncourt\n    - Submitted patch to fix double dash format in fwsnort man page.\n    - Architected the process of packaging fwsnort (and the other Cipherdyne\n      projects) for the Debian Linux distribution.\n    - Submitted fwsnort documentation fixes for the ChangeLog and fwsnort man\n      page.\n    - Suggested creating the Snort rules directory if it doesn't already exist\n      when downloading the rules from Emerging Threats.\n    - Submitted patch for the MAX_STRING_LEN protection around iptables string\n      match arguments.\n    - Submitted patch for fwsnort to use the \"! <option> <arg>\" syntax instead\n      of the older \"<option> ! <arg>\" for the iptables command line.\n\nJustin B Rye\n    - Suggested wording updates for the fwsnort(8) man page in support of the\n      Debian package for fwsnort.\n\nD T\n    - Asked about whether fwsnort could be updated to apply to IPv6 traffic\n      on the fwsnort mailing list.\n\nGuillermo Gomez\n    - Fedora maintainer of fwsnort.\n    - Suggested a default logging location of /var/log/fwsnort/fwsnort.log\n      instead of /var/log/fwsnort.log.  The result was the addition of the\n      LOG_DIR and associated variables in the fwsnort.conf file.\n\nAndy Rowland\n    - Found a bug where fwsnort would attempt to use an invalid URL when\n      updating the Emerging Threats rule set via --update-rules.\n\nYves Pagani\n    - Found a bug where fwnsort could build iptables --log-prefix strings that\n      are longer than the underlying iptables firewall would allow.\n\nKim Hagen\n    - Submitted a patch for a bug in fwsnort-1.6 where the fwsnort policy in\n      iptables-save format could not be loaded whenever iptables-save put the\n      nat table output after the filter table output.  In this case, fwsnort\n      would fail with an error like the following (fixed in fwsnort-1.6.1):\n\n        Couldn't load target\n        `FWSNORT_FORWARD_ESTAB':/lib/xtables/libipt_FWSNORT_FORWARD_ESTAB.so:\n        cannot open shared object file: No such file or directory\n\nPeter Vrabec\n    - Suggested a new directory /var/lib/fwsnort/ for the fwsnort.sh script\n      and associated files (fwsnort.save, fwsnort_iptcmd.sh, etc.).\n\nAndrew Merenbach\n    - Contributed bug fix to properly honor --exclude-regex filtering option.\n\nDwight Davis\n    - Contributed patches for several bugs including not handling\n      --exclude-regex properly, not ignoring the deleted.rules file, not\n      handling --strict mode opertions correctly, and more.  These issues and\n      the corresponding patch were originally reported here:\n        http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=693000\n", "fwsnort-1.6.3 (12/21/2012):\n    - Bug fix to ensure that !, <, >, and = chars in content strings are\n      converted to the appropriate hex equivalents.  All content strings with\n      characters outside of [A-Za-z0-9] are now converted to hex-string format\n      in their entirety.  This should also fix an issue that results in the\n      following error when running /var/lib/fwsnort/fwsnort.sh:\n\n        Using intrapositioned negation (`--option ! this`) is deprecated in\n        favor of extrapositioned (`! --option this`).\n        Bad argument `bm'\n        Error occurred at line: 64\n        Try `iptables-restore -h' or 'iptables-restore --help' for more\n        information.\n            Done.\n\n    - Bug fix to set default max string length in --no-ipt-test mode where\n      iptables capabilities are not tested.\n    - (Andrew Merenbach) Bug fix to properly honor --exclude-regex filtering\n      option.\n    - Added fwsnort test suite to the test/ directory.  This mimics the test\n      suites from the psad and fwknop projects, and it designed to examine\n      many of the run time results of fwsnort.\n    - Added the ability to easily revert the fwsnort policy back to the\n      original iptables policy with \"/var/lib/fwsnort/fwsnort.sh -r\".  Note\n      that this reverts back to the policy as it was when fwsnort itself was\n      executed.\n    - Implemented a single unified function for iptables match parameter\n      length testing, and optimized to drastically reduce run time for iptables\n      capabilities checks (going from over 20 seconds to less than one second\n      in some cases).\n    - (Dwight Davis) Contributed patches for several bugs including not\n      handling --exclude-regex properly, not ignoring the deleted.rules file,\n      not handling --strict mode operations correctly, and more.  These issues\n      and the corresponding patch were originally reported here:\n        http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=693000\n    - Bug fix for Snort rules with HOME_NET(any) -> EXTERNAL_NET(any) to\n      ensure they go into the OUTPUT chain instead of the INPUT chain.  This\n      bug was reported by Dwight Davis.\n    - Updated to bundle the latest Emerging Threats rule set.\n\nfwsnort-1.6.2 (04/28/2012):\n    - Switched --no-ipt-sync to default to not syncing with the iptables policy.\n      By default fwsnort attempts to match translated Snort rules to the\n      running iptables policy, but this is tough to do well because iptables\n      policies can be complex.  And, before fwsnort switched to the\n      iptables-save format for instantiating the policy, a large set of\n      translated rules could take a really long time to make active within the\n      kernel.  Finally, many Snort rules restrict themselves to established TCP\n      connections anyway, and if a restrictive policy doesn't allow connections\n      to get into the established state for some port let's say, then there is\n      little harm in having translated Snort rules for this port.  Some kernel\n      memory would be wasted (small), but no performance would be lost since\n      packets won't be processed against these rules anyway.  The end result is\n      that the default behavior is now to not sync with the local iptables\n      policy in favor of translating and instantiating as many rules as\n      possible.\n    - Replaced Net::IPv4Addr with the excellent NetAddr::IP module which has\n      comprehensive support for IPv6 address network parsing and comparisons.\n    - Moved the fwsnort.sh script and associated files into the\n      /var/lib/fwsnort/ directory.  This was suggested by Peter Vrabec.\n    - Bug fix for recent versions of iptables (such as 1.4.12) where the icmp\n      match requires --icmp-type to be set - some Snort rules look for a string\n      to match in icmp traffic, but don't also specify an icmp type.\n    - Bug fix for 'qw(...) usage as parenthesis' warnings for perl > 5.14\n    - Removed the ExtUtils::MakeMaker RPM build requirement from the\n      fwsnort.spec file.  This is a compromise which will allow the fwsnort RPM\n      to be built even if RPM dosen't or can't see that ExtUtils::MakeMaker is\n      installed - most likely it will build anyway.  If it doesn't, there are\n      bigger problems since fwsnort is written in perl.  If you want to build\n      the fwsnort RPM with a .spec file that requires ExtUtils::MakeMaker, then\n      use the \"fwsnort-require-makemaker.spec\" file that is bundled in the\n      fwsnort sources.\n\nfwsnort-1.6.1 (11/01/2011):\n    - (Kim Hagen) submitted a patch for a bug in fwsnort-1.6 where the fwsnort\n      policy in iptables-save format could not be loaded whenever iptables-save\n      put the nat table output after the filter table output.  In this case,\n      fwsnort would fail with an error like the following:\n\n        Couldn't load target\n        `FWSNORT_FORWARD_ESTAB':/lib/xtables/libipt_FWSNORT_FORWARD_ESTAB.so:\n        cannot open shared object file: No such file or directory\n\n      fwsnort now invokes 'iptables-save -t filter' in order to ensure that\n      ordering issues do not affect how fwsnort builds its translated rule set.\n    - Bug fix to ensure that fwsnort does not attempt to re-order pattern\n      matches for patterns that have a relative match requirement.  For non-\n      relative matches fwsnort re-orders pattern matches based on the pattern\n      length, reasoning that the longest pattern should be processed first for\n      better performance.  The usage of the fast_pattern keyword give the user\n      explicit control over this.  Here is a Snort rule that is now properly\n      handled by fwsnort (references removed):\n\n       alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:\"ET WEB_CLIENT\n       Possible Adobe Reader and Acrobat Forms Data Format Remote Security\n       Bypass Attempt\"; flow:established,to_client; file_data; content:\"%FDF-\";\n       depth:300; content:\"/F(JavaScript|3a|\"; nocase; distance:0;\n       classtype:attempted-user; sid:2010664; rev:8;)\n\n      Before this change, fwsnort translated this rule as:\n\n      $IPTABLES -A FWSNORT_FORWARD_ESTAB -p tcp -m tcp --sport 80 -m string\n      --hex-string \"/F(JavaScript|3a|\" --algo bm --from 69 --icase -m string\n      --hex-string \"%FDF|2d|\" --algo bm --to 364 -m comment --comment\n      \"sid:2010664; msg:ET WEB_CLIENT Possible Adobe Reader and Acrobat Forms\n      Data Format Remote Security Bypass Attempt; classtype:attempted-user;\n      rev:8; FWS:1.6;\" -j LOG --log-ip-options --log-tcp-options --log-prefix\n      \"SID2010664 ESTAB \"\n\n      Note that in the above rule, the \"/F(JavaScript|3a|\" pattern was switched\n      to be evaluated first even though it is a relative match to the previous\n      pattern in the original Snort rule.  After this change, fwsnort translates\n      this rule as:\n\n      $IPTABLES -A FWSNORT_FORWARD_ESTAB -p tcp -m tcp --sport 80 -m string\n      --hex-string \"%FDF|2d|\" --algo bm --to 364 -m string --hex-string\n      \"/F(JavaScript|3a|\" --algo bm --from 69 --icase -m comment --comment\n      \"sid:2010664; msg:ET WEB_CLIENT Possible Adobe Reader and Acrobat Forms\n      Data Format Remote Security Bypass Attempt; classtype:attempted-user;\n      rev:8; FWS:1.6;\" -j LOG --log-ip-options --log-tcp-options --log-prefix\n      \"SID2010664 ESTAB \"\n\n    - Updated to the latest Emerging Threats rule set.\n\nfwsnort-1.6 (07/28/2011):\n    - Fixed the --ipt-apply functionality - the variable that held the\n      fwsnort.sh path was not initialized properly prior to this change.\n    - Added the --Conntrack-state argument to specify a conntrack state\n      in place of the \"established\" state that commonly accompanies the Snort\n      \"flow\" keyword.  By default, fwsnort uses the conntrack state of\n      \"ESTABLISHED\" for this.  In certain corner cases, it might be useful to\n      use \"ESTABLISHED,RELATED\" instead to apply application layer inspection\n      to things like ICMP port unreachable messages that are responses to real\n      attempted communications.  (Need to add UDP tracking for the _ESTAB\n      chains for this too - coming soon.)\n    - Recent releases of iptables and the Linux kernel support matching on\n      connection state via the conntrack modules and the --ctstate switch.\n      Added a capabilities test for this, and will fall back to using the state\n      match if the conntrack module is not available.\n    - Bugfix to ensure the iptables log prefixes built by fwsnort are not\n      longer than those allowed by the running iptables firewall.  This is\n      usually a total of 29 characters, but fwsnort now dynamically figures out\n      this value.\n    - Bugfix for --ipt-list and --ipt-flush to ensure that the proper iptables\n      binary path is chosen.  These args failed without this because the\n      iptables binary was not set.\n\nfwsnort-1.5 (01/08/2011):\n    - Major update to use the iptables-save format instead of the older\n      strategy of always just executing iptables commands directly (which was\n      very flow for large fwsnort policies).  The /etc/fwsnort/fwsnort.sh\n      script now just executes:\n\n        /sbin/iptables-restore < /etc/fwsnort/fwsnort.save\n\n      All fwsnort rules are now placed in the /etc/fwsnort/fwsnort.save file,\n      but the older fwsnort.sh output (for the individual commands version)\n      is still available at /etc/fwsnort/fwsnort_iptcmds.sh.  This\n      functionality extends to ip6tables policies as well.  The fwsnort man\n      page explain this in better detail:\n\n      \"As of fwsnort-1.5 all iptables rules built by fwsnort are written out\n      to the /etc/fwsnort/fwsnort.save file in iptables-save format.  This\n      allows a long fwsnort policy (which may contain thousands of iptables\n      rules translated from a large Snort signature set) to be quickly\n      instantiated via the \"iptables-restore\" command.  A wrapper script\n      /etc/fwsnort/fwsnort.sh is also written out to make this easy.  Hence,\n      the typical work flow for fwsnort is to: 1) run fwsnort, 2) note the\n      Snort rules that fwsnort was able to successfully translate (the number\n      of such rules is printed to stdout), and then 3) execute the\n      /etc/fwsnort/fwsnort.sh wrapper script to instantiate the policy in the\n      running kernel.\"\n\n    - Added the --rules-url argument so that the URL for updating the\n      Emerging Threats rule set can be specified from the command line.  The\n      default is:\n\n        http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules\n\n    - Updated to automatically check for the maximum length string that the\n      string match supports, and this is used to through out any Snort rules\n      with content matches longer than this length.\n    - Updated the iptables capabilities testing routines to add and delete\n      testing rules to/from the custom chain 'FWS_CAP_TEST'.  This maintains a\n      a cleaner separation between fwsnort and any existing iptables policy\n      even during the capabilities testing phase.\n    - Added the --ipt-check-capabilities argument to have fwsnort test the\n      capabilities of the local iptables firewall and exit.\n    - Added the --string-match-alg argument to allow the string matching\n      algorithm used by fwsnort to be specified from the command line.  The\n      default algorithm is 'bm' for 'Boyer-Moore', but 'kmp' may also be\n      specified (short for the 'Knuth\u2013Morris\u2013Pratt' algorithm).\n    - Updated to the latest complete rule set from Emerging Threats (see\n      http://www.emergingthreats.net/).\n\nfwsnort-1.1 (01/05/2010):\n    - Added the ability to build an fwsnort policy that utilizes ip6tables\n      instead of iptables.  This allows fwsnort filtering and altering\n      capabilities to apply to IPv6 traffic instead of just IPv4 traffic.  To\n      enable ip6tables usage, use the \"-6\" or \"--ip6tables\" command line\n      arguments.\n    - Added the --include-perl-triggers command line argument so that\n      translated Snort rules can easily be tested.  This argument instructs\n      fwsnort to include 'perl -e print ... ' commands as comments in the\n      /etc/fwsnort/fwsnort.sh script, and these commands can be combined\n      with netcat to send payloads across the wire that match Snort rules.\n    - Updated fwsnort to create logs in the /var/log/fwsnort/ directory\n      instead of directly in the /var/log/ directory.  The path is controlled\n      by a new variable 'LOG_FILE' in the /etc/fwsnort/fwsnort.conf file.\n    - Added several variables in /etc/fwsnort/fwsnort.conf to control paths\n      to everything from the config file to the snort rules path.  Coupled\n      with this is the ability to create variables within path components and\n      fwsnort will expand them (e.g. 'CONF_DIR /etc/fwsnort;\n      CONF_FILE $CONF_DIR/fwsnort.conf').\n    - Added --Last-cmd arg so that it is easy to rebuild the fwsnort.sh script\n      with the same command line args as the previous execution.\n\nfwsnort-1.0.6 (05/30/2009):\n    - (Franck Joncourt) Updated fwsnort to use the \"! <option> <arg>\" syntax\n      instead of the older \"<option> ! <arg>\" for the iptables command line.\n    - (Franck Joncourt) For the --hex-string and --string matches, if the\n      argument exceeds 128 bytes (iptables 1.4.2) then iptables fails with an\n      error \"iptables v1.4.2: STRING too long\".  Fixes this with a patch that\n      adds a new variable in fwsnort.conf \"MAX_STRING_LEN\", so that the size of\n      the content can be limited. If the content (null terminated string) is\n      more than MAX_STRING_LEN chars, fwsnort throws the rule away.\n    - Bug fix to allow fwsnort to properly translate snort rules that have\n      \"content\" fields with embedded escaped semicolons (e.g. \"\\;\").  This\n      allows fwsnort to translate about 58 additional rules from the Emerging\n      Threats rule set.\n    - Bug fix to allow case insensitive matches to work properly with the\n      --include-re-caseless and --exclude-re-caseless arguments.\n    - Bug fix to move the 'rawbytes' keyword to the list of keywords that are\n      ignored since iptables does a raw match anyway as it doesn't run any\n      preprocessors in the Snort sense.\n    - Added the --snort-rfile argument so that a specific Snort rules file (or\n      list of files separated by commas) is parsed.\n    - Added a small hack to choose the first port from a port list until the\n      iptables 'multiport' match is supported.\n    - Updated to consolidate spaces in hex matches in the fwsnort.sh script\n      since the spaces are not part of patterns to be searched anyway.\n    - Updated to the latest complete rule set from Emerging Threats (see\n      http://www.emergingthreats.net/).\n    - Added the \"fwsnort-nobuildreqs.spec\" file for building fwsnort on\n      systems (such as Debian) that do not install/upgrade software via RPM.\n      This file omits the \"BuildRequires: perl-ExtUtils-MakeMaker\" directive,\n      and this fixes errors like the following on an Ubuntu system when\n      building fwsnort with rpmbuild:\n\n      rpm: To install rpm packages on Debian systems, use alien. See README.Debian.\n      error: cannot open Packages index using db3 - No such file or directory (2)\n      error: cannot open Packages database in /var/lib/rpm\n\nfwsnort-1.0.5 (08/21/2008):\n    - Replaced the bleeding-all.rules file with the emerging-all.rules file.\n      This is because Matt Jonkman now releases his rule sets at\n      http://www.emergingthreats.net/\n    - Restructured perl module paths to make it easy to introduce a \"nodeps\"\n      distribution of fwsnort that does not contain any perl modules.  This\n      allows better integration with systems that already have all necessary\n      modules installed (including the IPTables::ChainMgr and IPTables::Parse\n      modules).  The main driver for this work is to make all cipherdyne.org\n      projects easily integrated with distributions based on Debian, and\n      Franck Joncourt has been instrumental in making this process a reality.\n      All perl modules are now placed within the \"deps\" directory, and the\n      install.pl script checks to see if this directory exists - a separate\n      fwsnort-nodeps-<ver> tarball will be distributed without this directory.\n      The Debian package for fwsnort can then reference the -nodeps tarball,\n      and a new \"fwsnort-nodeps.spec\" file has been added to build an RPM from\n      the fwsnort sources that does not install any perl modules.\n    - Updated to import perl modules from /usr/lib/fwsnort, but only if this\n      path actually exists in the filesystem.  This is similar to the strategy\n      implemented by psad.  A new variable FWSNORT_LIBS_DIR was added to the\n      fwsnort.conf to support this.\n    - Added support for multiple Snort rule directories as a comma-separated\n      list for the argument to --snort-rdir.\n    - Moved 'threshold' to the unsupported list since there will be several\n      signatures that use this feature to detect the Dan Kaminsky DNS attack,\n      and fwsnort does not yet support the usage of the iptables --limit\n      match.\n\nfwsnort-1.0.4 (01/22/2008):\n    - (Grant Ferley) Submitted patch to exclude loopback interfaces from\n      iptables allow rules parsing.  This behavior can be reversed with the\n      existing --no-exclude-loopback command line argument.\n    - (Grant Ferley) Submitted patch to IPTables::Parse to take into account\n      iptables policy output that contains \"0\" instead of \"all\" to represent\n      any protocol.\n    - (Grant Ferley) Submitted patch to IPTables::Parse to set sport and dport\n      to '0:0' if the protocol is 'all'.\n    - Bugfix to allow negated networks to be specified within iptables allow\n      rules or within the fwsnort.conf file.\n    - Updated install.pl to set the LC_ALL environmental variable to \"C\". This\n      should fix potential locale problems (this fix was borrowed from the\n      fwknop project).\n\nfwsnort-1.0.3 (11/22/2007):\n    - Added --include-re-caseless and --exclude-re-caseless options to have\n      --include-regex and --exclude-regex options match case insensitively.\n    - Major signature update from Bleeding Threats. This update includes a\n      large number of new signatures with PCRE statements, with an emphasis on\n      detecting SQL injection attacks directed at internal webservers from\n      external sources.\n    - Added the ability to interpret PCRE statements that include simple\n      string matches separated by \".*\" and \".+\" as multiple iptables string\n      matches. The only negative consequence in terms of signature detection\n      is that ordering is not preserved; that is, the PCRE \"/UNION.+SELECT/\"\n      would only match a packet that contains \"UNION\" followed by \"SELECT\",\n      whereas an iptables rule that uses a string match for UNION and a\n      separate string match for SELECT would match a packet that contains both\n      strings but in reverse. Typically this is not a huge concern, and the\n      PCRE translation can be disabled with a new option --no-pcre.\n    - Added asn1 keyword to unsupported list.\n\nfwsnort-1.0.2 (08/26/2007):\n    - Bugfix to make sure to add in header lengths for depth and offset values\n      since the string match extension compares bytes from the start of the\n      data link header.\n\nfwsnort-1.0.1 (08/26/2007):\n    - Bugfix for ipt_rule_test() function name.\n    - Added the ability to automatically resolve command paths if any commands\n      cannot be found at the locations specified in the fwsnort.conf file.\n\nfwsnort-1.0 (04/19/2007):\n    - Major update to include support for the NFQUEUE and QUEUE targets with\n      new command line options --NFQUEUE and --QUEUE.  This changes the\n      default LOG target to the NFQUEUE or QUEUE targets instead, and at the\n      same time builds a parallel Snort rule set in the\n      /etc/fwsnort/snort_rules_queue directory.  Every Snort rule in this\n      directory has at least one \"content\" keyword, which fwsnort uses in the\n      resulting iptables policy.  This policy only sends those packets to\n      snort_inline via the NFQUEUE or QUEUE target that match a content field\n      within some Snort rule.  The end result is that snort_inline should run\n      faster because the vast majority of packets (which are not malicious)\n      are processed via the Linux kernel without ever having to be sent to\n      userspace for analysis.  There is a tradeoff here in terms of attack\n      detection; snort_inline does not receive all packets associated with a\n      stream, so it cannot detect attacks quite as effectively (snort_inline\n      does not have an opportunity to look at reassembled buffers).  However,\n      this trade off may be acceptable for large sites where performance is\n      more important.\n    - Bug fix to remove any existing jump rules from the built-in INPUT,\n      OUTPUT, and FORWARD chains before creating a new jump rules.  This\n      allows the fwsnort.sh script to be executed multiple times without\n      creating a new jump rule into the fwsnort chains for each execution.\n    - Added the -X command line argument to allow fwsnort to delete all of\n      the fwsnort chains; this emulates the iptables command line argument\n      of the same name.\n    - Minor output enhancements and bugfixes to give more insight into the\n      translation process.  For example, if fwsnort is run in --snort-sid\n      mode but is unable to translate the specified signatures, the user is\n      notified.  Also, any existing /etc/fwsnort/fwsnort.sh script is not\n      archived and erased until fwsnort is actually going to write a new one.\n    - Added sid values to iptables comment match string.\n    - Bugfix for iptables string match --from and --to values to skip past\n      packet headers.  This is an approximation until a new --payload option\n      can be added to the string match extension.\n    - Added a single iptables rule testing API internally within fwsnort;\n      this adds a measure of consistency and removes some duplicate code.\n    - Added fwsnort mailing list at SourceForge.\n\nfwsnort-0.9.0 (03/22/2007):\n    - Added support for multiple content matches since this is supported by\n      iptables.  This made a 10% increase in the fwsnort translation rate -\n      about 60% of all Snort-2.3.3 rules can be translated now.\n    - Added emulation for distance and within from previous content match\n      based on --from and --to (string match extension) and the length of\n      the previous pattern.\n    - Added the ability to include the Snort \"msg\", \"classtype\", \"reference\",\n      \"priority\", and \"rev\" fields in each iptables rule with the comment\n      match.  This can be disabled with a new command line argument\n      --no-ipt-comments.  The fwsnort version is also included within this\n      string.\n    - Added the ability to include the iptables rule number for each rule in\n      the fwsnort chains.  This is useful to easily know which iptables rule\n      is being triggered by network traffic (so it can be disabled if\n      necessary).  This can be disabled with --no-ipt-rule-nums.\n    - Added the --include-regex and --exclude-regex command line arguments.\n      These arguments allow rules to be included/excluded based on a regular\n      expression supplied on the command line.\n    - Updated to include the original Snort rule as a comment within the\n      fwsnort.sh script without having to use --verbose.\n    - Bugfix to force install of IPTables::Parse since it had been updated in\n      the fwsnort-0.8.2 release.\n    - Changed the IGNORE_ADDR variable to WHITELIST since this name better\n      describes the actual function of this var.  Updated to allow multiple\n      WHITELIST lines.\n    - Added the BLACKLIST variable to allow a true blacklist to be\n      instantiated with either the DROP or REJECT targets.  The syntax for the\n      BLACKLIST variable is \"BLACKLIST  <ip or network>  <target>\", where\n      \"target\" is either \"DROP\" or \"REJECT\".\n    - Added -F and -L command line arguments to flush and list iptables rules.\n      This is similar to the iptables command line args of the same names.\n    - Bugfix to ensure that traffic directed into the INPUT or coming from the\n      OUTPUT chains is treated as going toward or originating from the\n      HOME_NET.  After all the HOME_NET variable may contain an internal\n      network but omit the IP assigned to an external interface on the\n      firewall.\n    - Added \"--log-ip-options\" and \"--log-tcp-options\" to fwsnort LOG rules by\n      default (in the generated fwsnort.sh script).  This can be disabled with\n      --no-log-ip-opts and --no-log-tcp-opts arguments on the fwsnort command\n      line.\n    - Added the ability to include --log-tcp-sequence to LOG rules in\n      fwsnort.sh with a new argument --ipt-log-tcp-seq on the fwsnort command\n      line.\n    - Updated to handle negative string matches with \"--string ! <string>\".\n    - Updated to output all unsupported options of the /var/log/fwsnort.log\n      file to assist in the development of addition keyword emulation.\n\nfwsnort-0.8.2 (02/17/2007):\n    - Updated to newer IPTables::Parse module that uses the array of hash\n      references method of returning iptables policy data.\n    - Added --Dump-ipt and --Dump-snort rules to allow iptables policy and\n      Snort rules to be dumped to STDOUT.\n    - Added bleeding-all.rules file from http://www.bleedingsnort.com/\n    - Added patches/bm_goodshift_fix.patch patch file that fixes an\n      initialization bug in the Boyer-Moore text search implementation in the\n      kernel (linux-2.6.x/lib/ts_bm.c) which caused slightly repetitive\n      patterns to only match at specific offsets with the string match\n      extension.\n    - Bugfix to ensure that a depth cannot be less that an offset (these\n      translate to the --to and --from command line arguments to iptables).\n    - Bugfix to escape '$' chars in iptables search strings.\n    - Added cd_rpmbuilder to make it easy to automatically build RPM files of\n      fwsnort.\n    - Added support for the iptables OUTPUT chain.\n    - Added the ChangeLog.svn file so that all of the changed files and\n      corresponding svn commit messages can be viewed (this file is built from\n      release to release).\n\nfwsnort-0.8.1 (11/11/2005):\n    - Updated to use the string match extension \"--algo bm\" argument if\n      fwsnort is being run on a 2.6.14 (or greater) kernel.\n    - Updated to handle the Snort \"offset\" and \"depth\" keywords via the\n      --from and --to options to the string match extension in the 2.6.14\n      kernel.\n    - Created RPM package of fwsnort.\n    - Minor man page updates.\n\nfwsnort-0.8.0 (07/11/2005):\n    - Completely re-structured fwsnort w.r.t. how it creates Netfilter\n      chains.  There are no longer any per-interface chains (this\n      greatly simplifies the Netfilter chains).\n    - Added three new chains \"FWSNORT_INPUT_ESTAB\", \"FWSNORT_OUTPUT_ESTAB\"\n      and \"FWSNORT_FORWARD_ESTAB\" to which tcp connections in the\n      ESTABLISHED state are jumped.  This allows fwsnort to use the\n      Netfilter tcp connection tracking mechanism to ignore Stick and Snot\n      style attacks (similar to the flow:established Snort rule option).\n    - Added true variable resolution (i.e. HTTP_SERVERS -> HOME_NET -> any)\n      for the Snort rule header.  This directly emulates the behavior of\n      the Snort IDS.\n    - Added IP protocol support in the translation of the Snort rule\n      header.  The Snort rule translation rate is now at about 53% for\n      Snort-2.3.\n    - Bugfix for ipopts Snort option (several arguments are not supported\n      by the ipv4options extension).\n    - Better tests for Netfiler TTL, TOS, and ipv4options matches.\n    - Replaced IGNORE_IP and IGNORE_NET keywords with single IGNORE_ADDR\n      keywork in fwsnort.conf.\n    - Updated to correctly handle ICMP type and code rules (itype and\n      icode Snort options) via the \"--icmp-types type/code\" convention.\n    - Added support for emulating the dsize Snort option through the use\n      of the Netfilter length match.\n    - Changed --type argument to --include-types and added list support\n      so it accepts things like \"chat,ddos\".  Also added --exclude-types\n      command line argument.\n    - Added support for multiple sid's (as a comma separated list) in\n      --snort-sids argument.  Also added --exclude-sids argument to remove\n      a list of sids from translation.\n    - Added support for the replace Snort option (originally from the\n      Snort_inline project).  The requires the replace string patch.\n    - Added support for restricting jump rules to a list of interfaces\n      via the --restrict-intf argument.\n    - Added kernel patch to extend the maximum packet length that the\n      string match extension will attempt to search from 1024 bytes to\n      2048 bytes (requires a kernel re-compile of course).\n    - Added DRP and REJ strings to logging prefix if --ipt-drop or\n      --ipt-reject is specified.\n    - Added snortspoof.pl, which is a simple perl script that emulates\n      the Stick and Snot tools.\n\nfwsnort-0.7.0 (06/05/2005):\n    - Added support for the Snort pass action by using the ACCEPT target.\n    - Added support for the Snort log action by using the ULOG target\n      (which can then log the packet via the pcap writer).\n    - Added support for all fwsnort alerts to be logged via the ULOG\n      target instead of the LOG target.\n    - Added support for the \"resp\" keyword to allow it to drive the\n      Netfilter argument to the REJECT target.\n    - Added \"pcre\" to the unsupported list... this knocks the fwsnort\n      translation rate down to about 50% for Snort-2.3 rules (pcre is\n      heavily utilized).\n    - Added \"priority\" and \"rev\" to comment lines.\n\nfwsnort-0.6.5 (03/20/2005):\n    - Updated to not attempt to download Snort rules from snort.org\n      because the rules are no longer available for automatic downloads\n    - Changed the install.pl script and the --update-rules mode for\n      fwsnort to download the latest signature set from\n      http://www.bleedingsnort.com/.\n      (Snort.org is now offering pay-service around their rule sets).\n    - Added signature test for the \"flowbits\" keyword.\n\nfwsnort-0.6.4 (12/18/2004):\n    - Updated to Snort-2.3 rules.  FWSnort can convert a total of 1710\n      out of 2559 total Snort-2.3 rules.\n    - Updated to new Snort rules download link for --update-rules mode:\n      http://www.snort.org/dl/rules/snortrules-snapshot-CURRENT.tar.gz\n    - Updated to standard [+], [-], and [*] prefixes for info, warning\n      and die logging messages.\n    - Added --replace-string patches.\n\nfwsnort-0.6.3 (04/04/2004):\n    - Added ignore functionality for both IPs and networks\n    - Split --ipt-block into --ipt-drop and --ipt-reject to add DROP\n      or REJECT rules respectively.\n    - Added --add-deleted option to allow rules in the \"deleted.rules\"\n      file to be added.\n\nfwsnort-0.6.2 (03/19/2004):\n    - Added --internal-net and --dmz-net options so that internal and\n      dmz networks can be manually specified without having to parse\n      the output of ifconfig.  This is most useful for running fwsnort\n      on a linux system that is acting as a bridge where no ip addresses\n      are assigned to the interfaces.\n    - Bugfix for missing icmp-port-unreachable rejects for UDP packets.\n\nfwsnort-0.6.1 (02/01/2004):\n    - Bugfix for not adding dmz interface rules to INPUT chain.\n    - Bugfix for not getting the DMZ interface network.\n\nfwsnort-0.6 (01/04/2004):\n    - Speed increase and disk access decrease by writing iptables\n      commands to the iptables script only after all lines have been\n      generated.\n    - Bugfix for DMZ interface.\n    - Bugfix for multiple ip_proto fields.\n    - Removed the ip protocol as an allowed protocol for translation.\n    - Bugfix for negated port numbers.\n    - Removed \"<-\" rule direction since not even snort supports this.\n    - Fixed snort rule updates from snort.org.\n\nfwsnort-0.5 (12/21/2003):\n    - Added \"-j REJECT --reject-with tcp-reset\" for tcp sessions\n      if the --ipt-block option is specified.\n    - Added ability to download latest snort rules from snort.org.\n    - Added --no-ipt-jumps.\n    - Added better checking for iptables build characteristics such\n      as the LOG target and wether or not the ipv4options extension\n      is compiled in.\n    - Added config preservation code from psad in install.pl.\n", "#!/usr/bin/perl -w\n#\n###############################################################################\n#\n# File: fwsnort\n#\n# URL: http://www.cipherdyne.org/fwsnort/\n#\n# Purpose: To translate snort rules into equivalent iptables rules.\n#          fwsnort is based on the original snort2iptables shell script\n#          written by William Stearns.\n#\n# Author: Michael Rash <mbr@cipherdyne.org>\n#\n# Credits: (see the CREDITS file)\n#\n# Version: 1.6.3\n#\n# Copyright (C) 2003-2012 Michael Rash (mbr@cipherdyne.org)\n#\n# License - GNU Public License version 2 (GPLv2):\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program; if not, write to the Free Software\n#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301\n#    USA\n#\n# TODO:\n#   - Add the ability to remove rules from a real snort config in the same\n#     way we remove them from iptables rulesets in fwsnort (we remove rules\n#     from an iptables ruleset if the iptables policy will not allow such\n#     traffic through in the first place).\n#   - New option: --ipt-mark.\n#\n# Reference: Snort is a registered trademark of Sourcefire, Inc\n#\n# Snort Rule Options:\n#\n#   msg:           Prints a message in alerts and packet logs.\n#   logto:         Log the packet to a user specified filename instead of the\n#                  standard output file.\n#   ttl:           Test the IP header's TTL field value.\n#   tos:           Test the IP header's TOS field value.\n#   id:            Test the IP header's fragment ID field for a specific\n#                  value.\n#   ipoption:      Watch the IP option fields for specific codes.\n#   fragbits:      Test the fragmentation bits of the IP header.\n#   dsize:         Test the packet's payload size against a value.\n#   flags          Test the TCP flags for certain values.\n#   seq:           Test the TCP sequence number field for a specific value.\n#   ack:           Test the TCP acknowledgement field for a specific value.\n#   itype:         Test the ICMP type field against a specific value.\n#   icode:         Test the ICMP code field against a specific value.\n#   icmp_id:       Test the ICMP ECHO ID field against a specific value.\n#   icmp_seq:      Test the ICMP ECHO sequence number against a specific\n#                  value.\n#   content:       Search for a pattern in the packet's payload.\n#   content-list:  Search for a set of patterns in the packet's payload.\n#   offset:        Modifier for the content option, sets the offset to begin\n#                  attempting a pattern match.\n#   depth:         Modifier for the content option, sets the maximum search\n#                  depth for a pattern match attempt.\n#   nocase:        Match the preceding content string with case insensitivity.\n#   session        Dumps the application layer information for a given\n#                  session.\n#   rpc:           Watch RPC services for specific application/procedure\n#                  calls.\n#   resp:          Active response (knock down connections, etc).\n#   react:         Active response (block web sites).\n#   reference:     External attack reference ids.\n#   sid:           snort rule id.\n#   rev:           Rule revision number.\n#   classtype:     Rule classification identifier.\n#   priority:      Rule severity identifier.\n#   uricontent:    Search for a pattern in the URI portion of a packet\n#\n#   tag:           Advanced logging actions for rules.\n#   ip_proto:      IP header's protocol value.\n#   sameip:        Determines if source ip equals the destination ip.\n#   stateless:     Valid regardless of stream state.\n#   regex:         Wildcard pattern matching.\n#\n############################################################################\n#\n\nuse IO::Socket;\nuse File::Copy;\nuse File::Path;\nuse Sys::Hostname;\nuse Data::Dumper;\nuse Cwd;\nuse Getopt::Long;\nuse strict;\n\n### config file\nmy $CONFIG_DEFAULT = '/etc/fwsnort/fwsnort.conf';\nmy $fwsnort_conf = $CONFIG_DEFAULT;\n\n### version number\nmy $version = '1.6.3';\n\nmy %ipt_hdr_opts = (\n    'src'      => '-s',\n    'sport'    => '--sport',\n    'dst'      => '-d',\n    'dport'    => '--dport',\n    'proto'    => '-p',\n);\n\nmy %snort_opts = (\n    ### snort options that we can directly filter on\n    ### in iptables rulesets (snort options are separate\n    ### from the snort \"header\" which include protocol,\n    ### source, destination, etc.)\n    'filter' => {\n\n        ### application layer\n        'uricontent' => {  ### use --strict to not translate this\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]uricontent:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'content' => {\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]content:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'fast_pattern' => {\n            'iptopt' => '',  ### fast_pattern just governs ordering of\n                             ### content matches\n            'regex'  => qr/[\\s;]fast_pattern(?::\\s*.*?\\s*)?;/,\n        },\n        'pcre' => {\n            ### only basic PCRE's that just have strings separated\n            ### by \".*\" or \".+\" are supported.\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]pcre:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'nocase'  => {\n            'iptopt' => '--icase',\n            'regex'  => qr/[\\s;]nocase\\s*;/,\n        },\n        'offset'  => {\n            'iptopt' => '--from',\n            'regex'  => qr/[\\s;]offset:\\s*(\\d+)\\s*;/\n        },\n        'depth' =>  {\n            'iptopt' => '--to',\n            'regex'  => qr/[\\s;]depth:\\s*(\\d+)\\s*;/\n        },\n\n        ### technically, the \"distance\" and \"within\" criteria\n        ### are relative to the end of the previous pattern match,\n        ### so iptables cannot emulate these directly; an approximation\n        ### is made based on the on length of the previous pattern an\n        ### any \"depth\" or \"offset\" criteria for the previous pattern.\n        ### To disable signatures with \"distance\" and \"within\", just\n        ### use the --strict option.\n        'distance'  => {\n            'iptopt' => '--from',\n            'regex'  => qr/[\\s;]distance:\\s*(\\d+)\\s*;/\n        },\n        'within' =>  {\n            'iptopt' => '--to',\n            'regex'  => qr/[\\s;]within:\\s*(\\d+)\\s*;/\n        },\n        'replace' => {  ### for Snort running in inline mode\n            'iptopt' => '--replace-string',\n            'regex'  => qr/[\\s;]replace:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'resp' => {\n            'iptopt' => '-j REJECT',\n            'regex'  => qr/[\\s;]resp:\\s*(.*?)\\s*;/\n        },\n\n        ### transport layer\n        'flags' => {\n            'iptopt' => '--tcp-flags',\n            'regex'  => qr/[\\s;]flags:\\s*(.*?)\\s*;/\n        },\n        'flow' => {\n            'iptopt' => '--tcp-flags',\n            'regex'  => qr/[\\s;]flow:\\s*(.*?)\\s*;/\n        },\n\n        ### network layer\n        'itype' => {\n            'iptopt' => '--icmp-type',  ### --icmp-type type/code\n            'regex'  => qr/[\\s;]itype:\\s*(.*?)\\s*;/\n        },\n        'icode' => {\n            'iptopt' => 'NONE',\n            'regex'  => qr/[\\s;]icode:\\s*(.*?)\\s*;/\n        },\n        'ttl' => {\n            'iptopt' => '-m ttl', ### requires CONFIG_IP_NF_MATCH_TTL\n            'regex'  => qr/[\\s;]ttl:\\s*(.*?)\\s*;/\n        },\n        'tos' => {\n            'iptopt' => '-m tos --tos', ### requires CONFIG_IP_NF_MATCH_TOS\n            'regex'  => qr/[\\s;]tos:\\s*(\\d+)\\s*;/\n        },\n        'ipopts' => {\n            'iptopt' => '-m ipv4options',  ### requires ipv4options extension\n            'regex'  => qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/\n        },\n        'ip_proto' => {\n            'iptopt' => '-p',\n            'regex'  => qr/[\\s;]ip_proto:\\s*(.*?)\\s*;/\n        },\n        'dsize' => {  ### requires CONFIG_IP_NF_MATCH_LENGTH\n            'iptopt' => '-m length --length',\n            'regex'  => qr/[\\s;]dsize:\\s*(.*?)\\s*;/\n        },\n    },\n\n    ### snort options that can be put into iptables\n    ### ruleset, but only in log messages with --log-prefix\n    'logprefix' =>  {\n        'sid'       => qr/[\\s;]sid:\\s*(\\d+)\\s*;/,\n        'msg'       => qr/[\\s;]msg:\\s*\\\"(.*?)\\\"\\s*;/,  ### we create a space\n        'classtype' => qr/[\\s;]classtype:\\s*(.*?)\\s*;/,\n        'reference' => qr/[\\s;]reference:\\s*(.*?)\\s*;/,\n        'priority'  => qr/[\\s;]priority:\\s*(\\d+)\\s*;/,\n        'rev'       => qr/[\\s;]rev:\\s*(\\d+)\\s*;/,\n    },\n\n    ### snort options that cannot be included directly\n    ### within iptables filter statements (yet :)\n    'unsupported' => {\n        'asn1'         => qr/[\\s;]asn1:\\s*.*?\\s*;/,\n        'fragbits'     => qr/[\\s;]fragbits:\\s*.*?\\s*;/,\n        'content-list' => qr/[\\s;]content\\-list:\\s*\\\".*?\\\"\\s*;/,\n        'rpc'          => qr/[\\s;]rpc:\\s*.*?\\s*;/,\n        'byte_test'    => qr/[\\s;]byte_test\\s*.*?\\s*;/,\n        'byte_jump'    => qr/[\\s;]byte_jump\\s*.*?\\s*;/,\n        'byte_extract' => qr/[\\s;]byte_extract\\s*.*?\\s*;/,\n        'file_data'    => qr/[\\s;]file_data\\s*;/,\n        'window'       => qr/[\\s;]window:\\s*.*?\\s*;/,\n        'flowbits'     => qr/[\\s;]flowbits:\\s*.*?\\s*;/,\n        'tag'          => qr/[\\s;]tag:\\s*.*?\\s*;/,\n        'ftpbounce'    => qr/[\\s;]ftpbounce\\s*;/,\n        'base64_data'  => qr/[\\s;]base64_data\\s*;/,\n        'base64_decode' => qr/[\\s;]base64_decode:\\s*.*?\\s*;/,\n#        'offset'       => qr/[\\s;]offset:\\s*\\d+\\s*;/,\n#        'depth'        => qr/[\\s;]depth:\\s*\\d+\\s*;/,\n\n        ### the following fields get logged by iptables but\n        ### we cannot filter them directly except with the\n        ### iptables u32 module.  Functionality has been built\n        ### into psad to generate alerts for most of these Snort\n        ### options.\n        'id'        => qr/[\\s;]id:\\s*(\\d+)\\s*;/,\n        'seq'       => qr/[\\s;]seq:\\s*(\\d+)\\s*;/,  ### --log-tcp-sequence\n        'ack'       => qr/[\\s;]ack:\\s*.*?\\s*;/,    ### --log-tcp-sequence\n        'icmp_seq'  => qr/[\\s;]icmp_seq:\\s*(\\d+)\\s*;/,\n        'icmp_id'   => qr/[\\s;]icmp_id:\\s*(\\d+)\\s*;/,\n        'sameip'    => qr/[\\s;]sameip\\s*;/,\n        'regex'     => qr/[\\s;]regex:\\s*(.*?)\\s*;/,\n        'isdataat'  => qr/[\\s;]isdataat:\\s*(.*?)\\s*;/,\n        'threshold' => qr/[\\s;]threshold:\\s*.*?\\s*;/,               ### FIXME --limit\n        'detection_filter' => qr/[\\s;]detection_filter:\\s*.*?\\s*;/  ### FIXME --limit\n    },\n\n    ### snort options that fwsnort will ignore\n    'ignore' => {\n        'rawbytes' => qr/[\\s;]rawbytes\\s*;/,  ### iptables does a raw match anyway\n        'logto'    => qr/[\\s;]logto:\\s*\\S+\\s*;/,\n        'session'  => qr/[\\s;]session\\s*;/,\n        'tag'      => qr/[\\s;]tag:\\s*.*?\\s*;/,\n        'react'    => qr/[\\s;]react:\\s*.*?\\s*;/, ### FIXME -j REJECT\n        'http_uri' => qr/[\\s;]http_uri\\s*;/,\n        'http_raw_uri' => qr/[\\s;]http_raw_uri\\s*;/,\n        'http_method' => qr/[\\s;]http_method\\s*;/,\n        'http_stat_code' => qr/[\\s;]http_stat_code\\s*;/,\n        'http_stat_msg' => qr/[\\s;]http_stat_msg\\s*;/,\n        'http_client_body' => qr/[\\s;]http_client_body\\s*;/,\n        'http_cookie' => qr/[\\s;]http_cookie\\s*;/,\n        'urilen'    => qr/[\\s;]urilen:\\s*.*?\\s*;/,\n    },\n\n    ### in --strict mode, signatures that include any of these\n    ### options are not translated to iptables rules\n    'strict_list' => [\n        'uricontent',\n        'pcre',\n        'distance',\n        'within',\n        'http_uri',\n        'http_raw_uri',\n        'http_method',\n        'http_stat_code',\n        'http_stat_msg',\n        'http_client_body',\n        'http_cookie',\n        'urilen'\n    ]\n);\n\n### rules update link\nmy $DEFAULT_RULES_URL = 'http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules';\nmy $rules_url = $DEFAULT_RULES_URL;\n\n### config vars that may span multiple lines\nmy %multi_line_vars = (\n    'UPDATE_RULES_URL' => '',\n    'WHITELIST' => '',\n    'BLACKLIST' => '',\n);\n\n### array that contains the fwsnort iptables script (will be written\n### to $config{'FWSNORT_SCRIPT'})\nmy @ipt_script_lines = ();\n\n### array that contains the fwsnort policy in iptables-save format.\n### This will also contain the running iptables policy, so the fwsnort\n### policy is integrated in.\nmy @fwsnort_save_lines = ();\nmy @ipt_save_lines     = ();\nmy $ipt_save_index     = 0;\nmy @ipt_save_script_lines = ();\nmy $ipt_save_completed_line = '';\nmy $save_str    = 'iptables-save';\nmy $ipt_str     = 'iptables';\nmy $save_bin    = '';\nmy $restore_bin = '';\nmy $ipt_bin     = '';\n\n### contains a cache of the iptables policy\nmy %ipt_policy = ();\nmy %ipt_default_policy_setting = ();\nmy %ipt_default_drop = ();\nmy %ipt_save_existing_chains = ();\n\n### hashes for save format data\nmy %save_format_whitelist = ();\nmy %save_format_blacklist = ();\nmy %save_format_prereqs   = ();\nmy %save_format_rules     = ();\nmy %save_format_conntrack_jumps = ();\n\n### regex to match ip addresses\nmy $ip_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\nmy %snort_dump_cache = ();\nmy %ipt_dump_cache = ();\n\n### for iptables capabilities testing\nmy $NON_HOST     = '127.0.0.2';\nmy $NON_IP6_HOST = '::2/128';\nmy $non_host     = '';\n\nmy $IPT_SUCCESS = 1;\nmy $IPT_FAILURE = 0;\nmy $IPT_TEST_RULE_NUM = 1;\n\nmy $MATCH_EQUIV  = 1;\nmy $MATCH_SUBSTR = 2;\n\n### header lengths; note that IP and TCP lengths are defined\n### in the fwsnort.conf file since they may each contain options,\n### but until the --payload option is added to the string match\n### extension there is no way to account for them except to\n### define an average length.\nmy $MAC_HDR_LEN = 14;\nmy $UDP_HDR_LEN = 8;\nmy $ICMP_HDR_LEN = 8;\n\n### config and commands hashes (constructed by import_config())\nmy %config = ();\nmy %cmds   = ();\n\nmy @local_addrs   = ();\nmy %include_types = ();\nmy %exclude_types = ();\nmy %include_sids  = ();\nmy %exclude_sids  = ();\nmy %restrict_interfaces = ();\n\n### establish some default behavior\nmy $home_net   = '';  ### normally comes from fwsnort.conf\nmy $ext_net    = '';  ### normally comes from fwsnort.conf\nmy $ipt_exec   = 0;\nmy $ipt_revert = 0;\nmy $ipt_drop   = 0;\nmy $ipt_reject = 0;\nmy $ipt_max_buf_len = 1025;\nmy $ipt_cap_search_factor = 128;\nmy $help       = 0;\nmy $stdout     = 0;\nmy $lib_dir    = '';\nmy $rules_file = '';\nmy $debug      = 0;\nmy $is_root    = 0;\nmy $dumper     = 0;\nmy $dump_ipt   = 0;\nmy $dump_snort = 0;\nmy $strict     = 0;\nmy $ipt_script = '';\nmy $logfile    = '';\nmy $rules_dir  = '';\nmy $homedir    = '';\nmy $abs_num    = 0;\nmy $run_last   = 0;\nmy $queue_rules_dir = '';\nmy $queue_pre_match_max = 0;\nmy $dump_conf  = 0;\nmy $kernel_ver = '2.6';  ### default\nmy $string_match_alg = 'bm';\nmy $verbose    = 0;\nmy $print_ver  = 0;\nmy $cmdl_homedir   = '';\nmy $update_rules   = 0;  ### used to download latest snort rules\nmy $default_icmp_type = 8;  ### echo request\nmy $ipt_print_type = 0;\nmy $ipt_check_capabilities = 0;\nmy $ipt_rule_ctr   = 1;\nmy $ipt_sync       = 0;\nmy $ipt_flush      = 0;\nmy $ipt_del_chains = 0;\nmy $ipt_list       = 0;\nmy $ipt_file       = '';\nmy $no_pcre        = 0;\nmy $no_ipt_log     = 0;\nmy $no_ipt_test    = 0;\nmy $no_ipt_jumps   = 0;\nmy $no_ipt_input   = 0;\nmy $no_ipt_output  = 0;\nmy $no_addr_check  = 0;\nmy $no_ipt_forward = 0;\nmy $ignore_opt     = 0;\nmy $include_sids   = '';\nmy $exclude_sids   = '';\nmy $add_deleted    = 0;\nmy $rules_types    = '';\nmy $exclude_types  = '';\nmy $snort_type     = '';\nmy $ulog_nlgroup   = 1;\nmy $queue_mode     = 0;\nmy $nfqueue_mode   = 0;\nmy $nfqueue_num    = 0;\nmy $ulog_mode      = 0;\nmy $exclude_re     = '';\nmy $include_re     = '';\nmy $include_re_caseless = 0;\nmy $exclude_re_caseless = 0;\nmy $enable_ip6tables  = 0;\nmy $ipt_var_str       = 'IPTABLES';\nmy $no_ipt_conntrack  = 0;\nmy $conntrack_state   = 'ESTABLISHED';\nmy $have_conntrack    = 0;\nmy $have_state        = 0;\nmy $snort_conf_file   = '';\nmy $ipt_restrict_intf = '';\nmy $no_ipt_comments  = 0;\nmy $no_ipt_rule_nums = 0;\nmy $no_exclude_loopback = 0;\nmy $no_ipt_log_ip_opts  = 0;\nmy $no_ipt_log_tcp_opts = 0;\nmy $ipt_log_tcp_seq     = 0;\nmy $include_perl_triggers = 0;\nmy $duplicate_last_build  = 0;\nmy $ipt_max_str_len = 1;\nmy $ipt_max_log_prefix_len = 1;\nmy $ipt_max_comment_len = 1;\nmy $no_fast_pattern_order = 0;\nmy $ipt_have_multiport_match = 0;\nmy $ipt_multiport_max = 2;\n\n### to be added to the string match extension\nmy $ipt_has_string_payload_offset_opt = 0;\n\n### default to processing these filter chains\nmy %process_chains = (\n    'INPUT'   => 1,\n    'FORWARD' => 1,\n    'OUTPUT'  => 1,\n);\nmy $TEST_CHAIN = 'FWS_CAP_TEST';\n\nmy %chain_ctr = ();\n\n### save a copy of the command line args\nmy @argv_cp = @ARGV;\n\n### see if we are running as root\n&is_root();\n\n### handle the command line args\n&handle_cmd_line();\n\n&run_last_cmdline() if $run_last;\n\n### import config, initialize various things, etc.\n&fwsnort_init();\n\n### if we are running with $chk_ipt_policy, then cache\n### the current iptables policy\n&cache_ipt_policy() if $ipt_sync;\n\n### truncate old fwsnort log\n&truncate_logfile();\n\n### check to make sure iptables has various functionality available\n### such as the LOG target, --hex-strings, the comment match, etc.\nif ($no_ipt_test) {\n    &set_defaults_without_ipt_test();\n} else {\n    &ipt_capabilities();\n}\n\n### cache the running iptables policy in iptables-save format\n&cache_ipt_save_policy();\n\n### print a header at the top of the iptables ruleset\n### script\n&ipt_hdr();\n\n### now that we have the interfaces, add the iptables\n### chains to the fwsnort shell script\n&ipt_add_chains();\n\n### add any WHITELIST rules to the main fwsnort chains\n### with the RETURN target\n&ipt_whitelist();\n\n### add any BLACKLIST rules to the main fwsnort chains\n### with the DROP or REJECT targets\n&ipt_blacklist();\n\n### add jump rules for established tcp connections to\n### the fwsnort state tracking chains\n&ipt_add_conntrack_jumps() unless $no_ipt_conntrack;\n\n### display the config on STDOUT\n&dump_conf() if $dump_conf;\n\n### make sure <type>.rules file exists if --type was\n### specified on the command line\n&check_type() if $rules_types;\n\n&logr(\"[+] Begin parsing cycle.\");\n\n### parse snort rules (signatures)\nif ($include_sids) {\n    print \"[+] Parsing Snort rules files...\\n\";\n} else {\n    if ($ipt_sync) {\n        print \"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\",\n            \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\",\n            sprintf(\"%-30s%-10s%-10s%-10s%-10s\", '    Snort Rules File',\n                'Success', 'Fail', 'Ipt_apply', 'Total'), \"\\n\\n\";\n    } else {\n        print \"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\",\n            \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\",\n            sprintf(\"%-30s%-10s%-10s%-10s\", '    Snort Rules File',\n                'Success', 'Fail', 'Total'), \"\\n\\n\";\n    }\n}\n\n### main subroutine to parse snort rules and add them to the\n### fwsnort.sh script.\n&parse_snort_rules();\n\n### append all translated rules to the iptables-save formatted array\n&save_format_append_rules();\n\n### jump packets (as appropriate) from the INPUT and\n### FORWARD chains to our fwsnort chains\n&ipt_jump_chain() unless $no_ipt_jumps;\n\npush @ipt_script_lines, qq|\\n\\$ECHO \"[+] Finished.\"|, '### EOF ###';\npush @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n\nprint \"\\n[+] Logfile: $config{'LOG_FILE'}\\n\";\n\nif ($ipt_rule_ctr > 1) {\n\n    ### write the iptables script out to disk\n    &write_ipt_script();\n\n    if ($queue_mode or $nfqueue_mode) {\n        print \"[+] Snort rule set directory for rules to be queued \",\n            \"to userspace:\\n        $config{'QUEUE_RULES_DIR'}\\n\";\n    }\n    print \"[+] $ipt_str script (individual commands): \" .\n        \"$config{'FWSNORT_SCRIPT'}\\n\";\n\n} else {\n    die \"[-] No Snort rules could be translated, exiting\\n\";\n}\n\n&write_save_file();\n\n&print_final_message();\n\nexit 0;\n#===================== end main ======================\n\nsub parse_snort_rules() {\n\n    my @rfiles = ();\n\n    my $cwd = cwd();\n\n    if ($rules_file) {\n        @rfiles = split /\\,/, $rules_file;\n    } else {\n        for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n            opendir D, $dir or die \"[*] Could not opendir $dir\";\n            for my $file (readdir D) {\n                push @rfiles, \"$dir/$file\";\n            }\n            closedir D;\n        }\n    }\n\n    my $sabs_num = 0;\n    my $tot_ipt_apply = 0;\n    my $tot_unsup_ctr = 0;\n    FILE: for my $rfile (sort @rfiles) {\n        $rfile = $cwd . '/' . $rfile unless $rfile =~ m|^/|;\n        my $type = '';\n        my $filename = '';\n        if ($rfile =~ m|.*/(\\S+\\.rules)$|) {\n            $filename = $1;\n        }\n        if ($rfile =~ m|.*/(\\S+)\\.rules$|) {\n            $type = $1;\n        } else {\n            next FILE;\n        }\n        $ipt_print_type = 0;\n        if ($rules_types) {\n            next FILE unless defined $include_types{$type};\n        }\n        if ($exclude_types) {\n            next FILE if defined $exclude_types{$type};\n        }\n        if ($rfile =~ m|deleted\\.rules|) {\n            next FILE unless $add_deleted;\n        }\n        ($snort_type) = ($rfile =~ m|.*/(\\S+)\\.rules|);\n        printf(\"%-30s\", \"[+] $filename\") unless $include_sids;\n\n        &logr(\"[+] Parsing $rfile\");\n        open R, \"< $rfile\" or die \"[*] Could not open: $rfile\";\n        my @lines = <R>;\n        close R;\n\n        ### contains Snort rules that will be used by Snort_inline\n        ### if fwsnort is building a QUEUE policy; these rules have\n        ### met the criteria that at least one \"content\" match is\n        ### required.\n        my @queue_rules = ();\n\n        my $line_num   = 0;\n        my $rule_num   = 0;\n        my $parsed_ctr = 0;\n        my $unsup_ctr  = 0;\n        my $ipt_apply_ctr = 0;\n        my $ipt_rules_ctr = 0;\n\n        RULE: for my $rule (@lines) {\n            chomp $rule;\n            my $rule_hdr;\n            my $rule_options;\n            $line_num++;\n\n            ### pass == ACCEPT, log == ULOG\n            unless ($rule =~ /^\\s*alert/ or $rule =~ /^\\s*pass/\n                    or $rule =~ /^\\s*log/) {\n                next RULE;\n            }\n\n            ### regex filters\n            if ($exclude_re) {\n                next RULE if $rule =~ $exclude_re;\n            }\n\n            if ($include_re) {\n                next RULE unless $rule =~ $include_re;\n            }\n\n            $rule_num++;  ### keep track of the abs num of rules\n            $sabs_num++;\n\n            if ($rule =~ m|^(.*?)\\s+\\((.*)\\)|) {\n                $rule_hdr     = $1;\n                $rule_options = \" $2 \";  ### allows out-of-order options\n            } else {\n                &logr(\"[-] Unrecognized rule format at line: $line_num. \" .\n                    \"Skipping.\");\n                next RULE;\n            }\n\n            ### skip all icmp \"Undefined Code\" rules; psad properly\n            ### handles this, but not fwsnort (see the icmp-info.rules\n            ### file).\n            if ($filename =~ /icmp/ and $rule_options =~ /undefined\\s+code/i) {\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n\n            ### parse header portion of Snort rule\n            my $hdr_hr = &parse_rule_hdr($rule_hdr, $line_num);\n            unless (keys %$hdr_hr) {\n                &logr(\"[-] Unrecognized rule header: \\\"$rule_hdr\\\" at \" .\n                    \"line: $line_num, skipping.\");\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n\n            ### parse options portion of Snort rule\n            my ($parse_rv, $opts_hr, $patterns_ar) = &parse_rule_options(\n                    $rule_options, &get_avg_hdr_len($hdr_hr), $line_num);\n\n            unless ($parse_rv) {\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n            if ($include_sids) {\n                print \"[+] Found sid: $opts_hr->{'sid'} in $filename\\n\";\n            }\n\n            if ($queue_mode or $nfqueue_mode) {\n\n                ### In general, it is not easy to modify the signatures that\n                ### snort_inline would use; one would think that an optimzation\n                ### would be to remove all \"content\" keywords since the kernel\n                ### itself is doing this now, but consider the following:\n\n                ### Suppose there are two original Snort signatures like so:\n                ###\n                ###     msg: \"SIG1\"; content: \"abc\"; pcre: \"(d|e)\";\n                ###     msg: \"SIG2\"; content: \"xyz\"; pcre: \"(e|f)\";\n                ###\n                ### Now, suppose there is a packet with the following data:\n                ###\n                ###     packet data: \"xyz------------e------\"\n                ###\n                ### Then the SIG1 matches when it shouldn't because the packet\n                ### does not contain \"abc\" (assuming the \"abc\" string is\n                ### removed from the signature that is actually deployed with\n                ### snort_inline).  There does not seem to be a good solution\n                ### for this problem if pcre criteria are involved because the\n                ### two pcre's would have to be interpreted to see if there is\n                ### any data that could satisfy both at the same time.\n\n                ### However, performing the duplicate string matching is far\n                ### less expensive than not sending a large portion of network\n                ### traffic to userspace for analysis by snort_inline in the\n                ### first place.  This is the real benefit of letting fwsnort\n                ### build a smarter iptables queueing policy.  This does come\n                ### with a penalty against detection, since snort_inline is\n                ### only receiving individual packets that match one of the\n                ### content keywords in a signature; it does not get the\n                ### entire stream.  But, this may be worth it for large sites\n                ### where performance is the primary concern.  Also, there is\n                ### some potential for removing a subset of the content\n                ### matches if done in the right way; this is the reason the\n                ### queue_get_rule() function is stubbed in below.\n                my $queue_rule = &queue_get_rule($rule_hdr, $rule_options);\n\n                push @queue_rules, $queue_rule if $queue_rule;\n            }\n\n            ### construct the equivalent iptables rule and add it\n            ### to $config{'FWSNORT_SCRIPT'}\n            my ($ipt_rv, $num_rules) = &ipt_build($hdr_hr,\n                    $opts_hr, $patterns_ar, $rule);\n\n            if ($ipt_rv) {\n                $ipt_apply_ctr++;\n                $tot_ipt_apply++;\n                ### may have the rule in several chains\n                $ipt_rules_ctr += $num_rules;\n                if ($include_sids) {\n                    print \"    Successful translation.\\n\";\n                }\n            } else {\n                if ($include_sids) {\n                    print \"    Unsuccessful translation.\\n\";\n                }\n            }\n            $parsed_ctr++;  ### keep track of successfully parsed rules\n            $abs_num++;;\n        }\n\n        if (($queue_mode or $nfqueue_mode) and @queue_rules) {\n            open M, \"> $config{'QUEUE_RULES_DIR'}/$filename\" or die \"[*] Could not \",\n                \"open $config{'QUEUE_RULES_DIR'}/$filename: $!\";\n            print M \"#\\n### This file generated with: fwsnort @argv_cp\\n#\\n\\n\";\n            print M \"$_\\n\", for @queue_rules;\n            print M \"\\n### EOF ###\\n\";\n            close F;\n        }\n\n        if ($ipt_rules_ctr) {\n            $ipt_rules_ctr *= 2 if $ipt_drop;\n            $ipt_rules_ctr *= 2 if $ipt_reject;\n            push @ipt_script_lines,\n                qq|\\$ECHO \"    Rules added: $ipt_rules_ctr\"|;\n        }\n\n        unless ($include_sids) {\n            if ($ipt_sync) {\n                printf(\"%-10s%-10s%-10s%-10s\\n\", $parsed_ctr, $unsup_ctr,\n                    $ipt_apply_ctr, $rule_num);\n            } else {\n                printf(\"%-10s%-10s%-10s\\n\", $parsed_ctr, $unsup_ctr,\n                    $rule_num);\n            }\n        }\n    }\n    unless ($include_sids) {\n        if ($ipt_sync) {\n            printf(\"%30s\", ' ');\n            print \"=======================================\\n\";\n            printf(\"%30s%-10s%-10s%-10s%-10s\\n\", ' ',\n                $abs_num, $tot_unsup_ctr, $tot_ipt_apply, $sabs_num);\n        } else {\n            printf(\"%30s\", ' ');\n            print \"=============================\\n\";\n            printf(\"%30s%-10s%-10s%-10s\\n\", ' ',\n                $abs_num, $tot_unsup_ctr, $sabs_num);\n        }\n        print \"\\n\";\n        if ($abs_num) {  ### we parsed at least one rule\n            print \"[+] Generated $ipt_str rules for $abs_num out of \",\n                \"$sabs_num signatures: \",\n                sprintf(\"%.2f\", $abs_num/$sabs_num*100), \"%\\n\";\n        } else {\n            print \"[+] No rules parsed.\\n\";\n        }\n        if ($ipt_sync) {\n            print \"[+] Found $tot_ipt_apply applicable snort rules to your \" .\n                \"current $ipt_str\\n    policy.\\n\";\n        }\n    }\n    return;\n}\n\nsub parse_rule_options() {\n    my ($rule_options, $avg_hdr_len, $line_num) = @_;\n\n    my $sid      = -1;\n    my %opts     = ();\n    my @patterns = ();\n\n    ### get the sid here for logging purposes\n    if ($rule_options =~ $snort_opts{'logprefix'}{'sid'}) {\n        $sid = $1;\n    } else {\n        return 0, \\%opts, \\@patterns;\n    }\n\n    if (%exclude_sids) {\n        return 0, \\%opts, \\@patterns if defined $exclude_sids{$sid};\n    }\n    if (%include_sids) {\n        if (defined $include_sids{$sid}) {\n            &logr(\"[+] matched sid:$sid: $rule_options\");\n        } else {\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    unless ($queue_mode or $nfqueue_mode) {\n\n        ### if we're queuing packets to userspace Snort, then we don't have to\n        ### disqualify a signature based on an option that is not supported by\n        ### iptables\n        my $found_unsupported = '';\n        for my $opt (keys %{$snort_opts{'unsupported'}}) {\n            ### see if we match a regex belonging to an unsupported option\n            if ($rule_options =~ $snort_opts{'unsupported'}{$opt}) {\n                $found_unsupported .= \"'$opt', \";\n            }\n        }\n        if ($found_unsupported) {\n            $found_unsupported =~ s/,\\s+$//;\n            &logr(\"[-] SID: $sid  Unsupported option(s): $found_unsupported \" .\n                \"at line: $line_num, skipping.\");\n            if (%include_sids and defined $include_sids{$sid}) {\n                print \"[-] SID: $sid contain the unsupported option(s): \",\n                    \"$found_unsupported at line: $line_num\\n\";\n            }\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    if ($rule_options =~ /ip_proto\\s*:.*ip_proto\\s*:/) {\n        &logr(\"[-] SID: $sid, unsupported multiple ip_proto fields at \" .\n            \"line: $line_num, skipping.\");\n        return 0, \\%opts, \\@patterns;\n    }\n\n    for my $opt (keys %{$snort_opts{'filter'}}) {\n        ### see if we match the option regex\n        if ($rule_options =~ $snort_opts{'filter'}{$opt}{'regex'}) {\n            $opts{$opt} = 1;\n            $opts{$opt} = $1 if defined $1;  ### some keywords may not have an option\n        }\n    }\n\n    my $found_content = 0;\n    while ($rule_options =~ /(\\w+):?\\s*((?:.*?[^\\x5c]?))\\s*;/g) {\n        my $opt = $1;\n        my $val = 1;\n        $val = $2 if defined $2;  ### some keywords may not have an argument\n\n        if ($opt eq 'content' or $opt eq 'uricontent') {\n            return 0, \\%opts, \\@patterns unless $val =~ /\"$/;\n            $val =~ s/^\\s*\"//;\n            $val =~ s/\"\\s*$//;\n            return 0, \\%opts, \\@patterns unless $val =~ /\\S/;\n\n            ### convert the string into a form that is more compatible\n            ### for iptables\n            my ($rv, $log_str, $ipt_pattern_hr)\n                    = &convert_pattern_for_iptables($val);\n\n            if ($rv) {\n                $found_content = 1;\n                push @patterns, $ipt_pattern_hr;\n            } else {\n                &logr(\"[-] SID: $sid, $log_str\");\n                return 0, \\%opts, \\@patterns;\n            }\n\n        } elsif ($opt eq 'pcre') {\n\n            $val =~ s|^\\s*\"/||;\n            $val =~ s|/\\w{0,3}\"$||;\n\n            ### see if this pcre only has strings separated with \".*\" or \".+\"\n            ### and if so translate to multple string matches\n            my ($pcre_rv, $pcre_strings_ar) = &parse_pcre($val);\n            if ($pcre_rv) {\n                for my $str (@$pcre_strings_ar) {\n                    push @patterns, $str;\n                }\n            } else {\n                unless ($queue_mode or $nfqueue_mode) {\n                    &logr(\"[-] SID: $sid, unsupported complex pcre: $val\");\n                    return 0, \\%opts, \\@patterns;\n                }\n            }\n\n        } elsif ($opt eq 'fast_pattern') {\n            if ($no_fast_pattern_order) {\n                ### force it to be the first pattern so no reordering\n                ### will happen\n                $patterns[0]->{'fast_pattern'} = 1;\n            } else {\n                $patterns[$#patterns]->{'fast_pattern'} = 1;\n            }\n        } elsif ($opt eq 'nocase') {\n            unless (defined $snort_opts{'ignore'}{'nocase'}) {\n                $patterns[$#patterns]->{'nocase'} = 1;\n            }\n        } else {\n            for my $key (qw(offset depth within distance)) {\n                if ($opt eq $key) {\n                    my ($offsets_rv, $log_str)\n                            = &define_offsets(\\@patterns,\n                                $avg_hdr_len, $key, $val);\n                    unless ($offsets_rv) {\n                        &logr(\"[-] SID: $sid, $log_str\");\n                        return 0, \\%opts, \\@patterns;\n                    }\n                    last;\n                }\n            }\n        }\n    }\n\n    if (($queue_mode or $nfqueue_mode) and not $found_content) {\n        my $queue_str = 'QUEUE';\n        $queue_str = 'NFQUEUE' if $nfqueue_mode;\n        &logr(\"[-] SID: $sid  In --$queue_str mode signature must have \" .\n                \"'content' or 'uricontent' keyword \" .\n                \"at line: $line_num, skipping.\");\n        if (%include_sids and defined $include_sids{$sid}) {\n            print \"[-] SID: $sid does not contain 'content' \",\n                  \"or 'uricontent'\\n\";\n        }\n        return 0, \\%opts, \\@patterns;\n    }\n\n    ### update offset, depth, within, and distance values for relative\n    ### matches\n    my ($offsets_rv, $log_str) = &update_offsets_relative_matches(\\@patterns);\n    unless ($offsets_rv) {\n        &logr(\"[-] SID: $sid, $log_str\");\n        return 0, \\%opts, \\@patterns;\n    }\n\n    for my $opt (keys %{$snort_opts{'logprefix'}}) {\n        if ($rule_options =~ $snort_opts{'logprefix'}{$opt}) {\n            $opts{$opt} = $1;\n        }\n    }\n\n    unless ($queue_mode or $nfqueue_mode) {\n        while ($rule_options =~ /(\\w+):\\s*.*?;/g) {\n            my $option = $1;\n            if (not defined $opts{$option}\n                    and not defined $snort_opts{'ignore'}{$option}) {\n                &logr(\"[-] SID: $sid bad option: \\\"$option\\\" at line: $line_num \" .\n                    \"-- $rule_options\");\n                return 0, \\%opts, \\@patterns;\n            }\n        }\n\n        if (defined $opts{'ipopts'}\n                and $opts{'ipopts'} ne 'rr'\n                and $opts{'ipopts'} ne 'ts'\n                and $opts{'ipopts'} ne 'ssrr'\n                and $opts{'ipopts'} ne 'lsrr'\n                and $opts{'ipopts'} ne 'any') {\n            &logr(\"[-] SID: $sid, unsupported ipopts field at \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n\n        if (defined $opts{'itype'}\n                and ($opts{'itype'} =~ m|<| or $opts{'itype'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in itype field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n        if (defined $opts{'icode'}\n                and ($opts{'icode'} =~ m|<| or $opts{'icode'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in icode field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n        if (defined $opts{'ip_proto'}\n                and ($opts{'ip_proto'} =~ m|<| or $opts{'ip_proto'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in ip_proto field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    ### success\n    return 1, \\%opts, \\@patterns;\n}\n\nsub parse_rule_hdr() {\n    my ($rule_hdr, $line_num) = @_;\n    my $bidir = 0;\n    my $action = 'alert';  ### default\n    if ($rule_hdr =~ /^\\s*pass/) {\n        $action = 'pass';\n    } elsif ($rule_hdr =~ /^\\s*log/) {\n        $action = 'log';\n    }\n    if ($rule_hdr =~ m|^\\s*\\w+\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\n                        \\s+(\\S+)\\s+(\\S+)\\s+(\\S+)|ix) {\n        my $proto  = lc($1);\n        my $src    = $2;\n        my $sport  = $3;\n        my $bidir  = $4;\n        my $dst    = $5;\n        my $dport  = $6;\n\n        unless ($proto =~ /^\\w+$/) {\n            &logr(\"[-] Unsupported protocol: \\\"$proto\\\" at line: \" .\n                \"$line_num, skipping.\");\n            return {};\n        }\n\n        ### in --ip6tables mode make sure we're not looking at IPv4 addresses\n        if ($enable_ip6tables\n                and ($src =~ /\\b$ip_re\\b/ or $dst =~ /\\b$ip_re\\b/)) {\n            &logr(\"[-] --ip6tables mode enabled but IPv4 \" .\n                \"address in rule variable at line: $line_num.\");\n            return {};\n        }\n\n        ### in --ip6tables mode exclude the icmp protocol - maybe should\n        ### change to icmp6 in the future\n        if ($enable_ip6tables and $proto eq 'icmp') {\n            &logr(\"[-] --ip6tables mode enabled, so excluding \" .\n                \"icmp (non-icmp6) siganture at line: $line_num.\");\n            return {};\n        }\n\n        my $bidir_flag = 0;\n        $bidir_flag = 1 if $bidir eq '<>';\n\n        my %hsh = (\n            'action' => $action,\n            'proto'  => $proto,\n            'src'    => $src,\n            'sport'  => $sport,\n            'bidir'  => $bidir_flag,\n            'dst'    => $dst,\n            'dport'  => $dport,\n        );\n\n        ### map to expanded values (e.g. $HOME -> \"any\" or whatever\n        ### is defined in fwsnort.conf)\n        for my $var (qw(src sport dst dport)) {\n            my $val = $hsh{$var};\n            my $negate_flag = 0;\n            $negate_flag = 1 if $val =~ m|!|;\n            while ($val =~ /\\$(\\w+)/) {\n                $val = $1;\n                if (defined $config{$val}) {\n                    $val = $config{$val};\n                    if ($enable_ip6tables and $val =~ /\\b$ip_re\\b/) {\n                        &logr(\"[-] --ip6tables mode enabled but IPv4 \" .\n                            \"address in rule variable at line: $line_num.\");\n                        return {};\n                    }\n                } else {\n                    &logr(\"[-] Undefined variable $val in rule header \" .\n                        \"at line: $line_num.\");\n                    return {};\n                }\n            }\n            if ($negate_flag and $val !~ m|!|) {\n                $hsh{$var} = \"!$val\";\n            } else {\n                $hsh{$var} = $val;\n            }\n        }\n\n        for my $var (qw(sport dport)) {\n            next unless $hsh{$var} =~ /,/;\n            if ($ipt_have_multiport_match) {\n                $hsh{$var} =~ s/\\[//;\n                $hsh{$var} =~ s/\\]//;\n                my $ctr = 1;\n                my @ports = split /\\s*,\\s*/, $hsh{$var};\n                my $ports_str = '';\n                for my $port (@ports) {\n                    if ($port =~ /\\d+:$/) {\n                        $ports_str .= \"${port}65535,\";\n                    } else {\n                        $ports_str .= \"${port},\";\n                    }\n                    $ctr++;\n                    $ctr++ if $port =~ /\\:/;  ### a range counts for two ports\n                    ### multiport is limited to 15 ports\n                    last if $ctr >= $ipt_multiport_max;\n                }\n                $ports_str =~ s/,$//;\n                $hsh{$var} = $ports_str;\n            } else {\n                &logr(\"[-] Warning: taking the first port in the list \" .\n                    \"$hsh{$var} until the $ipt_str multiport match is supported \" .\n                    \"at line: $line_num.\");\n                $hsh{$var} =~ s/,.*//;\n                $hsh{$var} =~ s/\\[//;\n                $hsh{$var} =~ s/\\]//;\n            }\n        }\n\n        return \\%hsh;\n    }\n    return {};\n}\n\nsub parse_pcre() {\n    my $pcre = shift;\n    my $rv = 0;\n    my @patterns = ();\n\n    if ($pcre =~ m|^\\w+$|) {\n        push @patterns, (&convert_pattern_for_iptables($pcre))[2];\n        $rv = 1;\n    } elsif ($pcre =~ m|UNION\\x5c\\x73\\x2bSELECT|) {\n        ### a bunch of Emerging Threats rules contain \"UNION\\s+SELECT\"\n        ### as a PCRE.  Sure, the translation below can be evaded, but\n        ### it is better than nothing.\n        push @patterns, (&convert_pattern_for_iptables('UNION SELECT'))[2];\n        $rv = 1;\n    } else {\n        my @ar = ();\n        if ($pcre =~ m|\\.\\*|) {\n            @ar = split /\\.\\*/, $pcre;\n            $rv = 1;\n        } elsif ($pcre =~ m|\\.\\+|) {\n            @ar = split /\\.\\+/, $pcre;\n            $rv = 1;\n        } elsif ($pcre =~ m|\\x5b\\x5e\\x5c\\x6e\\x5d\\x2b|) {  ### [^\\n]+\n            @ar = split /\\x5b\\x5e\\x5c\\x6e\\x5d\\x2b/, $pcre;\n            $rv = 1;\n        }\n        if ($rv == 1) {\n            for my $part (@ar) {\n                next unless $part;  ### some Snort pcre's begin with .* or .+\n                                    ### (which seems useless)\n\n                ### Replace \"\\(\" with hex equivalent in PCRE's\n                ### like: /.+ASCII\\(.+SELECT/\n                $part =~ s/\\x5c\\x28/|5c 28|/;\n\n                ### Replace \"\\:\" with hex equivalent in PCRE's\n                ### like: /User-Agent\\:[^\\n]+spyaxe/\n                $part =~ s/\\x5c\\x3a/|5c 3a|/;\n\n                my $basic = $part;\n                $basic =~ s/\\|5c 28\\|//;\n                $basic =~ s/\\|5c 3a\\|//;\n\n                if ($basic =~ /^[\\w\\x20]+$/) {\n                    push @patterns, (&convert_pattern_for_iptables($part))[2];\n                } elsif ($basic eq 'User-Agent') {\n                    push @patterns, (&convert_pattern_for_iptables($part))[2];\n                } else {\n                    $rv = 0;\n                }\n            }\n        }\n    }\n    return $rv, \\@patterns;\n}\n\nsub queue_get_rule() {\n    my ($rule_hdr, $rule_opts) = @_;\n\n    ### FIXME: the following commented out code would need to be\n    ### drastically improved to ensure that the remaining signatures\n    ### are completely unique in userspace.  For now, just return\n    ### the original Snort rule\n    ###     Remove all of the following keywords since they are handled\n    ###     within the kernel directly.\n#    for my $key qw/uricontent content offset depth within distance/ {\n#        $rule_opts =~ s/([\\s;])$key:\\s*.*?\\s*;\\s*/$1/g;\n#    }\n\n    $rule_opts =~ s/^\\s*//;\n    $rule_opts =~ s/\\s*$//;\n\n    return \"$rule_hdr ($rule_opts)\";\n}\n\nsub ipt_allow_traffic() {\n    my ($hdr_hr, $opts_hr, $chain, $orig_snort_rule) = @_;\n\n    my $rule_ctr = 0;\n\n    if ($dump_snort) {\n        print \"\\n[+] Snort rule: $orig_snort_rule\"\n                unless defined $snort_dump_cache{$orig_snort_rule};\n        $snort_dump_cache{$orig_snort_rule} = '';\n    }\n\n    ### check to see if the header is allowed through the chain,\n    ### and if not we don't really care about matching traffic\n    ### because iptables doesn't allow it anyway\n    RULE: for my $rule_hr (@{$ipt_policy{$chain}}) {\n        $rule_ctr++;\n\n        if ($dumper and $verbose) {\n            print \"[+] RULE: $rule_ctr:\\n\",\n                Dumper($rule_hr);\n        }\n        if ($dump_ipt) {\n            print \"[+] $ipt_str rule: $rule_hr->{'raw'}\\n\"\n                unless defined $ipt_dump_cache{$rule_hr->{'raw'}};\n            $ipt_dump_cache{$rule_hr->{'raw'}} = '';\n        }\n\n        ### don't match on rules to/from the loopback interface\n        unless ($no_exclude_loopback) {\n            if ($rule_hr->{'intf_in'} eq 'lo'\n                    or $rule_hr->{'intf_out'} eq 'lo') {\n                print \"[-] Skipping $chain rule $rule_ctr: loopback rule\\n\"\n                    if $debug;\n                next RULE;\n            }\n        }\n\n        ### don't match on rules that build state\n        if ($rule_hr->{'extended'} =~ /state/) {\n            print \"[-] Skipping $chain rule $rule_ctr: state rule\\n\"\n                if $debug;\n            next RULE;\n        }\n\n        ### match protocol\n        unless (($hdr_hr->{'proto'} eq $rule_hr->{'proto'}\n                or $rule_hr->{'proto'} eq 'all')) {\n            print \"[-] Skipping $chain rule $rule_ctr: $hdr_hr->{'proto'} \",\n                \"!= $rule_hr->{'proto'}\\n\" if $debug;\n            next RULE;\n        }\n\n        ### match src/dst IP/network\n        unless (&match_addr($hdr_hr->{'src'}, $rule_hr->{'src'})) {\n            print \"[-] Skipping $chain rule $rule_ctr: src $hdr_hr->{'src'} \",\n                \"not part of $rule_hr->{'src'}\\n\" if $debug;\n            next RULE;\n        }\n        unless (&match_addr($hdr_hr->{'dst'}, $rule_hr->{'dst'})) {\n            print \"[-] Skipping $chain rule $rule_ctr: dst $hdr_hr->{'dst'} \",\n                \"not part of $rule_hr->{'dst'}\\n\" if $debug;\n            next RULE;\n        }\n\n        ### match src/dst ports\n        if ($hdr_hr->{'proto'} ne 'icmp') {\n            unless (&match_port($hdr_hr->{'sport'},\n                    $rule_hr->{'sport'})) {\n                print \"[-] Skipping $chain rule $rule_ctr: sport \",\n                    \"$hdr_hr->{'sport'} not part of $rule_hr->{'sport'}\\n\"\n                    if $debug;\n                next RULE;\n            }\n            unless (&match_port($hdr_hr->{'dport'},\n                    $rule_hr->{'dport'})) {\n                print \"[-] Skipping $chain rule $rule_ctr: dport \",\n                    \"$hdr_hr->{'dport'} not part of $rule_hr->{'dport'}\\n\"\n                    if $debug;\n                next RULE;\n            }\n        }\n\n        if (defined $opts_hr->{'flow'} and $rule_hr->{'state'}) {\n            if ($opts_hr->{'flow'} eq 'established') {\n                unless ($rule_hr->{'state'} =~ /ESTABLISHED/) {\n                    print \"[-] Skipping $chain rule $rule_ctr: state \",\n                        \"$opts_hr->{'flow'} not part of $rule_hr->{'state'}\\n\"\n                        if $debug;\n                    next RULE;\n                }\n            }\n        }\n\n        ### if we make it here, then this rule matches the signature\n        ### (from a header perspective)\n        if ($rule_hr->{'target'} eq 'DROP'\n                or $rule_hr->{'target'} eq 'REJECT') {\n\n            print \"[-] Matching $ipt_str rule has DROP or REJECT target; \",\n                \"$ipt_str policy does not allow this Snort rule.\\n\"\n                if $debug;\n            if ($dumper) {\n                print \"\\n[-] RULE $chain DROP:\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    Dumper($rule_hr),\n                    \"\\n\";\n            }\n            return 0;\n        } elsif ($rule_hr->{'target'} eq 'ACCEPT') {\n            if ($dumper) {\n                print \"\\n[+] RULE $chain ACCEPT:\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    Dumper($rule_hr),\n                    \"\\n\";\n            }\n            print \"[-] Matching $ipt_str rule has ACCEPT target; \",\n                \"$ipt_str policy allows this Snort rule.\\n\" if $debug;\n            return 1;\n        }  ### we don't support other targets besides DROP, REJECT,\n           ### or ACCEPT for now.\n    }\n\n    ### if we make it here, then no specific ACCEPT rule matched the header,\n    ### so return false if the chain policy is set to DROP (or there is\n    ### a default drop rule). Otherwise there is no rule that would block\n    ### the traffic.\n    if (defined $ipt_default_policy_setting{$chain}) {\n        if ($ipt_default_policy_setting{$chain} eq 'ACCEPT') {\n            if (defined $ipt_default_drop{$chain}) {\n                if (defined $ipt_default_drop{$chain}{'all'}) {\n                    print \"[-] Default DROP rule applies to this Snort rule.\\n\"\n                        if $debug;\n                    return 0;\n                } elsif (defined $ipt_default_drop{$chain}\n                        {$hdr_hr->{'proto'}}) {\n                    print \"[-] Default DROP rule applies to this Snort rule.\\n\"\n                        if $debug;\n                    return 0;\n                }\n            }\n            if ($dumper) {\n                print \"\\nACCEPT $chain, no $ipt_str matching rule\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    \"\\n\";\n            }\n            return 1;\n        }\n    }\n    if ($dumper) {\n        print \"\\nDROP $chain, no $ipt_str matching rule\\n\",\n            Dumper($hdr_hr),\n            Dumper($opts_hr),\n            \"\\n\";\n    }\n\n    ### maybe a \"strict\" option should be added here?\n    return 0;\n}\n\nsub match_addr() {\n    my ($hdr_src, $rule_src) = @_;\n    return 1 if $rule_src eq '0.0.0.0/0';\n    return 1 if $hdr_src =~ /any/i;\n    return 1 if $hdr_src eq $rule_src;\n\n    my $ipt_ip   = '';\n    my $ipt_mask = '32';\n    my $negate = 0;\n\n    my $s_obj   = '';\n    my $ipt_obj = '';\n\n    $negate = 1 if $hdr_src =~ /\\!/;\n\n    if ($rule_src =~ /\\!/) {\n        if ($negate) {\n            ### if both hdr_src and rule_src are negated\n            ### then revert to normal match.\n            $negate = 0;\n        } else {\n            $negate = 1;\n        }\n    }\n\n    if ($rule_src =~ m|($ip_re)/($ip_re)|) {\n        $ipt_ip   = $1;\n        $ipt_mask = $2;\n    } elsif ($rule_src =~ m|($ip_re)/(\\d+)|) {\n        $ipt_ip   = $1;\n        $ipt_mask = $2;\n    } elsif ($rule_src =~ m|($ip_re)|) {\n        $ipt_ip = $1;\n    }\n\n    $ipt_obj = new NetAddr::IP($ipt_ip, $ipt_mask);\n\n    for my $addr (@{&expand_addresses($hdr_src)}) {\n        my $src_ip   = '';\n        my $src_mask = '32';\n        if ($addr =~ m|($ip_re)/($ip_re)|) {\n            $src_ip   = $1;\n            $src_mask = $2;\n        } elsif ($addr =~ m|($ip_re)/(\\d+)|) {\n            $src_ip   = $1;\n            $src_mask = $2;\n        } elsif ($addr =~ m|($ip_re)|) {\n            $src_ip = $1;\n        }\n        $s_obj = new NetAddr::IP($src_ip, $src_mask);\n        if ($negate) {\n            return 1 unless $ipt_obj->within($s_obj);\n        } else {\n            return 1 if $ipt_obj->within($s_obj);\n        }\n    }\n    return 0;\n}\n\nsub match_port() {\n    my ($snort_port, $ipt_port) = @_;\n    return 1 if $ipt_port eq '0:0';\n    return 1 if $snort_port =~ /any/i;\n    return 1 if $ipt_port eq $snort_port;\n    my $ipt_start = 0;\n    my $ipt_end   = 65535;\n    my $h_start   = 0;\n    my $h_end     = 65535;\n\n    if ($ipt_port =~ /:/) {\n        if ($ipt_port =~ /(\\d+):/) {\n            $ipt_start = $1;\n        }\n        if ($ipt_port =~ /:(\\d+)/) {\n            $ipt_end = $1;\n        }\n    } elsif ($ipt_port =~ /(\\d+)/) {\n        $ipt_start = $ipt_end = $1;\n    }\n\n    if ($snort_port =~ /:/) {\n        if ($snort_port =~ /(\\d+):/) {\n            $h_start = $1;\n        }\n        if ($snort_port =~ /:(\\d+)/) {\n            $h_end = $1;\n        }\n    } elsif ($snort_port =~ /(\\d+)/) {\n        $h_start = $h_end = $1;\n    }\n\n    if ($ipt_port =~ /!/) {\n        if ($snort_port =~ /!/) {\n            return 0;\n        } else {\n            return 1 if (($h_start < $ipt_start and $h_end < $ipt_start)\n                    or ($h_start > $ipt_end and $h_end > $ipt_end));\n        }\n    } else {\n        if ($snort_port =~ /!/) {\n            return 1 if (($ipt_start < $h_start and $ipt_end < $h_start)\n                    or ($ipt_start > $h_end and $ipt_end > $h_end));\n        } else {\n            return 1 if $h_start >= $ipt_start and $h_end <= $ipt_end;\n        }\n    }\n    return 0;\n}\n\nsub cache_ipt_policy() {\n\n    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'}\n        or die \"[*] Could not acquire IPTables::Parse object: $!\";\n\n    for my $chain (keys %process_chains) {\n        next unless $process_chains{$chain};\n\n        $ipt_policy{$chain} = $ipt->chain_rules('filter',\n            $chain, $ipt_file);\n\n        $ipt_default_policy_setting{$chain}\n            = $ipt->chain_policy('filter', $chain, $ipt_file);\n\n        my ($def_drop_hr, $ipt_rv)\n            = $ipt->default_drop('filter', $chain, $ipt_file);\n\n        if ($ipt_rv) {\n            $ipt_default_drop{$chain} = $def_drop_hr;\n        }\n    }\n    return;\n}\n\nsub ipt_build() {\n    my ($snort_hdr_hr, $snort_opts_hr, $patterns_ar, $orig_snort_rule) = @_;\n\n    my $found_rule = 0;\n    my $num_rules  = 0;\n\n    my %process_rules = ();\n\n    ### define iptables source and destination\n    if ($snort_hdr_hr->{'dst'} =~ /any/i) {\n        if ($snort_hdr_hr->{'src'} =~ /any/i) {\n            if ($orig_snort_rule =~ m|\\$HOME_NET.*\\-\\>\\s+\\$EXTERNAL_NET|) {\n                push @{$process_rules{'OUTPUT'}}, '' if $process_chains{'OUTPUT'};\n            } else {\n                push @{$process_rules{'INPUT'}}, '' if $process_chains{'INPUT'};\n            }\n            push @{$process_rules{'FORWARD'}}, ''\n                if $process_chains{'FORWARD'};\n        } else {\n            my $addr_ar = &expand_addresses($snort_hdr_hr->{'src'});\n            my $negate = '';\n            $negate = '! ' if $snort_hdr_hr->{'src'} =~ m|!|;\n            unless ($addr_ar) {\n                &logr(\"[-] No valid source IPs/networks in Snort \" .\n                    \"rule header.\");\n                return 0, 0;\n            }\n            for my $src (@$addr_ar) {\n                if (&is_local($src)) {\n                    push @{$process_rules{'OUTPUT'}},\n                            \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                            if $process_chains{'OUTPUT'};\n                } else {\n                    push @{$process_rules{'INPUT'}},\n                            \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                            if $process_chains{'INPUT'};\n                }\n                push @{$process_rules{'FORWARD'}},\n                        \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                        if $process_chains{'FORWARD'};\n            }\n        }\n    } else {\n        my $dst_addr_ar = &expand_addresses($snort_hdr_hr->{'dst'});\n        unless ($dst_addr_ar) {\n            &logr(\"[-] No valid destination IPs/networks in Snort rule \" .\n                \"header.\");\n            return 0, 0;\n        }\n        if ($snort_hdr_hr->{'src'} =~ /any/i) {\n            my $negate = '';\n            $negate = '! ' if $snort_hdr_hr->{'dst'} =~ m|!|;\n            for my $dst (@$dst_addr_ar) {\n                if (&is_local($dst)) {\n                    push @{$process_rules{'INPUT'}},\n                            \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'INPUT'};\n                } else {\n                    push @{$process_rules{'OUTPUT'}},\n                            \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'OUTPUT'};\n                }\n                push @{$process_rules{'FORWARD'}},\n                        \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                        if $process_chains{'FORWARD'};\n            }\n        } else {\n            my $src_addr_ar = &expand_addresses($snort_hdr_hr->{'src'});\n            my $negate_src = '';\n            $negate_src = '! ' if $snort_hdr_hr->{'src'} =~ m|!|;\n            my $negate_dst = '';\n            $negate_dst = '! ' if $snort_hdr_hr->{'dst'} =~ m|!|;\n            unless ($src_addr_ar) {\n                &logr(\"[-] No valid source IPs/networks in Snort rule \" .\n                    \"header.\");\n                return 0, 0;\n            }\n            for my $src (@$src_addr_ar) {\n                for my $dst (@$dst_addr_ar) {\n                    if (&is_local($dst)) {\n                        push @{$process_rules{'INPUT'}},\n                            \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                            \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'INPUT'};\n                    } else {\n                        push @{$process_rules{'OUTPUT'}},\n                            \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                            \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'OUTPUT'};\n                    }\n                    push @{$process_rules{'FORWARD'}},\n                        \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                        \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                        if $process_chains{'FORWARD'};\n                }\n            }\n        }\n    }\n\n    ### determine which chain (e.g. stateful/stateless)\n    my $flow_established = '';\n    unless ($no_ipt_conntrack) {\n        if (defined $snort_hdr_hr->{'proto'}\n                and $snort_hdr_hr->{'proto'} =~ /tcp/i\n                and defined $snort_opts_hr->{'flow'}\n                and $snort_opts_hr->{'flow'} =~ /established/i) {\n            $flow_established = 'ESTABLISHED';\n        }\n    }\n\n    my $add_snort_comment = 1;\n    my $add_perl_trigger  = 1;\n    for my $chain (keys %process_chains) {\n\n        next unless $process_chains{$chain} and $process_rules{$chain};\n\n        for my $src_dst (@{$process_rules{$chain}}) {\n\n            my $rule = \"\\$${ipt_var_str} -A \";\n            my $save_rule = '-A';\n            my $fwsnort_chain = '';\n\n            ### see if we can jump to the ESTABLISHED inspection chain.\n            if ($flow_established) {\n                $rule .= $config{\"FWSNORT_${chain}_ESTAB\"};\n                $fwsnort_chain = $config{\"FWSNORT_${chain}_ESTAB\"};\n            } else {\n                $rule .= $config{\"FWSNORT_$chain\"};\n                $fwsnort_chain = $config{\"FWSNORT_$chain\"};\n            }\n\n            ### append interface restriction if necessary\n            if ($src_dst =~ m|127\\.0\\.0\\.\\d/|) {\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                    $rule .= ' ! -i lo';\n                } elsif ($chain eq 'OUTPUT') {\n                    $rule .= ' ! -o lo';\n                }\n            }\n\n            ### append source and destination criteria\n            if ($src_dst) {\n                if ($chain eq 'FORWARD') {\n                    $rule .= \" $src_dst\";\n                } elsif ($chain eq 'INPUT') {\n                    ### we always treat the INPUT chain as part of the HOME_NET;\n                    ### the system running iptables may have an interface on the\n                    ### external network and hence may not be part of the HOME_NET\n                    ### as defined in the fwsnort.conf file so we don't necessarily\n                    ### append the IP criteria\n                    if ($src_dst ne \"$ipt_hdr_opts{'dst'} $config{'HOME_NET'}\") {\n                        $rule .= \" $src_dst\";\n                    }\n                } elsif ($chain eq 'OUTPUT') {\n                    if ($src_dst ne \"$ipt_hdr_opts{'src'} $config{'HOME_NET'}\") {\n                        $rule .= \" $src_dst\";\n                    }\n                }\n            }\n\n            my $rv = &ipt_build_rule(\n                $chain,\n                $fwsnort_chain,\n                $rule,\n                $snort_hdr_hr,\n                $snort_opts_hr,\n                $patterns_ar,\n                $orig_snort_rule,\n                $flow_established,\n                $add_snort_comment,\n                $add_perl_trigger\n            );\n            if ($rv) {\n                $found_rule        = 1;\n                $add_snort_comment = 0;\n                $add_perl_trigger  = 0;\n                $num_rules++;\n            }\n        }\n    }\n    return $found_rule, $num_rules;\n}\n\nsub is_local() {\n    my $addr = shift;\n\n    return 1 if $no_addr_check;\n\n    my $ip   = '';\n    my $mask = '32';\n\n    if ($addr =~ m|($ip_re)/($ip_re)|) {\n        $ip   = $1;\n        $mask = $2;\n    } elsif ($addr =~ m|($ip_re)/(\\d+)|) {\n        $ip   = $1;\n        $mask = $2;\n    } elsif ($addr =~ m|($ip_re)|) {\n        $ip = $1;\n    }\n\n    my $ip_obj = new NetAddr::IP($ip, $mask);\n\n    for my $local_ar (@local_addrs) {\n        my $local_ip   = $local_ar->[0];\n        my $local_mask = $local_ar->[1];\n\n        my $local_obj = new NetAddr::IP($local_ip, $local_mask);\n\n        return 1 if $ip_obj->within($local_obj);\n    }\n    return 0;\n}\n\nsub get_local_addrs() {\n    open IFC, \"$cmds{'ifconfig'} -a |\" or die \"[*] Could not run \",\n        \"$cmds{'ifconfig'}: $!\";\n    my @lines = <IFC>;\n    close IFC;\n\n    my $intf_name = '';\n    for my $line (@lines) {\n        if ($line =~ /^(\\w+)\\s+Link/) {\n            $intf_name = $1;\n            next;\n        }\n        next if $intf_name eq 'lo';\n        next if $intf_name =~ /dummy/i;\n        if ($line =~ /^\\s+inet.*?:($ip_re).*:($ip_re)/i) {\n            push @local_addrs, [$1, $2];\n        }\n    }\n    return;\n}\n\nsub ipt_build_rule() {\n    my ($chain, $fwsnort_chain, $rule, $hdr_hr, $opts_hr, $patterns_ar,\n            $orig_snort_rule, $flow_logging_prefix, $add_snort_comment,\n            $add_perl_trigger) = @_;\n\n    ### $chain is used only to see whether or not we need to add the\n    ### rule to the iptables script based on whether the built-in chain\n    ### will pass the traffic in the first place.\n    if ($ipt_sync) {\n        return 0 unless &ipt_allow_traffic($hdr_hr,\n                $opts_hr, $chain, $orig_snort_rule);\n    }\n\n    ### append the protocol to the rule\n    if (defined $opts_hr->{'ip_proto'}) {\n        return 0 unless $opts_hr->{'ip_proto'} =~ /^\\w+$/;\n        $rule .= \" $snort_opts{'filter'}{'ip_proto'}{'iptopt'} \" .\n            \"$opts_hr->{'ip_proto'}\";\n    } else {\n        return 0 unless $hdr_hr->{'proto'} =~ /^\\w+$/;\n        if ((($hdr_hr->{'sport'} !~ /any/i and $hdr_hr->{'sport'} ne '')\n                or ($hdr_hr->{'dport'} !~ /any/i\n                and $hdr_hr->{'dport'} ne ''))\n                and $hdr_hr->{'proto'} !~ /tcp/i\n                and $hdr_hr->{'proto'} !~ /udp/i) {\n            ### force to tcp because iptables does not like src/dst\n            ### ports with anything other than tcp or udp\n            $hdr_hr->{'proto'} = 'tcp';\n        }\n\n        if ($hdr_hr->{'proto'} =~ /ip/) {\n            $rule .= \" $ipt_hdr_opts{'proto'} $hdr_hr->{'proto'}\";\n        } else {\n            $rule .= \" $ipt_hdr_opts{'proto'} $hdr_hr->{'proto'} \" .\n                \"-m $hdr_hr->{'proto'}\";\n        }\n    }\n\n    ### append the source and destination ports\n    for my $type (qw(sport dport)) {\n        if (defined $hdr_hr->{$type} and $hdr_hr->{$type} !~ /any/i) {\n            my $negate = '';\n            my $port = $hdr_hr->{$type};\n            $negate = '! ' if $port =~ m|!|;\n            $port =~ s/\\!\\s*(\\d)/$1/;\n            if ($port =~ /,/) {\n                ### multiport match\n                $rule .= \" -m multiport ${negate}--${type}s $port\";\n            } else {\n                $rule .= \" ${negate}$ipt_hdr_opts{$type} $port\";\n            }\n        }\n    }\n\n    my $rv = &ipt_build_opts($rule, $hdr_hr, $opts_hr, $patterns_ar,\n        $orig_snort_rule, $flow_logging_prefix, $chain, $fwsnort_chain,\n        $add_snort_comment, $add_perl_trigger);\n\n    return $rv;\n}\n\nsub ipt_build_opts() {\n    my ($rule, $hdr_hr, $opts_hr, $patterns_ar, $orig_snort_rule,\n            $flow_logging_prefix, $chain, $fwsnort_chain, $add_snort_comment,\n            $add_perl_trigger) = @_;\n\n    ### append tcp flags\n    if (defined $opts_hr->{'flags'}) {\n        my $f_str = '';\n\n        $f_str .= 'URG,' if $opts_hr->{'flags'} =~ /U/i;\n        $f_str .= 'ACK,' if $opts_hr->{'flags'} =~ /A/i;\n        $f_str .= 'PSH,' if $opts_hr->{'flags'} =~ /P/i;\n        $f_str .= 'RST,' if $opts_hr->{'flags'} =~ /R/i;\n        $f_str .= 'SYN,' if $opts_hr->{'flags'} =~ /S/i;\n        $f_str .= 'FIN,' if $opts_hr->{'flags'} =~ /F/i;\n        $f_str =~ s/\\,$//;\n\n        if ($opts_hr->{'flags'} =~ /\\+/) {\n            ### --tcp-flags ACK ACK\n            $rule .= \" $snort_opts{'filter'}{'flags'}{'iptopt'} \" .\n                \"$f_str $f_str\";\n        } else {\n            ### --tcp-flags ALL URG,PSH,SYN,FIN\n            $rule .= \" $snort_opts{'filter'}{'flags'}{'iptopt'} \" .\n                \"ALL $f_str\";\n        }\n    }\n\n    if ($no_ipt_conntrack) {\n        ### fall back to appending --tcp-flags ACK ACK if flow=established.\n        ### NOTE: we can't really handle \"flow\" in the same way snort can,\n        ### since there is no way to keep track of which side initiated the\n        ### tcp session (where the SYN packet came from), but older versions\n        ### of snort (pre 1.9) just used tcp flags \"A+\" to keep track of\n        ### this... we need to do the same.\n        if (defined $opts_hr->{'flow'} && ! defined $opts_hr->{'flags'}) {\n            if ($opts_hr->{'flow'} =~ /established/i) {\n                ### note that this ignores the \"stateless\" keyword\n                ### as it should...\n                $rule .= \" $snort_opts{'filter'}{'flow'}{'iptopt'} ACK ACK\";\n            }\n        }\n    }\n\n    ### append icmp type\n    if ($hdr_hr->{'proto'} =~ /icmp/i) {\n        if (defined $opts_hr->{'itype'}) {\n            $rule .= \" $snort_opts{'filter'}{'itype'}{'iptopt'} \" .\n                \"$opts_hr->{'itype'}\";\n            ### append icmp code (becomes \"--icmp-type type/code\")\n            if (defined $opts_hr->{'icode'}) {\n                $rule .= \"/$opts_hr->{'icode'}\";\n            }\n        } else {\n            ### append the default icmp type since some recent versions of\n            ### iptables (such as 1.4.12 on Fedora 16) require it - an error\n            ### like the following will be thrown if it's not there:\n            ### iptables-restore v1.4.12: icmp: option \"--icmp-type\" must be specified\n            $rule .= \" $snort_opts{'filter'}{'itype'}{'iptopt'} \" .\n                $default_icmp_type;\n        }\n    }\n\n    ### append ip options\n    if (defined $opts_hr->{'ipopts'}) {\n        $rule .= \" $snort_opts{'filter'}{'ipopts'}{'iptopt'} \" .\n            \"--$opts_hr->{'ipopts'}\"\n    }\n\n    ### append tos (requires CONFIG_IP_NF_MATCH_TOS)\n    if (defined $opts_hr->{'tos'}) {\n        $rule .= \" $snort_opts{'filter'}{'tos'}{'iptopt'} \" .\n            \"$opts_hr->{'tos'}\"\n    }\n\n\n    ### append ttl (requires CONFIG_IP_NF_MATCH_TTL)\n    if (defined $opts_hr->{'ttl'}) {\n        if ($opts_hr->{'ttl'} =~ /\\<\\s*(\\d+)/) {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} --ttl-lt $1\";\n        } elsif ($opts_hr->{'ttl'} =~ /\\>\\s*(\\d+)/) {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} --ttl-gt $1\";\n        } else {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} \" .\n                \"--ttl-eq $opts_hr->{'ttl'}\";\n        }\n    }\n\n    my $avg_hdr_len = &get_avg_hdr_len($hdr_hr);\n\n    ### append dsize option (requires CONFIG_IP_NF_MATCH_LENGTH)\n    if (defined $opts_hr->{'dsize'}) {\n        ### get the average packet header size based on the protocol\n        ### (the iptables length match applies to the network header\n        ### and up).\n        if ($opts_hr->{'dsize'} =~ m|(\\d+)\\s*<>\\s*(\\d+)|) {\n            my $iptables_len1 = $1 + $avg_hdr_len;\n            my $iptables_len2 = $2 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                \"$iptables_len1:$iptables_len2\";\n        } elsif ($opts_hr->{'dsize'} =~ m|<\\s*(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                \"$avg_hdr_len:$iptables_len\";\n        } elsif ($opts_hr->{'dsize'} =~ m|>\\s*(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            if ($iptables_len < $config{'MAX_FRAME_LEN'} + $avg_hdr_len) {\n                $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                    \"$iptables_len:\" .\n                    ($config{'MAX_FRAME_LEN'} + $avg_hdr_len);\n            }\n        } elsif ($opts_hr->{'dsize'} =~ m|(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                $iptables_len;\n        }\n    }\n\n    ### append snort content options\n    my $ipt_content_criteria = 0;\n    my $perl_trigger_str = '';\n\n    if ($#$patterns_ar > -1) {\n        ($ipt_content_criteria, $perl_trigger_str)\n            = &build_content_matches($opts_hr, $patterns_ar);\n\n        return 0 unless $ipt_content_criteria;\n        $rule .= $ipt_content_criteria;\n    }\n\n    ### print the rest of the logprefix snort options in a comment\n    ### one line above the rule\n    my $comment    = '';\n    my $target_str = '';\n    for my $key (qw(sid msg classtype reference priority rev)) {\n        if (defined $opts_hr->{$key}) {\n            $comment .= qq|$key:$opts_hr->{$key}; |;\n        }\n    }\n    $comment =~ s/\\s*$//;\n    $comment =~ s/,$//;\n\n    ### append the fwsnort version as \"FWS:$version\"\n    $comment .= \" FWS:$version;\";\n\n    ### build up the logging prefix and comment match\n    if (defined $opts_hr->{'sid'}) {\n        unless ($no_ipt_comments) {\n            ### add the Snort msg (and other) fields to the iptables rule\n            ### with the 'comment' match (which can handle up to 255 chars\n            ### and is set/verified by the ipt_find_max_comment_len()\n            ### function).\n            $comment =~ s|\\\"||g;\n            $comment =~ s|/\\*||g;\n            $comment =~ s|\\*/||g;\n            if (length($comment) < $ipt_max_comment_len) {\n                $target_str = qq| -m comment --comment \"$comment\"|;\n            }\n        }\n        ### increment chain counter and add in if necessary\n        $chain_ctr{$chain}++;\n\n        if ($queue_mode or $nfqueue_mode) {\n            if ($queue_mode) {\n                $target_str .= qq| -j QUEUE|;\n            } else {\n                $target_str .= qq| -j NFQUEUE|;\n                if ($nfqueue_num) {\n                    $target_str .= \" --queue-num $nfqueue_num\";\n                }\n            }\n        } else {\n            if ($hdr_hr->{'action'} eq 'log' or $ulog_mode) {\n                $target_str .= qq| -j ULOG --ulog-nlgroup $ulog_nlgroup --ulog-prefix \"|;\n            } else {\n                $target_str .= ' -j LOG ';\n                $target_str .= '--log-ip-options ' unless $no_ipt_log_ip_opts;\n                if ($hdr_hr->{'proto'} eq 'tcp') {\n                    $target_str .= '--log-tcp-options ' unless $no_ipt_log_tcp_opts;\n                    $target_str .= '--log-tcp-sequence ' if $ipt_log_tcp_seq;\n                }\n                $target_str .= qq|--log-prefix |;\n            }\n\n\n            ### build up the LOG prefix string\n            my $prefix_str = '';\n\n            unless ($no_ipt_rule_nums) {\n                $prefix_str .= \"[$chain_ctr{$chain}] \";\n            }\n\n            if ($ipt_drop) {\n                $prefix_str .= 'DRP ';\n            } elsif ($ipt_reject) {\n                $prefix_str .= 'REJ ';\n            }\n\n            ### always add the sid\n            $prefix_str .= qq|SID$opts_hr->{'sid'} |;\n            if ($flow_logging_prefix) {\n                $prefix_str .= 'ESTAB ';\n            }\n\n            if (length($prefix_str) >= $ipt_max_log_prefix_len) {\n                $prefix_str = qq|SID$opts_hr->{'sid'} |;\n                if (length($prefix_str) >= $ipt_max_log_prefix_len) {\n                    return 0 unless $ipt_content_criteria;\n                }\n            }\n\n            $target_str .= qq|\"| . $prefix_str . qq|\"|;\n        }\n    }\n\n    ### print the snort rules type header to the fwsnort.sh script\n    unless ($ipt_print_type) {\n        &ipt_type($snort_type);\n        $ipt_print_type = 1;\n    }\n\n    ### write the rule out to the iptables script\n    &ipt_add_rule($hdr_hr, $opts_hr, $orig_snort_rule,\n        $rule, $target_str, \"### $comment\", $add_snort_comment,\n        $perl_trigger_str, $add_perl_trigger, $chain, $fwsnort_chain);\n    return 1;\n}\n\nsub build_content_matches() {\n    my ($opts_hr, $patterns_ar) = @_;\n\n    my $fast_pattern_index   = 0;\n    my $fast_pattern_is_set  = 0;\n    my $ipt_content_criteria = '';\n    my $perl_trigger_command = '';\n    my @content_fast_pattern_order = ();\n\n    $perl_trigger_command = q|perl -e 'print \"| if $include_perl_triggers;\n\n    if ($no_fast_pattern_order) {\n        $patterns_ar->[0]->{'fast_pattern'} = 1;\n    }\n\n    for (my $index=0; $index <= $#$patterns_ar; $index++) {\n        if ($patterns_ar->[$index]->{'fast_pattern'}) {\n            $fast_pattern_index  = $index;\n            $fast_pattern_is_set = 1;\n            last;\n        }\n    }\n\n    unless ($fast_pattern_is_set) {\n        ### in this case, the 'fast_pattern' option was not used, so pick the\n        ### longest pattern to match first (this should help with performance\n        ### of signature matches on average)\n        my $max_len = 0;\n        my $max_len_index = 0;\n        PATTERN: for (my $index=0; $index <= $#$patterns_ar; $index++) {\n            my $pat_ar = $patterns_ar->[$index];\n\n            if ($pat_ar->{'length'} > $max_len) {\n\n                ### make sure it is not a relative match\n                next PATTERN if defined $pat_ar->{'distance'};\n                next PATTERN if defined $pat_ar->{'within'};\n\n                if ($index < $#$patterns_ar) {\n                    my $next_pat_ar = $patterns_ar->[$index+1];\n                    next PATTERN if defined $next_pat_ar->{'distance'};\n                    next PATTERN if defined $next_pat_ar->{'within'};\n                }\n\n                $max_len = $pat_ar->{'length'};\n                $max_len_index = $index;\n            }\n        }\n        $fast_pattern_index = $max_len_index;\n    }\n\n    $content_fast_pattern_order[0] = $patterns_ar->[$fast_pattern_index];\n    for (my $i=0; $i <= $#$patterns_ar; $i++) {\n        next if $i == $fast_pattern_index;\n        push @content_fast_pattern_order, $patterns_ar->[$i];\n    }\n\n    for (my $i=0; $i <= $#content_fast_pattern_order; $i++) {\n\n        if (($queue_mode or $nfqueue_mode) and $queue_pre_match_max > 0) {\n            ### limit the number of content matches to perform within the\n            ### kernel before sending the packet to a userspace Snort\n            ### instance\n            last if $i >= $queue_pre_match_max;\n        }\n\n        my $pattern_hr = $content_fast_pattern_order[$i];\n        my $content_str = $pattern_hr->{'ipt_pattern'};\n\n        if ($content_str =~ /\\|.+\\|/) {\n            ### there is hex data in the content\n            if ($pattern_hr->{'negative_match'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{! --hex-string \"$content_str\"};\n            } else {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{--hex-string \"$content_str\"};\n            }\n        } else {\n            ### there is no hex data in the content\n            if ($pattern_hr->{'negative_match'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{! --string \"$content_str\"};\n            } else {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{--string \"$content_str\"};\n            }\n        }\n\n        if (defined $opts_hr->{'replace'}) {\n            my $replace_str = $opts_hr->{'replace'};\n            $replace_str =~ s/`/\\\\`/g;\n            if ($replace_str =~ /\\|.+\\|/) {  ### there is hex data in the content\n                $ipt_content_criteria\n                        .= qq{ --replace-hex-string \"$replace_str\"};\n            } else {\n                $ipt_content_criteria\n                        .= qq{ --replace-string \"$replace_str\"};\n            }\n        }\n\n        if ($kernel_ver ne '2.4') {\n            $ipt_content_criteria .= \" --algo $string_match_alg\";\n\n            ### see if we have any offset, depth, distance, or within\n            ### criteria\n\n            if (defined $pattern_hr->{'offset'}) {\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'offset'}{'iptopt'} . \" $pattern_hr->{'offset'}\";\n                $perl_trigger_command .= 'A'x$pattern_hr->{'offset'}\n                    if $include_perl_triggers;\n\n            } elsif (defined $pattern_hr->{'distance'}) {  ### offset trumps distance\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'distance'}{'iptopt'} . \" $pattern_hr->{'distance'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'distance'}\n                    if $include_perl_triggers;\n            }\n\n            if (defined $pattern_hr->{'depth'}) {\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'depth'}{'iptopt'} . \" $pattern_hr->{'depth'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'depth'}\n                    if $include_perl_triggers;\n\n            } elsif (defined $pattern_hr->{'within'}) {  ### depth trumps within\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'within'}{'iptopt'} . \" $pattern_hr->{'within'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'within'}\n                    if $include_perl_triggers;\n            }\n\n            ### see if we need to match the string match case insensitive\n            if ($pattern_hr->{'nocase'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'nocase'}{'iptopt'};\n            }\n\n            ### if the --payload option is available for\n            ### the string match extension\n            $ipt_content_criteria .= ' --payload'\n                if $ipt_has_string_payload_offset_opt;\n        }\n\n        if ($include_perl_triggers) {\n            ### now append the perl trigger command bytes\n            if ($pattern_hr->{'negative_match'}) {\n                $perl_trigger_command .= 'A'x($pattern_hr->{'length'});\n            } else {\n                $perl_trigger_command .= &translate_perl_trigger($content_str);\n            }\n        }\n    }\n\n    if ($include_perl_triggers) {\n        $perl_trigger_command .= qq|\"'|;\n    }\n\n    return $ipt_content_criteria, $perl_trigger_command;\n}\n\nsub convert_pattern_for_iptables() {\n    my $snort_str = shift;\n\n    my $rv = 0;\n    my $ipt_str = $snort_str;\n    my $log_str = '';\n\n    my %pattern = (\n        'orig_snort_str' => $snort_str,\n        'ipt_pattern'    => '',\n        'negative_match' => 0,\n        'fast_pattern'   => 0,\n        'nocase'         => 0,\n    );\n\n    if ($ipt_str =~ /^\\s*\\!\\s*\"/) {\n        $ipt_str =~ s/^\\s*\\!\\s*\"//;\n        $pattern{'negative_match'} = 1;\n    }\n\n    ### convert all escaped chars to their hex equivalents\n    $ipt_str =~ s/\\x5c(.)/sprintf \"|%02x|\", (ord($1))/eg;\n\n    ### consolidate any consecutive \"|aa||bb|\" sequences\n    $ipt_str =~ s/\\|\\|//g;\n\n    ### remove all spaces between hex codes (they simply waste space\n    ### on the command line, and they aren't part of the string to\n    ### search in network traffic anyway).\n    $ipt_str = &consolidate_hex_spaces($ipt_str);\n\n    ### if there are any existing hex blocks or if there are any chars\n    ### that require a new hex block, then just convert the whole string\n    ### to hex syntax for simplicity\n    if ($ipt_str =~ /\\|/ or &have_hex_char($ipt_str)) {\n        $ipt_str = &convert_str_to_hex($ipt_str);\n    }\n\n    ### if we ever have more than one hex block then there was some\n    ### pattern translation error\n    my $hex_ctr = 0;\n    while ($ipt_str =~ /\\|/g) {\n        $hex_ctr++;\n        last if $hex_ctr >= 10;\n    }\n\n    if ($hex_ctr > 2) {\n        return 0, \"too many hex blocks, could not translate: $snort_str\",\n            \\%pattern;\n    }\n\n    ### handles length of hex blocks\n    my $content_len = &get_content_len($ipt_str);\n    if ($content_len >= $ipt_max_str_len\n            or $content_len >= $config{'MAX_STRING_LEN'}) {\n        return 0, \"pattern too long: $snort_str\", \\%pattern;\n    }\n\n    $pattern{'ipt_pattern'} = $ipt_str;\n    $pattern{'length'}      = $content_len;\n\n    return 1, $log_str, \\%pattern;\n}\n\nsub define_offsets() {\n    my ($patterns_ar, $avg_hdr_len, $opt, $val) = @_;\n\n    my $current_index = $#$patterns_ar;\n\n    ### the option should not be defined - if so, there is a duplicate\n    ### Snort keyword in the signature\n    if (defined $patterns_ar->[$current_index]->{$opt}) {\n        return 0, \"duplicate keyword: $opt\";\n    }\n\n    ### store the value that was in the original Snort rule\n    $patterns_ar->[$current_index]->{\"${opt}_snort_orig\"} = $val;\n\n    ### store the value and account for average header length if\n    ### necessary\n    if ($ipt_has_string_payload_offset_opt) {\n        $patterns_ar->[$current_index]->{$opt} = $val;\n    } else {\n        $patterns_ar->[$current_index]->{$opt}\n            = $val + $avg_hdr_len + $MAC_HDR_LEN;\n    }\n\n    return 1, '';\n}\n\nsub update_offsets_relative_matches() {\n    my $patterns_ar = shift;\n\n    for (my $i=0; $i <= $#$patterns_ar; $i++) {\n\n        my $pat_hr = $patterns_ar->[$i];\n        my $snort_offset   = -1;\n        my $snort_depth    = -1;\n        my $snort_distance = -1;\n        my $snort_within   = -1;\n\n        $snort_offset = $pat_hr->{'offset_snort_orig'}\n            if defined $pat_hr->{'offset_snort_orig'};\n        $snort_depth = $pat_hr->{'depth_snort_orig'}\n            if defined $pat_hr->{'depth_snort_orig'};\n        $snort_distance = $pat_hr->{'distance_snort_orig'}\n            if defined $pat_hr->{'distance_snort_orig'};\n        $snort_within = $pat_hr->{'within_snort_orig'}\n            if defined $pat_hr->{'within_snort_orig'};\n\n        if ($snort_depth > -1) {\n            ### if there is also an offset, then the depth begins after\n            ### the offset starts\n            if ($snort_offset > -1) {\n                $pat_hr->{'depth'} += $snort_offset;\n            } elsif ($snort_distance > -1) {\n                $pat_hr->{'depth'} += $snort_distance;\n            }\n            if ($snort_depth < $pat_hr->{'length'}) {\n                return 0, \"depth: $snort_depth less than \" .\n                    \"pattern length: $pat_hr->{'length'}\";\n            }\n        }\n\n        if ($snort_distance > -1) {\n            ### see if we need to increase the distance based\n            ### on the length of the previous pattern match and offset\n            if ($i > 0) {\n                my $prev_pat_hr = $patterns_ar->[$i-1];\n                $pat_hr->{'distance'} += $prev_pat_hr->{'length'};\n                if (defined $prev_pat_hr->{'offset_snort_orig'}) {\n                    $pat_hr->{'distance'} += $prev_pat_hr->{'offset_snort_orig'};\n                }\n            }\n        }\n\n        if ($snort_within > -1) {\n            if ($snort_offset > -1) {\n                $pat_hr->{'within'} += $snort_offset;\n            } elsif ($snort_distance > -1) {\n                $pat_hr->{'within'} += $snort_distance;\n            }\n            if ($i > 0) {\n                my $prev_pat_hr = $patterns_ar->[$i-1];\n                $pat_hr->{'within'} += $prev_pat_hr->{'length'};\n                if (defined $prev_pat_hr->{'offset_snort_orig'}) {\n                    $pat_hr->{'within'} += $prev_pat_hr->{'offset_snort_orig'};\n                }\n            }\n        }\n    }\n    return 1, '';\n}\n\nsub get_avg_hdr_len() {\n    my $hdr_hr = shift;\n\n    my $avg_hdr_len = $config{'AVG_IP_HEADER_LEN'};\n    if (defined $hdr_hr->{'proto'}) {\n        if ($hdr_hr->{'proto'} =~ /udp/i) {\n            $avg_hdr_len += $UDP_HDR_LEN;  ### udp header is 8 bytes\n        } elsif ($hdr_hr->{'proto'} =~ /icmp/i) {\n            $avg_hdr_len += $ICMP_HDR_LEN;  ### icmp header is 8 bytes\n        } else {\n            ### default to TCP\n            $avg_hdr_len += $config{'AVG_TCP_HEADER_LEN'};\n        }\n    } else {\n        ### don't know what the average transport layer (if there\n        ### is one) length will be; add 10 bytes just to be safe\n        $avg_hdr_len += 10;\n    }\n    return $avg_hdr_len;\n}\n\n### handles length of hex blocks\nsub get_content_len() {\n    my $str = shift;\n    my $len = 0;\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    for (my $i=0; $i<=$#chars; $i++) {\n        if ($chars[$i] eq '|') {\n            $hex_mode == 0 ? ($hex_mode = 1) : ($hex_mode = 0);\n            next;\n        }\n        if ($hex_mode) {\n            next if $chars[$i] eq ' ';\n            $len++;\n            $i++;\n        } else {\n            $len++;\n        }\n    }\n    return $len;\n}\n\nsub consolidate_hex_spaces() {\n    my $str = shift;\n\n    my $new_str = '';\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    for my $char (@chars) {\n        if ($char eq '|') {\n            $hex_mode == 0 ? ($hex_mode = 1) : ($hex_mode = 0);\n        }\n        if ($hex_mode) {\n            next if $char eq ' ';\n        }\n        $new_str .= $char;\n    }\n    return $new_str;\n}\n\nsub have_hex_char() {\n    my $str = shift;\n    return 1 if $str =~ /[^A-Za-z0-9]/;\n    return 0;\n}\n\nsub convert_str_to_hex() {\n    my $str = shift;\n\n    my $new_str = '';\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    CHAR: for my $char (@chars) {\n        if ($char eq '|') {\n            if ($hex_mode) {\n                $new_str .= $char;\n                $hex_mode = 0;\n            } else {\n                $new_str .= $char;\n                $hex_mode = 1;\n            }\n            next CHAR;\n        }\n        if ($hex_mode) {\n            $new_str .= $char;\n        } else {\n            $new_str .= sprintf \"|%02x|\", ord($char);\n        }\n    }\n\n    ### consolidate any consecutive \"|aa||bb|\" sequences\n    $new_str =~ s/\\|\\|//g;\n\n    return $new_str;\n}\n\nsub translate_perl_trigger() {\n    my $str = shift;\n    my $trigger_str = '';\n    my $hex_mode = 0;\n    my $append_hex_str = '';\n    my $append_non_hex_str = '';\n\n    my @chars = split //, $str;\n\n    for my $char (@chars) {\n        if ($char eq '|') {\n            if ($hex_mode) {\n                if ($append_hex_str) {\n                    while ($append_hex_str =~ /(.{2})/g) {\n                        $trigger_str .= \"\\\\x$1\";\n                    }\n                    $append_hex_str = '';\n                }\n                $hex_mode = 0;\n            } else {\n                if ($append_non_hex_str) {\n                    $trigger_str .= qq|$append_non_hex_str|;\n                    $append_non_hex_str = '';\n                }\n                $hex_mode = 1;\n            }\n            next;\n        }\n\n        if ($hex_mode) {\n            $append_hex_str .= $char;\n        } else {\n            $append_non_hex_str .= $char;\n        }\n    }\n\n    if ($append_hex_str) {\n        while ($append_hex_str =~ /(.{2})/g) {\n            $trigger_str .= \"\\\\x$1\";\n        }\n    }\n    $trigger_str .= qq|$append_non_hex_str| if $append_non_hex_str;\n\n    return $trigger_str;\n}\n\nsub ipt_add_rule() {\n    my ($hdr_hr, $opts_hr, $orig_snort_rule, $rule_base,\n        $target_str, $comment, $add_snort_comment,\n        $perl_trigger_str, $add_perl_trigger, $chain, $fwsnort_chain) = @_;\n\n    my $action_rule = '';\n    if ($hdr_hr->{'proto'} eq 'tcp') {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            if (defined $opts_hr->{'resp'}\n                    and $opts_hr->{'resp'} =~ /rst/i) {\n                ### iptables can only send tcp resets to the connection\n                ### client, so we can't support rst_rcv, but we should\n                ### try to tear the connection down anyway.\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with tcp-reset\";\n            } elsif ($ipt_drop) {\n                $action_rule = \"$rule_base -j DROP\";\n            } elsif ($ipt_reject) {\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with tcp-reset\";\n            }\n        }\n    } elsif ($hdr_hr->{'proto'} eq 'udp') {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            if (defined $opts_hr->{'resp'}\n                    and $opts_hr->{'resp'} =~ /icmp/i) {\n                if ($opts_hr->{'resp'} =~ /all/i) {  ### icmp_all\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-port-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /net/i) {  ### icmp_net\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-net-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /host/i) {  ### icmp_host\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-host-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /port/i) {  ### icmp_port\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-port-unreachable\";\n                }\n            } elsif ($ipt_drop) {\n                $action_rule = \"$rule_base -j DROP\";\n            } elsif ($ipt_reject) {\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with icmp-port-unreachable\";\n            }\n        }\n    } else {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            $action_rule = \"$rule_base -j DROP\";\n        }\n    }\n    my $ipt_rule = $rule_base . $target_str;\n\n    push @ipt_script_lines, \"\\n### $orig_snort_rule\" if $add_snort_comment;\n    if ($include_perl_triggers and $add_perl_trigger) {\n        push @ipt_script_lines, \"### $perl_trigger_str\";\n    }\n    if ($verbose) {\n        push @ipt_script_lines, qq|\\$ECHO \"[+] rule $ipt_rule_ctr\"|;\n    }\n\n    ### save format handling\n    my $save_format_ipt_rule    = $ipt_rule . \" \\n\";\n    my $save_format_action_rule = $action_rule . \" \\n\";\n\n    $save_format_ipt_rule    =~ s|\\$${ipt_var_str}\\s+\\-A|-A|;\n    $save_format_action_rule =~ s|\\$${ipt_var_str}\\s+\\-A|-A|;\n\n    if ($hdr_hr->{'action'} ne 'pass') {\n        if ($queue_mode or $nfqueue_mode) {\n\n            push @ipt_script_lines, $ipt_rule;\n            push @{$save_format_rules{$fwsnort_chain}}, $save_format_ipt_rule;\n\n        } else {\n\n            push @ipt_script_lines, $ipt_rule unless $no_ipt_log;\n            push @{$save_format_rules{$fwsnort_chain}}, $save_format_ipt_rule\n                unless $no_ipt_log;\n        }\n    }\n\n    if ($action_rule and ($ipt_drop or $ipt_reject or\n            $hdr_hr->{'action'} eq 'pass' or defined $opts_hr->{'resp'})) {\n\n        push @ipt_script_lines, $action_rule;\n        push @{$save_format_rules{$fwsnort_chain}}, $save_format_action_rule;\n    }\n\n    $ipt_rule_ctr++;\n    return;\n}\n\nsub save_format_append_rules() {\n\n     for my $chain (sort keys %ipt_save_existing_chains) {\n\n        next unless &is_fwsnort_chain($chain, $MATCH_EQUIV);\n\n        ### make sure that whitelist/blacklist and established jump rules\n        ### are added at the beginning of each chain in save format\n        &save_format_add_prereqs($chain);\n\n        for my $rule (@{$save_format_rules{$chain}}) {\n\n            push @fwsnort_save_lines, $rule;\n        }\n    }\n\n    ### now append any last lines from the iptables-save output that\n    ### had nothing to do with fwsnort (other custom chains, etc.)\n    for (my $i = $ipt_save_index; $i <= $#ipt_save_lines; $i++) {\n        next if &is_fwsnort_chain($ipt_save_lines[$i], $MATCH_SUBSTR);\n        push @fwsnort_save_lines, $ipt_save_lines[$i];\n    }\n\n    return;\n}\n\nsub save_format_add_prereqs() {\n    my $chain = shift;\n\n    return if defined $save_format_prereqs{$chain};\n\n    ### add whitelist\n    if (defined $save_format_whitelist{$chain}) {\n        for my $whitelist_rule (@{$save_format_whitelist{$chain}}) {\n            push @fwsnort_save_lines, \"$whitelist_rule \\n\";\n        }\n    }\n\n    ### add blacklist\n    if (defined $save_format_blacklist{$chain}) {\n        for my $blacklist_rule (@{$save_format_blacklist{$chain}}) {\n            push @fwsnort_save_lines, \"$blacklist_rule \\n\";\n        }\n    }\n\n    ### add jump rules into the connection tracking fwsnort chains\n    if (defined $save_format_conntrack_jumps{$chain}) {\n        for my $jump_rule (@{$save_format_conntrack_jumps{$chain}}) {\n            push @fwsnort_save_lines, \"$jump_rule \\n\";\n        }\n    }\n\n    $save_format_prereqs{$chain} = '';\n\n    return;\n}\n\nsub ipt_whitelist() {\n    my @whitelist_addrs = ();\n\n    for my $whitelist_line (@{$config{'WHITELIST'}}) {\n        for my $addr (@{&expand_addresses($whitelist_line)}) {\n            push @whitelist_addrs, $addr;\n        }\n    }\n\n    return unless $#whitelist_addrs >= 0;\n\n    push @ipt_script_lines, \"\\n###\\n############ Add IP/network \" .\n        \"WHITELIST rules. ############\\n###\";\n\n    for my $addr (@whitelist_addrs) {\n        for my $chain (keys %process_chains) {\n            next unless $process_chains{$chain};\n\n            if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                    \"-s $addr -j RETURN\";\n                push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n\n                push @{$save_format_whitelist{$config{\"FWSNORT_$chain\"}}},\n                    $rule_str;\n            }\n            if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n                my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                    \"-d $addr -j RETURN\";\n                push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n\n                push @{$save_format_whitelist{$config{\"FWSNORT_$chain\"}}},\n                    $rule_str;\n            }\n        }\n    }\n    return;\n}\n\nsub ipt_blacklist() {\n\n    my $printed_intro = 0;\n\n    for my $blacklist_line (@{$config{'BLACKLIST'}}) {\n\n        my @blacklist_addrs = ();\n        my $target = 'DROP';  ### default\n\n        if ($blacklist_line =~ /\\s+REJECT/) {\n            $target = 'REJECT';\n        }\n\n        for my $addr (@{&expand_addresses($blacklist_line)}) {\n            push @blacklist_addrs, $addr;\n        }\n\n        return unless $#blacklist_addrs >= 0;\n\n        unless ($printed_intro) {\n            push @ipt_script_lines, \"\\n###\\n############ Add IP/network \" .\n                \"BLACKLIST rules. ############\\n###\";\n            $printed_intro = 1;\n        }\n\n        for my $addr (@blacklist_addrs) {\n            for my $chain (keys %process_chains) {\n                next unless $process_chains{$chain};\n\n                if ($target eq 'DROP') {\n                    if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                            \"-s $addr -j DROP\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n\n                    if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                            \"-d $addr -j DROP\";\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                } else {\n                    if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p tcp -j REJECT --reject-with tcp-reset\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p udp -j REJECT --reject-with icmp-port-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p icmp -j REJECT --reject-with icmp-host-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                    if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p tcp -j REJECT --reject-with tcp-reset\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p udp -j REJECT --reject-with icmp-port-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p icmp -j REJECT --reject-with icmp-host-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub ipt_add_chains() {\n\n    ### save format\n    my %ipt_save_built_in_chains = ();\n    my $look_for_chains = 0;\n    for (@ipt_save_lines) {\n        unless ($look_for_chains) {\n            push @fwsnort_save_lines, $_;\n        }\n        if (/^\\*filter/) {\n            $look_for_chains = 1;\n        } elsif ($look_for_chains and $_ =~ /^:(\\S+)/) {\n            my $chain = $1;\n            if ($chain eq 'INPUT'\n                    or $chain eq 'OUTPUT'\n                    or $chain eq 'FORWARD') {\n                $ipt_save_built_in_chains{$chain} = $_;\n            } else {\n                ### don't preserve any old fwsnort chains, but preserve\n                ### any other existing custom chains\n                unless (&is_fwsnort_chain($chain, $MATCH_EQUIV)) {\n                    $ipt_save_existing_chains{$chain} = $_;\n                }\n            }\n        } elsif ($look_for_chains and $_ !~ /^:(\\S+)/) {\n            last;\n        }\n        $ipt_save_index++;\n    }\n\n    ### save format - add the built-in chains first\n    for my $chain (qw(INPUT FORWARD OUTPUT)) {\n        ### should always be defined unless we're not running as root\n        next unless defined $ipt_save_built_in_chains{$chain};\n        push @fwsnort_save_lines, $ipt_save_built_in_chains{$chain};\n    }\n\n    ### add the fwsnort chains\n    push @ipt_script_lines, \"\\n###\\n############ Create \" .\n        \"fwsnort $ipt_str chains. ############\\n###\";\n\n    for my $built_in_chain (qw(INPUT FORWARD OUTPUT)) {\n\n        ### see if any of the \"FWSNORT_<built-in-chain>\" chains need to be\n        ### excluded\n        next unless $process_chains{$built_in_chain};\n\n        for my $chain ($config{\"FWSNORT_$built_in_chain\"},\n                $config{\"FWSNORT_${built_in_chain}_ESTAB\"}) {\n            if ($no_ipt_conntrack) {\n                next if $chain eq\n                    $config{\"FWSNORT_${built_in_chain}_ESTAB\"};\n            }\n            push @ipt_script_lines,\n                \"\\$${ipt_var_str} -N $chain 2> /dev/null\",\n                \"\\$${ipt_var_str} -F $chain\\n\";\n\n            ### save format\n            $ipt_save_existing_chains{$chain} = \":$chain - [0:0]\\n\";\n        }\n    }\n\n    ### save format - add the custom chains\n    for my $chain (sort keys %ipt_save_existing_chains) {\n        push @fwsnort_save_lines, $ipt_save_existing_chains{$chain};\n    }\n\n    ### save format - add in the jump rules from the\n    ### built-in chains here\n    &save_format_add_jump_rules();\n\n    ### add in any rules from custom chains that alphabetically come\n    ### before the first fwsnort chain\n    &save_format_add_early_custom_chains();\n\n    return;\n}\n\nsub save_format_add_jump_rules() {\n\n    ### add the jump rule for each built-in chain\n    for my $built_in_chain (qw(INPUT FORWARD OUTPUT)) {\n\n        next unless defined $process_chains{$built_in_chain}\n            and $process_chains{$built_in_chain};\n\n        ### get the current $chain rules (if any), and then see where to add\n        ### the fwsnort jump rule\n\n        my @existing_chain_rules = ();\n\n        for (my $i = $ipt_save_index; $i < $#ipt_save_lines; $i++) {\n\n            ### delete any existing fwsnort jump rules\n            if ($ipt_save_lines[$i] =~ /^\\-A\\s$built_in_chain\\s/) {\n                if ($ipt_save_lines[$i] !~ /\\-j\\sFWSNORT_/) {\n                    push @existing_chain_rules, $ipt_save_lines[$i];\n                }\n            } else {\n                last;\n            }\n            $ipt_save_index++;\n        }\n\n        my $ctr = 1;\n        my $added_jump_rule = 0;\n        for my $existing_rule (@existing_chain_rules) {\n            if ($ctr == $config{\"FWSNORT_${built_in_chain}_JUMP\"}) {\n                &save_format_add_chain_jump_rule($built_in_chain);\n                $added_jump_rule = 1;\n            }\n\n            push @fwsnort_save_lines, $existing_rule;\n            $ctr++;\n        }\n\n        ### the chain may have been empty\n        unless ($added_jump_rule) {\n            &save_format_add_chain_jump_rule($built_in_chain);\n        }\n    }\n\n    return;\n}\n\nsub save_format_add_chain_jump_rule() {\n    my $built_in_chain = shift;\n    my $fwsnort_chain = \"FWSNORT_${built_in_chain}\";\n    if (%restrict_interfaces) {\n        for my $intf (keys %restrict_interfaces) {\n            if ($built_in_chain eq 'INPUT' or $built_in_chain eq 'FORWARD') {\n                push @fwsnort_save_lines, \"-A $built_in_chain -i $intf \" .\n                    \"-j $fwsnort_chain \\n\";\n            } elsif ($built_in_chain eq 'OUTPUT') {\n                push @fwsnort_save_lines, \"-A $built_in_chain -o $intf \" .\n                    \"-j $fwsnort_chain \\n\";\n            }\n        }\n    } else {\n        if ($no_exclude_loopback) {\n            push @fwsnort_save_lines, \"-A $built_in_chain \" .\n                \"-j $fwsnort_chain \\n\";\n        } else {\n            if ($built_in_chain eq 'INPUT' or $built_in_chain eq 'FORWARD') {\n                push @fwsnort_save_lines, \"-A $built_in_chain ! -i lo \" .\n                    \"-j $fwsnort_chain \\n\";\n            } elsif ($built_in_chain eq 'OUTPUT') {\n                push @fwsnort_save_lines, \"-A $built_in_chain ! -o lo \" .\n                    \"-j $fwsnort_chain \\n\";\n            }\n        }\n    }\n\n    return;\n}\n\nsub save_format_add_early_custom_chains() {\n\n    for my $chain (sort keys %ipt_save_existing_chains) {\n        last if &is_fwsnort_chain($chain, $MATCH_EQUIV);\n\n        for (my $i = $ipt_save_index; $i <= $#ipt_save_lines; $i++) {\n            last if &is_fwsnort_chain($ipt_save_lines[$i], $MATCH_SUBSTR);\n            push @fwsnort_save_lines, $ipt_save_lines[$i];\n            $ipt_save_index++;\n        }\n    }\n\n    return;\n}\n\nsub is_fwsnort_chain() {\n    my ($str, $match_style) = @_;\n    my $rv = 0;\n\n    for my $fwsnort_chain ($config{'FWSNORT_INPUT'},\n            $config{'FWSNORT_INPUT_ESTAB'},\n            $config{'FWSNORT_FORWARD'},\n            $config{'FWSNORT_FORWARD_ESTAB'},\n            $config{'FWSNORT_OUTPUT'},\n            $config{'FWSNORT_OUTPUT_ESTAB'}) {\n\n        if ($match_style eq $MATCH_SUBSTR) {\n            if ($str =~ /$fwsnort_chain/) {\n                $rv = 1;\n                last;\n            }\n        } elsif ($match_style eq $MATCH_EQUIV) {\n            if ($str eq $fwsnort_chain) {\n                $rv = 1;\n                last;\n            }\n        }\n    }\n\n    return $rv;\n}\n\nsub ipt_add_conntrack_jumps() {\n    ### jump ESTABLISHED tcp traffic to each of the _ESTAB\n    ### chains\n    push @ipt_script_lines, \"\\n###\\n############ Inspect $conntrack_state \" .\n        \"tcp connections. ############\\n###\";\n\n    for my $chain (keys %process_chains) {\n        next unless $process_chains{$chain};\n\n        my $rule_str = '';\n\n        if ($have_conntrack) {\n            $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -p tcp -m conntrack | .\n                qq|--ctstate $conntrack_state -j | .\n                qq|$config{\"FWSNORT_${chain}_ESTAB\"}|;\n        } elsif ($have_state) {\n            $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -p tcp -m state | .\n                qq|--state $conntrack_state -j | .\n                qq|$config{\"FWSNORT_${chain}_ESTAB\"}|;\n        }\n        next unless $rule_str;\n\n        push @ipt_script_lines, qq|\\$${ipt_var_str} $rule_str|;\n        push @{$save_format_conntrack_jumps{$config{\"FWSNORT_$chain\"}}},\n            $rule_str;\n    }\n    return;\n}\n\nsub ipt_jump_chain() {\n    push @ipt_script_lines, \"\\n###\\n############ Jump traffic \" .\n        \"to the fwsnort chains. ############\\n###\";\n    if (%restrict_interfaces) {\n        for my $intf (keys %restrict_interfaces) {\n            for my $chain (keys %process_chains) {\n                next unless $process_chains{$chain};\n\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                    ### delete any existing jump rule so that fwsnort.sh can\n                    ### be executed many times in a row without adding several\n                    ### jump rules\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|-i $intf -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    ### now add the jump rule\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} -i | .\n                        qq|$intf -j $config{\"FWSNORT_$chain\"}|;\n                } elsif ($chain eq 'OUTPUT') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|-o $intf -j $config{'FWSNORT_OUTPUT'}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{'FWSNORT_OUTPUT_JUMP'} -o | .\n                        qq|$intf -j $config{'FWSNORT_OUTPUT'}|;\n                }\n            }\n        }\n    } else {\n        for my $chain (keys %process_chains) {\n            next unless $process_chains{$chain};\n\n            if ($no_exclude_loopback) {\n\n                push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                    qq|-j $config{\"FWSNORT_$chain\"}| .\n                    ' 2> /dev/null';\n\n                push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                    qq|$config{\"FWSNORT_${chain}_JUMP\"} | .\n                    qq|-j $config{\"FWSNORT_$chain\"}|;\n            } else {\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|! -i lo -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} ! -i lo | .\n                        qq|-j $config{\"FWSNORT_$chain\"}|;\n\n                } elsif ($chain eq 'OUTPUT') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|! -o lo -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} ! -o lo | .\n                        qq|-j $config{\"FWSNORT_$chain\"}|;\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub hdr_lines() {\n    return\n        \"#!$cmds{'sh'}\\n#\", '#'x76,\n        \"#\\n# File:  $config{'FWSNORT_SCRIPT'}\",\n        \"#\\n# Purpose:  This script was auto-\" .\n        \"generated by fwsnort, and implements\",\n        \"#           an $ipt_str ruleset based upon \" .\n        \"Snort rules.  For more\",\n        \"#           information see the fwsnort man \" .\n        \"page or the documentation\",\n        \"#           available at \" .\n        \"http://www.cipherdyne.org/fwsnort/\",\n        \"#\\n# Generated with:     fwsnort @argv_cp\",\n        \"# Generated on host:  \" . hostname(),\n        \"# Time stamp:         \" . localtime(),\n        \"#\\n# Author:  Michael Rash <mbr\\@cipherdyne.org>\",\n        \"#\\n# Version: $version\",\n        \"#\", '#'x76, \"#\\n\";\n}\n\nsub ipt_hdr() {\n    push @ipt_script_lines, &hdr_lines();\n    push @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n\n    ### add paths to system binaries (iptables included)\n    &ipt_config_section();\n    return;\n}\n\nsub ipt_config_section() {\n    ### build the config section of the iptables script\n    push @ipt_script_lines,\n        '#==================== config ====================',\n        \"ECHO=$cmds{'echo'}\",\n        \"${ipt_var_str}=$ipt_bin\",\n        \"#================== end config ==================\\n\";\n    push @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n    return;\n}\n\nsub ipt_type() {\n    my $type = shift;\n    push @ipt_script_lines, \"\\n###\\n############ ${type}.rules #######\" .\n        \"#####\\n###\", \"\\$ECHO \\\"[+] Adding $type rules:\\\"\";\n    return;\n}\n\nsub check_type() {\n    for my $type_hr (\\%include_types, \\%exclude_types) {\n        for my $type (keys %$type_hr) {\n            my $found = 0;\n            my @valid_types = ();\n            for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n                if (-e \"$dir/${type}.rules\") {\n                    $found = 1;\n                } else {\n                    opendir D, $dir or die \"[*] Could not open $dir: $!\";\n                    for my $file (readdir D) {\n                        if ($file =~ /(\\S+)\\.rules/) {\n                            push @valid_types, $1;\n                        }\n                    }\n                }\n            }\n            unless ($found) {\n                print \"[-] \\\"$type\\\" is not a valid type.\\n\",\n                \"    Choose from the following available signature types:\\n\";\n                for my $type (sort @valid_types) {\n                    print \"        $type\\n\";\n                }\n                die \"[-] Exiting.\";\n            }\n        }\n    }\n    return;\n}\n\nsub import_config() {\n    open C, \"< $fwsnort_conf\" or die \"[*] Could not open $fwsnort_conf: $!\";\n    my @lines = <C>;\n    close C;\n    my $l_ctr = 0;\n    for my $line (@lines) {\n        $l_ctr++;\n        chomp $line;\n        next if $line =~ /^\\s*#/;\n        next unless $line =~ /\\S/;\n        if ($line =~ /^\\s*(\\S+)Cmd\\s+(\\S+);/) {  ### e.g. \"iptablesCmd\"\n            $cmds{$1} = $2;\n        } elsif ($line =~ /^\\s*(\\S+)\\s+(.*?);/) {\n            my $var = $1;\n            my $val = $2;\n            die \"[*] $fwsnort_conf: Variable \\\"$var\\\" is set to\\n\",\n                \"    _CHANGEME_ at line $l_ctr.  Edit $fwsnort_conf.\\n\"\n                if $val eq '_CHANGEME_';\n            if (defined $multi_line_vars{$var}) {\n                push @{$config{$var}}, $val;\n            } else {\n                ### may have already been defined in existing snort.conf\n                ### file if --snort-conf was given.\n                $config{$var} = $val unless defined $config{$var};\n            }\n        }\n    }\n\n    &expand_vars();\n\n    return;\n}\n\nsub ipt_list() {\n    for my $chain (\n        $config{'FWSNORT_INPUT'},\n        $config{'FWSNORT_INPUT_ESTAB'},\n        $config{'FWSNORT_OUTPUT'},\n        $config{'FWSNORT_OUTPUT_ESTAB'},\n        $config{'FWSNORT_FORWARD'},\n        $config{'FWSNORT_FORWARD_ESTAB'}\n    ) {\n        my $cmd = \"$ipt_bin -v -n -L $chain\";\n        my $exists = (system \"$cmd > /dev/null 2>&1\") >> 8;\n        if ($exists == 0) {\n            print \"[+] Listing $chain chain...\\n\";\n            system $cmd;\n            print \"\\n\";\n        } else {\n            print \"[-] Chain $chain does not exist...\\n\";\n        }\n    }\n    exit 0;\n}\n\nsub ipt_flush() {\n    for my $chain (\n        $config{'FWSNORT_INPUT'},\n        $config{'FWSNORT_INPUT_ESTAB'},\n        $config{'FWSNORT_OUTPUT'},\n        $config{'FWSNORT_OUTPUT_ESTAB'},\n        $config{'FWSNORT_FORWARD'},\n        $config{'FWSNORT_FORWARD_ESTAB'}\n    ) {\n        my $exists = (system \"$ipt_bin -n -L \" .\n            \"$chain > /dev/null 2>&1\") >> 8;\n        if ($exists == 0) {\n            print \"[+] Flushing $chain chain...\\n\";\n            system \"$ipt_bin -F $chain\";\n            if ($ipt_del_chains) {\n                ### must remove any jump rules from the built-in\n                ### chains\n                &del_jump_rule($chain);\n\n                print \"    Deleting $chain chain...\\n\";\n                system \"$ipt_bin -X $chain\";\n            }\n        } else {\n            print \"[-] Chain $chain does not exist...\\n\";\n        }\n    }\n    exit 0;\n}\n\nsub cache_ipt_save_policy() {\n\n    return unless $is_root;\n\n    open IPT, \"$save_bin -t filter |\" or die \"[*] Could not execute $save_bin\";\n    while (<IPT>) {\n        push @ipt_save_lines, $_;\n    }\n    close IPT;\n\n    ### also write out the current iptables policy so that we can\n    ### revert to it if necessary (iptables does a good job of not committing\n    ### a policy via iptables-save if there is a problem with a rule though).\n    &archive($config{'IPT_BACKUP_SAVE_FILE'});\n    open F, \"> $config{'IPT_BACKUP_SAVE_FILE'}\" or die \"[*] Could not \" .\n        \"open $config{'IPT_BACKUP_SAVE_FILE'}: $!\";\n    print F for @ipt_save_lines;\n    close F;\n\n    ### remove the last two lines (the 'COMMIT' and '# Completed ...' lines\n    ### so they can be added later).\n    $ipt_save_completed_line = $ipt_save_lines[$#ipt_save_lines];\n    pop @ipt_save_lines;\n    pop @ipt_save_lines;\n\n    return;\n}\n\nsub del_jump_rule() {\n    my $chain = shift;\n\n    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'}\n        or die \"[*] Could not acquire IPTables::Parse object: $!\";\n\n    for my $built_in_chain (qw(INPUT OUTPUT FORWARD)) {\n        my $rules_ar = $ipt->chain_rules('filter', $built_in_chain, $ipt_file);\n\n        for (my $i=0; $i <= $#$rules_ar; $i++) {\n            my $rule_num = $i+1;\n            if ($rules_ar->[$i]->{'target'} eq $chain) {\n                system \"$ipt_bin -D $built_in_chain $rule_num\";\n                last;\n            }\n        }\n    }\n\n    return;\n}\n\nsub fwsnort_init() {\n\n    ### set umask to -rw-------\n    umask 0077;\n\n    ### turn off buffering\n    $| = 1;\n\n    &set_non_root_values() unless $is_root;\n\n    ### read in configuration info from the config file\n    &import_config();\n\n    ### make sure the commands are where the\n    ### config file says they are\n    &chk_commands();\n\n    ### make sure all of the required variables are defined\n    ### in the config file\n    &required_vars();\n\n    $non_host    = $NON_HOST;\n    $ipt_bin     = $cmds{'iptables'};\n    $restore_bin = $cmds{'iptables-restore'};\n    $save_bin    = $cmds{'iptables-save'};\n\n    if ($enable_ip6tables) {\n        for my $opt (qw(itype icode ttl tos ipopts)) {\n            $snort_opts{'unsupported'}{$opt}\n                = $snort_opts{'filter'}{$opt};\n            delete $snort_opts{'filter'}{$opt};\n        }\n        $non_host    = $NON_IP6_HOST;\n        $save_str    = 'ip6tables-save';\n        $ipt_str     = 'ip6tables';\n        $ipt_bin     = $cmds{'ip6tables'};\n        $restore_bin = $cmds{'ip6tables-restore'};\n        $save_bin    = $cmds{'ip6tables-save'};\n    }\n\n    unless ($is_root) {\n        $no_ipt_test = 1;\n    }\n\n    if ($ipt_exec) {\n        die \"[*] You need to be root for --ipt-apply\" unless $is_root;\n        if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n            print \"[+] Executing $config{'FWSNORT_SAVE_EXEC_FILE'}\\n\";\n            system $config{'FWSNORT_SAVE_EXEC_FILE'};\n            exit 0;\n        } else {\n            die \"[*] $config{'FWSNORT_SAVE_EXEC_FILE'} does not exist.\";\n        }\n    } elsif ($ipt_revert) {\n        die \"[*] You need to be root for --ipt-revert\" unless $is_root;\n        if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n            print \"[+] Executing $config{'FWSNORT_SAVE_EXEC_FILE'}\\n\";\n            system \"$config{'FWSNORT_SAVE_EXEC_FILE'} -r\";\n            exit 0;\n        } else {\n            die \"[*] $config{'FWSNORT_SAVE_EXEC_FILE'} does not exist.\";\n        }\n    }\n\n    if ($enable_ip6tables) {\n        ### switch to ip6tables\n        $ipt_var_str = 'IP6TABLES';\n    }\n\n    $process_chains{'INPUT'}   = 0 if $no_ipt_input;\n    $process_chains{'FORWARD'} = 0 if $no_ipt_forward;\n    $process_chains{'OUTPUT'}  = 0 if $no_ipt_output;\n\n    ### import HOME_NET, etc. from existing Snort config file.\n    &import_snort_conf() if $snort_conf_file;\n\n    if ($rules_types) {\n        my @types = split /\\,/, $rules_types;\n        for my $type (@types) {\n            $include_types{$type} = '';\n        }\n    }\n    if ($exclude_types) {\n        my @types = split /\\,/, $exclude_types;\n        for my $type (@types) {\n            $exclude_types{$type} = '';\n        }\n    }\n    if ($include_sids) {\n        ### disable iptables policy parsing if we are translating a\n        ### specific set of Snort sids.\n        $ipt_sync = 0;\n\n        my @sids = split /\\,/, $include_sids;\n        for my $sid (@sids) {\n            $include_sids{$sid} = '';\n        }\n    }\n    if ($exclude_sids) {\n        my @sids = split /\\,/, $exclude_sids;\n        for my $sid (@sids) {\n            $exclude_sids{$sid} = '';\n        }\n    }\n    if ($ipt_restrict_intf) {\n        my @interfaces = split /\\,/, $ipt_restrict_intf;\n        for my $intf (@interfaces) {\n            $restrict_interfaces{$intf} = '';\n        }\n    }\n\n    if ($include_re) {\n        if ($include_re_caseless) {\n            $include_re = qr|$include_re|i;\n        } else {\n            $include_re = qr|$include_re|;\n        }\n    }\n    if ($exclude_re) {\n        if ($exclude_re_caseless) {\n            $exclude_re = qr|$exclude_re|i;\n        } else {\n            $exclude_re = qr|$exclude_re|;\n        }\n    }\n\n    ### flush all fwsnort chains.\n    &ipt_flush() if $ipt_flush or $ipt_del_chains;\n\n    ### list all fwsnort chains.\n    &ipt_list() if $ipt_list;\n\n    ### download latest snort rules from snort.org\n    &update_rules() if $update_rules;\n\n    ### make sure some directories exist, etc.\n    &setup();\n\n    ### get kernel version (this is mainly used to know whether\n    ### the \"--algo bm\" argument is required for the string match\n    ### extension in the 2.6.14 (and later) kernels.  Also, the\n    ### string match extension as of 2.6.14 supports the Snort\n    ### offset and depth keywords via --from and --to\n    &get_kernel_ver();\n\n    ### may have been specified on the command line\n    $home_net = $config{'HOME_NET'} unless $home_net;\n    $ext_net  = $config{'EXTERNAL_NET'} unless $ext_net;\n\n    &get_local_addrs() unless $no_addr_check;\n\n    if ($strict) {\n        ### make the snort options parser very strict\n        for my $opt (@{$snort_opts{'strict_list'}}) {\n            if (defined $snort_opts{'filter'}{$opt}) {\n                $snort_opts{'unsupported'}{$opt}\n                    = $snort_opts{'filter'}{$opt};\n                delete $snort_opts{'filter'}{$opt};\n            } elsif (defined $snort_opts{'ignore'}{$opt}) {\n                $snort_opts{'unsupported'}{$opt}\n                    = $snort_opts{'ignore'}{$opt};\n                delete $snort_opts{'ignore'}{$opt};\n            }\n        }\n        my @ignore = (qw(nocase));\n\n        if ($kernel_ver eq '2.4') {\n            push @ignore, 'offset', 'depth';\n        }\n        for my $opt (@ignore) {\n            next unless defined $snort_opts{'ignore'}{$opt};\n            $snort_opts{'unsupported'}{$opt}\n                = $snort_opts{'ignore'}{$opt};\n            delete $snort_opts{'ignore'}{$opt};\n        }\n    }\n    if ($no_pcre) {\n        ### skip trying to translate basic PCRE's\n        $snort_opts{'unsupported'}{'pcre'}\n            = $snort_opts{'filter'}{'pcre'};\n        delete $snort_opts{'filter'}{'pcre'};\n    }\n\n    if ($no_fast_pattern_order) {\n        $snort_opts{'ignore'}{'fast_pattern'}\n            = $snort_opts{'filter'}{'fast_pattern'}{'regex'};\n        delete $snort_opts{'filter'}{'fast_pattern'};\n    }\n    return;\n}\n\nsub get_kernel_ver() {\n    die \"[*] uname command: $cmds{'uname'} is not executable.\"\n        unless -x $cmds{'uname'};\n    open U, \"$cmds{'uname'} -a |\" or die \"[*] Could not run \",\n        \"$cmds{'uname'} -a\";\n    my $out = <U>;\n    close U;\n    ### Linux orthanc 2.6.12.5 #2 Tue Sep 27 22:43:02 EDT 2005 i686 \\\n    ### Pentium III (Coppermine) GenuineIntel GNU/Linux\n    if ($out =~ /\\s2\\.6/) {\n        $kernel_ver = '2.6';\n    }\n    return;\n}\n\nsub handle_cmd_line() {\n\n    ### make Getopts case sensitive\n    Getopt::Long::Configure('no_ignore_case');\n\n    die \"[*] Use --help for usage information.\\n\" unless (GetOptions(\n        'ipt-apply'      => \\$ipt_exec,     # Apply the generated ruleset.\n        'ipt-exec'       => \\$ipt_exec,     # Apply the generated ruleset.\n        'ipt-revert'     => \\$ipt_revert,     # Apply the generated ruleset.\n        'ipt-drop'       => \\$ipt_drop,     # Add iptables DROP rules.\n        'ipt-reject'     => \\$ipt_reject,   # Add iptables REJECT rules.\n        'ipt-script=s'   => \\$ipt_script,   # Manually specify the path to the\n                                            # generated iptables script.\n        'ipt-log-tcp-seq' => \\$ipt_log_tcp_seq, # Log TCP seq/ack values.\n        'ipt-flush'      => \\$ipt_flush,    # Flush any existing fwsnort chains.\n        'ipt-check-capabilities' =>\\$ipt_check_capabilities, # Check capabilities\n                                                             # and exit.\n        'Flush'          => \\$ipt_flush,    # Synonym for --ipt-flush\n        'ipt-list'       => \\$ipt_list,     # List any existing fwsnort chains.\n        'List'           => \\$ipt_list,     # Synonym for --ipt-list\n        'fw-list'        => \\$ipt_list,     # Synonym for --ipt-list\n        'ipt-del'        => \\$ipt_del_chains, # Delete fwsnort chains.\n        'ip6tables'      => \\$enable_ip6tables, # Turn on ip6tables mode.\n        '6'              => \\$enable_ip6tables, # Synonym for --ip6tables.\n        'X'              => \\$ipt_del_chains, # Synonym for --ipt-del.\n        'ipt-file=s'     => \\$ipt_file,     # Read iptables policy from a file.\n        'Home-net=s'     => \\$home_net,     # Manually specify home network.\n        'External-net=s' => \\$ext_net,      # Manually specify external network.\n        'snort-sid=s'    => \\$include_sids, # Parse only these particular snort rules.\n        'snort-sids=s'   => \\$include_sids, # Synonum for --snort-sid\n        'string-match-alg=s' => \\$string_match_alg,\n        'exclude-sid=s'  => \\$exclude_sids, # Exclude these particular snort rules.\n        'snort-conf=s'   => \\$snort_conf_file, # Get HOME_NET, etc. vars from\n                                            # existing Snort config file.\n        'include-perl-triggers' => \\$include_perl_triggers, # perl commands to\n                                            # trigger signature matches.\n        'include-type=s' => \\$rules_types,  # Process only this type of snort rule\n                                            # (e.g. \"ddos\")\n        'exclude-type=s' => \\$exclude_types,# Exclude specified types (e.g. \"ddos\").\n        'include-regex=s' => \\$include_re,  # Include only those signatures that\n                                            # match the specified regex.\n        'include-re-caseless' => \\$include_re_caseless, # make include regex case\n                                                        # insensitive\n        'exclude-regex=s' => \\$exclude_re,  # Exclude those signatures that\n                                            # match the specified regex.\n        'exclude-re-caseless' => \\$exclude_re_caseless, # make exclude regex case\n                                                        # insensitive\n        'snort-rdir=s'   => \\$rules_dir,    # Manually specify the snort rules\n                                            # directory.\n        'snort-rfile=s'  => \\$rules_file,   # Translate a single rules file.\n        'no-pcre'        => \\$no_pcre,      # Make no attempt to translate PCRE's.\n        'no-addresses'   => \\$no_addr_check, # Don't check local ifconfig output.\n        'no-ipt-sync'    => \\$ignore_opt,   # Do not sync with the iptables policy.\n        'ipt-sync'       => \\$ipt_sync,     # Sync fwsnort rules with the iptables\n                                            # policy.\n        'no-ipt-log'     => \\$no_ipt_log,   # Do not generate iptables logging rules.\n        'no-ipt-test'    => \\$no_ipt_test,  # Don't perform any checks for\n                                            # iptables capabilities.\n        'no-ipt-jumps'   => \\$no_ipt_jumps, # Don't jump packets from the INPUT or\n                                            # FORWARD chains.\n        'no-ipt-conntrack' => \\$no_ipt_conntrack, # Don't use iptables connection\n                                            # tracking (falls back to ACK flag test).\n        'Conntrack-state=s' => \\$conntrack_state, ### Specify conntrack state for\n                                                  ### 'flow' keyword emulation\n                                                  ### (default is ESTABLISHED).\n        'no-ipt-INPUT'   => \\$no_ipt_input, # Disable fwsnort rules processed via\n                                            # the INPUT chain.\n        'no-ipt-OUTPUT'  => \\$no_ipt_output, # Disable fwsnort rules processed via\n                                             # the OUTPUT chain.\n        'no-ipt-FORWARD' => \\$no_ipt_forward, # Disable fwsnort rules processed via\n                                              # the FORWARD chain.\n        'no-ipt-comments' => \\$no_ipt_comments, # Don't include msg fields\n                                                # with the comment match\n        'no-ipt-rule-nums' => \\$no_ipt_rule_nums, # Exclude rule numbers from\n                                                  # logging prefixes.\n        'no-exclude-lo'  => \\$no_exclude_loopback, # include loopback interface\n        'no-log-ip-opts' => \\$no_ipt_log_ip_opts, # Don't log IP options\n        'no-log-tcp-opts' => \\$no_ipt_log_tcp_opts, # Don't log TCP options\n        'no-fast-pattern-order' => \\$no_fast_pattern_order, ### Don't alter\n                                              # pattern match ordering based on\n                                              # pattern length, and ignore the\n                                              # explicit 'fast_pattern' keyword\n        'restrict-intf=s' => \\$ipt_restrict_intf, # Restrict iptables rules to an\n                                            # individual interface (supports a\n                                            # comma separate list).\n        'update-rules'   => \\$update_rules, # Download latest snort rules.\n        'rules-url=s'    => \\$rules_url,    # Specify rules URL.\n        'add-deleted'    => \\$add_deleted,  # Add deleted rules.\n        'strict'         => \\$strict,       # Strict mode.\n        'debug'          => \\$debug,        # Debug mode.\n        'dumper'         => \\$dumper,       # Dumper mode for IPTables::Parse\n                                            # hashes.\n        'Dump-conf'      => \\$dump_conf,    # Display config variables\n        'Dump-ipt'       => \\$dump_ipt,     # Dump iptables rules on STDOUT.\n        'Dump-snort'     => \\$dump_snort,   # Dump snort rules on STDOUT.\n        'config=s'       => \\$fwsnort_conf, # Manually specify the config file\n        'Ulog'           => \\$ulog_mode,    # Force ULOG mode.\n        'ulog-nlgroup=i' => \\$ulog_nlgroup, # Specify the ulogd nl group.\n        'QUEUE'          => \\$queue_mode,   # Specify QUEUE mode; this pulls out\n                                            #  all kernel-matchable features from\n                                            #  original Snort rules and creates a\n                                            #  a modified rule set based on this.\n        'NFQUEUE'        => \\$nfqueue_mode, # Same as QUEUE mode, except use the\n                                            #  updated NFQUEUE target.\n        'queue-rules-dir=s' => \\$queue_rules_dir, # Change the path to the generated\n                                                  # rules directory in --QUEUE or\n                                                  # --NFQUEUE mode.\n        'queue-num=i'    => \\$nfqueue_num,  # Specifies the NFQUEUE number.\n        'queue-pre-match-max=i' => \\$queue_pre_match_max,  ### max number of patterns\n                                                  ### to match within the kernel before\n                                                  ### queuing a packet to userspace\n                                                  ### Snort\n        'Home-dir=s'     => \\$cmdl_homedir,\n        'Last-cmd'       => \\$run_last,\n        'lib-dir=s'      => \\$lib_dir,      # Specify path to lib directory.\n        'verbose'        => \\$verbose,\n        'logfile=s'      => \\$logfile,      # Specify the logfile path.\n        'stdout'         => \\$stdout,       # Print log messages to stdout.\n        'Version'        => \\$print_ver,\n        'help'           => \\$help\n    ));\n\n    &get_homedir();\n\n    &usage(0) if $help;\n\n    &save_args() unless $run_last;\n\n    ### Print the version number and exit if -V given on the command line.\n    if ($print_ver) {\n        print \"[+] fwsnort v$version by Michael Rash <mbr\\@cipherdyne.org>\\n\";\n        exit 0;\n    }\n\n    if (($queue_mode or $nfqueue_mode) and ($ipt_drop or $ipt_reject)) {\n        die\n\"[*] --NFQUEUE and --QUEUE modes are not compatible with --ipt-drop or\\n\",\n\"    --ipt-reject; a userland process should set the verdict. If you can\\n\",\n\"    always use fwsnort with --ipt-drop or --ipt-reject and add an NFQUEUE\\n\",\n\"    or QUEUE rule manually to a built-in chain. This allows the fwsnort\\n\",\n\"    policy to DROP or REJECT packets that match signatures before they are\\n\",\n\"    communicated to userland (hence speeding up Snort_inline).\\n\";\n    }\n\n    if ($nfqueue_num != 0) {\n        unless ($nfqueue_num > 0 and $nfqueue_num < 65536) {\n            die \"[*] --queue-num must be between 0 and 65535 (inclusive)\";\n        }\n        unless ($nfqueue_mode) {\n            die \"[*] Must also specifiy --NFQUEUE mode if using --queue-num\";\n        }\n    }\n\n    if ($no_ipt_log and not ($ipt_drop or $ipt_reject)) {\n        die \"[*] --ipt-no-log option can only be used \",\n            \"with --ipt-drop or --ipt-reject\";\n    }\n\n    if ($ipt_drop and $ipt_reject) {\n        die \"[*] Cannot specify both --ipt-drop and --ipt-reject\";\n    }\n\n    return;\n}\n\nsub import_snort_conf() {\n    unless (-e $snort_conf_file) {\n        die \"[*] Snort config file $snort_conf_file does not exist.\";\n    }\n    open F, \"< $snort_conf_file\" or die \"[*] Could not open Snort \",\n        \"config $snort_conf_file: $!\";\n    my @lines = <F>;\n    close F;\n    for my $line (@lines) {\n        chomp $line;\n        next if $line =~ /^\\s*#/;\n        if ($line =~ /^\\s*var\\s+(\\w+)\\s+(.*)\\s*/) {\n            $config{$1} = $2;\n        }\n    }\n    return;\n}\n\nsub expand_vars() {\n\n    my $has_sub_var = 1;\n    my $resolve_ctr = 0;\n\n    while ($has_sub_var) {\n        $resolve_ctr++;\n        $has_sub_var = 0;\n        if ($resolve_ctr >= 20) {\n            die \"[*] Exceeded maximum variable resolution counter.\";\n        }\n        for my $hr (\\%config, \\%cmds) {\n            for my $var (keys %$hr) {\n                my $val = $hr->{$var};\n                if ($val =~ m|\\$(\\w+)|) {\n                    my $sub_var = $1;\n                    die \"[*] sub-ver $sub_var not allowed within same \",\n                        \"variable $var\" if $sub_var eq $var;\n                    if (defined $config{$sub_var}) {\n                        if ($sub_var eq 'INSTALL_ROOT'\n                                and $config{$sub_var} eq '/') {\n                            $val =~ s|\\$$sub_var||;\n                        } else {\n                            $val =~ s|\\$$sub_var|$config{$sub_var}|;\n                        }\n                        $hr->{$var} = $val;\n                    } else {\n                        die \"[*] sub-var \\\"$sub_var\\\" not defined in \",\n                            \"config for var: $var.\"\n                    }\n                    $has_sub_var = 1;\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub required_vars() {\n    my @required_vars = (qw(\n        HOME_NET EXTERNAL_NET HTTP_SERVERS SMTP_SERVERS DNS_SERVERS\n        SQL_SERVERS TELNET_SERVERS AIM_SERVERS HTTP_PORTS SHELLCODE_PORTS\n        SSH_PORTS ORACLE_PORTS WHITELIST BLACKLIST AVG_IP_HEADER_LEN\n        AVG_TCP_HEADER_LEN MAX_FRAME_LEN FWSNORT_INPUT FWSNORT_INPUT_ESTAB\n        FWSNORT_OUTPUT FWSNORT_OUTPUT_ESTAB FWSNORT_FORWARD\n        FWSNORT_FORWARD_ESTAB FWSNORT_INPUT_JUMP FWSNORT_OUTPUT_JUMP\n        FWSNORT_FORWARD_JUMP MAX_STRING_LEN CONF_DIR RULES_DIR ARCHIVE_DIR\n        QUEUE_RULES_DIR LOG_DIR LIBS_DIR CONF_FILE FWSNORT_SCRIPT LOG_FILE\n        FWSNORT_SAVE_FILE FWSNORT_SAVE_EXEC_FILE IPT_BACKUP_SAVE_FILE\n        UPDATE_RULES_URL STATE_DIR INSTALL_ROOT\n    ));\n    for my $var (@required_vars) {\n        die \"[*] Variable $var not defined in $fwsnort_conf. Exiting.\\n\"\n            unless defined $config{$var};\n    }\n    return;\n}\n\nsub ipt_capabilities() {\n\n    print \"[+] Testing $ipt_bin for supported capabilities...\\n\";\n\n    my $test_rule_rv = -1;\n\n    ### create test chain\n    &create_test_chain();\n\n    ### test for the LOG target.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            \"$non_host -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has 'LOG' target support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### check for the max --log-prefix string length\n        $ipt_max_log_prefix_len = &ipt_find_max_len(\n            $ipt_max_log_prefix_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n            qq|$non_host -p tcp --dport 1234 -j LOG --log-prefix \"|, qq|\"|\n        );\n\n        print \"    Max supported LOG prefix length: $ipt_max_log_prefix_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n    } else {\n        &delete_test_chain();\n        die \"[*] $ipt_str has not been compiled with logging support.  \",\n            \"If you want to\\n    have fwsnort generate an $ipt_str script \",\n            \"    anyway then specify the\\n    --no-ipt-test option. \",\n            \"Exiting.\\n\"\n            unless $no_ipt_log;\n    }\n\n    ### test for the comment match (where Snort msg fields are placed)\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -m comment --comment \"testing the comment match\" | .\n            qq|-j LOG|) == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has 'comment' match support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        $ipt_max_comment_len = &ipt_find_max_len(\n            $ipt_max_comment_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n            qq|$non_host -p tcp --dport 1234 -m comment --comment | .\n            qq|\"|, qq|\" -j LOG|\n        );\n\n        print \"    Max supported comment length: $ipt_max_comment_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n    } else {\n        unless ($no_ipt_comments) {\n            print\"[-] It looks like the $ipt_str 'comment' match is not \",\n                \"available, disabling.\\n\";\n            $no_ipt_comments = 1;\n        }\n    }\n\n    ### test for the ipv4options extension.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp -m \" .\n            \"ipv4options --rr -s $non_host -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'ipv4options' extension...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n\n        &logr(\"[-] $ipt_str ipv4options extension not available, \" .\n            \"disabling ipopts translation.\");\n        ### put ipopts in the unsupported list\n        if (defined $snort_opts{'filter'}{'ipopts'}) {\n            $snort_opts{'unsupported'}{'ipopts'} =\n                $snort_opts{'filter'}{'ipopts'}{'regex'};\n            delete $snort_opts{'filter'}{'ipopts'};\n        } else {\n            $snort_opts{'unsupported'}{'ipopts'} = qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/;\n        }\n        print \"[-] $ipt_str does not have the 'ipv4options' extension, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the ttl match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m ttl --ttl-eq 1 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'ttl' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put ttl in the unsupported list\n        &logr(\"[-] $ipt_str TTL match not available, \" .\n            \"disabling ttl translation.\");\n        if (defined $snort_opts{'filter'}{'ttl'}) {\n            $snort_opts{'unsupported'}{'ttl'} =\n                $snort_opts{'filter'}{'ttl'}{'regex'};\n            delete $snort_opts{'filter'}{'ttl'};\n        } else {\n            $snort_opts{'unsupported'}{'ttl'} = qr/[\\s;]ttl:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'ttl' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the TOS match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m tos --tos 8 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'tos' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put tos in the unsupported list\n        &logr(\"[-] $ipt_str TOS match not available, \" .\n            \"disabling tos translation.\");\n        if (defined $snort_opts{'filter'}{'tos'}) {\n            $snort_opts{'unsupported'}{'tos'} =\n                $snort_opts{'filter'}{'tos'}{'regex'};\n            delete $snort_opts{'filter'}{'tos'};\n        } else {\n            $snort_opts{'unsupported'}{'tos'} = qr/[\\s;]tos:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'tos' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the length match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m length --length 256 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'length' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put length in the unsupported list\n        &logr(\"[-] $ipt_str length match not available, \" .\n            \"disabling length translation.\");\n        if (defined $snort_opts{'filter'}{'dsize'}) {\n            $snort_opts{'unsupported'}{'dsize'} =\n                $snort_opts{'filter'}{'dsize'}{'regex'};\n            delete $snort_opts{'filter'}{'dsize'};\n        } else {\n            $snort_opts{'unsupported'}{'dsize'} = qr/[\\s;]dsize:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'length' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the multiport match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n            \"-s $non_host -m multiport --dports 53,123:500 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'multiport' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n        $ipt_have_multiport_match = 1;\n\n        ### find the maximum number of supported ports (usually 15)\n        &ipt_find_max_multiport_supported_ports();\n\n    } else {\n        print \"[-] $ipt_str does not have the 'multiport' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n        &logr(\"[-] $ipt_str multiport match not available\");\n    }\n\n    ### test for string match support.\n    my $ipt_str_test = my $ipt_str_test_base =\n            \"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -m string --string \"test\" |;\n\n    if ($kernel_ver ne '2.4') {\n        ### default to include \"--algo bm\"\n        $ipt_str_test .= qq|--algo $string_match_alg -j LOG|;\n    } else {\n        $ipt_str_test .= qq|-j LOG|;\n    }\n\n    $test_rule_rv = &ipt_rule_test($ipt_str_test);\n\n    if ($test_rule_rv == $IPT_SUCCESS) {\n\n        print \"[+] $ipt_str has the 'string' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### now find the maximum string length that is supported by iptables\n        if ($kernel_ver eq '2.4') {\n            $ipt_max_str_len = &ipt_find_max_len(\n                $ipt_max_str_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n                    qq|$non_host -m string --string \"|, qq|\" -j LOG|);\n        } else {\n            $ipt_max_str_len = &ipt_find_max_len(\n                $ipt_max_str_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n                qq|$non_host -m string --string \"|, qq|\" | .\n                qq|--algo $string_match_alg -j LOG|);\n        }\n\n        print \"    Max supported string length: $ipt_max_str_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### test for case insensitive string matching\n        $ipt_str_test = $ipt_str_test_base;\n\n        if ($kernel_ver ne '2.4') {\n            $ipt_str_test .= qq|--algo $string_match_alg --icase -j LOG|;\n        } else {\n            $ipt_str_test .= qq|--icase -j LOG|;\n        }\n\n        $test_rule_rv = &ipt_rule_test($ipt_str_test);\n\n        unless ($test_rule_rv == $IPT_SUCCESS) {\n            $snort_opts{'ignore'}{'nocase'}\n                = $snort_opts{'filter'}{'nocase'}{'regex'};\n            delete $snort_opts{'filter'}{'fast_pattern'};\n        }\n\n        ### test for --replace-string support (only available for 2.4 kernels\n        ### if the replace-string patch has been applied).\n        if ($kernel_ver eq '2.4') {\n            unless (&ipt_rule_test($ipt_str_test_base .\n                    qq|--replace-string \"repl\" -j LOG|) == $IPT_SUCCESS) {\n                if (defined $snort_opts{'filter'}{'replace'}) {\n                    $snort_opts{'unsupported'}{'replace'} =\n                        $snort_opts{'filter'}{'replace'}{'regex'};\n                    delete $snort_opts{'filter'}{'replace'};\n                } else {\n                    $snort_opts{'unsupported'}{'replace'}\n                        = qr/[\\s;]replace:\\s*(.*?)\\s*;/;\n                }\n            }\n        } else {\n            $snort_opts{'unsupported'}{'replace'}\n                = qr/[\\s;]replace:\\s*(.*?)\\s*;/;\n        }\n\n        ### test to see whether '--icmp-type any' is supported\n        $ipt_str_test = $ipt_str_test_base;\n        if ($kernel_ver ne '2.4') {\n            $ipt_str_test .= qq|--algo $string_match_alg -p icmp -m icmp --icmp-type any -j LOG|;\n        } else {\n            $ipt_str_test .= qq|-p icmp -m icmp --icmp-type any -j LOG|;\n        }\n\n        $test_rule_rv = &ipt_rule_test($ipt_str_test);\n        if ($test_rule_rv == $IPT_SUCCESS) {\n            $default_icmp_type = 'any';\n        }\n\n    } else {\n        &delete_test_chain();\n        die\n\"[*] It does not appear that string match support has been compiled into\\n\",\n\"    the kernel.  Fwsnort will not be of very much use without this.\\n\",\n\"    ** NOTE: If you want to have fwsnort generate an $ipt_str policy\\n\",\n\"    anyway, use the --no-ipt-test option.  Exiting.\\n\";\n    }\n\n    ### test for --hex-string\n    if ($kernel_ver ne '2.4') {\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host \" .\n            qq{-m string --hex-string \"|0a 5d|\" --algo $string_match_alg -j LOG});\n    } else {\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host \" .\n            qq{-m string --hex-string \"|0a 5d|\" -j LOG});\n    }\n\n    if ($test_rule_rv == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has --hex-string support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        &delete_test_chain();\n        die\n\"[*] It does not appear that the --hex-string patch has been applied.\\n\",\n\"    fwsnort will not be of very much use without this. ** NOTE: If you\\n\",\n\"    want to have fwsnort generate an $ipt_str policy anyway, then\\n\",\n\"    use the --no-ipt-test option.  Exiting.\\n\";\n    }\n\n    ### test for the --payload option\n    if ($kernel_ver ne '2.4'\n            and &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host -m string --string \" .\n            qq|\"test\" --algo $string_match_alg --to 50 --payload -j LOG|) == $IPT_SUCCESS) {\n        $ipt_has_string_payload_offset_opt = 1;\n    }\n\n    if ($queue_mode or $nfqueue_mode) {\n        ### test for the QUEUE or NFQUEUE target\n        if ($nfqueue_mode) {\n            if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                    \"$non_host -p tcp --dport 3001 -j NFQUEUE\")\n                        == $IPT_SUCCESS) {\n                print \"[+] $ipt_str has NFQUEUE support....\\n\"\n                    if $verbose or $ipt_check_capabilities;\n            } else {\n                die \"[*] The NFQUEUE target does not appear to be available \",\n                    \"in iptables.\";\n            }\n        } else {\n            if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                    \"$non_host -p tcp --dport 3001 -j QUEUE\")\n                        == $IPT_SUCCESS) {\n                print \"[+] $ipt_str has QUEUE support....\\n\"\n                    if $verbose or $ipt_check_capabilities;\n            } else {\n                die \"[*] The QUEUE target does not appear to be available \",\n                    \"in iptables.\";\n            }\n        }\n    }\n\n    unless ($no_ipt_conntrack) {\n\n        ### test for connection tracking support (conntrack\n        ### match first then state match if not available)\n        if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                \"$non_host -p tcp --dport 3001 -m conntrack \" .\n                \"--ctstate ESTABLISHED -j LOG\")\n                    == $IPT_SUCCESS) {\n            print \"[+] $ipt_str has conntrack state tracking support...\\n\"\n                if $verbose or $ipt_check_capabilities;\n\n            if ($conntrack_state ne 'ESTABLISHED') {\n\n                ### check to make sure the specified state is supported\n                if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                        \"$non_host -p tcp --dport 3001 -m conntrack \" .\n                        \"--ctstate $conntrack_state -j LOG\")\n                            != $IPT_SUCCESS) {\n                     die \"[*] The connection state $conntrack_state does not \",\n                        \"appear to be supported by iptables.\\n\";\n                }\n            }\n\n            $have_conntrack = 1;\n\n        } elsif (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                \"$non_host -p tcp --dport 3001 -m state \" .\n                \"--state ESTABLISHED -j LOG\")\n                    == $IPT_SUCCESS) {\n            print \"[+] $ipt_str has state tracking support...\\n\"\n                if $verbose or $ipt_check_capabilities;\n\n            if ($conntrack_state ne 'ESTABLISHED') {\n\n                ### check to make sure the specified state is supported\n                if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                        \"$non_host -p tcp --dport 3001 -m state \" .\n                        \"--state ESTABLISHED -j LOG\")\n                            != $IPT_SUCCESS) {\n                    die \"[*] The connection state $conntrack_state does not \",\n                        \"appear to be supported by iptables.\\n\";\n                }\n            }\n\n            $have_state = 1;\n        } else {\n            &delete_test_chain();\n            die\n\"[*] It does not appear that $ipt_str has been compiled with connection\\n\",\n\"    tracking support.  If you want fwsnort to generate a policy anyway\\n\",\n\"    and just use a tcp flags check for established tcp connections, then\\n\",\n\"    use the --no-ipt-conntrack option.  **NOTE: The resulting fwsnort\\n\",\n\"    $ipt_str policy will be susceptible to a stick or snot-style attack.\\n\",\n\"    Exiting.\\n\";\n        }\n    }\n\n    if ($ipt_reject) {\n        ### we are going to generate a policy that drops icmp and udp\n        ### packets, and kills tcp sessions with tcp-reset.\n        unless (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n            \"-s $non_host \" .\n            \"-j REJECT --reject-with tcp-reset\") == $IPT_SUCCESS) {\n\n            ### in newer versions of iptables (> 1.3.5?) the \"tcp-reset\"\n            ### command line arg has been changed to \"tcp-rst\"\n            unless (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n                    \"-s $non_host \" .\n                    \"-j REJECT --reject-with tcp-rst\") == $IPT_SUCCESS) {\n                &delete_test_chain();\n                die\n\"[*] It does not appear that the REJECT target has been compiled into\\n\",\n\"    the kernel.  The --ipt-reject option requires this option so that tcp\\n\",\n\"    sessions can be killed.  Exiting.\\n\";\n            }\n        }\n        print \"[+] $ipt_str has the 'REJECT' target support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    }\n\n    &delete_test_chain();\n\n    exit 0 if $ipt_check_capabilities;\n\n    ### more tests should be added\n    return;\n}\n\nsub ipt_find_max_len() {\n    my ($len, $ipt_pre_pattern, $ipt_post_pattern) = @_;\n\n    my $test_pattern = '';\n\n    for (;;) {\n\n        $test_pattern = 'A'x$len;\n\n        last if &ipt_rule_test($ipt_pre_pattern\n            . $test_pattern . $ipt_post_pattern) != $IPT_SUCCESS;\n\n        $len += $ipt_cap_search_factor;\n\n        last if $len >= $ipt_max_buf_len;\n    }\n\n    for (;;) {\n\n        $test_pattern = 'A'x$len;\n\n        last if &ipt_rule_test($ipt_pre_pattern\n            . $test_pattern . $ipt_post_pattern) == $IPT_SUCCESS;\n\n        $len--;\n\n        last if $len == 1;  ### minimum\n    }\n\n    return --$len;\n}\n\nsub ipt_find_max_multiport_supported_ports() {\n\n    my $test_ports_str = $ipt_multiport_max-1;\n\n    for (;;) {\n\n        $test_ports_str .= \",$ipt_multiport_max\";\n\n        my $test_rule_rv = 0;\n\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -p tcp -m multiport --dports $test_ports_str -j LOG |);\n\n        last if $test_rule_rv != $IPT_SUCCESS;\n\n        $ipt_multiport_max++;\n\n        last if $ipt_multiport_max == $ipt_max_buf_len; ### unlikely we'll ever get here\n    }\n    $ipt_multiport_max--;\n\n    print \"    Max supported multiport ports: $ipt_multiport_max\\n\"\n        if $verbose or $ipt_check_capabilities;\n\n    return;\n}\n\nsub dump_conf() {\n    for my $var (sort keys %config) {\n        printf \"%-30s %s\\n\", \"[+] $var\", $config{$var};\n    }\n    exit 0;\n}\n\nsub import_perl_modules() {\n\n    my $mod_paths_ar = &get_mod_paths();\n\n    if ($#$mod_paths_ar > -1) {  ### /usr/lib/fwsnort/ exists\n        push @$mod_paths_ar, @INC;\n        splice @INC, 0, $#$mod_paths_ar+1, @$mod_paths_ar;\n    }\n\n    if ($debug) {\n        print \"[+] import_perl_modules(): The \\@INC array:\\n\";\n        print \"$_\\n\" for @INC;\n    }\n\n    require IPTables::Parse;\n    require NetAddr::IP;\n\n    return;\n}\n\nsub get_mod_paths() {\n\n    my @paths = ();\n\n    $config{'LIBS_DIR'} = $lib_dir if $lib_dir;\n\n    unless (-d $config{'LIBS_DIR'}) {\n        my $dir_tmp = $config{'LIBS_DIR'};\n        $dir_tmp =~ s|lib/|lib64/|;\n        if (-d $dir_tmp) {\n            $config{'LIBS_DIR'} = $dir_tmp;\n        } else {\n            return [];\n        }\n    }\n\n    opendir D, $config{'LIBS_DIR'}\n        or die \"[*] Could not open $config{'LIBS_DIR'}: $!\";\n    my @dirs = readdir D;\n    closedir D;\n\n    push @paths, $config{'LIBS_DIR'};\n\n    for my $dir (@dirs) {\n        ### get directories like \"/usr/lib/fwsnort/x86_64-linux\"\n        next unless -d \"$config{'LIBS_DIR'}/$dir\";\n        push @paths, \"$config{'LIBS_DIR'}/$dir\"\n            if $dir =~ m|linux| or $dir =~ m|thread|;\n    }\n    return \\@paths;\n}\n\nsub setup() {\n\n    ### these two directories must already exist for\n    ### things to work\n    die \"[*] No fwsnort directory $config{'CONF_DIR'}\"\n        unless -d $config{'CONF_DIR'};\n\n    $config{'FWSNORT_SCRIPT'}  = $ipt_script if $ipt_script;\n    $config{'RULES_DIR'}       = $rules_dir if $rules_dir;\n    $config{'QUEUE_RULES_DIR'} = $queue_rules_dir if $queue_rules_dir;\n    $config{'LOG_FILE'}        = $logfile if $logfile;\n\n    if ($rules_file) {\n        for my $file (split /\\,/, $rules_file) {\n            die \"[*] Snort rules file $file does not exist.\" unless -e $file;\n        }\n    } else {\n        for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n            die \"[*] No snort rules directory $dir, use --snort-rdir\"\n                unless -d $dir;\n        }\n    }\n\n    ### import fwsnort perl modules\n    &import_perl_modules();\n\n    for my $dir ($config{'LOG_DIR'}, $config{'STATE_DIR'}) {\n        unless (-d $dir) {\n            mkdir $dir, 0755 or die \"[*] Could not mkdir($dir): $!\";\n        }\n    }\n\n    unless (-d $config{'ARCHIVE_DIR'}) {\n        mkdir $config{'ARCHIVE_DIR'}, 0500 or\n            die \"[*] Could not mkdir($config{'ARCHIVE_DIR'}): $!\";\n    }\n\n    if (($queue_mode or $nfqueue_mode) and not -d $config{'QUEUE_RULES_DIR'}) {\n        mkdir $config{'QUEUE_RULES_DIR'}, 0500 or die $!;\n    }\n\n    return;\n}\n\nsub update_rules() {\n    print \"[+] Downloading latest rules into $config{'RULES_DIR'}/\";\n\n    my $dir = $config{'RULES_DIR'};\n    $dir =~ s/\\,.*//;\n    chdir $dir or die \"[*] Could not chdir $dir: $!\";\n\n    my $ctr = 0;\n    for my $url (@{$config{'UPDATE_RULES_URL'}}) {\n        my $file = '';\n        if ($url =~ m|.*/(.*)|) {\n            $file = $1;\n        } else {\n            next;\n        }\n\n        if (-e $file) {\n            move $file, \"${file}.tmp\"\n                or die \"[*] Could not move $file -> $file.tmp\";\n        }\n\n        system \"$cmds{'wget'} $url\";\n\n        if (-e $file) {  ### successful download\n            unlink \"${file}.tmp\";\n        } else {\n            print \"[-] Could not download $file file.\\n\";\n            if (-e \"${file}.tmp\") {\n                ### move the original back\n                move $file, \"${file}.tmp\"\n                    or die \"[*] Could not move $file -> $file.tmp\";\n            }\n        }\n\n        if ($ctr == 0 and $rules_url ne $DEFAULT_RULES_URL) {\n            ### manual URL specified from the command line\n            last;\n        }\n    }\n\n    print \"[+] Finished.\\n\";\n    exit 0;\n}\n\nsub ipt_rule_test() {\n    my $rule = shift;\n    my $chain = '';\n\n    print \"    CMD: $ipt_bin $rule\\n\" if $verbose;\n\n    if ($rule =~ m/\\-I\\s+(\\w+)\\s/) {\n        $chain = $1;\n    }\n\n    die qq{[*] Could not extract $ipt_str chain from: \"$rule\"}\n        unless $chain;\n\n    my $rv = (system \"$ipt_bin $rule 2> /dev/null\") >> 8;\n    if ($rv == 0) {\n        ### rule success, make sure to delete it.  We force that\n        ### the rule has just been inserted, so just delete the\n        ### first rule in the chain.  We could just delete the\n        ### rule using $rule, but it is unlikely that the first\n        ### rule in the chain isn't the one we just added\n        system \"$ipt_bin -D $chain $IPT_TEST_RULE_NUM\";\n        return $IPT_SUCCESS;\n    }\n    return $IPT_FAILURE;\n}\n\nsub create_test_chain() {\n    system \"$ipt_bin -F $TEST_CHAIN 2> /dev/null\";\n    system \"$ipt_bin -N $TEST_CHAIN 2> /dev/null\";\n    return;\n}\n\nsub delete_test_chain() {\n    system \"$ipt_bin -F $TEST_CHAIN 2> /dev/null\";\n    system \"$ipt_bin -X $TEST_CHAIN 2> /dev/null\";\n    return;\n}\n\nsub chk_commands() {\n    my @path = (qw(\n        /bin\n        /sbin\n        /usr/bin\n        /usr/sbin\n        /usr/local/bin\n        /usr/local/sbin\n    ));\n    CMD: for my $cmd (keys %cmds) {\n        unless (-x $cmds{$cmd}) {\n            my $found = 0;\n            PATH: for my $dir (@path) {\n                if (-x \"${dir}/${cmd}\") {\n                    $cmds{$cmd} = \"${dir}/${cmd}\";\n                    $found = 1;\n                    last PATH;\n                }\n            }\n            unless ($found) {\n                die \"[*] Could not find $cmd, edit $fwsnort_conf\";\n            }\n        }\n    }\n    return;\n}\n\nsub archive() {\n    my $file = shift;\n    return unless -e $file;\n    return unless $file =~ m|/|;\n    my ($filename) = ($file =~ m|.*/(.*)|);\n    my $targetbase = \"$config{'ARCHIVE_DIR'}/${filename}.old\";\n    for (my $i = 4; $i > 1; $i--) {  ### keep five copies of the old config files\n        my $oldfile = $targetbase . $i;\n        my $newfile = $targetbase . ($i+1);\n        if (-e $oldfile) {\n            move $oldfile, $newfile;\n        }\n    }\n    if (-e $targetbase) {\n        my $newfile = $targetbase . '2';\n        move $targetbase, $newfile;\n    }\n    &logr(\"[+] Archiving $file\");\n    move $file, $targetbase;   ### move $file into the archive directory\n    return;\n}\n\nsub write_ipt_script() {\n\n    ### archive any existing ipt_script file\n    &archive($config{'FWSNORT_SCRIPT'});\n\n    ### make sure the script is writable first\n    if (-e $config{'FWSNORT_SCRIPT'}) {\n        chmod 0755, $config{'FWSNORT_SCRIPT'} or\n            die \"[*] Could not chmod $config{'FWSNORT_SCRIPT'}: $!\";\n    }\n\n    open F, \"> $config{'FWSNORT_SCRIPT'}\" or\n        die \"[*] Could not open $config{'FWSNORT_SCRIPT'}: $!\";\n    print F \"$_\\n\" for @ipt_script_lines;\n    close F;\n\n    chmod 0500, $config{'FWSNORT_SCRIPT'} or\n        die \"[*] Could not chmod $config{'FWSNORT_SCRIPT'}: $!\";\n\n    return;\n}\n\nsub expand_addresses() {\n    my $addr_string = shift;\n    $addr_string =~ s/\\]//;\n    $addr_string =~ s/\\[//;\n\n    return ['0.0.0.0/0'] if $addr_string =~ /any/i;\n\n    my @addrs = ();\n\n    my @addrstmp = split /\\s*,\\s*/, $addr_string;\n    for my $addr (@addrstmp) {\n        if ($addr =~ m|($ip_re/$ip_re)|) {\n            push @addrs, $1;\n        } elsif ($addr =~ m|($ip_re/\\d+)|) {\n            push @addrs, $1;\n        } elsif ($addr =~ m|($ip_re)|) {\n            push @addrs, $1;\n        }\n    }\n    return \\@addrs;\n}\n\nsub run_last_cmdline() {\n\n    my $save_file = \"$homedir/.fwsnort.run\";\n\n    open S, \"< $save_file\" or die \"[*] Could not open $save_file: $!\";\n    my $arg_line = <S>;\n    close S;\n    chomp $arg_line;\n\n    print \"[+] Running with last command line args: $arg_line\\n\";\n\n    @ARGV = split /\\s+/, $arg_line;\n    @argv_cp = @ARGV;\n\n    ### run GetOpt() to get command line args\n    &handle_cmd_line();\n\n    return;\n}\n\nsub save_args() {\n    my $save_file  = \"$homedir/.fwsnort.run\";\n\n    open S, \"> $save_file\" or die \"[*] Could not open $save_file\";\n    print S \"@argv_cp\\n\";\n    close S;\n\n    return;\n}\n\nsub get_homedir() {\n    my $uid = $<;\n    if ($cmdl_homedir) {\n        $homedir = $cmdl_homedir;\n    } else {\n        ### prefer homedir specified in /etc/passwd (if it exists)\n        if (-e '/etc/passwd') {\n            open P, \"< /etc/passwd\" or die \"[*] Could not open /etc/passwd. \",\n                \"Exiting.\\n\";\n            my @lines = <P>;\n            close P;\n            for my $line (@lines) {\n                ### mbr:x:222:222:Michael Rash:/home/mbr:/bin/bash\n                chomp $line;\n                if ($line =~ /^(?:.*:){2}$uid:(?:.*:){2}(\\S+):/) {\n                    $homedir = $1;\n                    last;\n                }\n            }\n        }\n        unless ($homedir and -d $homedir) {\n            $homedir = $ENV{'HOME'} if defined $ENV{'HOME'};\n        }\n    }\n    die '[*] Could not determine homedir, use --Home option.'\n        unless ($homedir and -d $homedir);\n\n    return;\n}\n\nsub truncate_logfile() {\n    open L, \"> $config{'LOG_FILE'}\" or\n        die \"[*] Could not open $config{'LOG_FILE'}: $!\";\n    close L;\n    return;\n}\n\nsub write_save_file() {\n\n    ### append the final 'COMMIT' and 'Completed' lines\n    push @fwsnort_save_lines, \"COMMIT\\n\";\n    push @fwsnort_save_lines, $ipt_save_completed_line;\n\n    ### write out the iptables-save formatted fwsnort rules\n    &archive($config{'FWSNORT_SAVE_FILE'});\n\n    ### make sure the save file is writable first\n    if (-e $config{'FWSNORT_SCRIPT'}) {\n        chmod 0755, $config{'FWSNORT_SCRIPT'} or die $!;\n    }\n\n    open T, \"> $config{'FWSNORT_SAVE_FILE'}\" or\n        die \"[*] Could not write to: $config{'FWSNORT_SAVE_FILE'}\";\n    print T for @fwsnort_save_lines;\n    close T;\n\n    chmod 0600, $config{'FWSNORT_SAVE_FILE'} or\n        die \"[*] Could not chmod 0600 $config{'FWSNORT_SAVE_FILE'}\";\n\n    ### write out the script that will exec iptables-restore against\n    ### save file - this is what splices the fwsnort policy into the\n    ### running iptables policy\n    &archive($config{'FWSNORT_SAVE_EXEC_FILE'});\n\n    my @fws_exec_lines = ();\n    push @fws_exec_lines, &hdr_lines();\n\n    push @fws_exec_lines, <<_FWSNORT_SH_;\nDO_REVERT=0\n\nwhile getopts r f\ndo\n    case \\$f in\n        r) DO_REVERT=1\n    esac\ndone\n\nif [ \"\\$DO_REVERT\" = 1 ];\nthen\n    echo \" \"\n    echo \"[+] Reverting to original iptables policy...\"\n    $cmds{'grep'} -v FWSNORT $config{'FWSNORT_SAVE_FILE'} | exec $restore_bin\nelse\n    echo \" \"\n    echo \"[+] Splicing fwsnort $abs_num rules into the iptables policy...\"\n    $cmds{'cat'} $config{'FWSNORT_SAVE_FILE'} | exec $restore_bin\nfi\n\nexit\n\n_FWSNORT_SH_\n\n    ### make sure the file is writable first\n    if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n        chmod 0755, $config{'FWSNORT_SAVE_EXEC_FILE'} or die $!;\n    }\n\n    open T, \"> $config{'FWSNORT_SAVE_EXEC_FILE'}\" or\n        die \"[*] Could not write to: $config{'FWSNORT_SAVE_EXEC_FILE'}\";\n    print T \"$_\\n\" for @fws_exec_lines;\n    close T;\n\n    chmod 0500, $config{'FWSNORT_SAVE_EXEC_FILE'} or\n        die \"[*] Could not chmod 0500 $config{'FWSNORT_SAVE_EXEC_FILE'}\";\n\n    return;\n}\n\nsub is_root() {\n    if ($< == 0 and $> == 0) {\n        $is_root = 1;\n    }\n    return;\n}\n\nsub set_non_root_values() {\n    if ($fwsnort_conf eq $CONFIG_DEFAULT) {\n        $fwsnort_conf = './fwsnort.conf';\n    }\n\n    &set_defaults_without_ipt_test();\n    return;\n}\n\nsub set_defaults_without_ipt_test() {\n\n    $have_conntrack = 1;\n    $ipt_max_str_len = 128;\n    $ipt_max_comment_len = 255;\n    $ipt_max_log_prefix_len = 29;\n    $ipt_have_multiport_match = 1;\n    $ipt_multiport_max = 15;\n\n    ### put ipopts in the unsupported list\n    if (defined $snort_opts{'filter'}{'ipopts'}) {\n        $snort_opts{'unsupported'}{'ipopts'} =\n            $snort_opts{'filter'}{'ipopts'}{'regex'};\n        delete $snort_opts{'filter'}{'ipopts'};\n    } else {\n        $snort_opts{'unsupported'}{'ipopts'} = qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/;\n    }\n\n    return;\n}\n\nsub print_final_message() {\n\n    if ($is_root) {\n        print <<_MSG_;\n\n\n    Main fwsnort $save_str file: $config{'FWSNORT_SAVE_FILE'}\n\n    You can instantiate the fwsnort policy with the following command:\n\n    $restore_bin < $config{'FWSNORT_SAVE_FILE'}\n\n    Or just execute: $config{'FWSNORT_SAVE_EXEC_FILE'}\n\n_MSG_\n    } else {\n        print <<_MSG_;\n\n    Main fwsnort $save_str file: $config{'FWSNORT_SAVE_FILE'}\n\n    It does not appear as though you are running as root, so it is NOT\n    recommended that you run the fwsnort.sh script without first re-running\n    fwsnort as root first. The reason is that non-root users cannot execute\n    iptables, and therefore fwsnort had no way to check for iptables\n    capabilities or to parse any existing iptables policy for proper splicing\n    of fwsnort rules.\n\n    Exiting.\n\n_MSG_\n    }\n    return;\n}\n\nsub logr() {\n    my $msg = shift;\n    if ($stdout) {\n        print STDOUT \"$msg\\n\";\n    } else {\n        open F, \">> $config{'LOG_FILE'}\"\n            or die \"[*] Could not open $config{'LOG_FILE'}: $!\";\n        print F \"$msg\\n\";\n        close F;\n    }\n    return;\n}\n\nsub usage() {\n    my $exit = shift;\n    print <<_USAGE_;\n\nfwsnort v$version\n[+] By Michael Rash <mbr\\@cipherdyne.org>, http://www.cipherdyne.org/\n\nUsage: fwsnort [options]\n\nOptions:\n    --strict                  - Make snort parser very strict about\n                                which options it will translate into\n                                iptables rules.\n    --ipt-script=<script>     - Print iptables script to <script>\n                                instead of the default location at\n                                /var/lib/fwsnort/fwsnort.sh\n    --ipt-apply               - Execute the fwsnort.sh script.\n    --ipt-exec                - Synonym for --ipt-apply.\n    --ipt-revert              - Revert to a version of the iptables\n                                policy without any fwsnort rules.\n    --ipt-reject              - Add a protocol dependent REJECT rule\n                                (tcp resets for tcp or icmp port\n                                unreachable for udp messages) for\n                                every logging rule.\n    --ipt-drop                - Add a DROP rule for every logging rule.\n    --ipt-list                - List all rules in fwsnort chains.\n    --List                    - Synonym for --ipt-list.\n    --ipt-flush               - Flush all rules in fwsnort chains.\n    --Flush                   - Synonym for --ipt-flush.\n    --ipt-file=<file>         - Read iptables policy from a file.\n    --ipt-log-tcp-seq         - Add the --log-tcp-sequence iptables\n                                command line argument to LOG rules.\n    --snort-sid=<sid>         - Generate an equivalent iptables rule\n                                for the specific snort id <sid> (also\n                                supports a comma separate list of sids.)\n    --exclude-sid=<sid>       - Exclude a list of sids from translation.\n    --snort-conf=<file>       - Read Snort specific variables out of\n                                existing snort.conf file.\n    --snort-rdir=<dir>        - Specify path to Snort rules directory.\n                                This can be a list of directories separated\n                                by commas.\n    --snort-rfile=<file>      - Translate a single rules file (or a set of\n                                them separated by commas).\n    --ipt-check-capabilities  - Check iptables capabilities and exit.\n    --no-ipt-comments         - Do not add Snort \"msg\" fields to iptables\n                                rules with the iptables comment match.\n    --ipt-sync                - Only add iptables rules for signatures that\n                                are not already blocked by iptables.\n    --no-ipt-log              - Do not generate iptables log rules\n                                (can only be used with --ipt-drop).\n    --no-ipt-test             - Do not run any checks for availability\n                                of iptables modules (string, LOG,\n                                ttl, etc.).\n    --no-ipt-jumps            - Do not jump packets from built-in\n                                iptables INPUT or FORWARD chains to\n                                chains created by fwsnort.\n    --no-ipt-rule-nums        - For each iptables rule, add the rule\n                                number in the fwsnort chain to the\n                                logging prefix.  This option disables\n                                this behavior.\n    --no-ipt-INPUT            - Exclude INPUT chain processing.\n    --no-ipt-OUTPUT           - Exclude OUTPUT chain processing.\n    --no-ipt-FORWARD          - Exclude FORWARD chain processing.\n    --no-fast-pattern-order   - Do not reorder patterns based on length,\n                                and ignore the 'fast_pattern' keyword\n    --no-log-ip-opts          - Do not add --log-ip-options to LOG\n                                rules.\n    --no-log-tcp-opts         - Do not add --log-tcp-options to LOG\n                                rules.\n    --no-addresses            - Do not look at addresses assigned to\n                                local interfaces (useful for running\n                                fwsnort on a bridge).\n    --no-exclude-lo           - Do not exclude the loopback interface\n                                from fwsnort rules.\n    --restrict-intf=<intf>    - Restrict fwsnort rules to a specified\n                                interface (e.g. \"eth0\").\n    -6, --ip6tables           - Enable ip6tables mode to build an fwsnort\n                                policy via ip6tables instead of iptables.\n    --Home-net=<net/mask>     - Manually specify the Home network\n                                (CIDR or standard notation).\n    --External-net=<net/mask> - Manually specify the external network\n                                (CIDR or standard notation).\n    --update-rules            - Download latest rules from Emerging Threats\n                                (http://www.emergingthreats.net).\n    --rules-url=<url>         - Specify the URL to use for updating the\n                                Emerging Threats rule set - the default is:\n                                $rules_url\n    --include-perl-triggers   - Include 'perl -e \"print ...\"' commands that\n                                build payload data that matches snort\n                                rules.  By combining these commands with\n                                netcat, it is easy to test whether the\n                                iptables policy built by fwsnort properly\n                                detects attacks.\n    --include-type=<type>     - Only process snort rules of type <type>\n                                (e.g. \"ddos\" or \"backdoor\"). <type> can\n                                be a comma separated list.\n    --exclude-type=<type>     - Exclude processing of Snort rules of\n                                type <type> (e.g. \"ddos\" or \"backdoor\").\n                                <type> can be a comma separated list.\n    --include-regex=<regex>   - Include only those signatures that\n                                match the specified regex.\n    --exclude-regex=<regex>   - Exclude all Snort signatures that\n                                match the specified regex.\n    --include-re-caseless     - Make --include-regex searching case\n                                insensitive.\n    --exclude-re-caseless     - Make --exclude-regex searching case\n                                insensitive.\n    -c   --config=<config>    - Use <config> instead of the normal\n                                config file located at\n                                $fwsnort_conf\n    --logfile=<file>          - Log messages to <file> instead of the\n                                default location at:\n                                /var/log/fwsnort/fwsnort.log\n    -N   --NFQUEUE            - Build a policy designed to only send packets\n                                that match Snort signature \"content\" fields\n                                to userspace via the NFQUEUE target. This is\n                                designed to build a hybrid fwsnort policy\n                                that can be used by snort_inline.\n    --queue-num=<num>         - Specify the queue number in --NFQUEUE mode;\n                                the default is zero.\n    --queue-rules-dir=<dir>   - Specify the path to the generated set of\n                                Snort rules that are to be queued to\n                                userspace in --NFQUEUE or --QUEUE mode.  The\n                                default is /var/lib/fwsnort/snort_rules_queue/.\n    -Q   --QUEUE              - Same as the --NFQUEUE option, except use the\n                                older iptables QUEUE target.\n    --string-match-alg=<alg>  - Specify the string match algorithm to use\n                                within the kernel; the default is '$string_match_alg',\n                                but 'kmp' may also be chosen.\n    -U   --Ulog               - Force ULOG target for all log generation.\n    --ulog-nlgroup=<groupnum> - Specify a ULOG netlink group (the default\n                                is 1).  This gets used in -U mode, or for\n                                \"log\" rules since then we need all of the\n                                packet to be logged (via the ULOG pcap\n                                writer).\n    --Dump-ipt                - Dump iptables rules on STDOUT as the\n                                rules are parsed (most useful when trying\n                                to debug how Fwsnort integrates with an\n                                existing iptables policy).\n    --Dump-snort              - Dump Snort rules on STDOUT.\n    --Dump-conf               - Dump configuration on STDOUT and exit.\n    --add-deleted             - Added Snort \"deleted\" rules.\n    --Last-cmd                - Rebuild fwsnort.sh with the same command\n                                line args as the previous execution.\n    --lib-dir=<path>          - Specify path to lib directory.\n    --debug                   - Run in debug mode.\n    -v   --verbose            - Run in verbose mode.\n    -V   --Version            - Print fwsnort version number and exit.\n    -h   --help               - Display usage on STDOUT and exit.\n\n_USAGE_\n    exit $exit;\n}\n", ".\\\" Process this file with\n.\\\" groff -man -Tascii foo.1\n.\\\"\n.TH FWSNORT 8 \"Jan, 2011\" Linux\n.SH NAME\n.B fwsnort\n\\- Firewall Snort\n.SH SYNOPSIS\n.B fwsnort [options]\n.SH DESCRIPTION\n.B fwsnort\ntranslates SNORT rules into iptables rules on Linux systems and generates a\ncorresponding iptables policy in iptables-save format.  This ruleset allows\nnetwork traffic that matches Snort signatures (i.e.  attacks and other suspicious\nnetwork behavior) to\nbe logged and/or dropped by iptables directly without putting an interface\ninto promiscuous mode or queuing packets from kernel to user space.  Note\nthat fwsnort can also build an iptables policy that combines the string\nmatch extension with the NFQUEUE or QUEUE targets to allow the kernel to\nperform preliminary string matches that are defined within Snort rules\nbefore queuing matching packets to a userspace snort_inline instance.  Because the bulk of\nnetwork communications are not generallly malicious, this should provide a speedup\nfor snort_inline since the majority of packets do not then have to be\ncopied from kernel memory into user memory and subsequently inspected by\nsnort_inline.  There is a tradeoff here in terms of signature detection\nhowever because snort_inline when deployed in this way does not have the\nopportunity to see all packets associated with a session, so stream\nreassembly and signature comparisons against a reassembled buffer do not\ntake place (the stream preprocessor should be disabled in the userspace\nsnort_inline instance).\n\nAs of\n.B fwsnort-1.5\nall iptables rules built by fwsnort are written out to the\n.I /var/lib/fwsnort/fwsnort.save\nfile in iptables-save format.  This allows a long fwsnort policy (which may\ncontain thousands of iptables rules translated from a large Snort signature\nset) to be quickly instantiated via the \"iptables-restore\" command.  A wrapper\nscript\n.I /var/lib/fwsnort/fwsnort.sh\nis also written out to make this easy.  Hence, the typical work flow for\nfwsnort is to: 1) run fwsnort, 2) note the Snort rules that fwsnort was able\nto successfully translate (the number of such rules is printed to stdout),\nand then 3) execute the\n.I /var/lib/fwsnort/fwsnort.sh\nwrapper script to instantiate the policy in the running kernel.\n\n.B fwsnort\n(optionally) uses the IPTables::Parse CPAN module to parse\nthe iptables ruleset on the machine to determine which Snort rules are\napplicable to the specific iptables policy.  After all, if iptables is\nblocking all inbound http traffic from external addresses for example, it\nis probably not of much use to try detecting inbound attacks against against\ntcp/80.  By default fwsnort generates iptables rules that log Snort sid's\nwithin a \\-\\-log-prefix to syslog where the messages can be analyzed with a\nlog analyzer such as\n.B psad\n(see http://www.cipherdyne.org/psad/).\n.B fwsnort\nrelies on the iptables string match module to match Snort content fields\nin the application portion of ip traffic.  Since Snort rules can contain\nhex data in content fields (specified between pipe \"|\" characters), fwsnort\nimplements a patch against iptables (which has been accepted by the Netfilter\nproject as of iptables-1.2.7a) which adds a \"\\-\\-hex-string\" option.  This\nallow iptables to accept content fields from Snort rules such as\n\"|0d0a5b52504c5d3030320d0a|\" without any modification.\n.B fwsnort\nis able to translate approximately 60% of all rules from the Snort-2.3.3\nIDS into equivalent iptables rules.  For more information about the\ntranslation strategy as well as advantages/disadvantages of the method\nused by fwsnort to obtain intrusion detection data, see the README\nincluded with the fwsnort sources or browse to:\nhttp://www.cipherdyne.org/fwsnort/\n\n.B fwsnort\nis able to apply Snort rules to IPv6 traffic by building an ip6tables policy\n(see the \"\\-\\-ip6tables\" command line argument).\n.SH OPTIONS\n.TP\n.BR \\-c \", \" \\-\\^\\-config\\ \\<configuration\\ file>\nBy default fwsnort makes use of the configuration file\n.B /etc/fwsnort/fwsnort.conf\nfor almost all configuration parameters.  fwsnort can be made to\noverride this path by specifying a different file on the command\nline with the \\-\\-config option.\n.TP\n.BR \\-\\^\\-update-rules\nDownload the latest Emerging Threats rules from http://www.emergingthreats.net\nThis will overwrite the  emerging-all.rules file in the\n/etc/fwsnort/snort_rules/ directory.  Note that the automatic downloading\nof Snort rules from http://www.snort.org/ as of March, 2005 is only offered\nas a pay service.\n.TP\n.BR \\-\\^\\-rules-url\\ \\ <url>\nSpecify the URL to use when updating the Emerging Threats rule set (or any\nother rule set).  The default URL is: http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules\n.TP\n.BR \\-6 \", \" \\-\\^\\-ip6tables\nEnable\n.B ip6tables\nmode so that the fwsnort rule set is built into an ip6tables policy instead\nof the iptables policy.  This allows fwsnort controls to apply to IPv6\ntraffic.\n.TP\n.BR \\-\\^\\-include-type\\ \\ <rules\\ type>\nRestrict to processing snort rules of <rules type>.  Example rule\ntypes would include \"ddos\", \"backdoor\", and \"web-attacks\".  This option\nalso supports a comma-separated list of types, e.g. \"ddos,backdoor\".\n.TP\n.BR \\-\\^\\-exclude-type\\ \\ <rules\\ type>\nExclude all Snort rules from of type <rules type> from the translation\nprocess.  For example, if you don't want any rules from the file\nemerging-all.rules to be translated, then use \"emerging-all\" as the\nargument to this option.  A comma-separated list of types to exclude can\nbe specified.\n.TP\n.BR \\-\\^\\-include-regex\\ \\ <regex>\nOnly translate Snort rules that match the specified regular expression. This\nis useful to build\n.B fwsnort\npolicies for Snort rules that have a common characteristic (such as a string\nmatch on the word \"Storm\" for the Storm worm for example).\n.TP\n.BR \\-\\^\\-exclude-regex\\ \\ <regex>\nTranslate all Snort rules except those that match the specified regular\nexpression.  This is useful to omit Snort rules from\n.B fwsnort\npolicies that have a common characteristic (such as a string\nmatch on \"HTTP_PORTS\" for example).\n.TP\n.BR \\-\\^\\-include-re-caseless\nMake the rule matchine regular expression specified with\n.I \\-\\-include\\-regex\nmatch case insensitively.\n.TP\n.BR \\-\\^\\-exclude-re-caseless\nMake the rule matchine regular expression specified with\n.I \\-\\-exclude\\-regex\nmatch case insensitively.\n.TP\n.BR \\-\\^\\-snort-rdir\\ <snort-rules-directory>\nManually specify the directory where the snort rules files are located.\nThe default is\n.B /etc/fwsnort/snort_rules.\nMultiple directories are supported as a comma-separated list.\n.TP\n.BR \\-\\^\\-snort-rfile\\ <snort-rules-file>\nManually specify a Snort rules file to translated into iptables rules.\nMultiple files are also supported as a comma-separated list.\n.TP\n.BR \\-\\^\\-snort-sid\\ \\<sid>\nGenerate an iptables ruleset for a single snort rule specified by\n<sid>.  A comma-separated list of sids can be specified, e.g. \"2001842,1834\".\n.TP\n.BR \\-\\^\\-exclude-sid\\ \\<sid>\nProvide a list of Snort ID's to be excluded from the translation process.\n.TP\n.BR \\-\\^\\-include-perl-triggers\nInclude\n.I 'perl -e \"print ...\"'\ncommands as comments in the\n.I fwsnort.sh\nscript.  These commands allow payloads that are designed to trigger snort\nrules to easily be built, and when combined with netcat (or other software\nthat can send bytes over the wire) it becomes possible to test whether an\nfwsnort policy appropriately triggers on matching traffic.\n.TP\n.BR \\-\\^\\-ipt-script\\ \\<script\\ file>\nSpecify the path to the iptables script generated by fwsnort.  The\ndefault location is /var/lib/fwsnort/fwsnort.sh.\n.TP\n.BR \\-\\^\\-ipt-check-capabilities\nCheck iptables capabilities and exit.\n.TP\n.BR \\-\\^\\-Last\\-cmd\nRun\n.B fwsnort\nwith the same command line arguments as the previous execution.  This is a\nconvenient way of rebuilding the\n.I /var/lib/fwsnort/fwsnort.sh\nscript without having to remember what the last command line args were.\n.TP\n.BR \\-\\^\\-NFQUEUE\nBuild an\n.B fwsnort\npolicy that sends packets that match Snort\n.B content\nor\n.B uricontent\nfields to userspace via the iptables NFQUEUE target for further analysis.  This is a\nmechanism for reducing the signature inspection load placed on snort_inline.\nA parallel set of Snort rules that are successfully translated are placed in\nthe /etc/fwsnort/snort_rules_queue directory.  This requires\nCONFIG_NETFILTER_XT_TARGET_NFQUEUE support in the Linux kernel.\n.TP\n.BR \\-\\^\\-QUEUE\nSame as the\n.B --NFQUEUE\ncommand line argument except that the older QUEUE target is used instead of\nthe NFQUEUE target.  This requires CONFIG_IP_NF_QUEUE support in the Linux kernel.\n.TP\n.BR \\-\\^\\-queue-num\\ \\<num>\nSpecify a queue number in \\-\\-NFQUEUE mode.\n.TP\n.BR \\-\\^\\-queue-pre-match-max\\ \\<num>\nIn \\-\\-QUEUE or \\-\\-NFQUEUE mode, limit the number of content matches that are\nperformed within the kernel before sending a matching packet to a userspace\nSnort instance.  This allows a level of tuning with respect to how much work\nthe kernel does to qualify a packet based on a signature match before having\nSnort do the same thing.  The default is to perform all specified content\nmatches in the signature before queuing the packet to userspace because the\nmultiple in-kernel content matches is probably less expensive than sending a\npacket to userspace by default.\n.TP\n.BR \\-\\^\\-string-match-alg\\ \\<alg>\nSpecify the string matching algorithm to use with the kernel.  By default, this\nis 'bm' for the 'Boyer-Moore' string matching algorithm, but 'kmp' may also be\nspecified (short for the 'Knuth\u2013Morris\u2013Pratt' algorithm).\n.TP\n.BR \\-\\^\\-ipt-apply\nExecute the iptables script generated by fwsnort.\n.TP\n.BR \\-\\^\\-ipt-exec\nSynonym for \\-\\-ipt-apply.\n.TP\n.BR \\-\\^\\-ipt-revert\nRevert to a version of the iptables policy without any\n.B fwsnort\nrules.  Note that this reverts to the iptables policy as it was when\n.B fwsnort\nwas originally executed.  So, it is not recommended to use this option if there\nis a large amount of time between when fwsnort is run to translate Snort rules\nvs. running it with this option.  For most purposes it is better to use\nthe \\-\\-ipt-flush option below.\n.TP\n.BR \\-\\^\\-ipt-flush\nFlush all\n.B fwsnort\ncurrently active iptables rules (flushes the fwsnort chains).\n.TP\n.BR \\-\\^\\-ipt-list\nList all\n.B fwsnort\ncurrently active iptables rules (lists the fwsnort chains).\n.TP\n.BR \\-\\^\\-ipt-drop\nFor each logging rule generated by\n.B fwsnort\nadd a corresponding DROP\nrule.  Note that for TCP sessions using this option will cause retransmissions\nas packets that are part of established sessions selectively dropped.\nRemember that false positives are common occurrences for intrusion detection\nsystems, and so using this or the \\-\\-ipt-reject option may break things on\nyour network!  You have been warned.\n.TP\n.BR \\-\\^\\-ipt-reject\nFor each logging rule generated by\n.B fwsnort\nadd a corresponding REJECT rule.\nReset packets will be generated for TCP sessions through the use of\nthe \"\\-\\-reject-with tcp-reset\" option, and ICMP port unreachable messages will\nbe generated for UDP packets through the use of the\n\"\\-\\-reject-with icmp-port-unreachable\" option.\n.TP\n.BR \\-C \", \" \\-\\^\\-Conntrack-state\\ \\<state>\nSpecify a conntrack state in place of the \"established\" state that commonly\naccompanies the Snort \"flow\" keyword.  By default, fwsnort uses the conntrack\nstate of \"ESTABLISHED\" for this.  In certain corner cases, it might be useful\nto use \"ESTABLISHED,RELATED\" instead to apply application layer inspection to\nthings like ICMP port unreachable messages that are responses to real attempted\ncommunications.\n.TP\n.BR \\-\\^\\-no-ipt-log\nBy default fwsnort generates an iptables script that implements a logging\nrule for each successfully translated snort rule.  This can be disabled\nwith the \\-\\-no-ipt-log option, but \\-\\-ipt-drop must also be specified.\n.TP\n.BR \\-\\^\\-no-ipt-sync\nThis is a deprecated option since the default behavior is to translate as\nmany Snort rules into iptables rules as possible.  With\n.B fwsnort\nable to produce iptables rules in iptables\\-save format, it is extremely fast\nto instantiate a large set of translated Snort rules into an iptables policy.\nA new \\-\\-ipt-sync option has been added to reverse this behavior (not\nrecommended).\n.TP\n.BR \\-\\^\\-ipt-sync\nConsult the iptables policy currently running on the machine\nfor applicable snort rules.\n.TP\n.BR \\-\\^\\-no-ipt-test\nDo not test the iptables build for existence of support for the LOG and\nREJECT targets, and ascii and hex string matching.\n.TP\n.BR \\-\\^\\-no-ipt-jumps\nDo not jump packets from the built-in iptables INPUT, OUTPUT, and\nFORWARD chains to the custom\n.B fwsnort\nchains.  This options is mostly useful to make it\neasy to manually alter the placement of the jump rules in the iptables\nruleset.\n.TP\n.BR \\-\\^\\-no-ipt-rule-nums\nBy default\n.B fwsnort\nincludes the rule number within the logging prefix for each of the rules it\nadds to the fwsnort chains.  E.g. the logging prefix for rule 34 would look\nsomething like \"[34] SID1242 ESTAB\".  Use this option to not include the\nrule number.\n.TP\n.BR \\-\\^\\-no-ipt-comments\nIf the iptables \"comment\" match exists, then\n.B fwsnort\nputs the Snort \"msg\", \"classtype\", \"reference\", \"priority\", and \"rev\" fields\nwithin a comment for each iptables rule.  Use this option to disable this.\n.TP\n.BR \\-\\^\\-no-ipt-INPUT\nDo not jump packets from the iptables INPUT chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-ipt-OUTPUT\nDo not jump packets from the iptables OUTPUT chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-ipt-FORWARD\nDo not jump packets from the iptables FORWARD chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-fast-pattern-ordering\nCause\n.B fwsnort\nto not try to reorder pattern matches to process the longest pattern first.\nThe Snort\n.I fast_pattern\nkeyword is also ignored if this option is specified.\n.TP\n.BR \\-H \", \" \\-\\^\\-Home-net\\ \\<network/mask>\nSpecify the internal network instead of having\n.B fwsnort\nderive it from the HOME_NET keyword in the fwsnort.conf configuration\nfile.\n.TP\n.BR \\-E \", \" \\-\\^\\-External-net\\ \\<network/mask>\nSpecify the external network instead of having\n.B fwsnort\nderive it from the EXTERNAL_NET keyword in the fwsnort.conf configuration\nfile.\n.TP\n.BR \\-\\^\\-no-addresses\nDisable all checks against the output of ifconfig for proper IP addresses.\nThis is useful if\n.B fwsnort\nis running on a bridging firewall.\n.TP\n.BR \\-\\^\\-Dump-conf\nPrint the fwsnort configuration on STDOUT and exit.\n.TP\n.BR \\-\\^\\-debug\nRun in debug mode.  This will cause all parse errors which are normally\nwritten to the fwsnort logfile\n.B /var/log/fwsnort.log\nto be written to STDOUT instead.\n.TP\n.BR \\-\\^\\-strict\nRun fwsnort in \"strict\" mode.  This will prevent fwsnort from translating\nsnort rules that contain the keywords \"offset\", \"uricontent\", and \"depth\".\n.TP\n.BR \\-U \", \" \\-\\^\\-Ulog\nForce the usage of the ULOG target for all log messages instead of the\ndefault LOG target.\n.TP\n.BR \\-\\^\\-ulog-nlgroup\nSpecify the netlink group for ULOG rules.  Such rules are only added for\nSnort rules that have an action of \"log\", or when\n.B fwsnort\nis run in\n.B --Ulog\nmode.\n.TP\n.BR \\-l \", \" \\-\\^\\-logfile\\ <logfile>\nBy default fwsnort logs all parse errors to the logfile\n.B /var/log/fwsnort.log.\nThis path can be manually changed with the \\-\\-logfile option.\n.TP\n.BR \\-v \", \" \\-\\^\\-verbose\nRun fwsnort in verbose mode.  This will cause fwsnort to add the original\nsnort rule as a comment to the fwsnort.sh script for each successfully\ntranslated rule.\n.TP\n.BR \\-V \", \" \\-\\^\\-Version\nPrint the fwsnort version and exit.\n.TP\n.BR \\-h \", \" \\-\\^\\-help\nPrint usage information on STDOUT and exit.\n.SH FILES\n.B /etc/fwnort/fwsnort.conf\n.RS\nThe fwsnort configuration file.  The path to this file can be\nchanged on the command line with \\-\\-config.\n.RE\n\n.B /var/lib/fwnort/fwsnort.sh\n.RS\nThe iptables script generated by fwsnort.  The path can be manually\nspecified on the command line with the \\-\\-ipt-script option.\n.SH FWSNORT CONFIGURATION VARIABLES\nThis section describes what each of the more important fwsnort configuration\nvariables do and how they can be tuned to meet your needs.  These variables\nare located in the fwsnort configuration file\n.B /etc/fwsnort/fwsnort.conf\n.TP\n.BR HOME_NET\n.B fwsnort\nuses the same HOME_NET and EXTERNAL_NET variables as defined in Snort rules,\nand the same semantics are supported.  I.e., individual IP addresses or networks\nin standard dotted-quad or CIDR notation can be specified, and comma separated\nlists are also supported.\n.TP\n.BR EXTERNAL_NET\nDefines the external network.  See the HOME_NET variable for more information.\n.SH EXAMPLES\nThe following examples illustrate the command line arguments that could\nbe supplied to fwsnort in a few situations:\n.PP\nScript generation in logging mode, parse errors written to the fwsnort\nlogfile, and iptables policy checking are enabled by default without\nhaving to specify any command line arguments:\n.PP\n.B # fwsnort\n.PP\nGenerate ip6tables rules for attacks delivered over IPv6:\n.PP\n.B # fwsnort -6\n.PP\nGenerate iptables rules for ddos and backdoor Snort rules only:\n.PP\n.B # fwsnort --include-type ddos,backdoor\n.PP\nGenerate iptables rules for Snort ID's 2008475 and 2003268 (from emerging-all.rules):\n.PP\n.B fwsnort --snort-sid 2008475,2003268\n.PP\nGenerate iptables rules for Snort ID's 1834 and 2001842 but queue them to userspace\nvia the NFQUEUE target and restrict exclude the INPUT and OUTPUT chains:\n.PP\n.B fwsnort --snort-sid 1834,2001842 --NFQUEUE --no-ipt-INPUT --no-ipt-OUTPUT\n.PP\nInstruct\n.B fwsnort\nto only inspect traffic that traverses the eth0 and eth1 interfaces:\n.PP\n.B # fwsnort --restrict-intf eth0,eth1\n.PP\nGenerate iptables rules for Snort rules that appear to be allowed by the local\niptables policy, and write original snort rules to the iptables script as a comment:\n.PP\n.B # fwsnort --ipt-sync --verbose\n.SH DEPENDENCIES\n.B fwsnort\nrequires that the iptables string match module be compiled into the\nkernel (or as a loadable kernel module) in order to be able to match\nsnort signatures that make use of the \"content\" keyword.  Note that\nthe \\-\\-no-opt-test option can be specified to have fwsnort generate an\niptables script even if the string match module is not compiled in.\n.PP\n.B fwsnort\nalso requires the IPTables::Parse CPAN module in order to parse\niptables policies.  This module is bundled with the fwsnort sources in\nthe deps/ directory for convenience.\n.SH DIAGNOSTICS\nThe \\-\\-debug option can be used to display on STDOUT any errors that\nare generated as fwsnort parses each snort rule.  Normally these\nerrors are written to the fwsnort logfile /var/log/fwsnort.log\n.SH \"SEE ALSO\"\n.BR psad (8),\n.BR iptables (8),\n.BR snort (8),\n.BR nmap (1)\n.SH AUTHOR\nMichael Rash <mbr@cipherdyne.org>\n.SH CONTRIBUTORS\nMany people who are active in the open source community have contributed to fwsnort;\nsee the\n.B CREDITS\nfile in the fwsnort sources, or visit\n.B http://www.cipherdyne.org/fwsnort/docs/contributors.html\nto view the online list of contributors.\n\n.B fwsnort\nis based on the original\n.B snort2iptables\nscript written by William Stearns.\n.SH BUGS\nSend bug reports to mbr@cipherdyne.org. Suggestions and/or comments are\nalways welcome as well.\n.SH DISTRIBUTION\n.B fwsnort\nis distributed under the GNU General Public License (GPLv2), and the latest\nversion may be downloaded from\n.B http://www.cipherdyne.org/\nSnort is a registered trademark of Sourcefire, Inc.\n"], "fixing_code": ["Thomas Bullinger\n    - Contributed patches for the --no-jumps option\n    - Wrote the makefwsnort.sh script to download the latest stable snort\n      rules.\n    - Bugfix for correct IP protocol number.\n    - Bugfix for missed --ipt-script option.\n    - Suggested the ability to specify multiple sid's with the --snort-sids\n      option.\n\nPaul O'Neil\n    - Discovered missed DMZ interface code bug.\n\nAhmad Almulhem\n    - Suggested --ipt-tos and --ipt-mark options\n    - Suggested ability to manually specify interface networks instead of\n      automatically parsing the output of ifconfig.  This allows fwsnort to be\n      run on a system where no IP is assigned to an interface such as a linux\n      box that is acting as a bridge.\n\nHank Leininger\n    - Suggested the combination of the QUEUE target and string matching as a\n      way to speed up inline Snort implementations.  This suggestion was made\n      at a talk I gave about Linux Firewalls at ShmooCon 2007, and the\n      --NFQUEUE and --QUEUE command line arguements were the result.\n\nGrant Ferley\n    - Submitted patch to exclude loopback interfaces from iptables allow rules\n      parsing.  This behavior can be reversed with the existing\n      --no-exclude-loopback command line argument.\n    - Submitted patch to IPTables::Parse to take into account iptables policy\n      output that contains \"0\" instead of \"all\" to represent any protocol.\n    - Suggested bugfix to allow negated networks to be specified within\n      iptables allow rules or within the fwsnort.conf file.\n\nFranck Joncourt\n    - Submitted patch to fix double dash format in fwsnort man page.\n    - Architected the process of packaging fwsnort (and the other Cipherdyne\n      projects) for the Debian Linux distribution.\n    - Submitted fwsnort documentation fixes for the ChangeLog and fwsnort man\n      page.\n    - Suggested creating the Snort rules directory if it doesn't already exist\n      when downloading the rules from Emerging Threats.\n    - Submitted patch for the MAX_STRING_LEN protection around iptables string\n      match arguments.\n    - Submitted patch for fwsnort to use the \"! <option> <arg>\" syntax instead\n      of the older \"<option> ! <arg>\" for the iptables command line.\n\nJustin B Rye\n    - Suggested wording updates for the fwsnort(8) man page in support of the\n      Debian package for fwsnort.\n\nD T\n    - Asked about whether fwsnort could be updated to apply to IPv6 traffic\n      on the fwsnort mailing list.\n\nGuillermo Gomez\n    - Fedora maintainer of fwsnort.\n    - Suggested a default logging location of /var/log/fwsnort/fwsnort.log\n      instead of /var/log/fwsnort.log.  The result was the addition of the\n      LOG_DIR and associated variables in the fwsnort.conf file.\n\nAndy Rowland\n    - Found a bug where fwsnort would attempt to use an invalid URL when\n      updating the Emerging Threats rule set via --update-rules.\n\nYves Pagani\n    - Found a bug where fwnsort could build iptables --log-prefix strings that\n      are longer than the underlying iptables firewall would allow.\n\nKim Hagen\n    - Submitted a patch for a bug in fwsnort-1.6 where the fwsnort policy in\n      iptables-save format could not be loaded whenever iptables-save put the\n      nat table output after the filter table output.  In this case, fwsnort\n      would fail with an error like the following (fixed in fwsnort-1.6.1):\n\n        Couldn't load target\n        `FWSNORT_FORWARD_ESTAB':/lib/xtables/libipt_FWSNORT_FORWARD_ESTAB.so:\n        cannot open shared object file: No such file or directory\n\nPeter Vrabec\n    - Suggested a new directory /var/lib/fwsnort/ for the fwsnort.sh script\n      and associated files (fwsnort.save, fwsnort_iptcmd.sh, etc.).\n\nAndrew Merenbach\n    - Contributed bug fix to properly honor --exclude-regex filtering option.\n\nDwight Davis\n    - Contributed patches for several bugs including not handling\n      --exclude-regex properly, not ignoring the deleted.rules file, not\n      handling --strict mode opertions correctly, and more.  These issues and\n      the corresponding patch were originally reported here:\n        http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=693000\n\nMurray McAllister (Red Hat Security Team)\n    - Reported a bug fix for vulnerability CVE-2014-0039 in which an attacker-\n      controlled fwsnort.conf file could be read by fwsnort when not running as\n      root.  This was caused by fwsnort reading './fwsnort.conf' when not\n      running as root and when a path to the config file was not explicitly set\n      with -c on the command line.  This behavior has been changed to require\n      the user to specify a path to fwsnort.conf with -c when not running as\n      root.\n", "fwsnort-1.6.4 (02//2014):\n    - Bug fix for vulnerability CVE-2014-0039 reported by Murray McAllister of\n      the Red Hat Security Team in which an attacker-controlled fwsnort.conf\n      file could be read by fwsnort when not running as root.  This was caused\n      by fwsnort reading './fwsnort.conf' when not running as root and when a\n      path to the config file was not explicitly set with -c on the command\n      line.  This behavior has been changed to require the user to specify a\n      path to fwsnort.conf with -c when not running as root.\n\nfwsnort-1.6.3 (12/21/2012):\n    - Bug fix to ensure that !, <, >, and = chars in content strings are\n      converted to the appropriate hex equivalents.  All content strings with\n      characters outside of [A-Za-z0-9] are now converted to hex-string format\n      in their entirety.  This should also fix an issue that results in the\n      following error when running /var/lib/fwsnort/fwsnort.sh:\n\n        Using intrapositioned negation (`--option ! this`) is deprecated in\n        favor of extrapositioned (`! --option this`).\n        Bad argument `bm'\n        Error occurred at line: 64\n        Try `iptables-restore -h' or 'iptables-restore --help' for more\n        information.\n            Done.\n\n    - Bug fix to set default max string length in --no-ipt-test mode where\n      iptables capabilities are not tested.\n    - (Andrew Merenbach) Bug fix to properly honor --exclude-regex filtering\n      option.\n    - Added fwsnort test suite to the test/ directory.  This mimics the test\n      suites from the psad and fwknop projects, and it designed to examine\n      many of the run time results of fwsnort.\n    - Added the ability to easily revert the fwsnort policy back to the\n      original iptables policy with \"/var/lib/fwsnort/fwsnort.sh -r\".  Note\n      that this reverts back to the policy as it was when fwsnort itself was\n      executed.\n    - Implemented a single unified function for iptables match parameter\n      length testing, and optimized to drastically reduce run time for iptables\n      capabilities checks (going from over 20 seconds to less than one second\n      in some cases).\n    - (Dwight Davis) Contributed patches for several bugs including not\n      handling --exclude-regex properly, not ignoring the deleted.rules file,\n      not handling --strict mode operations correctly, and more.  These issues\n      and the corresponding patch were originally reported here:\n        http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=693000\n    - Bug fix for Snort rules with HOME_NET(any) -> EXTERNAL_NET(any) to\n      ensure they go into the OUTPUT chain instead of the INPUT chain.  This\n      bug was reported by Dwight Davis.\n    - Updated to bundle the latest Emerging Threats rule set.\n\nfwsnort-1.6.2 (04/28/2012):\n    - Switched --no-ipt-sync to default to not syncing with the iptables policy.\n      By default fwsnort attempts to match translated Snort rules to the\n      running iptables policy, but this is tough to do well because iptables\n      policies can be complex.  And, before fwsnort switched to the\n      iptables-save format for instantiating the policy, a large set of\n      translated rules could take a really long time to make active within the\n      kernel.  Finally, many Snort rules restrict themselves to established TCP\n      connections anyway, and if a restrictive policy doesn't allow connections\n      to get into the established state for some port let's say, then there is\n      little harm in having translated Snort rules for this port.  Some kernel\n      memory would be wasted (small), but no performance would be lost since\n      packets won't be processed against these rules anyway.  The end result is\n      that the default behavior is now to not sync with the local iptables\n      policy in favor of translating and instantiating as many rules as\n      possible.\n    - Replaced Net::IPv4Addr with the excellent NetAddr::IP module which has\n      comprehensive support for IPv6 address network parsing and comparisons.\n    - Moved the fwsnort.sh script and associated files into the\n      /var/lib/fwsnort/ directory.  This was suggested by Peter Vrabec.\n    - Bug fix for recent versions of iptables (such as 1.4.12) where the icmp\n      match requires --icmp-type to be set - some Snort rules look for a string\n      to match in icmp traffic, but don't also specify an icmp type.\n    - Bug fix for 'qw(...) usage as parenthesis' warnings for perl > 5.14\n    - Removed the ExtUtils::MakeMaker RPM build requirement from the\n      fwsnort.spec file.  This is a compromise which will allow the fwsnort RPM\n      to be built even if RPM dosen't or can't see that ExtUtils::MakeMaker is\n      installed - most likely it will build anyway.  If it doesn't, there are\n      bigger problems since fwsnort is written in perl.  If you want to build\n      the fwsnort RPM with a .spec file that requires ExtUtils::MakeMaker, then\n      use the \"fwsnort-require-makemaker.spec\" file that is bundled in the\n      fwsnort sources.\n\nfwsnort-1.6.1 (11/01/2011):\n    - (Kim Hagen) submitted a patch for a bug in fwsnort-1.6 where the fwsnort\n      policy in iptables-save format could not be loaded whenever iptables-save\n      put the nat table output after the filter table output.  In this case,\n      fwsnort would fail with an error like the following:\n\n        Couldn't load target\n        `FWSNORT_FORWARD_ESTAB':/lib/xtables/libipt_FWSNORT_FORWARD_ESTAB.so:\n        cannot open shared object file: No such file or directory\n\n      fwsnort now invokes 'iptables-save -t filter' in order to ensure that\n      ordering issues do not affect how fwsnort builds its translated rule set.\n    - Bug fix to ensure that fwsnort does not attempt to re-order pattern\n      matches for patterns that have a relative match requirement.  For non-\n      relative matches fwsnort re-orders pattern matches based on the pattern\n      length, reasoning that the longest pattern should be processed first for\n      better performance.  The usage of the fast_pattern keyword give the user\n      explicit control over this.  Here is a Snort rule that is now properly\n      handled by fwsnort (references removed):\n\n       alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:\"ET WEB_CLIENT\n       Possible Adobe Reader and Acrobat Forms Data Format Remote Security\n       Bypass Attempt\"; flow:established,to_client; file_data; content:\"%FDF-\";\n       depth:300; content:\"/F(JavaScript|3a|\"; nocase; distance:0;\n       classtype:attempted-user; sid:2010664; rev:8;)\n\n      Before this change, fwsnort translated this rule as:\n\n      $IPTABLES -A FWSNORT_FORWARD_ESTAB -p tcp -m tcp --sport 80 -m string\n      --hex-string \"/F(JavaScript|3a|\" --algo bm --from 69 --icase -m string\n      --hex-string \"%FDF|2d|\" --algo bm --to 364 -m comment --comment\n      \"sid:2010664; msg:ET WEB_CLIENT Possible Adobe Reader and Acrobat Forms\n      Data Format Remote Security Bypass Attempt; classtype:attempted-user;\n      rev:8; FWS:1.6;\" -j LOG --log-ip-options --log-tcp-options --log-prefix\n      \"SID2010664 ESTAB \"\n\n      Note that in the above rule, the \"/F(JavaScript|3a|\" pattern was switched\n      to be evaluated first even though it is a relative match to the previous\n      pattern in the original Snort rule.  After this change, fwsnort translates\n      this rule as:\n\n      $IPTABLES -A FWSNORT_FORWARD_ESTAB -p tcp -m tcp --sport 80 -m string\n      --hex-string \"%FDF|2d|\" --algo bm --to 364 -m string --hex-string\n      \"/F(JavaScript|3a|\" --algo bm --from 69 --icase -m comment --comment\n      \"sid:2010664; msg:ET WEB_CLIENT Possible Adobe Reader and Acrobat Forms\n      Data Format Remote Security Bypass Attempt; classtype:attempted-user;\n      rev:8; FWS:1.6;\" -j LOG --log-ip-options --log-tcp-options --log-prefix\n      \"SID2010664 ESTAB \"\n\n    - Updated to the latest Emerging Threats rule set.\n\nfwsnort-1.6 (07/28/2011):\n    - Fixed the --ipt-apply functionality - the variable that held the\n      fwsnort.sh path was not initialized properly prior to this change.\n    - Added the --Conntrack-state argument to specify a conntrack state\n      in place of the \"established\" state that commonly accompanies the Snort\n      \"flow\" keyword.  By default, fwsnort uses the conntrack state of\n      \"ESTABLISHED\" for this.  In certain corner cases, it might be useful to\n      use \"ESTABLISHED,RELATED\" instead to apply application layer inspection\n      to things like ICMP port unreachable messages that are responses to real\n      attempted communications.  (Need to add UDP tracking for the _ESTAB\n      chains for this too - coming soon.)\n    - Recent releases of iptables and the Linux kernel support matching on\n      connection state via the conntrack modules and the --ctstate switch.\n      Added a capabilities test for this, and will fall back to using the state\n      match if the conntrack module is not available.\n    - Bugfix to ensure the iptables log prefixes built by fwsnort are not\n      longer than those allowed by the running iptables firewall.  This is\n      usually a total of 29 characters, but fwsnort now dynamically figures out\n      this value.\n    - Bugfix for --ipt-list and --ipt-flush to ensure that the proper iptables\n      binary path is chosen.  These args failed without this because the\n      iptables binary was not set.\n\nfwsnort-1.5 (01/08/2011):\n    - Major update to use the iptables-save format instead of the older\n      strategy of always just executing iptables commands directly (which was\n      very flow for large fwsnort policies).  The /etc/fwsnort/fwsnort.sh\n      script now just executes:\n\n        /sbin/iptables-restore < /etc/fwsnort/fwsnort.save\n\n      All fwsnort rules are now placed in the /etc/fwsnort/fwsnort.save file,\n      but the older fwsnort.sh output (for the individual commands version)\n      is still available at /etc/fwsnort/fwsnort_iptcmds.sh.  This\n      functionality extends to ip6tables policies as well.  The fwsnort man\n      page explain this in better detail:\n\n      \"As of fwsnort-1.5 all iptables rules built by fwsnort are written out\n      to the /etc/fwsnort/fwsnort.save file in iptables-save format.  This\n      allows a long fwsnort policy (which may contain thousands of iptables\n      rules translated from a large Snort signature set) to be quickly\n      instantiated via the \"iptables-restore\" command.  A wrapper script\n      /etc/fwsnort/fwsnort.sh is also written out to make this easy.  Hence,\n      the typical work flow for fwsnort is to: 1) run fwsnort, 2) note the\n      Snort rules that fwsnort was able to successfully translate (the number\n      of such rules is printed to stdout), and then 3) execute the\n      /etc/fwsnort/fwsnort.sh wrapper script to instantiate the policy in the\n      running kernel.\"\n\n    - Added the --rules-url argument so that the URL for updating the\n      Emerging Threats rule set can be specified from the command line.  The\n      default is:\n\n        http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules\n\n    - Updated to automatically check for the maximum length string that the\n      string match supports, and this is used to through out any Snort rules\n      with content matches longer than this length.\n    - Updated the iptables capabilities testing routines to add and delete\n      testing rules to/from the custom chain 'FWS_CAP_TEST'.  This maintains a\n      a cleaner separation between fwsnort and any existing iptables policy\n      even during the capabilities testing phase.\n    - Added the --ipt-check-capabilities argument to have fwsnort test the\n      capabilities of the local iptables firewall and exit.\n    - Added the --string-match-alg argument to allow the string matching\n      algorithm used by fwsnort to be specified from the command line.  The\n      default algorithm is 'bm' for 'Boyer-Moore', but 'kmp' may also be\n      specified (short for the 'Knuth\u2013Morris\u2013Pratt' algorithm).\n    - Updated to the latest complete rule set from Emerging Threats (see\n      http://www.emergingthreats.net/).\n\nfwsnort-1.1 (01/05/2010):\n    - Added the ability to build an fwsnort policy that utilizes ip6tables\n      instead of iptables.  This allows fwsnort filtering and altering\n      capabilities to apply to IPv6 traffic instead of just IPv4 traffic.  To\n      enable ip6tables usage, use the \"-6\" or \"--ip6tables\" command line\n      arguments.\n    - Added the --include-perl-triggers command line argument so that\n      translated Snort rules can easily be tested.  This argument instructs\n      fwsnort to include 'perl -e print ... ' commands as comments in the\n      /etc/fwsnort/fwsnort.sh script, and these commands can be combined\n      with netcat to send payloads across the wire that match Snort rules.\n    - Updated fwsnort to create logs in the /var/log/fwsnort/ directory\n      instead of directly in the /var/log/ directory.  The path is controlled\n      by a new variable 'LOG_FILE' in the /etc/fwsnort/fwsnort.conf file.\n    - Added several variables in /etc/fwsnort/fwsnort.conf to control paths\n      to everything from the config file to the snort rules path.  Coupled\n      with this is the ability to create variables within path components and\n      fwsnort will expand them (e.g. 'CONF_DIR /etc/fwsnort;\n      CONF_FILE $CONF_DIR/fwsnort.conf').\n    - Added --Last-cmd arg so that it is easy to rebuild the fwsnort.sh script\n      with the same command line args as the previous execution.\n\nfwsnort-1.0.6 (05/30/2009):\n    - (Franck Joncourt) Updated fwsnort to use the \"! <option> <arg>\" syntax\n      instead of the older \"<option> ! <arg>\" for the iptables command line.\n    - (Franck Joncourt) For the --hex-string and --string matches, if the\n      argument exceeds 128 bytes (iptables 1.4.2) then iptables fails with an\n      error \"iptables v1.4.2: STRING too long\".  Fixes this with a patch that\n      adds a new variable in fwsnort.conf \"MAX_STRING_LEN\", so that the size of\n      the content can be limited. If the content (null terminated string) is\n      more than MAX_STRING_LEN chars, fwsnort throws the rule away.\n    - Bug fix to allow fwsnort to properly translate snort rules that have\n      \"content\" fields with embedded escaped semicolons (e.g. \"\\;\").  This\n      allows fwsnort to translate about 58 additional rules from the Emerging\n      Threats rule set.\n    - Bug fix to allow case insensitive matches to work properly with the\n      --include-re-caseless and --exclude-re-caseless arguments.\n    - Bug fix to move the 'rawbytes' keyword to the list of keywords that are\n      ignored since iptables does a raw match anyway as it doesn't run any\n      preprocessors in the Snort sense.\n    - Added the --snort-rfile argument so that a specific Snort rules file (or\n      list of files separated by commas) is parsed.\n    - Added a small hack to choose the first port from a port list until the\n      iptables 'multiport' match is supported.\n    - Updated to consolidate spaces in hex matches in the fwsnort.sh script\n      since the spaces are not part of patterns to be searched anyway.\n    - Updated to the latest complete rule set from Emerging Threats (see\n      http://www.emergingthreats.net/).\n    - Added the \"fwsnort-nobuildreqs.spec\" file for building fwsnort on\n      systems (such as Debian) that do not install/upgrade software via RPM.\n      This file omits the \"BuildRequires: perl-ExtUtils-MakeMaker\" directive,\n      and this fixes errors like the following on an Ubuntu system when\n      building fwsnort with rpmbuild:\n\n      rpm: To install rpm packages on Debian systems, use alien. See README.Debian.\n      error: cannot open Packages index using db3 - No such file or directory (2)\n      error: cannot open Packages database in /var/lib/rpm\n\nfwsnort-1.0.5 (08/21/2008):\n    - Replaced the bleeding-all.rules file with the emerging-all.rules file.\n      This is because Matt Jonkman now releases his rule sets at\n      http://www.emergingthreats.net/\n    - Restructured perl module paths to make it easy to introduce a \"nodeps\"\n      distribution of fwsnort that does not contain any perl modules.  This\n      allows better integration with systems that already have all necessary\n      modules installed (including the IPTables::ChainMgr and IPTables::Parse\n      modules).  The main driver for this work is to make all cipherdyne.org\n      projects easily integrated with distributions based on Debian, and\n      Franck Joncourt has been instrumental in making this process a reality.\n      All perl modules are now placed within the \"deps\" directory, and the\n      install.pl script checks to see if this directory exists - a separate\n      fwsnort-nodeps-<ver> tarball will be distributed without this directory.\n      The Debian package for fwsnort can then reference the -nodeps tarball,\n      and a new \"fwsnort-nodeps.spec\" file has been added to build an RPM from\n      the fwsnort sources that does not install any perl modules.\n    - Updated to import perl modules from /usr/lib/fwsnort, but only if this\n      path actually exists in the filesystem.  This is similar to the strategy\n      implemented by psad.  A new variable FWSNORT_LIBS_DIR was added to the\n      fwsnort.conf to support this.\n    - Added support for multiple Snort rule directories as a comma-separated\n      list for the argument to --snort-rdir.\n    - Moved 'threshold' to the unsupported list since there will be several\n      signatures that use this feature to detect the Dan Kaminsky DNS attack,\n      and fwsnort does not yet support the usage of the iptables --limit\n      match.\n\nfwsnort-1.0.4 (01/22/2008):\n    - (Grant Ferley) Submitted patch to exclude loopback interfaces from\n      iptables allow rules parsing.  This behavior can be reversed with the\n      existing --no-exclude-loopback command line argument.\n    - (Grant Ferley) Submitted patch to IPTables::Parse to take into account\n      iptables policy output that contains \"0\" instead of \"all\" to represent\n      any protocol.\n    - (Grant Ferley) Submitted patch to IPTables::Parse to set sport and dport\n      to '0:0' if the protocol is 'all'.\n    - Bugfix to allow negated networks to be specified within iptables allow\n      rules or within the fwsnort.conf file.\n    - Updated install.pl to set the LC_ALL environmental variable to \"C\". This\n      should fix potential locale problems (this fix was borrowed from the\n      fwknop project).\n\nfwsnort-1.0.3 (11/22/2007):\n    - Added --include-re-caseless and --exclude-re-caseless options to have\n      --include-regex and --exclude-regex options match case insensitively.\n    - Major signature update from Bleeding Threats. This update includes a\n      large number of new signatures with PCRE statements, with an emphasis on\n      detecting SQL injection attacks directed at internal webservers from\n      external sources.\n    - Added the ability to interpret PCRE statements that include simple\n      string matches separated by \".*\" and \".+\" as multiple iptables string\n      matches. The only negative consequence in terms of signature detection\n      is that ordering is not preserved; that is, the PCRE \"/UNION.+SELECT/\"\n      would only match a packet that contains \"UNION\" followed by \"SELECT\",\n      whereas an iptables rule that uses a string match for UNION and a\n      separate string match for SELECT would match a packet that contains both\n      strings but in reverse. Typically this is not a huge concern, and the\n      PCRE translation can be disabled with a new option --no-pcre.\n    - Added asn1 keyword to unsupported list.\n\nfwsnort-1.0.2 (08/26/2007):\n    - Bugfix to make sure to add in header lengths for depth and offset values\n      since the string match extension compares bytes from the start of the\n      data link header.\n\nfwsnort-1.0.1 (08/26/2007):\n    - Bugfix for ipt_rule_test() function name.\n    - Added the ability to automatically resolve command paths if any commands\n      cannot be found at the locations specified in the fwsnort.conf file.\n\nfwsnort-1.0 (04/19/2007):\n    - Major update to include support for the NFQUEUE and QUEUE targets with\n      new command line options --NFQUEUE and --QUEUE.  This changes the\n      default LOG target to the NFQUEUE or QUEUE targets instead, and at the\n      same time builds a parallel Snort rule set in the\n      /etc/fwsnort/snort_rules_queue directory.  Every Snort rule in this\n      directory has at least one \"content\" keyword, which fwsnort uses in the\n      resulting iptables policy.  This policy only sends those packets to\n      snort_inline via the NFQUEUE or QUEUE target that match a content field\n      within some Snort rule.  The end result is that snort_inline should run\n      faster because the vast majority of packets (which are not malicious)\n      are processed via the Linux kernel without ever having to be sent to\n      userspace for analysis.  There is a tradeoff here in terms of attack\n      detection; snort_inline does not receive all packets associated with a\n      stream, so it cannot detect attacks quite as effectively (snort_inline\n      does not have an opportunity to look at reassembled buffers).  However,\n      this trade off may be acceptable for large sites where performance is\n      more important.\n    - Bug fix to remove any existing jump rules from the built-in INPUT,\n      OUTPUT, and FORWARD chains before creating a new jump rules.  This\n      allows the fwsnort.sh script to be executed multiple times without\n      creating a new jump rule into the fwsnort chains for each execution.\n    - Added the -X command line argument to allow fwsnort to delete all of\n      the fwsnort chains; this emulates the iptables command line argument\n      of the same name.\n    - Minor output enhancements and bugfixes to give more insight into the\n      translation process.  For example, if fwsnort is run in --snort-sid\n      mode but is unable to translate the specified signatures, the user is\n      notified.  Also, any existing /etc/fwsnort/fwsnort.sh script is not\n      archived and erased until fwsnort is actually going to write a new one.\n    - Added sid values to iptables comment match string.\n    - Bugfix for iptables string match --from and --to values to skip past\n      packet headers.  This is an approximation until a new --payload option\n      can be added to the string match extension.\n    - Added a single iptables rule testing API internally within fwsnort;\n      this adds a measure of consistency and removes some duplicate code.\n    - Added fwsnort mailing list at SourceForge.\n\nfwsnort-0.9.0 (03/22/2007):\n    - Added support for multiple content matches since this is supported by\n      iptables.  This made a 10% increase in the fwsnort translation rate -\n      about 60% of all Snort-2.3.3 rules can be translated now.\n    - Added emulation for distance and within from previous content match\n      based on --from and --to (string match extension) and the length of\n      the previous pattern.\n    - Added the ability to include the Snort \"msg\", \"classtype\", \"reference\",\n      \"priority\", and \"rev\" fields in each iptables rule with the comment\n      match.  This can be disabled with a new command line argument\n      --no-ipt-comments.  The fwsnort version is also included within this\n      string.\n    - Added the ability to include the iptables rule number for each rule in\n      the fwsnort chains.  This is useful to easily know which iptables rule\n      is being triggered by network traffic (so it can be disabled if\n      necessary).  This can be disabled with --no-ipt-rule-nums.\n    - Added the --include-regex and --exclude-regex command line arguments.\n      These arguments allow rules to be included/excluded based on a regular\n      expression supplied on the command line.\n    - Updated to include the original Snort rule as a comment within the\n      fwsnort.sh script without having to use --verbose.\n    - Bugfix to force install of IPTables::Parse since it had been updated in\n      the fwsnort-0.8.2 release.\n    - Changed the IGNORE_ADDR variable to WHITELIST since this name better\n      describes the actual function of this var.  Updated to allow multiple\n      WHITELIST lines.\n    - Added the BLACKLIST variable to allow a true blacklist to be\n      instantiated with either the DROP or REJECT targets.  The syntax for the\n      BLACKLIST variable is \"BLACKLIST  <ip or network>  <target>\", where\n      \"target\" is either \"DROP\" or \"REJECT\".\n    - Added -F and -L command line arguments to flush and list iptables rules.\n      This is similar to the iptables command line args of the same names.\n    - Bugfix to ensure that traffic directed into the INPUT or coming from the\n      OUTPUT chains is treated as going toward or originating from the\n      HOME_NET.  After all the HOME_NET variable may contain an internal\n      network but omit the IP assigned to an external interface on the\n      firewall.\n    - Added \"--log-ip-options\" and \"--log-tcp-options\" to fwsnort LOG rules by\n      default (in the generated fwsnort.sh script).  This can be disabled with\n      --no-log-ip-opts and --no-log-tcp-opts arguments on the fwsnort command\n      line.\n    - Added the ability to include --log-tcp-sequence to LOG rules in\n      fwsnort.sh with a new argument --ipt-log-tcp-seq on the fwsnort command\n      line.\n    - Updated to handle negative string matches with \"--string ! <string>\".\n    - Updated to output all unsupported options of the /var/log/fwsnort.log\n      file to assist in the development of addition keyword emulation.\n\nfwsnort-0.8.2 (02/17/2007):\n    - Updated to newer IPTables::Parse module that uses the array of hash\n      references method of returning iptables policy data.\n    - Added --Dump-ipt and --Dump-snort rules to allow iptables policy and\n      Snort rules to be dumped to STDOUT.\n    - Added bleeding-all.rules file from http://www.bleedingsnort.com/\n    - Added patches/bm_goodshift_fix.patch patch file that fixes an\n      initialization bug in the Boyer-Moore text search implementation in the\n      kernel (linux-2.6.x/lib/ts_bm.c) which caused slightly repetitive\n      patterns to only match at specific offsets with the string match\n      extension.\n    - Bugfix to ensure that a depth cannot be less that an offset (these\n      translate to the --to and --from command line arguments to iptables).\n    - Bugfix to escape '$' chars in iptables search strings.\n    - Added cd_rpmbuilder to make it easy to automatically build RPM files of\n      fwsnort.\n    - Added support for the iptables OUTPUT chain.\n    - Added the ChangeLog.svn file so that all of the changed files and\n      corresponding svn commit messages can be viewed (this file is built from\n      release to release).\n\nfwsnort-0.8.1 (11/11/2005):\n    - Updated to use the string match extension \"--algo bm\" argument if\n      fwsnort is being run on a 2.6.14 (or greater) kernel.\n    - Updated to handle the Snort \"offset\" and \"depth\" keywords via the\n      --from and --to options to the string match extension in the 2.6.14\n      kernel.\n    - Created RPM package of fwsnort.\n    - Minor man page updates.\n\nfwsnort-0.8.0 (07/11/2005):\n    - Completely re-structured fwsnort w.r.t. how it creates Netfilter\n      chains.  There are no longer any per-interface chains (this\n      greatly simplifies the Netfilter chains).\n    - Added three new chains \"FWSNORT_INPUT_ESTAB\", \"FWSNORT_OUTPUT_ESTAB\"\n      and \"FWSNORT_FORWARD_ESTAB\" to which tcp connections in the\n      ESTABLISHED state are jumped.  This allows fwsnort to use the\n      Netfilter tcp connection tracking mechanism to ignore Stick and Snot\n      style attacks (similar to the flow:established Snort rule option).\n    - Added true variable resolution (i.e. HTTP_SERVERS -> HOME_NET -> any)\n      for the Snort rule header.  This directly emulates the behavior of\n      the Snort IDS.\n    - Added IP protocol support in the translation of the Snort rule\n      header.  The Snort rule translation rate is now at about 53% for\n      Snort-2.3.\n    - Bugfix for ipopts Snort option (several arguments are not supported\n      by the ipv4options extension).\n    - Better tests for Netfiler TTL, TOS, and ipv4options matches.\n    - Replaced IGNORE_IP and IGNORE_NET keywords with single IGNORE_ADDR\n      keywork in fwsnort.conf.\n    - Updated to correctly handle ICMP type and code rules (itype and\n      icode Snort options) via the \"--icmp-types type/code\" convention.\n    - Added support for emulating the dsize Snort option through the use\n      of the Netfilter length match.\n    - Changed --type argument to --include-types and added list support\n      so it accepts things like \"chat,ddos\".  Also added --exclude-types\n      command line argument.\n    - Added support for multiple sid's (as a comma separated list) in\n      --snort-sids argument.  Also added --exclude-sids argument to remove\n      a list of sids from translation.\n    - Added support for the replace Snort option (originally from the\n      Snort_inline project).  The requires the replace string patch.\n    - Added support for restricting jump rules to a list of interfaces\n      via the --restrict-intf argument.\n    - Added kernel patch to extend the maximum packet length that the\n      string match extension will attempt to search from 1024 bytes to\n      2048 bytes (requires a kernel re-compile of course).\n    - Added DRP and REJ strings to logging prefix if --ipt-drop or\n      --ipt-reject is specified.\n    - Added snortspoof.pl, which is a simple perl script that emulates\n      the Stick and Snot tools.\n\nfwsnort-0.7.0 (06/05/2005):\n    - Added support for the Snort pass action by using the ACCEPT target.\n    - Added support for the Snort log action by using the ULOG target\n      (which can then log the packet via the pcap writer).\n    - Added support for all fwsnort alerts to be logged via the ULOG\n      target instead of the LOG target.\n    - Added support for the \"resp\" keyword to allow it to drive the\n      Netfilter argument to the REJECT target.\n    - Added \"pcre\" to the unsupported list... this knocks the fwsnort\n      translation rate down to about 50% for Snort-2.3 rules (pcre is\n      heavily utilized).\n    - Added \"priority\" and \"rev\" to comment lines.\n\nfwsnort-0.6.5 (03/20/2005):\n    - Updated to not attempt to download Snort rules from snort.org\n      because the rules are no longer available for automatic downloads\n    - Changed the install.pl script and the --update-rules mode for\n      fwsnort to download the latest signature set from\n      http://www.bleedingsnort.com/.\n      (Snort.org is now offering pay-service around their rule sets).\n    - Added signature test for the \"flowbits\" keyword.\n\nfwsnort-0.6.4 (12/18/2004):\n    - Updated to Snort-2.3 rules.  FWSnort can convert a total of 1710\n      out of 2559 total Snort-2.3 rules.\n    - Updated to new Snort rules download link for --update-rules mode:\n      http://www.snort.org/dl/rules/snortrules-snapshot-CURRENT.tar.gz\n    - Updated to standard [+], [-], and [*] prefixes for info, warning\n      and die logging messages.\n    - Added --replace-string patches.\n\nfwsnort-0.6.3 (04/04/2004):\n    - Added ignore functionality for both IPs and networks\n    - Split --ipt-block into --ipt-drop and --ipt-reject to add DROP\n      or REJECT rules respectively.\n    - Added --add-deleted option to allow rules in the \"deleted.rules\"\n      file to be added.\n\nfwsnort-0.6.2 (03/19/2004):\n    - Added --internal-net and --dmz-net options so that internal and\n      dmz networks can be manually specified without having to parse\n      the output of ifconfig.  This is most useful for running fwsnort\n      on a linux system that is acting as a bridge where no ip addresses\n      are assigned to the interfaces.\n    - Bugfix for missing icmp-port-unreachable rejects for UDP packets.\n\nfwsnort-0.6.1 (02/01/2004):\n    - Bugfix for not adding dmz interface rules to INPUT chain.\n    - Bugfix for not getting the DMZ interface network.\n\nfwsnort-0.6 (01/04/2004):\n    - Speed increase and disk access decrease by writing iptables\n      commands to the iptables script only after all lines have been\n      generated.\n    - Bugfix for DMZ interface.\n    - Bugfix for multiple ip_proto fields.\n    - Removed the ip protocol as an allowed protocol for translation.\n    - Bugfix for negated port numbers.\n    - Removed \"<-\" rule direction since not even snort supports this.\n    - Fixed snort rule updates from snort.org.\n\nfwsnort-0.5 (12/21/2003):\n    - Added \"-j REJECT --reject-with tcp-reset\" for tcp sessions\n      if the --ipt-block option is specified.\n    - Added ability to download latest snort rules from snort.org.\n    - Added --no-ipt-jumps.\n    - Added better checking for iptables build characteristics such\n      as the LOG target and wether or not the ipv4options extension\n      is compiled in.\n    - Added config preservation code from psad in install.pl.\n", "#!/usr/bin/perl -w\n#\n###############################################################################\n#\n# File: fwsnort\n#\n# URL: http://www.cipherdyne.org/fwsnort/\n#\n# Purpose: To translate snort rules into equivalent iptables rules.\n#          fwsnort is based on the original snort2iptables shell script\n#          written by William Stearns.\n#\n# Author: Michael Rash <mbr@cipherdyne.org>\n#\n# Credits: (see the CREDITS file)\n#\n# Version: 1.6.3\n#\n# Copyright (C) 2003-2012 Michael Rash (mbr@cipherdyne.org)\n#\n# License - GNU Public License version 2 (GPLv2):\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program; if not, write to the Free Software\n#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301\n#    USA\n#\n# TODO:\n#   - Add the ability to remove rules from a real snort config in the same\n#     way we remove them from iptables rulesets in fwsnort (we remove rules\n#     from an iptables ruleset if the iptables policy will not allow such\n#     traffic through in the first place).\n#   - New option: --ipt-mark.\n#\n# Reference: Snort is a registered trademark of Sourcefire, Inc\n#\n# Snort Rule Options:\n#\n#   msg:           Prints a message in alerts and packet logs.\n#   logto:         Log the packet to a user specified filename instead of the\n#                  standard output file.\n#   ttl:           Test the IP header's TTL field value.\n#   tos:           Test the IP header's TOS field value.\n#   id:            Test the IP header's fragment ID field for a specific\n#                  value.\n#   ipoption:      Watch the IP option fields for specific codes.\n#   fragbits:      Test the fragmentation bits of the IP header.\n#   dsize:         Test the packet's payload size against a value.\n#   flags          Test the TCP flags for certain values.\n#   seq:           Test the TCP sequence number field for a specific value.\n#   ack:           Test the TCP acknowledgement field for a specific value.\n#   itype:         Test the ICMP type field against a specific value.\n#   icode:         Test the ICMP code field against a specific value.\n#   icmp_id:       Test the ICMP ECHO ID field against a specific value.\n#   icmp_seq:      Test the ICMP ECHO sequence number against a specific\n#                  value.\n#   content:       Search for a pattern in the packet's payload.\n#   content-list:  Search for a set of patterns in the packet's payload.\n#   offset:        Modifier for the content option, sets the offset to begin\n#                  attempting a pattern match.\n#   depth:         Modifier for the content option, sets the maximum search\n#                  depth for a pattern match attempt.\n#   nocase:        Match the preceding content string with case insensitivity.\n#   session        Dumps the application layer information for a given\n#                  session.\n#   rpc:           Watch RPC services for specific application/procedure\n#                  calls.\n#   resp:          Active response (knock down connections, etc).\n#   react:         Active response (block web sites).\n#   reference:     External attack reference ids.\n#   sid:           snort rule id.\n#   rev:           Rule revision number.\n#   classtype:     Rule classification identifier.\n#   priority:      Rule severity identifier.\n#   uricontent:    Search for a pattern in the URI portion of a packet\n#\n#   tag:           Advanced logging actions for rules.\n#   ip_proto:      IP header's protocol value.\n#   sameip:        Determines if source ip equals the destination ip.\n#   stateless:     Valid regardless of stream state.\n#   regex:         Wildcard pattern matching.\n#\n############################################################################\n#\n\nuse IO::Socket;\nuse File::Copy;\nuse File::Path;\nuse Sys::Hostname;\nuse Data::Dumper;\nuse Cwd;\nuse Getopt::Long;\nuse strict;\n\n### config file\nmy $CONFIG_DEFAULT = '/etc/fwsnort/fwsnort.conf';\nmy $fwsnort_conf = $CONFIG_DEFAULT;\n\n### version number\nmy $version = '1.6.3';\n\nmy %ipt_hdr_opts = (\n    'src'      => '-s',\n    'sport'    => '--sport',\n    'dst'      => '-d',\n    'dport'    => '--dport',\n    'proto'    => '-p',\n);\n\nmy %snort_opts = (\n    ### snort options that we can directly filter on\n    ### in iptables rulesets (snort options are separate\n    ### from the snort \"header\" which include protocol,\n    ### source, destination, etc.)\n    'filter' => {\n\n        ### application layer\n        'uricontent' => {  ### use --strict to not translate this\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]uricontent:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'content' => {\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]content:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'fast_pattern' => {\n            'iptopt' => '',  ### fast_pattern just governs ordering of\n                             ### content matches\n            'regex'  => qr/[\\s;]fast_pattern(?::\\s*.*?\\s*)?;/,\n        },\n        'pcre' => {\n            ### only basic PCRE's that just have strings separated\n            ### by \".*\" or \".+\" are supported.\n            'iptopt' => '-m string',\n            'regex'  => qr/[\\s;]pcre:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'nocase'  => {\n            'iptopt' => '--icase',\n            'regex'  => qr/[\\s;]nocase\\s*;/,\n        },\n        'offset'  => {\n            'iptopt' => '--from',\n            'regex'  => qr/[\\s;]offset:\\s*(\\d+)\\s*;/\n        },\n        'depth' =>  {\n            'iptopt' => '--to',\n            'regex'  => qr/[\\s;]depth:\\s*(\\d+)\\s*;/\n        },\n\n        ### technically, the \"distance\" and \"within\" criteria\n        ### are relative to the end of the previous pattern match,\n        ### so iptables cannot emulate these directly; an approximation\n        ### is made based on the on length of the previous pattern an\n        ### any \"depth\" or \"offset\" criteria for the previous pattern.\n        ### To disable signatures with \"distance\" and \"within\", just\n        ### use the --strict option.\n        'distance'  => {\n            'iptopt' => '--from',\n            'regex'  => qr/[\\s;]distance:\\s*(\\d+)\\s*;/\n        },\n        'within' =>  {\n            'iptopt' => '--to',\n            'regex'  => qr/[\\s;]within:\\s*(\\d+)\\s*;/\n        },\n        'replace' => {  ### for Snort running in inline mode\n            'iptopt' => '--replace-string',\n            'regex'  => qr/[\\s;]replace:\\s*\\\"(.*?)\\\"\\s*;/\n        },\n        'resp' => {\n            'iptopt' => '-j REJECT',\n            'regex'  => qr/[\\s;]resp:\\s*(.*?)\\s*;/\n        },\n\n        ### transport layer\n        'flags' => {\n            'iptopt' => '--tcp-flags',\n            'regex'  => qr/[\\s;]flags:\\s*(.*?)\\s*;/\n        },\n        'flow' => {\n            'iptopt' => '--tcp-flags',\n            'regex'  => qr/[\\s;]flow:\\s*(.*?)\\s*;/\n        },\n\n        ### network layer\n        'itype' => {\n            'iptopt' => '--icmp-type',  ### --icmp-type type/code\n            'regex'  => qr/[\\s;]itype:\\s*(.*?)\\s*;/\n        },\n        'icode' => {\n            'iptopt' => 'NONE',\n            'regex'  => qr/[\\s;]icode:\\s*(.*?)\\s*;/\n        },\n        'ttl' => {\n            'iptopt' => '-m ttl', ### requires CONFIG_IP_NF_MATCH_TTL\n            'regex'  => qr/[\\s;]ttl:\\s*(.*?)\\s*;/\n        },\n        'tos' => {\n            'iptopt' => '-m tos --tos', ### requires CONFIG_IP_NF_MATCH_TOS\n            'regex'  => qr/[\\s;]tos:\\s*(\\d+)\\s*;/\n        },\n        'ipopts' => {\n            'iptopt' => '-m ipv4options',  ### requires ipv4options extension\n            'regex'  => qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/\n        },\n        'ip_proto' => {\n            'iptopt' => '-p',\n            'regex'  => qr/[\\s;]ip_proto:\\s*(.*?)\\s*;/\n        },\n        'dsize' => {  ### requires CONFIG_IP_NF_MATCH_LENGTH\n            'iptopt' => '-m length --length',\n            'regex'  => qr/[\\s;]dsize:\\s*(.*?)\\s*;/\n        },\n    },\n\n    ### snort options that can be put into iptables\n    ### ruleset, but only in log messages with --log-prefix\n    'logprefix' =>  {\n        'sid'       => qr/[\\s;]sid:\\s*(\\d+)\\s*;/,\n        'msg'       => qr/[\\s;]msg:\\s*\\\"(.*?)\\\"\\s*;/,  ### we create a space\n        'classtype' => qr/[\\s;]classtype:\\s*(.*?)\\s*;/,\n        'reference' => qr/[\\s;]reference:\\s*(.*?)\\s*;/,\n        'priority'  => qr/[\\s;]priority:\\s*(\\d+)\\s*;/,\n        'rev'       => qr/[\\s;]rev:\\s*(\\d+)\\s*;/,\n    },\n\n    ### snort options that cannot be included directly\n    ### within iptables filter statements (yet :)\n    'unsupported' => {\n        'asn1'         => qr/[\\s;]asn1:\\s*.*?\\s*;/,\n        'fragbits'     => qr/[\\s;]fragbits:\\s*.*?\\s*;/,\n        'content-list' => qr/[\\s;]content\\-list:\\s*\\\".*?\\\"\\s*;/,\n        'rpc'          => qr/[\\s;]rpc:\\s*.*?\\s*;/,\n        'byte_test'    => qr/[\\s;]byte_test\\s*.*?\\s*;/,\n        'byte_jump'    => qr/[\\s;]byte_jump\\s*.*?\\s*;/,\n        'byte_extract' => qr/[\\s;]byte_extract\\s*.*?\\s*;/,\n        'file_data'    => qr/[\\s;]file_data\\s*;/,\n        'window'       => qr/[\\s;]window:\\s*.*?\\s*;/,\n        'flowbits'     => qr/[\\s;]flowbits:\\s*.*?\\s*;/,\n        'tag'          => qr/[\\s;]tag:\\s*.*?\\s*;/,\n        'ftpbounce'    => qr/[\\s;]ftpbounce\\s*;/,\n        'base64_data'  => qr/[\\s;]base64_data\\s*;/,\n        'base64_decode' => qr/[\\s;]base64_decode:\\s*.*?\\s*;/,\n#        'offset'       => qr/[\\s;]offset:\\s*\\d+\\s*;/,\n#        'depth'        => qr/[\\s;]depth:\\s*\\d+\\s*;/,\n\n        ### the following fields get logged by iptables but\n        ### we cannot filter them directly except with the\n        ### iptables u32 module.  Functionality has been built\n        ### into psad to generate alerts for most of these Snort\n        ### options.\n        'id'        => qr/[\\s;]id:\\s*(\\d+)\\s*;/,\n        'seq'       => qr/[\\s;]seq:\\s*(\\d+)\\s*;/,  ### --log-tcp-sequence\n        'ack'       => qr/[\\s;]ack:\\s*.*?\\s*;/,    ### --log-tcp-sequence\n        'icmp_seq'  => qr/[\\s;]icmp_seq:\\s*(\\d+)\\s*;/,\n        'icmp_id'   => qr/[\\s;]icmp_id:\\s*(\\d+)\\s*;/,\n        'sameip'    => qr/[\\s;]sameip\\s*;/,\n        'regex'     => qr/[\\s;]regex:\\s*(.*?)\\s*;/,\n        'isdataat'  => qr/[\\s;]isdataat:\\s*(.*?)\\s*;/,\n        'threshold' => qr/[\\s;]threshold:\\s*.*?\\s*;/,               ### FIXME --limit\n        'detection_filter' => qr/[\\s;]detection_filter:\\s*.*?\\s*;/  ### FIXME --limit\n    },\n\n    ### snort options that fwsnort will ignore\n    'ignore' => {\n        'rawbytes' => qr/[\\s;]rawbytes\\s*;/,  ### iptables does a raw match anyway\n        'logto'    => qr/[\\s;]logto:\\s*\\S+\\s*;/,\n        'session'  => qr/[\\s;]session\\s*;/,\n        'tag'      => qr/[\\s;]tag:\\s*.*?\\s*;/,\n        'react'    => qr/[\\s;]react:\\s*.*?\\s*;/, ### FIXME -j REJECT\n        'http_uri' => qr/[\\s;]http_uri\\s*;/,\n        'http_raw_uri' => qr/[\\s;]http_raw_uri\\s*;/,\n        'http_method' => qr/[\\s;]http_method\\s*;/,\n        'http_stat_code' => qr/[\\s;]http_stat_code\\s*;/,\n        'http_stat_msg' => qr/[\\s;]http_stat_msg\\s*;/,\n        'http_client_body' => qr/[\\s;]http_client_body\\s*;/,\n        'http_cookie' => qr/[\\s;]http_cookie\\s*;/,\n        'urilen'    => qr/[\\s;]urilen:\\s*.*?\\s*;/,\n    },\n\n    ### in --strict mode, signatures that include any of these\n    ### options are not translated to iptables rules\n    'strict_list' => [\n        'uricontent',\n        'pcre',\n        'distance',\n        'within',\n        'http_uri',\n        'http_raw_uri',\n        'http_method',\n        'http_stat_code',\n        'http_stat_msg',\n        'http_client_body',\n        'http_cookie',\n        'urilen'\n    ]\n);\n\n### rules update link\nmy $DEFAULT_RULES_URL = 'http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules';\nmy $rules_url = $DEFAULT_RULES_URL;\n\n### config vars that may span multiple lines\nmy %multi_line_vars = (\n    'UPDATE_RULES_URL' => '',\n    'WHITELIST' => '',\n    'BLACKLIST' => '',\n);\n\n### array that contains the fwsnort iptables script (will be written\n### to $config{'FWSNORT_SCRIPT'})\nmy @ipt_script_lines = ();\n\n### array that contains the fwsnort policy in iptables-save format.\n### This will also contain the running iptables policy, so the fwsnort\n### policy is integrated in.\nmy @fwsnort_save_lines = ();\nmy @ipt_save_lines     = ();\nmy $ipt_save_index     = 0;\nmy @ipt_save_script_lines = ();\nmy $ipt_save_completed_line = '';\nmy $save_str    = 'iptables-save';\nmy $ipt_str     = 'iptables';\nmy $save_bin    = '';\nmy $restore_bin = '';\nmy $ipt_bin     = '';\n\n### contains a cache of the iptables policy\nmy %ipt_policy = ();\nmy %ipt_default_policy_setting = ();\nmy %ipt_default_drop = ();\nmy %ipt_save_existing_chains = ();\n\n### hashes for save format data\nmy %save_format_whitelist = ();\nmy %save_format_blacklist = ();\nmy %save_format_prereqs   = ();\nmy %save_format_rules     = ();\nmy %save_format_conntrack_jumps = ();\n\n### regex to match ip addresses\nmy $ip_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\nmy %snort_dump_cache = ();\nmy %ipt_dump_cache = ();\n\n### for iptables capabilities testing\nmy $NON_HOST     = '127.0.0.2';\nmy $NON_IP6_HOST = '::2/128';\nmy $non_host     = '';\n\nmy $IPT_SUCCESS = 1;\nmy $IPT_FAILURE = 0;\nmy $IPT_TEST_RULE_NUM = 1;\n\nmy $MATCH_EQUIV  = 1;\nmy $MATCH_SUBSTR = 2;\n\n### header lengths; note that IP and TCP lengths are defined\n### in the fwsnort.conf file since they may each contain options,\n### but until the --payload option is added to the string match\n### extension there is no way to account for them except to\n### define an average length.\nmy $MAC_HDR_LEN = 14;\nmy $UDP_HDR_LEN = 8;\nmy $ICMP_HDR_LEN = 8;\n\n### config and commands hashes (constructed by import_config())\nmy %config = ();\nmy %cmds   = ();\n\nmy @local_addrs   = ();\nmy %include_types = ();\nmy %exclude_types = ();\nmy %include_sids  = ();\nmy %exclude_sids  = ();\nmy %restrict_interfaces = ();\n\n### establish some default behavior\nmy $home_net   = '';  ### normally comes from fwsnort.conf\nmy $ext_net    = '';  ### normally comes from fwsnort.conf\nmy $ipt_exec   = 0;\nmy $ipt_revert = 0;\nmy $ipt_drop   = 0;\nmy $ipt_reject = 0;\nmy $ipt_max_buf_len = 1025;\nmy $ipt_cap_search_factor = 128;\nmy $help       = 0;\nmy $stdout     = 0;\nmy $lib_dir    = '';\nmy $rules_file = '';\nmy $debug      = 0;\nmy $is_root    = 0;\nmy $dumper     = 0;\nmy $dump_ipt   = 0;\nmy $dump_snort = 0;\nmy $strict     = 0;\nmy $ipt_script = '';\nmy $logfile    = '';\nmy $rules_dir  = '';\nmy $homedir    = '';\nmy $abs_num    = 0;\nmy $run_last   = 0;\nmy $queue_rules_dir = '';\nmy $queue_pre_match_max = 0;\nmy $dump_conf  = 0;\nmy $kernel_ver = '2.6';  ### default\nmy $string_match_alg = 'bm';\nmy $verbose    = 0;\nmy $print_ver  = 0;\nmy $cmdl_homedir   = '';\nmy $update_rules   = 0;  ### used to download latest snort rules\nmy $default_icmp_type = 8;  ### echo request\nmy $ipt_print_type = 0;\nmy $ipt_check_capabilities = 0;\nmy $ipt_rule_ctr   = 1;\nmy $ipt_sync       = 0;\nmy $ipt_flush      = 0;\nmy $ipt_del_chains = 0;\nmy $ipt_list       = 0;\nmy $ipt_file       = '';\nmy $no_pcre        = 0;\nmy $no_ipt_log     = 0;\nmy $no_ipt_test    = 0;\nmy $no_ipt_jumps   = 0;\nmy $no_ipt_input   = 0;\nmy $no_ipt_output  = 0;\nmy $no_addr_check  = 0;\nmy $no_ipt_forward = 0;\nmy $ignore_opt     = 0;\nmy $include_sids   = '';\nmy $exclude_sids   = '';\nmy $add_deleted    = 0;\nmy $rules_types    = '';\nmy $exclude_types  = '';\nmy $snort_type     = '';\nmy $ulog_nlgroup   = 1;\nmy $queue_mode     = 0;\nmy $nfqueue_mode   = 0;\nmy $nfqueue_num    = 0;\nmy $ulog_mode      = 0;\nmy $exclude_re     = '';\nmy $include_re     = '';\nmy $include_re_caseless = 0;\nmy $exclude_re_caseless = 0;\nmy $enable_ip6tables  = 0;\nmy $ipt_var_str       = 'IPTABLES';\nmy $no_ipt_conntrack  = 0;\nmy $conntrack_state   = 'ESTABLISHED';\nmy $have_conntrack    = 0;\nmy $have_state        = 0;\nmy $snort_conf_file   = '';\nmy $ipt_restrict_intf = '';\nmy $no_ipt_comments  = 0;\nmy $no_ipt_rule_nums = 0;\nmy $no_exclude_loopback = 0;\nmy $no_ipt_log_ip_opts  = 0;\nmy $no_ipt_log_tcp_opts = 0;\nmy $ipt_log_tcp_seq     = 0;\nmy $include_perl_triggers = 0;\nmy $duplicate_last_build  = 0;\nmy $ipt_max_str_len = 1;\nmy $ipt_max_log_prefix_len = 1;\nmy $ipt_max_comment_len = 1;\nmy $no_fast_pattern_order = 0;\nmy $ipt_have_multiport_match = 0;\nmy $ipt_multiport_max = 2;\n\n### to be added to the string match extension\nmy $ipt_has_string_payload_offset_opt = 0;\n\n### default to processing these filter chains\nmy %process_chains = (\n    'INPUT'   => 1,\n    'FORWARD' => 1,\n    'OUTPUT'  => 1,\n);\nmy $TEST_CHAIN = 'FWS_CAP_TEST';\n\nmy %chain_ctr = ();\n\n### save a copy of the command line args\nmy @argv_cp = @ARGV;\n\n### see if we are running as root\n&is_root();\n\n### handle the command line args\n&handle_cmd_line();\n\n&run_last_cmdline() if $run_last;\n\n### import config, initialize various things, etc.\n&fwsnort_init();\n\n### if we are running with $chk_ipt_policy, then cache\n### the current iptables policy\n&cache_ipt_policy() if $ipt_sync;\n\n### truncate old fwsnort log\n&truncate_logfile();\n\n### check to make sure iptables has various functionality available\n### such as the LOG target, --hex-strings, the comment match, etc.\nif ($no_ipt_test) {\n    &set_defaults_without_ipt_test();\n} else {\n    &ipt_capabilities();\n}\n\n### cache the running iptables policy in iptables-save format\n&cache_ipt_save_policy();\n\n### print a header at the top of the iptables ruleset\n### script\n&ipt_hdr();\n\n### now that we have the interfaces, add the iptables\n### chains to the fwsnort shell script\n&ipt_add_chains();\n\n### add any WHITELIST rules to the main fwsnort chains\n### with the RETURN target\n&ipt_whitelist();\n\n### add any BLACKLIST rules to the main fwsnort chains\n### with the DROP or REJECT targets\n&ipt_blacklist();\n\n### add jump rules for established tcp connections to\n### the fwsnort state tracking chains\n&ipt_add_conntrack_jumps() unless $no_ipt_conntrack;\n\n### display the config on STDOUT\n&dump_conf() if $dump_conf;\n\n### make sure <type>.rules file exists if --type was\n### specified on the command line\n&check_type() if $rules_types;\n\n&logr(\"[+] Begin parsing cycle.\");\n\n### parse snort rules (signatures)\nif ($include_sids) {\n    print \"[+] Parsing Snort rules files...\\n\";\n} else {\n    if ($ipt_sync) {\n        print \"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\",\n            \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\",\n            sprintf(\"%-30s%-10s%-10s%-10s%-10s\", '    Snort Rules File',\n                'Success', 'Fail', 'Ipt_apply', 'Total'), \"\\n\\n\";\n    } else {\n        print \"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\",\n            \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\",\n            sprintf(\"%-30s%-10s%-10s%-10s\", '    Snort Rules File',\n                'Success', 'Fail', 'Total'), \"\\n\\n\";\n    }\n}\n\n### main subroutine to parse snort rules and add them to the\n### fwsnort.sh script.\n&parse_snort_rules();\n\n### append all translated rules to the iptables-save formatted array\n&save_format_append_rules();\n\n### jump packets (as appropriate) from the INPUT and\n### FORWARD chains to our fwsnort chains\n&ipt_jump_chain() unless $no_ipt_jumps;\n\npush @ipt_script_lines, qq|\\n\\$ECHO \"[+] Finished.\"|, '### EOF ###';\npush @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n\nprint \"\\n[+] Logfile: $config{'LOG_FILE'}\\n\";\n\nif ($ipt_rule_ctr > 1) {\n\n    ### write the iptables script out to disk\n    &write_ipt_script();\n\n    if ($queue_mode or $nfqueue_mode) {\n        print \"[+] Snort rule set directory for rules to be queued \",\n            \"to userspace:\\n        $config{'QUEUE_RULES_DIR'}\\n\";\n    }\n    print \"[+] $ipt_str script (individual commands): \" .\n        \"$config{'FWSNORT_SCRIPT'}\\n\";\n\n} else {\n    die \"[-] No Snort rules could be translated, exiting\\n\";\n}\n\n&write_save_file();\n\n&print_final_message();\n\nexit 0;\n#===================== end main ======================\n\nsub parse_snort_rules() {\n\n    my @rfiles = ();\n\n    my $cwd = cwd();\n\n    if ($rules_file) {\n        @rfiles = split /\\,/, $rules_file;\n    } else {\n        for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n            opendir D, $dir or die \"[*] Could not opendir $dir\";\n            for my $file (readdir D) {\n                push @rfiles, \"$dir/$file\";\n            }\n            closedir D;\n        }\n    }\n\n    my $sabs_num = 0;\n    my $tot_ipt_apply = 0;\n    my $tot_unsup_ctr = 0;\n    FILE: for my $rfile (sort @rfiles) {\n        $rfile = $cwd . '/' . $rfile unless $rfile =~ m|^/|;\n        my $type = '';\n        my $filename = '';\n        if ($rfile =~ m|.*/(\\S+\\.rules)$|) {\n            $filename = $1;\n        }\n        if ($rfile =~ m|.*/(\\S+)\\.rules$|) {\n            $type = $1;\n        } else {\n            next FILE;\n        }\n        $ipt_print_type = 0;\n        if ($rules_types) {\n            next FILE unless defined $include_types{$type};\n        }\n        if ($exclude_types) {\n            next FILE if defined $exclude_types{$type};\n        }\n        if ($rfile =~ m|deleted\\.rules|) {\n            next FILE unless $add_deleted;\n        }\n        ($snort_type) = ($rfile =~ m|.*/(\\S+)\\.rules|);\n        printf(\"%-30s\", \"[+] $filename\") unless $include_sids;\n\n        &logr(\"[+] Parsing $rfile\");\n        open R, \"< $rfile\" or die \"[*] Could not open: $rfile\";\n        my @lines = <R>;\n        close R;\n\n        ### contains Snort rules that will be used by Snort_inline\n        ### if fwsnort is building a QUEUE policy; these rules have\n        ### met the criteria that at least one \"content\" match is\n        ### required.\n        my @queue_rules = ();\n\n        my $line_num   = 0;\n        my $rule_num   = 0;\n        my $parsed_ctr = 0;\n        my $unsup_ctr  = 0;\n        my $ipt_apply_ctr = 0;\n        my $ipt_rules_ctr = 0;\n\n        RULE: for my $rule (@lines) {\n            chomp $rule;\n            my $rule_hdr;\n            my $rule_options;\n            $line_num++;\n\n            ### pass == ACCEPT, log == ULOG\n            unless ($rule =~ /^\\s*alert/ or $rule =~ /^\\s*pass/\n                    or $rule =~ /^\\s*log/) {\n                next RULE;\n            }\n\n            ### regex filters\n            if ($exclude_re) {\n                next RULE if $rule =~ $exclude_re;\n            }\n\n            if ($include_re) {\n                next RULE unless $rule =~ $include_re;\n            }\n\n            $rule_num++;  ### keep track of the abs num of rules\n            $sabs_num++;\n\n            if ($rule =~ m|^(.*?)\\s+\\((.*)\\)|) {\n                $rule_hdr     = $1;\n                $rule_options = \" $2 \";  ### allows out-of-order options\n            } else {\n                &logr(\"[-] Unrecognized rule format at line: $line_num. \" .\n                    \"Skipping.\");\n                next RULE;\n            }\n\n            ### skip all icmp \"Undefined Code\" rules; psad properly\n            ### handles this, but not fwsnort (see the icmp-info.rules\n            ### file).\n            if ($filename =~ /icmp/ and $rule_options =~ /undefined\\s+code/i) {\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n\n            ### parse header portion of Snort rule\n            my $hdr_hr = &parse_rule_hdr($rule_hdr, $line_num);\n            unless (keys %$hdr_hr) {\n                &logr(\"[-] Unrecognized rule header: \\\"$rule_hdr\\\" at \" .\n                    \"line: $line_num, skipping.\");\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n\n            ### parse options portion of Snort rule\n            my ($parse_rv, $opts_hr, $patterns_ar) = &parse_rule_options(\n                    $rule_options, &get_avg_hdr_len($hdr_hr), $line_num);\n\n            unless ($parse_rv) {\n                $unsup_ctr++;\n                $tot_unsup_ctr++;\n                next RULE;\n            }\n            if ($include_sids) {\n                print \"[+] Found sid: $opts_hr->{'sid'} in $filename\\n\";\n            }\n\n            if ($queue_mode or $nfqueue_mode) {\n\n                ### In general, it is not easy to modify the signatures that\n                ### snort_inline would use; one would think that an optimzation\n                ### would be to remove all \"content\" keywords since the kernel\n                ### itself is doing this now, but consider the following:\n\n                ### Suppose there are two original Snort signatures like so:\n                ###\n                ###     msg: \"SIG1\"; content: \"abc\"; pcre: \"(d|e)\";\n                ###     msg: \"SIG2\"; content: \"xyz\"; pcre: \"(e|f)\";\n                ###\n                ### Now, suppose there is a packet with the following data:\n                ###\n                ###     packet data: \"xyz------------e------\"\n                ###\n                ### Then the SIG1 matches when it shouldn't because the packet\n                ### does not contain \"abc\" (assuming the \"abc\" string is\n                ### removed from the signature that is actually deployed with\n                ### snort_inline).  There does not seem to be a good solution\n                ### for this problem if pcre criteria are involved because the\n                ### two pcre's would have to be interpreted to see if there is\n                ### any data that could satisfy both at the same time.\n\n                ### However, performing the duplicate string matching is far\n                ### less expensive than not sending a large portion of network\n                ### traffic to userspace for analysis by snort_inline in the\n                ### first place.  This is the real benefit of letting fwsnort\n                ### build a smarter iptables queueing policy.  This does come\n                ### with a penalty against detection, since snort_inline is\n                ### only receiving individual packets that match one of the\n                ### content keywords in a signature; it does not get the\n                ### entire stream.  But, this may be worth it for large sites\n                ### where performance is the primary concern.  Also, there is\n                ### some potential for removing a subset of the content\n                ### matches if done in the right way; this is the reason the\n                ### queue_get_rule() function is stubbed in below.\n                my $queue_rule = &queue_get_rule($rule_hdr, $rule_options);\n\n                push @queue_rules, $queue_rule if $queue_rule;\n            }\n\n            ### construct the equivalent iptables rule and add it\n            ### to $config{'FWSNORT_SCRIPT'}\n            my ($ipt_rv, $num_rules) = &ipt_build($hdr_hr,\n                    $opts_hr, $patterns_ar, $rule);\n\n            if ($ipt_rv) {\n                $ipt_apply_ctr++;\n                $tot_ipt_apply++;\n                ### may have the rule in several chains\n                $ipt_rules_ctr += $num_rules;\n                if ($include_sids) {\n                    print \"    Successful translation.\\n\";\n                }\n            } else {\n                if ($include_sids) {\n                    print \"    Unsuccessful translation.\\n\";\n                }\n            }\n            $parsed_ctr++;  ### keep track of successfully parsed rules\n            $abs_num++;;\n        }\n\n        if (($queue_mode or $nfqueue_mode) and @queue_rules) {\n            open M, \"> $config{'QUEUE_RULES_DIR'}/$filename\" or die \"[*] Could not \",\n                \"open $config{'QUEUE_RULES_DIR'}/$filename: $!\";\n            print M \"#\\n### This file generated with: fwsnort @argv_cp\\n#\\n\\n\";\n            print M \"$_\\n\", for @queue_rules;\n            print M \"\\n### EOF ###\\n\";\n            close F;\n        }\n\n        if ($ipt_rules_ctr) {\n            $ipt_rules_ctr *= 2 if $ipt_drop;\n            $ipt_rules_ctr *= 2 if $ipt_reject;\n            push @ipt_script_lines,\n                qq|\\$ECHO \"    Rules added: $ipt_rules_ctr\"|;\n        }\n\n        unless ($include_sids) {\n            if ($ipt_sync) {\n                printf(\"%-10s%-10s%-10s%-10s\\n\", $parsed_ctr, $unsup_ctr,\n                    $ipt_apply_ctr, $rule_num);\n            } else {\n                printf(\"%-10s%-10s%-10s\\n\", $parsed_ctr, $unsup_ctr,\n                    $rule_num);\n            }\n        }\n    }\n    unless ($include_sids) {\n        if ($ipt_sync) {\n            printf(\"%30s\", ' ');\n            print \"=======================================\\n\";\n            printf(\"%30s%-10s%-10s%-10s%-10s\\n\", ' ',\n                $abs_num, $tot_unsup_ctr, $tot_ipt_apply, $sabs_num);\n        } else {\n            printf(\"%30s\", ' ');\n            print \"=============================\\n\";\n            printf(\"%30s%-10s%-10s%-10s\\n\", ' ',\n                $abs_num, $tot_unsup_ctr, $sabs_num);\n        }\n        print \"\\n\";\n        if ($abs_num) {  ### we parsed at least one rule\n            print \"[+] Generated $ipt_str rules for $abs_num out of \",\n                \"$sabs_num signatures: \",\n                sprintf(\"%.2f\", $abs_num/$sabs_num*100), \"%\\n\";\n        } else {\n            print \"[+] No rules parsed.\\n\";\n        }\n        if ($ipt_sync) {\n            print \"[+] Found $tot_ipt_apply applicable snort rules to your \" .\n                \"current $ipt_str\\n    policy.\\n\";\n        }\n    }\n    return;\n}\n\nsub parse_rule_options() {\n    my ($rule_options, $avg_hdr_len, $line_num) = @_;\n\n    my $sid      = -1;\n    my %opts     = ();\n    my @patterns = ();\n\n    ### get the sid here for logging purposes\n    if ($rule_options =~ $snort_opts{'logprefix'}{'sid'}) {\n        $sid = $1;\n    } else {\n        return 0, \\%opts, \\@patterns;\n    }\n\n    if (%exclude_sids) {\n        return 0, \\%opts, \\@patterns if defined $exclude_sids{$sid};\n    }\n    if (%include_sids) {\n        if (defined $include_sids{$sid}) {\n            &logr(\"[+] matched sid:$sid: $rule_options\");\n        } else {\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    unless ($queue_mode or $nfqueue_mode) {\n\n        ### if we're queuing packets to userspace Snort, then we don't have to\n        ### disqualify a signature based on an option that is not supported by\n        ### iptables\n        my $found_unsupported = '';\n        for my $opt (keys %{$snort_opts{'unsupported'}}) {\n            ### see if we match a regex belonging to an unsupported option\n            if ($rule_options =~ $snort_opts{'unsupported'}{$opt}) {\n                $found_unsupported .= \"'$opt', \";\n            }\n        }\n        if ($found_unsupported) {\n            $found_unsupported =~ s/,\\s+$//;\n            &logr(\"[-] SID: $sid  Unsupported option(s): $found_unsupported \" .\n                \"at line: $line_num, skipping.\");\n            if (%include_sids and defined $include_sids{$sid}) {\n                print \"[-] SID: $sid contain the unsupported option(s): \",\n                    \"$found_unsupported at line: $line_num\\n\";\n            }\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    if ($rule_options =~ /ip_proto\\s*:.*ip_proto\\s*:/) {\n        &logr(\"[-] SID: $sid, unsupported multiple ip_proto fields at \" .\n            \"line: $line_num, skipping.\");\n        return 0, \\%opts, \\@patterns;\n    }\n\n    for my $opt (keys %{$snort_opts{'filter'}}) {\n        ### see if we match the option regex\n        if ($rule_options =~ $snort_opts{'filter'}{$opt}{'regex'}) {\n            $opts{$opt} = 1;\n            $opts{$opt} = $1 if defined $1;  ### some keywords may not have an option\n        }\n    }\n\n    my $found_content = 0;\n    while ($rule_options =~ /(\\w+):?\\s*((?:.*?[^\\x5c]?))\\s*;/g) {\n        my $opt = $1;\n        my $val = 1;\n        $val = $2 if defined $2;  ### some keywords may not have an argument\n\n        if ($opt eq 'content' or $opt eq 'uricontent') {\n            return 0, \\%opts, \\@patterns unless $val =~ /\"$/;\n            $val =~ s/^\\s*\"//;\n            $val =~ s/\"\\s*$//;\n            return 0, \\%opts, \\@patterns unless $val =~ /\\S/;\n\n            ### convert the string into a form that is more compatible\n            ### for iptables\n            my ($rv, $log_str, $ipt_pattern_hr)\n                    = &convert_pattern_for_iptables($val);\n\n            if ($rv) {\n                $found_content = 1;\n                push @patterns, $ipt_pattern_hr;\n            } else {\n                &logr(\"[-] SID: $sid, $log_str\");\n                return 0, \\%opts, \\@patterns;\n            }\n\n        } elsif ($opt eq 'pcre') {\n\n            $val =~ s|^\\s*\"/||;\n            $val =~ s|/\\w{0,3}\"$||;\n\n            ### see if this pcre only has strings separated with \".*\" or \".+\"\n            ### and if so translate to multple string matches\n            my ($pcre_rv, $pcre_strings_ar) = &parse_pcre($val);\n            if ($pcre_rv) {\n                for my $str (@$pcre_strings_ar) {\n                    push @patterns, $str;\n                }\n            } else {\n                unless ($queue_mode or $nfqueue_mode) {\n                    &logr(\"[-] SID: $sid, unsupported complex pcre: $val\");\n                    return 0, \\%opts, \\@patterns;\n                }\n            }\n\n        } elsif ($opt eq 'fast_pattern') {\n            if ($no_fast_pattern_order) {\n                ### force it to be the first pattern so no reordering\n                ### will happen\n                $patterns[0]->{'fast_pattern'} = 1;\n            } else {\n                $patterns[$#patterns]->{'fast_pattern'} = 1;\n            }\n        } elsif ($opt eq 'nocase') {\n            unless (defined $snort_opts{'ignore'}{'nocase'}) {\n                $patterns[$#patterns]->{'nocase'} = 1;\n            }\n        } else {\n            for my $key (qw(offset depth within distance)) {\n                if ($opt eq $key) {\n                    my ($offsets_rv, $log_str)\n                            = &define_offsets(\\@patterns,\n                                $avg_hdr_len, $key, $val);\n                    unless ($offsets_rv) {\n                        &logr(\"[-] SID: $sid, $log_str\");\n                        return 0, \\%opts, \\@patterns;\n                    }\n                    last;\n                }\n            }\n        }\n    }\n\n    if (($queue_mode or $nfqueue_mode) and not $found_content) {\n        my $queue_str = 'QUEUE';\n        $queue_str = 'NFQUEUE' if $nfqueue_mode;\n        &logr(\"[-] SID: $sid  In --$queue_str mode signature must have \" .\n                \"'content' or 'uricontent' keyword \" .\n                \"at line: $line_num, skipping.\");\n        if (%include_sids and defined $include_sids{$sid}) {\n            print \"[-] SID: $sid does not contain 'content' \",\n                  \"or 'uricontent'\\n\";\n        }\n        return 0, \\%opts, \\@patterns;\n    }\n\n    ### update offset, depth, within, and distance values for relative\n    ### matches\n    my ($offsets_rv, $log_str) = &update_offsets_relative_matches(\\@patterns);\n    unless ($offsets_rv) {\n        &logr(\"[-] SID: $sid, $log_str\");\n        return 0, \\%opts, \\@patterns;\n    }\n\n    for my $opt (keys %{$snort_opts{'logprefix'}}) {\n        if ($rule_options =~ $snort_opts{'logprefix'}{$opt}) {\n            $opts{$opt} = $1;\n        }\n    }\n\n    unless ($queue_mode or $nfqueue_mode) {\n        while ($rule_options =~ /(\\w+):\\s*.*?;/g) {\n            my $option = $1;\n            if (not defined $opts{$option}\n                    and not defined $snort_opts{'ignore'}{$option}) {\n                &logr(\"[-] SID: $sid bad option: \\\"$option\\\" at line: $line_num \" .\n                    \"-- $rule_options\");\n                return 0, \\%opts, \\@patterns;\n            }\n        }\n\n        if (defined $opts{'ipopts'}\n                and $opts{'ipopts'} ne 'rr'\n                and $opts{'ipopts'} ne 'ts'\n                and $opts{'ipopts'} ne 'ssrr'\n                and $opts{'ipopts'} ne 'lsrr'\n                and $opts{'ipopts'} ne 'any') {\n            &logr(\"[-] SID: $sid, unsupported ipopts field at \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n\n        if (defined $opts{'itype'}\n                and ($opts{'itype'} =~ m|<| or $opts{'itype'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in itype field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n        if (defined $opts{'icode'}\n                and ($opts{'icode'} =~ m|<| or $opts{'icode'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in icode field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n        if (defined $opts{'ip_proto'}\n                and ($opts{'ip_proto'} =~ m|<| or $opts{'ip_proto'} =~ m|>|)) {\n            &logr(\"[-] SID: $sid, unsupported range operator in ip_proto field \" .\n                \"line: $line_num, skipping.\");\n            return 0, \\%opts, \\@patterns;\n        }\n    }\n\n    ### success\n    return 1, \\%opts, \\@patterns;\n}\n\nsub parse_rule_hdr() {\n    my ($rule_hdr, $line_num) = @_;\n    my $bidir = 0;\n    my $action = 'alert';  ### default\n    if ($rule_hdr =~ /^\\s*pass/) {\n        $action = 'pass';\n    } elsif ($rule_hdr =~ /^\\s*log/) {\n        $action = 'log';\n    }\n    if ($rule_hdr =~ m|^\\s*\\w+\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\n                        \\s+(\\S+)\\s+(\\S+)\\s+(\\S+)|ix) {\n        my $proto  = lc($1);\n        my $src    = $2;\n        my $sport  = $3;\n        my $bidir  = $4;\n        my $dst    = $5;\n        my $dport  = $6;\n\n        unless ($proto =~ /^\\w+$/) {\n            &logr(\"[-] Unsupported protocol: \\\"$proto\\\" at line: \" .\n                \"$line_num, skipping.\");\n            return {};\n        }\n\n        ### in --ip6tables mode make sure we're not looking at IPv4 addresses\n        if ($enable_ip6tables\n                and ($src =~ /\\b$ip_re\\b/ or $dst =~ /\\b$ip_re\\b/)) {\n            &logr(\"[-] --ip6tables mode enabled but IPv4 \" .\n                \"address in rule variable at line: $line_num.\");\n            return {};\n        }\n\n        ### in --ip6tables mode exclude the icmp protocol - maybe should\n        ### change to icmp6 in the future\n        if ($enable_ip6tables and $proto eq 'icmp') {\n            &logr(\"[-] --ip6tables mode enabled, so excluding \" .\n                \"icmp (non-icmp6) siganture at line: $line_num.\");\n            return {};\n        }\n\n        my $bidir_flag = 0;\n        $bidir_flag = 1 if $bidir eq '<>';\n\n        my %hsh = (\n            'action' => $action,\n            'proto'  => $proto,\n            'src'    => $src,\n            'sport'  => $sport,\n            'bidir'  => $bidir_flag,\n            'dst'    => $dst,\n            'dport'  => $dport,\n        );\n\n        ### map to expanded values (e.g. $HOME -> \"any\" or whatever\n        ### is defined in fwsnort.conf)\n        for my $var (qw(src sport dst dport)) {\n            my $val = $hsh{$var};\n            my $negate_flag = 0;\n            $negate_flag = 1 if $val =~ m|!|;\n            while ($val =~ /\\$(\\w+)/) {\n                $val = $1;\n                if (defined $config{$val}) {\n                    $val = $config{$val};\n                    if ($enable_ip6tables and $val =~ /\\b$ip_re\\b/) {\n                        &logr(\"[-] --ip6tables mode enabled but IPv4 \" .\n                            \"address in rule variable at line: $line_num.\");\n                        return {};\n                    }\n                } else {\n                    &logr(\"[-] Undefined variable $val in rule header \" .\n                        \"at line: $line_num.\");\n                    return {};\n                }\n            }\n            if ($negate_flag and $val !~ m|!|) {\n                $hsh{$var} = \"!$val\";\n            } else {\n                $hsh{$var} = $val;\n            }\n        }\n\n        for my $var (qw(sport dport)) {\n            next unless $hsh{$var} =~ /,/;\n            if ($ipt_have_multiport_match) {\n                $hsh{$var} =~ s/\\[//;\n                $hsh{$var} =~ s/\\]//;\n                my $ctr = 1;\n                my @ports = split /\\s*,\\s*/, $hsh{$var};\n                my $ports_str = '';\n                for my $port (@ports) {\n                    if ($port =~ /\\d+:$/) {\n                        $ports_str .= \"${port}65535,\";\n                    } else {\n                        $ports_str .= \"${port},\";\n                    }\n                    $ctr++;\n                    $ctr++ if $port =~ /\\:/;  ### a range counts for two ports\n                    ### multiport is limited to 15 ports\n                    last if $ctr >= $ipt_multiport_max;\n                }\n                $ports_str =~ s/,$//;\n                $hsh{$var} = $ports_str;\n            } else {\n                &logr(\"[-] Warning: taking the first port in the list \" .\n                    \"$hsh{$var} until the $ipt_str multiport match is supported \" .\n                    \"at line: $line_num.\");\n                $hsh{$var} =~ s/,.*//;\n                $hsh{$var} =~ s/\\[//;\n                $hsh{$var} =~ s/\\]//;\n            }\n        }\n\n        return \\%hsh;\n    }\n    return {};\n}\n\nsub parse_pcre() {\n    my $pcre = shift;\n    my $rv = 0;\n    my @patterns = ();\n\n    if ($pcre =~ m|^\\w+$|) {\n        push @patterns, (&convert_pattern_for_iptables($pcre))[2];\n        $rv = 1;\n    } elsif ($pcre =~ m|UNION\\x5c\\x73\\x2bSELECT|) {\n        ### a bunch of Emerging Threats rules contain \"UNION\\s+SELECT\"\n        ### as a PCRE.  Sure, the translation below can be evaded, but\n        ### it is better than nothing.\n        push @patterns, (&convert_pattern_for_iptables('UNION SELECT'))[2];\n        $rv = 1;\n    } else {\n        my @ar = ();\n        if ($pcre =~ m|\\.\\*|) {\n            @ar = split /\\.\\*/, $pcre;\n            $rv = 1;\n        } elsif ($pcre =~ m|\\.\\+|) {\n            @ar = split /\\.\\+/, $pcre;\n            $rv = 1;\n        } elsif ($pcre =~ m|\\x5b\\x5e\\x5c\\x6e\\x5d\\x2b|) {  ### [^\\n]+\n            @ar = split /\\x5b\\x5e\\x5c\\x6e\\x5d\\x2b/, $pcre;\n            $rv = 1;\n        }\n        if ($rv == 1) {\n            for my $part (@ar) {\n                next unless $part;  ### some Snort pcre's begin with .* or .+\n                                    ### (which seems useless)\n\n                ### Replace \"\\(\" with hex equivalent in PCRE's\n                ### like: /.+ASCII\\(.+SELECT/\n                $part =~ s/\\x5c\\x28/|5c 28|/;\n\n                ### Replace \"\\:\" with hex equivalent in PCRE's\n                ### like: /User-Agent\\:[^\\n]+spyaxe/\n                $part =~ s/\\x5c\\x3a/|5c 3a|/;\n\n                my $basic = $part;\n                $basic =~ s/\\|5c 28\\|//;\n                $basic =~ s/\\|5c 3a\\|//;\n\n                if ($basic =~ /^[\\w\\x20]+$/) {\n                    push @patterns, (&convert_pattern_for_iptables($part))[2];\n                } elsif ($basic eq 'User-Agent') {\n                    push @patterns, (&convert_pattern_for_iptables($part))[2];\n                } else {\n                    $rv = 0;\n                }\n            }\n        }\n    }\n    return $rv, \\@patterns;\n}\n\nsub queue_get_rule() {\n    my ($rule_hdr, $rule_opts) = @_;\n\n    ### FIXME: the following commented out code would need to be\n    ### drastically improved to ensure that the remaining signatures\n    ### are completely unique in userspace.  For now, just return\n    ### the original Snort rule\n    ###     Remove all of the following keywords since they are handled\n    ###     within the kernel directly.\n#    for my $key qw/uricontent content offset depth within distance/ {\n#        $rule_opts =~ s/([\\s;])$key:\\s*.*?\\s*;\\s*/$1/g;\n#    }\n\n    $rule_opts =~ s/^\\s*//;\n    $rule_opts =~ s/\\s*$//;\n\n    return \"$rule_hdr ($rule_opts)\";\n}\n\nsub ipt_allow_traffic() {\n    my ($hdr_hr, $opts_hr, $chain, $orig_snort_rule) = @_;\n\n    my $rule_ctr = 0;\n\n    if ($dump_snort) {\n        print \"\\n[+] Snort rule: $orig_snort_rule\"\n                unless defined $snort_dump_cache{$orig_snort_rule};\n        $snort_dump_cache{$orig_snort_rule} = '';\n    }\n\n    ### check to see if the header is allowed through the chain,\n    ### and if not we don't really care about matching traffic\n    ### because iptables doesn't allow it anyway\n    RULE: for my $rule_hr (@{$ipt_policy{$chain}}) {\n        $rule_ctr++;\n\n        if ($dumper and $verbose) {\n            print \"[+] RULE: $rule_ctr:\\n\",\n                Dumper($rule_hr);\n        }\n        if ($dump_ipt) {\n            print \"[+] $ipt_str rule: $rule_hr->{'raw'}\\n\"\n                unless defined $ipt_dump_cache{$rule_hr->{'raw'}};\n            $ipt_dump_cache{$rule_hr->{'raw'}} = '';\n        }\n\n        ### don't match on rules to/from the loopback interface\n        unless ($no_exclude_loopback) {\n            if ($rule_hr->{'intf_in'} eq 'lo'\n                    or $rule_hr->{'intf_out'} eq 'lo') {\n                print \"[-] Skipping $chain rule $rule_ctr: loopback rule\\n\"\n                    if $debug;\n                next RULE;\n            }\n        }\n\n        ### don't match on rules that build state\n        if ($rule_hr->{'extended'} =~ /state/) {\n            print \"[-] Skipping $chain rule $rule_ctr: state rule\\n\"\n                if $debug;\n            next RULE;\n        }\n\n        ### match protocol\n        unless (($hdr_hr->{'proto'} eq $rule_hr->{'proto'}\n                or $rule_hr->{'proto'} eq 'all')) {\n            print \"[-] Skipping $chain rule $rule_ctr: $hdr_hr->{'proto'} \",\n                \"!= $rule_hr->{'proto'}\\n\" if $debug;\n            next RULE;\n        }\n\n        ### match src/dst IP/network\n        unless (&match_addr($hdr_hr->{'src'}, $rule_hr->{'src'})) {\n            print \"[-] Skipping $chain rule $rule_ctr: src $hdr_hr->{'src'} \",\n                \"not part of $rule_hr->{'src'}\\n\" if $debug;\n            next RULE;\n        }\n        unless (&match_addr($hdr_hr->{'dst'}, $rule_hr->{'dst'})) {\n            print \"[-] Skipping $chain rule $rule_ctr: dst $hdr_hr->{'dst'} \",\n                \"not part of $rule_hr->{'dst'}\\n\" if $debug;\n            next RULE;\n        }\n\n        ### match src/dst ports\n        if ($hdr_hr->{'proto'} ne 'icmp') {\n            unless (&match_port($hdr_hr->{'sport'},\n                    $rule_hr->{'sport'})) {\n                print \"[-] Skipping $chain rule $rule_ctr: sport \",\n                    \"$hdr_hr->{'sport'} not part of $rule_hr->{'sport'}\\n\"\n                    if $debug;\n                next RULE;\n            }\n            unless (&match_port($hdr_hr->{'dport'},\n                    $rule_hr->{'dport'})) {\n                print \"[-] Skipping $chain rule $rule_ctr: dport \",\n                    \"$hdr_hr->{'dport'} not part of $rule_hr->{'dport'}\\n\"\n                    if $debug;\n                next RULE;\n            }\n        }\n\n        if (defined $opts_hr->{'flow'} and $rule_hr->{'state'}) {\n            if ($opts_hr->{'flow'} eq 'established') {\n                unless ($rule_hr->{'state'} =~ /ESTABLISHED/) {\n                    print \"[-] Skipping $chain rule $rule_ctr: state \",\n                        \"$opts_hr->{'flow'} not part of $rule_hr->{'state'}\\n\"\n                        if $debug;\n                    next RULE;\n                }\n            }\n        }\n\n        ### if we make it here, then this rule matches the signature\n        ### (from a header perspective)\n        if ($rule_hr->{'target'} eq 'DROP'\n                or $rule_hr->{'target'} eq 'REJECT') {\n\n            print \"[-] Matching $ipt_str rule has DROP or REJECT target; \",\n                \"$ipt_str policy does not allow this Snort rule.\\n\"\n                if $debug;\n            if ($dumper) {\n                print \"\\n[-] RULE $chain DROP:\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    Dumper($rule_hr),\n                    \"\\n\";\n            }\n            return 0;\n        } elsif ($rule_hr->{'target'} eq 'ACCEPT') {\n            if ($dumper) {\n                print \"\\n[+] RULE $chain ACCEPT:\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    Dumper($rule_hr),\n                    \"\\n\";\n            }\n            print \"[-] Matching $ipt_str rule has ACCEPT target; \",\n                \"$ipt_str policy allows this Snort rule.\\n\" if $debug;\n            return 1;\n        }  ### we don't support other targets besides DROP, REJECT,\n           ### or ACCEPT for now.\n    }\n\n    ### if we make it here, then no specific ACCEPT rule matched the header,\n    ### so return false if the chain policy is set to DROP (or there is\n    ### a default drop rule). Otherwise there is no rule that would block\n    ### the traffic.\n    if (defined $ipt_default_policy_setting{$chain}) {\n        if ($ipt_default_policy_setting{$chain} eq 'ACCEPT') {\n            if (defined $ipt_default_drop{$chain}) {\n                if (defined $ipt_default_drop{$chain}{'all'}) {\n                    print \"[-] Default DROP rule applies to this Snort rule.\\n\"\n                        if $debug;\n                    return 0;\n                } elsif (defined $ipt_default_drop{$chain}\n                        {$hdr_hr->{'proto'}}) {\n                    print \"[-] Default DROP rule applies to this Snort rule.\\n\"\n                        if $debug;\n                    return 0;\n                }\n            }\n            if ($dumper) {\n                print \"\\nACCEPT $chain, no $ipt_str matching rule\\n\",\n                    Dumper($hdr_hr),\n                    Dumper($opts_hr),\n                    \"\\n\";\n            }\n            return 1;\n        }\n    }\n    if ($dumper) {\n        print \"\\nDROP $chain, no $ipt_str matching rule\\n\",\n            Dumper($hdr_hr),\n            Dumper($opts_hr),\n            \"\\n\";\n    }\n\n    ### maybe a \"strict\" option should be added here?\n    return 0;\n}\n\nsub match_addr() {\n    my ($hdr_src, $rule_src) = @_;\n    return 1 if $rule_src eq '0.0.0.0/0';\n    return 1 if $hdr_src =~ /any/i;\n    return 1 if $hdr_src eq $rule_src;\n\n    my $ipt_ip   = '';\n    my $ipt_mask = '32';\n    my $negate = 0;\n\n    my $s_obj   = '';\n    my $ipt_obj = '';\n\n    $negate = 1 if $hdr_src =~ /\\!/;\n\n    if ($rule_src =~ /\\!/) {\n        if ($negate) {\n            ### if both hdr_src and rule_src are negated\n            ### then revert to normal match.\n            $negate = 0;\n        } else {\n            $negate = 1;\n        }\n    }\n\n    if ($rule_src =~ m|($ip_re)/($ip_re)|) {\n        $ipt_ip   = $1;\n        $ipt_mask = $2;\n    } elsif ($rule_src =~ m|($ip_re)/(\\d+)|) {\n        $ipt_ip   = $1;\n        $ipt_mask = $2;\n    } elsif ($rule_src =~ m|($ip_re)|) {\n        $ipt_ip = $1;\n    }\n\n    $ipt_obj = new NetAddr::IP($ipt_ip, $ipt_mask);\n\n    for my $addr (@{&expand_addresses($hdr_src)}) {\n        my $src_ip   = '';\n        my $src_mask = '32';\n        if ($addr =~ m|($ip_re)/($ip_re)|) {\n            $src_ip   = $1;\n            $src_mask = $2;\n        } elsif ($addr =~ m|($ip_re)/(\\d+)|) {\n            $src_ip   = $1;\n            $src_mask = $2;\n        } elsif ($addr =~ m|($ip_re)|) {\n            $src_ip = $1;\n        }\n        $s_obj = new NetAddr::IP($src_ip, $src_mask);\n        if ($negate) {\n            return 1 unless $ipt_obj->within($s_obj);\n        } else {\n            return 1 if $ipt_obj->within($s_obj);\n        }\n    }\n    return 0;\n}\n\nsub match_port() {\n    my ($snort_port, $ipt_port) = @_;\n    return 1 if $ipt_port eq '0:0';\n    return 1 if $snort_port =~ /any/i;\n    return 1 if $ipt_port eq $snort_port;\n    my $ipt_start = 0;\n    my $ipt_end   = 65535;\n    my $h_start   = 0;\n    my $h_end     = 65535;\n\n    if ($ipt_port =~ /:/) {\n        if ($ipt_port =~ /(\\d+):/) {\n            $ipt_start = $1;\n        }\n        if ($ipt_port =~ /:(\\d+)/) {\n            $ipt_end = $1;\n        }\n    } elsif ($ipt_port =~ /(\\d+)/) {\n        $ipt_start = $ipt_end = $1;\n    }\n\n    if ($snort_port =~ /:/) {\n        if ($snort_port =~ /(\\d+):/) {\n            $h_start = $1;\n        }\n        if ($snort_port =~ /:(\\d+)/) {\n            $h_end = $1;\n        }\n    } elsif ($snort_port =~ /(\\d+)/) {\n        $h_start = $h_end = $1;\n    }\n\n    if ($ipt_port =~ /!/) {\n        if ($snort_port =~ /!/) {\n            return 0;\n        } else {\n            return 1 if (($h_start < $ipt_start and $h_end < $ipt_start)\n                    or ($h_start > $ipt_end and $h_end > $ipt_end));\n        }\n    } else {\n        if ($snort_port =~ /!/) {\n            return 1 if (($ipt_start < $h_start and $ipt_end < $h_start)\n                    or ($ipt_start > $h_end and $ipt_end > $h_end));\n        } else {\n            return 1 if $h_start >= $ipt_start and $h_end <= $ipt_end;\n        }\n    }\n    return 0;\n}\n\nsub cache_ipt_policy() {\n\n    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'}\n        or die \"[*] Could not acquire IPTables::Parse object: $!\";\n\n    for my $chain (keys %process_chains) {\n        next unless $process_chains{$chain};\n\n        $ipt_policy{$chain} = $ipt->chain_rules('filter',\n            $chain, $ipt_file);\n\n        $ipt_default_policy_setting{$chain}\n            = $ipt->chain_policy('filter', $chain, $ipt_file);\n\n        my ($def_drop_hr, $ipt_rv)\n            = $ipt->default_drop('filter', $chain, $ipt_file);\n\n        if ($ipt_rv) {\n            $ipt_default_drop{$chain} = $def_drop_hr;\n        }\n    }\n    return;\n}\n\nsub ipt_build() {\n    my ($snort_hdr_hr, $snort_opts_hr, $patterns_ar, $orig_snort_rule) = @_;\n\n    my $found_rule = 0;\n    my $num_rules  = 0;\n\n    my %process_rules = ();\n\n    ### define iptables source and destination\n    if ($snort_hdr_hr->{'dst'} =~ /any/i) {\n        if ($snort_hdr_hr->{'src'} =~ /any/i) {\n            if ($orig_snort_rule =~ m|\\$HOME_NET.*\\-\\>\\s+\\$EXTERNAL_NET|) {\n                push @{$process_rules{'OUTPUT'}}, '' if $process_chains{'OUTPUT'};\n            } else {\n                push @{$process_rules{'INPUT'}}, '' if $process_chains{'INPUT'};\n            }\n            push @{$process_rules{'FORWARD'}}, ''\n                if $process_chains{'FORWARD'};\n        } else {\n            my $addr_ar = &expand_addresses($snort_hdr_hr->{'src'});\n            my $negate = '';\n            $negate = '! ' if $snort_hdr_hr->{'src'} =~ m|!|;\n            unless ($addr_ar) {\n                &logr(\"[-] No valid source IPs/networks in Snort \" .\n                    \"rule header.\");\n                return 0, 0;\n            }\n            for my $src (@$addr_ar) {\n                if (&is_local($src)) {\n                    push @{$process_rules{'OUTPUT'}},\n                            \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                            if $process_chains{'OUTPUT'};\n                } else {\n                    push @{$process_rules{'INPUT'}},\n                            \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                            if $process_chains{'INPUT'};\n                }\n                push @{$process_rules{'FORWARD'}},\n                        \"$negate$ipt_hdr_opts{'src'} ${src}\"\n                        if $process_chains{'FORWARD'};\n            }\n        }\n    } else {\n        my $dst_addr_ar = &expand_addresses($snort_hdr_hr->{'dst'});\n        unless ($dst_addr_ar) {\n            &logr(\"[-] No valid destination IPs/networks in Snort rule \" .\n                \"header.\");\n            return 0, 0;\n        }\n        if ($snort_hdr_hr->{'src'} =~ /any/i) {\n            my $negate = '';\n            $negate = '! ' if $snort_hdr_hr->{'dst'} =~ m|!|;\n            for my $dst (@$dst_addr_ar) {\n                if (&is_local($dst)) {\n                    push @{$process_rules{'INPUT'}},\n                            \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'INPUT'};\n                } else {\n                    push @{$process_rules{'OUTPUT'}},\n                            \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'OUTPUT'};\n                }\n                push @{$process_rules{'FORWARD'}},\n                        \"$negate$ipt_hdr_opts{'dst'} ${dst}\"\n                        if $process_chains{'FORWARD'};\n            }\n        } else {\n            my $src_addr_ar = &expand_addresses($snort_hdr_hr->{'src'});\n            my $negate_src = '';\n            $negate_src = '! ' if $snort_hdr_hr->{'src'} =~ m|!|;\n            my $negate_dst = '';\n            $negate_dst = '! ' if $snort_hdr_hr->{'dst'} =~ m|!|;\n            unless ($src_addr_ar) {\n                &logr(\"[-] No valid source IPs/networks in Snort rule \" .\n                    \"header.\");\n                return 0, 0;\n            }\n            for my $src (@$src_addr_ar) {\n                for my $dst (@$dst_addr_ar) {\n                    if (&is_local($dst)) {\n                        push @{$process_rules{'INPUT'}},\n                            \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                            \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'INPUT'};\n                    } else {\n                        push @{$process_rules{'OUTPUT'}},\n                            \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                            \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                            if $process_chains{'OUTPUT'};\n                    }\n                    push @{$process_rules{'FORWARD'}},\n                        \"$negate_src$ipt_hdr_opts{'src'} ${src}\" .\n                        \" $negate_dst$ipt_hdr_opts{'dst'} ${dst}\"\n                        if $process_chains{'FORWARD'};\n                }\n            }\n        }\n    }\n\n    ### determine which chain (e.g. stateful/stateless)\n    my $flow_established = '';\n    unless ($no_ipt_conntrack) {\n        if (defined $snort_hdr_hr->{'proto'}\n                and $snort_hdr_hr->{'proto'} =~ /tcp/i\n                and defined $snort_opts_hr->{'flow'}\n                and $snort_opts_hr->{'flow'} =~ /established/i) {\n            $flow_established = 'ESTABLISHED';\n        }\n    }\n\n    my $add_snort_comment = 1;\n    my $add_perl_trigger  = 1;\n    for my $chain (keys %process_chains) {\n\n        next unless $process_chains{$chain} and $process_rules{$chain};\n\n        for my $src_dst (@{$process_rules{$chain}}) {\n\n            my $rule = \"\\$${ipt_var_str} -A \";\n            my $save_rule = '-A';\n            my $fwsnort_chain = '';\n\n            ### see if we can jump to the ESTABLISHED inspection chain.\n            if ($flow_established) {\n                $rule .= $config{\"FWSNORT_${chain}_ESTAB\"};\n                $fwsnort_chain = $config{\"FWSNORT_${chain}_ESTAB\"};\n            } else {\n                $rule .= $config{\"FWSNORT_$chain\"};\n                $fwsnort_chain = $config{\"FWSNORT_$chain\"};\n            }\n\n            ### append interface restriction if necessary\n            if ($src_dst =~ m|127\\.0\\.0\\.\\d/|) {\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                    $rule .= ' ! -i lo';\n                } elsif ($chain eq 'OUTPUT') {\n                    $rule .= ' ! -o lo';\n                }\n            }\n\n            ### append source and destination criteria\n            if ($src_dst) {\n                if ($chain eq 'FORWARD') {\n                    $rule .= \" $src_dst\";\n                } elsif ($chain eq 'INPUT') {\n                    ### we always treat the INPUT chain as part of the HOME_NET;\n                    ### the system running iptables may have an interface on the\n                    ### external network and hence may not be part of the HOME_NET\n                    ### as defined in the fwsnort.conf file so we don't necessarily\n                    ### append the IP criteria\n                    if ($src_dst ne \"$ipt_hdr_opts{'dst'} $config{'HOME_NET'}\") {\n                        $rule .= \" $src_dst\";\n                    }\n                } elsif ($chain eq 'OUTPUT') {\n                    if ($src_dst ne \"$ipt_hdr_opts{'src'} $config{'HOME_NET'}\") {\n                        $rule .= \" $src_dst\";\n                    }\n                }\n            }\n\n            my $rv = &ipt_build_rule(\n                $chain,\n                $fwsnort_chain,\n                $rule,\n                $snort_hdr_hr,\n                $snort_opts_hr,\n                $patterns_ar,\n                $orig_snort_rule,\n                $flow_established,\n                $add_snort_comment,\n                $add_perl_trigger\n            );\n            if ($rv) {\n                $found_rule        = 1;\n                $add_snort_comment = 0;\n                $add_perl_trigger  = 0;\n                $num_rules++;\n            }\n        }\n    }\n    return $found_rule, $num_rules;\n}\n\nsub is_local() {\n    my $addr = shift;\n\n    return 1 if $no_addr_check;\n\n    my $ip   = '';\n    my $mask = '32';\n\n    if ($addr =~ m|($ip_re)/($ip_re)|) {\n        $ip   = $1;\n        $mask = $2;\n    } elsif ($addr =~ m|($ip_re)/(\\d+)|) {\n        $ip   = $1;\n        $mask = $2;\n    } elsif ($addr =~ m|($ip_re)|) {\n        $ip = $1;\n    }\n\n    my $ip_obj = new NetAddr::IP($ip, $mask);\n\n    for my $local_ar (@local_addrs) {\n        my $local_ip   = $local_ar->[0];\n        my $local_mask = $local_ar->[1];\n\n        my $local_obj = new NetAddr::IP($local_ip, $local_mask);\n\n        return 1 if $ip_obj->within($local_obj);\n    }\n    return 0;\n}\n\nsub get_local_addrs() {\n    open IFC, \"$cmds{'ifconfig'} -a |\" or die \"[*] Could not run \",\n        \"$cmds{'ifconfig'}: $!\";\n    my @lines = <IFC>;\n    close IFC;\n\n    my $intf_name = '';\n    for my $line (@lines) {\n        if ($line =~ /^(\\w+)\\s+Link/) {\n            $intf_name = $1;\n            next;\n        }\n        next if $intf_name eq 'lo';\n        next if $intf_name =~ /dummy/i;\n        if ($line =~ /^\\s+inet.*?:($ip_re).*:($ip_re)/i) {\n            push @local_addrs, [$1, $2];\n        }\n    }\n    return;\n}\n\nsub ipt_build_rule() {\n    my ($chain, $fwsnort_chain, $rule, $hdr_hr, $opts_hr, $patterns_ar,\n            $orig_snort_rule, $flow_logging_prefix, $add_snort_comment,\n            $add_perl_trigger) = @_;\n\n    ### $chain is used only to see whether or not we need to add the\n    ### rule to the iptables script based on whether the built-in chain\n    ### will pass the traffic in the first place.\n    if ($ipt_sync) {\n        return 0 unless &ipt_allow_traffic($hdr_hr,\n                $opts_hr, $chain, $orig_snort_rule);\n    }\n\n    ### append the protocol to the rule\n    if (defined $opts_hr->{'ip_proto'}) {\n        return 0 unless $opts_hr->{'ip_proto'} =~ /^\\w+$/;\n        $rule .= \" $snort_opts{'filter'}{'ip_proto'}{'iptopt'} \" .\n            \"$opts_hr->{'ip_proto'}\";\n    } else {\n        return 0 unless $hdr_hr->{'proto'} =~ /^\\w+$/;\n        if ((($hdr_hr->{'sport'} !~ /any/i and $hdr_hr->{'sport'} ne '')\n                or ($hdr_hr->{'dport'} !~ /any/i\n                and $hdr_hr->{'dport'} ne ''))\n                and $hdr_hr->{'proto'} !~ /tcp/i\n                and $hdr_hr->{'proto'} !~ /udp/i) {\n            ### force to tcp because iptables does not like src/dst\n            ### ports with anything other than tcp or udp\n            $hdr_hr->{'proto'} = 'tcp';\n        }\n\n        if ($hdr_hr->{'proto'} =~ /ip/) {\n            $rule .= \" $ipt_hdr_opts{'proto'} $hdr_hr->{'proto'}\";\n        } else {\n            $rule .= \" $ipt_hdr_opts{'proto'} $hdr_hr->{'proto'} \" .\n                \"-m $hdr_hr->{'proto'}\";\n        }\n    }\n\n    ### append the source and destination ports\n    for my $type (qw(sport dport)) {\n        if (defined $hdr_hr->{$type} and $hdr_hr->{$type} !~ /any/i) {\n            my $negate = '';\n            my $port = $hdr_hr->{$type};\n            $negate = '! ' if $port =~ m|!|;\n            $port =~ s/\\!\\s*(\\d)/$1/;\n            if ($port =~ /,/) {\n                ### multiport match\n                $rule .= \" -m multiport ${negate}--${type}s $port\";\n            } else {\n                $rule .= \" ${negate}$ipt_hdr_opts{$type} $port\";\n            }\n        }\n    }\n\n    my $rv = &ipt_build_opts($rule, $hdr_hr, $opts_hr, $patterns_ar,\n        $orig_snort_rule, $flow_logging_prefix, $chain, $fwsnort_chain,\n        $add_snort_comment, $add_perl_trigger);\n\n    return $rv;\n}\n\nsub ipt_build_opts() {\n    my ($rule, $hdr_hr, $opts_hr, $patterns_ar, $orig_snort_rule,\n            $flow_logging_prefix, $chain, $fwsnort_chain, $add_snort_comment,\n            $add_perl_trigger) = @_;\n\n    ### append tcp flags\n    if (defined $opts_hr->{'flags'}) {\n        my $f_str = '';\n\n        $f_str .= 'URG,' if $opts_hr->{'flags'} =~ /U/i;\n        $f_str .= 'ACK,' if $opts_hr->{'flags'} =~ /A/i;\n        $f_str .= 'PSH,' if $opts_hr->{'flags'} =~ /P/i;\n        $f_str .= 'RST,' if $opts_hr->{'flags'} =~ /R/i;\n        $f_str .= 'SYN,' if $opts_hr->{'flags'} =~ /S/i;\n        $f_str .= 'FIN,' if $opts_hr->{'flags'} =~ /F/i;\n        $f_str =~ s/\\,$//;\n\n        if ($opts_hr->{'flags'} =~ /\\+/) {\n            ### --tcp-flags ACK ACK\n            $rule .= \" $snort_opts{'filter'}{'flags'}{'iptopt'} \" .\n                \"$f_str $f_str\";\n        } else {\n            ### --tcp-flags ALL URG,PSH,SYN,FIN\n            $rule .= \" $snort_opts{'filter'}{'flags'}{'iptopt'} \" .\n                \"ALL $f_str\";\n        }\n    }\n\n    if ($no_ipt_conntrack) {\n        ### fall back to appending --tcp-flags ACK ACK if flow=established.\n        ### NOTE: we can't really handle \"flow\" in the same way snort can,\n        ### since there is no way to keep track of which side initiated the\n        ### tcp session (where the SYN packet came from), but older versions\n        ### of snort (pre 1.9) just used tcp flags \"A+\" to keep track of\n        ### this... we need to do the same.\n        if (defined $opts_hr->{'flow'} && ! defined $opts_hr->{'flags'}) {\n            if ($opts_hr->{'flow'} =~ /established/i) {\n                ### note that this ignores the \"stateless\" keyword\n                ### as it should...\n                $rule .= \" $snort_opts{'filter'}{'flow'}{'iptopt'} ACK ACK\";\n            }\n        }\n    }\n\n    ### append icmp type\n    if ($hdr_hr->{'proto'} =~ /icmp/i) {\n        if (defined $opts_hr->{'itype'}) {\n            $rule .= \" $snort_opts{'filter'}{'itype'}{'iptopt'} \" .\n                \"$opts_hr->{'itype'}\";\n            ### append icmp code (becomes \"--icmp-type type/code\")\n            if (defined $opts_hr->{'icode'}) {\n                $rule .= \"/$opts_hr->{'icode'}\";\n            }\n        } else {\n            ### append the default icmp type since some recent versions of\n            ### iptables (such as 1.4.12 on Fedora 16) require it - an error\n            ### like the following will be thrown if it's not there:\n            ### iptables-restore v1.4.12: icmp: option \"--icmp-type\" must be specified\n            $rule .= \" $snort_opts{'filter'}{'itype'}{'iptopt'} \" .\n                $default_icmp_type;\n        }\n    }\n\n    ### append ip options\n    if (defined $opts_hr->{'ipopts'}) {\n        $rule .= \" $snort_opts{'filter'}{'ipopts'}{'iptopt'} \" .\n            \"--$opts_hr->{'ipopts'}\"\n    }\n\n    ### append tos (requires CONFIG_IP_NF_MATCH_TOS)\n    if (defined $opts_hr->{'tos'}) {\n        $rule .= \" $snort_opts{'filter'}{'tos'}{'iptopt'} \" .\n            \"$opts_hr->{'tos'}\"\n    }\n\n\n    ### append ttl (requires CONFIG_IP_NF_MATCH_TTL)\n    if (defined $opts_hr->{'ttl'}) {\n        if ($opts_hr->{'ttl'} =~ /\\<\\s*(\\d+)/) {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} --ttl-lt $1\";\n        } elsif ($opts_hr->{'ttl'} =~ /\\>\\s*(\\d+)/) {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} --ttl-gt $1\";\n        } else {\n            $rule .= \" $snort_opts{'filter'}{'ttl'}{'iptopt'} \" .\n                \"--ttl-eq $opts_hr->{'ttl'}\";\n        }\n    }\n\n    my $avg_hdr_len = &get_avg_hdr_len($hdr_hr);\n\n    ### append dsize option (requires CONFIG_IP_NF_MATCH_LENGTH)\n    if (defined $opts_hr->{'dsize'}) {\n        ### get the average packet header size based on the protocol\n        ### (the iptables length match applies to the network header\n        ### and up).\n        if ($opts_hr->{'dsize'} =~ m|(\\d+)\\s*<>\\s*(\\d+)|) {\n            my $iptables_len1 = $1 + $avg_hdr_len;\n            my $iptables_len2 = $2 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                \"$iptables_len1:$iptables_len2\";\n        } elsif ($opts_hr->{'dsize'} =~ m|<\\s*(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                \"$avg_hdr_len:$iptables_len\";\n        } elsif ($opts_hr->{'dsize'} =~ m|>\\s*(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            if ($iptables_len < $config{'MAX_FRAME_LEN'} + $avg_hdr_len) {\n                $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                    \"$iptables_len:\" .\n                    ($config{'MAX_FRAME_LEN'} + $avg_hdr_len);\n            }\n        } elsif ($opts_hr->{'dsize'} =~ m|(\\d+)|) {\n            my $iptables_len = $1 + $avg_hdr_len;\n            $rule .= \" $snort_opts{'filter'}{'dsize'}{'iptopt'} \" .\n                $iptables_len;\n        }\n    }\n\n    ### append snort content options\n    my $ipt_content_criteria = 0;\n    my $perl_trigger_str = '';\n\n    if ($#$patterns_ar > -1) {\n        ($ipt_content_criteria, $perl_trigger_str)\n            = &build_content_matches($opts_hr, $patterns_ar);\n\n        return 0 unless $ipt_content_criteria;\n        $rule .= $ipt_content_criteria;\n    }\n\n    ### print the rest of the logprefix snort options in a comment\n    ### one line above the rule\n    my $comment    = '';\n    my $target_str = '';\n    for my $key (qw(sid msg classtype reference priority rev)) {\n        if (defined $opts_hr->{$key}) {\n            $comment .= qq|$key:$opts_hr->{$key}; |;\n        }\n    }\n    $comment =~ s/\\s*$//;\n    $comment =~ s/,$//;\n\n    ### append the fwsnort version as \"FWS:$version\"\n    $comment .= \" FWS:$version;\";\n\n    ### build up the logging prefix and comment match\n    if (defined $opts_hr->{'sid'}) {\n        unless ($no_ipt_comments) {\n            ### add the Snort msg (and other) fields to the iptables rule\n            ### with the 'comment' match (which can handle up to 255 chars\n            ### and is set/verified by the ipt_find_max_comment_len()\n            ### function).\n            $comment =~ s|\\\"||g;\n            $comment =~ s|/\\*||g;\n            $comment =~ s|\\*/||g;\n            if (length($comment) < $ipt_max_comment_len) {\n                $target_str = qq| -m comment --comment \"$comment\"|;\n            }\n        }\n        ### increment chain counter and add in if necessary\n        $chain_ctr{$chain}++;\n\n        if ($queue_mode or $nfqueue_mode) {\n            if ($queue_mode) {\n                $target_str .= qq| -j QUEUE|;\n            } else {\n                $target_str .= qq| -j NFQUEUE|;\n                if ($nfqueue_num) {\n                    $target_str .= \" --queue-num $nfqueue_num\";\n                }\n            }\n        } else {\n            if ($hdr_hr->{'action'} eq 'log' or $ulog_mode) {\n                $target_str .= qq| -j ULOG --ulog-nlgroup $ulog_nlgroup --ulog-prefix \"|;\n            } else {\n                $target_str .= ' -j LOG ';\n                $target_str .= '--log-ip-options ' unless $no_ipt_log_ip_opts;\n                if ($hdr_hr->{'proto'} eq 'tcp') {\n                    $target_str .= '--log-tcp-options ' unless $no_ipt_log_tcp_opts;\n                    $target_str .= '--log-tcp-sequence ' if $ipt_log_tcp_seq;\n                }\n                $target_str .= qq|--log-prefix |;\n            }\n\n\n            ### build up the LOG prefix string\n            my $prefix_str = '';\n\n            unless ($no_ipt_rule_nums) {\n                $prefix_str .= \"[$chain_ctr{$chain}] \";\n            }\n\n            if ($ipt_drop) {\n                $prefix_str .= 'DRP ';\n            } elsif ($ipt_reject) {\n                $prefix_str .= 'REJ ';\n            }\n\n            ### always add the sid\n            $prefix_str .= qq|SID$opts_hr->{'sid'} |;\n            if ($flow_logging_prefix) {\n                $prefix_str .= 'ESTAB ';\n            }\n\n            if (length($prefix_str) >= $ipt_max_log_prefix_len) {\n                $prefix_str = qq|SID$opts_hr->{'sid'} |;\n                if (length($prefix_str) >= $ipt_max_log_prefix_len) {\n                    return 0 unless $ipt_content_criteria;\n                }\n            }\n\n            $target_str .= qq|\"| . $prefix_str . qq|\"|;\n        }\n    }\n\n    ### print the snort rules type header to the fwsnort.sh script\n    unless ($ipt_print_type) {\n        &ipt_type($snort_type);\n        $ipt_print_type = 1;\n    }\n\n    ### write the rule out to the iptables script\n    &ipt_add_rule($hdr_hr, $opts_hr, $orig_snort_rule,\n        $rule, $target_str, \"### $comment\", $add_snort_comment,\n        $perl_trigger_str, $add_perl_trigger, $chain, $fwsnort_chain);\n    return 1;\n}\n\nsub build_content_matches() {\n    my ($opts_hr, $patterns_ar) = @_;\n\n    my $fast_pattern_index   = 0;\n    my $fast_pattern_is_set  = 0;\n    my $ipt_content_criteria = '';\n    my $perl_trigger_command = '';\n    my @content_fast_pattern_order = ();\n\n    $perl_trigger_command = q|perl -e 'print \"| if $include_perl_triggers;\n\n    if ($no_fast_pattern_order) {\n        $patterns_ar->[0]->{'fast_pattern'} = 1;\n    }\n\n    for (my $index=0; $index <= $#$patterns_ar; $index++) {\n        if ($patterns_ar->[$index]->{'fast_pattern'}) {\n            $fast_pattern_index  = $index;\n            $fast_pattern_is_set = 1;\n            last;\n        }\n    }\n\n    unless ($fast_pattern_is_set) {\n        ### in this case, the 'fast_pattern' option was not used, so pick the\n        ### longest pattern to match first (this should help with performance\n        ### of signature matches on average)\n        my $max_len = 0;\n        my $max_len_index = 0;\n        PATTERN: for (my $index=0; $index <= $#$patterns_ar; $index++) {\n            my $pat_ar = $patterns_ar->[$index];\n\n            if ($pat_ar->{'length'} > $max_len) {\n\n                ### make sure it is not a relative match\n                next PATTERN if defined $pat_ar->{'distance'};\n                next PATTERN if defined $pat_ar->{'within'};\n\n                if ($index < $#$patterns_ar) {\n                    my $next_pat_ar = $patterns_ar->[$index+1];\n                    next PATTERN if defined $next_pat_ar->{'distance'};\n                    next PATTERN if defined $next_pat_ar->{'within'};\n                }\n\n                $max_len = $pat_ar->{'length'};\n                $max_len_index = $index;\n            }\n        }\n        $fast_pattern_index = $max_len_index;\n    }\n\n    $content_fast_pattern_order[0] = $patterns_ar->[$fast_pattern_index];\n    for (my $i=0; $i <= $#$patterns_ar; $i++) {\n        next if $i == $fast_pattern_index;\n        push @content_fast_pattern_order, $patterns_ar->[$i];\n    }\n\n    for (my $i=0; $i <= $#content_fast_pattern_order; $i++) {\n\n        if (($queue_mode or $nfqueue_mode) and $queue_pre_match_max > 0) {\n            ### limit the number of content matches to perform within the\n            ### kernel before sending the packet to a userspace Snort\n            ### instance\n            last if $i >= $queue_pre_match_max;\n        }\n\n        my $pattern_hr = $content_fast_pattern_order[$i];\n        my $content_str = $pattern_hr->{'ipt_pattern'};\n\n        if ($content_str =~ /\\|.+\\|/) {\n            ### there is hex data in the content\n            if ($pattern_hr->{'negative_match'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{! --hex-string \"$content_str\"};\n            } else {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{--hex-string \"$content_str\"};\n            }\n        } else {\n            ### there is no hex data in the content\n            if ($pattern_hr->{'negative_match'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{! --string \"$content_str\"};\n            } else {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'content'}{'iptopt'} . ' ' .\n                    qq{--string \"$content_str\"};\n            }\n        }\n\n        if (defined $opts_hr->{'replace'}) {\n            my $replace_str = $opts_hr->{'replace'};\n            $replace_str =~ s/`/\\\\`/g;\n            if ($replace_str =~ /\\|.+\\|/) {  ### there is hex data in the content\n                $ipt_content_criteria\n                        .= qq{ --replace-hex-string \"$replace_str\"};\n            } else {\n                $ipt_content_criteria\n                        .= qq{ --replace-string \"$replace_str\"};\n            }\n        }\n\n        if ($kernel_ver ne '2.4') {\n            $ipt_content_criteria .= \" --algo $string_match_alg\";\n\n            ### see if we have any offset, depth, distance, or within\n            ### criteria\n\n            if (defined $pattern_hr->{'offset'}) {\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'offset'}{'iptopt'} . \" $pattern_hr->{'offset'}\";\n                $perl_trigger_command .= 'A'x$pattern_hr->{'offset'}\n                    if $include_perl_triggers;\n\n            } elsif (defined $pattern_hr->{'distance'}) {  ### offset trumps distance\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'distance'}{'iptopt'} . \" $pattern_hr->{'distance'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'distance'}\n                    if $include_perl_triggers;\n            }\n\n            if (defined $pattern_hr->{'depth'}) {\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'depth'}{'iptopt'} . \" $pattern_hr->{'depth'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'depth'}\n                    if $include_perl_triggers;\n\n            } elsif (defined $pattern_hr->{'within'}) {  ### depth trumps within\n\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'within'}{'iptopt'} . \" $pattern_hr->{'within'}\";\n\n                $perl_trigger_command .= 'A'x$pattern_hr->{'within'}\n                    if $include_perl_triggers;\n            }\n\n            ### see if we need to match the string match case insensitive\n            if ($pattern_hr->{'nocase'}) {\n                $ipt_content_criteria .= ' ' . $snort_opts{'filter'}\n                    {'nocase'}{'iptopt'};\n            }\n\n            ### if the --payload option is available for\n            ### the string match extension\n            $ipt_content_criteria .= ' --payload'\n                if $ipt_has_string_payload_offset_opt;\n        }\n\n        if ($include_perl_triggers) {\n            ### now append the perl trigger command bytes\n            if ($pattern_hr->{'negative_match'}) {\n                $perl_trigger_command .= 'A'x($pattern_hr->{'length'});\n            } else {\n                $perl_trigger_command .= &translate_perl_trigger($content_str);\n            }\n        }\n    }\n\n    if ($include_perl_triggers) {\n        $perl_trigger_command .= qq|\"'|;\n    }\n\n    return $ipt_content_criteria, $perl_trigger_command;\n}\n\nsub convert_pattern_for_iptables() {\n    my $snort_str = shift;\n\n    my $rv = 0;\n    my $ipt_str = $snort_str;\n    my $log_str = '';\n\n    my %pattern = (\n        'orig_snort_str' => $snort_str,\n        'ipt_pattern'    => '',\n        'negative_match' => 0,\n        'fast_pattern'   => 0,\n        'nocase'         => 0,\n    );\n\n    if ($ipt_str =~ /^\\s*\\!\\s*\"/) {\n        $ipt_str =~ s/^\\s*\\!\\s*\"//;\n        $pattern{'negative_match'} = 1;\n    }\n\n    ### convert all escaped chars to their hex equivalents\n    $ipt_str =~ s/\\x5c(.)/sprintf \"|%02x|\", (ord($1))/eg;\n\n    ### consolidate any consecutive \"|aa||bb|\" sequences\n    $ipt_str =~ s/\\|\\|//g;\n\n    ### remove all spaces between hex codes (they simply waste space\n    ### on the command line, and they aren't part of the string to\n    ### search in network traffic anyway).\n    $ipt_str = &consolidate_hex_spaces($ipt_str);\n\n    ### if there are any existing hex blocks or if there are any chars\n    ### that require a new hex block, then just convert the whole string\n    ### to hex syntax for simplicity\n    if ($ipt_str =~ /\\|/ or &have_hex_char($ipt_str)) {\n        $ipt_str = &convert_str_to_hex($ipt_str);\n    }\n\n    ### if we ever have more than one hex block then there was some\n    ### pattern translation error\n    my $hex_ctr = 0;\n    while ($ipt_str =~ /\\|/g) {\n        $hex_ctr++;\n        last if $hex_ctr >= 10;\n    }\n\n    if ($hex_ctr > 2) {\n        return 0, \"too many hex blocks, could not translate: $snort_str\",\n            \\%pattern;\n    }\n\n    ### handles length of hex blocks\n    my $content_len = &get_content_len($ipt_str);\n    if ($content_len >= $ipt_max_str_len\n            or $content_len >= $config{'MAX_STRING_LEN'}) {\n        return 0, \"pattern too long: $snort_str\", \\%pattern;\n    }\n\n    $pattern{'ipt_pattern'} = $ipt_str;\n    $pattern{'length'}      = $content_len;\n\n    return 1, $log_str, \\%pattern;\n}\n\nsub define_offsets() {\n    my ($patterns_ar, $avg_hdr_len, $opt, $val) = @_;\n\n    my $current_index = $#$patterns_ar;\n\n    ### the option should not be defined - if so, there is a duplicate\n    ### Snort keyword in the signature\n    if (defined $patterns_ar->[$current_index]->{$opt}) {\n        return 0, \"duplicate keyword: $opt\";\n    }\n\n    ### store the value that was in the original Snort rule\n    $patterns_ar->[$current_index]->{\"${opt}_snort_orig\"} = $val;\n\n    ### store the value and account for average header length if\n    ### necessary\n    if ($ipt_has_string_payload_offset_opt) {\n        $patterns_ar->[$current_index]->{$opt} = $val;\n    } else {\n        $patterns_ar->[$current_index]->{$opt}\n            = $val + $avg_hdr_len + $MAC_HDR_LEN;\n    }\n\n    return 1, '';\n}\n\nsub update_offsets_relative_matches() {\n    my $patterns_ar = shift;\n\n    for (my $i=0; $i <= $#$patterns_ar; $i++) {\n\n        my $pat_hr = $patterns_ar->[$i];\n        my $snort_offset   = -1;\n        my $snort_depth    = -1;\n        my $snort_distance = -1;\n        my $snort_within   = -1;\n\n        $snort_offset = $pat_hr->{'offset_snort_orig'}\n            if defined $pat_hr->{'offset_snort_orig'};\n        $snort_depth = $pat_hr->{'depth_snort_orig'}\n            if defined $pat_hr->{'depth_snort_orig'};\n        $snort_distance = $pat_hr->{'distance_snort_orig'}\n            if defined $pat_hr->{'distance_snort_orig'};\n        $snort_within = $pat_hr->{'within_snort_orig'}\n            if defined $pat_hr->{'within_snort_orig'};\n\n        if ($snort_depth > -1) {\n            ### if there is also an offset, then the depth begins after\n            ### the offset starts\n            if ($snort_offset > -1) {\n                $pat_hr->{'depth'} += $snort_offset;\n            } elsif ($snort_distance > -1) {\n                $pat_hr->{'depth'} += $snort_distance;\n            }\n            if ($snort_depth < $pat_hr->{'length'}) {\n                return 0, \"depth: $snort_depth less than \" .\n                    \"pattern length: $pat_hr->{'length'}\";\n            }\n        }\n\n        if ($snort_distance > -1) {\n            ### see if we need to increase the distance based\n            ### on the length of the previous pattern match and offset\n            if ($i > 0) {\n                my $prev_pat_hr = $patterns_ar->[$i-1];\n                $pat_hr->{'distance'} += $prev_pat_hr->{'length'};\n                if (defined $prev_pat_hr->{'offset_snort_orig'}) {\n                    $pat_hr->{'distance'} += $prev_pat_hr->{'offset_snort_orig'};\n                }\n            }\n        }\n\n        if ($snort_within > -1) {\n            if ($snort_offset > -1) {\n                $pat_hr->{'within'} += $snort_offset;\n            } elsif ($snort_distance > -1) {\n                $pat_hr->{'within'} += $snort_distance;\n            }\n            if ($i > 0) {\n                my $prev_pat_hr = $patterns_ar->[$i-1];\n                $pat_hr->{'within'} += $prev_pat_hr->{'length'};\n                if (defined $prev_pat_hr->{'offset_snort_orig'}) {\n                    $pat_hr->{'within'} += $prev_pat_hr->{'offset_snort_orig'};\n                }\n            }\n        }\n    }\n    return 1, '';\n}\n\nsub get_avg_hdr_len() {\n    my $hdr_hr = shift;\n\n    my $avg_hdr_len = $config{'AVG_IP_HEADER_LEN'};\n    if (defined $hdr_hr->{'proto'}) {\n        if ($hdr_hr->{'proto'} =~ /udp/i) {\n            $avg_hdr_len += $UDP_HDR_LEN;  ### udp header is 8 bytes\n        } elsif ($hdr_hr->{'proto'} =~ /icmp/i) {\n            $avg_hdr_len += $ICMP_HDR_LEN;  ### icmp header is 8 bytes\n        } else {\n            ### default to TCP\n            $avg_hdr_len += $config{'AVG_TCP_HEADER_LEN'};\n        }\n    } else {\n        ### don't know what the average transport layer (if there\n        ### is one) length will be; add 10 bytes just to be safe\n        $avg_hdr_len += 10;\n    }\n    return $avg_hdr_len;\n}\n\n### handles length of hex blocks\nsub get_content_len() {\n    my $str = shift;\n    my $len = 0;\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    for (my $i=0; $i<=$#chars; $i++) {\n        if ($chars[$i] eq '|') {\n            $hex_mode == 0 ? ($hex_mode = 1) : ($hex_mode = 0);\n            next;\n        }\n        if ($hex_mode) {\n            next if $chars[$i] eq ' ';\n            $len++;\n            $i++;\n        } else {\n            $len++;\n        }\n    }\n    return $len;\n}\n\nsub consolidate_hex_spaces() {\n    my $str = shift;\n\n    my $new_str = '';\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    for my $char (@chars) {\n        if ($char eq '|') {\n            $hex_mode == 0 ? ($hex_mode = 1) : ($hex_mode = 0);\n        }\n        if ($hex_mode) {\n            next if $char eq ' ';\n        }\n        $new_str .= $char;\n    }\n    return $new_str;\n}\n\nsub have_hex_char() {\n    my $str = shift;\n    return 1 if $str =~ /[^A-Za-z0-9]/;\n    return 0;\n}\n\nsub convert_str_to_hex() {\n    my $str = shift;\n\n    my $new_str = '';\n    my $hex_mode = 0;\n    my @chars = split //, $str;\n    CHAR: for my $char (@chars) {\n        if ($char eq '|') {\n            if ($hex_mode) {\n                $new_str .= $char;\n                $hex_mode = 0;\n            } else {\n                $new_str .= $char;\n                $hex_mode = 1;\n            }\n            next CHAR;\n        }\n        if ($hex_mode) {\n            $new_str .= $char;\n        } else {\n            $new_str .= sprintf \"|%02x|\", ord($char);\n        }\n    }\n\n    ### consolidate any consecutive \"|aa||bb|\" sequences\n    $new_str =~ s/\\|\\|//g;\n\n    return $new_str;\n}\n\nsub translate_perl_trigger() {\n    my $str = shift;\n    my $trigger_str = '';\n    my $hex_mode = 0;\n    my $append_hex_str = '';\n    my $append_non_hex_str = '';\n\n    my @chars = split //, $str;\n\n    for my $char (@chars) {\n        if ($char eq '|') {\n            if ($hex_mode) {\n                if ($append_hex_str) {\n                    while ($append_hex_str =~ /(.{2})/g) {\n                        $trigger_str .= \"\\\\x$1\";\n                    }\n                    $append_hex_str = '';\n                }\n                $hex_mode = 0;\n            } else {\n                if ($append_non_hex_str) {\n                    $trigger_str .= qq|$append_non_hex_str|;\n                    $append_non_hex_str = '';\n                }\n                $hex_mode = 1;\n            }\n            next;\n        }\n\n        if ($hex_mode) {\n            $append_hex_str .= $char;\n        } else {\n            $append_non_hex_str .= $char;\n        }\n    }\n\n    if ($append_hex_str) {\n        while ($append_hex_str =~ /(.{2})/g) {\n            $trigger_str .= \"\\\\x$1\";\n        }\n    }\n    $trigger_str .= qq|$append_non_hex_str| if $append_non_hex_str;\n\n    return $trigger_str;\n}\n\nsub ipt_add_rule() {\n    my ($hdr_hr, $opts_hr, $orig_snort_rule, $rule_base,\n        $target_str, $comment, $add_snort_comment,\n        $perl_trigger_str, $add_perl_trigger, $chain, $fwsnort_chain) = @_;\n\n    my $action_rule = '';\n    if ($hdr_hr->{'proto'} eq 'tcp') {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            if (defined $opts_hr->{'resp'}\n                    and $opts_hr->{'resp'} =~ /rst/i) {\n                ### iptables can only send tcp resets to the connection\n                ### client, so we can't support rst_rcv, but we should\n                ### try to tear the connection down anyway.\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with tcp-reset\";\n            } elsif ($ipt_drop) {\n                $action_rule = \"$rule_base -j DROP\";\n            } elsif ($ipt_reject) {\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with tcp-reset\";\n            }\n        }\n    } elsif ($hdr_hr->{'proto'} eq 'udp') {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            if (defined $opts_hr->{'resp'}\n                    and $opts_hr->{'resp'} =~ /icmp/i) {\n                if ($opts_hr->{'resp'} =~ /all/i) {  ### icmp_all\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-port-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /net/i) {  ### icmp_net\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-net-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /host/i) {  ### icmp_host\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-host-unreachable\";\n                } elsif ($opts_hr->{'resp'} =~ /port/i) {  ### icmp_port\n                    $action_rule = \"$rule_base -j REJECT \" .\n                        \"--reject-with icmp-port-unreachable\";\n                }\n            } elsif ($ipt_drop) {\n                $action_rule = \"$rule_base -j DROP\";\n            } elsif ($ipt_reject) {\n                $action_rule = \"$rule_base -j REJECT \" .\n                    \"--reject-with icmp-port-unreachable\";\n            }\n        }\n    } else {\n        if ($hdr_hr->{'action'} eq 'pass') {\n            $action_rule = \"$rule_base -j ACCEPT\";\n        } else {\n            $action_rule = \"$rule_base -j DROP\";\n        }\n    }\n    my $ipt_rule = $rule_base . $target_str;\n\n    push @ipt_script_lines, \"\\n### $orig_snort_rule\" if $add_snort_comment;\n    if ($include_perl_triggers and $add_perl_trigger) {\n        push @ipt_script_lines, \"### $perl_trigger_str\";\n    }\n    if ($verbose) {\n        push @ipt_script_lines, qq|\\$ECHO \"[+] rule $ipt_rule_ctr\"|;\n    }\n\n    ### save format handling\n    my $save_format_ipt_rule    = $ipt_rule . \" \\n\";\n    my $save_format_action_rule = $action_rule . \" \\n\";\n\n    $save_format_ipt_rule    =~ s|\\$${ipt_var_str}\\s+\\-A|-A|;\n    $save_format_action_rule =~ s|\\$${ipt_var_str}\\s+\\-A|-A|;\n\n    if ($hdr_hr->{'action'} ne 'pass') {\n        if ($queue_mode or $nfqueue_mode) {\n\n            push @ipt_script_lines, $ipt_rule;\n            push @{$save_format_rules{$fwsnort_chain}}, $save_format_ipt_rule;\n\n        } else {\n\n            push @ipt_script_lines, $ipt_rule unless $no_ipt_log;\n            push @{$save_format_rules{$fwsnort_chain}}, $save_format_ipt_rule\n                unless $no_ipt_log;\n        }\n    }\n\n    if ($action_rule and ($ipt_drop or $ipt_reject or\n            $hdr_hr->{'action'} eq 'pass' or defined $opts_hr->{'resp'})) {\n\n        push @ipt_script_lines, $action_rule;\n        push @{$save_format_rules{$fwsnort_chain}}, $save_format_action_rule;\n    }\n\n    $ipt_rule_ctr++;\n    return;\n}\n\nsub save_format_append_rules() {\n\n     for my $chain (sort keys %ipt_save_existing_chains) {\n\n        next unless &is_fwsnort_chain($chain, $MATCH_EQUIV);\n\n        ### make sure that whitelist/blacklist and established jump rules\n        ### are added at the beginning of each chain in save format\n        &save_format_add_prereqs($chain);\n\n        for my $rule (@{$save_format_rules{$chain}}) {\n\n            push @fwsnort_save_lines, $rule;\n        }\n    }\n\n    ### now append any last lines from the iptables-save output that\n    ### had nothing to do with fwsnort (other custom chains, etc.)\n    for (my $i = $ipt_save_index; $i <= $#ipt_save_lines; $i++) {\n        next if &is_fwsnort_chain($ipt_save_lines[$i], $MATCH_SUBSTR);\n        push @fwsnort_save_lines, $ipt_save_lines[$i];\n    }\n\n    return;\n}\n\nsub save_format_add_prereqs() {\n    my $chain = shift;\n\n    return if defined $save_format_prereqs{$chain};\n\n    ### add whitelist\n    if (defined $save_format_whitelist{$chain}) {\n        for my $whitelist_rule (@{$save_format_whitelist{$chain}}) {\n            push @fwsnort_save_lines, \"$whitelist_rule \\n\";\n        }\n    }\n\n    ### add blacklist\n    if (defined $save_format_blacklist{$chain}) {\n        for my $blacklist_rule (@{$save_format_blacklist{$chain}}) {\n            push @fwsnort_save_lines, \"$blacklist_rule \\n\";\n        }\n    }\n\n    ### add jump rules into the connection tracking fwsnort chains\n    if (defined $save_format_conntrack_jumps{$chain}) {\n        for my $jump_rule (@{$save_format_conntrack_jumps{$chain}}) {\n            push @fwsnort_save_lines, \"$jump_rule \\n\";\n        }\n    }\n\n    $save_format_prereqs{$chain} = '';\n\n    return;\n}\n\nsub ipt_whitelist() {\n    my @whitelist_addrs = ();\n\n    for my $whitelist_line (@{$config{'WHITELIST'}}) {\n        for my $addr (@{&expand_addresses($whitelist_line)}) {\n            push @whitelist_addrs, $addr;\n        }\n    }\n\n    return unless $#whitelist_addrs >= 0;\n\n    push @ipt_script_lines, \"\\n###\\n############ Add IP/network \" .\n        \"WHITELIST rules. ############\\n###\";\n\n    for my $addr (@whitelist_addrs) {\n        for my $chain (keys %process_chains) {\n            next unless $process_chains{$chain};\n\n            if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                    \"-s $addr -j RETURN\";\n                push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n\n                push @{$save_format_whitelist{$config{\"FWSNORT_$chain\"}}},\n                    $rule_str;\n            }\n            if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n                my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                    \"-d $addr -j RETURN\";\n                push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n\n                push @{$save_format_whitelist{$config{\"FWSNORT_$chain\"}}},\n                    $rule_str;\n            }\n        }\n    }\n    return;\n}\n\nsub ipt_blacklist() {\n\n    my $printed_intro = 0;\n\n    for my $blacklist_line (@{$config{'BLACKLIST'}}) {\n\n        my @blacklist_addrs = ();\n        my $target = 'DROP';  ### default\n\n        if ($blacklist_line =~ /\\s+REJECT/) {\n            $target = 'REJECT';\n        }\n\n        for my $addr (@{&expand_addresses($blacklist_line)}) {\n            push @blacklist_addrs, $addr;\n        }\n\n        return unless $#blacklist_addrs >= 0;\n\n        unless ($printed_intro) {\n            push @ipt_script_lines, \"\\n###\\n############ Add IP/network \" .\n                \"BLACKLIST rules. ############\\n###\";\n            $printed_intro = 1;\n        }\n\n        for my $addr (@blacklist_addrs) {\n            for my $chain (keys %process_chains) {\n                next unless $process_chains{$chain};\n\n                if ($target eq 'DROP') {\n                    if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                            \"-s $addr -j DROP\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n\n                    if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} | .\n                            \"-d $addr -j DROP\";\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                } else {\n                    if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p tcp -j REJECT --reject-with tcp-reset\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p udp -j REJECT --reject-with icmp-port-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -s $addr | .\n                            \"-p icmp -j REJECT --reject-with icmp-host-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                    if ($chain eq 'OUTPUT' or $chain eq 'FORWARD') {\n                        my $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p tcp -j REJECT --reject-with tcp-reset\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p udp -j REJECT --reject-with icmp-port-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n\n                        $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -d $addr | .\n                            \"-p icmp -j REJECT --reject-with icmp-host-unreachable\";\n\n                        push @ipt_script_lines, \"\\$${ipt_var_str} $rule_str\";\n                        push @{$save_format_blacklist{$config{\"FWSNORT_$chain\"}}},\n                            $rule_str;\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub ipt_add_chains() {\n\n    ### save format\n    my %ipt_save_built_in_chains = ();\n    my $look_for_chains = 0;\n    for (@ipt_save_lines) {\n        unless ($look_for_chains) {\n            push @fwsnort_save_lines, $_;\n        }\n        if (/^\\*filter/) {\n            $look_for_chains = 1;\n        } elsif ($look_for_chains and $_ =~ /^:(\\S+)/) {\n            my $chain = $1;\n            if ($chain eq 'INPUT'\n                    or $chain eq 'OUTPUT'\n                    or $chain eq 'FORWARD') {\n                $ipt_save_built_in_chains{$chain} = $_;\n            } else {\n                ### don't preserve any old fwsnort chains, but preserve\n                ### any other existing custom chains\n                unless (&is_fwsnort_chain($chain, $MATCH_EQUIV)) {\n                    $ipt_save_existing_chains{$chain} = $_;\n                }\n            }\n        } elsif ($look_for_chains and $_ !~ /^:(\\S+)/) {\n            last;\n        }\n        $ipt_save_index++;\n    }\n\n    ### save format - add the built-in chains first\n    for my $chain (qw(INPUT FORWARD OUTPUT)) {\n        ### should always be defined unless we're not running as root\n        next unless defined $ipt_save_built_in_chains{$chain};\n        push @fwsnort_save_lines, $ipt_save_built_in_chains{$chain};\n    }\n\n    ### add the fwsnort chains\n    push @ipt_script_lines, \"\\n###\\n############ Create \" .\n        \"fwsnort $ipt_str chains. ############\\n###\";\n\n    for my $built_in_chain (qw(INPUT FORWARD OUTPUT)) {\n\n        ### see if any of the \"FWSNORT_<built-in-chain>\" chains need to be\n        ### excluded\n        next unless $process_chains{$built_in_chain};\n\n        for my $chain ($config{\"FWSNORT_$built_in_chain\"},\n                $config{\"FWSNORT_${built_in_chain}_ESTAB\"}) {\n            if ($no_ipt_conntrack) {\n                next if $chain eq\n                    $config{\"FWSNORT_${built_in_chain}_ESTAB\"};\n            }\n            push @ipt_script_lines,\n                \"\\$${ipt_var_str} -N $chain 2> /dev/null\",\n                \"\\$${ipt_var_str} -F $chain\\n\";\n\n            ### save format\n            $ipt_save_existing_chains{$chain} = \":$chain - [0:0]\\n\";\n        }\n    }\n\n    ### save format - add the custom chains\n    for my $chain (sort keys %ipt_save_existing_chains) {\n        push @fwsnort_save_lines, $ipt_save_existing_chains{$chain};\n    }\n\n    ### save format - add in the jump rules from the\n    ### built-in chains here\n    &save_format_add_jump_rules();\n\n    ### add in any rules from custom chains that alphabetically come\n    ### before the first fwsnort chain\n    &save_format_add_early_custom_chains();\n\n    return;\n}\n\nsub save_format_add_jump_rules() {\n\n    ### add the jump rule for each built-in chain\n    for my $built_in_chain (qw(INPUT FORWARD OUTPUT)) {\n\n        next unless defined $process_chains{$built_in_chain}\n            and $process_chains{$built_in_chain};\n\n        ### get the current $chain rules (if any), and then see where to add\n        ### the fwsnort jump rule\n\n        my @existing_chain_rules = ();\n\n        for (my $i = $ipt_save_index; $i < $#ipt_save_lines; $i++) {\n\n            ### delete any existing fwsnort jump rules\n            if ($ipt_save_lines[$i] =~ /^\\-A\\s$built_in_chain\\s/) {\n                if ($ipt_save_lines[$i] !~ /\\-j\\sFWSNORT_/) {\n                    push @existing_chain_rules, $ipt_save_lines[$i];\n                }\n            } else {\n                last;\n            }\n            $ipt_save_index++;\n        }\n\n        my $ctr = 1;\n        my $added_jump_rule = 0;\n        for my $existing_rule (@existing_chain_rules) {\n            if ($ctr == $config{\"FWSNORT_${built_in_chain}_JUMP\"}) {\n                &save_format_add_chain_jump_rule($built_in_chain);\n                $added_jump_rule = 1;\n            }\n\n            push @fwsnort_save_lines, $existing_rule;\n            $ctr++;\n        }\n\n        ### the chain may have been empty\n        unless ($added_jump_rule) {\n            &save_format_add_chain_jump_rule($built_in_chain);\n        }\n    }\n\n    return;\n}\n\nsub save_format_add_chain_jump_rule() {\n    my $built_in_chain = shift;\n    my $fwsnort_chain = \"FWSNORT_${built_in_chain}\";\n    if (%restrict_interfaces) {\n        for my $intf (keys %restrict_interfaces) {\n            if ($built_in_chain eq 'INPUT' or $built_in_chain eq 'FORWARD') {\n                push @fwsnort_save_lines, \"-A $built_in_chain -i $intf \" .\n                    \"-j $fwsnort_chain \\n\";\n            } elsif ($built_in_chain eq 'OUTPUT') {\n                push @fwsnort_save_lines, \"-A $built_in_chain -o $intf \" .\n                    \"-j $fwsnort_chain \\n\";\n            }\n        }\n    } else {\n        if ($no_exclude_loopback) {\n            push @fwsnort_save_lines, \"-A $built_in_chain \" .\n                \"-j $fwsnort_chain \\n\";\n        } else {\n            if ($built_in_chain eq 'INPUT' or $built_in_chain eq 'FORWARD') {\n                push @fwsnort_save_lines, \"-A $built_in_chain ! -i lo \" .\n                    \"-j $fwsnort_chain \\n\";\n            } elsif ($built_in_chain eq 'OUTPUT') {\n                push @fwsnort_save_lines, \"-A $built_in_chain ! -o lo \" .\n                    \"-j $fwsnort_chain \\n\";\n            }\n        }\n    }\n\n    return;\n}\n\nsub save_format_add_early_custom_chains() {\n\n    for my $chain (sort keys %ipt_save_existing_chains) {\n        last if &is_fwsnort_chain($chain, $MATCH_EQUIV);\n\n        for (my $i = $ipt_save_index; $i <= $#ipt_save_lines; $i++) {\n            last if &is_fwsnort_chain($ipt_save_lines[$i], $MATCH_SUBSTR);\n            push @fwsnort_save_lines, $ipt_save_lines[$i];\n            $ipt_save_index++;\n        }\n    }\n\n    return;\n}\n\nsub is_fwsnort_chain() {\n    my ($str, $match_style) = @_;\n    my $rv = 0;\n\n    for my $fwsnort_chain ($config{'FWSNORT_INPUT'},\n            $config{'FWSNORT_INPUT_ESTAB'},\n            $config{'FWSNORT_FORWARD'},\n            $config{'FWSNORT_FORWARD_ESTAB'},\n            $config{'FWSNORT_OUTPUT'},\n            $config{'FWSNORT_OUTPUT_ESTAB'}) {\n\n        if ($match_style eq $MATCH_SUBSTR) {\n            if ($str =~ /$fwsnort_chain/) {\n                $rv = 1;\n                last;\n            }\n        } elsif ($match_style eq $MATCH_EQUIV) {\n            if ($str eq $fwsnort_chain) {\n                $rv = 1;\n                last;\n            }\n        }\n    }\n\n    return $rv;\n}\n\nsub ipt_add_conntrack_jumps() {\n    ### jump ESTABLISHED tcp traffic to each of the _ESTAB\n    ### chains\n    push @ipt_script_lines, \"\\n###\\n############ Inspect $conntrack_state \" .\n        \"tcp connections. ############\\n###\";\n\n    for my $chain (keys %process_chains) {\n        next unless $process_chains{$chain};\n\n        my $rule_str = '';\n\n        if ($have_conntrack) {\n            $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -p tcp -m conntrack | .\n                qq|--ctstate $conntrack_state -j | .\n                qq|$config{\"FWSNORT_${chain}_ESTAB\"}|;\n        } elsif ($have_state) {\n            $rule_str = qq|-A $config{\"FWSNORT_$chain\"} -p tcp -m state | .\n                qq|--state $conntrack_state -j | .\n                qq|$config{\"FWSNORT_${chain}_ESTAB\"}|;\n        }\n        next unless $rule_str;\n\n        push @ipt_script_lines, qq|\\$${ipt_var_str} $rule_str|;\n        push @{$save_format_conntrack_jumps{$config{\"FWSNORT_$chain\"}}},\n            $rule_str;\n    }\n    return;\n}\n\nsub ipt_jump_chain() {\n    push @ipt_script_lines, \"\\n###\\n############ Jump traffic \" .\n        \"to the fwsnort chains. ############\\n###\";\n    if (%restrict_interfaces) {\n        for my $intf (keys %restrict_interfaces) {\n            for my $chain (keys %process_chains) {\n                next unless $process_chains{$chain};\n\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n                    ### delete any existing jump rule so that fwsnort.sh can\n                    ### be executed many times in a row without adding several\n                    ### jump rules\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|-i $intf -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    ### now add the jump rule\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} -i | .\n                        qq|$intf -j $config{\"FWSNORT_$chain\"}|;\n                } elsif ($chain eq 'OUTPUT') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|-o $intf -j $config{'FWSNORT_OUTPUT'}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{'FWSNORT_OUTPUT_JUMP'} -o | .\n                        qq|$intf -j $config{'FWSNORT_OUTPUT'}|;\n                }\n            }\n        }\n    } else {\n        for my $chain (keys %process_chains) {\n            next unless $process_chains{$chain};\n\n            if ($no_exclude_loopback) {\n\n                push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                    qq|-j $config{\"FWSNORT_$chain\"}| .\n                    ' 2> /dev/null';\n\n                push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                    qq|$config{\"FWSNORT_${chain}_JUMP\"} | .\n                    qq|-j $config{\"FWSNORT_$chain\"}|;\n            } else {\n                if ($chain eq 'INPUT' or $chain eq 'FORWARD') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|! -i lo -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} ! -i lo | .\n                        qq|-j $config{\"FWSNORT_$chain\"}|;\n\n                } elsif ($chain eq 'OUTPUT') {\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -D $chain \" .\n                        qq|! -o lo -j $config{\"FWSNORT_$chain\"}| .\n                        ' 2> /dev/null';\n\n                    push @ipt_script_lines, \"\\$${ipt_var_str} -I $chain \" .\n                        qq|$config{\"FWSNORT_${chain}_JUMP\"} ! -o lo | .\n                        qq|-j $config{\"FWSNORT_$chain\"}|;\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub hdr_lines() {\n    return\n        \"#!$cmds{'sh'}\\n#\", '#'x76,\n        \"#\\n# File:  $config{'FWSNORT_SCRIPT'}\",\n        \"#\\n# Purpose:  This script was auto-\" .\n        \"generated by fwsnort, and implements\",\n        \"#           an $ipt_str ruleset based upon \" .\n        \"Snort rules.  For more\",\n        \"#           information see the fwsnort man \" .\n        \"page or the documentation\",\n        \"#           available at \" .\n        \"http://www.cipherdyne.org/fwsnort/\",\n        \"#\\n# Generated with:     fwsnort @argv_cp\",\n        \"# Generated on host:  \" . hostname(),\n        \"# Time stamp:         \" . localtime(),\n        \"#\\n# Author:  Michael Rash <mbr\\@cipherdyne.org>\",\n        \"#\\n# Version: $version\",\n        \"#\", '#'x76, \"#\\n\";\n}\n\nsub ipt_hdr() {\n    push @ipt_script_lines, &hdr_lines();\n    push @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n\n    ### add paths to system binaries (iptables included)\n    &ipt_config_section();\n    return;\n}\n\nsub ipt_config_section() {\n    ### build the config section of the iptables script\n    push @ipt_script_lines,\n        '#==================== config ====================',\n        \"ECHO=$cmds{'echo'}\",\n        \"${ipt_var_str}=$ipt_bin\",\n        \"#================== end config ==================\\n\";\n    push @ipt_save_script_lines, $ipt_script_lines[$#ipt_script_lines];\n    return;\n}\n\nsub ipt_type() {\n    my $type = shift;\n    push @ipt_script_lines, \"\\n###\\n############ ${type}.rules #######\" .\n        \"#####\\n###\", \"\\$ECHO \\\"[+] Adding $type rules:\\\"\";\n    return;\n}\n\nsub check_type() {\n    for my $type_hr (\\%include_types, \\%exclude_types) {\n        for my $type (keys %$type_hr) {\n            my $found = 0;\n            my @valid_types = ();\n            for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n                if (-e \"$dir/${type}.rules\") {\n                    $found = 1;\n                } else {\n                    opendir D, $dir or die \"[*] Could not open $dir: $!\";\n                    for my $file (readdir D) {\n                        if ($file =~ /(\\S+)\\.rules/) {\n                            push @valid_types, $1;\n                        }\n                    }\n                }\n            }\n            unless ($found) {\n                print \"[-] \\\"$type\\\" is not a valid type.\\n\",\n                \"    Choose from the following available signature types:\\n\";\n                for my $type (sort @valid_types) {\n                    print \"        $type\\n\";\n                }\n                die \"[-] Exiting.\";\n            }\n        }\n    }\n    return;\n}\n\nsub import_config() {\n    open C, \"< $fwsnort_conf\" or die \"[*] Could not open $fwsnort_conf: $!\";\n    my @lines = <C>;\n    close C;\n    my $l_ctr = 0;\n    for my $line (@lines) {\n        $l_ctr++;\n        chomp $line;\n        next if $line =~ /^\\s*#/;\n        next unless $line =~ /\\S/;\n        if ($line =~ /^\\s*(\\S+)Cmd\\s+(\\S+);/) {  ### e.g. \"iptablesCmd\"\n            $cmds{$1} = $2;\n        } elsif ($line =~ /^\\s*(\\S+)\\s+(.*?);/) {\n            my $var = $1;\n            my $val = $2;\n            die \"[*] $fwsnort_conf: Variable \\\"$var\\\" is set to\\n\",\n                \"    _CHANGEME_ at line $l_ctr.  Edit $fwsnort_conf.\\n\"\n                if $val eq '_CHANGEME_';\n            if (defined $multi_line_vars{$var}) {\n                push @{$config{$var}}, $val;\n            } else {\n                ### may have already been defined in existing snort.conf\n                ### file if --snort-conf was given.\n                $config{$var} = $val unless defined $config{$var};\n            }\n        }\n    }\n\n    &expand_vars();\n\n    return;\n}\n\nsub ipt_list() {\n    for my $chain (\n        $config{'FWSNORT_INPUT'},\n        $config{'FWSNORT_INPUT_ESTAB'},\n        $config{'FWSNORT_OUTPUT'},\n        $config{'FWSNORT_OUTPUT_ESTAB'},\n        $config{'FWSNORT_FORWARD'},\n        $config{'FWSNORT_FORWARD_ESTAB'}\n    ) {\n        my $cmd = \"$ipt_bin -v -n -L $chain\";\n        my $exists = (system \"$cmd > /dev/null 2>&1\") >> 8;\n        if ($exists == 0) {\n            print \"[+] Listing $chain chain...\\n\";\n            system $cmd;\n            print \"\\n\";\n        } else {\n            print \"[-] Chain $chain does not exist...\\n\";\n        }\n    }\n    exit 0;\n}\n\nsub ipt_flush() {\n    for my $chain (\n        $config{'FWSNORT_INPUT'},\n        $config{'FWSNORT_INPUT_ESTAB'},\n        $config{'FWSNORT_OUTPUT'},\n        $config{'FWSNORT_OUTPUT_ESTAB'},\n        $config{'FWSNORT_FORWARD'},\n        $config{'FWSNORT_FORWARD_ESTAB'}\n    ) {\n        my $exists = (system \"$ipt_bin -n -L \" .\n            \"$chain > /dev/null 2>&1\") >> 8;\n        if ($exists == 0) {\n            print \"[+] Flushing $chain chain...\\n\";\n            system \"$ipt_bin -F $chain\";\n            if ($ipt_del_chains) {\n                ### must remove any jump rules from the built-in\n                ### chains\n                &del_jump_rule($chain);\n\n                print \"    Deleting $chain chain...\\n\";\n                system \"$ipt_bin -X $chain\";\n            }\n        } else {\n            print \"[-] Chain $chain does not exist...\\n\";\n        }\n    }\n    exit 0;\n}\n\nsub cache_ipt_save_policy() {\n\n    return unless $is_root;\n\n    open IPT, \"$save_bin -t filter |\" or die \"[*] Could not execute $save_bin\";\n    while (<IPT>) {\n        push @ipt_save_lines, $_;\n    }\n    close IPT;\n\n    ### also write out the current iptables policy so that we can\n    ### revert to it if necessary (iptables does a good job of not committing\n    ### a policy via iptables-save if there is a problem with a rule though).\n    &archive($config{'IPT_BACKUP_SAVE_FILE'});\n    open F, \"> $config{'IPT_BACKUP_SAVE_FILE'}\" or die \"[*] Could not \" .\n        \"open $config{'IPT_BACKUP_SAVE_FILE'}: $!\";\n    print F for @ipt_save_lines;\n    close F;\n\n    ### remove the last two lines (the 'COMMIT' and '# Completed ...' lines\n    ### so they can be added later).\n    $ipt_save_completed_line = $ipt_save_lines[$#ipt_save_lines];\n    pop @ipt_save_lines;\n    pop @ipt_save_lines;\n\n    return;\n}\n\nsub del_jump_rule() {\n    my $chain = shift;\n\n    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'}\n        or die \"[*] Could not acquire IPTables::Parse object: $!\";\n\n    for my $built_in_chain (qw(INPUT OUTPUT FORWARD)) {\n        my $rules_ar = $ipt->chain_rules('filter', $built_in_chain, $ipt_file);\n\n        for (my $i=0; $i <= $#$rules_ar; $i++) {\n            my $rule_num = $i+1;\n            if ($rules_ar->[$i]->{'target'} eq $chain) {\n                system \"$ipt_bin -D $built_in_chain $rule_num\";\n                last;\n            }\n        }\n    }\n\n    return;\n}\n\nsub fwsnort_init() {\n\n    ### set umask to -rw-------\n    umask 0077;\n\n    ### turn off buffering\n    $| = 1;\n\n    &set_non_root_values() unless $is_root;\n\n    ### read in configuration info from the config file\n    &import_config();\n\n    ### make sure the commands are where the\n    ### config file says they are\n    &chk_commands();\n\n    ### make sure all of the required variables are defined\n    ### in the config file\n    &required_vars();\n\n    $non_host    = $NON_HOST;\n    $ipt_bin     = $cmds{'iptables'};\n    $restore_bin = $cmds{'iptables-restore'};\n    $save_bin    = $cmds{'iptables-save'};\n\n    if ($enable_ip6tables) {\n        for my $opt (qw(itype icode ttl tos ipopts)) {\n            $snort_opts{'unsupported'}{$opt}\n                = $snort_opts{'filter'}{$opt};\n            delete $snort_opts{'filter'}{$opt};\n        }\n        $non_host    = $NON_IP6_HOST;\n        $save_str    = 'ip6tables-save';\n        $ipt_str     = 'ip6tables';\n        $ipt_bin     = $cmds{'ip6tables'};\n        $restore_bin = $cmds{'ip6tables-restore'};\n        $save_bin    = $cmds{'ip6tables-save'};\n    }\n\n    unless ($is_root) {\n        $no_ipt_test = 1;\n    }\n\n    if ($ipt_exec) {\n        die \"[*] You need to be root for --ipt-apply\" unless $is_root;\n        if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n            print \"[+] Executing $config{'FWSNORT_SAVE_EXEC_FILE'}\\n\";\n            system $config{'FWSNORT_SAVE_EXEC_FILE'};\n            exit 0;\n        } else {\n            die \"[*] $config{'FWSNORT_SAVE_EXEC_FILE'} does not exist.\";\n        }\n    } elsif ($ipt_revert) {\n        die \"[*] You need to be root for --ipt-revert\" unless $is_root;\n        if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n            print \"[+] Executing $config{'FWSNORT_SAVE_EXEC_FILE'}\\n\";\n            system \"$config{'FWSNORT_SAVE_EXEC_FILE'} -r\";\n            exit 0;\n        } else {\n            die \"[*] $config{'FWSNORT_SAVE_EXEC_FILE'} does not exist.\";\n        }\n    }\n\n    if ($enable_ip6tables) {\n        ### switch to ip6tables\n        $ipt_var_str = 'IP6TABLES';\n    }\n\n    $process_chains{'INPUT'}   = 0 if $no_ipt_input;\n    $process_chains{'FORWARD'} = 0 if $no_ipt_forward;\n    $process_chains{'OUTPUT'}  = 0 if $no_ipt_output;\n\n    ### import HOME_NET, etc. from existing Snort config file.\n    &import_snort_conf() if $snort_conf_file;\n\n    if ($rules_types) {\n        my @types = split /\\,/, $rules_types;\n        for my $type (@types) {\n            $include_types{$type} = '';\n        }\n    }\n    if ($exclude_types) {\n        my @types = split /\\,/, $exclude_types;\n        for my $type (@types) {\n            $exclude_types{$type} = '';\n        }\n    }\n    if ($include_sids) {\n        ### disable iptables policy parsing if we are translating a\n        ### specific set of Snort sids.\n        $ipt_sync = 0;\n\n        my @sids = split /\\,/, $include_sids;\n        for my $sid (@sids) {\n            $include_sids{$sid} = '';\n        }\n    }\n    if ($exclude_sids) {\n        my @sids = split /\\,/, $exclude_sids;\n        for my $sid (@sids) {\n            $exclude_sids{$sid} = '';\n        }\n    }\n    if ($ipt_restrict_intf) {\n        my @interfaces = split /\\,/, $ipt_restrict_intf;\n        for my $intf (@interfaces) {\n            $restrict_interfaces{$intf} = '';\n        }\n    }\n\n    if ($include_re) {\n        if ($include_re_caseless) {\n            $include_re = qr|$include_re|i;\n        } else {\n            $include_re = qr|$include_re|;\n        }\n    }\n    if ($exclude_re) {\n        if ($exclude_re_caseless) {\n            $exclude_re = qr|$exclude_re|i;\n        } else {\n            $exclude_re = qr|$exclude_re|;\n        }\n    }\n\n    ### flush all fwsnort chains.\n    &ipt_flush() if $ipt_flush or $ipt_del_chains;\n\n    ### list all fwsnort chains.\n    &ipt_list() if $ipt_list;\n\n    ### download latest snort rules from snort.org\n    &update_rules() if $update_rules;\n\n    ### make sure some directories exist, etc.\n    &setup();\n\n    ### get kernel version (this is mainly used to know whether\n    ### the \"--algo bm\" argument is required for the string match\n    ### extension in the 2.6.14 (and later) kernels.  Also, the\n    ### string match extension as of 2.6.14 supports the Snort\n    ### offset and depth keywords via --from and --to\n    &get_kernel_ver();\n\n    ### may have been specified on the command line\n    $home_net = $config{'HOME_NET'} unless $home_net;\n    $ext_net  = $config{'EXTERNAL_NET'} unless $ext_net;\n\n    &get_local_addrs() unless $no_addr_check;\n\n    if ($strict) {\n        ### make the snort options parser very strict\n        for my $opt (@{$snort_opts{'strict_list'}}) {\n            if (defined $snort_opts{'filter'}{$opt}) {\n                $snort_opts{'unsupported'}{$opt}\n                    = $snort_opts{'filter'}{$opt};\n                delete $snort_opts{'filter'}{$opt};\n            } elsif (defined $snort_opts{'ignore'}{$opt}) {\n                $snort_opts{'unsupported'}{$opt}\n                    = $snort_opts{'ignore'}{$opt};\n                delete $snort_opts{'ignore'}{$opt};\n            }\n        }\n        my @ignore = (qw(nocase));\n\n        if ($kernel_ver eq '2.4') {\n            push @ignore, 'offset', 'depth';\n        }\n        for my $opt (@ignore) {\n            next unless defined $snort_opts{'ignore'}{$opt};\n            $snort_opts{'unsupported'}{$opt}\n                = $snort_opts{'ignore'}{$opt};\n            delete $snort_opts{'ignore'}{$opt};\n        }\n    }\n    if ($no_pcre) {\n        ### skip trying to translate basic PCRE's\n        $snort_opts{'unsupported'}{'pcre'}\n            = $snort_opts{'filter'}{'pcre'};\n        delete $snort_opts{'filter'}{'pcre'};\n    }\n\n    if ($no_fast_pattern_order) {\n        $snort_opts{'ignore'}{'fast_pattern'}\n            = $snort_opts{'filter'}{'fast_pattern'}{'regex'};\n        delete $snort_opts{'filter'}{'fast_pattern'};\n    }\n    return;\n}\n\nsub get_kernel_ver() {\n    die \"[*] uname command: $cmds{'uname'} is not executable.\"\n        unless -x $cmds{'uname'};\n    open U, \"$cmds{'uname'} -a |\" or die \"[*] Could not run \",\n        \"$cmds{'uname'} -a\";\n    my $out = <U>;\n    close U;\n    ### Linux orthanc 2.6.12.5 #2 Tue Sep 27 22:43:02 EDT 2005 i686 \\\n    ### Pentium III (Coppermine) GenuineIntel GNU/Linux\n    if ($out =~ /\\s2\\.6/) {\n        $kernel_ver = '2.6';\n    }\n    return;\n}\n\nsub handle_cmd_line() {\n\n    ### make Getopts case sensitive\n    Getopt::Long::Configure('no_ignore_case');\n\n    die \"[*] Use --help for usage information.\\n\" unless (GetOptions(\n        'ipt-apply'      => \\$ipt_exec,     # Apply the generated ruleset.\n        'ipt-exec'       => \\$ipt_exec,     # Apply the generated ruleset.\n        'ipt-revert'     => \\$ipt_revert,     # Apply the generated ruleset.\n        'ipt-drop'       => \\$ipt_drop,     # Add iptables DROP rules.\n        'ipt-reject'     => \\$ipt_reject,   # Add iptables REJECT rules.\n        'ipt-script=s'   => \\$ipt_script,   # Manually specify the path to the\n                                            # generated iptables script.\n        'ipt-log-tcp-seq' => \\$ipt_log_tcp_seq, # Log TCP seq/ack values.\n        'ipt-flush'      => \\$ipt_flush,    # Flush any existing fwsnort chains.\n        'ipt-check-capabilities' =>\\$ipt_check_capabilities, # Check capabilities\n                                                             # and exit.\n        'Flush'          => \\$ipt_flush,    # Synonym for --ipt-flush\n        'ipt-list'       => \\$ipt_list,     # List any existing fwsnort chains.\n        'List'           => \\$ipt_list,     # Synonym for --ipt-list\n        'fw-list'        => \\$ipt_list,     # Synonym for --ipt-list\n        'ipt-del'        => \\$ipt_del_chains, # Delete fwsnort chains.\n        'ip6tables'      => \\$enable_ip6tables, # Turn on ip6tables mode.\n        '6'              => \\$enable_ip6tables, # Synonym for --ip6tables.\n        'X'              => \\$ipt_del_chains, # Synonym for --ipt-del.\n        'ipt-file=s'     => \\$ipt_file,     # Read iptables policy from a file.\n        'Home-net=s'     => \\$home_net,     # Manually specify home network.\n        'External-net=s' => \\$ext_net,      # Manually specify external network.\n        'snort-sid=s'    => \\$include_sids, # Parse only these particular snort rules.\n        'snort-sids=s'   => \\$include_sids, # Synonum for --snort-sid\n        'string-match-alg=s' => \\$string_match_alg,\n        'exclude-sid=s'  => \\$exclude_sids, # Exclude these particular snort rules.\n        'snort-conf=s'   => \\$snort_conf_file, # Get HOME_NET, etc. vars from\n                                            # existing Snort config file.\n        'include-perl-triggers' => \\$include_perl_triggers, # perl commands to\n                                            # trigger signature matches.\n        'include-type=s' => \\$rules_types,  # Process only this type of snort rule\n                                            # (e.g. \"ddos\")\n        'exclude-type=s' => \\$exclude_types,# Exclude specified types (e.g. \"ddos\").\n        'include-regex=s' => \\$include_re,  # Include only those signatures that\n                                            # match the specified regex.\n        'include-re-caseless' => \\$include_re_caseless, # make include regex case\n                                                        # insensitive\n        'exclude-regex=s' => \\$exclude_re,  # Exclude those signatures that\n                                            # match the specified regex.\n        'exclude-re-caseless' => \\$exclude_re_caseless, # make exclude regex case\n                                                        # insensitive\n        'snort-rdir=s'   => \\$rules_dir,    # Manually specify the snort rules\n                                            # directory.\n        'snort-rfile=s'  => \\$rules_file,   # Translate a single rules file.\n        'no-pcre'        => \\$no_pcre,      # Make no attempt to translate PCRE's.\n        'no-addresses'   => \\$no_addr_check, # Don't check local ifconfig output.\n        'no-ipt-sync'    => \\$ignore_opt,   # Do not sync with the iptables policy.\n        'ipt-sync'       => \\$ipt_sync,     # Sync fwsnort rules with the iptables\n                                            # policy.\n        'no-ipt-log'     => \\$no_ipt_log,   # Do not generate iptables logging rules.\n        'no-ipt-test'    => \\$no_ipt_test,  # Don't perform any checks for\n                                            # iptables capabilities.\n        'no-ipt-jumps'   => \\$no_ipt_jumps, # Don't jump packets from the INPUT or\n                                            # FORWARD chains.\n        'no-ipt-conntrack' => \\$no_ipt_conntrack, # Don't use iptables connection\n                                            # tracking (falls back to ACK flag test).\n        'Conntrack-state=s' => \\$conntrack_state, ### Specify conntrack state for\n                                                  ### 'flow' keyword emulation\n                                                  ### (default is ESTABLISHED).\n        'no-ipt-INPUT'   => \\$no_ipt_input, # Disable fwsnort rules processed via\n                                            # the INPUT chain.\n        'no-ipt-OUTPUT'  => \\$no_ipt_output, # Disable fwsnort rules processed via\n                                             # the OUTPUT chain.\n        'no-ipt-FORWARD' => \\$no_ipt_forward, # Disable fwsnort rules processed via\n                                              # the FORWARD chain.\n        'no-ipt-comments' => \\$no_ipt_comments, # Don't include msg fields\n                                                # with the comment match\n        'no-ipt-rule-nums' => \\$no_ipt_rule_nums, # Exclude rule numbers from\n                                                  # logging prefixes.\n        'no-exclude-lo'  => \\$no_exclude_loopback, # include loopback interface\n        'no-log-ip-opts' => \\$no_ipt_log_ip_opts, # Don't log IP options\n        'no-log-tcp-opts' => \\$no_ipt_log_tcp_opts, # Don't log TCP options\n        'no-fast-pattern-order' => \\$no_fast_pattern_order, ### Don't alter\n                                              # pattern match ordering based on\n                                              # pattern length, and ignore the\n                                              # explicit 'fast_pattern' keyword\n        'restrict-intf=s' => \\$ipt_restrict_intf, # Restrict iptables rules to an\n                                            # individual interface (supports a\n                                            # comma separate list).\n        'update-rules'   => \\$update_rules, # Download latest snort rules.\n        'rules-url=s'    => \\$rules_url,    # Specify rules URL.\n        'add-deleted'    => \\$add_deleted,  # Add deleted rules.\n        'strict'         => \\$strict,       # Strict mode.\n        'debug'          => \\$debug,        # Debug mode.\n        'dumper'         => \\$dumper,       # Dumper mode for IPTables::Parse\n                                            # hashes.\n        'Dump-conf'      => \\$dump_conf,    # Display config variables\n        'Dump-ipt'       => \\$dump_ipt,     # Dump iptables rules on STDOUT.\n        'Dump-snort'     => \\$dump_snort,   # Dump snort rules on STDOUT.\n        'config=s'       => \\$fwsnort_conf, # Manually specify the config file\n        'Ulog'           => \\$ulog_mode,    # Force ULOG mode.\n        'ulog-nlgroup=i' => \\$ulog_nlgroup, # Specify the ulogd nl group.\n        'QUEUE'          => \\$queue_mode,   # Specify QUEUE mode; this pulls out\n                                            #  all kernel-matchable features from\n                                            #  original Snort rules and creates a\n                                            #  a modified rule set based on this.\n        'NFQUEUE'        => \\$nfqueue_mode, # Same as QUEUE mode, except use the\n                                            #  updated NFQUEUE target.\n        'queue-rules-dir=s' => \\$queue_rules_dir, # Change the path to the generated\n                                                  # rules directory in --QUEUE or\n                                                  # --NFQUEUE mode.\n        'queue-num=i'    => \\$nfqueue_num,  # Specifies the NFQUEUE number.\n        'queue-pre-match-max=i' => \\$queue_pre_match_max,  ### max number of patterns\n                                                  ### to match within the kernel before\n                                                  ### queuing a packet to userspace\n                                                  ### Snort\n        'Home-dir=s'     => \\$cmdl_homedir,\n        'Last-cmd'       => \\$run_last,\n        'lib-dir=s'      => \\$lib_dir,      # Specify path to lib directory.\n        'verbose'        => \\$verbose,\n        'logfile=s'      => \\$logfile,      # Specify the logfile path.\n        'stdout'         => \\$stdout,       # Print log messages to stdout.\n        'Version'        => \\$print_ver,\n        'help'           => \\$help\n    ));\n\n    &get_homedir();\n\n    &usage(0) if $help;\n\n    &save_args() unless $run_last;\n\n    ### Print the version number and exit if -V given on the command line.\n    if ($print_ver) {\n        print \"[+] fwsnort v$version by Michael Rash <mbr\\@cipherdyne.org>\\n\";\n        exit 0;\n    }\n\n    if (($queue_mode or $nfqueue_mode) and ($ipt_drop or $ipt_reject)) {\n        die\n\"[*] --NFQUEUE and --QUEUE modes are not compatible with --ipt-drop or\\n\",\n\"    --ipt-reject; a userland process should set the verdict. If you can\\n\",\n\"    always use fwsnort with --ipt-drop or --ipt-reject and add an NFQUEUE\\n\",\n\"    or QUEUE rule manually to a built-in chain. This allows the fwsnort\\n\",\n\"    policy to DROP or REJECT packets that match signatures before they are\\n\",\n\"    communicated to userland (hence speeding up Snort_inline).\\n\";\n    }\n\n    if ($nfqueue_num != 0) {\n        unless ($nfqueue_num > 0 and $nfqueue_num < 65536) {\n            die \"[*] --queue-num must be between 0 and 65535 (inclusive)\";\n        }\n        unless ($nfqueue_mode) {\n            die \"[*] Must also specifiy --NFQUEUE mode if using --queue-num\";\n        }\n    }\n\n    if ($no_ipt_log and not ($ipt_drop or $ipt_reject)) {\n        die \"[*] --ipt-no-log option can only be used \",\n            \"with --ipt-drop or --ipt-reject\";\n    }\n\n    if ($ipt_drop and $ipt_reject) {\n        die \"[*] Cannot specify both --ipt-drop and --ipt-reject\";\n    }\n\n    return;\n}\n\nsub import_snort_conf() {\n    unless (-e $snort_conf_file) {\n        die \"[*] Snort config file $snort_conf_file does not exist.\";\n    }\n    open F, \"< $snort_conf_file\" or die \"[*] Could not open Snort \",\n        \"config $snort_conf_file: $!\";\n    my @lines = <F>;\n    close F;\n    for my $line (@lines) {\n        chomp $line;\n        next if $line =~ /^\\s*#/;\n        if ($line =~ /^\\s*var\\s+(\\w+)\\s+(.*)\\s*/) {\n            $config{$1} = $2;\n        }\n    }\n    return;\n}\n\nsub expand_vars() {\n\n    my $has_sub_var = 1;\n    my $resolve_ctr = 0;\n\n    while ($has_sub_var) {\n        $resolve_ctr++;\n        $has_sub_var = 0;\n        if ($resolve_ctr >= 20) {\n            die \"[*] Exceeded maximum variable resolution counter.\";\n        }\n        for my $hr (\\%config, \\%cmds) {\n            for my $var (keys %$hr) {\n                my $val = $hr->{$var};\n                if ($val =~ m|\\$(\\w+)|) {\n                    my $sub_var = $1;\n                    die \"[*] sub-ver $sub_var not allowed within same \",\n                        \"variable $var\" if $sub_var eq $var;\n                    if (defined $config{$sub_var}) {\n                        if ($sub_var eq 'INSTALL_ROOT'\n                                and $config{$sub_var} eq '/') {\n                            $val =~ s|\\$$sub_var||;\n                        } else {\n                            $val =~ s|\\$$sub_var|$config{$sub_var}|;\n                        }\n                        $hr->{$var} = $val;\n                    } else {\n                        die \"[*] sub-var \\\"$sub_var\\\" not defined in \",\n                            \"config for var: $var.\"\n                    }\n                    $has_sub_var = 1;\n                }\n            }\n        }\n    }\n    return;\n}\n\nsub required_vars() {\n    my @required_vars = (qw(\n        HOME_NET EXTERNAL_NET HTTP_SERVERS SMTP_SERVERS DNS_SERVERS\n        SQL_SERVERS TELNET_SERVERS AIM_SERVERS HTTP_PORTS SHELLCODE_PORTS\n        SSH_PORTS ORACLE_PORTS WHITELIST BLACKLIST AVG_IP_HEADER_LEN\n        AVG_TCP_HEADER_LEN MAX_FRAME_LEN FWSNORT_INPUT FWSNORT_INPUT_ESTAB\n        FWSNORT_OUTPUT FWSNORT_OUTPUT_ESTAB FWSNORT_FORWARD\n        FWSNORT_FORWARD_ESTAB FWSNORT_INPUT_JUMP FWSNORT_OUTPUT_JUMP\n        FWSNORT_FORWARD_JUMP MAX_STRING_LEN CONF_DIR RULES_DIR ARCHIVE_DIR\n        QUEUE_RULES_DIR LOG_DIR LIBS_DIR CONF_FILE FWSNORT_SCRIPT LOG_FILE\n        FWSNORT_SAVE_FILE FWSNORT_SAVE_EXEC_FILE IPT_BACKUP_SAVE_FILE\n        UPDATE_RULES_URL STATE_DIR INSTALL_ROOT\n    ));\n    for my $var (@required_vars) {\n        die \"[*] Variable $var not defined in $fwsnort_conf. Exiting.\\n\"\n            unless defined $config{$var};\n    }\n    return;\n}\n\nsub ipt_capabilities() {\n\n    print \"[+] Testing $ipt_bin for supported capabilities...\\n\";\n\n    my $test_rule_rv = -1;\n\n    ### create test chain\n    &create_test_chain();\n\n    ### test for the LOG target.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            \"$non_host -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has 'LOG' target support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### check for the max --log-prefix string length\n        $ipt_max_log_prefix_len = &ipt_find_max_len(\n            $ipt_max_log_prefix_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n            qq|$non_host -p tcp --dport 1234 -j LOG --log-prefix \"|, qq|\"|\n        );\n\n        print \"    Max supported LOG prefix length: $ipt_max_log_prefix_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n    } else {\n        &delete_test_chain();\n        die \"[*] $ipt_str has not been compiled with logging support.  \",\n            \"If you want to\\n    have fwsnort generate an $ipt_str script \",\n            \"    anyway then specify the\\n    --no-ipt-test option. \",\n            \"Exiting.\\n\"\n            unless $no_ipt_log;\n    }\n\n    ### test for the comment match (where Snort msg fields are placed)\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -m comment --comment \"testing the comment match\" | .\n            qq|-j LOG|) == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has 'comment' match support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        $ipt_max_comment_len = &ipt_find_max_len(\n            $ipt_max_comment_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n            qq|$non_host -p tcp --dport 1234 -m comment --comment | .\n            qq|\"|, qq|\" -j LOG|\n        );\n\n        print \"    Max supported comment length: $ipt_max_comment_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n    } else {\n        unless ($no_ipt_comments) {\n            print\"[-] It looks like the $ipt_str 'comment' match is not \",\n                \"available, disabling.\\n\";\n            $no_ipt_comments = 1;\n        }\n    }\n\n    ### test for the ipv4options extension.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp -m \" .\n            \"ipv4options --rr -s $non_host -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'ipv4options' extension...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n\n        &logr(\"[-] $ipt_str ipv4options extension not available, \" .\n            \"disabling ipopts translation.\");\n        ### put ipopts in the unsupported list\n        if (defined $snort_opts{'filter'}{'ipopts'}) {\n            $snort_opts{'unsupported'}{'ipopts'} =\n                $snort_opts{'filter'}{'ipopts'}{'regex'};\n            delete $snort_opts{'filter'}{'ipopts'};\n        } else {\n            $snort_opts{'unsupported'}{'ipopts'} = qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/;\n        }\n        print \"[-] $ipt_str does not have the 'ipv4options' extension, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the ttl match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m ttl --ttl-eq 1 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'ttl' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put ttl in the unsupported list\n        &logr(\"[-] $ipt_str TTL match not available, \" .\n            \"disabling ttl translation.\");\n        if (defined $snort_opts{'filter'}{'ttl'}) {\n            $snort_opts{'unsupported'}{'ttl'} =\n                $snort_opts{'filter'}{'ttl'}{'regex'};\n            delete $snort_opts{'filter'}{'ttl'};\n        } else {\n            $snort_opts{'unsupported'}{'ttl'} = qr/[\\s;]ttl:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'ttl' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the TOS match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m tos --tos 8 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'tos' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put tos in the unsupported list\n        &logr(\"[-] $ipt_str TOS match not available, \" .\n            \"disabling tos translation.\");\n        if (defined $snort_opts{'filter'}{'tos'}) {\n            $snort_opts{'unsupported'}{'tos'} =\n                $snort_opts{'filter'}{'tos'}{'regex'};\n            delete $snort_opts{'filter'}{'tos'};\n        } else {\n            $snort_opts{'unsupported'}{'tos'} = qr/[\\s;]tos:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'tos' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the length match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p icmp \" .\n            \"-s $non_host -m length --length 256 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'length' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        ### put length in the unsupported list\n        &logr(\"[-] $ipt_str length match not available, \" .\n            \"disabling length translation.\");\n        if (defined $snort_opts{'filter'}{'dsize'}) {\n            $snort_opts{'unsupported'}{'dsize'} =\n                $snort_opts{'filter'}{'dsize'}{'regex'};\n            delete $snort_opts{'filter'}{'dsize'};\n        } else {\n            $snort_opts{'unsupported'}{'dsize'} = qr/[\\s;]dsize:\\s*(.*?)\\s*;/;\n        }\n        print \"[+] $ipt_str does not have the 'length' match, \" .\n            \"disabling...\\n\" if $verbose or $ipt_check_capabilities;\n    }\n\n    ### test for the multiport match.\n    if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n            \"-s $non_host -m multiport --dports 53,123:500 -j LOG\") == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has the 'multiport' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n        $ipt_have_multiport_match = 1;\n\n        ### find the maximum number of supported ports (usually 15)\n        &ipt_find_max_multiport_supported_ports();\n\n    } else {\n        print \"[-] $ipt_str does not have the 'multiport' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n        &logr(\"[-] $ipt_str multiport match not available\");\n    }\n\n    ### test for string match support.\n    my $ipt_str_test = my $ipt_str_test_base =\n            \"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -m string --string \"test\" |;\n\n    if ($kernel_ver ne '2.4') {\n        ### default to include \"--algo bm\"\n        $ipt_str_test .= qq|--algo $string_match_alg -j LOG|;\n    } else {\n        $ipt_str_test .= qq|-j LOG|;\n    }\n\n    $test_rule_rv = &ipt_rule_test($ipt_str_test);\n\n    if ($test_rule_rv == $IPT_SUCCESS) {\n\n        print \"[+] $ipt_str has the 'string' match...\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### now find the maximum string length that is supported by iptables\n        if ($kernel_ver eq '2.4') {\n            $ipt_max_str_len = &ipt_find_max_len(\n                $ipt_max_str_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n                    qq|$non_host -m string --string \"|, qq|\" -j LOG|);\n        } else {\n            $ipt_max_str_len = &ipt_find_max_len(\n                $ipt_max_str_len, qq|-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s | .\n                qq|$non_host -m string --string \"|, qq|\" | .\n                qq|--algo $string_match_alg -j LOG|);\n        }\n\n        print \"    Max supported string length: $ipt_max_str_len\\n\"\n            if $verbose or $ipt_check_capabilities;\n\n        ### test for case insensitive string matching\n        $ipt_str_test = $ipt_str_test_base;\n\n        if ($kernel_ver ne '2.4') {\n            $ipt_str_test .= qq|--algo $string_match_alg --icase -j LOG|;\n        } else {\n            $ipt_str_test .= qq|--icase -j LOG|;\n        }\n\n        $test_rule_rv = &ipt_rule_test($ipt_str_test);\n\n        unless ($test_rule_rv == $IPT_SUCCESS) {\n            $snort_opts{'ignore'}{'nocase'}\n                = $snort_opts{'filter'}{'nocase'}{'regex'};\n            delete $snort_opts{'filter'}{'fast_pattern'};\n        }\n\n        ### test for --replace-string support (only available for 2.4 kernels\n        ### if the replace-string patch has been applied).\n        if ($kernel_ver eq '2.4') {\n            unless (&ipt_rule_test($ipt_str_test_base .\n                    qq|--replace-string \"repl\" -j LOG|) == $IPT_SUCCESS) {\n                if (defined $snort_opts{'filter'}{'replace'}) {\n                    $snort_opts{'unsupported'}{'replace'} =\n                        $snort_opts{'filter'}{'replace'}{'regex'};\n                    delete $snort_opts{'filter'}{'replace'};\n                } else {\n                    $snort_opts{'unsupported'}{'replace'}\n                        = qr/[\\s;]replace:\\s*(.*?)\\s*;/;\n                }\n            }\n        } else {\n            $snort_opts{'unsupported'}{'replace'}\n                = qr/[\\s;]replace:\\s*(.*?)\\s*;/;\n        }\n\n        ### test to see whether '--icmp-type any' is supported\n        $ipt_str_test = $ipt_str_test_base;\n        if ($kernel_ver ne '2.4') {\n            $ipt_str_test .= qq|--algo $string_match_alg -p icmp -m icmp --icmp-type any -j LOG|;\n        } else {\n            $ipt_str_test .= qq|-p icmp -m icmp --icmp-type any -j LOG|;\n        }\n\n        $test_rule_rv = &ipt_rule_test($ipt_str_test);\n        if ($test_rule_rv == $IPT_SUCCESS) {\n            $default_icmp_type = 'any';\n        }\n\n    } else {\n        &delete_test_chain();\n        die\n\"[*] It does not appear that string match support has been compiled into\\n\",\n\"    the kernel.  Fwsnort will not be of very much use without this.\\n\",\n\"    ** NOTE: If you want to have fwsnort generate an $ipt_str policy\\n\",\n\"    anyway, use the --no-ipt-test option.  Exiting.\\n\";\n    }\n\n    ### test for --hex-string\n    if ($kernel_ver ne '2.4') {\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host \" .\n            qq{-m string --hex-string \"|0a 5d|\" --algo $string_match_alg -j LOG});\n    } else {\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host \" .\n            qq{-m string --hex-string \"|0a 5d|\" -j LOG});\n    }\n\n    if ($test_rule_rv == $IPT_SUCCESS) {\n        print \"[+] $ipt_str has --hex-string support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    } else {\n        &delete_test_chain();\n        die\n\"[*] It does not appear that the --hex-string patch has been applied.\\n\",\n\"    fwsnort will not be of very much use without this. ** NOTE: If you\\n\",\n\"    want to have fwsnort generate an $ipt_str policy anyway, then\\n\",\n\"    use the --no-ipt-test option.  Exiting.\\n\";\n    }\n\n    ### test for the --payload option\n    if ($kernel_ver ne '2.4'\n            and &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM \" .\n            \"-s $non_host -m string --string \" .\n            qq|\"test\" --algo $string_match_alg --to 50 --payload -j LOG|) == $IPT_SUCCESS) {\n        $ipt_has_string_payload_offset_opt = 1;\n    }\n\n    if ($queue_mode or $nfqueue_mode) {\n        ### test for the QUEUE or NFQUEUE target\n        if ($nfqueue_mode) {\n            if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                    \"$non_host -p tcp --dport 3001 -j NFQUEUE\")\n                        == $IPT_SUCCESS) {\n                print \"[+] $ipt_str has NFQUEUE support....\\n\"\n                    if $verbose or $ipt_check_capabilities;\n            } else {\n                die \"[*] The NFQUEUE target does not appear to be available \",\n                    \"in iptables.\";\n            }\n        } else {\n            if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                    \"$non_host -p tcp --dport 3001 -j QUEUE\")\n                        == $IPT_SUCCESS) {\n                print \"[+] $ipt_str has QUEUE support....\\n\"\n                    if $verbose or $ipt_check_capabilities;\n            } else {\n                die \"[*] The QUEUE target does not appear to be available \",\n                    \"in iptables.\";\n            }\n        }\n    }\n\n    unless ($no_ipt_conntrack) {\n\n        ### test for connection tracking support (conntrack\n        ### match first then state match if not available)\n        if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                \"$non_host -p tcp --dport 3001 -m conntrack \" .\n                \"--ctstate ESTABLISHED -j LOG\")\n                    == $IPT_SUCCESS) {\n            print \"[+] $ipt_str has conntrack state tracking support...\\n\"\n                if $verbose or $ipt_check_capabilities;\n\n            if ($conntrack_state ne 'ESTABLISHED') {\n\n                ### check to make sure the specified state is supported\n                if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                        \"$non_host -p tcp --dport 3001 -m conntrack \" .\n                        \"--ctstate $conntrack_state -j LOG\")\n                            != $IPT_SUCCESS) {\n                     die \"[*] The connection state $conntrack_state does not \",\n                        \"appear to be supported by iptables.\\n\";\n                }\n            }\n\n            $have_conntrack = 1;\n\n        } elsif (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                \"$non_host -p tcp --dport 3001 -m state \" .\n                \"--state ESTABLISHED -j LOG\")\n                    == $IPT_SUCCESS) {\n            print \"[+] $ipt_str has state tracking support...\\n\"\n                if $verbose or $ipt_check_capabilities;\n\n            if ($conntrack_state ne 'ESTABLISHED') {\n\n                ### check to make sure the specified state is supported\n                if (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n                        \"$non_host -p tcp --dport 3001 -m state \" .\n                        \"--state ESTABLISHED -j LOG\")\n                            != $IPT_SUCCESS) {\n                    die \"[*] The connection state $conntrack_state does not \",\n                        \"appear to be supported by iptables.\\n\";\n                }\n            }\n\n            $have_state = 1;\n        } else {\n            &delete_test_chain();\n            die\n\"[*] It does not appear that $ipt_str has been compiled with connection\\n\",\n\"    tracking support.  If you want fwsnort to generate a policy anyway\\n\",\n\"    and just use a tcp flags check for established tcp connections, then\\n\",\n\"    use the --no-ipt-conntrack option.  **NOTE: The resulting fwsnort\\n\",\n\"    $ipt_str policy will be susceptible to a stick or snot-style attack.\\n\",\n\"    Exiting.\\n\";\n        }\n    }\n\n    if ($ipt_reject) {\n        ### we are going to generate a policy that drops icmp and udp\n        ### packets, and kills tcp sessions with tcp-reset.\n        unless (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n            \"-s $non_host \" .\n            \"-j REJECT --reject-with tcp-reset\") == $IPT_SUCCESS) {\n\n            ### in newer versions of iptables (> 1.3.5?) the \"tcp-reset\"\n            ### command line arg has been changed to \"tcp-rst\"\n            unless (&ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -p tcp \" .\n                    \"-s $non_host \" .\n                    \"-j REJECT --reject-with tcp-rst\") == $IPT_SUCCESS) {\n                &delete_test_chain();\n                die\n\"[*] It does not appear that the REJECT target has been compiled into\\n\",\n\"    the kernel.  The --ipt-reject option requires this option so that tcp\\n\",\n\"    sessions can be killed.  Exiting.\\n\";\n            }\n        }\n        print \"[+] $ipt_str has the 'REJECT' target support...\\n\"\n            if $verbose or $ipt_check_capabilities;\n    }\n\n    &delete_test_chain();\n\n    exit 0 if $ipt_check_capabilities;\n\n    ### more tests should be added\n    return;\n}\n\nsub ipt_find_max_len() {\n    my ($len, $ipt_pre_pattern, $ipt_post_pattern) = @_;\n\n    my $test_pattern = '';\n\n    for (;;) {\n\n        $test_pattern = 'A'x$len;\n\n        last if &ipt_rule_test($ipt_pre_pattern\n            . $test_pattern . $ipt_post_pattern) != $IPT_SUCCESS;\n\n        $len += $ipt_cap_search_factor;\n\n        last if $len >= $ipt_max_buf_len;\n    }\n\n    for (;;) {\n\n        $test_pattern = 'A'x$len;\n\n        last if &ipt_rule_test($ipt_pre_pattern\n            . $test_pattern . $ipt_post_pattern) == $IPT_SUCCESS;\n\n        $len--;\n\n        last if $len == 1;  ### minimum\n    }\n\n    return --$len;\n}\n\nsub ipt_find_max_multiport_supported_ports() {\n\n    my $test_ports_str = $ipt_multiport_max-1;\n\n    for (;;) {\n\n        $test_ports_str .= \",$ipt_multiport_max\";\n\n        my $test_rule_rv = 0;\n\n        $test_rule_rv = &ipt_rule_test(\"-I $TEST_CHAIN $IPT_TEST_RULE_NUM -s \" .\n            qq|$non_host -p tcp -m multiport --dports $test_ports_str -j LOG |);\n\n        last if $test_rule_rv != $IPT_SUCCESS;\n\n        $ipt_multiport_max++;\n\n        last if $ipt_multiport_max == $ipt_max_buf_len; ### unlikely we'll ever get here\n    }\n    $ipt_multiport_max--;\n\n    print \"    Max supported multiport ports: $ipt_multiport_max\\n\"\n        if $verbose or $ipt_check_capabilities;\n\n    return;\n}\n\nsub dump_conf() {\n    for my $var (sort keys %config) {\n        printf \"%-30s %s\\n\", \"[+] $var\", $config{$var};\n    }\n    exit 0;\n}\n\nsub import_perl_modules() {\n\n    my $mod_paths_ar = &get_mod_paths();\n\n    if ($#$mod_paths_ar > -1) {  ### /usr/lib/fwsnort/ exists\n        push @$mod_paths_ar, @INC;\n        splice @INC, 0, $#$mod_paths_ar+1, @$mod_paths_ar;\n    }\n\n    if ($debug) {\n        print \"[+] import_perl_modules(): The \\@INC array:\\n\";\n        print \"$_\\n\" for @INC;\n    }\n\n    require IPTables::Parse;\n    require NetAddr::IP;\n\n    return;\n}\n\nsub get_mod_paths() {\n\n    my @paths = ();\n\n    $config{'LIBS_DIR'} = $lib_dir if $lib_dir;\n\n    unless (-d $config{'LIBS_DIR'}) {\n        my $dir_tmp = $config{'LIBS_DIR'};\n        $dir_tmp =~ s|lib/|lib64/|;\n        if (-d $dir_tmp) {\n            $config{'LIBS_DIR'} = $dir_tmp;\n        } else {\n            return [];\n        }\n    }\n\n    opendir D, $config{'LIBS_DIR'}\n        or die \"[*] Could not open $config{'LIBS_DIR'}: $!\";\n    my @dirs = readdir D;\n    closedir D;\n\n    push @paths, $config{'LIBS_DIR'};\n\n    for my $dir (@dirs) {\n        ### get directories like \"/usr/lib/fwsnort/x86_64-linux\"\n        next unless -d \"$config{'LIBS_DIR'}/$dir\";\n        push @paths, \"$config{'LIBS_DIR'}/$dir\"\n            if $dir =~ m|linux| or $dir =~ m|thread|;\n    }\n    return \\@paths;\n}\n\nsub setup() {\n\n    ### these two directories must already exist for\n    ### things to work\n    die \"[*] No fwsnort directory $config{'CONF_DIR'}\"\n        unless -d $config{'CONF_DIR'};\n\n    $config{'FWSNORT_SCRIPT'}  = $ipt_script if $ipt_script;\n    $config{'RULES_DIR'}       = $rules_dir if $rules_dir;\n    $config{'QUEUE_RULES_DIR'} = $queue_rules_dir if $queue_rules_dir;\n    $config{'LOG_FILE'}        = $logfile if $logfile;\n\n    if ($rules_file) {\n        for my $file (split /\\,/, $rules_file) {\n            die \"[*] Snort rules file $file does not exist.\" unless -e $file;\n        }\n    } else {\n        for my $dir (split /\\,/, $config{'RULES_DIR'}) {\n            die \"[*] No snort rules directory $dir, use --snort-rdir\"\n                unless -d $dir;\n        }\n    }\n\n    ### import fwsnort perl modules\n    &import_perl_modules();\n\n    for my $dir ($config{'LOG_DIR'}, $config{'STATE_DIR'}) {\n        unless (-d $dir) {\n            mkdir $dir, 0755 or die \"[*] Could not mkdir($dir): $!\";\n        }\n    }\n\n    unless (-d $config{'ARCHIVE_DIR'}) {\n        mkdir $config{'ARCHIVE_DIR'}, 0500 or\n            die \"[*] Could not mkdir($config{'ARCHIVE_DIR'}): $!\";\n    }\n\n    if (($queue_mode or $nfqueue_mode) and not -d $config{'QUEUE_RULES_DIR'}) {\n        mkdir $config{'QUEUE_RULES_DIR'}, 0500 or die $!;\n    }\n\n    return;\n}\n\nsub update_rules() {\n    print \"[+] Downloading latest rules into $config{'RULES_DIR'}/\";\n\n    my $dir = $config{'RULES_DIR'};\n    $dir =~ s/\\,.*//;\n    chdir $dir or die \"[*] Could not chdir $dir: $!\";\n\n    my $ctr = 0;\n    for my $url (@{$config{'UPDATE_RULES_URL'}}) {\n        my $file = '';\n        if ($url =~ m|.*/(.*)|) {\n            $file = $1;\n        } else {\n            next;\n        }\n\n        if (-e $file) {\n            move $file, \"${file}.tmp\"\n                or die \"[*] Could not move $file -> $file.tmp\";\n        }\n\n        system \"$cmds{'wget'} $url\";\n\n        if (-e $file) {  ### successful download\n            unlink \"${file}.tmp\";\n        } else {\n            print \"[-] Could not download $file file.\\n\";\n            if (-e \"${file}.tmp\") {\n                ### move the original back\n                move $file, \"${file}.tmp\"\n                    or die \"[*] Could not move $file -> $file.tmp\";\n            }\n        }\n\n        if ($ctr == 0 and $rules_url ne $DEFAULT_RULES_URL) {\n            ### manual URL specified from the command line\n            last;\n        }\n    }\n\n    print \"[+] Finished.\\n\";\n    exit 0;\n}\n\nsub ipt_rule_test() {\n    my $rule = shift;\n    my $chain = '';\n\n    print \"    CMD: $ipt_bin $rule\\n\" if $verbose;\n\n    if ($rule =~ m/\\-I\\s+(\\w+)\\s/) {\n        $chain = $1;\n    }\n\n    die qq{[*] Could not extract $ipt_str chain from: \"$rule\"}\n        unless $chain;\n\n    my $rv = (system \"$ipt_bin $rule 2> /dev/null\") >> 8;\n    if ($rv == 0) {\n        ### rule success, make sure to delete it.  We force that\n        ### the rule has just been inserted, so just delete the\n        ### first rule in the chain.  We could just delete the\n        ### rule using $rule, but it is unlikely that the first\n        ### rule in the chain isn't the one we just added\n        system \"$ipt_bin -D $chain $IPT_TEST_RULE_NUM\";\n        return $IPT_SUCCESS;\n    }\n    return $IPT_FAILURE;\n}\n\nsub create_test_chain() {\n    system \"$ipt_bin -F $TEST_CHAIN 2> /dev/null\";\n    system \"$ipt_bin -N $TEST_CHAIN 2> /dev/null\";\n    return;\n}\n\nsub delete_test_chain() {\n    system \"$ipt_bin -F $TEST_CHAIN 2> /dev/null\";\n    system \"$ipt_bin -X $TEST_CHAIN 2> /dev/null\";\n    return;\n}\n\nsub chk_commands() {\n    my @path = (qw(\n        /bin\n        /sbin\n        /usr/bin\n        /usr/sbin\n        /usr/local/bin\n        /usr/local/sbin\n    ));\n    CMD: for my $cmd (keys %cmds) {\n        unless (-x $cmds{$cmd}) {\n            my $found = 0;\n            PATH: for my $dir (@path) {\n                if (-x \"${dir}/${cmd}\") {\n                    $cmds{$cmd} = \"${dir}/${cmd}\";\n                    $found = 1;\n                    last PATH;\n                }\n            }\n            unless ($found) {\n                die \"[*] Could not find $cmd, edit $fwsnort_conf\";\n            }\n        }\n    }\n    return;\n}\n\nsub archive() {\n    my $file = shift;\n    return unless -e $file;\n    return unless $file =~ m|/|;\n    my ($filename) = ($file =~ m|.*/(.*)|);\n    my $targetbase = \"$config{'ARCHIVE_DIR'}/${filename}.old\";\n    for (my $i = 4; $i > 1; $i--) {  ### keep five copies of the old config files\n        my $oldfile = $targetbase . $i;\n        my $newfile = $targetbase . ($i+1);\n        if (-e $oldfile) {\n            move $oldfile, $newfile;\n        }\n    }\n    if (-e $targetbase) {\n        my $newfile = $targetbase . '2';\n        move $targetbase, $newfile;\n    }\n    &logr(\"[+] Archiving $file\");\n    move $file, $targetbase;   ### move $file into the archive directory\n    return;\n}\n\nsub write_ipt_script() {\n\n    ### archive any existing ipt_script file\n    &archive($config{'FWSNORT_SCRIPT'});\n\n    ### make sure the script is writable first\n    if (-e $config{'FWSNORT_SCRIPT'}) {\n        chmod 0755, $config{'FWSNORT_SCRIPT'} or\n            die \"[*] Could not chmod $config{'FWSNORT_SCRIPT'}: $!\";\n    }\n\n    open F, \"> $config{'FWSNORT_SCRIPT'}\" or\n        die \"[*] Could not open $config{'FWSNORT_SCRIPT'}: $!\";\n    print F \"$_\\n\" for @ipt_script_lines;\n    close F;\n\n    chmod 0500, $config{'FWSNORT_SCRIPT'} or\n        die \"[*] Could not chmod $config{'FWSNORT_SCRIPT'}: $!\";\n\n    return;\n}\n\nsub expand_addresses() {\n    my $addr_string = shift;\n    $addr_string =~ s/\\]//;\n    $addr_string =~ s/\\[//;\n\n    return ['0.0.0.0/0'] if $addr_string =~ /any/i;\n\n    my @addrs = ();\n\n    my @addrstmp = split /\\s*,\\s*/, $addr_string;\n    for my $addr (@addrstmp) {\n        if ($addr =~ m|($ip_re/$ip_re)|) {\n            push @addrs, $1;\n        } elsif ($addr =~ m|($ip_re/\\d+)|) {\n            push @addrs, $1;\n        } elsif ($addr =~ m|($ip_re)|) {\n            push @addrs, $1;\n        }\n    }\n    return \\@addrs;\n}\n\nsub run_last_cmdline() {\n\n    my $save_file = \"$homedir/.fwsnort.run\";\n\n    open S, \"< $save_file\" or die \"[*] Could not open $save_file: $!\";\n    my $arg_line = <S>;\n    close S;\n    chomp $arg_line;\n\n    print \"[+] Running with last command line args: $arg_line\\n\";\n\n    @ARGV = split /\\s+/, $arg_line;\n    @argv_cp = @ARGV;\n\n    ### run GetOpt() to get command line args\n    &handle_cmd_line();\n\n    return;\n}\n\nsub save_args() {\n    my $save_file  = \"$homedir/.fwsnort.run\";\n\n    open S, \"> $save_file\" or die \"[*] Could not open $save_file\";\n    print S \"@argv_cp\\n\";\n    close S;\n\n    return;\n}\n\nsub get_homedir() {\n    my $uid = $<;\n    if ($cmdl_homedir) {\n        $homedir = $cmdl_homedir;\n    } else {\n        ### prefer homedir specified in /etc/passwd (if it exists)\n        if (-e '/etc/passwd') {\n            open P, \"< /etc/passwd\" or die \"[*] Could not open /etc/passwd. \",\n                \"Exiting.\\n\";\n            my @lines = <P>;\n            close P;\n            for my $line (@lines) {\n                ### mbr:x:222:222:Michael Rash:/home/mbr:/bin/bash\n                chomp $line;\n                if ($line =~ /^(?:.*:){2}$uid:(?:.*:){2}(\\S+):/) {\n                    $homedir = $1;\n                    last;\n                }\n            }\n        }\n        unless ($homedir and -d $homedir) {\n            $homedir = $ENV{'HOME'} if defined $ENV{'HOME'};\n        }\n    }\n    die '[*] Could not determine homedir, use --Home option.'\n        unless ($homedir and -d $homedir);\n\n    return;\n}\n\nsub truncate_logfile() {\n    open L, \"> $config{'LOG_FILE'}\" or\n        die \"[*] Could not open $config{'LOG_FILE'}: $!\";\n    close L;\n    return;\n}\n\nsub write_save_file() {\n\n    ### append the final 'COMMIT' and 'Completed' lines\n    push @fwsnort_save_lines, \"COMMIT\\n\";\n    push @fwsnort_save_lines, $ipt_save_completed_line;\n\n    ### write out the iptables-save formatted fwsnort rules\n    &archive($config{'FWSNORT_SAVE_FILE'});\n\n    ### make sure the save file is writable first\n    if (-e $config{'FWSNORT_SCRIPT'}) {\n        chmod 0755, $config{'FWSNORT_SCRIPT'} or die $!;\n    }\n\n    open T, \"> $config{'FWSNORT_SAVE_FILE'}\" or\n        die \"[*] Could not write to: $config{'FWSNORT_SAVE_FILE'}\";\n    print T for @fwsnort_save_lines;\n    close T;\n\n    chmod 0600, $config{'FWSNORT_SAVE_FILE'} or\n        die \"[*] Could not chmod 0600 $config{'FWSNORT_SAVE_FILE'}\";\n\n    ### write out the script that will exec iptables-restore against\n    ### save file - this is what splices the fwsnort policy into the\n    ### running iptables policy\n    &archive($config{'FWSNORT_SAVE_EXEC_FILE'});\n\n    my @fws_exec_lines = ();\n    push @fws_exec_lines, &hdr_lines();\n\n    push @fws_exec_lines, <<_FWSNORT_SH_;\nDO_REVERT=0\n\nwhile getopts r f\ndo\n    case \\$f in\n        r) DO_REVERT=1\n    esac\ndone\n\nif [ \"\\$DO_REVERT\" = 1 ];\nthen\n    echo \" \"\n    echo \"[+] Reverting to original iptables policy...\"\n    $cmds{'grep'} -v FWSNORT $config{'FWSNORT_SAVE_FILE'} | exec $restore_bin\nelse\n    echo \" \"\n    echo \"[+] Splicing fwsnort $abs_num rules into the iptables policy...\"\n    $cmds{'cat'} $config{'FWSNORT_SAVE_FILE'} | exec $restore_bin\nfi\n\nexit\n\n_FWSNORT_SH_\n\n    ### make sure the file is writable first\n    if (-e $config{'FWSNORT_SAVE_EXEC_FILE'}) {\n        chmod 0755, $config{'FWSNORT_SAVE_EXEC_FILE'} or die $!;\n    }\n\n    open T, \"> $config{'FWSNORT_SAVE_EXEC_FILE'}\" or\n        die \"[*] Could not write to: $config{'FWSNORT_SAVE_EXEC_FILE'}\";\n    print T \"$_\\n\" for @fws_exec_lines;\n    close T;\n\n    chmod 0500, $config{'FWSNORT_SAVE_EXEC_FILE'} or\n        die \"[*] Could not chmod 0500 $config{'FWSNORT_SAVE_EXEC_FILE'}\";\n\n    return;\n}\n\nsub is_root() {\n    if ($< == 0 and $> == 0) {\n        $is_root = 1;\n    }\n    return;\n}\n\nsub set_non_root_values() {\n\n    if ($fwsnort_conf eq $CONFIG_DEFAULT) {\n        die \"[*] Must specify a path to readable \",\n            \"fwsnort.conf file when not running as root.\";\n    }\n\n    &set_defaults_without_ipt_test();\n    return;\n}\n\nsub set_defaults_without_ipt_test() {\n\n    $have_conntrack = 1;\n    $ipt_max_str_len = 128;\n    $ipt_max_comment_len = 255;\n    $ipt_max_log_prefix_len = 29;\n    $ipt_have_multiport_match = 1;\n    $ipt_multiport_max = 15;\n\n    ### put ipopts in the unsupported list\n    if (defined $snort_opts{'filter'}{'ipopts'}) {\n        $snort_opts{'unsupported'}{'ipopts'} =\n            $snort_opts{'filter'}{'ipopts'}{'regex'};\n        delete $snort_opts{'filter'}{'ipopts'};\n    } else {\n        $snort_opts{'unsupported'}{'ipopts'} = qr/[\\s;]ipopts:\\s*(\\w+)\\s*;/;\n    }\n\n    return;\n}\n\nsub print_final_message() {\n\n    if ($is_root) {\n        print <<_MSG_;\n\n\n    Main fwsnort $save_str file: $config{'FWSNORT_SAVE_FILE'}\n\n    You can instantiate the fwsnort policy with the following command:\n\n    $restore_bin < $config{'FWSNORT_SAVE_FILE'}\n\n    Or just execute: $config{'FWSNORT_SAVE_EXEC_FILE'}\n\n_MSG_\n    } else {\n        print <<_MSG_;\n\n    Main fwsnort $save_str file: $config{'FWSNORT_SAVE_FILE'}\n\n    It does not appear as though you are running as root, so it is NOT\n    recommended that you run the fwsnort.sh script without first re-running\n    fwsnort as root first. The reason is that non-root users cannot execute\n    iptables, and therefore fwsnort had no way to check for iptables\n    capabilities or to parse any existing iptables policy for proper splicing\n    of fwsnort rules.\n\n    Exiting.\n\n_MSG_\n    }\n    return;\n}\n\nsub logr() {\n    my $msg = shift;\n    if ($stdout) {\n        print STDOUT \"$msg\\n\";\n    } else {\n        open F, \">> $config{'LOG_FILE'}\"\n            or die \"[*] Could not open $config{'LOG_FILE'}: $!\";\n        print F \"$msg\\n\";\n        close F;\n    }\n    return;\n}\n\nsub usage() {\n    my $exit = shift;\n    print <<_USAGE_;\n\nfwsnort v$version\n[+] By Michael Rash <mbr\\@cipherdyne.org>, http://www.cipherdyne.org/\n\nUsage: fwsnort [options]\n\nOptions:\n    --strict                  - Make snort parser very strict about\n                                which options it will translate into\n                                iptables rules.\n    --ipt-script=<script>     - Print iptables script to <script>\n                                instead of the default location at\n                                /var/lib/fwsnort/fwsnort.sh\n    --ipt-apply               - Execute the fwsnort.sh script.\n    --ipt-exec                - Synonym for --ipt-apply.\n    --ipt-revert              - Revert to a version of the iptables\n                                policy without any fwsnort rules.\n    --ipt-reject              - Add a protocol dependent REJECT rule\n                                (tcp resets for tcp or icmp port\n                                unreachable for udp messages) for\n                                every logging rule.\n    --ipt-drop                - Add a DROP rule for every logging rule.\n    --ipt-list                - List all rules in fwsnort chains.\n    --List                    - Synonym for --ipt-list.\n    --ipt-flush               - Flush all rules in fwsnort chains.\n    --Flush                   - Synonym for --ipt-flush.\n    --ipt-file=<file>         - Read iptables policy from a file.\n    --ipt-log-tcp-seq         - Add the --log-tcp-sequence iptables\n                                command line argument to LOG rules.\n    --snort-sid=<sid>         - Generate an equivalent iptables rule\n                                for the specific snort id <sid> (also\n                                supports a comma separate list of sids.)\n    --exclude-sid=<sid>       - Exclude a list of sids from translation.\n    --snort-conf=<file>       - Read Snort specific variables out of\n                                existing snort.conf file.\n    --snort-rdir=<dir>        - Specify path to Snort rules directory.\n                                This can be a list of directories separated\n                                by commas.\n    --snort-rfile=<file>      - Translate a single rules file (or a set of\n                                them separated by commas).\n    --ipt-check-capabilities  - Check iptables capabilities and exit.\n    --no-ipt-comments         - Do not add Snort \"msg\" fields to iptables\n                                rules with the iptables comment match.\n    --ipt-sync                - Only add iptables rules for signatures that\n                                are not already blocked by iptables.\n    --no-ipt-log              - Do not generate iptables log rules\n                                (can only be used with --ipt-drop).\n    --no-ipt-test             - Do not run any checks for availability\n                                of iptables modules (string, LOG,\n                                ttl, etc.).\n    --no-ipt-jumps            - Do not jump packets from built-in\n                                iptables INPUT or FORWARD chains to\n                                chains created by fwsnort.\n    --no-ipt-rule-nums        - For each iptables rule, add the rule\n                                number in the fwsnort chain to the\n                                logging prefix.  This option disables\n                                this behavior.\n    --no-ipt-INPUT            - Exclude INPUT chain processing.\n    --no-ipt-OUTPUT           - Exclude OUTPUT chain processing.\n    --no-ipt-FORWARD          - Exclude FORWARD chain processing.\n    --no-fast-pattern-order   - Do not reorder patterns based on length,\n                                and ignore the 'fast_pattern' keyword\n    --no-log-ip-opts          - Do not add --log-ip-options to LOG\n                                rules.\n    --no-log-tcp-opts         - Do not add --log-tcp-options to LOG\n                                rules.\n    --no-addresses            - Do not look at addresses assigned to\n                                local interfaces (useful for running\n                                fwsnort on a bridge).\n    --no-exclude-lo           - Do not exclude the loopback interface\n                                from fwsnort rules.\n    --restrict-intf=<intf>    - Restrict fwsnort rules to a specified\n                                interface (e.g. \"eth0\").\n    -6, --ip6tables           - Enable ip6tables mode to build an fwsnort\n                                policy via ip6tables instead of iptables.\n    --Home-net=<net/mask>     - Manually specify the Home network\n                                (CIDR or standard notation).\n    --External-net=<net/mask> - Manually specify the external network\n                                (CIDR or standard notation).\n    --update-rules            - Download latest rules from Emerging Threats\n                                (http://www.emergingthreats.net).\n    --rules-url=<url>         - Specify the URL to use for updating the\n                                Emerging Threats rule set - the default is:\n                                $rules_url\n    --include-perl-triggers   - Include 'perl -e \"print ...\"' commands that\n                                build payload data that matches snort\n                                rules.  By combining these commands with\n                                netcat, it is easy to test whether the\n                                iptables policy built by fwsnort properly\n                                detects attacks.\n    --include-type=<type>     - Only process snort rules of type <type>\n                                (e.g. \"ddos\" or \"backdoor\"). <type> can\n                                be a comma separated list.\n    --exclude-type=<type>     - Exclude processing of Snort rules of\n                                type <type> (e.g. \"ddos\" or \"backdoor\").\n                                <type> can be a comma separated list.\n    --include-regex=<regex>   - Include only those signatures that\n                                match the specified regex.\n    --exclude-regex=<regex>   - Exclude all Snort signatures that\n                                match the specified regex.\n    --include-re-caseless     - Make --include-regex searching case\n                                insensitive.\n    --exclude-re-caseless     - Make --exclude-regex searching case\n                                insensitive.\n    -c   --config=<config>    - Use <config> instead of the normal\n                                config file located at\n                                $fwsnort_conf\n    --logfile=<file>          - Log messages to <file> instead of the\n                                default location at:\n                                /var/log/fwsnort/fwsnort.log\n    -N   --NFQUEUE            - Build a policy designed to only send packets\n                                that match Snort signature \"content\" fields\n                                to userspace via the NFQUEUE target. This is\n                                designed to build a hybrid fwsnort policy\n                                that can be used by snort_inline.\n    --queue-num=<num>         - Specify the queue number in --NFQUEUE mode;\n                                the default is zero.\n    --queue-rules-dir=<dir>   - Specify the path to the generated set of\n                                Snort rules that are to be queued to\n                                userspace in --NFQUEUE or --QUEUE mode.  The\n                                default is /var/lib/fwsnort/snort_rules_queue/.\n    -Q   --QUEUE              - Same as the --NFQUEUE option, except use the\n                                older iptables QUEUE target.\n    --string-match-alg=<alg>  - Specify the string match algorithm to use\n                                within the kernel; the default is '$string_match_alg',\n                                but 'kmp' may also be chosen.\n    -U   --Ulog               - Force ULOG target for all log generation.\n    --ulog-nlgroup=<groupnum> - Specify a ULOG netlink group (the default\n                                is 1).  This gets used in -U mode, or for\n                                \"log\" rules since then we need all of the\n                                packet to be logged (via the ULOG pcap\n                                writer).\n    --Dump-ipt                - Dump iptables rules on STDOUT as the\n                                rules are parsed (most useful when trying\n                                to debug how Fwsnort integrates with an\n                                existing iptables policy).\n    --Dump-snort              - Dump Snort rules on STDOUT.\n    --Dump-conf               - Dump configuration on STDOUT and exit.\n    --add-deleted             - Added Snort \"deleted\" rules.\n    --Last-cmd                - Rebuild fwsnort.sh with the same command\n                                line args as the previous execution.\n    --lib-dir=<path>          - Specify path to lib directory.\n    --debug                   - Run in debug mode.\n    -v   --verbose            - Run in verbose mode.\n    -V   --Version            - Print fwsnort version number and exit.\n    -h   --help               - Display usage on STDOUT and exit.\n\n_USAGE_\n    exit $exit;\n}\n", ".\\\" Process this file with\n.\\\" groff -man -Tascii foo.1\n.\\\"\n.TH FWSNORT 8 \"Jan, 2011\" Linux\n.SH NAME\n.B fwsnort\n\\- Firewall Snort\n.SH SYNOPSIS\n.B fwsnort [options]\n.SH DESCRIPTION\n.B fwsnort\ntranslates SNORT rules into iptables rules on Linux systems and generates a\ncorresponding iptables policy in iptables-save format.  This ruleset allows\nnetwork traffic that matches Snort signatures (i.e.  attacks and other suspicious\nnetwork behavior) to\nbe logged and/or dropped by iptables directly without putting an interface\ninto promiscuous mode or queuing packets from kernel to user space.  Note\nthat fwsnort can also build an iptables policy that combines the string\nmatch extension with the NFQUEUE or QUEUE targets to allow the kernel to\nperform preliminary string matches that are defined within Snort rules\nbefore queuing matching packets to a userspace snort_inline instance.  Because the bulk of\nnetwork communications are not generallly malicious, this should provide a speedup\nfor snort_inline since the majority of packets do not then have to be\ncopied from kernel memory into user memory and subsequently inspected by\nsnort_inline.  There is a tradeoff here in terms of signature detection\nhowever because snort_inline when deployed in this way does not have the\nopportunity to see all packets associated with a session, so stream\nreassembly and signature comparisons against a reassembled buffer do not\ntake place (the stream preprocessor should be disabled in the userspace\nsnort_inline instance).\n\nAs of\n.B fwsnort-1.5\nall iptables rules built by fwsnort are written out to the\n.I /var/lib/fwsnort/fwsnort.save\nfile in iptables-save format.  This allows a long fwsnort policy (which may\ncontain thousands of iptables rules translated from a large Snort signature\nset) to be quickly instantiated via the \"iptables-restore\" command.  A wrapper\nscript\n.I /var/lib/fwsnort/fwsnort.sh\nis also written out to make this easy.  Hence, the typical work flow for\nfwsnort is to: 1) run fwsnort, 2) note the Snort rules that fwsnort was able\nto successfully translate (the number of such rules is printed to stdout),\nand then 3) execute the\n.I /var/lib/fwsnort/fwsnort.sh\nwrapper script to instantiate the policy in the running kernel.\n\n.B fwsnort\n(optionally) uses the IPTables::Parse CPAN module to parse\nthe iptables ruleset on the machine to determine which Snort rules are\napplicable to the specific iptables policy.  After all, if iptables is\nblocking all inbound http traffic from external addresses for example, it\nis probably not of much use to try detecting inbound attacks against against\ntcp/80.  By default fwsnort generates iptables rules that log Snort sid's\nwithin a \\-\\-log-prefix to syslog where the messages can be analyzed with a\nlog analyzer such as\n.B psad\n(see http://www.cipherdyne.org/psad/).\n.B fwsnort\nrelies on the iptables string match module to match Snort content fields\nin the application portion of ip traffic.  Since Snort rules can contain\nhex data in content fields (specified between pipe \"|\" characters), fwsnort\nimplements a patch against iptables (which has been accepted by the Netfilter\nproject as of iptables-1.2.7a) which adds a \"\\-\\-hex-string\" option.  This\nallow iptables to accept content fields from Snort rules such as\n\"|0d0a5b52504c5d3030320d0a|\" without any modification.\n.B fwsnort\nis able to translate approximately 60% of all rules from the Snort-2.3.3\nIDS into equivalent iptables rules.  For more information about the\ntranslation strategy as well as advantages/disadvantages of the method\nused by fwsnort to obtain intrusion detection data, see the README\nincluded with the fwsnort sources or browse to:\nhttp://www.cipherdyne.org/fwsnort/\n\n.B fwsnort\nis able to apply Snort rules to IPv6 traffic by building an ip6tables policy\n(see the \"\\-\\-ip6tables\" command line argument).\n.SH OPTIONS\n.TP\n.BR \\-c \", \" \\-\\^\\-config\\ \\<configuration\\ file>\nBy default fwsnort makes use of the configuration file\n.B /etc/fwsnort/fwsnort.conf\nfor almost all configuration parameters.  fwsnort can be made to\noverride this path by specifying a different file on the command\nline with the \\-\\-config option.  When fwsnort is not executed as root, then\na path to a readable fwsnort.conf file is required.\n.TP\n.BR \\-\\^\\-update-rules\nDownload the latest Emerging Threats rules from http://www.emergingthreats.net\nThis will overwrite the  emerging-all.rules file in the\n/etc/fwsnort/snort_rules/ directory.  Note that the automatic downloading\nof Snort rules from http://www.snort.org/ as of March, 2005 is only offered\nas a pay service.\n.TP\n.BR \\-\\^\\-rules-url\\ \\ <url>\nSpecify the URL to use when updating the Emerging Threats rule set (or any\nother rule set).  The default URL is: http://rules.emergingthreats.net/open/snort-2.9.0/emerging-all.rules\n.TP\n.BR \\-6 \", \" \\-\\^\\-ip6tables\nEnable\n.B ip6tables\nmode so that the fwsnort rule set is built into an ip6tables policy instead\nof the iptables policy.  This allows fwsnort controls to apply to IPv6\ntraffic.\n.TP\n.BR \\-\\^\\-include-type\\ \\ <rules\\ type>\nRestrict to processing snort rules of <rules type>.  Example rule\ntypes would include \"ddos\", \"backdoor\", and \"web-attacks\".  This option\nalso supports a comma-separated list of types, e.g. \"ddos,backdoor\".\n.TP\n.BR \\-\\^\\-exclude-type\\ \\ <rules\\ type>\nExclude all Snort rules from of type <rules type> from the translation\nprocess.  For example, if you don't want any rules from the file\nemerging-all.rules to be translated, then use \"emerging-all\" as the\nargument to this option.  A comma-separated list of types to exclude can\nbe specified.\n.TP\n.BR \\-\\^\\-include-regex\\ \\ <regex>\nOnly translate Snort rules that match the specified regular expression. This\nis useful to build\n.B fwsnort\npolicies for Snort rules that have a common characteristic (such as a string\nmatch on the word \"Storm\" for the Storm worm for example).\n.TP\n.BR \\-\\^\\-exclude-regex\\ \\ <regex>\nTranslate all Snort rules except those that match the specified regular\nexpression.  This is useful to omit Snort rules from\n.B fwsnort\npolicies that have a common characteristic (such as a string\nmatch on \"HTTP_PORTS\" for example).\n.TP\n.BR \\-\\^\\-include-re-caseless\nMake the rule matchine regular expression specified with\n.I \\-\\-include\\-regex\nmatch case insensitively.\n.TP\n.BR \\-\\^\\-exclude-re-caseless\nMake the rule matchine regular expression specified with\n.I \\-\\-exclude\\-regex\nmatch case insensitively.\n.TP\n.BR \\-\\^\\-snort-rdir\\ <snort-rules-directory>\nManually specify the directory where the snort rules files are located.\nThe default is\n.B /etc/fwsnort/snort_rules.\nMultiple directories are supported as a comma-separated list.\n.TP\n.BR \\-\\^\\-snort-rfile\\ <snort-rules-file>\nManually specify a Snort rules file to translated into iptables rules.\nMultiple files are also supported as a comma-separated list.\n.TP\n.BR \\-\\^\\-snort-sid\\ \\<sid>\nGenerate an iptables ruleset for a single snort rule specified by\n<sid>.  A comma-separated list of sids can be specified, e.g. \"2001842,1834\".\n.TP\n.BR \\-\\^\\-exclude-sid\\ \\<sid>\nProvide a list of Snort ID's to be excluded from the translation process.\n.TP\n.BR \\-\\^\\-include-perl-triggers\nInclude\n.I 'perl -e \"print ...\"'\ncommands as comments in the\n.I fwsnort.sh\nscript.  These commands allow payloads that are designed to trigger snort\nrules to easily be built, and when combined with netcat (or other software\nthat can send bytes over the wire) it becomes possible to test whether an\nfwsnort policy appropriately triggers on matching traffic.\n.TP\n.BR \\-\\^\\-ipt-script\\ \\<script\\ file>\nSpecify the path to the iptables script generated by fwsnort.  The\ndefault location is /var/lib/fwsnort/fwsnort.sh.\n.TP\n.BR \\-\\^\\-ipt-check-capabilities\nCheck iptables capabilities and exit.\n.TP\n.BR \\-\\^\\-Last\\-cmd\nRun\n.B fwsnort\nwith the same command line arguments as the previous execution.  This is a\nconvenient way of rebuilding the\n.I /var/lib/fwsnort/fwsnort.sh\nscript without having to remember what the last command line args were.\n.TP\n.BR \\-\\^\\-NFQUEUE\nBuild an\n.B fwsnort\npolicy that sends packets that match Snort\n.B content\nor\n.B uricontent\nfields to userspace via the iptables NFQUEUE target for further analysis.  This is a\nmechanism for reducing the signature inspection load placed on snort_inline.\nA parallel set of Snort rules that are successfully translated are placed in\nthe /etc/fwsnort/snort_rules_queue directory.  This requires\nCONFIG_NETFILTER_XT_TARGET_NFQUEUE support in the Linux kernel.\n.TP\n.BR \\-\\^\\-QUEUE\nSame as the\n.B --NFQUEUE\ncommand line argument except that the older QUEUE target is used instead of\nthe NFQUEUE target.  This requires CONFIG_IP_NF_QUEUE support in the Linux kernel.\n.TP\n.BR \\-\\^\\-queue-num\\ \\<num>\nSpecify a queue number in \\-\\-NFQUEUE mode.\n.TP\n.BR \\-\\^\\-queue-pre-match-max\\ \\<num>\nIn \\-\\-QUEUE or \\-\\-NFQUEUE mode, limit the number of content matches that are\nperformed within the kernel before sending a matching packet to a userspace\nSnort instance.  This allows a level of tuning with respect to how much work\nthe kernel does to qualify a packet based on a signature match before having\nSnort do the same thing.  The default is to perform all specified content\nmatches in the signature before queuing the packet to userspace because the\nmultiple in-kernel content matches is probably less expensive than sending a\npacket to userspace by default.\n.TP\n.BR \\-\\^\\-string-match-alg\\ \\<alg>\nSpecify the string matching algorithm to use with the kernel.  By default, this\nis 'bm' for the 'Boyer-Moore' string matching algorithm, but 'kmp' may also be\nspecified (short for the 'Knuth\u2013Morris\u2013Pratt' algorithm).\n.TP\n.BR \\-\\^\\-ipt-apply\nExecute the iptables script generated by fwsnort.\n.TP\n.BR \\-\\^\\-ipt-exec\nSynonym for \\-\\-ipt-apply.\n.TP\n.BR \\-\\^\\-ipt-revert\nRevert to a version of the iptables policy without any\n.B fwsnort\nrules.  Note that this reverts to the iptables policy as it was when\n.B fwsnort\nwas originally executed.  So, it is not recommended to use this option if there\nis a large amount of time between when fwsnort is run to translate Snort rules\nvs. running it with this option.  For most purposes it is better to use\nthe \\-\\-ipt-flush option below.\n.TP\n.BR \\-\\^\\-ipt-flush\nFlush all\n.B fwsnort\ncurrently active iptables rules (flushes the fwsnort chains).\n.TP\n.BR \\-\\^\\-ipt-list\nList all\n.B fwsnort\ncurrently active iptables rules (lists the fwsnort chains).\n.TP\n.BR \\-\\^\\-ipt-drop\nFor each logging rule generated by\n.B fwsnort\nadd a corresponding DROP\nrule.  Note that for TCP sessions using this option will cause retransmissions\nas packets that are part of established sessions selectively dropped.\nRemember that false positives are common occurrences for intrusion detection\nsystems, and so using this or the \\-\\-ipt-reject option may break things on\nyour network!  You have been warned.\n.TP\n.BR \\-\\^\\-ipt-reject\nFor each logging rule generated by\n.B fwsnort\nadd a corresponding REJECT rule.\nReset packets will be generated for TCP sessions through the use of\nthe \"\\-\\-reject-with tcp-reset\" option, and ICMP port unreachable messages will\nbe generated for UDP packets through the use of the\n\"\\-\\-reject-with icmp-port-unreachable\" option.\n.TP\n.BR \\-C \", \" \\-\\^\\-Conntrack-state\\ \\<state>\nSpecify a conntrack state in place of the \"established\" state that commonly\naccompanies the Snort \"flow\" keyword.  By default, fwsnort uses the conntrack\nstate of \"ESTABLISHED\" for this.  In certain corner cases, it might be useful\nto use \"ESTABLISHED,RELATED\" instead to apply application layer inspection to\nthings like ICMP port unreachable messages that are responses to real attempted\ncommunications.\n.TP\n.BR \\-\\^\\-no-ipt-log\nBy default fwsnort generates an iptables script that implements a logging\nrule for each successfully translated snort rule.  This can be disabled\nwith the \\-\\-no-ipt-log option, but \\-\\-ipt-drop must also be specified.\n.TP\n.BR \\-\\^\\-no-ipt-sync\nThis is a deprecated option since the default behavior is to translate as\nmany Snort rules into iptables rules as possible.  With\n.B fwsnort\nable to produce iptables rules in iptables\\-save format, it is extremely fast\nto instantiate a large set of translated Snort rules into an iptables policy.\nA new \\-\\-ipt-sync option has been added to reverse this behavior (not\nrecommended).\n.TP\n.BR \\-\\^\\-ipt-sync\nConsult the iptables policy currently running on the machine\nfor applicable snort rules.\n.TP\n.BR \\-\\^\\-no-ipt-test\nDo not test the iptables build for existence of support for the LOG and\nREJECT targets, and ascii and hex string matching.\n.TP\n.BR \\-\\^\\-no-ipt-jumps\nDo not jump packets from the built-in iptables INPUT, OUTPUT, and\nFORWARD chains to the custom\n.B fwsnort\nchains.  This options is mostly useful to make it\neasy to manually alter the placement of the jump rules in the iptables\nruleset.\n.TP\n.BR \\-\\^\\-no-ipt-rule-nums\nBy default\n.B fwsnort\nincludes the rule number within the logging prefix for each of the rules it\nadds to the fwsnort chains.  E.g. the logging prefix for rule 34 would look\nsomething like \"[34] SID1242 ESTAB\".  Use this option to not include the\nrule number.\n.TP\n.BR \\-\\^\\-no-ipt-comments\nIf the iptables \"comment\" match exists, then\n.B fwsnort\nputs the Snort \"msg\", \"classtype\", \"reference\", \"priority\", and \"rev\" fields\nwithin a comment for each iptables rule.  Use this option to disable this.\n.TP\n.BR \\-\\^\\-no-ipt-INPUT\nDo not jump packets from the iptables INPUT chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-ipt-OUTPUT\nDo not jump packets from the iptables OUTPUT chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-ipt-FORWARD\nDo not jump packets from the iptables FORWARD chain to the\n.B fwsnort\nchains.\n.TP\n.BR \\-\\^\\-no-fast-pattern-ordering\nCause\n.B fwsnort\nto not try to reorder pattern matches to process the longest pattern first.\nThe Snort\n.I fast_pattern\nkeyword is also ignored if this option is specified.\n.TP\n.BR \\-H \", \" \\-\\^\\-Home-net\\ \\<network/mask>\nSpecify the internal network instead of having\n.B fwsnort\nderive it from the HOME_NET keyword in the fwsnort.conf configuration\nfile.\n.TP\n.BR \\-E \", \" \\-\\^\\-External-net\\ \\<network/mask>\nSpecify the external network instead of having\n.B fwsnort\nderive it from the EXTERNAL_NET keyword in the fwsnort.conf configuration\nfile.\n.TP\n.BR \\-\\^\\-no-addresses\nDisable all checks against the output of ifconfig for proper IP addresses.\nThis is useful if\n.B fwsnort\nis running on a bridging firewall.\n.TP\n.BR \\-\\^\\-Dump-conf\nPrint the fwsnort configuration on STDOUT and exit.\n.TP\n.BR \\-\\^\\-debug\nRun in debug mode.  This will cause all parse errors which are normally\nwritten to the fwsnort logfile\n.B /var/log/fwsnort.log\nto be written to STDOUT instead.\n.TP\n.BR \\-\\^\\-strict\nRun fwsnort in \"strict\" mode.  This will prevent fwsnort from translating\nsnort rules that contain the keywords \"offset\", \"uricontent\", and \"depth\".\n.TP\n.BR \\-U \", \" \\-\\^\\-Ulog\nForce the usage of the ULOG target for all log messages instead of the\ndefault LOG target.\n.TP\n.BR \\-\\^\\-ulog-nlgroup\nSpecify the netlink group for ULOG rules.  Such rules are only added for\nSnort rules that have an action of \"log\", or when\n.B fwsnort\nis run in\n.B --Ulog\nmode.\n.TP\n.BR \\-l \", \" \\-\\^\\-logfile\\ <logfile>\nBy default fwsnort logs all parse errors to the logfile\n.B /var/log/fwsnort.log.\nThis path can be manually changed with the \\-\\-logfile option.\n.TP\n.BR \\-v \", \" \\-\\^\\-verbose\nRun fwsnort in verbose mode.  This will cause fwsnort to add the original\nsnort rule as a comment to the fwsnort.sh script for each successfully\ntranslated rule.\n.TP\n.BR \\-V \", \" \\-\\^\\-Version\nPrint the fwsnort version and exit.\n.TP\n.BR \\-h \", \" \\-\\^\\-help\nPrint usage information on STDOUT and exit.\n.SH FILES\n.B /etc/fwnort/fwsnort.conf\n.RS\nThe fwsnort configuration file.  The path to this file can be\nchanged on the command line with \\-\\-config.\n.RE\n\n.B /var/lib/fwnort/fwsnort.sh\n.RS\nThe iptables script generated by fwsnort.  The path can be manually\nspecified on the command line with the \\-\\-ipt-script option.\n.SH FWSNORT CONFIGURATION VARIABLES\nThis section describes what each of the more important fwsnort configuration\nvariables do and how they can be tuned to meet your needs.  These variables\nare located in the fwsnort configuration file\n.B /etc/fwsnort/fwsnort.conf\n.TP\n.BR HOME_NET\n.B fwsnort\nuses the same HOME_NET and EXTERNAL_NET variables as defined in Snort rules,\nand the same semantics are supported.  I.e., individual IP addresses or networks\nin standard dotted-quad or CIDR notation can be specified, and comma separated\nlists are also supported.\n.TP\n.BR EXTERNAL_NET\nDefines the external network.  See the HOME_NET variable for more information.\n.SH EXAMPLES\nThe following examples illustrate the command line arguments that could\nbe supplied to fwsnort in a few situations:\n.PP\nScript generation in logging mode, parse errors written to the fwsnort\nlogfile, and iptables policy checking are enabled by default without\nhaving to specify any command line arguments:\n.PP\n.B # fwsnort\n.PP\nGenerate ip6tables rules for attacks delivered over IPv6:\n.PP\n.B # fwsnort -6\n.PP\nGenerate iptables rules for ddos and backdoor Snort rules only:\n.PP\n.B # fwsnort --include-type ddos,backdoor\n.PP\nGenerate iptables rules for Snort ID's 2008475 and 2003268 (from emerging-all.rules):\n.PP\n.B fwsnort --snort-sid 2008475,2003268\n.PP\nGenerate iptables rules for Snort ID's 1834 and 2001842 but queue them to userspace\nvia the NFQUEUE target and restrict exclude the INPUT and OUTPUT chains:\n.PP\n.B fwsnort --snort-sid 1834,2001842 --NFQUEUE --no-ipt-INPUT --no-ipt-OUTPUT\n.PP\nInstruct\n.B fwsnort\nto only inspect traffic that traverses the eth0 and eth1 interfaces:\n.PP\n.B # fwsnort --restrict-intf eth0,eth1\n.PP\nGenerate iptables rules for Snort rules that appear to be allowed by the local\niptables policy, and write original snort rules to the iptables script as a comment:\n.PP\n.B # fwsnort --ipt-sync --verbose\n.SH DEPENDENCIES\n.B fwsnort\nrequires that the iptables string match module be compiled into the\nkernel (or as a loadable kernel module) in order to be able to match\nsnort signatures that make use of the \"content\" keyword.  Note that\nthe \\-\\-no-opt-test option can be specified to have fwsnort generate an\niptables script even if the string match module is not compiled in.\n.PP\n.B fwsnort\nalso requires the IPTables::Parse CPAN module in order to parse\niptables policies.  This module is bundled with the fwsnort sources in\nthe deps/ directory for convenience.\n.SH DIAGNOSTICS\nThe \\-\\-debug option can be used to display on STDOUT any errors that\nare generated as fwsnort parses each snort rule.  Normally these\nerrors are written to the fwsnort logfile /var/log/fwsnort.log\n.SH \"SEE ALSO\"\n.BR psad (8),\n.BR iptables (8),\n.BR snort (8),\n.BR nmap (1)\n.SH AUTHOR\nMichael Rash <mbr@cipherdyne.org>\n.SH CONTRIBUTORS\nMany people who are active in the open source community have contributed to fwsnort;\nsee the\n.B CREDITS\nfile in the fwsnort sources, or visit\n.B http://www.cipherdyne.org/fwsnort/docs/contributors.html\nto view the online list of contributors.\n\n.B fwsnort\nis based on the original\n.B snort2iptables\nscript written by William Stearns.\n.SH BUGS\nSend bug reports to mbr@cipherdyne.org. Suggestions and/or comments are\nalways welcome as well.\n.SH DISTRIBUTION\n.B fwsnort\nis distributed under the GNU General Public License (GPLv2), and the latest\nversion may be downloaded from\n.B http://www.cipherdyne.org/\nSnort is a registered trademark of Sourcefire, Inc.\n"], "filenames": ["CREDITS", "ChangeLog", "fwsnort", "fwsnort.8"], "buggy_code_start_loc": [92, 0, 4662, 85], "buggy_code_end_loc": [92, 0, 4665, 86], "fixing_code_start_loc": [93, 1, 4663, 85], "fixing_code_end_loc": [102, 10, 4667, 87], "type": "NVD-CWE-Other", "message": "Untrusted search path vulnerability in fwsnort before 1.6.4, when not running as root, allows local users to execute arbitrary code via a Trojan horse fwsnort.conf in the current working directory.", "other": {"cve": {"id": "CVE-2014-0039", "sourceIdentifier": "secalert@redhat.com", "published": "2014-02-08T00:55:06.113", "lastModified": "2014-02-21T05:06:09.170", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/426.html\n\n\"CWE-426: Untrusted Search Path\"", "descriptions": [{"lang": "en", "value": "Untrusted search path vulnerability in fwsnort before 1.6.4, when not running as root, allows local users to execute arbitrary code via a Trojan horse fwsnort.conf in the current working directory."}, {"lang": "es", "value": "Vulnerabilidad de b\u00fasqueda de ruta no confiable en fwsnort anterior a 1.6.4, cuando no es ejecutado como root, permite a usuarios locales ejecutar c\u00f3digo arbitrario a trav\u00e9s de un caballo de troya en fwsnort.conf en el directorio de trabajo actual."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.6.4", "matchCriteriaId": "170A21ED-7050-40B0-B11F-E63727579442"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "E4EC707F-46CD-44EE-BCDD-189D6F70FB95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "495A77C4-39A8-4858-8DBE-FE1F74ED631F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "A1EFAD69-44B1-4485-B9B1-037445FAF5DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "7844F7AF-BA8A-4EB4-BE62-1B8537083E7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D30B951D-FF25-434E-A9BA-37C6F615DB45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "003F7E4B-C398-47B0-8930-49874384FFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "4C556AEE-80FC-4DD4-BBF9-90FB23D121D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F7773C4-0A27-482E-BFC9-80C39CE3B413"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "40B1E95B-9B88-48A8-ACB2-D39E771533F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "F9AAC770-99D3-4831-BFE6-9D18365D5D6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "599C3D77-2613-435E-B0A9-49CC0DB0EB5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "221A4123-FD80-491A-88FE-8CD0981C30D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "257CD4EE-2004-4270-8603-F7945CA3395A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "8EE760A8-A555-4FED-9D2D-62FD95704D8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E630E2C4-0382-4B30-A21E-683B78851CC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "85CA3B40-9AE2-4BB5-A5A8-89977C256047"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "E9C4F2A0-E32E-464A-9870-458E261B6A0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "7C08624B-505E-4B2D-8BAD-69AD6C7CD153"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "7B22F1F4-6A4F-4260-BEEF-72E3C85735CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "BA40AF1B-4B80-4FAA-8FCD-01E25584555B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "F3E2D5AD-3F53-4B10-B232-E96158392E84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "987CD07D-A6F4-4D6D-AD63-EBA87A89C2F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "B96FB1B4-DA6C-40FB-AF23-E44FE5D4050A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cipherdyne:fwsnort:1.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "E0AF9A22-165E-4F51-A604-70C5A5E8D763"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-February/128188.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-February/128205.html", "source": "secalert@redhat.com"}, {"url": "http://seclists.org/oss-sec/2014/q1/221", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/65341", "source": "secalert@redhat.com"}, {"url": "https://github.com/mrash/fwsnort/blob/master/ChangeLog", "source": "secalert@redhat.com"}, {"url": "https://github.com/mrash/fwsnort/commit/fa977453120cc48e1654f373311f9cac468d3348", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/mrash/fwsnort/commit/fa977453120cc48e1654f373311f9cac468d3348"}}