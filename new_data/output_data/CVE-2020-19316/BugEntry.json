{"buggy_code": ["<?php\n\nnamespace Illuminate\\Filesystem;\n\nuse ErrorException;\nuse FilesystemIterator;\nuse Symfony\\Component\\Finder\\Finder;\nuse Illuminate\\Support\\Traits\\Macroable;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\n\nclass Filesystem\n{\n    use Macroable;\n\n    /**\n     * Determine if a file or directory exists.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function exists($path)\n    {\n        return file_exists($path);\n    }\n\n    /**\n     * Get the contents of a file.\n     *\n     * @param  string  $path\n     * @param  bool  $lock\n     * @return string\n     *\n     * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n     */\n    public function get($path, $lock = false)\n    {\n        if ($this->isFile($path)) {\n            return $lock ? $this->sharedGet($path) : file_get_contents($path);\n        }\n\n        throw new FileNotFoundException(\"File does not exist at path {$path}\");\n    }\n\n    /**\n     * Get contents of a file with shared access.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function sharedGet($path)\n    {\n        $contents = '';\n\n        $handle = fopen($path, 'rb');\n\n        if ($handle) {\n            try {\n                if (flock($handle, LOCK_SH)) {\n                    clearstatcache(true, $path);\n\n                    $contents = fread($handle, $this->size($path) ?: 1);\n\n                    flock($handle, LOCK_UN);\n                }\n            } finally {\n                fclose($handle);\n            }\n        }\n\n        return $contents;\n    }\n\n    /**\n     * Get the returned value of a file.\n     *\n     * @param  string  $path\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n     */\n    public function getRequire($path)\n    {\n        if ($this->isFile($path)) {\n            return require $path;\n        }\n\n        throw new FileNotFoundException(\"File does not exist at path {$path}\");\n    }\n\n    /**\n     * Require the given file once.\n     *\n     * @param  string  $file\n     * @return mixed\n     */\n    public function requireOnce($file)\n    {\n        require_once $file;\n    }\n\n    /**\n     * Get the MD5 hash of the file at the given path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function hash($path)\n    {\n        return md5_file($path);\n    }\n\n    /**\n     * Write the contents of a file.\n     *\n     * @param  string  $path\n     * @param  string  $contents\n     * @param  bool  $lock\n     * @return int|bool\n     */\n    public function put($path, $contents, $lock = false)\n    {\n        return file_put_contents($path, $contents, $lock ? LOCK_EX : 0);\n    }\n\n    /**\n     * Write the contents of a file, replacing it atomically if it already exists.\n     *\n     * @param  string  $path\n     * @param  string  $content\n     * @return void\n     */\n    public function replace($path, $content)\n    {\n        // If the path already exists and is a symlink, get the real path...\n        clearstatcache(true, $path);\n\n        $path = realpath($path) ?: $path;\n\n        $tempPath = tempnam(dirname($path), basename($path));\n\n        // Fix permissions of tempPath because `tempnam()` creates it with permissions set to 0600...\n        chmod($tempPath, 0777 - umask());\n\n        file_put_contents($tempPath, $content);\n\n        rename($tempPath, $path);\n    }\n\n    /**\n     * Prepend to a file.\n     *\n     * @param  string  $path\n     * @param  string  $data\n     * @return int\n     */\n    public function prepend($path, $data)\n    {\n        if ($this->exists($path)) {\n            return $this->put($path, $data.$this->get($path));\n        }\n\n        return $this->put($path, $data);\n    }\n\n    /**\n     * Append to a file.\n     *\n     * @param  string  $path\n     * @param  string  $data\n     * @return int\n     */\n    public function append($path, $data)\n    {\n        return file_put_contents($path, $data, FILE_APPEND);\n    }\n\n    /**\n     * Get or set UNIX mode of a file or directory.\n     *\n     * @param  string  $path\n     * @param  int  $mode\n     * @return mixed\n     */\n    public function chmod($path, $mode = null)\n    {\n        if ($mode) {\n            return chmod($path, $mode);\n        }\n\n        return substr(sprintf('%o', fileperms($path)), -4);\n    }\n\n    /**\n     * Delete the file at a given path.\n     *\n     * @param  string|array  $paths\n     * @return bool\n     */\n    public function delete($paths)\n    {\n        $paths = is_array($paths) ? $paths : func_get_args();\n\n        $success = true;\n\n        foreach ($paths as $path) {\n            try {\n                if (! @unlink($path)) {\n                    $success = false;\n                }\n            } catch (ErrorException $e) {\n                $success = false;\n            }\n        }\n\n        return $success;\n    }\n\n    /**\n     * Move a file to a new location.\n     *\n     * @param  string  $path\n     * @param  string  $target\n     * @return bool\n     */\n    public function move($path, $target)\n    {\n        return rename($path, $target);\n    }\n\n    /**\n     * Copy a file to a new location.\n     *\n     * @param  string  $path\n     * @param  string  $target\n     * @return bool\n     */\n    public function copy($path, $target)\n    {\n        return copy($path, $target);\n    }\n\n    /**\n     * Create a hard link to the target file or directory.\n     *\n     * @param  string  $target\n     * @param  string  $link\n     * @return void\n     */\n    public function link($target, $link)\n    {\n        if (! windows_os()) {\n            return symlink($target, $link);\n        }\n\n        $mode = $this->isDirectory($target) ? 'J' : 'H';\n\n        exec(\"mklink /{$mode} \\\"{$link}\\\" \\\"{$target}\\\"\");\n    }\n\n    /**\n     * Extract the file name from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function name($path)\n    {\n        return pathinfo($path, PATHINFO_FILENAME);\n    }\n\n    /**\n     * Extract the trailing name component from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function basename($path)\n    {\n        return pathinfo($path, PATHINFO_BASENAME);\n    }\n\n    /**\n     * Extract the parent directory from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function dirname($path)\n    {\n        return pathinfo($path, PATHINFO_DIRNAME);\n    }\n\n    /**\n     * Extract the file extension from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function extension($path)\n    {\n        return pathinfo($path, PATHINFO_EXTENSION);\n    }\n\n    /**\n     * Get the file type of a given file.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function type($path)\n    {\n        return filetype($path);\n    }\n\n    /**\n     * Get the mime-type of a given file.\n     *\n     * @param  string  $path\n     * @return string|false\n     */\n    public function mimeType($path)\n    {\n        return finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);\n    }\n\n    /**\n     * Get the file size of a given file.\n     *\n     * @param  string  $path\n     * @return int\n     */\n    public function size($path)\n    {\n        return filesize($path);\n    }\n\n    /**\n     * Get the file's last modification time.\n     *\n     * @param  string  $path\n     * @return int\n     */\n    public function lastModified($path)\n    {\n        return filemtime($path);\n    }\n\n    /**\n     * Determine if the given path is a directory.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function isDirectory($directory)\n    {\n        return is_dir($directory);\n    }\n\n    /**\n     * Determine if the given path is readable.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isReadable($path)\n    {\n        return is_readable($path);\n    }\n\n    /**\n     * Determine if the given path is writable.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isWritable($path)\n    {\n        return is_writable($path);\n    }\n\n    /**\n     * Determine if the given path is a file.\n     *\n     * @param  string  $file\n     * @return bool\n     */\n    public function isFile($file)\n    {\n        return is_file($file);\n    }\n\n    /**\n     * Find path names matching a given pattern.\n     *\n     * @param  string  $pattern\n     * @param  int     $flags\n     * @return array\n     */\n    public function glob($pattern, $flags = 0)\n    {\n        return glob($pattern, $flags);\n    }\n\n    /**\n     * Get an array of all files in a directory.\n     *\n     * @param  string  $directory\n     * @param  bool  $hidden\n     * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n     */\n    public function files($directory, $hidden = false)\n    {\n        return iterator_to_array(\n            Finder::create()->files()->ignoreDotFiles(! $hidden)->in($directory)->depth(0)->sortByName(),\n            false\n        );\n    }\n\n    /**\n     * Get all of the files from the given directory (recursive).\n     *\n     * @param  string  $directory\n     * @param  bool  $hidden\n     * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n     */\n    public function allFiles($directory, $hidden = false)\n    {\n        return iterator_to_array(\n            Finder::create()->files()->ignoreDotFiles(! $hidden)->in($directory)->sortByName(),\n            false\n        );\n    }\n\n    /**\n     * Get all of the directories within a given directory.\n     *\n     * @param  string  $directory\n     * @return array\n     */\n    public function directories($directory)\n    {\n        $directories = [];\n\n        foreach (Finder::create()->in($directory)->directories()->depth(0)->sortByName() as $dir) {\n            $directories[] = $dir->getPathname();\n        }\n\n        return $directories;\n    }\n\n    /**\n     * Create a directory.\n     *\n     * @param  string  $path\n     * @param  int     $mode\n     * @param  bool    $recursive\n     * @param  bool    $force\n     * @return bool\n     */\n    public function makeDirectory($path, $mode = 0755, $recursive = false, $force = false)\n    {\n        if ($force) {\n            return @mkdir($path, $mode, $recursive);\n        }\n\n        return mkdir($path, $mode, $recursive);\n    }\n\n    /**\n     * Move a directory.\n     *\n     * @param  string  $from\n     * @param  string  $to\n     * @param  bool  $overwrite\n     * @return bool\n     */\n    public function moveDirectory($from, $to, $overwrite = false)\n    {\n        if ($overwrite && $this->isDirectory($to) && ! $this->deleteDirectory($to)) {\n            return false;\n        }\n\n        return @rename($from, $to) === true;\n    }\n\n    /**\n     * Copy a directory from one location to another.\n     *\n     * @param  string  $directory\n     * @param  string  $destination\n     * @param  int     $options\n     * @return bool\n     */\n    public function copyDirectory($directory, $destination, $options = null)\n    {\n        if (! $this->isDirectory($directory)) {\n            return false;\n        }\n\n        $options = $options ?: FilesystemIterator::SKIP_DOTS;\n\n        // If the destination directory does not actually exist, we will go ahead and\n        // create it recursively, which just gets the destination prepared to copy\n        // the files over. Once we make the directory we'll proceed the copying.\n        if (! $this->isDirectory($destination)) {\n            $this->makeDirectory($destination, 0777, true);\n        }\n\n        $items = new FilesystemIterator($directory, $options);\n\n        foreach ($items as $item) {\n            // As we spin through items, we will check to see if the current file is actually\n            // a directory or a file. When it is actually a directory we will need to call\n            // back into this function recursively to keep copying these nested folders.\n            $target = $destination.'/'.$item->getBasename();\n\n            if ($item->isDir()) {\n                $path = $item->getPathname();\n\n                if (! $this->copyDirectory($path, $target, $options)) {\n                    return false;\n                }\n            }\n\n            // If the current items is just a regular file, we will just copy this to the new\n            // location and keep looping. If for some reason the copy fails we'll bail out\n            // and return false, so the developer is aware that the copy process failed.\n            else {\n                if (! $this->copy($item->getPathname(), $target)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Recursively delete a directory.\n     *\n     * The directory itself may be optionally preserved.\n     *\n     * @param  string  $directory\n     * @param  bool    $preserve\n     * @return bool\n     */\n    public function deleteDirectory($directory, $preserve = false)\n    {\n        if (! $this->isDirectory($directory)) {\n            return false;\n        }\n\n        $items = new FilesystemIterator($directory);\n\n        foreach ($items as $item) {\n            // If the item is a directory, we can just recurse into the function and\n            // delete that sub-directory otherwise we'll just delete the file and\n            // keep iterating through each file until the directory is cleaned.\n            if ($item->isDir() && ! $item->isLink()) {\n                $this->deleteDirectory($item->getPathname());\n            }\n\n            // If the item is just a file, we can go ahead and delete it since we're\n            // just looping through and waxing all of the files in this directory\n            // and calling directories recursively, so we delete the real path.\n            else {\n                $this->delete($item->getPathname());\n            }\n        }\n\n        if (! $preserve) {\n            @rmdir($directory);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all of the directories within a given directory.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function deleteDirectories($directory)\n    {\n        $allDirectories = $this->directories($directory);\n\n        if (! empty($allDirectories)) {\n            foreach ($allDirectories as $directoryName) {\n                $this->deleteDirectory($directoryName);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Empty the specified directory of all files and folders.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function cleanDirectory($directory)\n    {\n        return $this->deleteDirectory($directory, true);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Illuminate\\Filesystem;\n\nuse ErrorException;\nuse FilesystemIterator;\nuse Symfony\\Component\\Finder\\Finder;\nuse Illuminate\\Support\\Traits\\Macroable;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\n\nclass Filesystem\n{\n    use Macroable;\n\n    /**\n     * Determine if a file or directory exists.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function exists($path)\n    {\n        return file_exists($path);\n    }\n\n    /**\n     * Get the contents of a file.\n     *\n     * @param  string  $path\n     * @param  bool  $lock\n     * @return string\n     *\n     * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n     */\n    public function get($path, $lock = false)\n    {\n        if ($this->isFile($path)) {\n            return $lock ? $this->sharedGet($path) : file_get_contents($path);\n        }\n\n        throw new FileNotFoundException(\"File does not exist at path {$path}\");\n    }\n\n    /**\n     * Get contents of a file with shared access.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function sharedGet($path)\n    {\n        $contents = '';\n\n        $handle = fopen($path, 'rb');\n\n        if ($handle) {\n            try {\n                if (flock($handle, LOCK_SH)) {\n                    clearstatcache(true, $path);\n\n                    $contents = fread($handle, $this->size($path) ?: 1);\n\n                    flock($handle, LOCK_UN);\n                }\n            } finally {\n                fclose($handle);\n            }\n        }\n\n        return $contents;\n    }\n\n    /**\n     * Get the returned value of a file.\n     *\n     * @param  string  $path\n     * @return mixed\n     *\n     * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n     */\n    public function getRequire($path)\n    {\n        if ($this->isFile($path)) {\n            return require $path;\n        }\n\n        throw new FileNotFoundException(\"File does not exist at path {$path}\");\n    }\n\n    /**\n     * Require the given file once.\n     *\n     * @param  string  $file\n     * @return mixed\n     */\n    public function requireOnce($file)\n    {\n        require_once $file;\n    }\n\n    /**\n     * Get the MD5 hash of the file at the given path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function hash($path)\n    {\n        return md5_file($path);\n    }\n\n    /**\n     * Write the contents of a file.\n     *\n     * @param  string  $path\n     * @param  string  $contents\n     * @param  bool  $lock\n     * @return int|bool\n     */\n    public function put($path, $contents, $lock = false)\n    {\n        return file_put_contents($path, $contents, $lock ? LOCK_EX : 0);\n    }\n\n    /**\n     * Write the contents of a file, replacing it atomically if it already exists.\n     *\n     * @param  string  $path\n     * @param  string  $content\n     * @return void\n     */\n    public function replace($path, $content)\n    {\n        // If the path already exists and is a symlink, get the real path...\n        clearstatcache(true, $path);\n\n        $path = realpath($path) ?: $path;\n\n        $tempPath = tempnam(dirname($path), basename($path));\n\n        // Fix permissions of tempPath because `tempnam()` creates it with permissions set to 0600...\n        chmod($tempPath, 0777 - umask());\n\n        file_put_contents($tempPath, $content);\n\n        rename($tempPath, $path);\n    }\n\n    /**\n     * Prepend to a file.\n     *\n     * @param  string  $path\n     * @param  string  $data\n     * @return int\n     */\n    public function prepend($path, $data)\n    {\n        if ($this->exists($path)) {\n            return $this->put($path, $data.$this->get($path));\n        }\n\n        return $this->put($path, $data);\n    }\n\n    /**\n     * Append to a file.\n     *\n     * @param  string  $path\n     * @param  string  $data\n     * @return int\n     */\n    public function append($path, $data)\n    {\n        return file_put_contents($path, $data, FILE_APPEND);\n    }\n\n    /**\n     * Get or set UNIX mode of a file or directory.\n     *\n     * @param  string  $path\n     * @param  int  $mode\n     * @return mixed\n     */\n    public function chmod($path, $mode = null)\n    {\n        if ($mode) {\n            return chmod($path, $mode);\n        }\n\n        return substr(sprintf('%o', fileperms($path)), -4);\n    }\n\n    /**\n     * Delete the file at a given path.\n     *\n     * @param  string|array  $paths\n     * @return bool\n     */\n    public function delete($paths)\n    {\n        $paths = is_array($paths) ? $paths : func_get_args();\n\n        $success = true;\n\n        foreach ($paths as $path) {\n            try {\n                if (! @unlink($path)) {\n                    $success = false;\n                }\n            } catch (ErrorException $e) {\n                $success = false;\n            }\n        }\n\n        return $success;\n    }\n\n    /**\n     * Move a file to a new location.\n     *\n     * @param  string  $path\n     * @param  string  $target\n     * @return bool\n     */\n    public function move($path, $target)\n    {\n        return rename($path, $target);\n    }\n\n    /**\n     * Copy a file to a new location.\n     *\n     * @param  string  $path\n     * @param  string  $target\n     * @return bool\n     */\n    public function copy($path, $target)\n    {\n        return copy($path, $target);\n    }\n\n    /**\n     * Create a hard link to the target file or directory.\n     *\n     * @param  string  $target\n     * @param  string  $link\n     * @return void\n     */\n    public function link($target, $link)\n    {\n        if (! windows_os()) {\n            return symlink($target, $link);\n        }\n\n        $mode = $this->isDirectory($target) ? 'J' : 'H';\n\n        exec(\"mklink /{$mode} \".escapeshellarg($link).\" \".escapeshellarg($target));\n    }\n\n    /**\n     * Extract the file name from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function name($path)\n    {\n        return pathinfo($path, PATHINFO_FILENAME);\n    }\n\n    /**\n     * Extract the trailing name component from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function basename($path)\n    {\n        return pathinfo($path, PATHINFO_BASENAME);\n    }\n\n    /**\n     * Extract the parent directory from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function dirname($path)\n    {\n        return pathinfo($path, PATHINFO_DIRNAME);\n    }\n\n    /**\n     * Extract the file extension from a file path.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function extension($path)\n    {\n        return pathinfo($path, PATHINFO_EXTENSION);\n    }\n\n    /**\n     * Get the file type of a given file.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function type($path)\n    {\n        return filetype($path);\n    }\n\n    /**\n     * Get the mime-type of a given file.\n     *\n     * @param  string  $path\n     * @return string|false\n     */\n    public function mimeType($path)\n    {\n        return finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);\n    }\n\n    /**\n     * Get the file size of a given file.\n     *\n     * @param  string  $path\n     * @return int\n     */\n    public function size($path)\n    {\n        return filesize($path);\n    }\n\n    /**\n     * Get the file's last modification time.\n     *\n     * @param  string  $path\n     * @return int\n     */\n    public function lastModified($path)\n    {\n        return filemtime($path);\n    }\n\n    /**\n     * Determine if the given path is a directory.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function isDirectory($directory)\n    {\n        return is_dir($directory);\n    }\n\n    /**\n     * Determine if the given path is readable.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isReadable($path)\n    {\n        return is_readable($path);\n    }\n\n    /**\n     * Determine if the given path is writable.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isWritable($path)\n    {\n        return is_writable($path);\n    }\n\n    /**\n     * Determine if the given path is a file.\n     *\n     * @param  string  $file\n     * @return bool\n     */\n    public function isFile($file)\n    {\n        return is_file($file);\n    }\n\n    /**\n     * Find path names matching a given pattern.\n     *\n     * @param  string  $pattern\n     * @param  int     $flags\n     * @return array\n     */\n    public function glob($pattern, $flags = 0)\n    {\n        return glob($pattern, $flags);\n    }\n\n    /**\n     * Get an array of all files in a directory.\n     *\n     * @param  string  $directory\n     * @param  bool  $hidden\n     * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n     */\n    public function files($directory, $hidden = false)\n    {\n        return iterator_to_array(\n            Finder::create()->files()->ignoreDotFiles(! $hidden)->in($directory)->depth(0)->sortByName(),\n            false\n        );\n    }\n\n    /**\n     * Get all of the files from the given directory (recursive).\n     *\n     * @param  string  $directory\n     * @param  bool  $hidden\n     * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n     */\n    public function allFiles($directory, $hidden = false)\n    {\n        return iterator_to_array(\n            Finder::create()->files()->ignoreDotFiles(! $hidden)->in($directory)->sortByName(),\n            false\n        );\n    }\n\n    /**\n     * Get all of the directories within a given directory.\n     *\n     * @param  string  $directory\n     * @return array\n     */\n    public function directories($directory)\n    {\n        $directories = [];\n\n        foreach (Finder::create()->in($directory)->directories()->depth(0)->sortByName() as $dir) {\n            $directories[] = $dir->getPathname();\n        }\n\n        return $directories;\n    }\n\n    /**\n     * Create a directory.\n     *\n     * @param  string  $path\n     * @param  int     $mode\n     * @param  bool    $recursive\n     * @param  bool    $force\n     * @return bool\n     */\n    public function makeDirectory($path, $mode = 0755, $recursive = false, $force = false)\n    {\n        if ($force) {\n            return @mkdir($path, $mode, $recursive);\n        }\n\n        return mkdir($path, $mode, $recursive);\n    }\n\n    /**\n     * Move a directory.\n     *\n     * @param  string  $from\n     * @param  string  $to\n     * @param  bool  $overwrite\n     * @return bool\n     */\n    public function moveDirectory($from, $to, $overwrite = false)\n    {\n        if ($overwrite && $this->isDirectory($to) && ! $this->deleteDirectory($to)) {\n            return false;\n        }\n\n        return @rename($from, $to) === true;\n    }\n\n    /**\n     * Copy a directory from one location to another.\n     *\n     * @param  string  $directory\n     * @param  string  $destination\n     * @param  int     $options\n     * @return bool\n     */\n    public function copyDirectory($directory, $destination, $options = null)\n    {\n        if (! $this->isDirectory($directory)) {\n            return false;\n        }\n\n        $options = $options ?: FilesystemIterator::SKIP_DOTS;\n\n        // If the destination directory does not actually exist, we will go ahead and\n        // create it recursively, which just gets the destination prepared to copy\n        // the files over. Once we make the directory we'll proceed the copying.\n        if (! $this->isDirectory($destination)) {\n            $this->makeDirectory($destination, 0777, true);\n        }\n\n        $items = new FilesystemIterator($directory, $options);\n\n        foreach ($items as $item) {\n            // As we spin through items, we will check to see if the current file is actually\n            // a directory or a file. When it is actually a directory we will need to call\n            // back into this function recursively to keep copying these nested folders.\n            $target = $destination.'/'.$item->getBasename();\n\n            if ($item->isDir()) {\n                $path = $item->getPathname();\n\n                if (! $this->copyDirectory($path, $target, $options)) {\n                    return false;\n                }\n            }\n\n            // If the current items is just a regular file, we will just copy this to the new\n            // location and keep looping. If for some reason the copy fails we'll bail out\n            // and return false, so the developer is aware that the copy process failed.\n            else {\n                if (! $this->copy($item->getPathname(), $target)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Recursively delete a directory.\n     *\n     * The directory itself may be optionally preserved.\n     *\n     * @param  string  $directory\n     * @param  bool    $preserve\n     * @return bool\n     */\n    public function deleteDirectory($directory, $preserve = false)\n    {\n        if (! $this->isDirectory($directory)) {\n            return false;\n        }\n\n        $items = new FilesystemIterator($directory);\n\n        foreach ($items as $item) {\n            // If the item is a directory, we can just recurse into the function and\n            // delete that sub-directory otherwise we'll just delete the file and\n            // keep iterating through each file until the directory is cleaned.\n            if ($item->isDir() && ! $item->isLink()) {\n                $this->deleteDirectory($item->getPathname());\n            }\n\n            // If the item is just a file, we can go ahead and delete it since we're\n            // just looping through and waxing all of the files in this directory\n            // and calling directories recursively, so we delete the real path.\n            else {\n                $this->delete($item->getPathname());\n            }\n        }\n\n        if (! $preserve) {\n            @rmdir($directory);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all of the directories within a given directory.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function deleteDirectories($directory)\n    {\n        $allDirectories = $this->directories($directory);\n\n        if (! empty($allDirectories)) {\n            foreach ($allDirectories as $directoryName) {\n                $this->deleteDirectory($directoryName);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Empty the specified directory of all files and folders.\n     *\n     * @param  string  $directory\n     * @return bool\n     */\n    public function cleanDirectory($directory)\n    {\n        return $this->deleteDirectory($directory, true);\n    }\n}\n"], "filenames": ["src/Illuminate/Filesystem/Filesystem.php"], "buggy_code_start_loc": [257], "buggy_code_end_loc": [258], "fixing_code_start_loc": [257], "fixing_code_end_loc": [258], "type": "CWE-78", "message": "OS Command injection vulnerability in function link in Filesystem.php in Laravel Framework before 5.8.17.", "other": {"cve": {"id": "CVE-2020-19316", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-20T20:15:07.593", "lastModified": "2021-12-22T03:42:56.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OS Command injection vulnerability in function link in Filesystem.php in Laravel Framework before 5.8.17."}, {"lang": "es", "value": "Una vulnerabilidad de inyecci\u00f3n de comandos en el enlace de la funci\u00f3n Filesystem.php en Laravel Framework versiones anteriores a 5.8.17"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:laravel:framework:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.17", "matchCriteriaId": "A114BA47-F86F-4997-AF13-F02E7B540333"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "http://www.netbytesec.com/advisories/OSCommandInjectionInLaravelFramework/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/commit/44c3feb604944599ad1c782a9942981c3991fa31", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/laravel/framework/commit/44c3feb604944599ad1c782a9942981c3991fa31"}}