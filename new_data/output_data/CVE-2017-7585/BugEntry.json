{"buggy_code": ["/*\n** Copyright (C) 2004-2017 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2004 Tobias Gehrig <tgehrig@ira.uka.de>\n**\n** This program is free software ; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation ; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY ; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program ; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdio.h>\n#include\t<stdlib.h>\n#include\t<fcntl.h>\n#include\t<string.h>\n#include\t<ctype.h>\n#include\t<math.h>\n\n#include\t\"sndfile.h\"\n#include\t\"common.h\"\n\n#if HAVE_EXTERNAL_XIPH_LIBS\n\n#include\t<FLAC/stream_decoder.h>\n#include\t<FLAC/stream_encoder.h>\n#include\t<FLAC/metadata.h>\n\n/*------------------------------------------------------------------------------\n** Private static functions.\n*/\n\n#define\tFLAC_DEFAULT_COMPRESSION_LEVEL\t5\n\n#define ENC_BUFFER_SIZE 8192\n\ntypedef enum\n{\tPFLAC_PCM_SHORT = 50,\n\tPFLAC_PCM_INT = 51,\n\tPFLAC_PCM_FLOAT = 52,\n\tPFLAC_PCM_DOUBLE = 53\n} PFLAC_PCM ;\n\ntypedef struct\n{\n\tFLAC__StreamDecoder *fsd ;\n\tFLAC__StreamEncoder *fse ;\n\n\tPFLAC_PCM pcmtype ;\n\tvoid* ptr ;\n\tunsigned pos, len, remain ;\n\n\tFLAC__StreamMetadata *metadata ;\n\n\tconst int32_t * const * wbuffer ;\n\tint32_t * rbuffer [FLAC__MAX_CHANNELS] ;\n\n\tint32_t* encbuffer ;\n\tunsigned bufferpos ;\n\n\tconst FLAC__Frame *frame ;\n\tFLAC__bool bufferbackup ;\n\n\tunsigned compression ;\n} FLAC_PRIVATE ;\n\ntypedef struct\n{\tconst char *tag ;\n\tint type ;\n} FLAC_TAG ;\n\nstatic sf_count_t\tflac_seek (SF_PRIVATE *psf, int mode, sf_count_t offset) ;\nstatic int\t\t\tflac_byterate (SF_PRIVATE *psf) ;\nstatic int\t\t\tflac_close (SF_PRIVATE *psf) ;\n\nstatic int\t\t\tflac_enc_init (SF_PRIVATE *psf) ;\nstatic int\t\t\tflac_read_header (SF_PRIVATE *psf) ;\n\nstatic sf_count_t\tflac_read_flac2s (SF_PRIVATE *psf, short *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2i (SF_PRIVATE *psf, int *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2f (SF_PRIVATE *psf, float *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2d (SF_PRIVATE *psf, double *ptr, sf_count_t len) ;\n\nstatic sf_count_t\tflac_write_s2flac (SF_PRIVATE *psf, const short *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_i2flac (SF_PRIVATE *psf, const int *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_f2flac (SF_PRIVATE *psf, const float *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_d2flac (SF_PRIVATE *psf, const double *ptr, sf_count_t len) ;\n\nstatic void\t\tf2flac8_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac16_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac24_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac8_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac16_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac24_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac8_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac16_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac24_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac8_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac16_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac24_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\n\nstatic int flac_command (SF_PRIVATE *psf, int command, void *data, int datasize) ;\n\n/* Decoder Callbacks */\nstatic FLAC__StreamDecoderReadStatus sf_flac_read_callback (const FLAC__StreamDecoder *decoder, FLAC__byte buffer [], size_t *bytes, void *client_data) ;\nstatic FLAC__StreamDecoderSeekStatus sf_flac_seek_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamDecoderTellStatus sf_flac_tell_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamDecoderLengthStatus sf_flac_length_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data) ;\nstatic FLAC__bool sf_flac_eof_callback (const FLAC__StreamDecoder *decoder, void *client_data) ;\nstatic FLAC__StreamDecoderWriteStatus sf_flac_write_callback (const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data) ;\nstatic void sf_flac_meta_callback (const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data) ;\nstatic void sf_flac_error_callback (const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data) ;\n\n/* Encoder Callbacks */\nstatic FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback (const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback (const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback (const FLAC__StreamEncoder *encoder, const FLAC__byte buffer [], size_t bytes, unsigned samples, unsigned current_frame, void *client_data) ;\n\nstatic void\ns2flac8_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 8 ;\n} /* s2flac8_array */\n\nstatic void\ns2flac16_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] ;\n} /* s2flac16_array */\n\nstatic void\ns2flac24_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] << 8 ;\n} /* s2flac24_array */\n\nstatic void\ni2flac8_array (const int *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 24 ;\n} /* i2flac8_array */\n\nstatic void\ni2flac16_array (const int *src, int32_t *dest, int count)\n{\n\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 16 ;\n} /* i2flac16_array */\n\nstatic void\ni2flac24_array (const int *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 8 ;\n} /* i2flac24_array */\n\nstatic sf_count_t\nflac_buffer_copy (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tconst FLAC__Frame *frame = pflac->frame ;\n\tconst int32_t* const *buffer = pflac->wbuffer ;\n\tunsigned i = 0, j, offset, channels, len ;\n\n\t/*\n\t**\tframe->header.blocksize is variable and we're using a constant blocksize\n\t**\tof FLAC__MAX_BLOCK_SIZE.\n\t**\tCheck our assumptions here.\n\t*/\n\tif (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)\n\t{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;\n\t\tpsf->error = SFE_INTERNAL ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frame->header.channels > FLAC__MAX_CHANNELS)\n\t\tpsf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;\n\n\tchannels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;\n\n\tif (pflac->ptr == NULL)\n\t{\t/*\n\t\t**\tNot sure why this code is here and not elsewhere.\n\t\t**\tRemoving it causes valgrind errors.\n\t\t*/\n\t\tpflac->bufferbackup = SF_TRUE ;\n\t\tfor (i = 0 ; i < channels ; i++)\n\t\t{\n\t\t\tif (pflac->rbuffer [i] == NULL)\n\t\t\t\tpflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;\n\n\t\t\tmemcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;\n\t\t\t} ;\n\t\tpflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;\n\n\t\treturn 0 ;\n\t\t} ;\n\n\n\tlen = SF_MIN (pflac->len, frame->header.blocksize) ;\n\n\tswitch (pflac->pcmtype)\n\t{\tcase PFLAC_PCM_SHORT :\n\t\t\t{\tshort *retpcm = (short*) pflac->ptr ;\n\t\t\t\tint shift = 16 - frame->header.bits_per_sample ;\n\t\t\t\tif (shift < 0)\n\t\t\t\t{\tshift = abs (shift) ;\n\t\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;\n\t\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;\n\n\t\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_INT :\n\t\t\t{\tint *retpcm = (int*) pflac->ptr ;\n\t\t\t\tint shift = 32 - frame->header.bits_per_sample ;\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_FLOAT :\n\t\t\t{\tfloat *retpcm = (float*) pflac->ptr ;\n\t\t\t\tfloat norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_DOUBLE :\n\t\t\t{\tdouble *retpcm = (double*) pflac->ptr ;\n\t\t\t\tdouble norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\treturn 0 ;\n\t\t} ;\n\n\toffset = i * channels ;\n\tpflac->pos += i * channels ;\n\n\treturn offset ;\n} /* flac_buffer_copy */\n\n\nstatic FLAC__StreamDecoderReadStatus\nsf_flac_read_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__byte buffer [], size_t *bytes, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*bytes = psf_fread (buffer, 1, *bytes, psf) ;\n\tif (*bytes > 0 && psf->error == 0)\n\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE ;\n\n\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT ;\n} /* sf_flac_read_callback */\n\nstatic FLAC__StreamDecoderSeekStatus\nsf_flac_seek_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_fseek (psf, absolute_byte_offset, SEEK_SET) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_SEEK_STATUS_OK ;\n} /* sf_flac_seek_callback */\n\nstatic FLAC__StreamDecoderTellStatus\nsf_flac_tell_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*absolute_byte_offset = psf_ftell (psf) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_TELL_STATUS_OK ;\n} /* sf_flac_tell_callback */\n\nstatic FLAC__StreamDecoderLengthStatus\nsf_flac_length_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 *stream_length, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif ((*stream_length = psf->filelength) == 0)\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_OK ;\n} /* sf_flac_length_callback */\n\nstatic FLAC__bool\nsf_flac_eof_callback (const FLAC__StreamDecoder *UNUSED (decoder), void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif (psf_ftell (psf) == psf->filelength)\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* sf_flac_eof_callback */\n\nstatic FLAC__StreamDecoderWriteStatus\nsf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\n\tflac_buffer_copy (psf) ;\n\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} /* sf_flac_write_callback */\n\nstatic void\nsf_flac_meta_get_vorbiscomments (SF_PRIVATE *psf, const FLAC__StreamMetadata *metadata)\n{\tstatic FLAC_TAG tags [] =\n\t{ \t{ \"title\", SF_STR_TITLE },\n\t\t{ \"copyright\", SF_STR_COPYRIGHT },\n\t\t{ \"software\", SF_STR_SOFTWARE },\n\t\t{ \"artist\", SF_STR_ARTIST },\n\t\t{ \"comment\", SF_STR_COMMENT },\n\t\t{ \"date\", SF_STR_DATE },\n\t\t{ \"album\", SF_STR_ALBUM },\n\t\t{ \"license\", SF_STR_LICENSE },\n\t\t{ \"tracknumber\", SF_STR_TRACKNUMBER },\n\t\t{ \"genre\", SF_STR_GENRE }\n\t\t} ;\n\n\tconst char *value, *cptr ;\n\tint k, tag_num ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (tags) ; k++)\n\t{\ttag_num = FLAC__metadata_object_vorbiscomment_find_entry_from (metadata, 0, tags [k].tag) ;\n\n\t\tif (tag_num < 0)\n\t\t\tcontinue ;\n\n\t\tvalue = (const char*) metadata->data.vorbis_comment.comments [tag_num].entry ;\n\t\tif ((cptr = strchr (value, '=')) != NULL)\n\t\t\tvalue = cptr + 1 ;\n\n\t\tpsf_log_printf (psf, \"  %-12s : %s\\n\", tags [k].tag, value) ;\n\t\tpsf_store_string (psf, tags [k].type, value) ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_meta_get_vorbiscomments */\n\nstatic void\nsf_flac_meta_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__StreamMetadata *metadata, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tint bitwidth = 0, i ;\n\n\tswitch (metadata->type)\n\t{\tcase FLAC__METADATA_TYPE_STREAMINFO :\n\t\t\tpsf->sf.channels = metadata->data.stream_info.channels ;\n\t\t\tpsf->sf.samplerate = metadata->data.stream_info.sample_rate ;\n\t\t\tpsf->sf.frames = metadata->data.stream_info.total_samples ;\n\n\t\t\tpsf_log_printf (psf, \"FLAC Stream Metadata\\n  Channels    : %d\\n  Sample rate : %d\\n\", psf->sf.channels, psf->sf.samplerate) ;\n\n\t\t\tif (psf->sf.frames == 0)\n\t\t\t{\tpsf_log_printf (psf, \"  Frames      : 0 (bumping to SF_COUNT_MAX)\\n\") ;\n\t\t\t\tpsf->sf.frames = SF_COUNT_MAX ;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpsf_log_printf (psf, \"  Frames      : %D\\n\", psf->sf.frames) ;\n\n\t\t\tswitch (metadata->data.stream_info.bits_per_sample)\n\t\t\t{\tcase 8 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_S8 ;\n\t\t\t\t\tbitwidth = 8 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 16 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_16 ;\n\t\t\t\t\tbitwidth = 16 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 24 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_24 ;\n\t\t\t\t\tbitwidth = 24 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tdefault :\n\t\t\t\t\tpsf_log_printf (psf, \"sf_flac_meta_callback : bits_per_sample %d not yet implemented.\\n\", metadata->data.stream_info.bits_per_sample) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (bitwidth > 0)\n\t\t\t\tpsf_log_printf (psf, \"  Bit width   : %d\\n\", bitwidth) ;\n\n\n\t\t\tfor (i = 0 ; i < psf->sf.channels ; i++)\n\t\t\t\tpflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;\n\n\t\t\tpflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT :\n\t\t\tpsf_log_printf (psf, \"Vorbis Comment Metadata\\n\") ;\n\t\t\tsf_flac_meta_get_vorbiscomments (psf, metadata) ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_PADDING :\n\t\t\tpsf_log_printf (psf, \"Padding Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_APPLICATION :\n\t\t\tpsf_log_printf (psf, \"Application Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_SEEKTABLE :\n\t\t\tpsf_log_printf (psf, \"Seektable Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_CUESHEET :\n\t\t\tpsf_log_printf (psf, \"Cuesheet Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_PICTURE :\n\t\t\tpsf_log_printf (psf, \"Picture Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_UNDEFINED :\n\t\t\tpsf_log_printf (psf, \"Undefined Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"sf_flac_meta_callback : metadata-type %d not yet implemented.\\n\", metadata->type) ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_meta_callback */\n\nstatic void\nsf_flac_error_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__StreamDecoderErrorStatus status, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_log_printf (psf, \"ERROR : %s\\n\", FLAC__StreamDecoderErrorStatusString [status]) ;\n\n\tswitch (status)\n\t{\tcase FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC :\n\t\t\tpsf->error = SFE_FLAC_LOST_SYNC ;\n\t\t\tbreak ;\n\t\tcase FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER :\n\t\t\tpsf->error = SFE_FLAC_BAD_HEADER ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tpsf->error = SFE_FLAC_UNKOWN_ERROR ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_error_callback */\n\nstatic FLAC__StreamEncoderSeekStatus\nsf_flac_enc_seek_callback (const FLAC__StreamEncoder * UNUSED (encoder), FLAC__uint64 absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_fseek (psf, absolute_byte_offset, SEEK_SET) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_OK ;\n} /* sf_flac_enc_seek_callback */\n\nstatic FLAC__StreamEncoderTellStatus\nsf_flac_enc_tell_callback (const FLAC__StreamEncoder *UNUSED (encoder), FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*absolute_byte_offset = psf_ftell (psf) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_ENCODER_TELL_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_ENCODER_TELL_STATUS_OK ;\n} /* sf_flac_enc_tell_callback */\n\nstatic FLAC__StreamEncoderWriteStatus\nsf_flac_enc_write_callback (const FLAC__StreamEncoder * UNUSED (encoder), const FLAC__byte buffer [], size_t bytes, unsigned UNUSED (samples), unsigned UNUSED (current_frame), void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif (psf_fwrite (buffer, 1, bytes, psf) == (sf_count_t) bytes && psf->error == 0)\n\t\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_OK ;\n\n\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR ;\n} /* sf_flac_enc_write_callback */\n\nstatic void\nflac_write_strings (SF_PRIVATE *psf, FLAC_PRIVATE* pflac)\n{\tFLAC__StreamMetadata_VorbisComment_Entry entry ;\n\tint\tk, string_count = 0 ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS ; k++)\n\t{\tif (psf->strings.data [k].type != 0)\n\t\t\tstring_count ++ ;\n\t\t} ;\n\n\tif (string_count == 0)\n\t\treturn ;\n\n\tif (pflac->metadata == NULL && (pflac->metadata = FLAC__metadata_object_new (FLAC__METADATA_TYPE_VORBIS_COMMENT)) == NULL)\n\t{\tpsf_log_printf (psf, \"FLAC__metadata_object_new returned NULL\\n\") ;\n\t\treturn ;\n\t\t} ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS && psf->strings.data [k].type != 0 ; k++)\n\t{\tconst char * key, * value ;\n\n\t\tswitch (psf->strings.data [k].type)\n\t\t{\tcase SF_STR_SOFTWARE :\n\t\t\t\tkey = \"software\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_TITLE :\n\t\t\t\tkey = \"title\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_COPYRIGHT :\n\t\t\t\tkey = \"copyright\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_ARTIST :\n\t\t\t\tkey = \"artist\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_COMMENT :\n\t\t\t\tkey = \"comment\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_DATE :\n\t\t\t\tkey = \"date\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_ALBUM :\n\t\t\t\tkey = \"album\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_LICENSE :\n\t\t\t\tkey = \"license\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_TRACKNUMBER :\n\t\t\t\tkey = \"tracknumber\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_GENRE :\n\t\t\t\tkey = \"genre\" ;\n\t\t\t\tbreak ;\n\t\t\tdefault :\n\t\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tvalue = psf->strings.storage + psf->strings.data [k].offset ;\n\n\t\tFLAC__metadata_object_vorbiscomment_entry_from_name_value_pair (&entry, key, value) ;\n\t\tFLAC__metadata_object_vorbiscomment_append_comment (pflac->metadata, entry, /* copy */ SF_FALSE) ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_metadata (pflac->fse, &pflac->metadata, 1))\n\t{\tprintf (\"%s %d : fail\\n\", __func__, __LINE__) ;\n\t\treturn ;\n\t\t} ;\n\n\treturn ;\n} /* flac_write_strings */\n\nstatic int\nflac_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tint err ;\n\n\tflac_write_strings (psf, pflac) ;\n\n\tif ((err = FLAC__stream_encoder_init_stream (pflac->fse, sf_flac_enc_write_callback, sf_flac_enc_seek_callback, sf_flac_enc_tell_callback, NULL, psf)) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n\t{\tpsf_log_printf (psf, \"Error : FLAC encoder init returned error : %s\\n\", FLAC__StreamEncoderInitStatusString [err]) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (psf->error == 0)\n\t\tpsf->dataoffset = psf_ftell (psf) ;\n\tpflac->encbuffer = calloc (ENC_BUFFER_SIZE, sizeof (int32_t)) ;\n\n\treturn psf->error ;\n} /* flac_write_header */\n\n/*------------------------------------------------------------------------------\n** Public function.\n*/\n\nint\nflac_open\t(SF_PRIVATE *psf)\n{\tint\t\tsubformat ;\n\tint\t\terror = 0 ;\n\n\tFLAC_PRIVATE* pflac = calloc (1, sizeof (FLAC_PRIVATE)) ;\n\tpsf->codec_data = pflac ;\n\n\t/* Set the default value here. Over-ridden later if necessary. */\n\tpflac->compression = FLAC_DEFAULT_COMPRESSION_LEVEL ;\n\n\tif (psf->file.mode == SFM_RDWR)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif ((error = flac_read_header (psf)))\n\t\t\treturn error ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_FLAC)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\tpsf->sf.seekable = 0 ;\n\n\t\tpsf->strings.flags = SF_STR_ALLOW_START ;\n\n\t\tif ((error = flac_enc_init (psf)))\n\t\t\treturn error ;\n\n\t\t/* In an ideal world we would write the header at this point. Unfortunately\n\t\t** that would prevent string metadata being added so we have to hold off.\n\t\t*/\n\n\t\tpsf->write_header = flac_write_header ;\n\t\t} ;\n\n\tpsf->datalength = psf->filelength ;\n\tpsf->dataoffset = 0 ;\n\n\tpsf->container_close = flac_close ;\n\tpsf->seek = flac_seek ;\n\tpsf->byterate = flac_byterate ;\n\n\tpsf->command = flac_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_S8 :\t/* 8-bit FLAC.  */\n\t\tcase SF_FORMAT_PCM_16 :\t/* 16-bit FLAC. */\n\t\tcase SF_FORMAT_PCM_24 :\t/* 24-bit FLAC. */\n\t\t\terror = flac_init (psf) ;\n\t\t\tbreak ;\n\n\t\tdefault : return SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\treturn error ;\n} /* flac_open */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int\nflac_close\t(SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac ;\n\tint k ;\n\n\tif ((pflac = (FLAC_PRIVATE*) psf->codec_data) == NULL)\n\t\treturn 0 ;\n\n\tif (pflac->metadata != NULL)\n\t\tFLAC__metadata_object_delete (pflac->metadata) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tFLAC__stream_encoder_finish (pflac->fse) ;\n\t\tFLAC__stream_encoder_delete (pflac->fse) ;\n\t\tfree (pflac->encbuffer) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tFLAC__stream_decoder_finish (pflac->fsd) ;\n\t\tFLAC__stream_decoder_delete (pflac->fsd) ;\n\t\t} ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (pflac->rbuffer) ; k++)\n\t\tfree (pflac->rbuffer [k]) ;\n\n\tfree (pflac) ;\n\tpsf->codec_data = NULL ;\n\n\treturn 0 ;\n} /* flac_close */\n\nstatic int\nflac_enc_init (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tunsigned bps ;\n\n\t/* To cite the flac FAQ at\n\t** http://flac.sourceforge.net/faq.html#general__samples\n\t**     \"FLAC supports linear sample rates from 1Hz - 655350Hz in 1Hz\n\t**     increments.\"\n\t*/\n\tif (psf->sf.samplerate < 1 || psf->sf.samplerate > 655350)\n\t{\tpsf_log_printf (psf, \"flac sample rate out of range.\\n\", psf->sf.samplerate) ;\n\t\treturn SFE_FLAC_BAD_SAMPLE_RATE ;\n\t\t} ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tbps = 8 ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tbps = 16 ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tbps = 24 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tbps = 0 ;\n\t\t\tbreak ;\n\t\t} ;\n\n\tif (pflac->fse)\n\t\tFLAC__stream_encoder_delete (pflac->fse) ;\n\tif ((pflac->fse = FLAC__stream_encoder_new ()) == NULL)\n\t\treturn SFE_FLAC_NEW_DECODER ;\n\n\tif (! FLAC__stream_encoder_set_channels (pflac->fse, psf->sf.channels))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_channels (%d) return false.\\n\", psf->sf.channels) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_sample_rate (pflac->fse, psf->sf.samplerate))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_sample_rate (%d) returned false.\\n\", psf->sf.samplerate) ;\n\t\treturn SFE_FLAC_BAD_SAMPLE_RATE ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_bits_per_sample (pflac->fse, bps))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_bits_per_sample (%d) return false.\\n\", bps) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_compression_level (pflac->fse, pflac->compression))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_compression_level (%d) return false.\\n\", pflac->compression) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\treturn 0 ;\n} /* flac_enc_init */\n\nstatic int\nflac_read_header (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tif (pflac->fsd)\n\t\tFLAC__stream_decoder_delete (pflac->fsd) ;\n\tif ((pflac->fsd = FLAC__stream_decoder_new ()) == NULL)\n\t\treturn SFE_FLAC_NEW_DECODER ;\n\n\tFLAC__stream_decoder_set_metadata_respond_all (pflac->fsd) ;\n\n\tif (FLAC__stream_decoder_init_stream (pflac->fsd, sf_flac_read_callback, sf_flac_seek_callback, sf_flac_tell_callback, sf_flac_length_callback, sf_flac_eof_callback, sf_flac_write_callback, sf_flac_meta_callback, sf_flac_error_callback, psf) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\n\tFLAC__stream_decoder_process_until_end_of_metadata (pflac->fsd) ;\n\n\tpsf_log_printf (psf, \"End\\n\") ;\n\n\tif (psf->error == 0)\n\t{\tFLAC__uint64 position ;\n\n\t\tFLAC__stream_decoder_get_decode_position (pflac->fsd, &position) ;\n\t\tpsf->dataoffset = position ;\n\t\t} ;\n\n\treturn psf->error ;\n} /* flac_read_header */\n\nstatic int\nflac_command (SF_PRIVATE * psf, int command, void * data, int datasize)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tdouble quality ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_COMPRESSION_LEVEL :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (psf->have_written)\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\t/* FLAC compression level is in the range [0, 8] while libsndfile takes\n\t\t\t** values in the range [0.0, 1.0]. Massage the libsndfile value here.\n\t\t\t*/\n\t\t\tquality = (*((double *) data)) * 8.0 ;\n\t\t\t/* Clip range. */\n\t\t\tpflac->compression = lrint (SF_MAX (0.0, SF_MIN (8.0, quality))) ;\n\n\t\t\tpsf_log_printf (psf, \"%s : Setting SFC_SET_COMPRESSION_LEVEL to %u.\\n\", __func__, pflac->compression) ;\n\n\t\t\tif (flac_enc_init (psf))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\treturn SF_TRUE ;\n\n\t\tdefault :\n\t\t\treturn SF_FALSE ;\n\t\t} ;\n\n\treturn SF_FALSE ;\n} /* flac_command */\n\nint\nflac_init (SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_RDWR)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->read_short\t\t= flac_read_flac2s ;\n\t\tpsf->read_int\t\t= flac_read_flac2i ;\n\t\tpsf->read_float\t\t= flac_read_flac2f ;\n\t\tpsf->read_double\t= flac_read_flac2d ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->write_short\t= flac_write_s2flac ;\n\t\tpsf->write_int\t\t= flac_write_i2flac ;\n\t\tpsf->write_float\t= flac_write_f2flac ;\n\t\tpsf->write_double\t= flac_write_d2flac ;\n\t\t} ;\n\n\tif (psf->filelength > psf->dataoffset)\n\t\tpsf->datalength = (psf->dataend) ? psf->dataend - psf->dataoffset : psf->filelength - psf->dataoffset ;\n\telse\n\t\tpsf->datalength = 0 ;\n\n\treturn 0 ;\n} /* flac_init */\n\nstatic unsigned\nflac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\n\t/* First copy data that has already been decoded and buffered. */\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\n\t/* Decode some more. */\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\n\tpflac->ptr = NULL ;\n\n\treturn pflac->pos ;\n} /* flac_read_loop */\n\nstatic sf_count_t\nflac_read_flac2s (SF_PRIVATE *psf, short *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_SHORT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2s */\n\nstatic sf_count_t\nflac_read_flac2i (SF_PRIVATE *psf, int *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_INT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2i */\n\nstatic sf_count_t\nflac_read_flac2f (SF_PRIVATE *psf, float *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_FLOAT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2f */\n\nstatic sf_count_t\nflac_read_flac2d (SF_PRIVATE *psf, double *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_DOUBLE ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2d */\n\nstatic sf_count_t\nflac_write_s2flac (SF_PRIVATE *psf, const short *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const short *, int32_t *, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = s2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = s2flac16_array ;\n\t\t\tbreak ;\n\t\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = s2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_s2flac */\n\nstatic sf_count_t\nflac_write_i2flac (SF_PRIVATE *psf, const int *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const int *, int32_t *, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = i2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = i2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = i2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_i2flac */\n\nstatic sf_count_t\nflac_write_f2flac (SF_PRIVATE *psf, const float *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const float *, int32_t *, int, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac8_clip_array : f2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac16_clip_array : f2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac24_clip_array : f2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount, psf->norm_float) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_f2flac */\n\nstatic void\nf2flac8_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7F))\n\t\t{\tdest [count] = 0x7F ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10))\n\t\t{\tdest [count] = 0x80 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* f2flac8_clip_array */\n\nstatic void\nf2flac16_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x1000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n} /* f2flac16_clip_array */\n\nstatic void\nf2flac24_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x100000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFF))\n\t\t{\tdest [count] = 0x7FFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x100000))\n\t\t{\tdest [count] = 0x800000 ;\n\t\t\tcontinue ;\n\t\t\t}\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* f2flac24_clip_array */\n\nstatic void\nf2flac8_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7F) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac8_array */\n\nstatic void\nf2flac16_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac16_array */\n\nstatic void\nf2flac24_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7FFFFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac24_array */\n\nstatic sf_count_t\nflac_write_d2flac (SF_PRIVATE *psf, const double *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const double *, int32_t *, int, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac8_clip_array : d2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac16_clip_array : d2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac24_clip_array : d2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount, psf->norm_double) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_d2flac */\n\nstatic void\nd2flac8_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7F))\n\t\t{\tdest [count] = 0x7F ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10))\n\t\t{\tdest [count] = 0x80 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac8_clip_array */\n\nstatic void\nd2flac16_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x1000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac16_clip_array */\n\nstatic void\nd2flac24_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x100000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFF))\n\t\t{\tdest [count] = 0x7FFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x100000))\n\t\t{\tdest [count] = 0x800000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac24_clip_array */\n\nstatic void\nd2flac8_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7F) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac8_array */\n\nstatic void\nd2flac16_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac16_array */\n\nstatic void\nd2flac24_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7FFFFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac24_array */\n\nstatic sf_count_t\nflac_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t offset)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tif (pflac == NULL)\n\t\treturn 0 ;\n\n\tif (psf->dataoffset < 0)\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn ((sf_count_t) -1) ;\n\t\t} ;\n\n\tpflac->frame = NULL ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif (FLAC__stream_decoder_seek_absolute (pflac->fsd, offset))\n\t\t\treturn offset ;\n\n\t\tif (offset == psf->sf.frames)\n\t\t{\t/*\n\t\t\t** If we've been asked to seek to the very end of the file, libFLAC\n\t\t\t** will return an error. However, we know the length of the file so\n\t\t\t** instead of returning an error, we can return the offset.\n\t\t\t*/\n\t\t\treturn offset ;\n\t\t\t} ;\n\n\t\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn ((sf_count_t) -1) ;\n\t\t} ;\n\n\t/* Seeking in write mode not yet supported. */\n\tpsf->error = SFE_BAD_SEEK ;\n\n\treturn ((sf_count_t) -1) ;\n} /* flac_seek */\n\nstatic int\nflac_byterate (SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_READ)\n\t\treturn (psf->datalength * psf->sf.samplerate) / psf->sf.frames ;\n\n\treturn -1 ;\n} /* flac_byterate */\n\n\n#else /* HAVE_EXTERNAL_XIPH_LIBS */\n\nint\nflac_open\t(SF_PRIVATE *psf)\n{\n\tpsf_log_printf (psf, \"This version of libsndfile was compiled without FLAC support.\\n\") ;\n\treturn SFE_UNIMPLEMENTED ;\n} /* flac_open */\n\n#endif\n"], "fixing_code": ["/*\n** Copyright (C) 2004-2017 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2004 Tobias Gehrig <tgehrig@ira.uka.de>\n**\n** This program is free software ; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation ; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY ; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program ; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdio.h>\n#include\t<stdlib.h>\n#include\t<fcntl.h>\n#include\t<string.h>\n#include\t<ctype.h>\n#include\t<math.h>\n\n#include\t\"sndfile.h\"\n#include\t\"common.h\"\n\n#if HAVE_EXTERNAL_XIPH_LIBS\n\n#include\t<FLAC/stream_decoder.h>\n#include\t<FLAC/stream_encoder.h>\n#include\t<FLAC/metadata.h>\n\n/*------------------------------------------------------------------------------\n** Private static functions.\n*/\n\n#define\tFLAC_DEFAULT_COMPRESSION_LEVEL\t5\n\n#define ENC_BUFFER_SIZE 8192\n\ntypedef enum\n{\tPFLAC_PCM_SHORT = 50,\n\tPFLAC_PCM_INT = 51,\n\tPFLAC_PCM_FLOAT = 52,\n\tPFLAC_PCM_DOUBLE = 53\n} PFLAC_PCM ;\n\ntypedef struct\n{\n\tFLAC__StreamDecoder *fsd ;\n\tFLAC__StreamEncoder *fse ;\n\n\tPFLAC_PCM pcmtype ;\n\tvoid* ptr ;\n\tunsigned pos, len, remain ;\n\n\tFLAC__StreamMetadata *metadata ;\n\n\tconst int32_t * const * wbuffer ;\n\tint32_t * rbuffer [FLAC__MAX_CHANNELS] ;\n\n\tint32_t* encbuffer ;\n\tunsigned bufferpos ;\n\n\tconst FLAC__Frame *frame ;\n\n\tunsigned compression ;\n\n} FLAC_PRIVATE ;\n\ntypedef struct\n{\tconst char *tag ;\n\tint type ;\n} FLAC_TAG ;\n\nstatic sf_count_t\tflac_seek (SF_PRIVATE *psf, int mode, sf_count_t offset) ;\nstatic int\t\t\tflac_byterate (SF_PRIVATE *psf) ;\nstatic int\t\t\tflac_close (SF_PRIVATE *psf) ;\n\nstatic int\t\t\tflac_enc_init (SF_PRIVATE *psf) ;\nstatic int\t\t\tflac_read_header (SF_PRIVATE *psf) ;\n\nstatic sf_count_t\tflac_read_flac2s (SF_PRIVATE *psf, short *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2i (SF_PRIVATE *psf, int *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2f (SF_PRIVATE *psf, float *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_read_flac2d (SF_PRIVATE *psf, double *ptr, sf_count_t len) ;\n\nstatic sf_count_t\tflac_write_s2flac (SF_PRIVATE *psf, const short *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_i2flac (SF_PRIVATE *psf, const int *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_f2flac (SF_PRIVATE *psf, const float *ptr, sf_count_t len) ;\nstatic sf_count_t\tflac_write_d2flac (SF_PRIVATE *psf, const double *ptr, sf_count_t len) ;\n\nstatic void\t\tf2flac8_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac16_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac24_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac8_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac16_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\tf2flac24_clip_array (const float *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac8_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac16_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac24_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac8_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac16_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\nstatic void\t\td2flac24_clip_array (const double *src, int32_t *dest, int count, int normalize) ;\n\nstatic int flac_command (SF_PRIVATE *psf, int command, void *data, int datasize) ;\n\n/* Decoder Callbacks */\nstatic FLAC__StreamDecoderReadStatus sf_flac_read_callback (const FLAC__StreamDecoder *decoder, FLAC__byte buffer [], size_t *bytes, void *client_data) ;\nstatic FLAC__StreamDecoderSeekStatus sf_flac_seek_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamDecoderTellStatus sf_flac_tell_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamDecoderLengthStatus sf_flac_length_callback (const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data) ;\nstatic FLAC__bool sf_flac_eof_callback (const FLAC__StreamDecoder *decoder, void *client_data) ;\nstatic FLAC__StreamDecoderWriteStatus sf_flac_write_callback (const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data) ;\nstatic void sf_flac_meta_callback (const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data) ;\nstatic void sf_flac_error_callback (const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data) ;\n\n/* Encoder Callbacks */\nstatic FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback (const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback (const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data) ;\nstatic FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback (const FLAC__StreamEncoder *encoder, const FLAC__byte buffer [], size_t bytes, unsigned samples, unsigned current_frame, void *client_data) ;\n\nstatic void\ns2flac8_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 8 ;\n} /* s2flac8_array */\n\nstatic void\ns2flac16_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] ;\n} /* s2flac16_array */\n\nstatic void\ns2flac24_array (const short *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] << 8 ;\n} /* s2flac24_array */\n\nstatic void\ni2flac8_array (const int *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 24 ;\n} /* i2flac8_array */\n\nstatic void\ni2flac16_array (const int *src, int32_t *dest, int count)\n{\n\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 16 ;\n} /* i2flac16_array */\n\nstatic void\ni2flac24_array (const int *src, int32_t *dest, int count)\n{\twhile (--count >= 0)\n\t\tdest [count] = src [count] >> 8 ;\n} /* i2flac24_array */\n\nstatic sf_count_t\nflac_buffer_copy (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tconst FLAC__Frame *frame = pflac->frame ;\n\tconst int32_t* const *buffer = pflac->wbuffer ;\n\tunsigned i = 0, j, offset, channels, len ;\n\n\t/*\n\t**\tframe->header.blocksize is variable and we're using a constant blocksize\n\t**\tof FLAC__MAX_BLOCK_SIZE.\n\t**\tCheck our assumptions here.\n\t*/\n\tif (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)\n\t{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;\n\t\tpsf->error = SFE_INTERNAL ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frame->header.channels > FLAC__MAX_CHANNELS)\n\t\tpsf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;\n\n\tchannels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;\n\n\tif (pflac->ptr == NULL)\n\t{\t/*\n\t\t** This pointer is reset to NULL each time the current frame has been\n\t\t** decoded. Somehow its used during encoding and decoding.\n\t\t*/\n\t\tfor (i = 0 ; i < channels ; i++)\n\t\t{\n\t\t\tif (pflac->rbuffer [i] == NULL)\n\t\t\t\tpflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;\n\n\t\t\tmemcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;\n\t\t\t} ;\n\t\tpflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;\n\n\t\treturn 0 ;\n\t\t} ;\n\n\n\tlen = SF_MIN (pflac->len, frame->header.blocksize) ;\n\n\tif (pflac->remain % channels != 0)\n\t{\tpsf_log_printf (psf, \"Error: pflac->remain %u    channels %u\\n\", pflac->remain, channels) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tswitch (pflac->pcmtype)\n\t{\tcase PFLAC_PCM_SHORT :\n\t\t\t{\tshort *retpcm = (short*) pflac->ptr ;\n\t\t\t\tint shift = 16 - frame->header.bits_per_sample ;\n\t\t\t\tif (shift < 0)\n\t\t\t\t{\tshift = abs (shift) ;\n\t\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;\n\t\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;\n\n\t\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_INT :\n\t\t\t{\tint *retpcm = (int*) pflac->ptr ;\n\t\t\t\tint shift = 32 - frame->header.bits_per_sample ;\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_FLOAT :\n\t\t\t{\tfloat *retpcm = (float*) pflac->ptr ;\n\t\t\t\tfloat norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_DOUBLE :\n\t\t\t{\tdouble *retpcm = (double*) pflac->ptr ;\n\t\t\t\tdouble norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)\n\t\t\t\t{\toffset = pflac->pos + i * channels ;\n\n\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels > pflac->len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j < channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;\n\t\t\t\t\tpflac->remain -= channels ;\n\t\t\t\t\tpflac->bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\treturn 0 ;\n\t\t} ;\n\n\toffset = i * channels ;\n\tpflac->pos += i * channels ;\n\n\treturn offset ;\n} /* flac_buffer_copy */\n\n\nstatic FLAC__StreamDecoderReadStatus\nsf_flac_read_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__byte buffer [], size_t *bytes, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*bytes = psf_fread (buffer, 1, *bytes, psf) ;\n\tif (*bytes > 0 && psf->error == 0)\n\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE ;\n\n\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT ;\n} /* sf_flac_read_callback */\n\nstatic FLAC__StreamDecoderSeekStatus\nsf_flac_seek_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_fseek (psf, absolute_byte_offset, SEEK_SET) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_SEEK_STATUS_OK ;\n} /* sf_flac_seek_callback */\n\nstatic FLAC__StreamDecoderTellStatus\nsf_flac_tell_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*absolute_byte_offset = psf_ftell (psf) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_TELL_STATUS_OK ;\n} /* sf_flac_tell_callback */\n\nstatic FLAC__StreamDecoderLengthStatus\nsf_flac_length_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__uint64 *stream_length, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif ((*stream_length = psf->filelength) == 0)\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_OK ;\n} /* sf_flac_length_callback */\n\nstatic FLAC__bool\nsf_flac_eof_callback (const FLAC__StreamDecoder *UNUSED (decoder), void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif (psf_ftell (psf) == psf->filelength)\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* sf_flac_eof_callback */\n\nstatic FLAC__StreamDecoderWriteStatus\nsf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\n\tpflac->wbuffer = buffer ;\n\n\tflac_buffer_copy (psf) ;\n\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} /* sf_flac_write_callback */\n\nstatic void\nsf_flac_meta_get_vorbiscomments (SF_PRIVATE *psf, const FLAC__StreamMetadata *metadata)\n{\tstatic FLAC_TAG tags [] =\n\t{ \t{ \"title\", SF_STR_TITLE },\n\t\t{ \"copyright\", SF_STR_COPYRIGHT },\n\t\t{ \"software\", SF_STR_SOFTWARE },\n\t\t{ \"artist\", SF_STR_ARTIST },\n\t\t{ \"comment\", SF_STR_COMMENT },\n\t\t{ \"date\", SF_STR_DATE },\n\t\t{ \"album\", SF_STR_ALBUM },\n\t\t{ \"license\", SF_STR_LICENSE },\n\t\t{ \"tracknumber\", SF_STR_TRACKNUMBER },\n\t\t{ \"genre\", SF_STR_GENRE }\n\t\t} ;\n\n\tconst char *value, *cptr ;\n\tint k, tag_num ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (tags) ; k++)\n\t{\ttag_num = FLAC__metadata_object_vorbiscomment_find_entry_from (metadata, 0, tags [k].tag) ;\n\n\t\tif (tag_num < 0)\n\t\t\tcontinue ;\n\n\t\tvalue = (const char*) metadata->data.vorbis_comment.comments [tag_num].entry ;\n\t\tif ((cptr = strchr (value, '=')) != NULL)\n\t\t\tvalue = cptr + 1 ;\n\n\t\tpsf_log_printf (psf, \"  %-12s : %s\\n\", tags [k].tag, value) ;\n\t\tpsf_store_string (psf, tags [k].type, value) ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_meta_get_vorbiscomments */\n\nstatic void\nsf_flac_meta_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__StreamMetadata *metadata, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tint bitwidth = 0, i ;\n\n\tswitch (metadata->type)\n\t{\tcase FLAC__METADATA_TYPE_STREAMINFO :\n\t\t\tpsf->sf.channels = metadata->data.stream_info.channels ;\n\t\t\tpsf->sf.samplerate = metadata->data.stream_info.sample_rate ;\n\t\t\tpsf->sf.frames = metadata->data.stream_info.total_samples ;\n\n\t\t\tpsf_log_printf (psf, \"FLAC Stream Metadata\\n  Channels    : %d\\n  Sample rate : %d\\n\", psf->sf.channels, psf->sf.samplerate) ;\n\n\t\t\tif (psf->sf.frames == 0)\n\t\t\t{\tpsf_log_printf (psf, \"  Frames      : 0 (bumping to SF_COUNT_MAX)\\n\") ;\n\t\t\t\tpsf->sf.frames = SF_COUNT_MAX ;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpsf_log_printf (psf, \"  Frames      : %D\\n\", psf->sf.frames) ;\n\n\t\t\tswitch (metadata->data.stream_info.bits_per_sample)\n\t\t\t{\tcase 8 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_S8 ;\n\t\t\t\t\tbitwidth = 8 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 16 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_16 ;\n\t\t\t\t\tbitwidth = 16 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 24 :\n\t\t\t\t\tpsf->sf.format |= SF_FORMAT_PCM_24 ;\n\t\t\t\t\tbitwidth = 24 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tdefault :\n\t\t\t\t\tpsf_log_printf (psf, \"sf_flac_meta_callback : bits_per_sample %d not yet implemented.\\n\", metadata->data.stream_info.bits_per_sample) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (bitwidth > 0)\n\t\t\t\tpsf_log_printf (psf, \"  Bit width   : %d\\n\", bitwidth) ;\n\n\n\t\t\tfor (i = 0 ; i < psf->sf.channels ; i++)\n\t\t\t\tpflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;\n\n\t\t\tpflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT :\n\t\t\tpsf_log_printf (psf, \"Vorbis Comment Metadata\\n\") ;\n\t\t\tsf_flac_meta_get_vorbiscomments (psf, metadata) ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_PADDING :\n\t\t\tpsf_log_printf (psf, \"Padding Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_APPLICATION :\n\t\t\tpsf_log_printf (psf, \"Application Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_SEEKTABLE :\n\t\t\tpsf_log_printf (psf, \"Seektable Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_CUESHEET :\n\t\t\tpsf_log_printf (psf, \"Cuesheet Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_PICTURE :\n\t\t\tpsf_log_printf (psf, \"Picture Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tcase FLAC__METADATA_TYPE_UNDEFINED :\n\t\t\tpsf_log_printf (psf, \"Undefined Metadata\\n\") ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"sf_flac_meta_callback : metadata-type %d not yet implemented.\\n\", metadata->type) ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_meta_callback */\n\nstatic void\nsf_flac_error_callback (const FLAC__StreamDecoder * UNUSED (decoder), FLAC__StreamDecoderErrorStatus status, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_log_printf (psf, \"ERROR : %s\\n\", FLAC__StreamDecoderErrorStatusString [status]) ;\n\n\tswitch (status)\n\t{\tcase FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC :\n\t\t\tpsf->error = SFE_FLAC_LOST_SYNC ;\n\t\t\tbreak ;\n\t\tcase FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER :\n\t\t\tpsf->error = SFE_FLAC_BAD_HEADER ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tpsf->error = SFE_FLAC_UNKOWN_ERROR ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* sf_flac_error_callback */\n\nstatic FLAC__StreamEncoderSeekStatus\nsf_flac_enc_seek_callback (const FLAC__StreamEncoder * UNUSED (encoder), FLAC__uint64 absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tpsf_fseek (psf, absolute_byte_offset, SEEK_SET) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_OK ;\n} /* sf_flac_enc_seek_callback */\n\nstatic FLAC__StreamEncoderTellStatus\nsf_flac_enc_tell_callback (const FLAC__StreamEncoder *UNUSED (encoder), FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\t*absolute_byte_offset = psf_ftell (psf) ;\n\tif (psf->error)\n\t\treturn FLAC__STREAM_ENCODER_TELL_STATUS_ERROR ;\n\n\treturn FLAC__STREAM_ENCODER_TELL_STATUS_OK ;\n} /* sf_flac_enc_tell_callback */\n\nstatic FLAC__StreamEncoderWriteStatus\nsf_flac_enc_write_callback (const FLAC__StreamEncoder * UNUSED (encoder), const FLAC__byte buffer [], size_t bytes, unsigned UNUSED (samples), unsigned UNUSED (current_frame), void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\n\tif (psf_fwrite (buffer, 1, bytes, psf) == (sf_count_t) bytes && psf->error == 0)\n\t\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_OK ;\n\n\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR ;\n} /* sf_flac_enc_write_callback */\n\nstatic void\nflac_write_strings (SF_PRIVATE *psf, FLAC_PRIVATE* pflac)\n{\tFLAC__StreamMetadata_VorbisComment_Entry entry ;\n\tint\tk, string_count = 0 ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS ; k++)\n\t{\tif (psf->strings.data [k].type != 0)\n\t\t\tstring_count ++ ;\n\t\t} ;\n\n\tif (string_count == 0)\n\t\treturn ;\n\n\tif (pflac->metadata == NULL && (pflac->metadata = FLAC__metadata_object_new (FLAC__METADATA_TYPE_VORBIS_COMMENT)) == NULL)\n\t{\tpsf_log_printf (psf, \"FLAC__metadata_object_new returned NULL\\n\") ;\n\t\treturn ;\n\t\t} ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS && psf->strings.data [k].type != 0 ; k++)\n\t{\tconst char * key, * value ;\n\n\t\tswitch (psf->strings.data [k].type)\n\t\t{\tcase SF_STR_SOFTWARE :\n\t\t\t\tkey = \"software\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_TITLE :\n\t\t\t\tkey = \"title\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_COPYRIGHT :\n\t\t\t\tkey = \"copyright\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_ARTIST :\n\t\t\t\tkey = \"artist\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_COMMENT :\n\t\t\t\tkey = \"comment\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_DATE :\n\t\t\t\tkey = \"date\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_ALBUM :\n\t\t\t\tkey = \"album\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_LICENSE :\n\t\t\t\tkey = \"license\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_TRACKNUMBER :\n\t\t\t\tkey = \"tracknumber\" ;\n\t\t\t\tbreak ;\n\t\t\tcase SF_STR_GENRE :\n\t\t\t\tkey = \"genre\" ;\n\t\t\t\tbreak ;\n\t\t\tdefault :\n\t\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tvalue = psf->strings.storage + psf->strings.data [k].offset ;\n\n\t\tFLAC__metadata_object_vorbiscomment_entry_from_name_value_pair (&entry, key, value) ;\n\t\tFLAC__metadata_object_vorbiscomment_append_comment (pflac->metadata, entry, /* copy */ SF_FALSE) ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_metadata (pflac->fse, &pflac->metadata, 1))\n\t{\tprintf (\"%s %d : fail\\n\", __func__, __LINE__) ;\n\t\treturn ;\n\t\t} ;\n\n\treturn ;\n} /* flac_write_strings */\n\nstatic int\nflac_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tint err ;\n\n\tflac_write_strings (psf, pflac) ;\n\n\tif ((err = FLAC__stream_encoder_init_stream (pflac->fse, sf_flac_enc_write_callback, sf_flac_enc_seek_callback, sf_flac_enc_tell_callback, NULL, psf)) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n\t{\tpsf_log_printf (psf, \"Error : FLAC encoder init returned error : %s\\n\", FLAC__StreamEncoderInitStatusString [err]) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (psf->error == 0)\n\t\tpsf->dataoffset = psf_ftell (psf) ;\n\tpflac->encbuffer = calloc (ENC_BUFFER_SIZE, sizeof (int32_t)) ;\n\n\treturn psf->error ;\n} /* flac_write_header */\n\n/*------------------------------------------------------------------------------\n** Public function.\n*/\n\nint\nflac_open\t(SF_PRIVATE *psf)\n{\tint\t\tsubformat ;\n\tint\t\terror = 0 ;\n\n\tFLAC_PRIVATE* pflac = calloc (1, sizeof (FLAC_PRIVATE)) ;\n\tpsf->codec_data = pflac ;\n\n\t/* Set the default value here. Over-ridden later if necessary. */\n\tpflac->compression = FLAC_DEFAULT_COMPRESSION_LEVEL ;\n\n\tif (psf->file.mode == SFM_RDWR)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif ((error = flac_read_header (psf)))\n\t\t\treturn error ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_FLAC)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\tpsf->sf.seekable = 0 ;\n\n\t\tpsf->strings.flags = SF_STR_ALLOW_START ;\n\n\t\tif ((error = flac_enc_init (psf)))\n\t\t\treturn error ;\n\n\t\t/* In an ideal world we would write the header at this point. Unfortunately\n\t\t** that would prevent string metadata being added so we have to hold off.\n\t\t*/\n\n\t\tpsf->write_header = flac_write_header ;\n\t\t} ;\n\n\tpsf->datalength = psf->filelength ;\n\tpsf->dataoffset = 0 ;\n\n\tpsf->container_close = flac_close ;\n\tpsf->seek = flac_seek ;\n\tpsf->byterate = flac_byterate ;\n\n\tpsf->command = flac_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_S8 :\t/* 8-bit FLAC.  */\n\t\tcase SF_FORMAT_PCM_16 :\t/* 16-bit FLAC. */\n\t\tcase SF_FORMAT_PCM_24 :\t/* 24-bit FLAC. */\n\t\t\terror = flac_init (psf) ;\n\t\t\tbreak ;\n\n\t\tdefault : return SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\treturn error ;\n} /* flac_open */\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int\nflac_close\t(SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac ;\n\tint k ;\n\n\tif ((pflac = (FLAC_PRIVATE*) psf->codec_data) == NULL)\n\t\treturn 0 ;\n\n\tif (pflac->metadata != NULL)\n\t\tFLAC__metadata_object_delete (pflac->metadata) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tFLAC__stream_encoder_finish (pflac->fse) ;\n\t\tFLAC__stream_encoder_delete (pflac->fse) ;\n\t\tfree (pflac->encbuffer) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tFLAC__stream_decoder_finish (pflac->fsd) ;\n\t\tFLAC__stream_decoder_delete (pflac->fsd) ;\n\t\t} ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (pflac->rbuffer) ; k++)\n\t\tfree (pflac->rbuffer [k]) ;\n\n\tfree (pflac) ;\n\tpsf->codec_data = NULL ;\n\n\treturn 0 ;\n} /* flac_close */\n\nstatic int\nflac_enc_init (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tunsigned bps ;\n\n\t/* To cite the flac FAQ at\n\t** http://flac.sourceforge.net/faq.html#general__samples\n\t**     \"FLAC supports linear sample rates from 1Hz - 655350Hz in 1Hz\n\t**     increments.\"\n\t*/\n\tif (psf->sf.samplerate < 1 || psf->sf.samplerate > 655350)\n\t{\tpsf_log_printf (psf, \"flac sample rate out of range.\\n\", psf->sf.samplerate) ;\n\t\treturn SFE_FLAC_BAD_SAMPLE_RATE ;\n\t\t} ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tbps = 8 ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tbps = 16 ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tbps = 24 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tbps = 0 ;\n\t\t\tbreak ;\n\t\t} ;\n\n\tif (pflac->fse)\n\t\tFLAC__stream_encoder_delete (pflac->fse) ;\n\tif ((pflac->fse = FLAC__stream_encoder_new ()) == NULL)\n\t\treturn SFE_FLAC_NEW_DECODER ;\n\n\tif (! FLAC__stream_encoder_set_channels (pflac->fse, psf->sf.channels))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_channels (%d) return false.\\n\", psf->sf.channels) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_sample_rate (pflac->fse, psf->sf.samplerate))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_sample_rate (%d) returned false.\\n\", psf->sf.samplerate) ;\n\t\treturn SFE_FLAC_BAD_SAMPLE_RATE ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_bits_per_sample (pflac->fse, bps))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_bits_per_sample (%d) return false.\\n\", bps) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\tif (! FLAC__stream_encoder_set_compression_level (pflac->fse, pflac->compression))\n\t{\tpsf_log_printf (psf, \"FLAC__stream_encoder_set_compression_level (%d) return false.\\n\", pflac->compression) ;\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\t\t} ;\n\n\treturn 0 ;\n} /* flac_enc_init */\n\nstatic int\nflac_read_header (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tif (pflac->fsd)\n\t\tFLAC__stream_decoder_delete (pflac->fsd) ;\n\tif ((pflac->fsd = FLAC__stream_decoder_new ()) == NULL)\n\t\treturn SFE_FLAC_NEW_DECODER ;\n\n\tFLAC__stream_decoder_set_metadata_respond_all (pflac->fsd) ;\n\n\tif (FLAC__stream_decoder_init_stream (pflac->fsd, sf_flac_read_callback, sf_flac_seek_callback, sf_flac_tell_callback, sf_flac_length_callback, sf_flac_eof_callback, sf_flac_write_callback, sf_flac_meta_callback, sf_flac_error_callback, psf) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n\t\treturn SFE_FLAC_INIT_DECODER ;\n\n\tFLAC__stream_decoder_process_until_end_of_metadata (pflac->fsd) ;\n\n\tpsf_log_printf (psf, \"End\\n\") ;\n\n\tif (psf->error == 0)\n\t{\tFLAC__uint64 position ;\n\n\t\tFLAC__stream_decoder_get_decode_position (pflac->fsd, &position) ;\n\t\tpsf->dataoffset = position ;\n\t\t} ;\n\n\treturn psf->error ;\n} /* flac_read_header */\n\nstatic int\nflac_command (SF_PRIVATE * psf, int command, void * data, int datasize)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tdouble quality ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_COMPRESSION_LEVEL :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (psf->have_written)\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\t/* FLAC compression level is in the range [0, 8] while libsndfile takes\n\t\t\t** values in the range [0.0, 1.0]. Massage the libsndfile value here.\n\t\t\t*/\n\t\t\tquality = (*((double *) data)) * 8.0 ;\n\t\t\t/* Clip range. */\n\t\t\tpflac->compression = lrint (SF_MAX (0.0, SF_MIN (8.0, quality))) ;\n\n\t\t\tpsf_log_printf (psf, \"%s : Setting SFC_SET_COMPRESSION_LEVEL to %u.\\n\", __func__, pflac->compression) ;\n\n\t\t\tif (flac_enc_init (psf))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\treturn SF_TRUE ;\n\n\t\tdefault :\n\t\t\treturn SF_FALSE ;\n\t\t} ;\n\n\treturn SF_FALSE ;\n} /* flac_command */\n\nint\nflac_init (SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_RDWR)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->read_short\t\t= flac_read_flac2s ;\n\t\tpsf->read_int\t\t= flac_read_flac2i ;\n\t\tpsf->read_float\t\t= flac_read_flac2f ;\n\t\tpsf->read_double\t= flac_read_flac2d ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->write_short\t= flac_write_s2flac ;\n\t\tpsf->write_int\t\t= flac_write_i2flac ;\n\t\tpsf->write_float\t= flac_write_f2flac ;\n\t\tpsf->write_double\t= flac_write_d2flac ;\n\t\t} ;\n\n\tif (psf->filelength > psf->dataoffset)\n\t\tpsf->datalength = (psf->dataend) ? psf->dataend - psf->dataoffset : psf->filelength - psf->dataoffset ;\n\telse\n\t\tpsf->datalength = 0 ;\n\n\treturn 0 ;\n} /* flac_init */\n\nstatic unsigned\nflac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tFLAC__StreamDecoderState state ;\n\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\n\tstate = FLAC__stream_decoder_get_state (pflac->fsd) ;\n\tif (state > FLAC__STREAM_DECODER_END_OF_STREAM)\n\t{\tpsf_log_printf (psf, \"FLAC__stream_decoder_get_state returned %s\\n\", FLAC__StreamDecoderStateString [state]) ;\n\t\t/* Current frame is busted, so NULL the pointer. */\n\t\tpflac->frame = NULL ;\n\t\t} ;\n\n\t/* First copy data that has already been decoded and buffered. */\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\n\t/* Decode some more. */\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tstate = FLAC__stream_decoder_get_state (pflac->fsd) ;\n\t\tif (state >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t{\tpsf_log_printf (psf, \"FLAC__stream_decoder_get_state returned %s\\n\", FLAC__StreamDecoderStateString [state]) ;\n\t\t\t/* Current frame is busted, so NULL the pointer. */\n\t\t\tpflac->frame = NULL ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tpflac->ptr = NULL ;\n\n\treturn pflac->pos ;\n} /* flac_read_loop */\n\nstatic sf_count_t\nflac_read_flac2s (SF_PRIVATE *psf, short *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_SHORT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2s */\n\nstatic sf_count_t\nflac_read_flac2i (SF_PRIVATE *psf, int *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_INT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2i */\n\nstatic sf_count_t\nflac_read_flac2f (SF_PRIVATE *psf, float *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_FLOAT ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2f */\n\nstatic sf_count_t\nflac_read_flac2d (SF_PRIVATE *psf, double *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tsf_count_t total = 0, current ;\n\tunsigned readlen ;\n\n\tpflac->pcmtype = PFLAC_PCM_DOUBLE ;\n\n\twhile (total < len)\n\t{\tpflac->ptr = ptr + total ;\n\t\treadlen = (len - total > 0x1000000) ? 0x1000000 : (unsigned) (len - total) ;\n\n\t\tcurrent = flac_read_loop (psf, readlen) ;\n\t\tif (current == 0)\n\t\t\tbreak ;\n\t\ttotal += current ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_read_flac2d */\n\nstatic sf_count_t\nflac_write_s2flac (SF_PRIVATE *psf, const short *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const short *, int32_t *, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = s2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = s2flac16_array ;\n\t\t\tbreak ;\n\t\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = s2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_s2flac */\n\nstatic sf_count_t\nflac_write_i2flac (SF_PRIVATE *psf, const int *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const int *, int32_t *, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = i2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = i2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = i2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_i2flac */\n\nstatic sf_count_t\nflac_write_f2flac (SF_PRIVATE *psf, const float *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const float *, int32_t *, int, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac8_clip_array : f2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac16_clip_array : f2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = (psf->add_clipping) ? f2flac24_clip_array : f2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount, psf->norm_float) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_f2flac */\n\nstatic void\nf2flac8_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7F))\n\t\t{\tdest [count] = 0x7F ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10))\n\t\t{\tdest [count] = 0x80 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* f2flac8_clip_array */\n\nstatic void\nf2flac16_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x1000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n} /* f2flac16_clip_array */\n\nstatic void\nf2flac24_clip_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x100000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFF))\n\t\t{\tdest [count] = 0x7FFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x100000))\n\t\t{\tdest [count] = 0x800000 ;\n\t\t\tcontinue ;\n\t\t\t}\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* f2flac24_clip_array */\n\nstatic void\nf2flac8_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7F) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac8_array */\n\nstatic void\nf2flac16_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac16_array */\n\nstatic void\nf2flac24_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7FFFFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac24_array */\n\nstatic sf_count_t\nflac_write_d2flac (SF_PRIVATE *psf, const double *ptr, sf_count_t len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tvoid (*convert) (const double *, int32_t *, int, int) ;\n\tint bufferlen, writecount, thiswrite ;\n\tsf_count_t\ttotal = 0 ;\n\tint32_t* buffer = pflac->encbuffer ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac8_clip_array : d2flac8_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac16_clip_array : d2flac16_array ;\n\t\t\tbreak ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\tconvert = (psf->add_clipping) ? d2flac24_clip_array : d2flac24_array ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn -1 ;\n\t\t} ;\n\n\tbufferlen = ENC_BUFFER_SIZE / (sizeof (int32_t) * psf->sf.channels) ;\n\tbufferlen *= psf->sf.channels ;\n\n\twhile (len > 0)\n\t{\twritecount = (len >= bufferlen) ? bufferlen : (int) len ;\n\t\tconvert (ptr + total, buffer, writecount, psf->norm_double) ;\n\t\tif (FLAC__stream_encoder_process_interleaved (pflac->fse, buffer, writecount / psf->sf.channels))\n\t\t\tthiswrite = writecount ;\n\t\telse\n\t\t\tbreak ;\n\t\ttotal += thiswrite ;\n\t\tif (thiswrite < writecount)\n\t\t\tbreak ;\n\n\t\tlen -= thiswrite ;\n\t\t} ;\n\n\treturn total ;\n} /* flac_write_d2flac */\n\nstatic void\nd2flac8_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7F))\n\t\t{\tdest [count] = 0x7F ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10))\n\t\t{\tdest [count] = 0x80 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac8_clip_array */\n\nstatic void\nd2flac16_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x1000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac16_clip_array */\n\nstatic void\nd2flac24_clip_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x100000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFF))\n\t\t{\tdest [count] = 0x7FFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x100000))\n\t\t{\tdest [count] = 0x800000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* d2flac24_clip_array */\n\nstatic void\nd2flac8_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7F) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac8_array */\n\nstatic void\nd2flac16_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac16_array */\n\nstatic void\nd2flac24_array (const double *src, int32_t *dest, int count, int normalize)\n{\tdouble normfact = normalize ? (1.0 * 0x7FFFFF) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n} /* d2flac24_array */\n\nstatic sf_count_t\nflac_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t offset)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tif (pflac == NULL)\n\t\treturn 0 ;\n\n\tif (psf->dataoffset < 0)\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn ((sf_count_t) -1) ;\n\t\t} ;\n\n\tpflac->frame = NULL ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif (FLAC__stream_decoder_seek_absolute (pflac->fsd, offset))\n\t\t\treturn offset ;\n\n\t\tif (offset == psf->sf.frames)\n\t\t{\t/*\n\t\t\t** If we've been asked to seek to the very end of the file, libFLAC\n\t\t\t** will return an error. However, we know the length of the file so\n\t\t\t** instead of returning an error, we can return the offset.\n\t\t\t*/\n\t\t\treturn offset ;\n\t\t\t} ;\n\n\t\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn ((sf_count_t) -1) ;\n\t\t} ;\n\n\t/* Seeking in write mode not yet supported. */\n\tpsf->error = SFE_BAD_SEEK ;\n\n\treturn ((sf_count_t) -1) ;\n} /* flac_seek */\n\nstatic int\nflac_byterate (SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_READ)\n\t\treturn (psf->datalength * psf->sf.samplerate) / psf->sf.frames ;\n\n\treturn -1 ;\n} /* flac_byterate */\n\n\n#else /* HAVE_EXTERNAL_XIPH_LIBS */\n\nint\nflac_open\t(SF_PRIVATE *psf)\n{\n\tpsf_log_printf (psf, \"This version of libsndfile was compiled without FLAC support.\\n\") ;\n\treturn SFE_UNIMPLEMENTED ;\n} /* flac_open */\n\n#endif\n"], "filenames": ["src/flac.c"], "buggy_code_start_loc": [71], "buggy_code_end_loc": [925], "fixing_code_start_loc": [70], "fixing_code_end_loc": [941], "type": "CWE-119", "message": "In libsndfile before 1.0.28, an error in the \"flac_buffer_copy()\" function (flac.c) can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.", "other": {"cve": {"id": "CVE-2017-7585", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-07T20:59:00.190", "lastModified": "2017-07-11T01:33:47.330", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libsndfile before 1.0.28, an error in the \"flac_buffer_copy()\" function (flac.c) can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."}, {"lang": "es", "value": "En libsndfile en versiones anteriores a 1.0.28, un error en la funci\u00f3n \"flac_buffer_copy()\" (flac.c) puede ser explotada para provocar un desbordamiento de b\u00fafer basado en pila a trav\u00e9s de un archivo FLAC especialmente manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsndfile_project:libsndfile:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.27", "matchCriteriaId": "59548F6B-A7DD-4844-8347-79E7FEBF8280"}]}]}], "references": [{"url": "http://www.mega-nerd.com/libsndfile/#History", "source": "cve@mitre.org", "tags": ["Product", "Release Notes"]}, {"url": "http://www.mega-nerd.com/libsndfile/NEWS", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/erikd/libsndfile/commit/60b234301adf258786d8b90be5c1d437fc8799e0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://secuniaresearch.flexerasoftware.com/secunia_research/2017-4/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201707-04", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/erikd/libsndfile/commit/60b234301adf258786d8b90be5c1d437fc8799e0"}}