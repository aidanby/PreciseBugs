{"buggy_code": ["import base64\nimport logging\nimport warnings\nfrom builtins import bytes\n\nfrom django_ses.deprecation import RemovedInDjangoSES20Warning\n\nfrom urllib.parse import urlparse\nfrom urllib.request import urlopen\nfrom urllib.error import URLError\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django_ses import settings\n\nlogger = logging.getLogger(__name__)\n\n_CERT_CACHE = {}\n\n\ndef clear_cert_cache():\n    \"\"\"Clear the certificate cache.\n\n    This one-liner exists to discourage imports and direct usage of\n    _CERT_CACHE.\n\n    :returns None\n    \"\"\"\n    _CERT_CACHE.clear()\n\n\nclass EventMessageVerifier(object):\n    \"\"\"\n    A utility class for validating event messages\n\n    See: http://docs.amazonwebservices.com/sns/latest/gsg/SendMessageToHttp.verify.signature.html\n    \"\"\"\n\n    _REQ_DEP_TMPL = (\n        \"%s is required for event message verification. Please install \"\n        \"`django-ses` with the `event` extra - e.g. \"\n        \"`pip install django-ses[events]`.\"\n    )\n\n    def __init__(self, notification):\n        \"\"\"\n        Creates a new event message from the given dict.\n        \"\"\"\n        self._data = notification\n        self._verified = None\n\n    def is_verified(self):\n        \"\"\"\n        Verifies an SES event message.\n\n        Sign the bytes from the notification and compare it to the signature in\n        the notification. If same, return True; else False.\n        \"\"\"\n        if self._verified is not None:\n            return self._verified\n\n        signature = self._data.get(\"Signature\")\n        if not signature:\n            self._verified = False\n            return self._verified\n\n        # Decode the signature from base64\n        signature = bytes(base64.b64decode(signature))\n\n        # Get the message to sign\n        sign_bytes = self._get_bytes_to_sign()\n        if not sign_bytes:\n            self._verified = False\n            return self._verified\n\n        if not self.certificate:\n            self._verified = False\n            return self._verified\n\n        try:\n            from cryptography.exceptions import InvalidSignature\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.asymmetric import padding\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`cryptography`\")\n\n        # Extract the public key\n        pkey = self.certificate.public_key()\n\n        # Use the public key to verify the signature.\n        try:\n            # The details here do not appear to be documented, but the\n            # algorithm and padding choices work in testing, which should mean\n            # they're the right ones.\n            pkey.verify(\n                signature,\n                sign_bytes,\n                padding.PKCS1v15(),\n                hashes.SHA1(),\n            )\n        except InvalidSignature:\n            logger.warning(\n                \"Invalid signature on message with ID: %s\",\n                self._data.get(\"MessageId\"),\n            )\n            self._verified = False\n        else:\n            self._verified = True\n        return self._verified\n\n    @property\n    def certificate(self):\n        \"\"\"\n        Retrieves the certificate used to sign the event message.\n\n        :returns: None if the cert cannot be retrieved. Else, gets the cert\n        caches it, and returns it, or simply returns it if already cached.\n        \"\"\"\n        cert_url = self._get_cert_url()\n        if not cert_url:\n            return None\n\n        if cert_url in _CERT_CACHE:\n            return _CERT_CACHE[cert_url]\n\n        # Only load certificates from a certain domain?\n        # Without some kind of trusted domain check, any old joe could\n        # craft a event message and sign it using his own certificate\n        # and we would happily load and verify it.\n        try:\n            import requests\n            from requests import RequestException\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`requests`\")\n\n        try:\n            from cryptography import x509\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`cryptography`\")\n\n        # We use requests because it verifies the https certificate when\n        # retrieving the signing certificate. If https was somehow hijacked\n        # then all bets are off.\n        try:\n            response = requests.get(cert_url, timeout=10)\n            response.raise_for_status()\n        except RequestException as exc:\n            logger.warning(\n                \"Network error downloading certificate from \" \"%s: %s\",\n                cert_url,\n                exc,\n            )\n            _CERT_CACHE[cert_url] = None\n            return _CERT_CACHE[cert_url]\n\n        # Handle errors loading the certificate.\n        # If the certificate is invalid then return\n        # false as we couldn't verify the message.\n        try:\n            _CERT_CACHE[cert_url] = x509.load_pem_x509_certificate(response.content)\n        except ValueError as e:\n            logger.warning('Could not load certificate from %s: \"%s\"', cert_url, e)\n            _CERT_CACHE[cert_url] = None\n\n        return _CERT_CACHE[cert_url]\n\n    def _get_cert_url(self):\n        \"\"\"\n        Get the signing certificate URL.\n        Only accept urls that match the domains set in the\n        AWS_SNS_EVENT_CERT_TRUSTED_DOMAINS setting. Sub-domains\n        are allowed. i.e. if amazonaws.com is in the trusted domains\n        then sns.us-east-1.amazonaws.com will match.\n        \"\"\"\n        cert_url = self._data.get(\"SigningCertURL\")\n        if not cert_url:\n            logger.warning('No signing certificate URL: \"%s\"', cert_url)\n            return None\n\n        if not cert_url.startswith(\"https://\"):\n            logger.warning('Untrusted certificate URL: \"%s\"', cert_url)\n            return None\n\n        url_obj = urlparse(cert_url)\n        for trusted_domain in settings.EVENT_CERT_DOMAINS:\n            parts = trusted_domain.split(\".\")\n            if url_obj.netloc.split(\".\")[-len(parts) :] == parts:\n                return cert_url\n\n        return None\n\n    def _get_bytes_to_sign(self):\n        \"\"\"\n        Creates the message used for signing SNS notifications.\n        This is used to verify the bounce message when it is received.\n        \"\"\"\n\n        # Depending on the message type the fields to add to the message\n        # differ so we handle that here.\n        msg_type = self._data.get('Type')\n        if msg_type == 'Notification':\n            fields_to_sign = [\n                'Message',\n                'MessageId',\n                'Subject',\n                'Timestamp',\n                'TopicArn',\n                'Type',\n            ]\n        elif (msg_type == 'SubscriptionConfirmation' or\n              msg_type == 'UnsubscribeConfirmation'):\n            fields_to_sign = [\n                'Message',\n                'MessageId',\n                'SubscribeURL',\n                'Timestamp',\n                'Token',\n                'TopicArn',\n                'Type',\n            ]\n        else:\n            # Unrecognized type\n            logger.warning('Unrecognized SNS message Type: \"%s\"', msg_type)\n            return None\n\n        bytes_to_sign = []\n        for field in fields_to_sign:\n            field_value = self._data.get(field)\n            if not field_value:\n                continue\n\n            # Some notification types do not have all fields. Only add fields\n            # with values.\n            bytes_to_sign.append(f\"{field}\\n{field_value}\\n\")\n\n        return \"\".join(bytes_to_sign).encode()\n\n\ndef BounceMessageVerifier(*args, **kwargs):\n    warnings.warn(\n        'utils.BounceMessageVerifier is deprecated. It is renamed to EventMessageVerifier.',\n        RemovedInDjangoSES20Warning,\n    )\n\n    # parameter name is renamed from bounce_dict to notification.\n    if 'bounce_dict' in kwargs:\n        kwargs['notification'] = kwargs['bounce_dict']\n        del kwargs['bounce_dict']\n\n    return EventMessageVerifier(*args, **kwargs)\n\n\ndef verify_event_message(notification):\n    \"\"\"\n    Verify an SES/SNS event notification message.\n    \"\"\"\n    verifier = EventMessageVerifier(notification)\n    return verifier.is_verified()\n\n\ndef verify_bounce_message(msg):\n    \"\"\"\n    Verify an SES/SNS bounce(event) notification message.\n    \"\"\"\n    warnings.warn(\n        'utils.verify_bounce_message is deprecated. It is renamed to verify_event_message.',\n        RemovedInDjangoSES20Warning,\n    )\n    return verify_event_message(msg)\n\n\ndef confirm_sns_subscription(notification):\n    logger.info(\n        'Received subscription confirmation: TopicArn: %s',\n        notification.get('TopicArn'),\n        extra={\n            'notification': notification,\n        },\n    )\n\n    # Get the subscribe url and hit the url to confirm the subscription.\n    subscribe_url = notification.get('SubscribeURL')\n    try:\n        urlopen(subscribe_url).read()\n    except URLError as e:\n        # Some kind of error occurred when confirming the request.\n        logger.error(\n            'Could not confirm subscription: \"%s\"', e,\n            extra={\n                'notification': notification,\n            },\n            exc_info=True,\n        )\n"], "fixing_code": ["import base64\nimport logging\nimport re\nimport warnings\nfrom builtins import bytes\nfrom urllib.error import URLError\nfrom urllib.parse import urlparse\nfrom urllib.request import urlopen\n\nfrom django.core.exceptions import ImproperlyConfigured\n\nfrom django_ses import settings\nfrom django_ses.deprecation import RemovedInDjangoSES20Warning\n\nlogger = logging.getLogger(__name__)\n\n_CERT_CACHE = {}\n\nSES_REGEX_CERT_URL = re.compile(\n    \"(?i)^https://sns\\.[a-z0-9\\-]+\\.amazonaws\\.com(\\.cn)?/SimpleNotificationService\\-[a-z0-9]+\\.pem$\"\n)\n\n\ndef clear_cert_cache():\n    \"\"\"Clear the certificate cache.\n\n    This one-liner exists to discourage imports and direct usage of\n    _CERT_CACHE.\n\n    :returns None\n    \"\"\"\n    _CERT_CACHE.clear()\n\n\nclass EventMessageVerifier(object):\n    \"\"\"\n    A utility class for validating event messages\n\n    See: http://docs.amazonwebservices.com/sns/latest/gsg/SendMessageToHttp.verify.signature.html\n    \"\"\"\n\n    _REQ_DEP_TMPL = (\n        \"%s is required for event message verification. Please install \"\n        \"`django-ses` with the `event` extra - e.g. \"\n        \"`pip install django-ses[events]`.\"\n    )\n\n    def __init__(self, notification):\n        \"\"\"\n        Creates a new event message from the given dict.\n        \"\"\"\n        self._data = notification\n        self._verified = None\n\n    def is_verified(self):\n        \"\"\"\n        Verifies an SES event message.\n\n        Sign the bytes from the notification and compare it to the signature in\n        the notification. If same, return True; else False.\n        \"\"\"\n        if self._verified is not None:\n            return self._verified\n\n        signature = self._data.get(\"Signature\")\n        if not signature:\n            self._verified = False\n            return self._verified\n\n        # Decode the signature from base64\n        signature = bytes(base64.b64decode(signature))\n\n        # Get the message to sign\n        sign_bytes = self._get_bytes_to_sign()\n        if not sign_bytes:\n            self._verified = False\n            return self._verified\n\n        if not self.certificate:\n            self._verified = False\n            return self._verified\n\n        try:\n            from cryptography.exceptions import InvalidSignature\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.asymmetric import padding\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`cryptography`\")\n\n        # Extract the public key\n        pkey = self.certificate.public_key()\n\n        # Use the public key to verify the signature.\n        try:\n            # The details here do not appear to be documented, but the\n            # algorithm and padding choices work in testing, which should mean\n            # they're the right ones.\n            pkey.verify(\n                signature,\n                sign_bytes,\n                padding.PKCS1v15(),\n                hashes.SHA1(),\n            )\n        except InvalidSignature:\n            logger.warning(\n                \"Invalid signature on message with ID: %s\",\n                self._data.get(\"MessageId\"),\n            )\n            self._verified = False\n        else:\n            self._verified = True\n        return self._verified\n\n    @property\n    def certificate(self):\n        \"\"\"\n        Retrieves the certificate used to sign the event message.\n\n        :returns: None if the cert cannot be retrieved. Else, gets the cert\n        caches it, and returns it, or simply returns it if already cached.\n        \"\"\"\n        cert_url = self._get_cert_url()\n        if not cert_url:\n            return None\n\n        if cert_url in _CERT_CACHE:\n            return _CERT_CACHE[cert_url]\n\n        # Only load certificates from a certain domain?\n        # Without some kind of trusted domain check, any old joe could\n        # craft a event message and sign it using his own certificate\n        # and we would happily load and verify it.\n        try:\n            import requests\n            from requests import RequestException\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`requests`\")\n\n        try:\n            from cryptography import x509\n        except ImportError:\n            raise ImproperlyConfigured(self._REQ_DEP_TMPL % \"`cryptography`\")\n\n        # We use requests because it verifies the https certificate when\n        # retrieving the signing certificate. If https was somehow hijacked\n        # then all bets are off.\n        try:\n            response = requests.get(cert_url, timeout=10)\n            response.raise_for_status()\n        except RequestException as exc:\n            logger.warning(\n                \"Network error downloading certificate from \" \"%s: %s\",\n                cert_url,\n                exc,\n            )\n            _CERT_CACHE[cert_url] = None\n            return _CERT_CACHE[cert_url]\n\n        # Handle errors loading the certificate.\n        # If the certificate is invalid then return\n        # false as we couldn't verify the message.\n        try:\n            _CERT_CACHE[cert_url] = x509.load_pem_x509_certificate(response.content)\n        except ValueError as e:\n            logger.warning('Could not load certificate from %s: \"%s\"', cert_url, e)\n            _CERT_CACHE[cert_url] = None\n\n        return _CERT_CACHE[cert_url]\n\n    def _get_cert_url(self):\n        \"\"\"\n        Get the signing certificate URL.\n        Only accept urls that match the domains set in the\n        AWS_SNS_EVENT_CERT_TRUSTED_DOMAINS setting. Sub-domains\n        are allowed. i.e. if amazonaws.com is in the trusted domains\n        then sns.us-east-1.amazonaws.com will match.\n        \"\"\"\n        cert_url = self._data.get(\"SigningCertURL\")\n        if not cert_url:\n            logger.warning('No signing certificate URL: \"%s\"', cert_url)\n            return None\n\n        if not cert_url.startswith(\"https://\"):\n            logger.warning('Untrusted certificate URL: \"%s\"', cert_url)\n            return None\n\n        url_obj = urlparse(cert_url)\n        for trusted_domain in settings.EVENT_CERT_DOMAINS:\n            parts = trusted_domain.split(\".\")\n            if \"amazonaws.com\" in trusted_domain:\n                if not SES_REGEX_CERT_URL.match(cert_url):\n                    if len(parts) < 4:\n                        return None\n                    else:\n                        logger.warning('Possible security risk for: \"%s\"', cert_url)\n                        logger.warning(\n                            \"It is strongly recommended to configure the full domain in EVENT_CERT_DOMAINS. \"\n                            \"See v3.5.0 release notes for more details.\"\n                        )\n\n            if url_obj.netloc.split(\".\")[-len(parts) :] == parts:\n                return cert_url\n\n        return None\n\n    def _get_bytes_to_sign(self):\n        \"\"\"\n        Creates the message used for signing SNS notifications.\n        This is used to verify the bounce message when it is received.\n        \"\"\"\n\n        # Depending on the message type the fields to add to the message\n        # differ so we handle that here.\n        msg_type = self._data.get(\"Type\")\n        if msg_type == \"Notification\":\n            fields_to_sign = [\n                \"Message\",\n                \"MessageId\",\n                \"Subject\",\n                \"Timestamp\",\n                \"TopicArn\",\n                \"Type\",\n            ]\n        elif (\n            msg_type == \"SubscriptionConfirmation\"\n            or msg_type == \"UnsubscribeConfirmation\"\n        ):\n            fields_to_sign = [\n                \"Message\",\n                \"MessageId\",\n                \"SubscribeURL\",\n                \"Timestamp\",\n                \"Token\",\n                \"TopicArn\",\n                \"Type\",\n            ]\n        else:\n            # Unrecognized type\n            logger.warning('Unrecognized SNS message Type: \"%s\"', msg_type)\n            return None\n\n        bytes_to_sign = []\n        for field in fields_to_sign:\n            field_value = self._data.get(field)\n            if not field_value:\n                continue\n\n            # Some notification types do not have all fields. Only add fields\n            # with values.\n            bytes_to_sign.append(f\"{field}\\n{field_value}\\n\")\n\n        return \"\".join(bytes_to_sign).encode()\n\n\ndef BounceMessageVerifier(*args, **kwargs):\n    warnings.warn(\n        \"utils.BounceMessageVerifier is deprecated. It is renamed to EventMessageVerifier.\",\n        RemovedInDjangoSES20Warning,\n    )\n\n    # parameter name is renamed from bounce_dict to notification.\n    if \"bounce_dict\" in kwargs:\n        kwargs[\"notification\"] = kwargs[\"bounce_dict\"]\n        del kwargs[\"bounce_dict\"]\n\n    return EventMessageVerifier(*args, **kwargs)\n\n\ndef verify_event_message(notification):\n    \"\"\"\n    Verify an SES/SNS event notification message.\n    \"\"\"\n    verifier = EventMessageVerifier(notification)\n    return verifier.is_verified()\n\n\ndef verify_bounce_message(msg):\n    \"\"\"\n    Verify an SES/SNS bounce(event) notification message.\n    \"\"\"\n    warnings.warn(\n        \"utils.verify_bounce_message is deprecated. It is renamed to verify_event_message.\",\n        RemovedInDjangoSES20Warning,\n    )\n    return verify_event_message(msg)\n\n\ndef confirm_sns_subscription(notification):\n    logger.info(\n        \"Received subscription confirmation: TopicArn: %s\",\n        notification.get(\"TopicArn\"),\n        extra={\n            \"notification\": notification,\n        },\n    )\n\n    # Get the subscribe url and hit the url to confirm the subscription.\n    subscribe_url = notification.get(\"SubscribeURL\")\n    try:\n        urlopen(subscribe_url).read()\n    except URLError as e:\n        # Some kind of error occurred when confirming the request.\n        logger.error(\n            'Could not confirm subscription: \"%s\"',\n            e,\n            extra={\n                \"notification\": notification,\n            },\n            exc_info=True,\n        )\n"], "filenames": ["django_ses/utils.py"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [290], "fixing_code_start_loc": [3], "fixing_code_end_loc": [308], "type": "CWE-347", "message": "Django-SES is a drop-in mail backend for Django. The django_ses library implements a mail backend for Django using AWS Simple Email Service. The library exports the `SESEventWebhookView class` intended to receive signed requests from AWS to handle email bounces, subscriptions, etc. These requests are signed by AWS and are verified by django_ses, however the verification of this signature was found to be flawed as it allowed users to specify arbitrary public certificates. This issue was patched in version 3.5.0.", "other": {"cve": {"id": "CVE-2023-33185", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-26T21:15:20.527", "lastModified": "2023-06-06T18:09:12.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Django-SES is a drop-in mail backend for Django. The django_ses library implements a mail backend for Django using AWS Simple Email Service. The library exports the `SESEventWebhookView class` intended to receive signed requests from AWS to handle email bounces, subscriptions, etc. These requests are signed by AWS and are verified by django_ses, however the verification of this signature was found to be flawed as it allowed users to specify arbitrary public certificates. This issue was patched in version 3.5.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:django-ses_project:django-ses:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.5.0", "matchCriteriaId": "B87C9D64-0546-4BC8-B456-D2EB87E34F57"}]}]}], "references": [{"url": "https://github.com/django-ses/django-ses/blob/3d627067935876487f9938310d5e1fbb249a7778/CVE/001-cert-url-signature-verification.md", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/django-ses/django-ses/commit/b71b5f413293a13997b6e6314086cb9c22629795", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/django-ses/django-ses/security/advisories/GHSA-qg36-9jxh-fj25", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/django-ses/django-ses/commit/b71b5f413293a13997b6e6314086cb9c22629795"}}