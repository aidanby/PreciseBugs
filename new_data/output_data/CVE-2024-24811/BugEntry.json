{"buggy_code": ["Change log\n==========\n\n2.2 (unreleased)\n----------------\n\n- Add support for Python 3.12.\n\n\n2.1 (2023-09-04)\n----------------\n\n- Add support for SQLAlchemy 2.0\n  (`#16 <https://github.com/zopefoundation/Products.SQLAlchemyDA/issues/16>`_)\n\n\n2.0 (2023-02-01)\n----------------\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n\n1.1.0 (2022-12-16)\n------------------\n\n- Fix insidious buildout configuration bug for tests against Zope 4.\n\n- Add support for Python 3.10 and 3.11.\n\n\n1.0.2 (2021-11-02)\n------------------\n\n- fix unexpected NoneType return on sql-update\n  (`#12 <https://github.com/zopefoundation/Products.SQLAlchemyDA/pull/12>`_)\n\n\n1.0.1 (2021-05-03)\n------------------\n\n- fix test failures under Python 3.5 by pinning SQLAlchemy.\n  Pin can be dropped when support for Zope 4 is dropped.\n\n- change package structure to move package code into a ``src`` subfolder\n\n\n1.0.0 (2020-11-13)\n------------------\n\n- add linting configurations and apply results\n\n- Package cleanup\n\n- Add support for Python 3.5-3.9\n  (`#8 <https://github.com/zopefoundation/Products.SQLAlchemyDA/pull/8>`_)\n\n\n0.6.2b3 (2017-04-03)\n--------------------\nURL fix in add form.\n\n\n0.6.2b2 (2015-06-24)\n--------------------\n\nWorkarounds for edge case error conditions looking up or\ncreating underlying z3c.sqlalchemy ZopeWrapper instances.\n\n\n0.6.2b1 (2015-06-23)\n--------------------\n\nBeta Release: If you try out this version, please provide feedback!\n\nAdded public API for use within Zope acquisition context to access\nthe underlying zc3.sqlalchemy `ZopeWrapper` instance, with added\nerror handling and logging to deal with situations where Zope\ncontext may have been lost.\n\nTests now assume a testrunner such as nose or py.test, and\ntestfixtures has been added as a testing dependency.\n\n\n0.6.1b1 (2015-06-19)\n--------------------\n\nImproved safety of non-acquisition public API by making registry no longer\ncontain Zope Persistent objects; instead storing and returning only the\nunderlying zc3.sqlalchemy `ZopeWrapper` instances. These objects\nare plain Python objects in memory with no Persistent connection to ZODB.\n(Thanks to Tres Seaver for the suggestion!)\n\n\n0.6.0b7 (2015-04-27)\n--------------------\n\nThis is a more stable beta, with several fixes. It has been tested\nwith SQLAlchemy 0.9.8, Zope2.13, and Python 2.7.9.\n\nFixes from beta 1-7 include:\n\n- Manifest now includes the .rst, .txt, and .zpt files required\n  for installation via ZMI in Zope2.\n- The new `lookup_da` registry was failing to populate after\n  Zope restarts; now the registry populates when the DA instance\n  unpickles. (TODO: needs test coverage; this feature is not\n  as robust as it could be, since the registry could be\n  called before unpickling). UPDATE for beta 7: Still no\n  test coverage, but after manual testing fixed bug with\n  switched key and values in registry.\n- Added a new `clear_da_registry` to support test teardown.\n- NOTE: Beta6 release was taken from the wrong branch,\n  and contained experimental untested code. DO not use beta6.\n\nSome non-public patches to support MSSQL have been tested; please inquire if\ninterested in having them merged to public code.\n\n\n0.6.0b (2015-03-23)\n-------------------\n\n- Added alternative lookup API to get a handle on SAWrapper instances.  To use\n  the new lookup mechanism, see Products.SQLAlchemyDA.da.py and look for the\n  function `lookup_da`. This was created to allow avoiding Zope Acquisition as\n  a lookup mechanism, and to work around the issue that the underlying\n  z3c.sqlalchemy `getSAWrapper` function is non-usable when created by the\n  SAWrapper DA. This is because API consumers have no access to the random\n  internally generated name ('util_id' attribute) under which the utility\n  is registered...at least not without resorting to Acquisition calls.\n- Tested with SQLAlchemy 0.7.6, Zope 2.13, and Python 2.7.9, and SQLite.\n  Your mileage may vary with other databases and versions, but most likely\n  it will run with older versions of Zope and Python as old as 2.5 (running\n  tests requires at least Python 2.5). Newer versions of SQLAlchemy will be\n  tested for the next release.\n\n\n0.5.2 (unreleased)\n------------------\n- Fixed LP #639597\n\n0.5.1 (2010-08-05)\n------------------\n- fixed typo in type mapping\n\n0.5.0 (2010-05-07)\n------------------\n\n- Fixed LP #570208\n- Added a method 'add_extra_engine_options' to set additional engine\n  options for SQLAlchemy.create_engine.\n- Removed SOFTWARE_HOME dependency\n- Requires SQLAlchemy >= 0.5.0\n\n0.4.1 (2008-06-01)\n------------------\n\n- fixed issue with version.txt file\n\n0.4.0 (2008-01-24)\n------------------\n\n- requires z3c.sqlalchemy (2.0.0 or higher)\n- requires SQLAlchemy 0.4.4 or higer\n\n\n0.3.0 (2007-06-10)\n------------------\n\n- fixed some security assertions\n- added \"Test\" tab for executing SQL queries directly\n- better error handling for ZMI screens\n- no longer depending on a pre-registered SQLAlchemy wrapper. SQLAlchemyDA\n  now accepts (as any other DA) a DSN as property 'dsn'\n- DSN can be passed through the add form\n- redirect directly to \"Info\" tab after creating an instance through the ZMI\n- catching some low-level exceptions from the sqlite interface in order to\n  make it work with SQLite\n- new properties 'transactional' and 'quoting_style'\n- improved support for Oracle and MySQL\n- SQLAlchemyDA no longer provides access to mapper related functionalities.\n  It now acts as a DA for executing SQL statements *only*.\n- fixed unregistration code for a wrapper (hopefully works with Zope 2.8 or\n  higher)\n\n- updated documentation\n\n0.2.1 (2007-05-06)\n------------------\n\n- connections can be closed/opened through the ZMI\n- some code cleanup\n- fixed a *very* stupid typo causing ZODB conflict errors\n\n0.2.0 (2007-05-05)\n------------------\n\n- first public release\n\n0.1.0 (2007-04-30)\n------------------\n\n- initial coding\n", "\"\"\"\nA DA-like integration of SQLAlchemy based on z3c.sqlalchemy\n\n(C) Zope Corporation and Contributors\nWritten by Andreas Jung for Haufe Mediengruppe, Freiburg, Germany\nand ZOPYX Ltd. & Co. KG, Tuebingen, Germany\n\"\"\"\n\nimport logging\nimport random\nimport time\nimport warnings\n\nfrom AccessControl import ClassSecurityInfo\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.Permissions import view_management_screens\nfrom OFS.PropertyManager import PropertyManager\nfrom OFS.SimpleItem import SimpleItem\nfrom Products.PageTemplates.PageTemplateFile import PageTemplateFile\nfrom zope.component import getGlobalSiteManager\n\nfrom z3c.sqlalchemy import createSAWrapper\nfrom z3c.sqlalchemy import getSAWrapper\nfrom z3c.sqlalchemy.interfaces import ISQLAlchemyWrapper\nfrom zope.sqlalchemy import mark_changed\n\n\nlogger = logging.getLogger('SQLAlchemyDA')\n\n# maps Python DB-API types to Zope types\ntypes_mapping = {\n    'DATE': 'd',\n    'TIME': 'd',\n    'DATETIME': 'd',\n    'STRING': 's',\n    'LONGINTEGER': 'i',\n    'INTEGER': 'i',\n    'NUMBER': 'n',\n    'BOOLEAN': 'n',\n    'ROWID': 'i',\n    'BINARY': None,  # ????\n}\n\n\n# Global registry of named Zope SQLAlchemyDA instances created to\n# work around unique anonymous/random names assigned to such wrappers\n# by the legacy DA code\n_wrapper_registry = {}\n\n\ndef register_sa_wrapper(name, wrapper):\n    \"\"\"\n    Register an SQLAlchemy `ZopeWrapper` database adapter by name as part of a\n    module level dict.\n\n    Args:\n        name(str): a globally unique name for the given `da_instance`). This\n                   is generally a Zope object id, automatically registered when\n                   instances of `SAWrapper` are initialized.  If this name is\n                   not unique, the most recently registered name will take\n                   effect. This registration API is not designed to be used\n                   with multiple `SAWrapper` instances sharing the same Zope\n                   object ids. An error will not be raised, to prevent problems\n                   for the majority of users who don't make use of this\n                   registration API (and use Acquisition instead).\n        wrapper(`SAWrapper`): a configured instance of\n                              `z3c.sqlalchemy.ZopeWrapper`\n\n    This might be called early in Zope startup, so this type of registration is\n    necessary instead of a zope.component registration.  (The same reason\n    z3c.sqlalchemy claims for using a module dict for registration)\n\n    Returns:\n        None\n    \"\"\"\n    _wrapper_registry[name] = wrapper\n\n\ndef deregister_sa_wrapper(name):\n    \"\"\"\n    Remove a named `SAWrapper` instance from the DA registry, if it exists.\n    Either way, the return value is None.\n    \"\"\"\n    _wrapper_registry.pop(name, None)\n\n\ndef lookup_sa_wrapper(name):\n    \"\"\"\n    Look up and return an `z3c.sqlalchemy.ZopeWrapper` instance registered by\n    name.\n\n    These instances are registered by the `SAWrapper` during initialization\n    of `ZopeWrapper` instances.\n\n    Returns:\n        'SAWrapper' instance.\n    \"\"\"\n    da = _wrapper_registry.get(name)\n    if not da:\n        raise LookupError(\"No SAWrapper instance registered under name \"\n                          + name)\n    return da\n\n\ndef clear_sa_wrapper_registry():\n    \"\"\"\n    Completely empty out the registry of `SAWrapper` instances.\n    \"\"\"\n    global _wrapper_registry\n    _wrapper_registry = {}\n\n\nclass SAWrapper(SimpleItem, PropertyManager):\n\n    \"\"\" A shim around z3c.sqlalchemy implementing something DA-ish \"\"\"\n\n    # MISSING document any special DA-ish hooks or places where Zope\n    #         automatically makes calls, or at least link to docs on\n    #         what makes it DA-ish. Is there a documented protocol?\n\n    manage_options = (({'label': 'Info', 'action': 'manage_workspace'},) +\n                      ({'label': 'Test', 'action': 'manage_test'},) +\n                      PropertyManager.manage_options +\n                      SimpleItem.manage_options)\n    _properties = (\n        {'id': 'dsn', 'type': 'string', 'mode': 'rw', },\n        {'id': 'title', 'type': 'string', 'mode': 'rw'},\n        {'id': 'encoding', 'type': 'string', 'mode': 'rw'},\n        {'id': 'transactional', 'type': 'boolean', 'mode': 'rw'},\n        {'id': 'convert_unicode', 'type': 'boolean', 'mode': 'rw'},\n        {'id': 'quoting_style', 'type': 'selection', 'mode': 'rw',\n               'select_variable': 'allQuotingStyles'},\n    )\n\n    meta_type = 'SQLAlchemyDA '\n    dsn = ''\n    encoding = 'iso-8859-15'\n    convert_unicode = 0\n    transactional = True\n    quoting_style = 'standard'\n    _isAnSQLConnection = True\n    extra_engine_options = ()\n    zmi_icon = 'fas fa-database'\n    zmi_show_add_dialog = False\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, id, title=''):\n        self.id = id\n        self.title = title\n\n    def __setstate__(self, *args, **kwargs):\n        \"\"\"\n        When an instance of SAWrapper is unpickled, perform the normal\n        'wakeup', but also ensure that the instance is in the module\n        registry of instances.\n        \"\"\"\n        # Don't use 'super' when old-style classes are involved.\n        SimpleItem.__setstate__(self, *args, **kwargs)\n        wrapper = self.sa_zope_wrapper()\n        if wrapper:\n            register_sa_wrapper(self.id, wrapper)\n\n    def manage_afterAdd(self, item, container):\n        \"\"\" Ensure that a new utility id is assigned after creating\n            or copying an instance.\n        \"\"\"\n        self._new_utilid()\n        wrapper = self.sa_zope_wrapper()\n        if wrapper:\n            register_sa_wrapper(self.id, wrapper)\n        return SimpleItem.manage_afterAdd(self, item, container)\n\n    def _new_utilid(self):\n        \"\"\" Assign a new unique utility ID \"\"\"\n        self.util_id = f'{time.time()}.{random.random()}'\n\n    def allQuotingStyles(self):\n        return ('standard', 'no-quote')\n\n    @property\n    def _wrapper(self):\n        \"\"\"\n        Legacy API for accessing the underlying z3c.sqlalchemy `ZopeWrapper`.\n\n        This API should no longer be used because:\n\n            1. Python property decorators can interfere with acquisition\n               context\n            2. It's not really private so is misnamed.\n\n        Instead use self.sa_zope_wrapper\n        \"\"\"\n        # can't use deprecation decorator, due to interference with\n        # acquisition context\n        warnings.warn(\"SAWrapper._wrapper deprecated, use \"\n                      \"SAWrapper.sa_zope_wrapper() instead\",\n                      DeprecationWarning,\n                      stacklevel=2)\n        return self.sa_zope_wrapper()\n\n    def sa_zope_wrapper(self):\n        \"\"\"\n        Public API for accessing the underlying z3c.sqlalchemy `ZopeWrapper`.\n\n        The first attempt will be to lookup the wrapper via attributes\n        accessible in the Zope context (self.util_id); if it does not exist,\n        the wrapper will be created and return.\n\n        If Zope acquisition context has been lost, fall back to the module\n        dict registration mechanism (which might not always be available\n        very early in the startup process, but should be available most\n        other times).\n        \"\"\"\n        wrapper = self._supply_z3c_sa_wrapper()\n        if wrapper is not None:\n            return wrapper\n        else:\n            # we've got trouble; log relevant info and fallback on module\n            # dict registration\n            selftype = type(self)\n            try:\n                # don't reveal DSN contents in a log file\n                dsn = 'nonempty' if self.dsn else self.dsn\n            except AttributeError:\n                dsn = 'AttributeError'\n            try:\n                util_id = self.util_id\n            except AttributeError:\n                util_id = 'AttributeError'\n            msg = (\"SAWrapper failed to get a handle to live connection.\\n\"\n                   \"Did we lose Acquisition context? type(self) is %s.\\n\"\n                   \"The self.dsn is '%s' and self.util_id is '%s'.\")\n            logger.exception(msg, selftype, dsn, util_id)\n            # Now that we've logged what we need, try recovering by using\n            # the module dict lookup.\n            try:\n                return lookup_sa_wrapper(self.id)\n            except LookupError:\n                # no such luck\n                return None\n\n    def _supply_z3c_sa_wrapper(self):\n        \"\"\"\n        Look up or create the underlying z3c.sqlalchemy `ZopeWrapper`.\n        \"\"\"\n        if not self.dsn:\n            return None\n        else:\n            try:\n                wrapper = getSAWrapper(self.util_id)\n            except ValueError:\n                try:\n                    if self.util_id is None:\n                        # the z3c.sqlalchemy registration doesn't register\n                        # None values of util_id; we need something that\n                        # will stick.\n                        self._new_utilid()\n                    wrapper = createSAWrapper(\n                        self.dsn,\n                        forZope=True,\n                        transactional=self.transactional,\n                        extension_options={'initial_state': 'invalidated'},\n                        engine_options=self.engine_options,\n                        name=self.util_id)\n                    register_sa_wrapper(self.id, wrapper)\n                except ValueError as e:\n                    # ...weird...could this be a timing issue during startup?\n                    # We've seen log messages that look like this:\n                    # \"ValueError: SAWrapper '1435583419.58.0.991532919015'\n                    # already registered. You can not register a wrapper\n                    # twice under the same name.\"\n                    # This makes little sense because we just tried a lookup\n                    # under that name and did not find it. Wrapper did not\n                    # exist in component registry, but did exist in the\n                    # z3c.sqlalchemy registeredWrappers dict registry. Try\n                    # recovering by using the module dict lookup.\n                    msg = \"Unexpected failure to create SAWrapper: \" + str(e)\n                    logger.warning(msg)\n                    try:\n                        wrapper = getSAWrapper(self.util_id)\n                    except LookupError as e:\n                        msg = (\"SAWrapper lookup falling back to SQLAlchemyDA \"\n                               \" registry:\" + str(e))\n                        logger.warning(msg)\n                        wrapper = lookup_sa_wrapper(self.id)\n                    except Exception:\n                        msg = \"No z3c.sqlalchemy ZopeWrapper found or created!\"\n                        logger.exception(msg)\n                        wrapper = None\n        return wrapper\n\n    @property\n    def engine_options(self):\n        engine_options = dict(self.extra_engine_options)\n        return engine_options\n\n    def add_extra_engine_options(self, engine_options):\n        \"\"\" engine_options is a tuple containing additional\n            options for sqlalchemy.create_engine.\n            Say you need to pass some engine options\n            to SQLAlchemy.create_engine::\n            wrapper = SAWrapper(id)\n            wrapper.add_extra_engine_options((('echo', True),\n                                              ('pool_size', 20)))\n        \"\"\"\n        self.extra_engine_options = engine_options\n\n    @security.protected(view_management_screens)\n    def getInfo(self):\n        \"\"\" return a dict with additional information \"\"\"\n        wrapper = self.sa_zope_wrapper()\n        if wrapper is not None:\n            d = self.sa_zope_wrapper().__dict__.copy()\n            d['DSN'] = self.sa_zope_wrapper().dsn\n            for k in list(d.keys()):\n                if k.startswith('_'):\n                    del d[k]\n            return d\n        else:\n            return {}\n\n    def _typesMap(self, proxy):\n        \"\"\" Obtain types map from the underlying DB-API. I hope\n            that is portable code.\n        \"\"\"\n\n        if not hasattr(self, '_v_types_map'):\n            dbapi = self.sa_zope_wrapper().engine.dialect.dbapi\n\n            map = dict()\n            for name in types_mapping.keys():\n                type_obj = getattr(dbapi, name, None)\n                if type_obj:\n                    if hasattr(type_obj, 'values'):\n                        for v in type_obj.values:\n                            map[v] = name\n                    else:\n                        try:\n                            for v in type_obj:\n                                map[v] = name\n                        except TypeError:\n                            # ATT: fix this:->\n                            pass\n\n            self._v_types_map = map\n        return self._v_types_map\n\n    def query(self, query_string, max_rows=None, query_data=None):\n        \"\"\" *The* query() method as used by the internal ZSQL\n            machinery.\n        \"\"\"\n        mark_changed(self.sa_zope_wrapper().session)\n        conn = self.sa_zope_wrapper().connection\n        cursor = conn.cursor()\n\n        rows = []\n        desc = None\n        nselects = 0\n\n        ts_start = time.time()\n\n        for qs in [x for x in query_string.split('\\0') if x]:\n\n            logger.debug(qs)\n            if query_data:\n                proxy = cursor.execute(qs, query_data)\n            else:\n                proxy = cursor.execute(qs)\n\n            description = cursor.description\n\n            if description is not None:\n                nselects += 1\n\n                if nselects > 1:\n                    raise ValueError(\"Can't execute multiple SELECTs \"\n                                     \"within a single query\")\n\n                if max_rows:\n                    rows = cursor.fetchmany(max_rows)\n                else:\n                    rows = cursor.fetchall()\n\n                desc = description\n                types_map = self._typesMap(proxy)\n\n        logger.debug('Execution time: %3.3f seconds' %\n                     (time.time() - ts_start))\n\n        if desc is None:\n            return (), ()\n\n        items = []\n        for (name,\n             type_code,\n             width,\n             internal_size,\n             precision,\n             scale,\n             null_ok) in desc:\n\n            items.append({\n                'name': name,\n                'type': types_mapping.get(types_map.get(type_code, None), 's'),\n                'null': null_ok,\n                'width': width, })\n\n        return items, rows\n\n    def __call__(self, *args, **kv):\n        return self\n\n    def sql_quote__(self, s):\n        if self.quoting_style == 'standard':\n            if \"\\'\" in s:\n                s = \"''\".join(s.split(\"\\'\"))\n            return \"'%s'\" % s\n        else:\n            return s\n\n    @security.protected(view_management_screens)\n    def connected(self):\n        try:\n            return self.sa_zope_wrapper()._engine.pool.checkedin() > 0\n        except Exception:\n            return 'n/a'\n\n    @security.protected(view_management_screens)\n    def getPoolSize(self):\n        \"\"\" \"\"\"\n        return self.sa_zope_wrapper()._engine.pool.size()\n\n    @security.protected(view_management_screens)\n    def getCheckedin(self):\n        \"\"\" \"\"\"\n        try:\n            return self.sa_zope_wrapper()._engine.pool.checkedin()\n        except Exception:\n            return 'n/a'\n\n    @security.protected(view_management_screens)\n    def manage_start(self, RESPONSE=None):\n        \"\"\" start engine \"\"\"\n        url = '%s/manage_workspace?manage_tabs_message=%s'\n        try:\n            self.query('COMMIT')\n            if RESPONSE:\n                msg = 'Database connection opened'\n                RESPONSE.redirect(url % (self.absolute_url(), msg))\n        except Exception as e:\n            if RESPONSE:\n                msg = 'Database connection could not be opened (%s)' % e\n                RESPONSE.redirect(url % (self.absolute_url(), msg))\n            else:\n                raise\n\n    @security.protected(view_management_screens)\n    def manage_stop(self, RESPONSE=None):\n        \"\"\" close engine \"\"\"\n        self.sa_zope_wrapper()._engine.pool.dispose()\n        if RESPONSE:\n            msg = 'Database connections closed'\n            RESPONSE.redirect(self.absolute_url() +\n                              '/manage_workspace?manage_tabs_message=%s' % msg)\n\n    @security.protected(view_management_screens)\n    def manage_doQuery(self, query):\n        \"\"\" perform a query through the ZMI\"\"\"\n        return self.query(query)\n\n    @security.protected(view_management_screens)\n    def manage_formatItem(self, s):\n        \"\"\" used by query form \"\"\"\n        if isinstance(s, str):\n            return s\n        if isinstance(s, bytes):\n            return s.decode(self.encoding, 'ignore')\n        return str(s)\n\n    @security.protected(view_management_screens)\n    def manage_editProperties(self, REQUEST):\n        \"\"\" Intercept changed properties in order to perform\n            further actions.\n        \"\"\"\n        gsm = getGlobalSiteManager()\n        gsm.unregisterUtility(provided=ISQLAlchemyWrapper, name=self.util_id)\n        self._new_utilid()\n\n        return super().manage_editProperties(REQUEST)\n\n    manage_workspace = PageTemplateFile('pt/info', globals(),\n                                        __name__='manage_workspace')\n    manage_test = PageTemplateFile('pt/query', globals(),\n                                   __name__='manage_test')\n\n\nInitializeClass(SAWrapper)\n\n\ndef manage_addSAWrapper(self, id, dsn, title, encoding='iso-8859-15',\n                        convert_unicode=0, RESPONSE=None):\n    \"\"\" create a new SAWrapper instance \"\"\"\n    wrapper = SAWrapper(id, title)\n    wrapper.dsn = dsn\n    wrapper.convert_unicode = convert_unicode\n    wrapper.encoding = encoding\n    # this will call manage_afterAdd\n    self._setObject(id, wrapper.__of__(self))\n    if RESPONSE:\n        return RESPONSE.redirect(self._getOb(id).absolute_url()\n                                 + '/manage_workspace')\n    else:\n        return wrapper\n\n\nmanage_addSAWrapperForm = PageTemplateFile('pt/addSAWrapperForm',\n                                           globals(),\n                                           __name__='addSAWrapperForm')\n"], "fixing_code": ["Change log\n==========\n\n2.2 (unreleased)\n----------------\n\n- Add missing security declarations on the database adapter class\n  to mitigate arbitrary SQL query execution vulnerability.\n\n- Add support for Python 3.12.\n\n\n2.1 (2023-09-04)\n----------------\n\n- Add support for SQLAlchemy 2.0\n  (`#16 <https://github.com/zopefoundation/Products.SQLAlchemyDA/issues/16>`_)\n\n\n2.0 (2023-02-01)\n----------------\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n\n1.1.0 (2022-12-16)\n------------------\n\n- Fix insidious buildout configuration bug for tests against Zope 4.\n\n- Add support for Python 3.10 and 3.11.\n\n\n1.0.2 (2021-11-02)\n------------------\n\n- fix unexpected NoneType return on sql-update\n  (`#12 <https://github.com/zopefoundation/Products.SQLAlchemyDA/pull/12>`_)\n\n\n1.0.1 (2021-05-03)\n------------------\n\n- fix test failures under Python 3.5 by pinning SQLAlchemy.\n  Pin can be dropped when support for Zope 4 is dropped.\n\n- change package structure to move package code into a ``src`` subfolder\n\n\n1.0.0 (2020-11-13)\n------------------\n\n- add linting configurations and apply results\n\n- Package cleanup\n\n- Add support for Python 3.5-3.9\n  (`#8 <https://github.com/zopefoundation/Products.SQLAlchemyDA/pull/8>`_)\n\n\n0.6.2b3 (2017-04-03)\n--------------------\nURL fix in add form.\n\n\n0.6.2b2 (2015-06-24)\n--------------------\n\nWorkarounds for edge case error conditions looking up or\ncreating underlying z3c.sqlalchemy ZopeWrapper instances.\n\n\n0.6.2b1 (2015-06-23)\n--------------------\n\nBeta Release: If you try out this version, please provide feedback!\n\nAdded public API for use within Zope acquisition context to access\nthe underlying zc3.sqlalchemy `ZopeWrapper` instance, with added\nerror handling and logging to deal with situations where Zope\ncontext may have been lost.\n\nTests now assume a testrunner such as nose or py.test, and\ntestfixtures has been added as a testing dependency.\n\n\n0.6.1b1 (2015-06-19)\n--------------------\n\nImproved safety of non-acquisition public API by making registry no longer\ncontain Zope Persistent objects; instead storing and returning only the\nunderlying zc3.sqlalchemy `ZopeWrapper` instances. These objects\nare plain Python objects in memory with no Persistent connection to ZODB.\n(Thanks to Tres Seaver for the suggestion!)\n\n\n0.6.0b7 (2015-04-27)\n--------------------\n\nThis is a more stable beta, with several fixes. It has been tested\nwith SQLAlchemy 0.9.8, Zope2.13, and Python 2.7.9.\n\nFixes from beta 1-7 include:\n\n- Manifest now includes the .rst, .txt, and .zpt files required\n  for installation via ZMI in Zope2.\n- The new `lookup_da` registry was failing to populate after\n  Zope restarts; now the registry populates when the DA instance\n  unpickles. (TODO: needs test coverage; this feature is not\n  as robust as it could be, since the registry could be\n  called before unpickling). UPDATE for beta 7: Still no\n  test coverage, but after manual testing fixed bug with\n  switched key and values in registry.\n- Added a new `clear_da_registry` to support test teardown.\n- NOTE: Beta6 release was taken from the wrong branch,\n  and contained experimental untested code. DO not use beta6.\n\nSome non-public patches to support MSSQL have been tested; please inquire if\ninterested in having them merged to public code.\n\n\n0.6.0b (2015-03-23)\n-------------------\n\n- Added alternative lookup API to get a handle on SAWrapper instances.  To use\n  the new lookup mechanism, see Products.SQLAlchemyDA.da.py and look for the\n  function `lookup_da`. This was created to allow avoiding Zope Acquisition as\n  a lookup mechanism, and to work around the issue that the underlying\n  z3c.sqlalchemy `getSAWrapper` function is non-usable when created by the\n  SAWrapper DA. This is because API consumers have no access to the random\n  internally generated name ('util_id' attribute) under which the utility\n  is registered...at least not without resorting to Acquisition calls.\n- Tested with SQLAlchemy 0.7.6, Zope 2.13, and Python 2.7.9, and SQLite.\n  Your mileage may vary with other databases and versions, but most likely\n  it will run with older versions of Zope and Python as old as 2.5 (running\n  tests requires at least Python 2.5). Newer versions of SQLAlchemy will be\n  tested for the next release.\n\n\n0.5.2 (unreleased)\n------------------\n- Fixed LP #639597\n\n0.5.1 (2010-08-05)\n------------------\n- fixed typo in type mapping\n\n0.5.0 (2010-05-07)\n------------------\n\n- Fixed LP #570208\n- Added a method 'add_extra_engine_options' to set additional engine\n  options for SQLAlchemy.create_engine.\n- Removed SOFTWARE_HOME dependency\n- Requires SQLAlchemy >= 0.5.0\n\n0.4.1 (2008-06-01)\n------------------\n\n- fixed issue with version.txt file\n\n0.4.0 (2008-01-24)\n------------------\n\n- requires z3c.sqlalchemy (2.0.0 or higher)\n- requires SQLAlchemy 0.4.4 or higer\n\n\n0.3.0 (2007-06-10)\n------------------\n\n- fixed some security assertions\n- added \"Test\" tab for executing SQL queries directly\n- better error handling for ZMI screens\n- no longer depending on a pre-registered SQLAlchemy wrapper. SQLAlchemyDA\n  now accepts (as any other DA) a DSN as property 'dsn'\n- DSN can be passed through the add form\n- redirect directly to \"Info\" tab after creating an instance through the ZMI\n- catching some low-level exceptions from the sqlite interface in order to\n  make it work with SQLite\n- new properties 'transactional' and 'quoting_style'\n- improved support for Oracle and MySQL\n- SQLAlchemyDA no longer provides access to mapper related functionalities.\n  It now acts as a DA for executing SQL statements *only*.\n- fixed unregistration code for a wrapper (hopefully works with Zope 2.8 or\n  higher)\n\n- updated documentation\n\n0.2.1 (2007-05-06)\n------------------\n\n- connections can be closed/opened through the ZMI\n- some code cleanup\n- fixed a *very* stupid typo causing ZODB conflict errors\n\n0.2.0 (2007-05-05)\n------------------\n\n- first public release\n\n0.1.0 (2007-04-30)\n------------------\n\n- initial coding\n", "\"\"\"\nA DA-like integration of SQLAlchemy based on z3c.sqlalchemy\n\n(C) Zope Corporation and Contributors\nWritten by Andreas Jung for Haufe Mediengruppe, Freiburg, Germany\nand ZOPYX Ltd. & Co. KG, Tuebingen, Germany\n\"\"\"\n\nimport logging\nimport random\nimport time\nimport warnings\n\nfrom AccessControl import ClassSecurityInfo\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.Permissions import change_database_connections\nfrom AccessControl.Permissions import view_management_screens\nfrom OFS.PropertyManager import PropertyManager\nfrom OFS.SimpleItem import SimpleItem\nfrom Products.PageTemplates.PageTemplateFile import PageTemplateFile\nfrom zope.component import getGlobalSiteManager\n\nfrom z3c.sqlalchemy import createSAWrapper\nfrom z3c.sqlalchemy import getSAWrapper\nfrom z3c.sqlalchemy.interfaces import ISQLAlchemyWrapper\nfrom zope.sqlalchemy import mark_changed\n\n\nlogger = logging.getLogger('SQLAlchemyDA')\n\n# maps Python DB-API types to Zope types\ntypes_mapping = {\n    'DATE': 'd',\n    'TIME': 'd',\n    'DATETIME': 'd',\n    'STRING': 's',\n    'LONGINTEGER': 'i',\n    'INTEGER': 'i',\n    'NUMBER': 'n',\n    'BOOLEAN': 'n',\n    'ROWID': 'i',\n    'BINARY': None,  # ????\n}\n\n\n# Global registry of named Zope SQLAlchemyDA instances created to\n# work around unique anonymous/random names assigned to such wrappers\n# by the legacy DA code\n_wrapper_registry = {}\n\n\ndef register_sa_wrapper(name, wrapper):\n    \"\"\"\n    Register an SQLAlchemy `ZopeWrapper` database adapter by name as part of a\n    module level dict.\n\n    Args:\n        name(str): a globally unique name for the given `da_instance`). This\n                   is generally a Zope object id, automatically registered when\n                   instances of `SAWrapper` are initialized.  If this name is\n                   not unique, the most recently registered name will take\n                   effect. This registration API is not designed to be used\n                   with multiple `SAWrapper` instances sharing the same Zope\n                   object ids. An error will not be raised, to prevent problems\n                   for the majority of users who don't make use of this\n                   registration API (and use Acquisition instead).\n        wrapper(`SAWrapper`): a configured instance of\n                              `z3c.sqlalchemy.ZopeWrapper`\n\n    This might be called early in Zope startup, so this type of registration is\n    necessary instead of a zope.component registration.  (The same reason\n    z3c.sqlalchemy claims for using a module dict for registration)\n\n    Returns:\n        None\n    \"\"\"\n    _wrapper_registry[name] = wrapper\n\n\ndef deregister_sa_wrapper(name):\n    \"\"\"\n    Remove a named `SAWrapper` instance from the DA registry, if it exists.\n    Either way, the return value is None.\n    \"\"\"\n    _wrapper_registry.pop(name, None)\n\n\ndef lookup_sa_wrapper(name):\n    \"\"\"\n    Look up and return an `z3c.sqlalchemy.ZopeWrapper` instance registered by\n    name.\n\n    These instances are registered by the `SAWrapper` during initialization\n    of `ZopeWrapper` instances.\n\n    Returns:\n        'SAWrapper' instance.\n    \"\"\"\n    da = _wrapper_registry.get(name)\n    if not da:\n        raise LookupError(\"No SAWrapper instance registered under name \"\n                          + name)\n    return da\n\n\ndef clear_sa_wrapper_registry():\n    \"\"\"\n    Completely empty out the registry of `SAWrapper` instances.\n    \"\"\"\n    global _wrapper_registry\n    _wrapper_registry = {}\n\n\nclass SAWrapper(SimpleItem, PropertyManager):\n\n    \"\"\" A shim around z3c.sqlalchemy implementing something DA-ish \"\"\"\n\n    # MISSING document any special DA-ish hooks or places where Zope\n    #         automatically makes calls, or at least link to docs on\n    #         what makes it DA-ish. Is there a documented protocol?\n\n    manage_options = (({'label': 'Info', 'action': 'manage_workspace'},) +\n                      ({'label': 'Test', 'action': 'manage_test'},) +\n                      PropertyManager.manage_options +\n                      SimpleItem.manage_options)\n    _properties = (\n        {'id': 'dsn', 'type': 'string', 'mode': 'rw', },\n        {'id': 'title', 'type': 'string', 'mode': 'rw'},\n        {'id': 'encoding', 'type': 'string', 'mode': 'rw'},\n        {'id': 'transactional', 'type': 'boolean', 'mode': 'rw'},\n        {'id': 'convert_unicode', 'type': 'boolean', 'mode': 'rw'},\n        {'id': 'quoting_style', 'type': 'selection', 'mode': 'rw',\n               'select_variable': 'allQuotingStyles'},\n    )\n\n    meta_type = 'SQLAlchemyDA '\n    dsn = ''\n    encoding = 'iso-8859-15'\n    convert_unicode = 0\n    transactional = True\n    quoting_style = 'standard'\n    _isAnSQLConnection = True\n    extra_engine_options = ()\n    zmi_icon = 'fas fa-database'\n    zmi_show_add_dialog = False\n\n    security = ClassSecurityInfo()\n\n    def __init__(self, id, title=''):\n        self.id = id\n        self.title = title\n\n    def __setstate__(self, *args, **kwargs):\n        \"\"\"\n        When an instance of SAWrapper is unpickled, perform the normal\n        'wakeup', but also ensure that the instance is in the module\n        registry of instances.\n        \"\"\"\n        # Don't use 'super' when old-style classes are involved.\n        SimpleItem.__setstate__(self, *args, **kwargs)\n        wrapper = self.sa_zope_wrapper()\n        if wrapper:\n            register_sa_wrapper(self.id, wrapper)\n\n    def manage_afterAdd(self, item, container):\n        \"\"\" Ensure that a new utility id is assigned after creating\n            or copying an instance.\n        \"\"\"\n        self._new_utilid()\n        wrapper = self.sa_zope_wrapper()\n        if wrapper:\n            register_sa_wrapper(self.id, wrapper)\n        return SimpleItem.manage_afterAdd(self, item, container)\n\n    def _new_utilid(self):\n        \"\"\" Assign a new unique utility ID \"\"\"\n        self.util_id = f'{time.time()}.{random.random()}'\n\n    def allQuotingStyles(self):\n        return ('standard', 'no-quote')\n\n    @property\n    def _wrapper(self):\n        \"\"\"\n        Legacy API for accessing the underlying z3c.sqlalchemy `ZopeWrapper`.\n\n        This API should no longer be used because:\n\n            1. Python property decorators can interfere with acquisition\n               context\n            2. It's not really private so is misnamed.\n\n        Instead use self.sa_zope_wrapper\n        \"\"\"\n        # can't use deprecation decorator, due to interference with\n        # acquisition context\n        warnings.warn(\"SAWrapper._wrapper deprecated, use \"\n                      \"SAWrapper.sa_zope_wrapper() instead\",\n                      DeprecationWarning,\n                      stacklevel=2)\n        return self.sa_zope_wrapper()\n\n    def sa_zope_wrapper(self):\n        \"\"\"\n        Public API for accessing the underlying z3c.sqlalchemy `ZopeWrapper`.\n\n        The first attempt will be to lookup the wrapper via attributes\n        accessible in the Zope context (self.util_id); if it does not exist,\n        the wrapper will be created and return.\n\n        If Zope acquisition context has been lost, fall back to the module\n        dict registration mechanism (which might not always be available\n        very early in the startup process, but should be available most\n        other times).\n        \"\"\"\n        wrapper = self._supply_z3c_sa_wrapper()\n        if wrapper is not None:\n            return wrapper\n        else:\n            # we've got trouble; log relevant info and fallback on module\n            # dict registration\n            selftype = type(self)\n            try:\n                # don't reveal DSN contents in a log file\n                dsn = 'nonempty' if self.dsn else self.dsn\n            except AttributeError:\n                dsn = 'AttributeError'\n            try:\n                util_id = self.util_id\n            except AttributeError:\n                util_id = 'AttributeError'\n            msg = (\"SAWrapper failed to get a handle to live connection.\\n\"\n                   \"Did we lose Acquisition context? type(self) is %s.\\n\"\n                   \"The self.dsn is '%s' and self.util_id is '%s'.\")\n            logger.exception(msg, selftype, dsn, util_id)\n            # Now that we've logged what we need, try recovering by using\n            # the module dict lookup.\n            try:\n                return lookup_sa_wrapper(self.id)\n            except LookupError:\n                # no such luck\n                return None\n\n    def _supply_z3c_sa_wrapper(self):\n        \"\"\"\n        Look up or create the underlying z3c.sqlalchemy `ZopeWrapper`.\n        \"\"\"\n        if not self.dsn:\n            return None\n        else:\n            try:\n                wrapper = getSAWrapper(self.util_id)\n            except ValueError:\n                try:\n                    if self.util_id is None:\n                        # the z3c.sqlalchemy registration doesn't register\n                        # None values of util_id; we need something that\n                        # will stick.\n                        self._new_utilid()\n                    wrapper = createSAWrapper(\n                        self.dsn,\n                        forZope=True,\n                        transactional=self.transactional,\n                        extension_options={'initial_state': 'invalidated'},\n                        engine_options=self.engine_options,\n                        name=self.util_id)\n                    register_sa_wrapper(self.id, wrapper)\n                except ValueError as e:\n                    # ...weird...could this be a timing issue during startup?\n                    # We've seen log messages that look like this:\n                    # \"ValueError: SAWrapper '1435583419.58.0.991532919015'\n                    # already registered. You can not register a wrapper\n                    # twice under the same name.\"\n                    # This makes little sense because we just tried a lookup\n                    # under that name and did not find it. Wrapper did not\n                    # exist in component registry, but did exist in the\n                    # z3c.sqlalchemy registeredWrappers dict registry. Try\n                    # recovering by using the module dict lookup.\n                    msg = \"Unexpected failure to create SAWrapper: \" + str(e)\n                    logger.warning(msg)\n                    try:\n                        wrapper = getSAWrapper(self.util_id)\n                    except LookupError as e:\n                        msg = (\"SAWrapper lookup falling back to SQLAlchemyDA \"\n                               \" registry:\" + str(e))\n                        logger.warning(msg)\n                        wrapper = lookup_sa_wrapper(self.id)\n                    except Exception:\n                        msg = \"No z3c.sqlalchemy ZopeWrapper found or created!\"\n                        logger.exception(msg)\n                        wrapper = None\n        return wrapper\n\n    @property\n    def engine_options(self):\n        engine_options = dict(self.extra_engine_options)\n        return engine_options\n\n    @security.protected(change_database_connections)\n    def add_extra_engine_options(self, engine_options):\n        \"\"\" engine_options is a tuple containing additional\n            options for sqlalchemy.create_engine.\n            Say you need to pass some engine options\n            to SQLAlchemy.create_engine::\n            wrapper = SAWrapper(id)\n            wrapper.add_extra_engine_options((('echo', True),\n                                              ('pool_size', 20)))\n        \"\"\"\n        self.extra_engine_options = engine_options\n\n    @security.protected(view_management_screens)\n    def getInfo(self):\n        \"\"\" return a dict with additional information \"\"\"\n        wrapper = self.sa_zope_wrapper()\n        if wrapper is not None:\n            d = self.sa_zope_wrapper().__dict__.copy()\n            d['DSN'] = self.sa_zope_wrapper().dsn\n            for k in list(d.keys()):\n                if k.startswith('_'):\n                    del d[k]\n            return d\n        else:\n            return {}\n\n    def _typesMap(self, proxy):\n        \"\"\" Obtain types map from the underlying DB-API. I hope\n            that is portable code.\n        \"\"\"\n\n        if not hasattr(self, '_v_types_map'):\n            dbapi = self.sa_zope_wrapper().engine.dialect.dbapi\n\n            map = dict()\n            for name in types_mapping.keys():\n                type_obj = getattr(dbapi, name, None)\n                if type_obj:\n                    if hasattr(type_obj, 'values'):\n                        for v in type_obj.values:\n                            map[v] = name\n                    else:\n                        try:\n                            for v in type_obj:\n                                map[v] = name\n                        except TypeError:\n                            # ATT: fix this:->\n                            pass\n\n            self._v_types_map = map\n        return self._v_types_map\n\n    @security.private\n    def query(self, query_string, max_rows=None, query_data=None):\n        \"\"\" *The* query() method as used by the internal ZSQL\n            machinery.\n        \"\"\"\n        mark_changed(self.sa_zope_wrapper().session)\n        conn = self.sa_zope_wrapper().connection\n        cursor = conn.cursor()\n\n        rows = []\n        desc = None\n        nselects = 0\n\n        ts_start = time.time()\n\n        for qs in [x for x in query_string.split('\\0') if x]:\n\n            logger.debug(qs)\n            if query_data:\n                proxy = cursor.execute(qs, query_data)\n            else:\n                proxy = cursor.execute(qs)\n\n            description = cursor.description\n\n            if description is not None:\n                nselects += 1\n\n                if nselects > 1:\n                    raise ValueError(\"Can't execute multiple SELECTs \"\n                                     \"within a single query\")\n\n                if max_rows:\n                    rows = cursor.fetchmany(max_rows)\n                else:\n                    rows = cursor.fetchall()\n\n                desc = description\n                types_map = self._typesMap(proxy)\n\n        logger.debug('Execution time: %3.3f seconds' %\n                     (time.time() - ts_start))\n\n        if desc is None:\n            return (), ()\n\n        items = []\n        for (name,\n             type_code,\n             width,\n             internal_size,\n             precision,\n             scale,\n             null_ok) in desc:\n\n            items.append({\n                'name': name,\n                'type': types_mapping.get(types_map.get(type_code, None), 's'),\n                'null': null_ok,\n                'width': width, })\n\n        return items, rows\n\n    def __call__(self, *args, **kv):\n        return self\n\n    def sql_quote__(self, s):\n        if self.quoting_style == 'standard':\n            if \"\\'\" in s:\n                s = \"''\".join(s.split(\"\\'\"))\n            return \"'%s'\" % s\n        else:\n            return s\n\n    @security.protected(view_management_screens)\n    def connected(self):\n        try:\n            return self.sa_zope_wrapper()._engine.pool.checkedin() > 0\n        except Exception:\n            return 'n/a'\n\n    @security.protected(view_management_screens)\n    def getPoolSize(self):\n        \"\"\" \"\"\"\n        return self.sa_zope_wrapper()._engine.pool.size()\n\n    @security.protected(view_management_screens)\n    def getCheckedin(self):\n        \"\"\" \"\"\"\n        try:\n            return self.sa_zope_wrapper()._engine.pool.checkedin()\n        except Exception:\n            return 'n/a'\n\n    @security.protected(view_management_screens)\n    def manage_start(self, RESPONSE=None):\n        \"\"\" start engine \"\"\"\n        url = '%s/manage_workspace?manage_tabs_message=%s'\n        try:\n            self.query('COMMIT')\n            if RESPONSE:\n                msg = 'Database connection opened'\n                RESPONSE.redirect(url % (self.absolute_url(), msg))\n        except Exception as e:\n            if RESPONSE:\n                msg = 'Database connection could not be opened (%s)' % e\n                RESPONSE.redirect(url % (self.absolute_url(), msg))\n            else:\n                raise\n\n    @security.protected(view_management_screens)\n    def manage_stop(self, RESPONSE=None):\n        \"\"\" close engine \"\"\"\n        self.sa_zope_wrapper()._engine.pool.dispose()\n        if RESPONSE:\n            msg = 'Database connections closed'\n            RESPONSE.redirect(self.absolute_url() +\n                              '/manage_workspace?manage_tabs_message=%s' % msg)\n\n    @security.protected(view_management_screens)\n    def manage_doQuery(self, query):\n        \"\"\" perform a query through the ZMI\"\"\"\n        return self.query(query)\n\n    @security.protected(view_management_screens)\n    def manage_formatItem(self, s):\n        \"\"\" used by query form \"\"\"\n        if isinstance(s, str):\n            return s\n        if isinstance(s, bytes):\n            return s.decode(self.encoding, 'ignore')\n        return str(s)\n\n    @security.protected(view_management_screens)\n    def manage_editProperties(self, REQUEST):\n        \"\"\" Intercept changed properties in order to perform\n            further actions.\n        \"\"\"\n        gsm = getGlobalSiteManager()\n        gsm.unregisterUtility(provided=ISQLAlchemyWrapper, name=self.util_id)\n        self._new_utilid()\n\n        return super().manage_editProperties(REQUEST)\n\n    manage_workspace = PageTemplateFile('pt/info', globals(),\n                                        __name__='manage_workspace')\n    manage_test = PageTemplateFile('pt/query', globals(),\n                                   __name__='manage_test')\n\n\nInitializeClass(SAWrapper)\n\n\ndef manage_addSAWrapper(self, id, dsn, title, encoding='iso-8859-15',\n                        convert_unicode=0, RESPONSE=None):\n    \"\"\" create a new SAWrapper instance \"\"\"\n    wrapper = SAWrapper(id, title)\n    wrapper.dsn = dsn\n    wrapper.convert_unicode = convert_unicode\n    wrapper.encoding = encoding\n    # this will call manage_afterAdd\n    self._setObject(id, wrapper.__of__(self))\n    if RESPONSE:\n        return RESPONSE.redirect(self._getOb(id).absolute_url()\n                                 + '/manage_workspace')\n    else:\n        return wrapper\n\n\nmanage_addSAWrapperForm = PageTemplateFile('pt/addSAWrapperForm',\n                                           globals(),\n                                           __name__='addSAWrapperForm')\n"], "filenames": ["CHANGES.rst", "src/Products/SQLAlchemyDA/da.py"], "buggy_code_start_loc": [5, 15], "buggy_code_end_loc": [5, 348], "fixing_code_start_loc": [6, 16], "fixing_code_end_loc": [9, 352], "type": "CWE-89", "message": "SQLAlchemyDA is a generic database adapter for ZSQL methods. A vulnerability found in versions prior to 2.2 allows unauthenticated execution of arbitrary SQL statements on the database to which the SQLAlchemyDA instance is connected. All users are affected. The problem has been patched in version 2.2. There is no workaround for the problem.", "other": {"cve": {"id": "CVE-2024-24811", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-07T15:15:08.507", "lastModified": "2024-02-14T20:26:39.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQLAlchemyDA is a generic database adapter for ZSQL methods. A vulnerability found in versions prior to 2.2 allows unauthenticated execution of arbitrary SQL statements on the database to which the SQLAlchemyDA instance is connected. All users are affected. The problem has been patched in version 2.2. There is no workaround for the problem."}, {"lang": "es", "value": "SQLAlchemyDA es un adaptador de base de datos gen\u00e9rico para m\u00e9todos ZSQL. Una vulnerabilidad encontrada en versiones anteriores a la 2.2 permite la ejecuci\u00f3n no autenticada de sentencias SQL arbitrarias en la base de datos a la que est\u00e1 conectada la instancia de SQLAlchemyDA. Todos los usuarios se ven afectados. El problema se solucion\u00f3 en la versi\u00f3n 2.2. No existe ning\u00fan workaround para el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zope:sqlalchemyda:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2", "matchCriteriaId": "26CB0366-8070-4564-8D4B-285BE5CB4C96"}]}]}], "references": [{"url": "https://github.com/zopefoundation/Products.SQLAlchemyDA/commit/e682b99f8406f20bc3f0f2c77153ed7345fd215a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zopefoundation/Products.SQLAlchemyDA/security/advisories/GHSA-r3jc-3qmm-w3pw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zopefoundation/Products.SQLAlchemyDA/commit/e682b99f8406f20bc3f0f2c77153ed7345fd215a"}}