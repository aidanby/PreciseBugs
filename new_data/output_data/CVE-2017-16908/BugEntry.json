{"buggy_code": ["/**\n * kronolith.js - Base application logic.\n *\n * TODO: loadingImg()\n *\n * Copyright 2008-2017 Horde LLC (http://www.horde.org/)\n *\n * See the enclosed file COPYING for license information (GPL). If you\n * did not receive this file, see http://www.horde.org/licenses/gpl.\n *\n * @author Jan Schneider <jan@horde.org>\n */\n\n/* Kronolith object. */\nKronolithCore = {\n    // Vars used and defaulting to null/false:\n    //   weekSizes, daySizes,\n    //   groupLoading, colorPicker, duration, timeMarker, monthDays,\n    //   allDays, eventsWeek, initialized\n\n    view: '',\n    ecache: $H(),\n    cacheStart: null,\n    cacheEnd: null,\n    holidays: [],\n    tcache: $H(),\n    eventsLoading: {},\n    loading: 0,\n    viewLoading: [],\n    fbLoading: 0,\n    redBoxLoading: false,\n    date: Date.today(),\n    tasktype: 'incomplete',\n    knl: {},\n    wrongFormat: $H(),\n    mapMarker: null,\n    map: null,\n    mapInitialized: false,\n    freeBusy: $H(),\n    search: 'future',\n    effectDur: 0.4,\n    macos: navigator.appVersion.indexOf('Mac') != -1,\n    orstart: null,\n    orend: null,\n    lastRecurType: 'None',\n    uatts: null,\n    ucb: null,\n    resourceACCache: { choices: [], map: $H() },\n    paramsCache: null,\n    attendees: [],\n    resources: [],\n\n    /**\n     * Flag that indicates if the event currently displayed in the event\n     * properties window is a recurring event.\n     *\n     * @type boolean\n     */\n    recurs: false,\n\n    /**\n     * The location that was open before the current location.\n     *\n     * @var string\n     */\n    lastLocation: '',\n\n    /**\n     * The currently open location.\n     *\n     * @var string\n     */\n    openLocation: '',\n\n    /**\n     * The current (main) location.\n     *\n     * This is different from openLocation as it isn't updated for any\n     * locations that are opened in a popup view, e.g. events.\n     *\n     * @var string\n     */\n    currentLocation: '',\n\n    kronolithBody: $('kronolithBody'),\n\n    onException: function(parentfunc, r, e)\n    {\n        /* Make sure loading images are closed. */\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n        this.closeRedBox();\n        HordeCore.notify(HordeCore.text.ajax_error, 'horde.error');\n        parentfunc(r, e);\n    },\n\n    setTitle: function(title)\n    {\n        document.title = Kronolith.conf.name + ' :: ' + title;\n        return title;\n    },\n\n    // url = (string) URL to redirect to\n    // hash = (boolean) If true, url is treated as hash information to alter\n    //        on the current page\n    redirect: function(url, hash)\n    {\n        if (hash) {\n            window.location.hash = escape(url);\n            window.location.reload();\n        } else {\n            HordeCore.redirect(url);\n        }\n    },\n\n    go: function(fullloc, data)\n    {\n        if (!this.initialized) {\n            this.go.bind(this, fullloc, data).defer();\n            return;\n        }\n\n        if (this.viewLoading.size()) {\n            this.viewLoading.push([ fullloc, data ]);\n            return;\n        }\n\n        var locParts = fullloc.split(':');\n        var loc = locParts.shift();\n\n        if (this.openLocation == fullloc) {\n            return;\n        }\n\n        this.viewLoading.push([ fullloc, data ]);\n\n        if (loc != 'search') {\n            HordeTopbar.searchGhost.reset();\n        }\n\n        this.switchTaskView(false);\n\n        switch (loc) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n        case 'month':\n        case 'year':\n        case 'agenda':\n        case 'tasks':\n            this.closeView(loc);\n            var locCap = loc.capitalize();\n            $('kronolithNav' + locCap).up().addClassName('horde-active');\n\n            switch (loc) {\n            case 'day':\n            case 'agenda':\n            case 'week':\n            case 'workweek':\n            case 'month':\n            case 'year':\n                var date = locParts.shift();\n                if (date) {\n                    date = this.parseDate(date);\n                } else {\n                    date = this.date;\n                }\n\n                if (this.view != 'agenda' &&\n                    this.view == loc &&\n                    date.getYear() == this.date.getYear() &&\n                    ((loc == 'year') ||\n                     (loc == 'month' && date.getMonth() == this.date.getMonth()) ||\n                     ((loc == 'week' || loc == 'workweek') && date.getRealWeek() == this.date.getRealWeek()) ||\n                     ((loc == 'day'  || loc == 'agenda') && date.dateString() == this.date.dateString()))) {\n                         this.setViewTitle(date, loc);\n                         this.addHistory(fullloc);\n                         this.loadNextView();\n                         return;\n                }\n\n                this.addHistory(fullloc);\n                this.view = loc;\n                this.date = date;\n                this.updateView(date, loc);\n                var dates = this.viewDates(date, loc);\n                this.loadEvents(dates[0], dates[1], loc);\n                $('kronolithView' + locCap).appear({\n                        duration: this.effectDur,\n                        queue: 'end',\n                        afterFinish: function() {\n                            if (loc == 'week' || loc == 'workweek' || loc == 'day') {\n                                this.calculateRowSizes(loc + 'Sizes', 'kronolithView' + locCap);\n                                if ($('kronolithTimeMarker')) {\n                                    this.positionTimeMarker();\n                                }\n                                if ($('kronolithTimeMarker')) {\n                                    $('kronolithTimeMarker').show();\n                                }\n                                // Scroll to the work day start time.\n                                $('kronolithView' + locCap).down('.kronolithViewBody').scrollTop = 9 * this[loc + 'Sizes'].height;\n                            }\n                            this.loadNextView();\n                        }.bind(this)\n                });\n                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());\n                this.updateMinical(date, loc);\n\n                break;\n\n            case 'tasks':\n                var tasktype = locParts.shift() || this.tasktype;\n\n\n                this.switchTaskView(true);\n                $('kronolithCurrent')\n                    .update(this.setTitle(Kronolith.text.tasks));\n                if (this.view == loc && this.tasktype == tasktype) {\n                    this.addHistory(fullloc);\n                    this.loadNextView();\n                    return;\n                }\n                if (!$w('all complete incomplete future').include(tasktype)) {\n                    this.loadNextView();\n                    return;\n                }\n\n                this.addHistory(fullloc);\n                this.view = loc;\n                this.tasktype = tasktype;\n                $w('All Complete Incomplete Future').each(function(tasktype) {\n                    $('kronolithTasks' + tasktype).up().removeClassName('horde-active');\n                });\n                $('kronolithTasks' + this.tasktype.capitalize()).up().addClassName('horde-active');\n                this.loadTasks(this.tasktype);\n                $('kronolithView' + locCap).appear({\n                    duration: this.effectDur,\n                    queue: 'end',\n                    afterFinish: function() {\n                        this.loadNextView();\n                    }.bind(this) });\n                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());\n                this.updateMinical(this.date);\n\n                break;\n\n            default:\n                if (!$('kronolithView' + locCap)) {\n                    break;\n                }\n                this.addHistory(fullloc);\n                this.view = loc;\n                $('kronolithView' + locCap).appear({\n                    duration: this.effectDur,\n                    queue: 'end',\n                    afterFinish: function() {\n                        this.loadNextView();\n                    }.bind(this) });\n                break;\n            }\n\n            break;\n\n        case 'search':\n            var cals = [], time = locParts[0], term = locParts[1],\n                query = Object.toJSON({ title: term });\n\n            if (!($w('all past future').include(time))) {\n                this.loadNextView();\n                return;\n            }\n\n            this.addHistory(fullloc);\n            this.search = time;\n            $w('All Past Future').each(function(time) {\n                $('kronolithSearch' + time).up().removeClassName('horde-active');\n            });\n            $('kronolithSearch' + this.search.capitalize()).up().addClassName('horde-active');\n            this.closeView('agenda');\n            this.view = 'agenda';\n            this.updateView(null, 'search', term);\n            $H(Kronolith.conf.calendars).each(function(type) {\n                $H(type.value).each(function(calendar) {\n                    if (calendar.value.show) {\n                        cals.push(type.key + '|' + calendar.key);\n                    }\n                });\n            });\n            $('kronolithAgendaNoItems').hide();\n            this.startLoading('search', query);\n\n            HordeCore.doAction('searchEvents', {\n                cals: Object.toJSON(cals),\n                query: query,\n                time: this.search\n            }, {\n                callback: function(r) {\n                    // Hide spinner.\n                    this.loading--;\n                    if (!this.loading) {\n                        $('kronolithLoading').hide();\n                    }\n                    if (r.view != 'search' ||\n                        r.query != this.eventsLoading.search) {\n                        return;\n                    }\n                    if (Object.isUndefined(r.events)) {\n                        $('kronolithAgendaNoItems').show();\n                        return;\n                    }\n                    delete this.eventsLoading.search;\n                    $H(r.events).each(function(calendars) {\n                        $H(calendars.value).each(function(events) {\n                            this.createAgendaDay(events.key);\n                            $H(events.value).each(function(event) {\n                                event.value.calendar = calendars.key;\n                                event.value.start = Date.parse(event.value.s);\n                                event.value.end = Date.parse(event.value.e);\n                                this.insertEvent(event, events.key, 'agenda');\n                            }, this);\n                        }, this);\n                    }, this);\n                }.bind(this)\n            });\n\n            $('kronolithViewAgenda').appear({\n                duration: this.effectDur,\n                queue: 'end',\n                afterFinish: function() {\n                    this.loadNextView();\n                }.bind(this) });\n            $('kronolithLoadingagenda').insert($('kronolithLoading').remove());\n            this.updateMinical(this.date);\n            break;\n\n        case 'event':\n            // Load view first if necessary.\n            if (!this.view ) {\n                this.viewLoading.pop();\n                this.go(Kronolith.conf.login_view);\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n\n            if (this.currentLocation == fullloc) {\n                this.loadNextView();\n                return;\n            }\n\n            this.addHistory(fullloc, false);\n            switch (locParts.length) {\n            case 0:\n                // New event.\n                this.editEvent();\n                break;\n            case 1:\n                // New event on a certain date.\n                this.editEvent(null, null, locParts[0]);\n                break;\n            default:\n                // Editing event.\n                var date = locParts.pop(),\n                    event = locParts.pop(),\n                    calendar = locParts.join(':');\n                this.editEvent(calendar, event, date);\n                break;\n            }\n            this.loadNextView();\n            break;\n\n        case 'task':\n            // Load view first if necessary.\n            if (!this.view ) {\n                this.viewLoading.pop();\n                this.go('tasks');\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n\n            this.switchTaskView(true);\n            switch (locParts.length) {\n            case 0:\n                this.addHistory(fullloc, false);\n                this.editTask();\n                break;\n            case 2:\n                this.addHistory(fullloc, false);\n                this.editTask(locParts[0], locParts[1]);\n                break;\n            }\n            this.loadNextView();\n            break;\n\n        case 'calendar':\n            if (!this.view) {\n                this.viewLoading.pop();\n                this.go(Kronolith.conf.login_view);\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n            this.addHistory(fullloc, false);\n            this.editCalendar(locParts.join(':'));\n            this.loadNextView();\n            break;\n\n        default:\n            this.loadNextView();\n            break;\n        }\n    },\n\n    /**\n     * Removes the last loaded view from the stack and loads the last added\n     * view, if the stack is still not empty.\n     *\n     * We want to load views from a LIFO queue, because the queue is only\n     * building up if the user switches to another view while the current view\n     * still loads. In that case we can go directly to the most recently\n     * clicked view and drop the remaining queue.\n     */\n    loadNextView: function()\n    {\n        var current = this.viewLoading.shift();\n        if (this.viewLoading.size()) {\n            var next = this.viewLoading.pop();\n            this.viewLoading = [];\n            if (current[0] != next[0] || current[1] || next[1]) {\n                this.go(next[0], next[1]);\n            }\n        }\n    },\n\n    /**\n     * Rebuilds one of the calendar views for a new date.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's rebuilt.\n     * @param mixed data   Any additional data that might be required.\n     */\n    updateView: function(date, view, data)\n    {\n        this.holidays = [];\n\n        switch (view) {\n        case 'day':\n            var today = Date.today();\n            this.dayEvents = [];\n            this.dayGroups = [];\n            this.allDayEvents = [];\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n            $('kronolithViewDay')\n                .down('.kronolithAllDayContainer')\n                .store('date', date.dateString());\n            $('kronolithEventsDay').store('date', date.dateString());\n            if (date.equals(today)) {\n                this.addTimeMarker('kronolithEventsDay');\n            }\n            break;\n\n        case 'week':\n        case 'workweek':\n            this.dayEvents = [];\n            this.dayGroups = [];\n            this.allDayEvents = [];\n            this.allDays = {};\n            this.eventsWeek = {};\n            var what = view == 'week' ? 'Week' : 'Workweek',\n                div = $('kronolithEvents' + what).down('div'),\n                th = $('kronolithView' + what + 'Head').down('.kronolithWeekDay'),\n                td = $('kronolithView' + what + 'Head').down('tbody td').next('td'),\n                hourRow = $('kronolithView' + what + 'Body').down('tr'),\n                dates = this.viewDates(date, view),\n                today = Date.today(),\n                day, dateString, i, hourCol;\n\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n\n            for (i = 0; i < 24; i++) {\n                day = dates[0].clone();\n                hourCol = hourRow.down('td').next('td');\n                while (hourCol) {\n                    hourCol.removeClassName('kronolith-today');\n                    if (day.equals(today)) {\n                        hourCol.addClassName('kronolith-today');\n                    }\n                    hourCol = hourCol.next('td');\n                    day.next().day();\n                }\n                hourRow = hourRow.next('tr');\n            }\n            day = dates[0].clone();\n\n            for (i = 0; i < (view == 'week' ? 7 : 5); i++) {\n                dateString = day.dateString();\n                this.allDays['kronolithAllDay' + dateString] = td.down('div');\n                this.eventsWeek['kronolithEvents' + what + dateString] = div;\n                div.store('date', dateString)\n                    .writeAttribute('id', 'kronolithEvents' + what + dateString);\n                th.store('date', dateString)\n                    .down('span').update(day.toString('dddd, d'));\n                td.removeClassName('kronolith-today');\n                this.allDays['kronolithAllDay' + dateString]\n                    .writeAttribute('id', 'kronolithAllDay' + dateString)\n                    .store('date', dateString);\n                if (day.equals(today)) {\n                    td.addClassName('kronolith-today');\n                    this.addTimeMarker('kronolithEvents' + what + dateString);\n                }\n                new Drop(td.down('div'));\n                div = div.next('div');\n                th = th.next('td');\n                td = td.next('td');\n                day.next().day();\n            }\n            break;\n\n        case 'month':\n            var tbody = $('kronolith-month-body'),\n                dates = this.viewDates(date, view),\n                day = dates[0].clone();\n\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n\n            // Remove old rows. Maybe we should only rebuild the calendars if\n            // necessary.\n            tbody.childElements().each(function(row) {\n                if (row.identify() != 'kronolithRowTemplate') {\n                    row.purge();\n                    row.remove();\n                }\n            });\n\n            // Build new calendar view.\n            this.monthDays = {};\n            while (!day.isAfter(dates[1])) {\n                tbody.insert(this.createWeekRow(day, date.getMonth(), dates).show());\n                day.next().week();\n            }\n            this.equalRowHeights(tbody);\n\n            break;\n\n        case 'year':\n            var month;\n\n            $('kronolithCurrent').update(this.setViewTitle(date, view, data));\n\n            // Build new calendar view.\n            for (month = 0; month < 12; month++) {\n                $('kronolithYear' + month).update(this.createYearMonth(date.getFullYear(), month, 'kronolithYear').show());\n            }\n\n            break;\n\n        case 'agenda':\n        case 'search':\n            // Agenda days are only created on demand, if there are any events\n            // to add.\n            if (view == 'agenda') {\n                var dates = this.viewDates(date, view);\n                $('kronolithCurrent')\n                    .update(this.setViewTitle(date, view, data));\n                $('kronolithSearchNavigation').up().up().hide();\n            } else {\n                $('kronolithCurrent')\n                    .update(this.setViewTitle(date, view, data));\n                $('kronolithSearchNavigation').up().up().show();\n            }\n\n            // Remove old rows. Maybe we should only rebuild the calendars if\n            // necessary.\n            tbody = $('kronolithViewAgendaBody').childElements().each(function(row) {\n                if (row.identify() != 'kronolithAgendaTemplate' &&\n                    row.identify() != 'kronolithAgendaNoItems') {\n                    row.purge();\n                    row.remove();\n                }\n            });\n\n            break;\n        }\n    },\n\n    /**\n     * Sets the browser title of the calendar views.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's displayed.\n     * @param mixed data   Any additional data that might be required.\n     */\n    setViewTitle: function(date, view, data)\n    {\n        switch (view) {\n        case 'day':\n            return this.setTitle(date.toString('D'));\n\n        case 'week':\n        case 'workweek':\n            var dates = this.viewDates(date, view);\n            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));\n\n        case 'month':\n            return this.setTitle(date.toString('MMMM yyyy'));\n\n        case 'year':\n            return this.setTitle(date.toString('yyyy'));\n\n        case 'agenda':\n            var dates = this.viewDates(date, view);\n            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));\n\n        case 'search':\n            return this.setTitle(Kronolith.text.searching.interpolate({ term: data })).escapeHTML();\n        }\n    },\n\n    /**\n     * Closes the currently active view.\n     */\n    closeView: function(loc)\n    {\n        $w('Day Workweek Week Month Year Tasks Agenda').each(function(a) {\n            a = $('kronolithNav' + a);\n            if (a) {\n                a.up().removeClassName('horde-active');\n            }\n        });\n        if (this.view && this.view != loc) {\n            $('kronolithView' + this.view.capitalize()).fade({\n                duration: this.effectDur,\n                queue: 'end'\n            });\n            this.view = null;\n        }\n    },\n\n    /**\n     * Creates a single row of day cells for usage in the month and multi-week\n     * views.\n     *\n     * @param Date date        The first day to show in the row.\n     * @param integer month    The current month. Days not from the current\n     *                         month get the kronolith-other-month CSS class\n     *                         assigned.\n     * @param array viewDates  Array of Date objects with the start and end\n     *                         dates of the view.\n     *\n     * @return Element  The element rendering a week row.\n     */\n    createWeekRow: function(date, month, viewDates)\n    {\n        var day = date.clone(), today = new Date().dateString(),\n            row, cell, dateString;\n\n        // Create a copy of the row template.\n        row = $('kronolithRowTemplate').clone(true);\n        row.removeAttribute('id');\n\n        // Fill week number and day cells.\n        cell = row.down()\n            .setText(date.getRealWeek())\n            .store('date', date.dateString())\n            .next();\n        while (cell) {\n            dateString = day.dateString();\n            this.monthDays['kronolithMonthDay' + dateString] = cell;\n            cell.id = 'kronolithMonthDay' + dateString;\n            cell.store('date', dateString);\n            cell.removeClassName('kronolith-other-month').removeClassName('kronolith-today');\n            if (day.getMonth() != month) {\n                cell.addClassName('kronolith-other-month');\n            }\n            if (dateString == today) {\n                cell.addClassName('kronolith-today');\n            }\n            new Drop(cell);\n            cell.store('date', dateString)\n                .down('.kronolith-day')\n                .store('date', dateString)\n                .update(day.getDate());\n\n            cell = cell.next();\n            day.add(1).day();\n        }\n\n        return row;\n    },\n\n    /**\n     * Creates a table row for a single day in the agenda view, if it doesn't\n     * exist yet.\n     *\n     * @param string date    The day to show in the row.\n     *\n     * @return Element  The element rendering a week row.\n     */\n    createAgendaDay: function(date)\n    {\n        // Exit if row exists already.\n        if ($('kronolithAgendaDay' + date)) {\n            return;\n        }\n\n        // Create a copy of the row template.\n        var body = $('kronolithViewAgendaBody'),\n            row = $('kronolithAgendaTemplate').clone(true);\n\n        // Fill week number and day cells.\n        row.store('date', date)\n            .down()\n            .setText(this.parseDate(date).toString('D'))\n            .next()\n            .writeAttribute('id', 'kronolithAgendaDay' + date);\n        row.removeAttribute('id');\n\n        // Insert row.\n        var nextRow;\n        body.childElements().each(function(elm) {\n            if (elm.retrieve('date') > date) {\n                nextRow = elm;\n                throw $break;\n            }\n        });\n        if (nextRow) {\n            nextRow.insert({ before: row.show() });\n        } else {\n            body.insert(row.show());\n        }\n\n        return row;\n    },\n\n    /**\n     * Creates a table for a single month in the year view.\n     *\n     * @param integer year     The year.\n     * @param integer month    The month.\n     * @param string idPrefix  If present, each day will get a DOM ID with this\n     *                         prefix\n     *\n     * @return Element  The element rendering a month table.\n     */\n    createYearMonth: function(year, month, idPrefix)\n    {\n        // Create a copy of the month template.\n        var table = $('kronolithYearTemplate').clone(true),\n            tbody = table.down('tbody');\n        table.removeAttribute('id');\n        tbody.writeAttribute('id', 'kronolithYearTable' + month);\n\n        // Set month name.\n        table.down('tr.kronolith-minical-nav th')\n            .store('date', year.toPaddedString(4) + (month + 1).toPaddedString(2) + '01')\n            .update(Date.CultureInfo.monthNames[month]);\n\n        // Build month table.\n        this.buildMinical(tbody, new Date(year, month, 1), null, idPrefix, year);\n\n        return table;\n    },\n\n    equalRowHeights: function(tbody)\n    {\n        var children = tbody.childElements();\n        children.invoke('setStyle', { height: (100 / (children.size() - 1)) + '%' });\n    },\n\n    /**\n     * Calculates some dimensions for the day and week view.\n     *\n     * @param string storage  Property name where the dimensions are stored.\n     * @param string view     DOM node ID of the view.\n     */\n    calculateRowSizes: function(storage, view)\n    {\n        if (!Object.isUndefined(this[storage])) {\n            return;\n        }\n\n        var td = $(view).down('.kronolithViewBody tr td').next('td'),\n            layout = td.getLayout(),\n            spacing = td.up('table').getStyle('borderSpacing');\n\n        // FIXME: spacing is hardcoded for IE 7 because it doesn't know about\n        // border-spacing, but still uses it. WTF?\n        spacing = spacing ? parseInt($w(spacing)[1], 10) : 2;\n        this[storage] = {};\n        this[storage].height = layout.get('margin-box-height') + spacing;\n        this[storage].spacing = this[storage].height - layout.get('padding-box-height') - layout.get('border-bottom');\n    },\n\n    /**\n     * Adds a horizontal ruler representing the current time to the specified\n     * container.\n     *\n     * @param string|Element  The container of the current day.\n     */\n    addTimeMarker: function(container)\n    {\n        if ($('kronolithTimeMarker')) {\n            $('kronolithTimeMarker').remove();\n            this.timeMarker.stop();\n        }\n        $(container).insert(new Element('div', { id: 'kronolithTimeMarker' }).setStyle({ position: 'absolute' }).hide());\n        this.timeMarker = new PeriodicalExecuter(this.positionTimeMarker.bind(this), 60);\n    },\n\n    /**\n     * Updates the horizontal ruler representing the current time.\n     */\n    positionTimeMarker: function()\n    {\n        var today = Date.today(), now;\n\n        switch (this.view) {\n        case 'day':\n            if (!this.date.equals(today)) {\n                $('kronolithTimeMarker').remove();\n                this.timeMarker.stop();\n                return;\n            }\n            break;\n        case 'week':\n        case 'workweek':\n            if ($('kronolithTimeMarker').up().retrieve('date') != today.dateString()) {\n                var newContainer = this.eventsWeek['kronolithEvents' + (this.view == 'week' ? 'Week' : 'Workweek') + today.dateString()];\n                $('kronolithTimeMarker').remove();\n                if (newContainer) {\n                    this.addTimeMarker(newContainer);\n                } else {\n                    this.timeMarker.stop();\n                }\n                return;\n            }\n            break;\n        default:\n            $('kronolithTimeMarker').remove();\n            this.timeMarker.stop();\n            return;\n        }\n\n        now = new Date();\n        $('kronolithTimeMarker').setStyle({ top: ((now.getHours() * 60 + now.getMinutes()) * this[this.view + 'Sizes'].height / 60 | 0) + 'px' });\n    },\n\n    /**\n     * Rebuilds the mini calendar.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's displayed, determines which days in\n     *                     the mini calendar are highlighted.\n     */\n    updateMinical: function(date, view)\n    {\n        // Update header.\n        $('kronolithMinicalDate')\n            .store('date', date.dateString())\n            .update(date.toString('MMMM yyyy'));\n\n        this.buildMinical($('kronolith-minical').down('tbody'), date, view);\n    },\n\n    /**\n     * Creates a mini calendar suitable for the navigation calendar and the\n     * year view.\n     *\n     * @param Element tbody    The table body to add the days to.\n     * @param Date date        The date to show in the calendar.\n     * @param string view      The view that's displayed, determines which days\n     *                         in the mini calendar are highlighted.\n     * @param string idPrefix  If present, each day will get a DOM ID with this\n     *                         prefix\n     * @param integer year     If present, generating mini calendars for the\n     *                         year view of this year.\n     */\n    buildMinical: function(tbody, date, view, idPrefix, year)\n    {\n        var dates = this.viewDates(date, 'month'),\n            day = dates[0].clone(),\n            date7 = date.clone().add(1).week(),\n            today = Date.today(),\n            week = this.viewDates(this.date, 'week'),\n            workweek = this.viewDates(this.date, 'workweek'),\n            dateString, td, tr, i;\n\n        // Remove old calendar rows. Maybe we should only rebuild the minical\n        // if necessary.\n        tbody.childElements().invoke('remove');\n\n        for (i = 0; i < 42; i++) {\n            dateString = day.dateString();\n            // Create calendar row and insert week number.\n            if (day.getDay() == Kronolith.conf.week_start) {\n                tr = new Element('tr');\n                tbody.insert(tr);\n                td = new Element('td', { className: 'kronolith-minical-week' })\n                    .store('weekdate', dateString);\n                td.update(day.getRealWeek());\n                tr.insert(td);\n                weekStart = day.clone();\n                weekEnd = day.clone();\n                weekEnd.add(6).days();\n            }\n\n            // Insert day cell.\n            td = new Element('td').store('date', dateString);\n            if (day.getMonth() != date.getMonth()) {\n                td.addClassName('kronolith-other-month');\n            } else if (!Object.isUndefined(idPrefix)) {\n                td.id = idPrefix + dateString;\n            }\n\n            // Highlight days currently being displayed.\n            if (view &&\n                ((view == 'month' && this.date.between(dates[0], dates[1])) ||\n                 (view == 'week' && day.between(week[0], week[1])) ||\n                 (view == 'workweek' && day.between(workweek[0], workweek[1])) ||\n                 (view == 'day' && day.equals(this.date)) ||\n                 (view == 'agenda' && !day.isBefore(date) && day.isBefore(date7)))) {\n                td.addClassName('kronolith-selected');\n            }\n\n            // Highlight today.\n            if (day.equals(today) &&\n                (Object.isUndefined(year) ||\n                 (day.getYear() + 1900 == year &&\n                  date.getMonth() == day.getMonth()))) {\n                td.addClassName('kronolith-today');\n            }\n            td.insert(new Element('a').update(day.getDate()));\n            tr.insert(td);\n            day.next().day();\n        }\n    },\n\n    /**\n     * Inserts a calendar entry in the sidebar menu.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     * @param object cal   The calendar object.\n     * @param Element div  Container DIV where to add the entry (optional).\n     */\n    insertCalendarInList: function(type, id, cal, div)\n    {\n        var noItems, calendar, link;\n        if (!div) {\n            div = this.getCalendarList(type, cal.owner);\n        }\n        noItems = div.previous();\n        if (noItems &&\n            noItems.tagName == 'DIV' &&\n            noItems.className == 'horde-info') {\n            noItems.hide();\n        }\n        link = new Element('span', { className: type != 'resourcegroup' ? (cal.show ? 'horde-resource-on' : 'horde-resource-off') : 'horde-resource-none' })\n            .insert(cal.name.escapeHTML());\n        calendar = new Element('div')\n            .store('calendar', id)\n            .store('calendarclass', type)\n            .setStyle({ backgroundColor: cal.bg, color: cal.fg });\n        if (type != 'holiday' && type != 'external') {\n            calendar.insert(\n                new Element('span', { className: 'horde-resource-edit-' + cal.fg.substring(1) })\n                    .setStyle({ backgroundColor: cal.bg, color: cal.fg })\n                    .insert('&#9658;'));\n        }\n        calendar.insert(\n            new Element('div', { className: 'horde-resource-link' })\n                .insert(link));\n        this.addShareIcon(cal, link);\n        div.insert(calendar);\n        if (cal.show) {\n            this.addCalendarLegend(type, id, cal);\n        }\n    },\n\n    /**\n     * Add the share icon after the calendar name in the calendar list.\n     *\n     * @param object cal       A calendar object from Kronolith.conf.calendars.\n     * @param Element element  The calendar element in the list.\n     */\n    addShareIcon: function(cal, element)\n    {\n        if (cal.owner && cal.perms) {\n            $H(cal.perms).each(function(perm) {\n                if (perm.key != 'type' &&\n                    ((Object.isArray(perm.value) && perm.value.size()) ||\n                     (!Object.isArray(perm.value) && perm.value))) {\n                    element.insert(' ').insert(new Element('img', { src: Kronolith.conf.images.attendees.replace(/fff/, cal.fg.substring(1)), title: Kronolith.text.shared }));\n                    throw $break;\n                }\n            });\n        }\n    },\n\n    /**\n     * Rebuilds the list of calendars.\n     */\n    updateCalendarList: function()\n    {\n        var ext = $H(), extNames = $H(),\n            extContainer = $('kronolithExternalCalendars');\n\n        $H(Kronolith.conf.calendars.internal).each(function(cal) {\n            this.insertCalendarInList('internal', cal.key, cal.value);\n        }, this);\n\n        if (Kronolith.conf.tasks) {\n            $H(Kronolith.conf.calendars.tasklists).each(function(cal) {\n                this.insertCalendarInList('tasklists', cal.key, cal.value);\n            }, this);\n        }\n\n        if (Kronolith.conf.calendars.resource) {\n            $H(Kronolith.conf.calendars.resource).each(function(cal) {\n               this.insertCalendarInList('resource', cal.key, cal.value);\n            }, this);\n        }\n\n        if (Kronolith.conf.calendars.resourcegroup) {\n            $H(Kronolith.conf.calendars.resourcegroup).each(function(cal) {\n                this.insertCalendarInList('resourcegroup', cal.key, cal.value);\n            }, this);\n        }\n\n        $H(Kronolith.conf.calendars.external).each(function(cal) {\n            var parts = cal.key.split('/'), api = parts.shift();\n            if (!ext.get(api)) {\n                ext.set(api, $H());\n            }\n            ext.get(api).set(parts.join('/'), cal.value);\n            extNames.set(api, cal.value.api ? cal.value.api : Kronolith.text.external_category);\n        });\n        ext.each(function(api) {\n            extContainer\n                .insert(new Element('div', { className: 'horde-sidebar-split' }))\n                .insert(new Element('div')\n                        .insert(new Element('h3')\n                                .insert(new Element('span', { className: 'horde-expand', title: HordeSidebar.text.expand })\n                                        .insert({ bottom: extNames.get(api.key).escapeHTML() })))\n                        .insert(new Element('div', { id: 'kronolithExternalCalendar' + api.key, className: 'horde-resources', style: 'display:none' })));\n            api.value.each(function(cal) {\n                this.insertCalendarInList('external', api.key + '/' + cal.key, cal.value, $('kronolithExternalCalendar' + api.key));\n            }, this);\n        }, this);\n\n        $H(Kronolith.conf.calendars.remote).each(function(cal) {\n            this.insertCalendarInList('remote', cal.key, cal.value);\n        }, this);\n\n        if (Kronolith.conf.calendars.holiday) {\n            $H(Kronolith.conf.calendars.holiday).each(function(cal) {\n                if (cal.value.show) {\n                   this.insertCalendarInList('holiday', cal.key, cal.value);\n                }\n            }, this);\n        } else {\n            $('kronolithAddholiday').up().hide();\n            $('kronolithHolidayCalendars').hide();\n        }\n    },\n\n    /**\n     * Returns the DIV container that holds all calendars of a certain type.\n     *\n     * @param string type  A calendar type\n     *\n     * @return Element  The container of the calendar type.\n     */\n    getCalendarList: function(type, personal)\n    {\n        switch (type) {\n        case 'internal':\n            return personal\n                ? $('kronolithMyCalendars')\n                : $('kronolithSharedCalendars');\n        case 'resource':\n            return $('kronolithResourceCalendars');\n        case 'resourcegroup':\n            return $('kronolithResourceGroups');\n        case 'tasklists':\n            return personal\n                ? $('kronolithMyTasklists')\n                : $('kronolithSharedTasklists');\n        case 'external':\n            return $('kronolithExternalCalendars');\n        case 'remote':\n            return $('kronolithRemoteCalendars');\n        case 'holiday':\n            return $('kronolithHolidayCalendars');\n        }\n    },\n\n    /**\n     * Loads a certain calendar, if the current view is still a calendar view.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    loadCalendar: function(type, calendar)\n    {\n        if (Kronolith.conf.calendars[type][calendar].show &&\n            $w('day workweek week month year agenda').include(this.view)) {\n            var dates = this.viewDates(this.date, this.view);\n            this.deleteCache([type, calendar]);\n            this.loadEvents(dates[0], dates[1], this.view, [[type, calendar]]);\n        }\n    },\n\n    /**\n     * Toggles a calendars visibility.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    toggleCalendar: function(type, calendar)\n    {\n        var elt = $('kronolithMenuCalendars').select('div').find(function(div) {\n            return div.retrieve('calendarclass') == type &&\n            div.retrieve('calendar') == calendar;\n        }).down('.horde-resource-link').down('span');\n\n        Kronolith.conf.calendars[type][calendar].show = !Kronolith.conf.calendars[type][calendar].show;\n        elt.toggleClassName('horde-resource-on');\n        elt.toggleClassName('horde-resource-off');\n\n        if (Kronolith.conf.calendars[type][calendar].show) {\n            this.addCalendarLegend(type, calendar, Kronolith.conf.calendars[type][calendar]);\n        } else {\n            this.deleteCalendarLegend(type, calendar);\n        }\n\n        switch (this.view) {\n        case 'month':\n        case 'agenda':\n            if (Object.isUndefined(this.ecache.get(type)) ||\n                Object.isUndefined(this.ecache.get(type).get(calendar))) {\n                this.loadCalendar(type, calendar);\n            } else {\n                var allEvents = this.kronolithBody.select('div').findAll(function(el) {\n                    return el.retrieve('calendar') == type + '|' + calendar;\n                });\n                if (this.view == 'month' && Kronolith.conf.max_events) {\n                    var dates = this.viewDates(this.date, this.view);\n                    if (elt.hasClassName('horde-resource-off')) {\n                        var day, more, events, calendars = [];\n                        $H(Kronolith.conf.calendars).each(function(type) {\n                            $H(type.value).each(function(cal) {\n                                if (cal.value.show) {\n                                    calendars.push(type.key + '|' + cal.key);\n                                }\n                            });\n                        });\n                        allEvents.each(function(el) {\n                            if (el.retrieve('calendar').startsWith('holiday|')) {\n                                this.holidays = this.holidays.without(el.retrieve('eventid'));\n                            }\n                            el.remove();\n                        }, this);\n                        for (var date = dates[0]; !date.isAfter(dates[1]); date.add(1).days()) {\n                            day = this.monthDays['kronolithMonthDay' + date.dateString()];\n                            more = day.select('.kronolithMore');\n                            events = day.select('.kronolith-event');\n                            if (more.size() &&\n                                events.size() < Kronolith.conf.max_events) {\n                                more[0].purge();\n                                more[0].remove();\n                                events.invoke('remove');\n                                calendars.each(function(calendar) {\n                                    this.insertEvents([date, date], 'month', calendar);\n                                }, this);\n                            }\n                        }\n                    } else {\n                        this.insertEvents(dates, 'month', type + '|' + calendar);\n                    }\n                } else {\n                    allEvents.invoke('toggle');\n                }\n            }\n            break;\n\n        case 'year':\n        case 'week':\n        case 'workweek':\n        case 'day':\n            if (Object.isUndefined(this.ecache.get(type)) ||\n                Object.isUndefined(this.ecache.get(type).get(calendar))) {\n                this.loadCalendar(type, calendar);\n            } else {\n                this.insertEvents(this.viewDates(this.date, this.view), this.view);\n            }\n            break;\n\n        case 'tasks':\n            if (type != 'tasklists') {\n                break;\n            }\n            var tasklist = calendar.substr(6);\n            if (elt.hasClassName('horde-resource-off')) {\n                $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n                    return el.retrieve('tasklist') == tasklist;\n                }).invoke('remove');\n            } else {\n                this.loadTasks(this.tasktype, [ tasklist ]);\n            }\n            break;\n        }\n\n        if ($w('tasklists remote external holiday resource').include(type)) {\n            calendar = type + '_' + calendar;\n        }\n        HordeCore.doAction('saveCalPref', { toggle_calendar: calendar });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the editable calendars.\n     *\n     * @param string id  The id of the SELECT element.\n     */\n    updateCalendarDropDown: function(id)\n    {\n        $(id).update();\n        ['internal', 'remote'].each(function(type) {\n            $H(Kronolith.conf.calendars[type]).each(function(cal) {\n                if (cal.value.edit) {\n                    $(id).insert(new Element('option', { value: type + '|' + cal.key })\n                                 .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })\n                                 .update(cal.value.name.escapeHTML()));\n                }\n            });\n        });\n    },\n\n    /**\n     * Adds a calendar entry to the print legend.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     * @param object cal   The calendar object.\n     */\n    addCalendarLegend: function(type, id, cal)\n    {\n        $('kronolith-legend').insert(\n            new Element('span')\n                .insert(cal.name.escapeHTML())\n                .store('calendar', id)\n                .store('calendarclass', type)\n                .setStyle({ backgroundColor: cal.bg, color: cal.fg })\n        );\n    },\n\n    /**\n     * Deletes a calendar entry from the print legend.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     */\n    deleteCalendarLegend: function(type, id)\n    {\n        var legend = $('kronolith-legend').select('span').find(function(span) {\n            return span.retrieve('calendarclass') == type &&\n                span.retrieve('calendar') == id;\n        });\n        if (legend) {\n            legend.remove();\n        }\n    },\n\n    /**\n     * Opens a tab in a form.\n     *\n     * @param Element  The A element of a tab.\n     */\n    openTab: function(elt)\n    {\n        var dialog = elt.up('form'), tab = $(elt.id.replace(/Link/, 'Tab')),\n            field;\n        dialog.select('.kronolithTabsOption').invoke('hide');\n        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');\n        tab.show();\n        elt.up().addClassName('horde-active');\n        if (elt.id == 'kronolithEventLinkMap') {\n            if (!this.mapInitialized) {\n                this.initializeMap();\n            }\n        }\n        field = tab.down('textarea');\n        if (!field) {\n            field = tab.down('input');\n        }\n        if (field) {\n            try {\n                field.focus();\n            } catch (e) {}\n        }\n        switch (tab.identify()) {\n        case 'kronolithEventTabAttendees':\n            this.attendeeStartDateHandler(this.getFBDate());\n            break;\n        case 'kronolithEventTabResources':\n            this.resourceStartDateHandler(this.getFBDate());\n            break;\n        }\n    },\n\n    /**\n     * Sets the load signature and show the loading spinner.\n     *\n     * @param string resource   The loading resource.\n     * @param string signatrue  The signature for this request.\n     */\n    startLoading: function(resource, signature)\n    {\n        this.eventsLoading[resource] = signature;\n        this.loading++;\n        $('kronolithLoading').show();\n    },\n\n    /**\n     */\n    loadEvents: function(firstDay, lastDay, view, calendars)\n    {\n        var loading = false;\n\n        if (typeof calendars == 'undefined') {\n            calendars = [];\n            $H(Kronolith.conf.calendars).each(function(type) {\n                $H(type.value).each(function(cal) {\n                    if (cal.value.show) {\n                        calendars.push([type.key, cal.key]);\n                    }\n                });\n            });\n        }\n\n        calendars.each(function(cal) {\n            var startDay = firstDay.clone(), endDay = lastDay.clone(),\n                cals = this.ecache.get(cal[0]);\n\n            if (typeof cals != 'undefined' &&\n                typeof cals.get(cal[1]) != 'undefined') {\n                cals = cals.get(cal[1]);\n                while (!Object.isUndefined(cals.get(startDay.dateString())) &&\n                       startDay.isBefore(endDay)) {\n                    if (view != 'year') {\n                        this.insertEvents([startDay, startDay], view, cal.join('|'));\n                    }\n                    startDay.add(1).day();\n                }\n                while (!Object.isUndefined(cals.get(endDay.dateString())) &&\n                       (!startDay.isAfter(endDay))) {\n                    if (view != 'year') {\n                        this.insertEvents([endDay, endDay], view, cal.join('|'));\n                    }\n                    endDay.add(-1).day();\n                }\n                if (startDay.compareTo(endDay) > 0) {\n                    return;\n                }\n            }\n            var start = startDay.dateString(), end = endDay.dateString(),\n                calendar = cal.join('|');\n            loading = true;\n            this.startLoading(calendar, start + end);\n            this.storeCache($H(), calendar, null, true);\n\n            HordeCore.doAction('listEvents', {\n                start: start,\n                end: end,\n                cal: calendar,\n                sig: start + end,\n                view: view\n            }, {\n                callback: function(r) {\n                    this.loadEventsCallback(r, true);\n                }.bind(this)\n            });\n        }, this);\n\n        if (!loading && view == 'year') {\n            this.insertEvents([firstDay, lastDay], 'year');\n        }\n    },\n\n    /**\n     * Callback method for inserting events in the current view.\n     *\n     * @param object r             The ajax response object.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet. Useful for\n     *                             (not) adding individual events to the cache\n     *                             if it doesn't match any cached views.\n     */\n    loadEventsCallback: function(r, createCache)\n    {\n        // Hide spinner.\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n\n        var start = this.parseDate(r.sig.substr(0, 8)),\n            end = this.parseDate(r.sig.substr(8, 8)),\n            dates = [start, end],\n            currentDates;\n\n        this.storeCache(r.events || {}, r.cal, dates, createCache);\n\n        // Check if this is the still the result of the most current request.\n        if (r.sig != this.eventsLoading[r.cal]) {\n            return;\n        }\n        delete this.eventsLoading[r.cal];\n\n        // Check if the calendar is still visible.\n        var calendar = r.cal.split('|');\n        if (!Kronolith.conf.calendars[calendar[0]][calendar[1]].show) {\n            return;\n        }\n\n        // Check if the result is still for the current view.\n        currentDates = this.viewDates(this.date, this.view);\n        if (r.view != this.view ||\n            !start.between(currentDates[0], currentDates[1])) {\n\n            return;\n        }\n\n        if (this.view == 'day' ||\n            this.view == 'week' ||\n            this.view == 'workweek' ||\n            this.view == 'month' ||\n            this.view == 'agenda' ||\n            (this.view == 'year' && !$H(this.eventsLoading).size())) {\n            this.insertEvents(dates, this.view, r.cal);\n        }\n    },\n\n    /**\n     * Reads events from the cache and inserts them into the view.\n     *\n     * If inserting events into day and week views, the calendar parameter is\n     * ignored, and events from all visible calendars are inserted instead.\n     * This is necessary because the complete view has to be re-rendered if\n     * events are not in chronological order.\n     * The year view is specially handled too because there are no individual\n     * events, only a summary of all events per day.\n     *\n     * @param Array dates      Start and end of dates to process.\n     * @param string view      The view to update.\n     * @param string calendar  The calendar to update.\n     */\n    insertEvents: function(dates, view, calendar)\n    {\n        switch (view) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n            // The day and week views require the view to be completely\n            // loaded, to correctly calculate the dimensions.\n            if (this.viewLoading.size() || this.view != view) {\n                this.insertEvents.bind(this, [dates[0].clone(), dates[1].clone()], view, calendar).defer();\n                return;\n            }\n            break;\n        }\n\n        var day = dates[0].clone(),\n                  viewDates = this.viewDates(this.date, this.view),\n                  date, more, title, titles, events, monthDay, busyHours;\n        while (!day.isAfter(dates[1])) {\n            // Skip if somehow events slipped in though the view is gone.\n            if (!day.between(viewDates[0], viewDates[1])) {\n                if (window.console) {\n                    window.console.trace();\n                }\n                day.next().day();\n                continue;\n            }\n\n            date = day.dateString();\n            switch (view) {\n            case 'day':\n            case 'week':\n            case 'workweek':\n                this.dayEvents = [];\n                this.dayGroups = [];\n                this.allDayEvents = [];\n                if (view == 'day') {\n                    $$('.kronolith-event').invoke('remove');\n                } else {\n                    this.eventsWeek['kronolithEvents' + (view == 'week' ? 'Week' : 'Workweek') + date]\n                        .select('.kronolith-event')\n                        .invoke('remove');\n                    this.allDays['kronolithAllDay' + date]\n                        .childElements()\n                        .invoke('remove');\n                }\n                break;\n\n            case 'month':\n                monthDay = this.monthDays['kronolithMonthDay' + date];\n                monthDay.select('div')\n                    .findAll(function(el) { return el.retrieve('calendar') == calendar; })\n                    .invoke('remove');\n                break;\n\n            case 'year':\n                titles = [];\n                busyHours = 0;\n            }\n\n            if (view == 'month' || view == 'agenda') {\n                events = this.getCacheForDate(date, calendar);\n            } else {\n                events = this.getCacheForDate(date);\n            }\n            events.sortBy(this.sortEvents).each(function(event) {\n                var insertBefore;\n                switch (view) {\n                case 'month':\n                case 'agenda':\n                    if (calendar.startsWith('holiday|')) {\n                        if (this.holidays.include(event.key)) {\n                            return;\n                        }\n                        this.holidays.push(event.key);\n                    }\n                    if (view == 'month' && Kronolith.conf.max_events) {\n                        more = monthDay.down('.kronolithMore');\n                        if (more) {\n                            more.purge();\n                            more.remove();\n                        }\n                    }\n                    if (view == 'month') {\n                        if (Kronolith.conf.max_events) {\n                        var events = monthDay.select('.kronolith-event');\n                        if (events.size() >= Kronolith.conf.max_events) {\n                            if (date == (new Date().dateString())) {\n                                // This is today.\n                                if (event.value.al || event.value.end.isBefore()) {\n                                    // No room for all-day or finished events.\n                                    this.insertMore(date);\n                                    return;\n                                }\n                                var remove, max;\n                                // Find an event that is earlier than now or\n                                // later then the current event.\n                                events.each(function(elm) {\n                                    var calendar = elm.retrieve('calendar').split('|'),\n                                        event = this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid'));\n                                    if (event.start.isBefore()) {\n                                        remove = elm;\n                                        throw $break;\n                                    }\n                                    if (!max || event.start.isAfter(max)) {\n                                        max = event.start;\n                                        remove = elm;\n                                    }\n                                }, this);\n                                if (remove) {\n                                    remove.purge();\n                                    remove.remove();\n                                    insertBefore = this.findInsertBefore(events.without(remove), event, date);\n                                } else {\n                                    this.insertMore(date);\n                                    return;\n                                }\n                            } else {\n                                // Not today.\n                                var allDays = events.findAll(function(elm) {\n                                    var calendar = elm.retrieve('calendar').split('|');\n                                    return this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).al;\n                                }.bind(this));\n                                if (event.value.al) {\n                                    // We want one all-day event.\n                                    if (allDays.size()) {\n                                        // There already is an all-day event.\n                                        if (event.value.x == Kronolith.conf.status.confirmed ||\n                                            event.value.x == Kronolith.conf.status.tentative) {\n                                            // But is there a less important\n                                            // one?\n                                            var status = [Kronolith.conf.status.free, Kronolith.conf.status.cancelled];\n                                            if (event.value.x == Kronolith.conf.status.confirmed) {\n                                                status.push(Kronolith.conf.status.tentative);\n                                            }\n                                            var free = allDays.detect(function(elm) {\n                                                var calendar = elm.retrieve('calendar').split('|');\n                                                return status.include(this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).x);\n                                            }.bind(this));\n                                            if (!free) {\n                                                this.insertMore(date);\n                                                return;\n                                            }\n                                            insertBefore = free.next();\n                                            free.purge();\n                                            free.remove();\n                                        } else {\n                                            // No.\n                                            this.insertMore(date);\n                                            return;\n                                        }\n                                    } else {\n                                        // Remove the last event to make room\n                                        // for this one.\n                                        var elm = events.pop();\n                                        elm.purge();\n                                        elm.remove();\n                                        insertBefore = events.first();\n                                    }\n                                } else {\n                                    if (allDays.size() > 1) {\n                                        // We don't want more than one all-day\n                                        // event.\n                                        var elm = allDays.pop();\n                                        // Remove element from events as well.\n                                        events = events.without(elm);\n                                        elm.purge();\n                                        elm.remove();\n                                        insertBefore = this.findInsertBefore(events, event, date);\n                                    } else {\n                                        // This day is full.\n                                        this.insertMore(date);\n                                        return;\n                                    }\n                                }\n                            }\n                            this.insertMore(date);\n                        } else {\n                            insertBefore = this.findInsertBefore(events, event, date);\n                        }\n                        } else {\n                            var events = monthDay.select('.kronolith-event');\n                            insertBefore = this.findInsertBefore(events, event, date);\n                        }\n                    }\n                    break;\n\n                case 'year':\n                    title = '';\n                    if (event.value.al) {\n                        title += Kronolith.text.allday;\n                    } else {\n                        title += event.value.start.toString('t') + '-' + event.value.end.toString('t');\n                    }\n                    if (event.value.t) {\n                        title += ': ' + event.value.t.escapeHTML();\n                    }\n                    if (event.value.x == Kronolith.conf.status.tentative ||\n                        event.value.x == Kronolith.conf.status.confirmed) {\n                        busyHours += event.value.start.getElapsed(event.value.end) / 3600000;\n                    }\n                    titles.push(title);\n                    return;\n                }\n                this.insertEvent(event, date, view, insertBefore);\n            }, this);\n\n            switch (view) {\n            case 'agenda':\n                if ($('kronolithViewAgendaBody').select('tr').length > 2) {\n                    $('kronolithAgendaNoItems').hide();\n                } else {\n                    $('kronolithAgendaNoItems').show();\n                }\n                break;\n\n            case 'year':\n                var td = $('kronolithYear' + date);\n                if (td.className == 'kronolith-minical-empty') {\n                    continue;\n                }\n                if (td.hasClassName('kronolith-today')) {\n                    td.className = 'kronolith-today';\n                } else {\n                    td.className = '';\n                }\n                if (titles.length) {\n                    td.addClassName('kronolithHasEvents');\n                    if (busyHours > 0) {\n                        td.addClassName(this.getHeatmapClass(busyHours));\n                        busyHours = 0;\n                    }\n                    td.down('a').writeAttribute('nicetitle', Object.toJSON(titles));\n                }\n            }\n\n            day.next().day();\n        }\n        // Workaround Firebug bug.\n        Prototype.emptyFunction();\n    },\n\n    findInsertBefore: function(events, event, date)\n    {\n        var insertBefore, insertSort;\n        events.each(function(elm) {\n            var calendar = elm.retrieve('calendar').split('|'),\n                existing = this.ecache\n                    .get(calendar[0])\n                    .get(calendar[1])\n                    .get(date)\n                    .get(elm.retrieve('eventid'));\n            if (event.value.sort < existing.sort &&\n                (!insertSort || existing.sort < insertSort)) {\n                insertBefore = elm;\n                insertSort = existing.sort;\n            }\n        }, this);\n        return insertBefore;\n    },\n\n    getHeatmapClass: function(hours)\n    {\n        return 'heat' + Math.min(Math.ceil(hours / 2), 6);\n    },\n\n    /**\n     * Creates the DOM node for an event bubble and inserts it into the view.\n     *\n     * @param object event    A Hash member with the event to insert.\n     * @param string date     The day to update.\n     * @param string view     The view to update.\n     * @param Element before  Insert the event before this element (month view).\n     */\n    insertEvent: function(event, date, view, before)\n    {\n        var calendar = event.value.calendar.split('|');\n        event.value.nodeId = ('kronolithEvent' + view + event.value.calendar + date + event.key).replace(new RegExp('[^a-zA-Z0-9]', 'g'), '');\n\n        var _createElement = function(event) {\n            var className ='kronolith-event';\n            switch (event.value.x) {\n            case 3:\n                className += ' kronolith-event-cancelled';\n                break;\n            case 1:\n            case 4:\n                className += ' kronolith-event-tentative';\n                break;\n            }\n            var el = new Element('div', { id: event.value.nodeId, className: className })\n                .store('calendar', event.value.calendar)\n                .store('eventid', event.key);\n            if (!Object.isUndefined(event.value.aj)) {\n                el.store('ajax', event.value.aj);\n            }\n            return el;\n        };\n\n        switch (view) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n            var storage = view + 'Sizes',\n                what = view == 'week' ? 'Week' : 'Workweek',\n                div = _createElement(event),\n                margin = view == 'day' ? 1 : 3,\n                style = { backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                          color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg };\n\n            div.writeAttribute('title', event.value.t);\n\n            if (event.value.al) {\n                if (view == 'day') {\n                    $('kronolithViewDay').down('.kronolithAllDayContainer').insert(div.setStyle(style));\n                } else {\n                    var allDay = this.allDays['kronolithAllDay' + date],\n                        existing = allDay.childElements(),\n                        weekHead = $('kronolithView' + what + 'Head');\n                    if (existing.size() == 3) {\n                        if (existing[2].className != 'kronolithMore') {\n                            existing[2].purge();\n                            existing[2].remove();\n                            allDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });\n                        }\n                    } else {\n                        allDay.insert(div.setStyle(style));\n                        if (event.value.pe) {\n                            div.addClassName('kronolithEditable');\n                            var layout = div.getLayout(),\n                                minLeft = weekHead.down('.kronolith-first-col').getWidth() + this[storage].spacing + (parseInt(div.getStyle('marginLeft'), 10) || 0),\n                                minTop = weekHead.down('thead').getHeight() + this[storage].spacing + (parseInt(div.getStyle('marginTop'), 10) || 0),\n                                maxLeft = weekHead.getWidth() - layout.get('margin-box-width'),\n                                maxTop = weekHead.down('thead').getHeight() + weekHead.down('.kronolith-all-day').getHeight(),\n                                opts = {\n                                    threshold: 5,\n                                    parentElement: function() {\n                                        return $('kronolithView' + what).down('.kronolith-view-head');\n                                    },\n                                    snap: function(x, y) {\n                                        return [Math.min(Math.max(x, minLeft), maxLeft),\n                                                Math.min(Math.max(y, minTop), maxTop - div.getHeight())];\n                                    }\n                                };\n                            var d = new Drag(event.value.nodeId, opts);\n                            div.store('drags', []);\n                            Object.extend(d, {\n                                event: event,\n                                innerDiv: new Element('div'),\n                                midnight: this.parseDate(date)\n                            });\n                            div.retrieve('drags').push(d);\n                        }\n                    }\n                }\n                break;\n            }\n\n            var midnight = this.parseDate(date),\n                resizable = event.value.pe && (Object.isUndefined(event.value.vl) || event.value.vl),\n                innerDiv = new Element('div', { className: 'kronolith-event-info' }),\n                minHeight = 0, parentElement, draggerTop, draggerBottom,\n                elapsed = (event.value.start.getHours() - midnight.getHours()) * 60 + (event.value.start.getMinutes() - midnight.getMinutes());\n            switch (view) {\n            case 'day':\n                parentElement = $('kronolithEventsDay');\n                break;\n            case 'week':\n                parentElement = this.eventsWeek['kronolithEventsWeek' + date];\n                break;\n            case 'workweek':\n                parentElement = this.eventsWeek['kronolithEventsWorkweek' + date];\n                break;\n            }\n            if (event.value.fi) {\n                div.addClassName('kronolithFirst');\n                if (resizable) {\n                    draggerTop = new Element('div', { id: event.value.nodeId + 'top', className: 'kronolithDragger kronolithDraggerTop' }).setStyle(style);\n                }\n            } else {\n                innerDiv.setStyle({ top: 0 });\n            }\n            if (event.value.la) {\n                div.addClassName('kronolithLast');\n                if (resizable) {\n                    draggerBottom = new Element('div', { id: event.value.nodeId + 'bottom', className: 'kronolithDragger kronolithDraggerBottom' }).setStyle(style);\n                }\n            } else {\n                innerDiv.setStyle({ bottom: 0 });\n            }\n\n            div.setStyle({\n                top: (elapsed * this[storage].height / 60 | 0) + 'px',\n                width: 100 - margin + '%'\n            })\n                .insert(innerDiv.setStyle(style));\n            if (draggerTop) {\n                div.insert(draggerTop);\n            }\n            if (draggerBottom) {\n                div.insert(draggerBottom);\n            }\n            parentElement.insert(div);\n            if (draggerTop) {\n                minHeight += draggerTop.getHeight();\n            }\n            if (draggerBottom) {\n                minHeight += draggerBottom.getHeight();\n            }\n            if (!minHeight) {\n                minHeight = parseInt(innerDiv.getStyle('lineHeight'), 10)\n                    + (parseInt(innerDiv.getStyle('paddingTop'), 10) || 0)\n                    + (parseInt(innerDiv.getStyle('paddingBottom'), 10) || 0);\n            }\n            div.setStyle({ height: Math.max(Math.round(event.value.start.getElapsed(event.value.end) / 60000) * this[storage].height / 60 - this[storage].spacing | 0, minHeight) + 'px' });\n\n            if (event.value.pe) {\n                div.addClassName('kronolithEditable');\n                div.store('drags', []);\n                // Number of pixels that cover 10 minutes.\n                var step = this[storage].height / 6,\n                    stepX, minLeft, maxLeft, maxTop,\n                    minBottom, maxBottom, dragBottomHeight;\n                if (draggerBottom) {\n                    // Height of bottom dragger\n                    dragBottomHeight = draggerBottom.getHeight();\n                }\n                if (draggerTop) {\n                    // Bottom-most position (maximum y) of top dragger\n                    maxTop = div.offsetTop\n                        - draggerTop.getHeight()\n                        - parseInt(innerDiv.getStyle('lineHeight'), 10);\n                    if (draggerBottom) {\n                        maxTop += draggerBottom.offsetTop;\n                    }\n                }\n                if (draggerBottom) {\n                    // Top-most position (minimum y) of bottom dragger (upper\n                    // edge)\n                    minBottom = div.offsetTop\n                        + parseInt(innerDiv.getStyle('lineHeight'), 10);\n                    // Bottom-most position (maximum y) of bottom dragger\n                    // (upper edge)\n                    maxBottom = 24 * this[storage].height\n                        + dragBottomHeight;\n                    if (draggerTop) {\n                        minBottom += draggerTop.getHeight();\n                    }\n                }\n                    // Height of the whole event div\n                var divHeight = div.getHeight(),\n                    // Maximum height of the whole event div\n                    maxDiv = 24 * this[storage].height - divHeight,\n                    // Whether the top dragger is dragged, vs. the bottom\n                    // dragger\n                    opts = {\n                        threshold: 5,\n                        constraint: 'vertical',\n                        scroll: this.kronolithBody,\n                        nodrop: true,\n                        parentElement: function() {\n                            return parentElement;\n                        }\n                    };\n\n                if (draggerTop) {\n                    opts.snap = function(x, y) {\n                        y = Math.max(0, step * (Math.min(maxTop, y - this.scrollTop) / step | 0));\n                        return [0, y];\n                    }.bind(this);\n                    var d = new Drag(event.value.nodeId + 'top', opts);\n                    Object.extend(d, {\n                        event: event,\n                        innerDiv: innerDiv,\n                        midnight: midnight\n                    });\n                    div.retrieve('drags').push(d);\n                }\n\n                if (draggerBottom) {\n                    opts.snap = function(x, y) {\n                        y = Math.min(maxBottom + dragBottomHeight + KronolithCore[storage].spacing, step * ((Math.max(minBottom, y - this.scrollTop) + dragBottomHeight + KronolithCore[storage].spacing) / step | 0)) - dragBottomHeight - KronolithCore[storage].spacing;\n                        return [0, y];\n                    }.bind(this);\n                    var d = new Drag(event.value.nodeId + 'bottom', opts);\n                    Object.extend(d, {\n                        event: event,\n                        innerDiv: innerDiv,\n                        midnight: midnight\n                    });\n                    div.retrieve('drags').push(d);\n                }\n\n                if (view == 'week' || view == 'workweek') {\n                    var dates = this.viewDates(midnight, view);\n                    minLeft = this.eventsWeek['kronolithEvents' + what + dates[0].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;\n                    maxLeft = this.eventsWeek['kronolithEvents' + what + dates[1].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;\n                    stepX = (maxLeft - minLeft) / (view == 'week' ? 6 : 4);\n                }\n                var d = new Drag(div, {\n                    threshold: 5,\n                    nodrop: true,\n                    parentElement: function() { return parentElement; },\n                    snap: function(x, y) {\n                        x = (view == 'week' || view == 'workweek')\n                            ? Math.max(minLeft, stepX * ((Math.min(maxLeft, x - (x < 0 ? stepX : 0)) + stepX / 2) / stepX | 0))\n                            : 0;\n                        y = Math.max(0, step * (Math.min(maxDiv, y - this.scrollTop) / step | 0));\n                        return [x, y];\n                    }.bind(this)\n                });\n                Object.extend(d, {\n                    divHeight: divHeight,\n                    startTop: div.offsetTop,\n                    event: event,\n                    midnight: midnight,\n                    stepX: stepX\n                });\n                div.retrieve('drags').push(d);\n            }\n\n            var\n                // The current column that we're probing for available space.\n                column = 1,\n                // The number of columns in the current conflict group.\n                columns,\n                // The column width in the current conflict group.\n                width,\n                // The first event that conflict with the current event.\n                conflict = false,\n                // The conflict group where this event should go.\n                pos = this.dayGroups.length,\n                // The event below that the current event fits.\n                placeFound = false,\n                // The minimum (virtual) duration of each event, defined by the\n                // minimum height of an event DIV.\n                minMinutes = (minHeight + this[storage].spacing) * 60 / this[storage].height;\n\n            // this.dayEvents contains all events of the current day.\n            // this.dayGroups contains conflict groups, i.e. all events that\n            // conflict with each other and share a set of columns.\n            //\n            // Go through all events that have been added to this day already.\n            this.dayEvents.each(function(ev) {\n                // Due to the minimum height of an event DIV, events might\n                // visually overlap, even if they physically don't.\n                var minEnd = ev.start.clone().add(minMinutes).minutes(),\n                    end = ev.end.isAfter(minEnd) ? ev.end : minEnd;\n\n                // If it doesn't conflict with the current event, go ahead.\n                if (!end.isAfter(event.value.start)) {\n                    return;\n                }\n\n                // Found a conflicting event, now find its conflict group.\n                for (pos = 0; pos < this.dayGroups.length; pos++) {\n                    if (this.dayGroups[pos].indexOf(ev) != -1) {\n                        // Increase column for each conflicting event in this\n                        // group.\n                        this.dayGroups[pos].each(function(ce) {\n                            var minEnd = ce.start.clone().add(minMinutes).minutes(),\n                                end = ce.end.isAfter(minEnd) ? ce.end : minEnd;\n                            if (end.isAfter(event.value.start)) {\n                                column++;\n                            }\n                        });\n                        throw $break;\n                    }\n                }\n            }, this);\n            event.value.column = event.value.columns = column;\n\n            if (Object.isUndefined(this.dayGroups[pos])) {\n                this.dayGroups[pos] = [];\n            }\n            this.dayGroups[pos].push(event.value);\n\n            // See if the current event had to add yet another column.\n            columns = Math.max(this.dayGroups[pos][0].columns, column);\n\n            // Update the widths of all events in a conflict group.\n            width = 100 / columns;\n            this.dayGroups[pos].each(function(ev) {\n                ev.columns = columns;\n                $(ev.nodeId).setStyle({ width: width - margin + '%', left: (width * (ev.column - 1)) + '%' });\n            });\n            this.dayEvents.push(event.value);\n\n            div = innerDiv;\n            break;\n\n        case 'month':\n            var monthDay = this.monthDays['kronolithMonthDay' + date],\n                div = _createElement(event)\n                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });\n            div.writeAttribute('title', event.value.t);\n            if (before) {\n                before.insert({ before: div });\n            } else {\n                monthDay.insert(div);\n            }\n            if (event.value.pe) {\n                div.setStyle({ cursor: 'move' });\n                new Drag(event.value.nodeId, { threshold: 5, parentElement: function() { return $('kronolith-month-body'); }, snapToParent: true });\n            }\n            if (Kronolith.conf.max_events) {\n                var more = monthDay.down('.kronolithMore');\n                if (more) {\n                    monthDay.insert({ bottom: more.remove() });\n                }\n            }\n            break;\n\n        case 'agenda':\n            var div = _createElement(event)\n                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });\n            this.createAgendaDay(date);\n            $('kronolithAgendaDay' + date).insert(div);\n            break;\n        }\n\n        this.setEventText(div, event.value,\n                          { time: view == 'agenda' || Kronolith.conf.show_time })\n            .observe('mouseover', div.addClassName.curry('kronolith-selected'))\n            .observe('mouseout', div.removeClassName.curry('kronolith-selected'));\n    },\n\n    /**\n     * Re-renders the necessary parts of the current view, if any event changes\n     * in those parts require re-rendering.\n     *\n     * @param Array dates  The date strings of days to re-render.\n     */\n    reRender: function(dates)\n    {\n        switch (this.view) {\n        case 'week':\n        case 'workweek':\n        case 'day':\n            dates.each(function(date) {\n                date = this.parseDate(date);\n                this.insertEvents([ date, date ], this.view);\n            }, this);\n            break;\n        case 'month':\n            dates.each(function(date) {\n                var day = this.monthDays['kronolithMonthDay' + date];\n                day.select('.kronolith-event').each(function(event) {\n                    if (event.retrieve('calendar').startsWith('holiday')) {\n                        delete this.holidays[event.retrieve('eventid')];\n                    }\n                    event.remove();\n                }, this);\n                day.select('.kronolithMore').invoke('remove');\n                date = this.parseDate(date);\n                this.loadEvents(date, date, 'month');\n            }, this);\n            break;\n        }\n    },\n\n    /**\n     * Returns all dates of the current view that contain (recurrences) of a\n     * certain event.\n     *\n     * @param String cal      A calendar string.\n     * @param String eventid  An event id.\n     *\n     * @return Array  A list of date strings that contain a recurrence of the\n     *                event.\n     */\n    findEventDays: function(cal, eventid)\n    {\n        cal = cal.split('|');\n        var cache = this.ecache.get(cal[0]).get(cal[1]),\n            dates = this.viewDates(this.date, this.view),\n            day = dates[0], days = [], dateString;\n        while (!day.isAfter(dates[1])) {\n            dateString = day.dateString();\n            if (cache.get(dateString).get(eventid)) {\n                days.push(dateString);\n            }\n            day.add(1).days();\n        }\n        return days;\n    },\n\n    /**\n     * Adds a \"more...\" button to the month view cell that links to the days,\n     * or moves it to the buttom.\n     *\n     * @param string date  The date string of the day cell.\n     */\n    insertMore: function(date)\n    {\n        var monthDay = this.monthDays['kronolithMonthDay' + date],\n            more = monthDay.down('.kronolithMore');\n        if (more) {\n            monthDay.insert({ bottom: more.remove() });\n        } else {\n            monthDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });\n        }\n    },\n\n    setEventText: function(div, event, opts)\n    {\n        var calendar = event.calendar.split('|'),\n            span = new Element('span'),\n            time, end;\n        opts = Object.extend({ time: false }, opts || {});\n\n        div.update();\n        if (event.ic) {\n            div.insert(new Element('img', { src: event.ic, className: 'kronolithEventIcon' }));\n        }\n        if (opts.time && !event.al) {\n            time = new Element('span', { className: 'kronolith-time' })\n                .insert(event.start.toString(Kronolith.conf.time_format));\n            if (!event.start.equals(event.end)) {\n                end = event.end.clone();\n                if (end.getHours() == 23 &&\n                    end.getMinutes() == 59 &&\n                    end.getSeconds() == 59) {\n                    end.add(1).second();\n                }\n                time.insert('-' + end.toString(Kronolith.conf.time_format));\n            }\n            div.insert(time).insert(' ');\n        }\n        div.insert(event.t.escapeHTML());\n        div.insert(span);\n        if (event.a) {\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.alarm.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.alarm + ' ' + event.a }));\n        }\n        if (event.r) {\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur[event.r] }));\n        } else if (event.bid) {\n            div.store('bid', event.bid);\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.exception.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur.exception }));\n        }\n        return div;\n    },\n\n    /**\n     * Finally removes events from the DOM and the cache.\n     *\n     * @param string calendar  A calendar name.\n     * @param string event     An event id. If empty, all events from the\n     *                         calendar are deleted.\n     */\n    removeEvent: function(calendar, event)\n    {\n        this.deleteCache(calendar, event);\n        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {\n            return el.retrieve('calendar') == calendar &&\n                (!event || el.retrieve('eventid') == event);\n        }).invoke('remove');\n    },\n\n    /**\n     * Removes all events that reprensent exceptions to the event series\n     * represented by uid.\n     *\n     * @param string calendar  A calendar name.\n     * @param string uid       An event uid.\n     */\n    removeException: function(calendar, uid)\n    {\n        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {\n            if (el.retrieve('calendar') == calendar && el.retrieve('bid') == uid) {\n                this.removeEvent(calendar, el.retrieve('eventid'));\n            }\n        }.bind(this));\n    },\n\n    /**\n     * Calculates the event's start and end dates based on some drag and drop\n     * information.\n     */\n    calculateEventDates: function(event, storage, step, offset, height, start, end)\n    {\n        if (!Object.isUndefined(start)) {\n            event.start = start;\n            event.end = end;\n        }\n        event.start.set({\n            hour: offset / this[storage].height | 0,\n            minute: Math.round(offset % this[storage].height / step) * 10\n        });\n        var hour = (offset + height + this[storage].spacing) / this[storage].height | 0,\n            minute = Math.round((offset + height + this[storage].spacing) % this[storage].height / step) * 10,\n            second = 0;\n        if (hour == 24) {\n            hour = 23;\n            minute = 59;\n            second = 59;\n        }\n        event.end.set({\n            hour: hour,\n            minute: minute,\n            second: second\n        });\n    },\n\n    switchTaskView: function(on)\n    {\n        if (on) {\n            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]\n                .replace(Kronolith.conf.new_task);\n            $('kronolithQuickEvent').addClassName('kronolithNewTask');\n            $('kronolithHeader').down('.kronolithPrev').up().addClassName('disabled');\n            $('kronolithHeader').down('.kronolithNext').up().addClassName('disabled');\n        } else {\n            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]\n                .replace(Kronolith.conf.new_event);\n            $('kronolithQuickEvent').removeClassName('kronolithNewTask');\n            $('kronolithHeader').down('.kronolithPrev').up().removeClassName('disabled');\n            $('kronolithHeader').down('.kronolithNext').up().removeClassName('disabled');\n        }\n    },\n\n    /**\n     * Returns the task cache storage names that hold the tasks of the\n     * requested task type.\n     *\n     * @param string tasktype  The task type.\n     *\n     * @return array  The list of task cache storage names.\n     */\n    getTaskStorage: function(tasktype)\n    {\n        var tasktypes;\n        if (tasktype == 'all' || tasktype == 'future') {\n            tasktypes = [ 'complete', 'incomplete' ];\n        } else {\n            tasktypes = [ tasktype ];\n        }\n        return tasktypes;\n    },\n\n    /**\n     * Loads tasks, either from cache or from the server.\n     *\n     * @param integer tasktype  The tasks type (all, incomplete, complete, or\n     *                          future).\n     * @param Array tasksLists  The lists from where to obtain the tasks.\n     */\n    loadTasks: function(tasktype, tasklists)\n    {\n        var tasktypes = this.getTaskStorage(tasktype), loading = false,\n            spinner = $('kronolithLoading');\n\n        if (Object.isUndefined(tasklists)) {\n            tasklists = [];\n            $H(Kronolith.conf.calendars.tasklists).each(function(tasklist) {\n                if (tasklist.value.show)\n                {\n                    tasklists.push(tasklist.key.substring(6));\n                }\n            });\n        }\n\n        tasktypes.each(function(type) {\n            tasklists.each(function(list) {\n                if (Object.isUndefined(this.tcache.get(type)) ||\n                    Object.isUndefined(this.tcache.get(type).get(list))) {\n                    loading = true;\n                    this.loading++;\n                    spinner.show();\n                    HordeCore.doAction('listTasks', {\n                        type: type,\n                        list: list\n                    }, {\n                        callback: function(r) {\n                            this.loadTasksCallback(r, true);\n                        }.bind(this)\n                    });\n                }\n            }, this);\n        }, this);\n\n        if (!loading) {\n            tasklists.each(function(list) {\n                this.insertTasks(tasktype, list);\n            }, this);\n        }\n    },\n\n    /**\n     * Callback method for inserting tasks in the current view.\n     *\n     * @param object r             The ajax response object.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet. Useful for\n     *                             (not) adding individual tasks to the cache\n     *                             without assuming to have all tasks of the\n     *                             list.\n     */\n    loadTasksCallback: function(r, createCache)\n    {\n        // Hide spinner.\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n\n        this.storeTasksCache(r.tasks || {}, r.type, r.list, createCache);\n\n        // Check if result is still valid for the current view.\n        // There could be a rare race condition where two responses for the\n        // same task(s) arrive in the wrong order. Checking this too, like we\n        // do for events seems not worth it.\n        var tasktypes = this.getTaskStorage(this.tasktype),\n            tasklist = Kronolith.conf.calendars.tasklists['tasks/' + r.list];\n        if (this.view != 'tasks' ||\n            !tasklist || !tasklist.show ||\n            !tasktypes.include(r.type)) {\n            return;\n        }\n        this.insertTasks(this.tasktype, r.list);\n    },\n\n    /**\n     * Reads tasks from the cache and inserts them into the view.\n     *\n     * @param integer tasktype  The tasks type (all, incomplete, complete, or\n     *                          future).\n     * @param string tasksList  The task list to be drawn.\n     */\n    insertTasks: function(tasktype, tasklist)\n    {\n        var tasktypes = this.getTaskStorage(tasktype), now = new Date();\n\n        $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n            return el.retrieve('tasklist') == tasklist;\n        }).invoke('remove');\n\n        tasktypes.each(function(type) {\n            if (!this.tcache.get(type)) {\n                return;\n            }\n            var tasks = this.tcache.get(type).get(tasklist);\n            $H(tasks).each(function(task) {\n                switch (tasktype) {\n                case 'complete':\n                    if (!task.value.cp) {\n                        return;\n                    }\n                    break;\n                case 'incomplete':\n                    if (task.value.cp ||\n                        (!Object.isUndefined(task.value.start) &&\n                         task.value.start.isAfter(now))) {\n                        return;\n                    }\n                    break;\n                case 'future':\n                    if (task.value.cp ||\n                        Object.isUndefined(task.value.start) ||\n                        !task.value.start.isAfter(now)) {\n                        return;\n                    }\n                    break;\n                }\n                this.insertTask(task);\n            }, this);\n        }, this);\n\n        if ($('kronolithViewTasksBody').select('tr').length > 2) {\n            $('kronolithTasksNoItems').hide();\n        } else {\n            $('kronolithTasksNoItems').show();\n        }\n    },\n\n    /**\n     * Creates the DOM node for a task and inserts it into the view.\n     *\n     * @param object task  A Hash with the task to insert\n     */\n    insertTask: function(task)\n    {\n        var row = $('kronolithTasksTemplate').clone(true),\n            col = row.down(), tagc;\n\n\n        row.removeAttribute('id');\n        row.store('tasklist', task.value.l);\n        row.store('taskid', task.key);\n        col.addClassName('kronolithTask' + (!!task.value.cp ? 'Completed' : ''));\n        col.setStyle({\n            backgroundColor: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].bg,\n            color: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg,\n            textIndent: task.value.i + 'em'\n        });\n        col.insert(task.value.n.escapeHTML());\n        if (!Object.isUndefined(task.value.due)) {\n            var now = new Date();\n            if (!now.isBefore(task.value.due)) {\n                col.addClassName('kronolithTaskDue');\n            }\n            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));\n            col.insert(new Element('span', { className: 'kronolithDate' }).update(task.value.due.toString(Kronolith.conf.date_format)));\n            if (task.value.r) {\n                col.insert(' ')\n                    .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg.substr(1)), title: Kronolith.text.recur[task.value.r] }));\n            }\n        }\n\n        if (!Object.isUndefined(task.value.sd)) {\n            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));\n            col.insert(new Element('span', { className: 'kronolithInfo' }).update(task.value.sd.escapeHTML()));\n        }\n\n        if (task.value.t && task.value.t.size() > 0) {\n            tagc = new Element('ul', { className: 'horde-tags' });\n            task.value.t.each(function(x) {\n                tagc.insert(new Element('li').update(x.escapeHTML()));\n            });\n            col.insert(tagc);\n        }\n        row.insert(col.show());\n        this.insertTaskPosition(row, task);\n    },\n\n    /**\n     * Inserts the task row in the correct position.\n     *\n     * @param Element newRow  The new row to be inserted.\n     * @param object newTask  A Hash with the task being added.\n     */\n    insertTaskPosition: function(newRow, newTask)\n    {\n        var rows = $('kronolithViewTasksBody').select('tr'),\n            rowTasklist, rowTaskId, rowTask, parentFound;\n        // The first row is a template, ignoring.\n        for (var i = 2; i < rows.length; i++) {\n            rowTasklist = rows[i].retrieve('tasklist');\n            rowTaskId = rows[i].retrieve('taskid');\n            if (newTask.value.p) {\n                if (rowTaskId == newTask.value.p) {\n                    parentFound = true;\n                    continue;\n                }\n                if (!parentFound) {\n                    continue;\n                }\n            }\n            rowTask = this.tcache.inject(null, function(acc, list) {\n                if (acc) {\n                    return acc;\n                }\n                if (!Object.isUndefined(list.value.get(rowTasklist))) {\n                    return list.value.get(rowTasklist).get(rowTaskId);\n                }\n            });\n\n            if (Object.isUndefined(rowTask)) {\n                // TODO: Throw error\n                return;\n            }\n            if (!this.isTaskAfter(newTask.value, rowTask)) {\n                break;\n            }\n        }\n        rows[--i].insert({ after: newRow.show() });\n    },\n\n    /**\n     * Analyzes which task should be drawn first.\n     *\n     * TODO: Very incomplete, only a dummy version\n     */\n    isTaskAfter: function(taskA, taskB)\n    {\n        // TODO: Make all ordering system\n        if ((taskA.p || taskB.p) && taskA.p != taskB.p) {\n            return !taskA.p;\n        }\n        return (taskA.pr >= taskB.pr);\n    },\n\n    /**\n     * Completes/uncompletes a task.\n     *\n     * @param string tasklist          The task list to which the tasks belongs.\n     * @param string taskid            The id of the task.\n     * @param boolean|string complete  True if the task is completed, a\n     *                                 due date if there are still\n     *                                 incomplete recurrences.\n     */\n    toggleCompletion: function(tasklist, taskid, complete)\n    {\n        // Update the cache.\n        var task = this.tcache.inject(null, function(acc, list) {\n            if (acc) {\n                return acc;\n            }\n            if (!Object.isUndefined(list.value.get(tasklist))) {\n                return list.value.get(tasklist).get(taskid);\n            }\n        });\n        if (Object.isUndefined(task)) {\n            // This shouldn't happen.\n            this.toggleCompletionClass(taskid);\n            return;\n        }\n        if (Object.isUndefined(complete) || complete === true) {\n            task.cp = !task.cp;\n        }\n\n        if (this.tcache.get(task.cp ? 'complete' : 'incomplete')) {\n            this.tcache.get(task.cp ? 'complete' : 'incomplete').get(tasklist).set(taskid, task);\n        }\n        if (this.tcache.get(task.cp ? 'incomplete' : 'complete')) {\n            this.tcache.get(task.cp ? 'incomplete' : 'complete').get(tasklist).unset(taskid);\n        }\n\n        // Remove row if necessary.\n        var row = this.getTaskRow(taskid);\n        if (!row) {\n            return;\n        }\n        if ((this.tasktype == 'complete' && !task.cp) ||\n            ((this.tasktype == 'incomplete' || this.tasktype == 'future_incomplete') && task.cp) ||\n            ((complete === true) && (this.tasktype == 'future'))) {\n\n            row.fade({\n                duration: this.effectDur,\n                afterFinish: function() {\n                    row.purge();\n                    row.remove();\n\n                    //Check if items remained in interface\n                    if ($('kronolithViewTasksBody').select('tr').length < 3) {\n                        $('kronolithTasksNoItems').show();\n                    }\n                }\n            });\n        }\n\n        // Update due date if necessary.\n        if (!Object.isUndefined(complete) && complete !== true) {\n            var now = new Date(), due = Date.parse(complete);\n            row.down('span.kronolithDate')\n                .update(due.toString(Kronolith.conf.date_format));\n            if (now.isBefore(due)) {\n                row.down('td.kronolithTaskCol')\n                    .removeClassName('kronolithTaskDue');\n            }\n        }\n    },\n\n    /**\n     * Toggles the CSS class to show that a task is completed/uncompleted.\n     *\n     * @param string taskid  The id of the task.\n     */\n    toggleCompletionClass: function(taskid)\n    {\n        var row = this.getTaskRow(taskid);\n        if (!row) {\n            return;\n        }\n        var col = row.down('td.kronolithTaskCol');\n        col.toggleClassName('kronolithTask');\n        col.toggleClassName('kronolithTaskCompleted');\n    },\n\n    /**\n     * Returns the table row of a task.\n     *\n     * @param string taskid  The id of the task.\n     *\n     * @return Element  The table row of the task list, if found.\n     */\n    getTaskRow: function(taskid)\n    {\n        return $('kronolithViewTasksBody').select('tr').find(function(el) {\n            return el.retrieve('taskid') == taskid;\n        });\n    },\n\n    editTask: function(tasklist, id, desc)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n\n        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithTaskTags)) {\n            this.editTask.bind(this, tasklist, id, desc).defer();\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithTaskForm').focusFirstElement();\n            } catch(e) {}\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n\n        this.openTab($('kronolithTaskForm').down('.tabset a.kronolithTabLink'));\n        $('kronolithTaskForm').enable();\n        $('kronolithTaskForm').reset();\n        HordeImple.AutoCompleter.kronolithTaskTags.reset();\n        $('kronolithTaskSave').show().enable();\n        $('kronolithTaskDelete').show().enable();\n        $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').show();\n        this.updateTasklistDropDown();\n        this.disableAlarmMethods('Task');\n        this.knl.kronolithTaskDueTime.markSelected();\n        if (id) {\n            RedBox.loading();\n            this.updateTaskParentDropDown(tasklist);\n            this.updateTaskAssigneeDropDown(tasklist);\n            HordeCore.doAction('getTask', {\n                list: tasklist,\n                id: id\n            }, {\n                callback: this.editTaskCallback.bind(this)\n            });\n            $('kronolithTaskTopTags').update();\n        } else {\n            $('kronolithTaskId').clear();\n            $('kronolithTaskOldList').clear();\n            $('kronolithTaskList').setValue(Kronolith.conf.tasks.default_tasklist);\n            this.updateTaskParentDropDown(Kronolith.conf.tasks.default_tasklist);\n            this.updateTaskAssigneeDropDown(Kronolith.conf.tasks.default_tasklist);\n            $('kronolithTaskParent').setValue('');\n            $('kronolithTaskAssignee').setValue('');\n            //$('kronolithTaskLocation').setValue('http://');\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')\n            });\n            $('kronolithTaskPriority').setValue(3);\n            if (Kronolith.conf.tasks.default_due) {\n                this.setDefaultDue();\n            }\n            if (desc) {\n                $('kronolithTaskDescription').setValue(desc);\n            }\n            this.toggleRecurrence(false, 'None');\n            $('kronolithTaskDelete').hide();\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithTaskDialog').show());\n        }\n    },\n\n    /**\n     * Callback method for showing task forms.\n     *\n     * @param object r  The ajax response object.\n     */\n    editTaskCallback: function(r)\n    {\n        if (!r.task) {\n            RedBox.close();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        var task = r.task;\n\n        /* Basic information */\n        $('kronolithTaskId').setValue(task.id);\n        $('kronolithTaskOldList').setValue(task.l);\n        $('kronolithTaskList').setValue(task.l);\n        $('kronolithTaskTitle').setValue(task.n);\n        $('kronolithTaskParent').setValue(task.p);\n        $('kronolithTaskAssignee').setValue(task.as);\n        //$('kronolithTaskLocation').setValue(task.l);\n        if (task.dd) {\n            $('kronolithTaskDueDate').setValue(task.dd);\n        }\n        if (task.dt) {\n            $('kronolithTaskDueTime').setValue(task.dt);\n            this.knl.kronolithTaskDueTime.setSelected(task.dt);\n        }\n        $('kronolithTaskDescription').setValue(task.de);\n        $('kronolithTaskPriority').setValue(task.pr);\n        $('kronolithTaskCompleted').setValue(task.cp);\n\n        /* Alarm */\n        if (task.a) {\n            this.enableAlarm('Task', task.a);\n            if (task.m) {\n                $('kronolithTaskAlarmDefaultOff').checked = true;\n                $H(task.m).each(function(method) {\n                    if (!$('kronolithTaskAlarm' + method.key)) {\n                        return;\n                    }\n                    $('kronolithTaskAlarm' + method.key).setValue(1);\n                    if ($('kronolithTaskAlarm' + method.key + 'Params')) {\n                        $('kronolithTaskAlarm' + method.key + 'Params').show();\n                    }\n                    $H(method.value).each(function(param) {\n                        var input = $('kronolithTaskAlarmParam' + param.key);\n                        if (!input) {\n                            return;\n                        }\n                        if (input.type == 'radio') {\n                            input.up('form').select('input[type=radio]').each(function(radio) {\n                                if (radio.name == input.name &&\n                                    radio.value == param.value) {\n                                    radio.setValue(1);\n                                    throw $break;\n                                }\n                            });\n                        } else {\n                            input.setValue(param.value);\n                        }\n                    });\n                });\n            }\n        } else {\n            $('kronolithTaskAlarmOff').setValue(true);\n        }\n\n        /* Recurrence */\n        if (task.r) {\n            this.setRecurrenceFields(false, task.r);\n        } else {\n            this.toggleRecurrence(false, 'None');\n        }\n\n        HordeImple.AutoCompleter.kronolithTaskTags.reset(task.t);\n\n        if (!task.pe) {\n            $('kronolithTaskSave').hide();\n            $('kronolithTaskForm').disable();\n        } else {\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')\n            });\n        }\n\n        if (!task.pd) {\n            $('kronolithTaskDelete').show();\n        }\n        if (!task.pe && !task.pd) {\n            $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').hide();\n        }\n\n        this.setTitle(task.n);\n        this.redBoxLoading = true;\n        RedBox.showHtml($('kronolithTaskDialog').show());\n\n        /* Hide alarm message for this task. */\n        if (r.msgs) {\n            r.msgs = r.msgs.reject(function(msg) {\n                if (msg.type != 'horde.alarm') {\n                    return false;\n                }\n                var alarm = msg.flags.alarm;\n                if (alarm.params && alarm.params.notify &&\n                    alarm.params.notify.show &&\n                    alarm.params.notify.show.tasklist &&\n                    alarm.params.notify.show.task &&\n                    alarm.params.notify.show.tasklist == task.l &&\n                    alarm.params.notify.show.task == task.id) {\n                    return true;\n                }\n                return false;\n            });\n        }\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the editable task lists.\n     */\n    updateTasklistDropDown: function()\n    {\n        var tasklist = $('kronolithTaskList');\n        tasklist.update();\n        $H(Kronolith.conf.calendars.tasklists).each(function(cal) {\n            if (cal.value.edit) {\n                tasklist.insert(new Element('option', { value: cal.key.substring(6) })\n                                .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })\n                                .update(cal.value.name.escapeHTML()));\n            }\n        });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the tasks of a task list.\n     *\n     * @param string list  A task list ID.\n     */\n    updateTaskParentDropDown: function(list)\n    {\n        var parents = $('kronolithTaskParent');\n        parents.update(new Element('option', { value: '' })\n                       .update(Kronolith.text.no_parent));\n        HordeCore.doAction('listTasks', {\n            type: 'future_incomplete',\n            list: list\n        }, {\n            ajaxopts: { asynchronuous: false },\n            callback: function(r) {\n                $H(r.tasks).each(function(task) {\n                    parents.insert(new Element('option', { value: task.key })\n                                .setStyle({ textIndent: task.value.i + 'em' })\n                                .update(task.value.n.escapeHTML()));\n                });\n            }.bind(this)\n        });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the users of a task list.\n     *\n     * @param string list  A task list ID.\n     */\n    updateTaskAssigneeDropDown: function(list)\n    {\n        var assignee = $('kronolithTaskAssignee');\n        assignee.update(new Element('option', { value: '' })\n                       .update(Kronolith.text.no_assignee));\n        $H(Kronolith.conf.calendars.tasklists['tasks/' + list].users).each(function(user) {\n            assignee.insert(new Element('option', { value: user.key })\n                            .update(user.value.escapeHTML()));\n        });\n    },\n\n    /**\n     * Sets the default due date and time for tasks.\n     */\n    setDefaultDue: function()\n    {\n        if ($F('kronolithTaskDueDate') || $F('kronolithTaskDueTime')) {\n            return;\n        }\n        $('kronolithTaskDueDate').setValue(new Date().add(Kronolith.conf.tasks.default_due_days).days().toString(Kronolith.conf.date_format));\n        if (Kronolith.conf.tasks.default_due_time == 'now') {\n            $('kronolithTaskDueTime').setValue(new Date().toString(Kronolith.conf.time_format));\n        } else {\n            var date = new Date();\n            date.setHours(Kronolith.conf.tasks.default_due_time.replace(/:.*$/, ''));\n            date.setMinutes(0);\n            $('kronolithTaskDueTime').setValue(date.toString(Kronolith.conf.time_format));\n        }\n    },\n\n    /**\n     * Finally removes tasks from the DOM and the cache.\n     *\n     * @param string list  A task list name.\n     * @param string task  A task id. If empty, all tasks from the list are\n     *                     deleted.\n     */\n    removeTask: function(list, task)\n    {\n        this.deleteTasksCache(list, task);\n        $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n            return el.retrieve('tasklist') == list &&\n                (!task || el.retrieve('taskid') == task);\n        }).invoke('remove');\n        this.removeEvent('tasklists|tasks/' + list, task ? '_tasks' + task : null);\n        if ($('kronolithViewTasksBody').select('tr').length > 2) {\n            $('kronolithTasksNoItems').hide();\n        } else {\n            $('kronolithTasksNoItems').show();\n        }\n    },\n\n    /**\n     * Submits the task edit form to create or update a task.\n     */\n    saveTask: function()\n    {\n        if (this.wrongFormat.size() ||\n            (($F('kronolithTaskAlarmOn')) && $F('kronolithTaskDueDate').length == 0)) {\n            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');\n            return;\n        }\n\n        var tasklist = $F('kronolithTaskOldList'),\n            target = $F('kronolithTaskList'),\n            taskid = $F('kronolithTaskId'),\n            viewDates = this.viewDates(this.date, this.view),\n            start = viewDates[0].dateString(),\n            end = viewDates[1].dateString();\n\n        HordeImple.AutoCompleter.kronolithTaskTags.shutdown();\n        $('kronolithTaskSave').disable();\n        this.startLoading('tasklists|tasks/' + target, start + end + this.tasktype);\n        this.loading++;\n        HordeCore.doAction(\n            'saveTask',\n            $H($('kronolithTaskForm').serialize({ hash: true })).merge({\n                sig: start + end + this.tasktype,\n                view: this.view,\n                view_start: start,\n                view_end: end\n            }), {\n                callback: function(r) {\n                    if (r.tasks && taskid) {\n                        this.removeTask(tasklist, taskid);\n                    }\n                    this.loadTasksCallback(r, false);\n                    this.loadEventsCallback(r, false);\n                    if (r.tasks) {\n                        this.closeRedBox();\n                        this.go(this.lastLocation);\n                    } else {\n                        $('kronolithTaskSave').enable();\n                    }\n                }.bind(this)\n            }\n        );\n    },\n\n    quickSaveTask: function()\n    {\n        var text = $F('kronolithQuicktaskQ'),\n            viewDates = this.viewDates(this.date, 'tasks'),\n            start = viewDates[0].dateString(),\n            end = viewDates[1].dateString(),\n            params = {\n                sig: start + end + this.tasktype,\n                view: 'tasks',\n                view_start: start,\n                view_end: end,\n                tasklist: Kronolith.conf.tasks.default_tasklist,\n                text: text\n            };\n\n        this.closeRedBox();\n        this.startLoading('tasklists|tasks/' + Kronolith.conf.tasks.default_tasklist,\n                          params.sig);\n        this.loading++;\n        HordeCore.doAction('quickSaveTask', params, {\n            callback: function(r) {\n                this.loadTasksCallback(r, false);\n                this.loadEventsCallback(r, false);\n                if (!r.tasks || !$H(r.tasks).size()) {\n                    this.editTask(null, null, text);\n                } else {\n                    $('kronolithQuicktaskQ').value = '';\n                }\n            }.bind(this)\n         });\n    },\n\n    /**\n     * Opens the form for editing a calendar.\n     *\n     * @param string calendar  Calendar type and calendar id, separated by '|'.\n     */\n    editCalendar: function(calendar)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n\n        var type = calendar.split('|')[0], cal = calendar.split('|')[1];\n        if (!$w('internal tasklists remote holiday resource resourcegroup').include(type)) {\n            return;\n        }\n\n        if (cal &&\n            (Object.isUndefined(Kronolith.conf.calendars[type]) ||\n             Object.isUndefined(Kronolith.conf.calendars[type][cal])) &&\n            (type == 'internal' || type == 'tasklists')) {\n            HordeCore.doAction('getCalendar', {\n                cal: cal\n            }, {\n                callback: function(r) {\n                    if (r.calendar) {\n                        Kronolith.conf.calendars[type][cal] = r.calendar;\n                        this.insertCalendarInList(type, cal, r.calendar);\n                        $('kronolithSharedCalendars').show();\n                        this.editCalendar(type + '|' + cal);\n                    } else {\n                        this.go(this.lastLocation);\n                    }\n                }.bind(this)\n            });\n            return;\n        }\n\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithCalendarForm' + type).focusFirstElement();\n            } catch(e) {}\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n\n        if ($('kronolithCalendarDialog')) {\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithCalendarDialog').show());\n            this.editCalendarCallback(calendar);\n        } else {\n            RedBox.loading();\n            HordeCore.doAction('chunkContent', {\n                chunk: 'calendar'\n            }, {\n                callback: function(r) {\n                    if (r.chunk) {\n                        this.redBoxLoading = true;\n                        RedBox.showHtml(r.chunk);\n                        ['internal', 'tasklists'].each(function(type) {\n                            $('kronolithC' + type + 'PGList').observe('change', function() {\n                                $('kronolithC' + type + 'PG').setValue(1);\n                                this.permsClickHandler(type, 'G');\n                            }.bind(this));\n                        }, this);\n                        this.editCalendarCallback(calendar);\n                    } else {\n                        this.closeRedBox();\n                    }\n                }.bind(this)\n            });\n        }\n    },\n\n    /**\n     * Callback for editing a calendar. Fills the edit form with the correct\n     * values.\n     *\n     * @param string calendar  Calendar type and calendar id, separated by '|'.\n     */\n    editCalendarCallback: function(calendar)\n    {\n        calendar = calendar.split('|');\n        var type = calendar[0];\n        calendar = calendar.length == 1 ? null : calendar[1];\n\n        var form = $('kronolithCalendarForm' + type),\n            firstTab = form.down('.tabset a.kronolithTabLink'),\n            info;\n\n        form.enable();\n        form.reset();\n        if (firstTab) {\n            this.openTab(firstTab);\n        }\n        $('kronolithCalendarDialog').select('.kronolithCalendarDiv').invoke('hide');\n        $('kronolithCalendar' + type + '1').show();\n        form.select('.kronolithCalendarContinue').invoke('enable');\n        $('kronolithC' + type + 'PUNew', 'kronolithC' + type + 'PGNew').compact().each(function(elm) {\n            if (elm.tagName == 'SELECT') {\n                $A(elm.options).each(function(option) {\n                    option.writeAttribute('disabled', false);\n                });\n            }\n        });\n\n        var newCalendar = !calendar;\n        if (calendar &&\n            (Object.isUndefined(Kronolith.conf.calendars[type]) ||\n             Object.isUndefined(Kronolith.conf.calendars[type][calendar]))) {\n            if (type != 'remote') {\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                return;\n            }\n            newCalendar = true;\n        }\n        if (type == 'resourcegroup') {\n            this.updateResourcegroupSelect();\n        }\n        if (newCalendar) {\n            switch (type) {\n            case 'internal':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset();\n                // Fall through.\n            case 'tasklists':\n                $('kronolithCalendar' + type + 'LinkExport').up('span').hide();\n                break;\n            case 'remote':\n                if (calendar) {\n                    $('kronolithCalendarremoteUrl').setValue(calendar);\n                    $('kronolithCalendarremoteId').setValue(calendar);\n                }\n                break;\n            case 'holiday':\n                $('kronolithCalendarholidayDriver').update();\n                $H(Kronolith.conf.calendars.holiday).each(function(calendar) {\n                    if (calendar.value.show) {\n                        return;\n                    }\n                    $('kronolithCalendarholidayDriver').insert(\n                        new Element('option', { value: calendar.key })\n                            .setStyle({ color: calendar.value.fg, backgroundColor: calendar.value.bg })\n                            .insert(calendar.value.name.escapeHTML())\n                    );\n                });\n                break;\n            }\n            $('kronolithCalendar' + type + 'Id').clear();\n            var color = '#', i;\n            for (i = 0; i < 3; i++) {\n                color += (Math.random() * 256 | 0).toColorPart();\n            }\n            $('kronolithCalendar' + type + 'Color').setValue(color).setStyle({ backgroundColor: color, color: Color.brightness(Color.hex2rgb(color)) < 125 ? '#fff' : '#000' });\n            form.down('.kronolithCalendarDelete').hide();\n            $('kronolithCalendarinternalImportButton').hide();\n        } else {\n            info = Kronolith.conf.calendars[type][calendar];\n\n            $('kronolithCalendar' + type + 'Id').setValue(calendar);\n            $('kronolithCalendar' + type + 'Name').setValue(info.name);\n            $('kronolithCalendar' + type + 'Color').setValue(info.bg).setStyle({ backgroundColor: info.bg, color: info.fg });\n            $('kronolithCalendarinternalImportButton').hide();\n\n            switch (type) {\n            case 'internal':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset(Kronolith.conf.calendars.internal[calendar].tg);\n                $('kronolithCalendar' + type + 'ImportCal').setValue('internal_' + calendar);\n                if ($('kronolithCalendar' + type + 'LinkImport')) {\n                    if (info.edit) {\n                        $('kronolithCalendar' + type + 'LinkImport').up('li').show();\n                    } else {\n                        $('kronolithCalendar' + type + 'LinkImport').up('li').hide();\n                    }\n                }\n                $('kronolithCalendar' + type + 'UrlFeed').setValue(info.feed);\n                $('kronolithCalendar' + type + 'EmbedUrl').setValue(info.embed);\n                // Fall through.\n            case 'tasklists':\n                $('kronolithCalendar' + type + 'Description').setValue(info.desc);\n                if ($('kronolithCalendar' + type + 'LinkExport')) {\n                    $('kronolithCalendar' + type + 'LinkExport').up('span').show();\n                    $('kronolithCalendar' + type + 'Export').href = type == 'internal'\n                        ? Kronolith.conf.URI_CALENDAR_EXPORT.interpolate({ calendar: calendar })\n                        : Kronolith.conf.tasks.URI_TASKLIST_EXPORT.interpolate({ tasklist: calendar.substring(6) });\n                }\n                $('kronolithCalendar' + type + 'LinkUrls').up().show();\n                if (info.caldav) {\n                    $('kronolithCalendar' + type + 'UrlCaldav').setValue(info.caldav);\n                    $('kronolithCalendar' + type + 'Caldav').show();\n                } else {\n                    $('kronolithCalendar' + type + 'Caldav').hide();\n                }\n                $('kronolithCalendar' + type + 'UrlWebdav').setValue(info.sub);\n                break;\n            case 'remote':\n                $('kronolithCalendarremoteUrl').setValue(calendar);\n                $('kronolithCalendarremoteDescription').setValue(info.desc);\n                $('kronolithCalendarremoteUsername').setValue(info.user);\n                $('kronolithCalendarremotePassword').setValue(info.password);\n                break;\n            case 'resourcegroup':\n                $('kronolithCalendarresourcegroupDescription').setValue(info.desc);\n                $('kronolithCalendarresourcegroupmembers').setValue(info.members);\n                break;\n            case 'resource':\n                $('kronolithCalendarresourceDescription').setValue(info.desc);\n                $('kronolithCalendarresourceResponseType').setValue(info.response_type);\n                $('kronolithCalendarresourceExport').href = Kronolith.conf.URI_RESOURCE_EXPORT.interpolate({ calendar: calendar });\n            }\n        }\n\n        if (newCalendar || info.owner) {\n            if (type == 'internal' || type == 'tasklists') {\n                this.updateGroupDropDown([['kronolithC' + type + 'PGList', this.updateGroupPerms.bind(this, type)],\n                                          ['kronolithC' + type + 'PGNew']]);\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PNone').setValue(1);\n                if ($('kronolithC' + type + 'PAllShow')) {\n                    $('kronolithC' + type + 'PAllShow').disable();\n                }\n                $('kronolithC' + type + 'PGList').disable();\n                $('kronolithC' + type + 'PGPerms').disable();\n                $('kronolithC' + type + 'PUList').disable();\n                $('kronolithC' + type + 'PUPerms').disable();\n                $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {\n                    return tr.retrieve('remove');\n                }).invoke('remove');\n                $('kronolithCalendar' + type + 'LinkUrls').up().show();\n                form.down('.kronolithColorPicker').show();\n                if (type == 'internal') {\n                    HordeCore.doAction('listTopTags', {}, {\n                        callback: this.topTagsCallback.curry('kronolithCalendarinternalTopTags', 'kronolithCalendarTag')\n                    });\n                }\n                form.down('.kronolithCalendarSubscribe').hide();\n                form.down('.kronolithCalendarUnsubscribe').hide();\n                if ($('kronolithCalendar' + type + 'LinkPerms')) {\n                    $('kronolithCalendar' + type + 'LinkPerms').up('span').show();\n                }\n                if (!Object.isUndefined(info) && info.owner) {\n                    this.setPermsFields(type, info.perms);\n                }\n            }\n            if (type == 'remote' || type == 'internal' || type == 'tasklists') {\n                if (newCalendar ||\n                    (type == 'internal' && calendar == Kronolith.conf.user) ||\n                    (type == 'tasklists' && calendar == 'tasks/' + Kronolith.conf.user)) {\n                    form.select('.kronolithCalendarDelete').invoke('hide');\n                } else {\n                    form.select('.kronolithCalendarDelete').invoke('show');\n                }\n            }\n            form.down('.kronolithCalendarSave').show();\n            form.down('.kronolithFormActions .kronolithSeparator').show();\n        } else {\n            form.disable();\n            form.down('.kronolithColorPicker').hide();\n            form.down('.kronolithCalendarDelete').hide();\n            form.down('.kronolithCalendarSave').hide();\n            if (type == 'internal' || type == 'tasklists') {\n                $('kronolithCalendar' + type + 'UrlCaldav').enable();\n                $('kronolithCalendar' + type + 'UrlAccount').enable();\n                $('kronolithCalendar' + type + 'UrlWebdav').enable();\n                if (type == 'internal') {\n                    $('kronolithCalendar' + type + 'UrlFeed').enable();\n                    $('kronolithCalendar' + type + 'EmbedUrl').enable();\n                    if (info.edit) {\n                        $('kronolithCalendarinternalImport').enable();\n                        if (info.del) {\n                            $('kronolithCalendarinternalImportOver').enable();\n                        }\n                        $('kronolithCalendarinternalImportButton').show().enable();\n                    }\n                }\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.disable();\n                if (Kronolith.conf.calendars[type][calendar].show) {\n                    form.down('.kronolithCalendarSubscribe').hide();\n                    form.down('.kronolithCalendarUnsubscribe').show().enable();\n                } else {\n                    form.down('.kronolithCalendarSubscribe').show().enable();\n                    form.down('.kronolithCalendarUnsubscribe').hide();\n                }\n                form.down('.kronolithFormActions .kronolithSeparator').show();\n                if ($('kronolithCalendar' + type + 'LinkPerms')) {\n                    $('kronolithCalendar' + type + 'LinkPerms').up('span').hide();\n                }\n            } else {\n                form.down('.kronolithFormActions .kronolithSeparator').hide();\n            }\n        }\n    },\n\n    /**\n     * Updates the select list in the resourcegroup calendar dialog.\n     */\n    updateResourcegroupSelect: function()\n    {\n        if (!Kronolith.conf.calendars.resource) {\n            return;\n        }\n        $('kronolithCalendarresourcegroupmembers').update();\n        $H(Kronolith.conf.calendars.resource).each(function(r) {\n            var o = new Element('option', { value: r.value.id }).update(r.value.name);\n            $('kronolithCalendarresourcegroupmembers').insert(o);\n        });\n    },\n\n    /**\n     * Handles clicks on the radio boxes of the basic permissions screen.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     * @param string perm  The permission to activate, 'None', 'All', or\n     *                     'Group'.\n     */\n    permsClickHandler: function(type, perm)\n    {\n        $('kronolithC' + type + 'PAdvanced')\n            .select('input[type=checkbox]')\n            .invoke('setValue', 0);\n        $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {\n            return tr.retrieve('remove');\n        }).invoke('remove');\n\n        switch (perm) {\n        case 'None':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            break;\n        case 'All':\n            $('kronolithC' + type + 'PAllShow').enable();\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            var perms = {\n                'default': Kronolith.conf.perms.read,\n                'guest': Kronolith.conf.perms.read\n            };\n            if ($F('kronolithC' + type + 'PAllShow')) {\n                perms['default'] |= Kronolith.conf.perms.show;\n                perms['guest'] |= Kronolith.conf.perms.show;\n            }\n            this.setPermsFields(type, perms);\n            break;\n        case 'G':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').enable();\n            $('kronolithC' + type + 'PGPerms').enable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            var group = $F('kronolithC' + type + 'PGSingle')\n                ? $F('kronolithC' + type + 'PGSingle')\n                : $F('kronolithC' + type + 'PGList');\n            this.insertGroupOrUser(type, 'group', group, true);\n            $('kronolithC' + type + 'PGshow_' + group).setValue(1);\n            $('kronolithC' + type + 'PGread_' + group).setValue(1);\n            if ($F('kronolithC' + type + 'PGPerms') == 'edit') {\n                $('kronolithC' + type + 'PGedit_' + group).setValue(1);\n            } else {\n                $('kronolithC' + type + 'PGedit_' + group).setValue(0);\n            }\n            $('kronolithC' + type + 'PGdel_' + group).setValue(0);\n            if ($('kronolithC' + type + 'PGdelegate_' + group)) {\n                $('kronolithC' + type + 'PGdelegate_' + group).setValue(0);\n            }\n            break;\n        case 'U':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').enable();\n            $('kronolithC' + type + 'PUPerms').enable();\n            var users = $F('kronolithC' + type + 'PUList').strip();\n            users = users ? users.split(/\\s*(?:,|\\n)\\s*/) : [];\n            users.each(function(user) {\n                if (!this.insertGroupOrUser(type, 'user', user, true)) {\n                    return;\n                }\n                $('kronolithC' + type + 'PUshow_' + user).setValue(1);\n                $('kronolithC' + type + 'PUread_' + user).setValue(1);\n                if ($F('kronolithC' + type + 'PUPerms') == 'edit') {\n                    $('kronolithC' + type + 'PUedit_' + user).setValue(1);\n                } else {\n                    $('kronolithC' + type + 'PUedit_' + user).setValue(0);\n                }\n                $('kronolithC' + type + 'PUdel_' + user).setValue(0);\n                if ($('kronolithC' + type + 'PUdelegate_' + user)) {\n                    $('kronolithC' + type + 'PUdelegate_' + user).setValue(0);\n                }\n            }, this);\n            break;\n        }\n    },\n\n    /**\n     * Populates the permissions field matrix.\n     *\n     * @param string type   The calendar type, 'internal' or 'taskslists'.\n     * @param object perms  An object with the resource permissions.\n     */\n    setPermsFields: function(type, perms)\n    {\n        if (this.groupLoading) {\n            this.setPermsFields.bind(this, type, perms).defer();\n            return;\n        }\n\n        var allperms = $H(Kronolith.conf.perms),\n            advanced = false, users = [],\n            basic, same, groupPerms, groupId, userPerms;\n        $H(perms).each(function(perm) {\n            switch (perm.key) {\n            case 'default':\n            case 'guest':\n                if (Object.isUndefined(same)) {\n                    same = perm.value;\n                } else if (Object.isUndefined(basic) &&\n                           same == perm.value &&\n                           (perm.value == Kronolith.conf.perms.read ||\n                            perm.value == (Kronolith.conf.perms.read | Kronolith.conf.perms.show))) {\n                    basic = perm.value == Kronolith.conf.perms.read ? 'all_read' : 'all_show';\n                } else if (perm.value != 0) {\n                    advanced = true;\n                }\n                break;\n            case 'creator':\n                if (perm.value != 0) {\n                    advanced = true;\n                }\n                break;\n            case 'groups':\n                if (!Object.isArray(perm.value)) {\n                    $H(perm.value).each(function(group) {\n                        if (!this.insertGroupOrUser(type, 'group', group.key)) {\n                            return;\n                        }\n                        if (!$('kronolithC' + type + 'PGshow_' + group.key)) {\n                            // Group doesn't exist anymore.\n                            delete perm.value[group.key];\n                            return;\n                        }\n                        groupPerms = group.value;\n                        groupId = group.key;\n                    }, this);\n                    if (Object.isUndefined(basic) &&\n                        $H(perm.value).size() == 1 &&\n                        (groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||\n                         groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {\n                        basic = groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'group_read' : 'group_edit';\n                    } else {\n                        advanced = true;\n                    }\n                }\n                break;\n            case 'users':\n                if (!Object.isArray(perm.value)) {\n                    $H(perm.value).each(function(user) {\n                        if (user.key != Kronolith.conf.user) {\n                            if (!this.insertGroupOrUser(type, 'user', user.key)) {\n                                return;\n                            }\n                            if (!$('kronolithC' + type + 'PUshow_' + user.key)) {\n                                // User doesn't exist anymore.\n                                delete perm.value[user.key];\n                                return;\n                            }\n                            // Check if we already have other basic permissions.\n                            if (Object.isUndefined(userPerms) &&\n                                !Object.isUndefined(basic)) {\n                                advanced = true;\n                            }\n                            // Check if all users have the same permissions.\n                            if (!Object.isUndefined(userPerms) &&\n                                userPerms != user.value) {\n                                advanced = true;\n                            }\n                            userPerms = user.value;\n                            if (!advanced &&\n                                (userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||\n                                 userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {\n                                basic = userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'user_read' : 'user_edit';\n                                users.push(user.key);\n                            } else {\n                                advanced = true;\n                            }\n                        }\n                    }, this);\n                }\n                break;\n            }\n\n            allperms.each(function(baseperm) {\n                if (baseperm.key == 'all') {\n                    return;\n                }\n                switch (perm.key) {\n                case 'default':\n                case 'guest':\n                case 'creator':\n                    if (baseperm.value & perm.value) {\n                        $('kronolithC' + type + 'P' + perm.key + baseperm.key).setValue(1);\n                    }\n                    break;\n                case 'groups':\n                    $H(perm.value).each(function(group) {\n                        if (baseperm.value & group.value) {\n                            $('kronolithC' + type + 'PG' + baseperm.key + '_' + group.key).setValue(1);\n                        }\n                    });\n                    break;\n                case 'users':\n                    $H(perm.value).each(function(user) {\n                        if (baseperm.value & user.value &&\n                            user.key != Kronolith.conf.user) {\n                            $('kronolithC' + type + 'PU' + baseperm.key + '_' + user.key).setValue(1);\n                        }\n                    });\n                    break;\n                }\n            });\n        }.bind(this));\n\n        if (advanced) {\n            this.activateAdvancedPerms(type);\n        } else {\n            switch (basic) {\n            case 'all_read':\n                $('kronolithC' + type + 'PAll').setValue(1);\n                $('kronolithC' + type + 'PAllShow').setValue(0);\n                $('kronolithC' + type + 'PAllShow').enable();\n                break;\n            case 'all_show':\n                $('kronolithC' + type + 'PAll').setValue(1);\n                $('kronolithC' + type + 'PAllShow').setValue(1);\n                $('kronolithC' + type + 'PAllShow').enable();\n                break;\n            case 'group_read':\n            case 'group_edit':\n                var setGroup = function(group) {\n                    if ($('kronolithC' + type + 'PGList').visible()) {\n                        $('kronolithC' + type + 'PGList').setValue(group);\n                        if ($('kronolithC' + type + 'PGList').getValue() != group) {\n                            // Group no longer exists.\n                            this.permsClickHandler(type, 'None');\n                        }\n                    } else if ($('kronolithC' + type + 'PGSingle').getValue() != group) {\n                        // Group no longer exists.\n                        this.permsClickHandler(type, 'None');\n                    }\n                }.bind(this, groupId);\n                if (this.groupLoading) {\n                    setGroup.defer();\n                } else {\n                    setGroup();\n                }\n                $('kronolithC' + type + 'PG').setValue(1);\n                $('kronolithC' + type + 'PGPerms').setValue(basic.substring(6));\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PGPerms').enable();\n                break;\n            case 'user_read':\n            case 'user_edit':\n                $('kronolithC' + type + 'PUList').enable().setValue(users.join(', '));\n                $('kronolithC' + type + 'PU').setValue(1);\n                $('kronolithC' + type + 'PUPerms').setValue(basic.substring(5));\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PUPerms').enable();\n                break;\n            }\n        }\n   },\n\n    /**\n     * Propagates a SELECT drop down list with the groups.\n     *\n     * @param array params  A two-dimensional array with the following values\n     *                      in each element:\n     *                      - The id of the SELECT element.\n     *                      - A callback method that is invoked with the group\n     *                        list passes as an argument.\n     */\n    updateGroupDropDown: function(params)\n    {\n        this.groupLoading = true;\n        params.each(function(param) {\n            var elm = $(param[0]), options = elm.childElements();\n            options.invoke('remove');\n            elm.up('form').disable();\n        });\n        HordeCore.doAction('listGroups', {}, {\n            callback: function(r) {\n                var groups;\n                if (r.groups) {\n                    groups = $H(r.groups);\n                    params.each(function(param) {\n                        groups.each(function(group) {\n                            $(param[0]).insert(new Element('option', { value: group.key }).update(group.value.escapeHTML()));\n                        });\n                    });\n                }\n                params.each(function(param) {\n                    $(param[0]).up('form').enable();\n                    if (param[1]) {\n                        param[1](groups);\n                    }\n                });\n                this.groupLoading = false;\n            }.bind(this)\n        });\n    },\n\n    /**\n     * Updates the group permission interface after the group list has\n     * been loaded.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     * @param Hash groups  The list of groups.\n     */\n    updateGroupPerms: function(type, groups)\n    {\n        $('kronolithC' + type + 'PGSingle').clear();\n        if (!groups) {\n            $('kronolithC' + type + 'PGNew').up('div').hide();\n            $('kronolithC' + type + 'PG').up('span').hide();\n        } else {\n            $('kronolithC' + type + 'PGNew').up('div').show();\n            $('kronolithC' + type + 'PG').up('span').show();\n            if (groups.size() == 1) {\n                $('kronolithC' + type + 'PGName')\n                    .update('&quot;' + groups.values()[0].escapeHTML() + '&quot;')\n                    .show();\n                $('kronolithC' + type + 'PGSingle').setValue(groups.keys()[0]);\n                $('kronolithC' + type + 'PGList').hide();\n            } else {\n                $('kronolithC' + type + 'PGName').hide();\n                $('kronolithC' + type + 'PGList').show();\n            }\n        }\n    },\n\n    /**\n     * Inserts a group or user row into the advanced permissions interface.\n     *\n     * @param string type          The calendar type, 'internal' or\n     *                             'taskslists'.\n     * @param what string          Either 'group' or 'user'.\n     * @param group string         The group id or user name to insert.\n     *                             Defaults to the value of the drop down.\n     * @param stay_basic boolean   Enforces to NOT switch to the advanced\n     *                             permissions screen.\n     *\n     * @return boolean  Whether a row has been inserted.\n     */\n    insertGroupOrUser: function(type, what, id, stay_basic)\n    {\n        var elm = $(what == 'user' ? 'kronolithC' + type + 'PUNew' : 'kronolithC' + type + 'PGNew');\n        if (id) {\n            elm.setValue(id);\n        }\n        var value = elm.getValue();\n        if (!value) {\n            if (id) {\n                HordeCore.notify(Kronolith.text.invalid_user + ': ' + id, 'horde.error');\n            }\n            return false;\n        }\n\n        var tr = elm.up('tr'),\n            row = tr.clone(true).store('remove', true),\n            td = row.down('td'),\n            clearName = elm.tagName == 'SELECT' ? elm.options[elm.selectedIndex].text: elm.getValue();\n\n        td.update();\n        td.insert(clearName.escapeHTML())\n            .insert(new Element('input', { type: 'hidden', name: (what == 'user' ? 'u' : 'g') + '_names[' + value + ']', value: value }));\n        row.select('input[type=checkbox]').each(function(input) {\n            input.writeAttribute('name', input.name.replace(/\\[.*?$/, '[' + value + ']'))\n                .writeAttribute('id', input.id.replace(/new/, value))\n                .next()\n                .writeAttribute('for', input.id);\n        });\n        tr.insert({ before: row });\n\n        if (elm.tagName == 'SELECT') {\n            elm.options[elm.selectedIndex].writeAttribute('disabled', true);\n            elm.selectedIndex = 0;\n        } else {\n            elm.clear();\n        }\n\n        if (!stay_basic) {\n            this.activateAdvancedPerms(type);\n        }\n\n        return true;\n    },\n\n    /**\n     * Activates the advanced permissions.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     */\n    activateAdvancedPerms: function(type)\n    {\n        [$('kronolithC' + type + 'PNone'),\n         $('kronolithC' + type + 'PU'),\n         $('kronolithC' + type + 'PG')].each(function(radio) {\n            radio.checked = false;\n        });\n        if ($('kronolithC' + type + 'PAll')) {\n            $('kronolithC' + type + 'PAll').checked = false;\n        }\n        $('kronolithC' + type + 'PBasic').hide();\n        $('kronolithC' + type + 'PAdvanced').show();\n    },\n\n    /**\n     * Opens the next screen of the calendar management wizard.\n     *\n     * @param string type  The calendar type.\n     */\n    calendarNext: function(type)\n    {\n        var i = 1;\n        while (!$('kronolithCalendar' + type + i).visible()) {\n            i++;\n        }\n        $('kronolithCalendar' + type + i).hide();\n        $('kronolithCalendar' + type + (++i)).show();\n        if (this.colorPicker) {\n            this.colorPicker.hide();\n        }\n    },\n\n    /**\n     * Submits the calendar form to save the calendar data.\n     *\n     * @param Element form  The form node.\n     *\n     * @return boolean  Whether the save request was successfully sent.\n     */\n    saveCalendar: function(form)\n    {\n        if (this.colorPicker) {\n            this.colorPicker.hide();\n        }\n        var data = form.serialize({ hash: true });\n\n        if (data.type == 'holiday') {\n            this.insertCalendarInList('holiday', data.driver, Kronolith.conf.calendars.holiday[data.driver]);\n            this.toggleCalendar('holiday', data.driver);\n            form.down('.kronolithCalendarSave').enable();\n            this.closeRedBox();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        if (data.name.empty()) {\n            HordeCore.notify(data.type == 'tasklists' ? Kronolith.text.no_tasklist_title : Kronolith.text.no_calendar_title, 'horde.warning');\n            $('kronolithCalendar' + data.type + 'Name').focus();\n            return false;\n        }\n        HordeCore.doAction('saveCalendar', data, {\n            callback: this.saveCalendarCallback.bind(this, form, data)\n        });\n        return true;\n    },\n\n    calendarImport: function(form, disableForm)\n    {\n        if ($F('kronolithCalendarinternalImport')) {\n            HordeCore.notify(Kronolith.text.import_warning, 'horde.message');\n            this.loading++;\n            $('kronolithLoading').show();\n            var name = 'kronolithIframe' + Math.round(Math.random() * 1000),\n                iframe = new Element('iframe', { src: 'about:blank', name: name, id: name }).setStyle({ display: 'none' });\n            document.body.insert(iframe);\n            form.enable();\n            form.target = name;\n            form.submit();\n            if (disableForm) {\n                form.disable();\n            }\n        }\n    },\n\n    /**\n     * Callback method after saving a calendar.\n     *\n     * @param Element form  The form node.\n     * @param object data   The serialized form data.\n     * @param object r      The ajax response object.\n     */\n    saveCalendarCallback: function(form, data, r)\n    {\n        var type = form.id.replace(/kronolithCalendarForm/, '');\n\n        // If saving the calendar changed the owner, we need to delete\n        // and re-insert the calendar.\n        if (r.deleted) {\n            this.deleteCalendar(type, data.calendar);\n            delete data.calendar;\n        }\n        if (r.saved) {\n            this.calendarImport(form, false);\n            var cal = r.calendar, id;\n            if (data.calendar) {\n                var color = {\n                    backgroundColor: cal.bg,\n                    color: cal.fg\n                },\n                legendSpan;\n                id = data.calendar;\n                this.getCalendarList(type, cal.owner).select('div').each(function(element) {\n                    if (element.retrieve('calendar') == id) {\n                        var link = element.down('.horde-resource-link span');\n                        element.setStyle(color);\n                        link.update(cal.name.escapeHTML());\n                        this.addShareIcon(cal, link);\n                        throw $break;\n                    }\n                }, this);\n                this.kronolithBody.select('div').each(function(el) {\n                    if (el.retrieve('calendar') == type + '|' + id) {\n                        el.setStyle(color);\n                    }\n                });\n                legendSpan = $('kronolith-legend').select('span')\n                    .find(function(span) {\n                        return span.retrieve('calendarclass') == type &&\n                            span.retrieve('calendar') == id;\n                    });\n                if (legendSpan) {\n                    legendSpan.setStyle(color).update(cal.name.escapeHTML());\n                }\n                Kronolith.conf.calendars[type][id] = cal;\n            } else {\n                id = r.id;\n                if (!Kronolith.conf.calendars[type]) {\n                    Kronolith.conf.calendars[type] = [];\n                }\n                Kronolith.conf.calendars[type][id] = cal;\n                this.insertCalendarInList(type, id, cal);\n                this.storeCache($H(), [type, id], this.viewDates(this.date, this.view), true);\n                if (type == 'tasklists') {\n                    this.storeTasksCache($H(), this.tasktype, id.replace(/^tasks\\//, ''), true);\n                }\n            }\n            if (type == 'remote') {\n                this.loadCalendar(type, id);\n            }\n        }\n        form.down('.kronolithCalendarSave').enable();\n        this.closeRedBox();\n        this.go(this.lastLocation);\n    },\n\n    /**\n     * Deletes a calendar and all its events from the interface and cache.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    deleteCalendar: function(type, calendar)\n    {\n        var container = this.getCalendarList(type, Kronolith.conf.calendars[type][calendar].owner),\n            noItems = container.previous(),\n            div = container.select('div').find(function(element) {\n                return element.retrieve('calendar') == calendar;\n            }),\n            arrow = div.down('span');\n        arrow.purge();\n        arrow.remove();\n        div.purge();\n        div.remove();\n        if (noItems &&\n            noItems.tagName == 'DIV' &&\n            noItems.className == 'horde-info' &&\n            !container.childElements().size()) {\n            noItems.show();\n        }\n        this.deleteCalendarLegend(type, calendar);\n        this.removeEvent(type + '|' + calendar);\n        this.deleteCache([type, calendar]);\n        if (type == 'tasklists' && this.view == 'tasks') {\n            this.removeTask(calendar.replace(/^tasks\\//, ''));\n        }\n        delete Kronolith.conf.calendars[type][calendar];\n    },\n\n    /**\n     * Parses a date attribute string into a Date object.\n     *\n     * For other strings use Date.parse().\n     *\n     * @param string date  A yyyyMMdd date string.\n     *\n     * @return Date  A date object.\n     */\n    parseDate: function(date)\n    {\n        var d = new Date(date.substr(0, 4), date.substr(4, 2) - 1, date.substr(6, 2));\n        if (date.length == 12) {\n            d.setHours(date.substr(8, 2));\n            d.setMinutes(date.substr(10, 2));\n        }\n        return d;\n    },\n\n    /**\n     * Calculates first and last days being displayed.\n     *\n     * @var Date date    The date of the view.\n     * @var string view  A view name.\n     *\n     * @return array  Array with first and last day of the view.\n     */\n    viewDates: function(date, view)\n    {\n        var start = date.clone(), end = date.clone();\n\n        switch (view) {\n        case 'week':\n        case 'workweek':\n            if (view == 'workweek') {\n                start.add(1).days();\n            }\n            start.moveToBeginOfWeek(view == 'week' ? Kronolith.conf.week_start : 1);\n            end = start.clone();\n            end.moveToEndOfWeek(Kronolith.conf.week_start);\n            if (view == 'workweek') {\n                end.add(Kronolith.conf.week_start == 0 ? -1 : -2).days();\n            }\n            break;\n        case 'month':\n            start.setDate(1);\n            start.moveToBeginOfWeek(Kronolith.conf.week_start);\n            end.moveToLastDayOfMonth();\n            end.moveToEndOfWeek(Kronolith.conf.week_start);\n            break;\n        case 'year':\n            start.setDate(1);\n            start.setMonth(0);\n            end.setMonth(11);\n            end.moveToLastDayOfMonth();\n            break;\n        case 'agenda':\n            end.add(6).days();\n            break;\n        }\n\n        return [start, end];\n    },\n\n    /**\n     * Stores a set of events in the cache.\n     *\n     * For dates in the specified date ranges that don't contain any events,\n     * empty cache entries are created so that those dates aren't re-fetched\n     * each time.\n     *\n     * @param object events        A list of calendars and events as returned\n     *                             from an ajax request.\n     * @param string calendar      A calendar string or array.\n     * @param string dates         A date range in the format yyyymmddyyyymmdd\n     *                             as used in the ajax response signature.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet.\n     */\n    storeCache: function(events, calendar, dates, createCache)\n    {\n        if (Object.isString(calendar)) {\n            calendar = calendar.split('|');\n        }\n\n        // Create cache entry for the calendar.\n        if (!this.ecache.get(calendar[0])) {\n            if (!createCache) {\n                return;\n            }\n            this.ecache.set(calendar[0], $H());\n        }\n        if (!this.ecache.get(calendar[0]).get(calendar[1])) {\n            if (!createCache) {\n                return;\n            }\n            this.ecache.get(calendar[0]).set(calendar[1], $H());\n        }\n        var calHash = this.ecache.get(calendar[0]).get(calendar[1]);\n\n        // Create empty cache entries for all dates.\n        if (!!dates) {\n            var day = dates[0].clone(), date;\n            while (!day.isAfter(dates[1])) {\n                date = day.dateString();\n                if (!calHash.get(date)) {\n                    if (!createCache) {\n                        return;\n                    }\n                    if (!this.cacheStart || this.cacheStart.isAfter(day)) {\n                        this.cacheStart = day.clone();\n                    }\n                    if (!this.cacheEnd || this.cacheEnd.isBefore(day)) {\n                        this.cacheEnd = day.clone();\n                    }\n                    calHash.set(date, $H());\n                }\n                day.add(1).day();\n            }\n        }\n\n        var cal = calendar.join('|');\n        $H(events).each(function(date) {\n            // We might not have a cache for this date if the event lasts\n            // longer than the current view\n            if (!calHash.get(date.key)) {\n                return;\n            }\n\n            // Store calendar string and other useful information in event\n            // objects.\n            $H(date.value).each(function(event) {\n                event.value.calendar = cal;\n                event.value.start = Date.parse(event.value.s);\n                event.value.end = Date.parse(event.value.e);\n            });\n\n            // Store events in cache.\n            calHash.set(date.key, calHash.get(date.key).merge(date.value));\n        });\n    },\n\n    /**\n     * Stores a set of tasks in the cache.\n     *\n     * @param Hash tasks           The tasks to be stored.\n     * @param string tasktypes     The task type that's being stored.\n     * @param string tasklist      The task list to which the tasks belong.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet.\n     */\n    storeTasksCache: function(tasks, tasktypes, tasklist, createCache)\n    {\n        var taskHashes = {}, cacheExists = {};\n\n        if (tasktypes == 'all' || tasktypes == 'future') {\n            tasktypes = [ 'complete', 'incomplete' ];\n        } else {\n            tasktypes = [ tasktypes ];\n        }\n\n        tasktypes.each(function(tasktype) {\n            cacheExists[tasktype] = false;\n            if (!this.tcache.get(tasktype)) {\n                if (!createCache) {\n                    return;\n                }\n                this.tcache.set(tasktype, $H());\n            }\n            if (!tasklist) {\n                return;\n            }\n            if (!this.tcache.get(tasktype).get(tasklist)) {\n                if (!createCache) {\n                    return;\n                }\n                this.tcache.get(tasktype).set(tasklist, $H());\n                cacheExists[tasktype] = true;\n            } else {\n                cacheExists[tasktype] = true;\n            }\n            taskHashes[tasktype] = this.tcache.get(tasktype).get(tasklist);\n        }, this);\n\n        $H(tasks).each(function(task) {\n            var tasktype = task.value.cp ? 'complete' : 'incomplete';\n            if (!cacheExists[tasktype]) {\n                return;\n            }\n            if (!Object.isUndefined(task.value.s)) {\n                task.value.start = Date.parse(task.value.s);\n            }\n            if (!Object.isUndefined(task.value.du)) {\n                task.value.due = Date.parse(task.value.du);\n            }\n            taskHashes[tasktype].set(task.key, task.value);\n        });\n    },\n\n    /**\n     * Deletes an event or a complete calendar from the cache.\n     *\n     * @param string calendar  A calendar string or array.\n     * @param string event     An event ID or empty if deleting the calendar.\n     * @param string day       A specific day to delete in yyyyMMdd form.\n     */\n    deleteCache: function(calendar, event, day)\n    {\n        if (Object.isString(calendar)) {\n            calendar = calendar.split('|');\n        }\n        if (!this.ecache.get(calendar[0]) ||\n            !this.ecache.get(calendar[0]).get(calendar[1])) {\n            return;\n        }\n        if (event) {\n            this.ecache.get(calendar[0]).get(calendar[1]).each(function(day) {\n                day.value.unset(event);\n            });\n        } else if (day) {\n            this.ecache.get(calendar[0]).get(calendar[1]).unset(day);\n        } else {\n            this.ecache.get(calendar[0]).unset(calendar[1]);\n        }\n    },\n\n    /**\n     * Deletes tasks from the cache.\n     *\n     * @param string list  A task list string.\n     * @param string task  A task ID. If empty, all tasks from the list are\n     *                     deleted.\n     */\n    deleteTasksCache: function(list, task)\n    {\n        this.deleteCache([ 'external', 'tasks/' + list ], task);\n        $w('complete incomplete').each(function(type) {\n            if (!Object.isUndefined(this.tcache.get(type)) &&\n                !Object.isUndefined(this.tcache.get(type).get(list))) {\n                if (task) {\n                    this.tcache.get(type).get(list).unset(task);\n                } else {\n                    this.tcache.get(type).unset(list);\n                }\n            }\n        }, this);\n    },\n\n    /**\n     * Return all events for a single day from all displayed calendars merged\n     * into a single hash.\n     *\n     * @param string date  A yyyymmdd date string.\n     *\n     * @return Hash  An event hash which event ids as keys and event objects as\n     *               values.\n     */\n    getCacheForDate: function(date, calendar)\n    {\n        if (calendar) {\n            var cals = calendar.split('|');\n            if (!this.ecache.get(cals[0]) ||\n                !this.ecache.get(cals[0]).get(cals[1])) {\n                return $H();\n            }\n            var x = this.ecache.get(cals[0]).get(cals[1]).get(date);\n            return this.ecache.get(cals[0]).get(cals[1]).get(date);\n        }\n\n        var events = $H();\n        this.ecache.each(function(type) {\n            type.value.each(function(cal) {\n                if (!Kronolith.conf.calendars[type.key][cal.key].show) {\n                    return;\n                }\n                events = events.merge(cal.value.get(date));\n            });\n        });\n        return events;\n    },\n\n    /**\n     * Helper method for Enumerable.sortBy to sort events first by start time,\n     * second by end time reversed.\n     *\n     * @param Hash event  A hash entry with the event object as the value.\n     *\n     * @return string  A comparable string.\n     */\n    sortEvents: function(event)\n    {\n        return event.value.sort;\n    },\n\n    /**\n     * Adds a new location to the history and displays it in the URL hash.\n     *\n     * This is not really a history, because only the current and the last\n     * location are stored.\n     *\n     * @param string loc    The location to save.\n     * @param boolean save  Whether to actually save the location. This should\n     *                      be false for any location that are displayed on top\n     *                      of another location, i.e. in a popup view.\n     */\n    addHistory: function(loc, save)\n    {\n        location.hash = encodeURIComponent(loc);\n        this.lastLocation = this.currentLocation;\n        if (Object.isUndefined(save) || save) {\n            this.currentLocation = loc;\n        }\n        this.openLocation = loc;\n    },\n\n    /**\n     * Loads an external page.\n     *\n     * @param string loc  The URL of the page to load.\n     */\n    loadPage: function(loc)\n    {\n        window.location.assign(loc);\n    },\n\n    searchSubmit: function(e)\n    {\n        this.go('search:' + this.search + ':' + $F('horde-search-input'));\n    },\n\n    searchReset: function(e)\n    {\n        HordeTopbar.searchGhost.reset();\n    },\n\n    /**\n     * Event handler for HordeCore:showNotifications events.\n     */\n    showNotification: function(e)\n    {\n        if (!e.memo.flags ||\n            !e.memo.flags.alarm ||\n            !e.memo.flags.growl ||\n            !e.memo.flags.alarm.params.notify.ajax) {\n            return;\n        }\n\n        var growl = e.memo.flags.growl, link = growl.down('A');\n\n        if (link) {\n            link.observe('click', function(ee) {\n                ee.stop();\n                HordeCore.Growler.ungrowl(growl);\n                this.go(e.memo.flags.alarm.params.notify.ajax);\n            }.bind(this));\n        }\n    },\n\n    /* Keydown event handler */\n    keydownHandler: function(e)\n    {\n        if (e.stopped) {\n            return;\n        }\n\n        var kc = e.keyCode || e.charCode,\n            form = e.findElement('FORM'), trigger = e.findElement();\n\n        switch (trigger.id) {\n        case 'kronolithEventLocation':\n            if (kc == Event.KEY_RETURN && $F('kronolithEventLocation')) {\n                this.initializeMap(true);\n                this.geocode($F('kronolithEventLocation'));\n                e.stop();\n                return;\n            }\n            break;\n\n        case 'kronolithCalendarinternalUrlCaldav':\n        case 'kronolithCalendarinternalUrlWebdav':\n        case 'kronolithCalendarinternalUrlAccount':\n        case 'kronolithCalendarinternalUrlFeed':\n        case 'kronolithCalendartasklistsUrlCaldav':\n        case 'kronolithCalendartasklistsUrlWebdav':\n        case 'kronolithCalendartasklistsUrlAccount':\n            if (String.fromCharCode(kc) != 'C' ||\n                (this.macos && !e.metaKey) ||\n                (!this.macos && !e.ctrlKey)) {\n                e.stop();\n                return;\n            }\n            break;\n        }\n\n        if (form) {\n            switch (kc) {\n            case Event.KEY_RETURN:\n                switch (form.identify()) {\n                case 'kronolithEventForm':\n                    if (e.element().tagName != 'TEXTAREA') {\n                        this.saveEvent();\n                        e.stop();\n                    }\n                    break;\n\n                case 'kronolithTaskForm':\n                    if (e.element().tagName != 'TEXTAREA') {\n                        this.saveTask();\n                        e.stop();\n                    }\n                    break;\n\n                case 'kronolithQuickinsertForm':\n                    this.quickSaveEvent();\n                    e.stop();\n                    break;\n\n                case 'kronolithCalendarForminternal':\n                case 'kronolithCalendarFormtasklists':\n                case 'kronolithCalendarFormremote':\n                    // Disabled for now, we have to also catch Continue buttons.\n                    //var saveButton = form.down('.kronolithCalendarSave');\n                    //saveButton.disable();\n                    //if (!this.saveCalendar(form)) {\n                    //    saveButton.enable();\n                    //}\n                    //e.stop();\n                    break;\n                }\n                break;\n\n            case Event.KEY_ESC:\n                switch (form.identify()) {\n                case 'kronolithQuickinsertForm':\n                case 'kronolithQuicktaskForm':\n                    this.quickClose();\n                    break;\n                case 'kronolithEventForm':\n                case 'kronolithTaskForm':\n                    Horde_Calendar.hideCal();\n                    this.closeRedBox();\n                    this.go(this.lastLocation);\n                    break;\n                }\n                break;\n            }\n\n            return;\n        }\n\n        switch (kc) {\n        case Event.KEY_ESC:\n            Horde_Calendar.hideCal();\n            this.closeRedBox();\n            break;\n        }\n    },\n\n    keyupHandler: function(e)\n    {\n        switch (e.element().readAttribute('id')) {\n        case 'kronolithEventLocation':\n            if ($F('kronolithEventLocation') && Kronolith.conf.maps.driver) {\n                $('kronolithEventMapLink').show();\n            } else if (Kronolith.conf.maps.driver) {\n                $('kronolithEventMapLink').hide();\n                this.removeMapMarker();\n            }\n            return;\n\n        case 'kronolithEventStartTime':\n        case 'kronolithEventEndTime':\n            var field = $(e.element().readAttribute('id')), kc = e.keyCode;\n\n            switch(e.keyCode) {\n            case Event.KEY_UP:\n            case Event.KEY_DOWN:\n            case Event.KEY_RIGHT:\n            case Event.KEY_LEFT:\n                return;\n            default:\n                if ($F(field) !== this.knl[field.identify()].getCurrentEntry()) {\n                    this.knl[field.identify()].markSelected(null);\n                }\n                return;\n            }\n        }\n\n    },\n\n    clickHandler: function(e, dblclick)\n    {\n        if (e.isRightClick() || typeof e.element != 'function') {\n            return;\n        }\n\n        var elt = e.element(),\n            orig = e.element(),\n            id, tmp, calendar;\n\n        while (Object.isElement(elt)) {\n            id = elt.readAttribute('id');\n\n            switch (id) {\n            case 'kronolithNewEvent':\n                this.go('event');\n                e.stop();\n                return;\n\n            case 'kronolithNewTask':\n                this.go('task');\n                e.stop();\n                return;\n\n            case 'kronolithQuickEvent':\n                if (this.view == 'tasks') {\n                    RedBox.showHtml($('kronolithQuicktask').show());\n                } else {\n                    this.updateCalendarDropDown('kronolithQuickinsertCalendars');\n                    $('kronolithQuickinsertCalendars').setValue(Kronolith.conf.default_calendar);\n                    RedBox.showHtml($('kronolithQuickinsert').show());\n                }\n                e.stop();\n                return;\n\n            case 'kronolithQuickinsertSave':\n                this.quickSaveEvent();\n                e.stop();\n                return;\n\n            case 'kronolithQuicktaskSave':\n                this.quickSaveTask();\n                e.stop();\n                return;\n\n            case 'kronolithQuickinsertCancel':\n            case 'kronolithQuicktaskCancel':\n                this.quickClose();\n                e.stop();\n                return;\n\n            case 'kronolithGotoToday':\n                var view = this.view;\n                if (!$w('day workweek week month year agenda').include(view)) {\n                    view = Kronolith.conf.login_view;\n                }\n                this.go(view + ':' + new Date().dateString());\n                e.stop();\n                return;\n\n            case 'kronolithEventAllday':\n                this.toggleAllDay();\n                break;\n\n            case 'kronolithEventAlarmDefaultOn':\n                this.disableAlarmMethods('Event');\n                break;\n\n            case 'kronolithTaskAlarmDefaultOn':\n                this.disableAlarmMethods('Task');\n                break;\n\n            case 'kronolithEventAlarmPrefs':\n                HordeCore.redirect(HordeCore.addURLParam(\n                    Kronolith.conf.prefs_url,\n                    {\n                        group: 'notification'\n                    }\n                ));\n                e.stop();\n                break;\n\n            case 'kronolithTaskAlarmPrefs':\n                if (Kronolith.conf.tasks.prefs_url) {\n                    HordeCore.redirect(HordeCore.addURLParam(\n                        Kronolith.conf.tasks.prefs_url,\n                        {\n                            group: 'notification'\n                        }\n                    ));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithEventLinkNone':\n            case 'kronolithEventLinkDaily':\n            case 'kronolithEventLinkWeekly':\n            case 'kronolithEventLinkMonthly':\n            case 'kronolithEventLinkYearly':\n            case 'kronolithEventLinkLength':\n            case 'kronolithTaskLinkNone':\n            case 'kronolithTaskLinkDaily':\n            case 'kronolithTaskLinkWeekly':\n            case 'kronolithTaskLinkMonthly':\n            case 'kronolithTaskLinkYearly':\n            case 'kronolithTaskLinkLength':\n                this.toggleRecurrence(\n                    id.startsWith('kronolithEvent'),\n                    id.substring(id.startsWith('kronolithEvent') ? 18 : 17));\n                break;\n\n            case 'kronolithEventRepeatDaily':\n            case 'kronolithEventRepeatWeekly':\n            case 'kronolithEventRepeatMonthly':\n            case 'kronolithEventRepeatYearly':\n            case 'kronolithEventRepeatLength':\n            case 'kronolithTaskRepeatDaily':\n            case 'kronolithTaskRepeatWeekly':\n            case 'kronolithTaskRepeatMonthly':\n            case 'kronolithTaskRepeatYearly':\n            case 'kronolithTaskRepeatLength':\n                this.toggleRecurrence(\n                    id.startsWith('kronolithEvent'),\n                    id.substring(id.startsWith('kronolithEvent') ? 20 : 19));\n                break;\n\n            case 'kronolithEventSave':\n                if (!elt.disabled) {\n                    this._checkDate($('kronolithEventStartDate'));\n                    this._checkDate($('kronolithEventEndDate'));\n                    if ($F('kronolithEventAttendees') && $F('kronolithEventId')) {\n                        $('kronolithEventSendUpdates').setValue(0);\n                        $('kronolithEventDiv').hide();\n                        $('kronolithUpdateDiv').show();\n                        e.stop();\n                        break;\n                    }\n                }\n            case 'kronolithEventSendUpdateYes':\n                if (this.uatts) {\n                    this.uatts.u = true;\n                } else {\n                    $('kronolithEventSendUpdates').setValue(1);\n                }\n            case 'kronolithEventSendUpdateNo':\n                if (this.uatts) {\n                    this.doDragDropUpdate(this.uatts, this.ucb);\n                    this.uatts = null;\n                    this.ucb = null;\n                    this.closeRedBox();\n                    $('kronolithUpdateDiv').hide();\n                    $('kronolithEventDiv').show();\n                } else if (!elt.disabled) {\n                    this.saveEvent();\n                }\n                e.stop();\n                break;\n            case 'kronolithEventConflictYes':\n                this.doSaveEvent();\n                e.stop();\n                break;\n            case 'kronolithEventConflictNo':\n                $('kronolithConflictDiv').hide();\n                $('kronolithEventDiv').show();\n                e.stop();\n                break;\n            case 'kronolithEventSaveAsNew':\n                if (!elt.disabled) {\n                    $('kronolithEventSendUpdates').setValue(1);\n                    this.saveEvent(true);\n                }\n                e.stop();\n                break;\n\n            case 'kronolithTaskSave':\n                if (!elt.disabled) {\n                    this.saveTask();\n                }\n                e.stop();\n                break;\n\n            case 'kronolithEventDeleteCancel':\n                $('kronolithDeleteDiv').hide();\n                $('kronolithEventDiv').show();\n                e.stop();\n                return;\n\n            case 'kronolithEventSendCancellationYes':\n                $('kronolithRecurDeleteAll').enable();\n                $('kronolithRecurDeleteCurrent').enable();\n                $('kronolithRecurDeleteFuture').enable();\n                this.paramsCache.sendupdates = 1;\n            case 'kronolithEventSendCancellationNo':\n                $('kronolithRecurDeleteAll').enable();\n                $('kronolithRecurDeleteCurrent').enable();\n                $('kronolithRecurDeleteFuture').enable();\n                $('kronolithCancellationDiv').hide();\n                this.delete_verified = true;\n            case 'kronolithEventDelete':\n                if ((Kronolith.conf.confirm_delete || this.recurs) && !this.delete_verified) {\n                    $('kronolithEventDiv').hide();\n                    $('kronolithDeleteDiv').show();\n                    e.stop();\n                    break;\n                } else {\n                    $('kronolithEventDiv').hide();\n                    this.delete_verified = false;\n                }\n                // Fallthrough\n            case 'kronolithRecurDeleteAll':\n            case 'kronolithRecurDeleteCurrent':\n            case 'kronolithRecurDeleteFuture':\n            case 'kronolithEventDeleteConfirm':\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n                elt.disable();\n                var cal = $F('kronolithEventCalendar'),\n                    eventid = $F('kronolithEventId');\n                if (id != 'kronolithEventSendCancellationNo' &&\n                    id != 'kronolithEventSendCancellationYes') {\n                    this.paramsCache = {\n                        cal: cal,\n                        id: eventid,\n                        rstart: $F('kronolithEventRecurOStart'),\n                        cstart: this.cacheStart.toISOString(),\n                        cend: this.cacheEnd.toISOString()\n                    };\n                    switch (id) {\n                    case 'kronolithRecurDeleteAll':\n                        this.paramsCache.r = 'all';\n                        break;\n                    case 'kronolithRecurDeleteCurrent':\n                        this.paramsCache.r = 'current';\n                        break;\n                    case 'kronolithRecurDeleteFuture':\n                        this.paramsCache.r = 'future';\n                        break;\n                    }\n                }\n\n                if (id != 'kronolithEventSendCancellationNo'\n                    && id != 'kronolithEventSendCancellationYes'\n                    && $F('kronolithEventAttendees')) {\n\n                    $('kronolithDeleteDiv').hide();\n                    $('kronolithCancellationDiv').show();\n                    e.stop();\n                    break;\n                }\n\n                this.kronolithBody.select('div').findAll(function(el) {\n                    return el.retrieve('calendar') == cal &&\n                        el.retrieve('eventid') == eventid;\n                }).invoke('hide');\n                var viewDates = this.viewDates(this.date, this.view),\n                start = viewDates[0].toString('yyyyMMdd'),\n                end = viewDates[1].toString('yyyyMMdd');\n                this.paramsCache.sig = start + end + (Math.random() + '').slice(2);\n                this.paramsCache.view_start = start;\n                this.paramsCache.view_end = end;\n\n                HordeCore.doAction('deleteEvent', this.paramsCache, {\n                    callback: function(elt,r) {\n                        if (r.deleted) {\n                            var days;\n                            if (this.view == 'month' ||\n                                this.view == 'week' ||\n                                this.view == 'workweek' ||\n                                this.view == 'day') {\n                                days = this.findEventDays(cal, eventid);\n                                days.each(function(day) {\n                                    this.refreshResources(day, cal, eventid);\n                                }.bind(this));\n                            }\n                            this.removeEvent(cal, eventid);\n                            if (r.uid) {\n                                this.removeException(cal, r.uid);\n                            }\n                            this.loadEventsCallback(r, false);\n                            if (days && days.length) {\n                                this.reRender(days);\n                            }\n                        } else {\n                            this.kronolithBody.select('div').findAll(function(el) {\n                                return el.retrieve('calendar') == cal &&\n                                       el.retrieve('eventid') == eventid;\n                            }).invoke('show');\n                        }\n                        elt.enable();\n                    }.curry(elt).bind(this)\n                });\n\n                $('kronolithDeleteDiv').hide();\n                $('kronolithEventDiv').show();\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithTaskDelete':\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n\n                elt.disable();\n                var tasklist = $F('kronolithTaskOldList'),\n                    taskid = $F('kronolithTaskId');\n\n                HordeCore.doAction('deleteTask', {\n                    list: tasklist,\n                    id: taskid\n                }, {\n                    callback: function(r) {\n                        if (r.deleted) {\n                            this.removeTask(tasklist, taskid);\n                        } else {\n                            elt.enable();\n                            $('kronolithViewTasksBody').select('tr').find(function(el) {\n                                return el.retrieve('tasklist') == tasklist &&\n                                       el.retrieve('taskid') == taskid;\n                            }).toggle();\n                        }\n                    }.bind(this)\n                });\n\n                var taskrow = $('kronolithViewTasksBody').select('tr').find(function(el) {\n                    return el.retrieve('tasklist') == tasklist &&\n                        el.retrieve('taskid') == taskid;\n                });\n                if (taskrow) {\n                    taskrow.hide();\n                }\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithCinternalPMore':\n            case 'kronolithCinternalPLess':\n            case 'kronolithCtasklistsPMore':\n            case 'kronolithCtasklistsPLess':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                $('kronolithC' + type + 'PBasic').toggle();\n                $('kronolithC' + type + 'PAdvanced').toggle();\n                e.stop();\n                break;\n\n            case 'kronolithCinternalPNone':\n            case 'kronolithCinternalPAll':\n            case 'kronolithCinternalPG':\n            case 'kronolithCinternalPU':\n            case 'kronolithCtasklistsPNone':\n            case 'kronolithCtasklistsPAll':\n            case 'kronolithCtasklistsPG':\n            case 'kronolithCtasklistsPU':\n                var info = id.match(/kronolithC(.*)P(.*)/);\n                this.permsClickHandler(info[1], info[2]);\n                break;\n\n            case 'kronolithCinternalPAllShow':\n            case 'kronolithCtasklistsPAllShow':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                this.permsClickHandler(type, 'All');\n                break;\n\n            case 'kronolithCinternalPAdvanced':\n            case 'kronolithCtasklistsPAdvanced':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                if (orig.tagName != 'INPUT') {\n                    break;\n                }\n                this.activateAdvancedPerms(type);\n                if (orig.name.match(/u_.*||new/)) {\n                    this.insertGroupOrUser(type, 'user');\n                }\n                break;\n\n            case 'kronolithCinternalPUAdd':\n            case 'kronolithCinternalPGAdd':\n            case 'kronolithCtasklistsPUAdd':\n            case 'kronolithCtasklistsPGAdd':\n                var info = id.match(/kronolithC(.*)P(.)/);\n                this.insertGroupOrUser(info[1], info[2] == 'U' ? 'user' : 'group');\n                break;\n\n            case 'kronolithNavDay':\n            case 'kronolithNavWeek':\n            case 'kronolithNavWorkweek':\n            case 'kronolithNavMonth':\n            case 'kronolithNavYear':\n            case 'kronolithNavAgenda':\n                this.go(id.substring(12).toLowerCase() + ':' + this.date.dateString());\n                e.stop();\n                return;\n\n            case 'kronolithNavTasks':\n                this.go('tasks');\n                e.stop();\n                return;\n\n            case 'kronolithTasksAll':\n            case 'kronolithTasksComplete':\n            case 'kronolithTasksIncomplete':\n            case 'kronolithTasksFuture':\n                this.go('tasks:' + id.substring(14).toLowerCase());\n                e.stop();\n                return;\n\n            case 'kronolithMinicalDate':\n                this.go('month:' + orig.retrieve('date'));\n                e.stop();\n                return;\n\n            case 'kronolith-minical':\n                if (orig.id == 'kronolith-minical-prev') {\n                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));\n                    date.previous().month();\n                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : undefined);\n                    e.stop();\n                    return;\n                }\n                if (orig.id == 'kronolith-minical-next') {\n                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));\n                    date.next().month();\n                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : null);\n                    e.stop();\n                    return;\n                }\n\n                var tmp = orig;\n                if (tmp.tagName.toLowerCase() != 'td') {\n                    tmp = tmp.up('td');\n                }\n                if (tmp) {\n                    if (tmp.retrieve('weekdate') &&\n                        tmp.hasClassName('kronolith-minical-week')) {\n                        this.go('week:' + tmp.retrieve('weekdate'));\n                    } else if (tmp.retrieve('date') &&\n                               !tmp.hasClassName('empty')) {\n                        this.go('day:' + tmp.retrieve('date'));\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithEventsDay':\n                var date = this.date.clone();\n                date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / this.daySizes.height * 2) * 30).minutes();\n                this.go('event:' + date.toString('yyyyMMddHHmm'));\n                e.stop();\n                return;\n\n            case 'kronolithViewMonth':\n                if (orig.hasClassName('kronolith-first-col')) {\n                    var date = orig.retrieve('date');\n                    if (date) {\n                        this.go('week:' + date);\n                        e.stop();\n                        return;\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithViewYear':\n                var tmp = orig;\n                if (tmp.tagName.toLowerCase() != 'td' && tmp.tagName.toLowerCase() != 'th') {\n                    tmp = tmp.up('td');\n                }\n                if (tmp) {\n                    if (tmp.retrieve('weekdate') &&\n                        tmp.hasClassName('kronolith-minical-week')) {\n                        this.go('week:' + tmp.retrieve('weekdate'));\n                    } else if (tmp.hasClassName('kronolithMinicalDate')) {\n                        this.go('month:' + tmp.retrieve('date'));\n                    } else if (tmp.retrieve('date') &&\n                               !tmp.hasClassName('empty')) {\n                        this.go('day:' + tmp.retrieve('date'));\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithViewAgendaBody':\n                var tmp = orig;\n                if (tmp.tagName != 'TR') {\n                    tmp = tmp.up('tr');\n                }\n                if (tmp && tmp.retrieve('date')) {\n                    this.go('day:' + tmp.retrieve('date'));\n                }\n                e.stop();\n                return;\n\n            case 'kronolithSearchButton':\n                this.go('search:' + this.search + ':' + $F('horde-search-input'));\n                e.stop();\n                break;\n\n            case 'kronolithSearchFuture':\n                if (this.search != 'future') {\n                    this.go('search:future:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithSearchPast':\n                if (this.search != 'past') {\n                    this.go('search:past:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithSearchAll':\n                if (this.search != 'all') {\n                    this.go('search:all:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n            case 'kronolithEventToTimeslice':\n                var params = $H();\n                params.set('e', $('kronolithEventId').value);\n                params.set('cal', $('kronolithEventCalendar').value);\n                params.set('t', $('kronolithEventTimesliceType').value);\n                params.set('c', $('kronolithEventTimesliceClient').value);\n                HordeCore.doAction('toTimeslice', params);\n                break;\n            case 'kronolithEventDialog':\n            case 'kronolithTaskDialog':\n                Horde_Calendar.hideCal();\n                return;\n\n            case 'kronolithCalendarDialog':\n                if (this.colorPicker) {\n                    this.colorPicker.hide();\n                }\n                return;\n\n            case 'kronolithEditRecurCurrent':\n            case 'kronolithEditRecurFuture':\n                $('kronolithEventStartDate').setValue(this.orstart);\n                $('kronolithEventEndDate').setValue(this.orend);\n                if (id == 'kronolithEditRecurCurrent') {\n                    this.toggleRecurrence('Exception');\n                } else {\n                    this.toggleRecurrence(this.lastRecurType);\n                }\n                return;\n            case 'kronolithEditRecurAll':\n                this.toggleRecurrence(this.lastRecurType);\n                break;\n            case 'kronolithEventUrlToggle':\n                $('kronolithEventUrlDisplay').hide();\n                $('kronolithEventUrl').show();\n                e.stop();\n                return;\n            case 'kronolithCalendarinternalImportButton':\n                // Used when user has edit perms to a shared calendar.\n                this.calendarImport(elt.up('form'), true);\n                break;\n            }\n\n            // Caution, this only works if the element has definitely only a\n            // single CSS class.\n            switch (elt.className) {\n            case 'kronolithPrev':\n            case 'kronolithNext':\n                var newDate = this.date.clone(),\n                    offset = elt.className == 'kronolithPrev' ? -1 : 1;\n                switch (this.view) {\n                case 'day':\n                case 'agenda':\n                    newDate.add(offset).day();\n                    break;\n                case 'week':\n                case 'workweek':\n                    newDate.add(offset).week();\n                    break;\n                case 'month':\n                    newDate.add(offset).month();\n                    break;\n                case 'year':\n                    newDate.add(offset).year();\n                    break;\n                }\n                this.go(this.view + ':' + newDate.dateString());\n                e.stop();\n                return;\n\n            case 'horde-add':\n                this.go('calendar:' + id.replace(/kronolithAdd/, ''));\n                e.stop();\n                return;\n\n            case 'kronolithTabLink':\n                this.openTab(elt);\n                e.stop();\n                break;\n\n            case 'horde-cancel':\n                this.closeRedBox();\n                this.resetMap();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithEventTag':\n                HordeImple.AutoCompleter.kronolithEventTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithCalendarTag':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithTaskTag':\n                HordeImple.AutoCompleter.kronolithTaskTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithEventGeo':\n                this.initializeMap(true);\n                this.geocode($F('kronolithEventLocation'));\n                e.stop();\n                break;\n\n            case 'kronolithTaskRow':\n                if (elt.retrieve('taskid')) {\n                    this.go('task:' + elt.retrieve('tasklist') + ':' + elt.retrieve('taskid'));\n                }\n                e.stop();\n                return;\n\n            case 'horde-resource-edit-000':\n            case 'horde-resource-edit-fff':\n                this.go('calendar:' + elt.up().retrieve('calendarclass') + '|' + elt.up().retrieve('calendar'));\n                e.stop();\n                return;\n\n            case 'kronolithMore':\n                this.go('day:' + elt.retrieve('date'));\n                e.stop();\n                return;\n\n            case 'kronolithDatePicker':\n                id = elt.readAttribute('id');\n                Horde_Calendar.open(id, Date.parseExact($F(id.replace(/Picker$/, 'Date')), Kronolith.conf.date_format));\n                e.stop();\n                return;\n\n            case 'kronolithColorPicker':\n                var input = elt.previous();\n                this.colorPicker = new ColorPicker({\n                    color: $F(input),\n                    offsetParent: elt,\n                    update: [[input, 'value'],\n                             [input, 'background']]\n                });\n                e.stop();\n                return;\n            }\n\n            if (elt.hasClassName('kronolith-event')) {\n                if (!Object.isUndefined(elt.retrieve('ajax'))) {\n                    this.go(elt.retrieve('ajax'));\n                } else {\n                    this.go('event:' + elt.retrieve('calendar') + ':' + elt.retrieve('eventid') + ':' + elt.up().retrieve('date'));\n                }\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithMonthDay')) {\n                if (orig.hasClassName('kronolith-day')) {\n                    var date = orig.retrieve('date');\n                    if (date) {\n                        this.go('day:' + date);\n                        e.stop();\n                        return;\n                    }\n                }\n                this.go('event:' + elt.retrieve('date'));\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithWeekDay')) {\n                this.go('day:' + elt.retrieve('date'));\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithEventsWeek') ||\n                       elt.hasClassName('kronolithEventsWorkweek') ||\n                       elt.hasClassName('kronolithAllDayContainer')) {\n                var date = elt.retrieve('date');\n                if (elt.hasClassName('kronolithAllDayContainer')) {\n                    date += 'all';\n                } else {\n                    date = this.parseDate(date);\n                    date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / (elt.hasClassName('kronolithEventsWeek') ? this.weekSizes.height : this.workweekSizes.height) * 2) * 30).minutes();\n                    date = date.toString('yyyyMMddHHmm');\n                }\n                this.go('event:' + date);\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithTaskCheckbox')) {\n                var taskid = elt.up('tr.kronolithTaskRow', 0).retrieve('taskid'),\n                    tasklist = elt.up('tr.kronolithTaskRow', 0).retrieve('tasklist');\n                this.toggleCompletionClass(taskid);\n\n                HordeCore.doAction('toggleCompletion', {\n                    list: tasklist,\n                    id: taskid\n                }, {\n                    callback: function(r) {\n                        if (r.toggled) {\n                            this.toggleCompletion(tasklist, taskid, r.toggled);\n                            if (r.toggled !== true) {\n                                this.toggleCompletionClass(taskid);\n                            }\n                        } else {\n                            this.toggleCompletionClass(taskid);\n                        }\n                    }.bind(this)\n                });\n\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithCalendarSave')) {\n                if (!elt.disabled) {\n                    elt.disable();\n                    if (!this.saveCalendar(elt.up('form'))) {\n                        elt.enable();\n                    }\n                }\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarContinue')) {\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n\n                elt.disable();\n                var form = elt.up('form'),\n                    type = form.id.replace(/kronolithCalendarForm/, ''),\n                    i = 1;\n                while (!$('kronolithCalendar' + type + i).visible()) {\n                    i++;\n                }\n                if (type == 'remote') {\n                    var params = { url: $F('kronolithCalendarremoteUrl') };\n                    if (i == 1) {\n                        if (!$F('kronolithCalendarremoteUrl')) {\n                            HordeCore.notify(Kronolith.text.no_url, 'horde.warning');\n                            e.stop();\n                            break;\n                        }\n\n                        HordeCore.doAction('getRemoteInfo', params, {\n                            asynchronous: false,\n                            callback: function(r) {\n                                if (r.success) {\n                                    if (r.name) {\n                                        $('kronolithCalendarremoteName').setValue(r.name);\n                                    }\n                                    if (r.desc) {\n                                        $('kronolithCalendarremoteDescription').setValue(r.desc);\n                                    }\n                                    this.calendarNext(type);\n                                    this.calendarNext(type);\n                                } else if (r.auth) {\n                                    this.calendarNext(type);\n                                } else {\n                                    elt.enable();\n                                }\n                            }.bind(this)\n                        });\n\n                    }\n                    if (i == 2) {\n                        if ($F('kronolithCalendarremoteUsername')) {\n                            params.user = $F('kronolithCalendarremoteUsername');\n                            params.password =  $F('kronolithCalendarremotePassword');\n                        }\n\n                        HordeCore.doAction('getRemoteInfo', params, {\n                            callback: function(r) {\n                                if (r.success) {\n                                    if (r.name &&\n                                        !$F('kronolithCalendarremoteName')) {\n                                        $('kronolithCalendarremoteName').setValue(r.name);\n                                    }\n                                    if (r.desc &&\n                                        !$F('kronolithCalendarremoteDescription')) {\n                                        $('kronolithCalendarremoteDescription').setValue(r.desc);\n                                    }\n                                    this.calendarNext(type);\n                                } else {\n                                    if (r.auth) {\n                                        HordeCore.notify(Kronolith.text.wrong_auth, 'horde.warning');\n                                    }\n                                    elt.enable();\n                                }\n                            }.bind(this)\n                        });\n                    }\n                    e.stop();\n                    break;\n                }\n                this.calendarNext(type);\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarDelete')) {\n                var form = elt.up('form'),\n                    type = form.id.replace(/kronolithCalendarForm/, ''),\n                    calendar = $F('kronolithCalendar' + type + 'Id');\n\n                if ((type == 'tasklists' &&\n                     !window.confirm(Kronolith.text.delete_tasklist)) ||\n                    (type != 'tasklists' &&\n                     !window.confirm(Kronolith.text.delete_calendar))) {\n                    e.stop();\n                    break;\n                }\n\n                if (!elt.disabled) {\n                    elt.disable();\n\n                    HordeCore.doAction('deleteCalendar', {\n                        type: type,\n                        calendar: calendar\n                    }, {\n                        callback: function(r) {\n                            if (r.deleted) {\n                                this.deleteCalendar(type, calendar);\n                            }\n                            this.closeRedBox();\n                            this.go(this.lastLocation);\n                        }.bind(this)\n                    });\n                }\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarSubscribe') ||\n                       elt.hasClassName('kronolithCalendarUnsubscribe')) {\n                var form = elt.up('form');\n                this.toggleCalendar($F(form.down('input[name=type]')),\n                                    $F(form.down('input[name=calendar]')));\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n            } else if (elt.tagName == 'INPUT' &&\n                       (elt.name == 'event_alarms[]' ||\n                        elt.name == 'task[alarm_methods][]')) {\n                if (elt.name == 'event_alarms[]') {\n                    $('kronolithEventAlarmOn').setValue(1);\n                    $('kronolithEventAlarmDefaultOff').setValue(1);\n                } else {\n                    $('kronolithTaskAlarmOn').setValue(1);\n                    $('kronolithTaskAlarmDefaultOff').setValue(1);\n                }\n                if ($(elt.id + 'Params')) {\n                    if (elt.getValue()) {\n                        $(elt.id + 'Params').show();\n                    } else {\n                        $(elt.id + 'Params').hide();\n                    }\n                }\n                break;\n            }\n\n            var calClass = elt.retrieve('calendarclass');\n            if (calClass) {\n                this.toggleCalendar(calClass, elt.retrieve('calendar'));\n                e.stop();\n                return;\n            }\n\n            elt = elt.up();\n        }\n        // Workaround Firebug bug.\n        Prototype.emptyFunction();\n    },\n\n    /**\n     * Handles date selections from a date picker.\n     */\n    datePickerHandler: function(e)\n    {\n        var field = e.element().previous();\n        field.setValue(e.memo.toString(Kronolith.conf.date_format));\n        this.updateTimeFields(field.identify());\n    },\n\n    /**\n     * Handles moving an event to a different day in month view and all day\n     * events in weekly/daily views.\n     */\n    onDrop: function(e)\n    {\n        var drop = e.element(),\n            el = e.memo.element;\n\n        if (drop == el.up()) {\n            return;\n        }\n\n        var lastDate = this.parseDate(el.up().retrieve('date')),\n            newDate = this.parseDate(drop.retrieve('date')),\n            diff = newDate.subtract(lastDate),\n            eventid = el.retrieve('eventid'),\n            cal = el.retrieve('calendar'),\n            viewDates = this.viewDates(this.date, this.view),\n            start = viewDates[0].toString('yyyyMMdd'),\n            end = viewDates[1].toString('yyyyMMdd'),\n            sig = start + end + (Math.random() + '').slice(2),\n            events = this.getCacheForDate(lastDate.toString('yyyyMMdd'), cal),\n            attributes = $H({ offDays: diff }),\n            event = events.find(function(e) { return e.key == eventid; });\n\n        drop.insert(el);\n        this.startLoading(cal, sig);\n        if (event.value.r) {\n            attributes.set('rday', lastDate);\n            attributes.set('cstart', this.cacheStart);\n            attributes.set('cend', this.cacheEnd);\n        }\n        var uatts = {\n            cal: cal,\n            id: eventid,\n            view: this.view,\n            sig: sig,\n            view_start: start,\n            view_end: end,\n            att: Object.toJSON(attributes)\n        },\n        callback = function(r) {\n          if (r.events) {\n              // Check if this is the still the result of the\n              // most current request.\n              if (r.sig == this.eventsLoading[r.cal]) {\n                  var days;\n                  if ((this.view == 'month' &&\n                       Kronolith.conf.max_events) ||\n                      this.view == 'week' ||\n                      this.view == 'workweek' ||\n                      this.view == 'day') {\n                      days = this.findEventDays(cal, eventid);\n                  }\n                  this.removeEvent(cal, eventid);\n                  if (days && days.length) {\n                      this.reRender(days);\n                  }\n              }\n              $H(r.events).each(function(days) {\n                  $H(days.value).each(function(event) {\n                      if (event.value.c.startsWith('tasks/')) {\n                          var tasklist = event.value.c.substr(6),\n                              task = event.key.substr(6),\n                              taskObject;\n                          if (this.tcache.get('incomplete') &&\n                              this.tcache.get('incomplete').get(tasklist) &&\n                              this.tcache.get('incomplete').get(tasklist).get(task)) {\n                              taskObject = this.tcache.get('incomplete').get(tasklist).get(task);\n                              taskObject.due = Date.parse(event.value.s);\n                              this.tcache.get('incomplete').get(tasklist).set(task, taskObject);\n                          }\n                      }\n                  }, this);\n              }, this);\n          }\n          this.loadEventsCallback(r, false);\n          $H(r.events).each(function(days) {\n              $H(days.value).each(function(event) {\n                  if (event.key == eventid) {\n                      this.refreshResources(days.key, cal, eventid, lastDate.toString('yyyyMMdd'), event);\n                  }\n              }.bind(this))\n          }.bind(this));\n      }.bind(this);\n\n      if (event.value.mt) {\n          $('kronolithEventDiv').hide();\n          $('kronolithUpdateDiv').show();\n          RedBox.showHtml($('kronolithEventDialog').show());\n          this.uatts = uatts;\n          this.ucb = callback;\n      } else {\n          this.doDragDropUpdate(uatts, callback);\n      }\n    },\n\n    onDragStart: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        var elt = e.element();\n\n        if (elt.hasClassName('kronolithDragger')) {\n            elt.up().addClassName('kronolith-selected');\n            DragDrop.Drags.getDrag(elt).top = elt.cumulativeOffset().top;\n        } else if (elt.hasClassName('kronolithEditable')) {\n            elt.addClassName('kronolith-selected').setStyle({ left: 0, width: (this.view == 'week' || this.view == 'workweek') ? '90%' : '95%', zIndex: 1 });\n        }\n\n        this.scrollTop = $('kronolithView' + this.view.capitalize())\n            .down('.kronolithViewBody')\n            .scrollTop;\n        this.scrollLast = this.scrollTop;\n    },\n\n    onDrag: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        var elt = e.element(),\n            drag = DragDrop.Drags.getDrag(elt);\n            storage = this.view + 'Sizes',\n            step = this[storage].height / 6;\n\n            if (!drag.event) {\n                return;\n            }\n\n        var event = drag.event.value;\n\n        if (elt.hasClassName('kronolithDragger')) {\n            // Resizing the event.\n            var div = elt.up(),\n                top = drag.ghost.cumulativeOffset().top,\n                scrollTop = $('kronolithView' + this.view.capitalize()).down('.kronolithViewBody').scrollTop,\n                offset = 0,\n                height;\n\n            // Check if view has scrolled since last call.\n            if (scrollTop != this.scrollLast) {\n                offset = scrollTop - this.scrollLast;\n                this.scrollLast = scrollTop;\n            }\n            if (elt.hasClassName('kronolithDraggerTop')) {\n                offset += top - drag.top;\n                height = div.offsetHeight - offset;\n                div.setStyle({\n                    top: (div.offsetTop + offset) + 'px'\n                });\n                offset = drag.ghost.offsetTop;\n                drag.top = top;\n            } else {\n                offset += top - drag.top;\n                height = div.offsetHeight + offset;\n                offset = div.offsetTop;\n                drag.top = top;\n            }\n            div.setStyle({\n                height: height + 'px'\n            });\n\n            this.calculateEventDates(event, storage, step, offset, height);\n            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());\n        } else if (elt.hasClassName('kronolithEditable')) {\n            // Moving the event.\n            if (Object.isUndefined(drag.innerDiv)) {\n                drag.innerDiv = drag.ghost.down('.kronolith-event-info');\n            }\n            if ((this.view == 'week') || (this.view == 'workweek')) {\n                var offsetX = Math.round(drag.ghost.offsetLeft / drag.stepX);\n                event.offsetDays = offsetX;\n                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight, event.start.clone().addDays(offsetX), event.end.clone().addDays(offsetX));\n            } else {\n                event.offsetDays = 0;\n                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight);\n            }\n            event.offsetTop = drag.ghost.offsetTop - drag.startTop;\n            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());\n            elt.clonePosition(drag.ghost, { offsetLeft: (this.view == 'week' || this.view == 'workweek') ? -2 : 0 });\n        }\n    },\n\n    onDragEnd: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        if (!e.element().hasClassName('kronolithDragger') &&\n            !e.element().hasClassName('kronolithEditable')) {\n            return;\n        }\n\n        var div = e.element(),\n            drag = DragDrop.Drags.getDrag(div),\n            event = drag.event;\n\n\n        if (event.value.al) {\n            return;\n        }\n        var date = drag.midnight,\n            storage = this.view + 'Sizes',\n            step = this[storage].height / 6,\n            dates = this.viewDates(date, this.view),\n            start = dates[0].dateString(),\n            end = dates[1].dateString(),\n            sig = start + end + (Math.random() + '').slice(2),\n            element, attributes;\n\n        div.removeClassName('kronolith-selected');\n        if (!Object.isUndefined(drag.innerDiv)) {\n            this.setEventText(drag.innerDiv, event.value);\n        }\n        this.startLoading(event.value.calendar, sig);\n        if (!Object.isUndefined(event.value.offsetTop)) {\n            attributes = $H({ offDays: event.value.offsetDays,\n                              offMins: Math.round(event.value.offsetTop / step) * 10 });\n            element = div;\n        } else if (div.hasClassName('kronolithDraggerTop')) {\n            attributes = $H({ start: event.value.start });\n            element = div.up();\n        } else if (div.hasClassName('kronolithDraggerBottom')) {\n            attributes = $H({ end: event.value.end });\n            element = div.up();\n        } else {\n            attributes = $H({ start: event.value.start,\n                              end: event.value.end });\n            element = div;\n        }\n        if (event.value.r) {\n            attributes.set('rstart', event.value.s);\n            attributes.set('rend', event.value.e);\n            attributes.set('cstart', this.cacheStart);\n            attributes.set('cend', this.cacheEnd);\n        }\n        element.retrieve('drags').invoke('destroy');\n        var uatts = {\n            cal: event.value.calendar,\n            id: event.key,\n            view: this.view,\n            sig: sig,\n            view_start: start,\n            view_end: end,\n            att: Object.toJSON(attributes)\n        },\n        callback = function(r) {\n            // Check if this is the still the result of the most current\n            // request.\n            if (r.events &&\n                r.sig == this.eventsLoading[r.cal]) {\n                if (event.value.rs) {\n                    var d = new Date(event.value.s);\n                    this.refreshResources(d.toString('yyyyMMdd'), event.value.calendar, event.key)\n                }\n                this.removeEvent(event.value.calendar, event.key);\n            }\n            this.loadEventsCallback(r, false);\n        }.bind(this);\n\n        if (event.value.mt) {\n            $('kronolithEventDiv').hide();\n            $('kronolithUpdateDiv').show();\n            RedBox.showHtml($('kronolithEventDialog').show());\n            this.uatts = uatts;\n            this.ucb = callback;\n        } else {\n            this.doDragDropUpdate(uatts, callback);\n        }\n    },\n\n    doDragDropUpdate: function(att, cb)\n    {\n        HordeCore.doAction('updateEvent', att, {\n            callback: cb\n        });\n    },\n\n    /**\n     * Refresh any resource calendars bound to the given just-updated event.\n     * Clears the old resource event from UI and cache, and clears the cache\n     * for the days of the new event, in order to allow listEvents to refresh\n     * the UI.\n     *\n     * @param  string dt       The current/new date for the event (yyyyMMdd).\n     * @param  string cal      The calendar the event exists in.\n     * @param  string eventid  The eventid that is changing.\n     * @param  string last_dt  The previous date for the event, if known. (yyyyMMdd).\n     * @param  object event    The event object (if a new event) dt is ignored.\n     *\n     */\n    refreshResources: function(dt, cal, eventid, last_dt, event)\n    {\n        var events = this.getCacheForDate(dt, cal),\n            update_cals = [], r_dates;\n\n        if (!event) {\n            event = events.find(function(e) { return e.key == eventid; });\n        }\n        if (!dt) {\n            dt = new Date(event.value.s);\n        } else {\n            dt = this.parseDate(dt);\n        }\n        if (event) {\n            $H(event.value.rs).each(function(r) {\n                var r_cal = ['resource', r.value.calendar],\n                    r_events = this.getCacheForDate(last_dt, r_cal.join('|')),\n                    r_event, day, end;\n\n                if (r_events) {\n                    r_event = r_events.find(function(e) { return e.value.uid == event.value.uid });\n                    if (r_event) {\n                        this.removeEvent(r_cal, r_event.key);\n                        day = new Date(r_event.value.s);\n                        end = new Date(r_event.value.s);\n                        while (!day.isAfter(end)) {\n                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));\n                            day.add(1).day();\n                        }\n                        day = new Date(event.value.s);\n                        end = new Date(event.value.e);\n\n                        while (!day.isAfter(end)) {\n                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));\n                            day.add(1).day();\n                        }\n                    } else {\n                        // Don't know the previous date/time so just nuke the cache.\n                       this.deleteCache(r_cal);\n                    }\n                } else {\n                    this.deleteCache(r_cal);\n                }\n                update_cals.push(r_cal);\n            }.bind(this));\n\n            if (update_cals.length) {\n                dates = this.viewDates(dt, this.view);\n                // Ensure we also grab the full length of the events.\n                if (dates[0].isAfter(dt)) {\n                    dates[0] = dt;\n                }\n                var dt_end = new Date(event.value.e);\n                if (dt_end.isAfter(dates[1])) {\n                    dates[1] = dt_end;\n                }\n                this.loadEvents(dates[0], dates[1], this.view, update_cals);\n            }\n        }\n    },\n\n    editEvent: function(calendar, id, date, title)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithEventTags)) {\n            this.editEvent.bind(this, calendar, id, date).defer();\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithEventForm').focusFirstElement();\n            } catch(e) {}\n            if (Kronolith.conf.maps.driver &&\n                $('kronolithEventLinkMap').up().hasClassName('horde-active') &&\n                !this.mapInitialized) {\n\n                this.initializeMap();\n            }\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n        this.attendees = [];\n        this.resources = [];\n        this.updateCalendarDropDown('kronolithEventTarget');\n        this.toggleAllDay(false);\n        this.openTab($('kronolithEventForm').down('.tabset a.kronolithTabLink'));\n        this.disableAlarmMethods('Event');\n        this.knl.kronolithEventStartTime.markSelected();\n        this.knl.kronolithEventEndTime.markSelected();\n        $('kronolithEventForm').reset();\n        this.resetMap();\n        HordeImple.AutoCompleter.kronolithEventAttendees.reset();\n        HordeImple.AutoCompleter.kronolithEventTags.reset();\n        HordeImple.AutoCompleter.kronolithEventResources.reset();\n        if (Kronolith.conf.maps.driver) {\n            $('kronolithEventMapLink').hide();\n        }\n        $('kronolithEventSave').show().enable();\n        $('kronolithEventSaveAsNew').show().enable();\n        $('kronolithEventDelete').show().enable();\n        $('kronolithEventDeleteConfirm').enable();\n        $('kronolithEventTarget').show();\n        $('kronolithEventTargetRO').hide();\n        $('kronolithEventForm').down('.kronolithFormActions .kronolithSeparator').show();\n        $('kronolithEventExceptions').clear();\n        if (id) {\n            // An id passed to this function indicates we are editing an event.\n            RedBox.loading();\n            var attributes = { cal: calendar, id: id, date: date };\n            // Need the current st and et of this instance.\n            var events = this.getCacheForDate(date.toString('yyyyMMdd'), calendar);\n            if (events) {\n                var ev = events.find(function(e) { return e.key == id; });\n                if (ev[1].r) {\n                    attributes.rsd = ev[1].start.dateString();\n                    attributes.red = ev[1].end.dateString();\n                }\n            }\n            HordeCore.doAction('getEvent', attributes, {\n                callback: this.editEventCallback.bind(this)\n            });\n            $('kronolithEventTopTags').update();\n        } else {\n            // This is a new event.\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')\n            });\n            var d;\n            if (date) {\n                if (date.endsWith('all')) {\n                    date = date.substring(0, date.length - 3);\n                    $('kronolithEventAllday').setValue(true);\n                    this.toggleAllDay(true);\n                }\n                d = this.parseDate(date);\n            } else {\n                d = new Date();\n            }\n            if (title) {\n                $('kronolithEventTitle').setValue(title);\n            }\n            $('kronolithEventId').clear();\n            $('kronolithEventCalendar').clear();\n            $('kronolithEventTarget').setValue(Kronolith.conf.default_calendar);\n            $('kronolithEventDelete').hide();\n            $('kronolithEventStartDate').setValue(d.toString(Kronolith.conf.date_format));\n            $('kronolithEventStartTime').setValue(d.toString(Kronolith.conf.time_format));\n            this.updateFBDate(d);\n            d.add(1).hour();\n            this.duration = 60;\n            $('kronolithEventEndDate').setValue(d.toString(Kronolith.conf.date_format));\n            $('kronolithEventEndTime').setValue(d.toString(Kronolith.conf.time_format));\n            $('kronolithEventLinkExport').up('span').hide();\n            $('kronolithEventSaveAsNew').hide();\n            $('kronolithEventUrlDisplay').hide();\n            $('kronolithEventUrl').show();\n            this.toggleRecurrence(true, 'None');\n            $('kronolithEventEditRecur').hide();\n            this.enableAlarm('Event', Kronolith.conf.default_alarm);\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithEventDialog').show());\n        }\n    },\n\n    /**\n     * Generates ajax request parameters for requests to save events.\n     *\n     * @return object  An object with request parameters.\n     */\n    saveEventParams: function()\n    {\n        var viewDates = this.viewDates(this.date, this.view),\n            params = {\n                sig: viewDates[0].dateString() + viewDates[1].dateString(),\n                view: this.view\n            };\n        if (this.cacheStart) {\n            params.view_start = this.cacheStart.dateString();\n            params.view_end = this.cacheEnd.dateString();\n        }\n        return params;\n    },\n\n    /**\n     * Submits the event edit form to create or update an event.\n     */\n    saveEvent: function(asnew)\n    {\n        this.validateEvent(asnew);\n    },\n\n    /**\n     * Perform any preliminary checks necessary. doSaveEvent will be called from\n     * the callback if checks are successful.\n     *\n     */\n    validateEvent: function(asnew)\n    {\n        if (this.wrongFormat.size()) {\n            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');\n            return;\n        }\n\n        // Check that there are no conflicts.\n        if (Kronolith.conf.has_resources && $F('kronolithEventResourceIds')) {\n            HordeCore.doAction(\n                'checkResources',\n                {\n                    s: this.getDate('start').toISOString(),\n                    e: this.getDate('end').toISOString(),\n                    i: $F('kronolithEventId'),\n                    c: $F('kronolithEventCalendar'),\n                    r: $F('kronolithEventResourceIds')\n                },\n                {\n                    callback: this.validateEventCallback.curry(asnew).bind(this)\n                }\n            );\n        } else {\n            this.validateEventCallback(asnew, {});\n        }\n    },\n\n    validateEventCallback: function(asnew, r)\n    {\n        var conflict = false;\n\n        $H(r).each(function(a) {\n            // 3 == Kronolith::RESPONSE_DECLINED\n            if (a.value == 3) {\n                $('kronolithEventDiv').hide();\n                $('kronolithConflictDiv').show();\n                conflict = true;\n                return;\n            }\n        });\n        if (!conflict) {\n            this.doSaveEvent(asnew);\n        }\n    },\n\n    doSaveEvent: function(asnew)\n    {\n        var cal = $F('kronolithEventCalendar'),\n            target = $F('kronolithEventTarget'),\n            eventid = $F('kronolithEventId'),\n            params;\n\n        if (this.mapInitialized) {\n            $('kronolithEventMapZoom').value = this.map.getZoom();\n        }\n\n        params = $H($('kronolithEventForm').serialize({ hash: true }))\n            .merge(this.saveEventParams());\n        params.set('as_new', asnew ? 1 : 0);\n        if (this.cacheStart) {\n            params.set('cstart', this.cacheStart.toISOString());\n            params.set('cend', this.cacheEnd.toISOString());\n        }\n        HordeImple.AutoCompleter.kronolithEventTags.shutdown();\n        $('kronolithEventSave').disable();\n        $('kronolithEventSaveAsNew').disable();\n        $('kronolithEventDelete').disable();\n        this.startLoading(target, params.get('sig'));\n        HordeCore.doAction('saveEvent', params, {\n            callback: function(r) {\n                if (!asnew && r.events && eventid) {\n                    this.removeEvent(cal, eventid);\n                }\n                this.loadEventsCallback(r, false);\n\n                // Refresh bound exceptions\n                var calendar = cal.split('|'), refreshed = false;\n                $H(r.events).each(function(d) {\n                    $H(d.value).each(function(evt) {\n                        if (evt.value.bid) {\n                            var cache = this.getCacheForDate(this.findEventDays(cal, evt.key, cal));\n                            cache.each(function(entry) {\n                                if (entry.value.bid == evt.value.bid && evt.value.c != calendar[1]) {\n                                    this.removeEvent(cal, entry.key);\n                                }\n                            }.bind(this));\n                        }\n                        if (!refreshed && ((evt.key == eventid) || !eventid) && evt.value.rs) {\n                            this.refreshResources(null, cal, eventid, false, evt);\n                            refreshed = true;\n                        }\n                    }.bind(this))\n                }.bind(this));\n\n                if (r.events) {\n                    this.resetMap();\n                    this.closeRedBox();\n                    this.go(this.lastLocation);\n                } else {\n                    $('kronolithEventSave').enable();\n                    $('kronolithEventSaveAsNew').enable();\n                    $('kronolithEventDelete').enable();\n                }\n                $('kronolithUpdateDiv').hide();\n                $('kronolithConflictDiv').hide();\n                $('kronolithEventDiv').show();\n            }.bind(this)\n        });\n    },\n\n    quickSaveEvent: function()\n    {\n        var text = $F('kronolithQuickinsertQ'),\n            cal = $F('kronolithQuickinsertCalendars'),\n            params;\n\n        params = $H($('kronolithEventForm').serialize({ hash: true }))\n            .merge(this.saveEventParams());\n        params.set('text', text);\n        params.set('cal', cal);\n\n        this.closeRedBox();\n        this.startLoading(cal, params.get('sig'));\n        HordeCore.doAction('quickSaveEvent', params, {\n            callback: function(r) {\n                this.loadEventsCallback(r, false);\n                if (r.error) {\n                    this.editEvent(null, null, null, text);\n                } else {\n                    $('kronolithQuickinsertQ').value = '';\n                }\n             }.bind(this)\n         });\n    },\n\n    /**\n     * Closes and resets the quick event form.\n     */\n    quickClose: function()\n    {\n        $('kronolithQuickinsertQ').value = '';\n        if ($('kronolithQuicktaskQ')) {\n            $('kronolithQuicktaskQ').value = '';\n        }\n        this.closeRedBox();\n    },\n\n    topTagsCallback: function(update, tagclass, r)\n    {\n        $('kronolithEventTabTags').select('label').invoke('show');\n        if (!r.tags) {\n            $(update).update();\n            return;\n        }\n\n        var t = new Element('ul', { className: 'horde-tags' });\n        r.tags.each(function(tag) {\n            if (tag == null) {\n                return;\n            }\n            t.insert(new Element('li', { className: tagclass }).update(tag.escapeHTML()));\n        });\n        $(update).update(t);\n    },\n\n    /**\n     * Callback method for showing event forms.\n     *\n     * @param object r  The ajax response object.\n     */\n    editEventCallback: function(r)\n    {\n        if (!r.event) {\n            RedBox.close();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        var ev = r.event;\n\n        if (!Object.isUndefined(ev.ln)) {\n            this.loadPage(ev.ln);\n            this.closeRedBox();\n            return;\n        }\n\n        /* Basic information */\n        $('kronolithEventId').setValue(ev.id);\n        $('kronolithEventCalendar').setValue(ev.ty + '|' + ev.c);\n        $('kronolithEventTarget').setValue(ev.ty + '|' + ev.c);\n        $('kronolithEventTargetRO').update(Kronolith.conf.calendars[ev.ty][ev.c].name.escapeHTML());\n        $('kronolithEventTitle').setValue(ev.t);\n        $('kronolithEventLocation').setValue(ev.l);\n        $('kronolithEventTimezone').setValue(ev.tz);\n        if (ev.l && Kronolith.conf.maps.driver) {\n            $('kronolithEventMapLink').show();\n        }\n        if (ev.uhl) {\n            $('kronolithEventUrlDisplay').down().update(ev.uhl);\n            $('kronolithEventUrlDisplay').show();\n            $('kronolithEventUrl').hide();\n        }\n        else {\n            $('kronolithEventUrlDisplay').hide();\n            $('kronolithEventUrl').show();\n        }\n\n        if (ev.u) {\n            $('kronolithEventUrl').setValue(ev.u);\n        }\n\n        $('kronolithEventAllday').setValue(ev.al);\n\n        if (ev.r && ev.rsd && ev.red) {\n            // Save the original datetime, so we can properly create the\n            // exception.\n            var osd = Date.parse(ev.rsd + ' ' + ev.st);\n            var oed = Date.parse(ev.red + ' ' + ev.et);\n\n            $('kronolithEventRecurOStart').setValue(osd.toString('s'));\n            $('kronolithEventRecurOEnd').setValue(oed.toString('s'));\n\n            // ...and put the same value in the form field to replace the\n            // date of the initial series.\n            $('kronolithEventStartDate').setValue(ev.sd);\n            $('kronolithEventEndDate').setValue(ev.ed);\n            // Save the current datetime in case we are not editing 'all'\n            this.orstart = ev.rsd;\n            this.orend = ev.red;\n        } else {\n            $('kronolithEventStartDate').setValue(ev.sd);\n            $('kronolithEventEndDate').setValue(ev.ed);\n            $('kronolithEventRecurEnd').clear();\n            $('kronolithEventRecurOStart').clear();\n            $('kronolithEventRecurOEnd').clear();\n            this.orstart = null;\n            this.orend = null;\n        }\n\n        $('kronolithEventStartTime').setValue(ev.st);\n        this.knl.kronolithEventStartTime.setSelected(ev.st);\n        this.updateFBDate(Date.parseExact(ev.sd, Kronolith.conf.date_format));\n        $('kronolithEventEndTime').setValue(ev.et);\n        this.knl.kronolithEventEndTime.setSelected(ev.et);\n        this.duration = Math.abs(Date.parse(ev.e).getTime() - Date.parse(ev.s).getTime()) / 60000;\n        this.toggleAllDay(ev.al);\n        $('kronolithEventStatus').setValue(ev.x);\n        $('kronolithEventDescription').setValue(ev.d);\n        $('kronolithEventPrivate').setValue(ev.pv);\n        $('kronolithEventLinkExport').up('span').show();\n        $('kronolithEventExport').href = Kronolith.conf.URI_EVENT_EXPORT.interpolate({ id: ev.id, calendar: ev.c, type: ev.ty });\n\n        /* Alarm */\n        if (ev.a) {\n            this.enableAlarm('Event', ev.a);\n            if (ev.m) {\n                $('kronolithEventAlarmDefaultOff').checked = true;\n                $H(ev.m).each(function(method) {\n                    $('kronolithEventAlarm' + method.key).setValue(1);\n                    if ($('kronolithEventAlarm' + method.key + 'Params')) {\n                        $('kronolithEventAlarm' + method.key + 'Params').show();\n                        $H(method.value).each(function(param) {\n                            var input = $('kronolithEventAlarmParam' + param.key);\n                            if (input.type == 'radio') {\n                                input.up('form').select('input[type=radio]').each(function(radio) {\n                                    if (radio.name == input.name &&\n                                        radio.value == param.value) {\n                                        radio.setValue(1);\n                                        throw $break;\n                                    }\n                                });\n                            } else {\n                                input.setValue(param.value);\n                            }\n                        });\n                    }\n                });\n            }\n        } else {\n            $('kronolithEventAlarmOff').setValue(true);\n        }\n\n        /* Recurrence */\n        if (ev.r) {\n            this.setRecurrenceFields(true, ev.r);\n            $('kronolithRecurDelete').show();\n            $('kronolithNoRecurDelete').hide();\n            $('kronolithEventEditRecur').show();\n            this.recurs = true;\n        } else if (ev.bid) {\n            $('kronolithRecurDelete').hide();\n            $('kronolithNoRecurDelete').show();\n            $('kronolithEventEditRecur').hide();\n            var div = $('kronolithEventRepeatException');\n            div.down('span').update(ev.eod);\n            this.toggleRecurrence(true, 'Exception');\n            this.recurs = false;\n        } else {\n            $('kronolithRecurDelete').hide();\n            $('kronolithNoRecurDelete').show();\n            $('kronolithEventEditRecur').hide();\n            this.toggleRecurrence(true, 'None');\n            this.recurs = false;\n        }\n\n        /* Attendees */\n        if (!Object.isUndefined(ev.at)) {\n            HordeImple.AutoCompleter.kronolithEventAttendees.reset(ev.at.pluck('l'));\n            ev.at.each(this.addAttendee.bind(this));\n            if (this.fbLoading) {\n                $('kronolithFBLoading').show();\n            }\n        }\n\n        /* Resources */\n        if (!Object.isUndefined(ev.rs)) {\n            var rs = $H(ev.rs);\n            HordeImple.AutoCompleter.kronolithEventResources.reset(rs.values().pluck('name'));\n            rs.each(function(r) { this.addResource(r.value, r.key); }.bind(this));\n            if (this.fbLoading) {\n                $('kronolithResourceFBLoading').show();\n            }\n        }\n\n        /* Tags */\n        HordeImple.AutoCompleter.kronolithEventTags.reset(ev.tg);\n\n        /* Geo */\n        if (ev.gl) {\n            $('kronolithEventLocationLat').value = ev.gl.lat;\n            $('kronolithEventLocationLon').value = ev.gl.lon;\n            $('kronolithEventMapZoom').value = Math.max(1, ev.gl.zoom);\n        }\n\n        if (!ev.pe) {\n            $('kronolithEventSave').hide();\n            HordeImple.AutoCompleter.kronolithEventTags.disable();\n            $('kronolithEventTabTags').select('label').invoke('hide');\n        } else {\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')\n            });\n        }\n        if (!ev.pd) {\n            $('kronolithEventDelete').hide();\n            $('kronolithEventTarget').hide();\n            $('kronolithEventTargetRO').show();\n        }\n\n        this.setTitle(ev.t);\n        this.redBoxLoading = true;\n        RedBox.showHtml($('kronolithEventDialog').show());\n\n        /* Hide alarm message for this event. */\n        if (r.msgs) {\n            r.msgs = r.msgs.reject(function(msg) {\n                if (msg.type != 'horde.alarm') {\n                    return false;\n                }\n                var alarm = msg.flags.alarm;\n                if (alarm.params && alarm.params.notify &&\n                    alarm.params.notify.show &&\n                    alarm.params.notify.show.calendar &&\n                    alarm.params.notify.show.event &&\n                    alarm.params.notify.show.calendar == ev.c &&\n                    alarm.params.notify.show.event == ev.id) {\n                    return true;\n                }\n                return false;\n            });\n        }\n    },\n\n    /**\n     * Adds an attendee row to the free/busy table.\n     *\n     * @param object attendee  An attendee object with the properties:\n     *                         - e: email address\n     *                         - l: the display name of the attendee\n     */\n    addAttendee: function(attendee)\n    {\n        if (typeof attendee == 'string') {\n            if (attendee.include('@')) {\n                HordeCore.doAction('parseEmailAddress', {\n                    email: attendee\n                }, {\n                    callback: function (r) {\n                        if (r.email) {\n                            this.addAttendee({ e: r.email, l: attendee });\n                        }\n                    }.bind(this)\n                });\n                return;\n            } else {\n                attendee = { l: attendee };\n            }\n        }\n\n        if (attendee.e) {\n            this.attendees.push(attendee);\n            this.fbLoading++;\n            HordeCore.doAction('getFreeBusy', {\n                email: attendee.e\n            }, {\n                callback: function(r) {\n                    this.fbLoading--;\n                    if (!this.fbLoading) {\n                        $('kronolithFBLoading').hide();\n                    }\n                    if (!Object.isUndefined(r.fb)) {\n                        this.freeBusy.get(attendee.l)[1] = r.fb;\n                        this.insertFreeBusy(attendee.l, this.getFBDate());\n                    }\n                }.bind(this)\n            });\n        }\n\n        var tr = new Element('tr'), response, i;\n        this.freeBusy.set(attendee.l, [ tr ]);\n        attendee.r = attendee.r || 1;\n        switch (attendee.r) {\n            case 1: response = 'None'; break;\n            case 2: response = 'Accepted'; break;\n            case 3: response = 'Declined'; break;\n            case 4: response = 'Tentative'; break;\n        }\n        tr.insert(new Element('td')\n                  .writeAttribute('title', attendee.l)\n                  .addClassName('kronolithAttendee' + response)\n                  .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));\n        for (i = 0; i < 24; i++) {\n            tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n        }\n        $('kronolithEventAttendeesList').down('tbody').insert(tr);\n    },\n\n    resetFBRows: function()\n    {\n        this.attendees.each(function(attendee) {\n            var row = this.freeBusy.get(attendee.l)[0];\n            row.update();\n\n            attendee.r = attendee.r || 1;\n            switch (attendee.r) {\n                case 1: response = 'None'; break;\n                case 2: response = 'Accepted'; break;\n                case 3: response = 'Declined'; break;\n                case 4: response = 'Tentative'; break;\n            }\n            row.insert(new Element('td')\n                      .writeAttribute('title', attendee.l)\n                      .addClassName('kronolithAttendee' + response)\n                      .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));\n            for (i = 0; i < 24; i++) {\n                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n        }.bind(this));\n        this.resources.each(function(resource) {\n            var row = this.freeBusy.get(resource)[0],\n                tdone = row.down('td');\n            row.update();\n            row.update(tdone);\n            for (i = 0; i < 24; i++) {\n                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n        }.bind(this));\n    },\n\n    addResource: function(resource, id)\n    {\n        var v, response = 1;\n        if (!id) {\n            // User entered\n            this.resourceACCache.choices.each(function(i) {\n                if (i.name == resource) {\n                    v = i.code;\n                    throw $break;\n                } else {\n                    v = false;\n                }\n            }.bind(this));\n        } else {\n            // Populating from an edit event action\n            v = id;\n            response = resource.response;\n            resource = resource.name;\n        }\n\n        switch (response) {\n            case 1: response = 'None'; break;\n            case 2: response = 'Accepted'; break;\n            case 3: response = 'Declined'; break;\n            case 4: response = 'Tentative'; break;\n        }\n        var att = {\n            'resource': v\n        },\n        tr, i;\n        if (att.resource) {\n            this.fbLoading++;\n            HordeCore.doAction('getFreeBusy', att, {\n                callback: this.addResourceCallback.curry(resource).bind(this)\n            });\n            tr = new Element('tr');\n            this.freeBusy.set(resource, [ tr ]);\n            tr.insert(new Element('td')\n                .writeAttribute('title', resource)\n                .addClassName('kronolithAttendee' + response)\n                .insert(resource.escapeHTML()));\n            for (i = 0; i < 24; i++) {\n                tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n            $('kronolithEventResourcesList').down('tbody').insert(tr);\n            this.resourceACCache.map.set(resource, v);\n            $('kronolithEventResourceIds').value = this.resourceACCache.map.values();\n        } else {\n            HordeCore.notify(Kronolith.text.unknown_resource + ': ' + resource, 'horde.error');\n        }\n    },\n\n    removeResource: function(resource)\n    {\n        var row = this.freeBusy.get(resource)[0];\n        row.purge();\n        row.remove();\n        this.resourceACCache.map.unset(resource);\n        $('kronolithEventResourceIds').value = this.resourceACCache.map.values();\n    },\n\n    addResourceCallback: function(resource, r)\n    {\n        this.fbLoading--;\n        if (!this.fbLoading) {\n            $('kronolithResourceFBLoading').hide();\n        }\n        if (Object.isUndefined(r.fb)) {\n            return;\n        }\n        this.resources.push(resource);\n        this.freeBusy.get(resource)[1] = r.fb;\n        this.insertFreeBusy(resource);\n    },\n\n    /**\n     * Removes an attendee row from the free/busy table.\n     *\n     * @param string attendee  The display name of the attendee.\n     */\n    removeAttendee: function(attendee)\n    {\n        var row = this.freeBusy.get(attendee)[0];\n        row.purge();\n        row.remove();\n    },\n\n    normalizeAttendee: function(attendee)\n    {\n        var pattern = /:(.*);/;\n        var match = pattern.exec(attendee);\n        if (match) {\n           return match[1].split(',');\n        }\n        return [attendee];\n    },\n\n    checkOrganizerAsAttendee: function()\n    {\n        if (HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.length == 1 &&\n            HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.first().rawValue != Kronolith.conf.email) {\n            // Invite the organizer of this event to the new event.\n            HordeImple.AutoCompleter.kronolithEventAttendees.addNewItemNode(Kronolith.conf.email);\n            this.addAttendee(Kronolith.conf.email);\n        }\n    },\n\n    getFBDate: function ()\n    {\n        var startDate = $('kronolithFBDate').innerHTML.split(' ');\n        if (startDate.length > 1) {\n            startDate = startDate[1];\n        } else {\n            startDate = startDate[0];\n        }\n        return Date.parseExact(startDate, Kronolith.conf.date_format);\n    },\n\n    /**\n     * Updates rows with free/busy information in the attendees table.\n     *\n     * @param string attendee  An attendee display name as the free/busy\n     *                         identifier.\n     * @param date   start     An optinal start date for f/b info. If omitted,\n     *                         $('kronolithEventStartDate') is used.\n     */\n    insertFreeBusy: function(attendee, start)\n    {\n        if (!$('kronolithEventDialog').visible() ||\n            !this.freeBusy.get(attendee)) {\n            return;\n        }\n        var fb = this.freeBusy.get(attendee)[1],\n            tr = this.freeBusy.get(attendee)[0],\n            td = tr.select('td')[1],\n            div = td.down('div'), start;\n        if (!fb) {\n            return;\n        }\n\n        if (!td.getWidth()) {\n            this.insertFreeBusy.bind(this, attendee, start).defer();\n            return;\n        }\n\n        if (div) {\n            div.purge();\n            div.remove();\n        }\n        if (!start) {\n            start = Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format);\n        }\n        var end = start.clone().add(1).days(),\n            width = td.getWidth(),\n            fbs = this.parseDate(fb.s),\n            fbe = this.parseDate(fb.e);\n\n\n        if (start.isBefore(fbs) || end.isBefore(fbs) || start.isAfter(fbe)) {\n            return;\n        }\n\n        tr.select('td').each(function(td, i) {\n            if (i != 0) {\n                td.className = 'kronolithFBFree';\n            }\n            i++;\n        });\n        div = new Element('div').setStyle({ position: 'relative', height: td.offsetHeight + 'px' });\n        td.insert(div);\n        $H(fb.b).each(function(busy) {\n            var left, from = Date.parse(busy.key).addSeconds(1),\n            to = Date.parse(busy.value).addSeconds(1);\n            if (!end.isAfter(from) || to.isBefore(start)) {\n                return;\n            }\n            if (from.isBefore(start)) {\n                from = start.clone();\n            }\n            if (to.isAfter(end)) {\n                to = end.clone();\n            }\n            if (to.getHours() === 0 && to.getMinutes() === 0) {\n                to.add(-1).minutes();\n            }\n            left = from.getHours() + from.getMinutes() / 60;\n            div.insert(new Element('div', { className: 'kronolithFBBusy' }).setStyle({ zIndex: 1, top: 0, left: (left * width) + 'px', width: (((to.getHours() + to.getMinutes() / 60) - left) * width) + 'px' }));\n        });\n\n    },\n\n    fbStartDateOnChange: function()\n    {\n        if (!$F('kronolithEventStartDate')) {\n          this._checkDate($('kronolithEventStartDate'));\n          return;\n        }\n        this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));\n    },\n\n    /**\n     * @param Date start  The start date.\n     */\n    fbStartDateHandler: function(start)\n    {\n        this.updateFBDate(start);\n        this.resetFBRows();\n        // Need to check visisbility - multiple changes will break the display\n        // due to the use of .defer() in insertFreeBusy().\n        if ($('kronolithEventTabAttendees').visible()) {\n            this.attendeeStartDateHandler(start);\n        }\n        if ($('kronolithEventTabResources').visible()) {\n            this.resourceStartDateHandler(start);\n        }\n    },\n\n    attendeeStartDateHandler: function(start)\n    {\n        this.attendees.each(function(attendee) {\n            this.insertFreeBusy(attendee.l, start);\n        }, this);\n    },\n\n    resourceStartDateHandler: function(start)\n    {\n        this.resources.each(function(resource) {\n            this.insertFreeBusy(resource, start);\n        }, this);\n    },\n\n    nextFreebusy: function()\n    {\n        this.fbStartDateHandler(this.getFBDate().addDays(1));\n    },\n\n    prevFreebusy: function()\n    {\n        this.fbStartDateHandler(this.getFBDate().addDays(-1));\n    },\n\n    /**\n     * @start Date object\n     */\n    updateFBDate: function(start)\n    {\n        $('kronolithFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));\n        $('kronolithResourceFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));\n    },\n\n    /**\n     * Toggles the start and end time fields of the event edit form on and off.\n     *\n     * @param boolean on  Whether the event is an all-day event, i.e. the time\n     *                    fields should be turned off. If not specified, the\n     *                    current state is toggled.\n     */\n    toggleAllDay: function(on)\n    {\n        var end = this.getDate('end'),\n            old = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'hidden';\n        if (Object.isUndefined(on)) {\n            on = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'visible';\n        }\n        if (end) {\n            if (on) {\n                if (end.getHours() == 0 && end.getMinutes() == 0) {\n                    end.add(-1).minute();\n                }\n            } else if (old) {\n                end.setHours(23);\n                end.setMinutes(59);\n            }\n            $('kronolithEventEndDate').setValue(end.toString(Kronolith.conf.date_format));\n            $('kronolithEventEndTime').setValue(end.toString(Kronolith.conf.time_format));\n        }\n        $('kronolithEventStartTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });\n        $('kronolithEventEndTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });\n    },\n\n    /**\n     * Enables the alarm in the event or task form and sets the correct value\n     * and unit.\n     *\n     * @param string type    The object type, either 'Event' or 'Task'.\n     * @param integer alarm  The alarm time in seconds.\n     */\n    enableAlarm: function(type, alarm) {\n        if (!alarm) {\n            return;\n        }\n        type = 'kronolith' + type + 'Alarm';\n        $(type + 'On').setValue(true);\n        [10080, 1440, 60, 1].each(function(unit) {\n            if (alarm % unit === 0) {\n                $(type + 'Value').setValue(alarm / unit);\n                $(type + 'Unit').setValue(unit);\n                throw $break;\n            }\n        });\n    },\n\n    /**\n     * Disables all custom alarm methods in the event form.\n     */\n    disableAlarmMethods: function(type) {\n        $('kronolith' + type + 'TabReminder').select('input').each(function(input) {\n            if (input.name == (type == 'Event' ? 'event_alarms[]' : 'task[alarm_methods][]')) {\n                input.setValue(0);\n                if ($(input.id + 'Params')) {\n                    $(input.id + 'Params').hide();\n                }\n            }\n        });\n    },\n\n    /**\n     * Toggles the recurrence fields of the event and task edit forms.\n     *\n     * @param boolean event  Whether to use the event form.\n     * @param string recur   The recurrence part of the field name, i.e. 'None',\n     *                       'Daily', etc.\n     */\n    toggleRecurrence: function(event, recur)\n    {\n        var prefix = 'kronolith' + (event ? 'Event' : 'Task');\n        if (recur == 'Exception') {\n            if (!$(prefix + 'RepeatException').visible()) {\n                $(prefix + 'TabRecur').select('div').invoke('hide');\n                $(prefix + 'RepeatException').show();\n            }\n        } else if (recur != 'None') {\n            var div = $(prefix + 'Repeat' + recur),\n                length = $(prefix + 'RepeatLength');\n            this.lastRecurType = recur;\n            if (!div.visible()) {\n                $(prefix + 'TabRecur').select('div').invoke('hide');\n                div.show();\n                length.show();\n                $(prefix + 'RepeatType').show();\n            }\n            switch (recur) {\n            case 'Daily':\n            case 'Weekly':\n            case 'Monthly':\n            case 'Yearly':\n                var recurLower = recur.toLowerCase();\n                if (div.down('input[name=recur_' + recurLower + '][value=1]').checked) {\n                    div.down('input[name=recur_' + recurLower + '_interval]').disable();\n                } else {\n                    div.down('input[name=recur_' + recurLower + '_interval]').enable();\n                }\n                break;\n            }\n\n            if (length.down('input[name=recur_end_type][value=date]').checked) {\n                $(prefix + 'RecurDate').enable();\n                $(prefix + 'RecurPicker').setStyle({ visibility: 'visible' });\n            } else {\n                $(prefix + 'RecurDate').disable();\n                $(prefix + 'RecurPicker').setStyle({ visibility: 'hidden' });\n            }\n            if (length.down('input[name=recur_end_type][value=count]').checked) {\n                $(prefix + 'RecurCount').enable();\n            } else {\n                $(prefix + 'RecurCount').disable();\n            }\n        } else {\n            $(prefix + 'TabRecur').select('div').invoke('hide');\n            $(prefix + 'RepeatType').show();\n        }\n    },\n\n    /**\n     * Fills the recurrence fields of the event and task edit forms.\n     *\n     * @param boolean event  Whether to use the event form.\n     * @param object recur   The recurrence object from the ajax response.\n     */\n    setRecurrenceFields: function(event, recur)\n    {\n        var scheme = Kronolith.conf.recur[recur.t],\n            schemeLower = scheme.toLowerCase(),\n            prefix = 'kronolith' + (event ? 'Event' : 'Task'),\n            div = $(prefix + 'Repeat' + scheme);\n        $(prefix + 'Link' + scheme).setValue(true);\n        if (scheme == 'Monthly' || scheme == 'Yearly') {\n            div.down('input[name=recur_' + schemeLower + '_scheme][value=' + recur.t + ']').setValue(true);\n        }\n        if (scheme == 'Weekly') {\n            div.select('input[type=checkbox]').each(function(input) {\n                if (input.name == 'weekly[]' &&\n                    input.value & recur.d) {\n                    input.setValue(true);\n                }\n            });\n        }\n        if (recur.i == 1) {\n            div.down('input[name=recur_' + schemeLower + '][value=1]').setValue(true);\n        } else {\n            div.down('input[name=recur_' + schemeLower + '][value=0]').setValue(true);\n            div.down('input[name=recur_' + schemeLower + '_interval]').setValue(recur.i);\n        }\n        if (!Object.isUndefined(recur.e)) {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=date]').setValue(true);\n            $(prefix + 'RecurDate').setValue(Date.parse(recur.e).toString(Kronolith.conf.date_format));\n        } else if (!Object.isUndefined(recur.c)) {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=count]').setValue(true);\n            $(prefix + 'RecurCount').setValue(recur.c);\n        } else {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=none]').setValue(true);\n        }\n        $(prefix + 'Exceptions').setValue(recur.ex || '');\n        if ($(prefix + 'Completions')) {\n            $(prefix + 'Completions').setValue(recur.co || '');\n        }\n        this.toggleRecurrence(event, scheme);\n    },\n\n    /**\n     * Returns the Date object representing the date and time specified in the\n     * event form's start or end fields.\n     *\n     * @param string what  Which fields to parse, either 'start' or 'end'.\n     *\n     * @return Date  The date object or null if the fields can't be parsed.\n     */\n    getDate: function(what) {\n        var dateElm, timeElm, date, time;\n        if (what == 'start') {\n            dateElm = 'kronolithEventStartDate';\n            timeElm = 'kronolithEventStartTime';\n        } else {\n            dateElm = 'kronolithEventEndDate';\n            timeElm = 'kronolithEventEndTime';\n        }\n        date = Date.parseExact($F(dateElm), Kronolith.conf.date_format)\n            || Date.parse($F(dateElm));\n        if (date) {\n            time = Date.parseExact($F(timeElm), Kronolith.conf.time_format);\n            if (!time) {\n                time = Date.parse($F(timeElm));\n            }\n            if (time) {\n                date.setHours(time.getHours());\n                date.setMinutes(time.getMinutes());\n            }\n        }\n        return date;\n    },\n\n    checkDate: function(e) {\n        this._checkDate(e.element());\n    },\n\n    _checkDate: function(elm)\n    {\n        if ($F(elm)) {\n            var date = Date.parseExact($F(elm), Kronolith.conf.date_format) || Date.parse($F(elm));\n            if (date) {\n                elm.setValue(date.toString(Kronolith.conf.date_format));\n                this.wrongFormat.unset(elm.id);\n            } else {\n                HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');\n                this.wrongFormat.set(elm.id, true);\n            }\n        } else {\n            HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');\n            this.wrongFormat.set(elm.id, true);\n        }\n    },\n\n    /**\n     * Attaches a KeyNavList drop down to one of the time fields.\n     *\n     * @param string|Element field  A time field (id).\n     *\n     * @return KeyNavList  The drop down list object.\n     */\n    attachTimeDropDown: function(field)\n    {\n        var list = [], d = new Date(), time, opts;\n\n        d.setHours(0);\n        d.setMinutes(0);\n        do {\n            time = d.toString(Kronolith.conf.time_format);\n            list.push({ l: time, v: time });\n            d.add(30).minutes();\n        } while (d.getHours() !== 0 || d.getMinutes() !== 0);\n\n        field = $(field);\n        opts = {\n            list: list,\n            domParent: field.up('.kronolithDialog'),\n            onChoose: function(value) {\n                if (value) {\n                    field.setValue(value);\n                }\n                this.updateTimeFields(field.identify());\n            }.bind(this)\n        };\n\n        this.knl[field.id] = new KeyNavList(field, opts);\n\n        return this.knl[field.id];\n    },\n\n    checkTime: function(e) {\n        var elm = e.element();\n        if ($F(elm)) {\n            var time = Date.parseExact(new Date().toString(Kronolith.conf.date_format) + ' ' + $F(elm), Kronolith.conf.date_format + ' ' + Kronolith.conf.time_format) || Date.parse(new Date().toString('yyyy-MM-dd ') + $F(elm));\n            if (time) {\n                elm.setValue(time.toString(Kronolith.conf.time_format));\n                this.wrongFormat.unset(elm.id);\n            } else {\n                HordeCore.notify(Kronolith.text.wrong_time_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.time_format) }), 'horde.warning');\n                this.wrongFormat.set(elm.id, true);\n            }\n        }\n    },\n\n    /**\n     * Updates the start time in the event form after changing the end time.\n     */\n    updateStartTime: function(date) {\n        var start = this.getDate('start'), end = this.getDate('end');\n        if (!start) {\n            return;\n        }\n        if (!date) {\n            date = end;\n        }\n        if (!date) {\n            return;\n        }\n        if (start.isAfter(end)) {\n            $('kronolithEventStartDate').setValue(date.toString(Kronolith.conf.date_format));\n            $('kronolithEventStartTime').setValue($F('kronolithEventEndTime'));\n        }\n        this.duration = Math.abs(date.getTime() - start.getTime()) / 60000;\n    },\n\n    /**\n     * Updates the end time in the event form after changing the start time.\n     */\n    updateEndTime: function() {\n        var date = this.getDate('start');\n        if (!date) {\n            return;\n        }\n        date.add(this.duration).minutes();\n        $('kronolithEventEndDate').setValue(date.toString(Kronolith.conf.date_format));\n        $('kronolithEventEndTime').setValue(date.toString(Kronolith.conf.time_format));\n    },\n\n    /**\n     * Event handler for scrolling the mouse over the date field.\n     *\n     * @param Event e       The mouse event.\n     * @param string field  The field name.\n     */\n    scrollDateField: function(e, field) {\n        var date = Date.parseExact($F(field), Kronolith.conf.date_format);\n        if (!date || (!e.wheelData && !e.detail)) {\n            return;\n        }\n        date.add(e.wheelData > 0 || e.detail < 0 ? 1 : -1).days();\n        $(field).setValue(date.toString(Kronolith.conf.date_format));\n        switch (field) {\n        case 'kronolithEventStartDate':\n            this.updateEndTime();\n            break;\n        case 'kronolithEventEndDate':\n            this.updateStartTime(date);\n            break;\n        }\n    },\n\n    /**\n     * Event handler for scrolling the mouse over the time field.\n     *\n     * @param Event e       The mouse event.\n     * @param string field  The field name.\n     */\n    scrollTimeField: function(e, field) {\n        var time = Date.parseExact($F(field), Kronolith.conf.time_format) || Date.parse($F(field)),\n            newTime, minute;\n        if (!time || (!e.wheelData && !e.detail)) {\n            return;\n        }\n\n        newTime = time.clone();\n        newTime.add(e.wheelData > 0 || e.detail < 0 ? 10 : -10).minutes();\n        minute = newTime.getMinutes();\n        if (minute % 10) {\n            if (e.wheelData > 0 || e.detail < 0) {\n                minute = minute / 10 | 0;\n            } else {\n                minute = (minute - 10) / 10 | 0;\n            }\n            minute *= 10;\n            newTime.setMinutes(minute);\n        }\n        if (newTime.getDate() != time.getDate()) {\n            if (newTime.isAfter(time)) {\n                newTime = time.clone().set({ hour: 23, minute: 59 });\n            } else {\n                newTime = time.clone().set({ hour: 0, minute: 0 });\n            }\n        }\n\n        $(field).setValue(newTime.toString(Kronolith.conf.time_format));\n        this.updateTimeFields(field);\n\n        /* Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=502818\n         * Need to stop or else multiple scroll events may be fired. We\n         * lose the ability to have the mousescroll bubble up, but that is\n         * more desirable than having the wrong scrolling behavior. */\n        if (Prototype.Browser.Gecko && !e.stop) {\n            Event.stop(e);\n        }\n    },\n\n    /**\n     * Updates the time fields of the event dialog after either has been\n     * changed.\n     *\n     * @param string field  The id of the field that has been changed.\n     */\n    updateTimeFields: function(field)\n    {\n        switch (field) {\n        case 'kronolithEventStartDate':\n            this.fbStartDateHandler(Date.parseExact($F(field), Kronolith.conf.date_format));\n        case 'kronolithEventStartTime':\n            this.updateEndTime();\n            break;\n        case 'kronolithEventEndDate':\n        case 'kronolithEventEndTime':\n            this.updateStartTime();\n            this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));\n            break;\n        }\n    },\n\n    /**\n     * Closes a RedBox overlay, after saving its content to the body.\n     */\n    closeRedBox: function()\n    {\n        if (!RedBox.getWindow()) {\n            return;\n        }\n        var content = RedBox.getWindowContents();\n        if (content) {\n            document.body.insert(content.hide());\n        }\n        RedBox.close();\n    },\n\n    // By default, no context onShow action\n    contextOnShow: Prototype.emptyFunction,\n\n    // By default, no context onClick action\n    contextOnClick: Prototype.emptyFunction,\n\n    // Map\n    initializeMap: function(ignoreLL)\n    {\n        if (this.mapInitialized) {\n            return;\n        }\n        var layers = [];\n        if (Kronolith.conf.maps.providers) {\n            Kronolith.conf.maps.providers.each(function(l) {\n                var p = new HordeMap[l]();\n                $H(p.getLayers()).values().each(function(e) {layers.push(e);});\n            });\n        }\n\n        this.map = new HordeMap.Map[Kronolith.conf.maps.driver]({\n            elt: 'kronolithEventMap',\n            delayed: true,\n            layers: layers,\n            markerDragEnd: this.onMarkerDragEnd.bind(this),\n            mapClick: this.afterClickMap.bind(this)\n        });\n\n        if ($('kronolithEventLocationLat').value && !ignoreLL) {\n            var ll = { lat:$('kronolithEventLocationLat').value, lon: $('kronolithEventLocationLon').value };\n            // Note that we need to cast the value of zoom to an integer here,\n            // otherwise the map display breaks.\n            this.placeMapMarker(ll, true, $('kronolithEventMapZoom').value - 0);\n        }\n        //@TODO: check for Location field - and if present, but no lat/lon value, attempt to\n        // geocode it.\n        this.map.display();\n        this.mapInitialized = true;\n    },\n\n    resetMap: function()\n    {\n        this.mapInitialized = false;\n        $('kronolithEventLocationLat').value = null;\n        $('kronolithEventLocationLon').value = null;\n        $('kronolithEventMapZoom').value = null;\n        if (this.mapMarker) {\n            this.map.removeMarker(this.mapMarker, {});\n            this.mapMarker = null;\n        }\n        if (this.map) {\n            this.map.destroy();\n            this.map = null;\n        }\n    },\n\n    /**\n     * Callback for handling marker drag end.\n     *\n     * @param object r  An object that implenents a getLonLat() method to obtain\n     *                  the new location of the marker.\n     */\n    onMarkerDragEnd: function(r)\n    {\n        var ll = r.getLonLat();\n        $('kronolithEventLocationLon').value = ll.lon;\n        $('kronolithEventLocationLat').value = ll.lat;\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.reverseGeocode(ll, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );\n    },\n\n    /**\n     * Callback for handling a reverse geocode request.\n     *\n     * @param array r  An array of objects containing the results. Each object in\n     *                 the array is {lat:, lon:, address}\n     */\n    onReverseGeocode: function(r)\n    {\n        if (!r.length) {\n            return;\n        }\n        $('kronolithEventLocation').value = r[0].address;\n    },\n\n    onGeocodeError: function(r)\n    {\n        $('kronolithEventGeo_loading_img').toggle();\n        HordeCore.notify(Kronolith.text.geocode_error + ' ' + r, 'horde.error');\n    },\n\n    /**\n     * Callback for geocoding calls.\n     */\n    onGeocode: function(r)\n    {\n        $('kronolithEventGeo_loading_img').toggle();\n        r = r.shift();\n        if (r.precision) {\n            zoom = r.precision * 2;\n        } else {\n            zoom = null;\n        }\n        this.ensureMap(true);\n        this.placeMapMarker({ lat: r.lat, lon: r.lon }, true, zoom);\n    },\n\n    geocode: function(a) {\n        if (!a) {\n            return;\n        }\n        $('kronolithEventGeo_loading_img').toggle();\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.geocode(a, this.onGeocode.bind(this), this.onGeocodeError);\n    },\n\n    /**\n     * Place the event marker on the map, at point ll, ensuring it exists.\n     * Optionally center the map on the marker and zoom. Zoom only honored if\n     * center is set, and if center is set, but zoom is null, we zoomToFit().\n     *\n     */\n    placeMapMarker: function(ll, center, zoom)\n    {\n        if (!this.mapMarker) {\n            this.mapMarker = this.map.addMarker(\n                    ll,\n                    { draggable: true },\n                    {\n                        context: this,\n                        dragend: this.onMarkerDragEnd\n                    });\n        } else {\n            this.map.moveMarker(this.mapMarker, ll);\n        }\n\n        if (center) {\n            this.map.setCenter(ll, zoom);\n            if (!zoom) {\n                this.map.zoomToFit();\n            }\n        }\n        $('kronolithEventLocationLon').value = ll.lon;\n        $('kronolithEventLocationLat').value = ll.lat;\n    },\n\n    /**\n     * Remove the event marker from the map. Called after clearing the location\n     * field.\n     */\n    removeMapMarker: function()\n    {\n        if (this.mapMarker) {\n            this.map.removeMarker(this.mapMarker, {});\n            $('kronolithEventLocationLon').value = null;\n            $('kronolithEventLocationLat').value = null;\n        }\n\n        this.mapMarker = false;\n    },\n\n    /**\n     * Ensures the map tab is visible and sets UI elements accordingly.\n     */\n    ensureMap: function(ignoreLL)\n    {\n        if (!this.mapInitialized) {\n            this.initializeMap(ignoreLL);\n        }\n        var dialog = $('kronolithEventForm');\n        dialog.select('.kronolithTabsOption').invoke('hide');\n        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');\n        $('kronolithEventTabMap').show();\n        $('kronolithEventLinkMap').up().addClassName('horde-active');\n    },\n\n    /**\n     * Callback that gets called after a new marker has been placed on the map\n     * due to a single click on the map.\n     *\n     * @return object o  { lonlat: }\n     */\n    afterClickMap: function(o)\n    {\n        this.placeMapMarker(o.lonlat, false);\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.reverseGeocode(o.lonlat, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );\n    },\n\n    /* Onload function. */\n    onDomLoad: function()\n    {\n        var dateFields, timeFields;\n\n        /* Initialize the starting page. */\n        var tmp = location.hash;\n        if (!tmp.empty() && tmp.startsWith('#')) {\n            tmp = (tmp.length == 1) ? '' : tmp.substring(1);\n        }\n        if (tmp.empty()) {\n            this.updateView(this.date, Kronolith.conf.login_view);\n            $('kronolithView' + Kronolith.conf.login_view.capitalize()).show();\n        }\n        HordeCore.doAction('listCalendars', {}, { callback: this.initialize.bind(this, tmp) });\n\n        RedBox.onDisplay = function() {\n            this.redBoxLoading = false;\n        }.bind(this);\n        RedBox.duration = this.effectDur;\n\n        $('kronolithEventStartDate', 'kronolithEventEndDate', 'kronolithTaskDueDate').compact().invoke('observe', 'blur', this.checkDate.bind(this));\n        var timeFields = $('kronolithEventStartTime', 'kronolithEventEndTime', 'kronolithTaskDueTime').compact();\n        timeFields.invoke('observe', 'blur', this.checkTime.bind(this));\n        timeFields.each(function(field) {\n            var dropDown = this.attachTimeDropDown(field);\n            field.observe('click', function() { dropDown.show(); });\n        }, this);\n        $('kronolithEventStartDate', 'kronolithEventStartTime').invoke('observe', 'change', this.updateEndTime.bind(this));\n        $('kronolithEventEndDate', 'kronolithEventEndTime').invoke('observe', 'change', function() { this.updateStartTime(); }.bind(this));\n\n        if (Kronolith.conf.has_tasks) {\n            $('kronolithTaskDueDate', 'kronolithTaskDueTime').compact().invoke('observe', 'focus', this.setDefaultDue.bind(this));\n            $('kronolithTaskList').observe('change', function() {\n                this.updateTaskParentDropDown($F('kronolithTaskList'));\n                this.updateTaskAssigneeDropDown($F('kronolithTaskList'));\n            }.bind(this));\n        }\n\n        document.observe('keydown', KronolithCore.keydownHandler.bindAsEventListener(KronolithCore));\n        document.observe('keyup', KronolithCore.keyupHandler.bindAsEventListener(KronolithCore));\n        document.observe('click', KronolithCore.clickHandler.bindAsEventListener(KronolithCore));\n        document.observe('dblclick', KronolithCore.clickHandler.bindAsEventListener(KronolithCore, true));\n\n        // Mouse wheel handler.\n        dateFields = [ 'kronolithEventStartDate', 'kronolithEventEndDate' ];\n        timeFields = [ 'kronolithEventStartTime', 'kronolithEventEndTime' ];\n        if (Kronolith.conf.has_tasks) {\n            dateFields.push('kronolithTaskDueDate');\n            timeFields.push('kronolithTaskDueTime');\n        }\n        dateFields.each(function(field) {\n            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollDateField.bindAsEventListener(this, field));\n        }, this);\n        timeFields.each(function(field) {\n            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollTimeField.bindAsEventListener(this, field));\n        }, this);\n\n        $('kronolithEventStartDate').observe('change', this.fbStartDateOnChange.bind(this));\n        $('kronolithFBDatePrev').observe('click', this.prevFreebusy.bind(this));\n        $('kronolithFBDateNext').observe('click', this.nextFreebusy.bind(this));\n        $('kronolithResourceFBDatePrev').observe('click', this.prevFreebusy.bind(this));\n        $('kronolithResourceFBDateNext').observe('click', this.nextFreebusy.bind(this));\n\n        this.updateMinical(this.date);\n    },\n\n    initialize: function(location, r)\n    {\n        Kronolith.conf.calendars = r.calendars;\n        this.updateCalendarList();\n        HordeSidebar.refreshEvents();\n        $('kronolithLoadingCalendars').hide();\n        $('kronolithMenuCalendars').show();\n        this.initialized = true;\n\n        /* Initialize the starting page. */\n        if (!location.empty()) {\n            this.go(decodeURIComponent(location));\n        } else {\n            this.go(Kronolith.conf.login_view);\n        }\n\n        /* Start polling. */\n        new PeriodicalExecuter(function()\n            {\n                HordeCore.doAction('poll');\n                $(kronolithGotoToday).update(Date.today().toString(Kronolith.conf.date_format));\n            },\n            60\n        );\n    }\n\n};\n\n/* Initialize global event handlers. */\ndocument.observe('dom:loaded', KronolithCore.onDomLoad.bind(KronolithCore));\ndocument.observe('DragDrop2:drag', KronolithCore.onDrag.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:drop', KronolithCore.onDrop.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:end', KronolithCore.onDragEnd.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:start', KronolithCore.onDragStart.bindAsEventListener(KronolithCore));\ndocument.observe('Horde_Calendar:select', KronolithCore.datePickerHandler.bindAsEventListener(KronolithCore));\ndocument.observe('FormGhost:reset', KronolithCore.searchReset.bindAsEventListener(KronolithCore));\ndocument.observe('FormGhost:submit', KronolithCore.searchSubmit.bindAsEventListener(KronolithCore));\ndocument.observe('HordeCore:showNotifications', KronolithCore.showNotification.bindAsEventListener(KronolithCore));\nif (Prototype.Browser.IE) {\n    $('kronolithBody').observe('selectstart', Event.stop);\n}\n\n/* Extend AJAX exception handling. */\nHordeCore.onException = HordeCore.onException.wrap(KronolithCore.onException.bind(KronolithCore));\n"], "fixing_code": ["/**\n * kronolith.js - Base application logic.\n *\n * TODO: loadingImg()\n *\n * Copyright 2008-2017 Horde LLC (http://www.horde.org/)\n *\n * See the enclosed file COPYING for license information (GPL). If you\n * did not receive this file, see http://www.horde.org/licenses/gpl.\n *\n * @author Jan Schneider <jan@horde.org>\n */\n\n/* Kronolith object. */\nKronolithCore = {\n    // Vars used and defaulting to null/false:\n    //   weekSizes, daySizes,\n    //   groupLoading, colorPicker, duration, timeMarker, monthDays,\n    //   allDays, eventsWeek, initialized\n\n    view: '',\n    ecache: $H(),\n    cacheStart: null,\n    cacheEnd: null,\n    holidays: [],\n    tcache: $H(),\n    eventsLoading: {},\n    loading: 0,\n    viewLoading: [],\n    fbLoading: 0,\n    redBoxLoading: false,\n    date: Date.today(),\n    tasktype: 'incomplete',\n    knl: {},\n    wrongFormat: $H(),\n    mapMarker: null,\n    map: null,\n    mapInitialized: false,\n    freeBusy: $H(),\n    search: 'future',\n    effectDur: 0.4,\n    macos: navigator.appVersion.indexOf('Mac') != -1,\n    orstart: null,\n    orend: null,\n    lastRecurType: 'None',\n    uatts: null,\n    ucb: null,\n    resourceACCache: { choices: [], map: $H() },\n    paramsCache: null,\n    attendees: [],\n    resources: [],\n\n    /**\n     * Flag that indicates if the event currently displayed in the event\n     * properties window is a recurring event.\n     *\n     * @type boolean\n     */\n    recurs: false,\n\n    /**\n     * The location that was open before the current location.\n     *\n     * @var string\n     */\n    lastLocation: '',\n\n    /**\n     * The currently open location.\n     *\n     * @var string\n     */\n    openLocation: '',\n\n    /**\n     * The current (main) location.\n     *\n     * This is different from openLocation as it isn't updated for any\n     * locations that are opened in a popup view, e.g. events.\n     *\n     * @var string\n     */\n    currentLocation: '',\n\n    kronolithBody: $('kronolithBody'),\n\n    onException: function(parentfunc, r, e)\n    {\n        /* Make sure loading images are closed. */\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n        this.closeRedBox();\n        HordeCore.notify(HordeCore.text.ajax_error, 'horde.error');\n        parentfunc(r, e);\n    },\n\n    setTitle: function(title)\n    {\n        document.title = Kronolith.conf.name + ' :: ' + title;\n        return title;\n    },\n\n    // url = (string) URL to redirect to\n    // hash = (boolean) If true, url is treated as hash information to alter\n    //        on the current page\n    redirect: function(url, hash)\n    {\n        if (hash) {\n            window.location.hash = escape(url);\n            window.location.reload();\n        } else {\n            HordeCore.redirect(url);\n        }\n    },\n\n    go: function(fullloc, data)\n    {\n        if (!this.initialized) {\n            this.go.bind(this, fullloc, data).defer();\n            return;\n        }\n\n        if (this.viewLoading.size()) {\n            this.viewLoading.push([ fullloc, data ]);\n            return;\n        }\n\n        var locParts = fullloc.split(':');\n        var loc = locParts.shift();\n\n        if (this.openLocation == fullloc) {\n            return;\n        }\n\n        this.viewLoading.push([ fullloc, data ]);\n\n        if (loc != 'search') {\n            HordeTopbar.searchGhost.reset();\n        }\n\n        this.switchTaskView(false);\n\n        switch (loc) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n        case 'month':\n        case 'year':\n        case 'agenda':\n        case 'tasks':\n            this.closeView(loc);\n            var locCap = loc.capitalize();\n            $('kronolithNav' + locCap).up().addClassName('horde-active');\n\n            switch (loc) {\n            case 'day':\n            case 'agenda':\n            case 'week':\n            case 'workweek':\n            case 'month':\n            case 'year':\n                var date = locParts.shift();\n                if (date) {\n                    date = this.parseDate(date);\n                } else {\n                    date = this.date;\n                }\n\n                if (this.view != 'agenda' &&\n                    this.view == loc &&\n                    date.getYear() == this.date.getYear() &&\n                    ((loc == 'year') ||\n                     (loc == 'month' && date.getMonth() == this.date.getMonth()) ||\n                     ((loc == 'week' || loc == 'workweek') && date.getRealWeek() == this.date.getRealWeek()) ||\n                     ((loc == 'day'  || loc == 'agenda') && date.dateString() == this.date.dateString()))) {\n                         this.setViewTitle(date, loc);\n                         this.addHistory(fullloc);\n                         this.loadNextView();\n                         return;\n                }\n\n                this.addHistory(fullloc);\n                this.view = loc;\n                this.date = date;\n                this.updateView(date, loc);\n                var dates = this.viewDates(date, loc);\n                this.loadEvents(dates[0], dates[1], loc);\n                $('kronolithView' + locCap).appear({\n                        duration: this.effectDur,\n                        queue: 'end',\n                        afterFinish: function() {\n                            if (loc == 'week' || loc == 'workweek' || loc == 'day') {\n                                this.calculateRowSizes(loc + 'Sizes', 'kronolithView' + locCap);\n                                if ($('kronolithTimeMarker')) {\n                                    this.positionTimeMarker();\n                                }\n                                if ($('kronolithTimeMarker')) {\n                                    $('kronolithTimeMarker').show();\n                                }\n                                // Scroll to the work day start time.\n                                $('kronolithView' + locCap).down('.kronolithViewBody').scrollTop = 9 * this[loc + 'Sizes'].height;\n                            }\n                            this.loadNextView();\n                        }.bind(this)\n                });\n                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());\n                this.updateMinical(date, loc);\n\n                break;\n\n            case 'tasks':\n                var tasktype = locParts.shift() || this.tasktype;\n\n\n                this.switchTaskView(true);\n                $('kronolithCurrent')\n                    .update(this.setTitle(Kronolith.text.tasks));\n                if (this.view == loc && this.tasktype == tasktype) {\n                    this.addHistory(fullloc);\n                    this.loadNextView();\n                    return;\n                }\n                if (!$w('all complete incomplete future').include(tasktype)) {\n                    this.loadNextView();\n                    return;\n                }\n\n                this.addHistory(fullloc);\n                this.view = loc;\n                this.tasktype = tasktype;\n                $w('All Complete Incomplete Future').each(function(tasktype) {\n                    $('kronolithTasks' + tasktype).up().removeClassName('horde-active');\n                });\n                $('kronolithTasks' + this.tasktype.capitalize()).up().addClassName('horde-active');\n                this.loadTasks(this.tasktype);\n                $('kronolithView' + locCap).appear({\n                    duration: this.effectDur,\n                    queue: 'end',\n                    afterFinish: function() {\n                        this.loadNextView();\n                    }.bind(this) });\n                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());\n                this.updateMinical(this.date);\n\n                break;\n\n            default:\n                if (!$('kronolithView' + locCap)) {\n                    break;\n                }\n                this.addHistory(fullloc);\n                this.view = loc;\n                $('kronolithView' + locCap).appear({\n                    duration: this.effectDur,\n                    queue: 'end',\n                    afterFinish: function() {\n                        this.loadNextView();\n                    }.bind(this) });\n                break;\n            }\n\n            break;\n\n        case 'search':\n            var cals = [], time = locParts[0], term = locParts[1],\n                query = Object.toJSON({ title: term });\n\n            if (!($w('all past future').include(time))) {\n                this.loadNextView();\n                return;\n            }\n\n            this.addHistory(fullloc);\n            this.search = time;\n            $w('All Past Future').each(function(time) {\n                $('kronolithSearch' + time).up().removeClassName('horde-active');\n            });\n            $('kronolithSearch' + this.search.capitalize()).up().addClassName('horde-active');\n            this.closeView('agenda');\n            this.view = 'agenda';\n            this.updateView(null, 'search', term);\n            $H(Kronolith.conf.calendars).each(function(type) {\n                $H(type.value).each(function(calendar) {\n                    if (calendar.value.show) {\n                        cals.push(type.key + '|' + calendar.key);\n                    }\n                });\n            });\n            $('kronolithAgendaNoItems').hide();\n            this.startLoading('search', query);\n\n            HordeCore.doAction('searchEvents', {\n                cals: Object.toJSON(cals),\n                query: query,\n                time: this.search\n            }, {\n                callback: function(r) {\n                    // Hide spinner.\n                    this.loading--;\n                    if (!this.loading) {\n                        $('kronolithLoading').hide();\n                    }\n                    if (r.view != 'search' ||\n                        r.query != this.eventsLoading.search) {\n                        return;\n                    }\n                    if (Object.isUndefined(r.events)) {\n                        $('kronolithAgendaNoItems').show();\n                        return;\n                    }\n                    delete this.eventsLoading.search;\n                    $H(r.events).each(function(calendars) {\n                        $H(calendars.value).each(function(events) {\n                            this.createAgendaDay(events.key);\n                            $H(events.value).each(function(event) {\n                                event.value.calendar = calendars.key;\n                                event.value.start = Date.parse(event.value.s);\n                                event.value.end = Date.parse(event.value.e);\n                                this.insertEvent(event, events.key, 'agenda');\n                            }, this);\n                        }, this);\n                    }, this);\n                }.bind(this)\n            });\n\n            $('kronolithViewAgenda').appear({\n                duration: this.effectDur,\n                queue: 'end',\n                afterFinish: function() {\n                    this.loadNextView();\n                }.bind(this) });\n            $('kronolithLoadingagenda').insert($('kronolithLoading').remove());\n            this.updateMinical(this.date);\n            break;\n\n        case 'event':\n            // Load view first if necessary.\n            if (!this.view ) {\n                this.viewLoading.pop();\n                this.go(Kronolith.conf.login_view);\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n\n            if (this.currentLocation == fullloc) {\n                this.loadNextView();\n                return;\n            }\n\n            this.addHistory(fullloc, false);\n            switch (locParts.length) {\n            case 0:\n                // New event.\n                this.editEvent();\n                break;\n            case 1:\n                // New event on a certain date.\n                this.editEvent(null, null, locParts[0]);\n                break;\n            default:\n                // Editing event.\n                var date = locParts.pop(),\n                    event = locParts.pop(),\n                    calendar = locParts.join(':');\n                this.editEvent(calendar, event, date);\n                break;\n            }\n            this.loadNextView();\n            break;\n\n        case 'task':\n            // Load view first if necessary.\n            if (!this.view ) {\n                this.viewLoading.pop();\n                this.go('tasks');\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n\n            this.switchTaskView(true);\n            switch (locParts.length) {\n            case 0:\n                this.addHistory(fullloc, false);\n                this.editTask();\n                break;\n            case 2:\n                this.addHistory(fullloc, false);\n                this.editTask(locParts[0], locParts[1]);\n                break;\n            }\n            this.loadNextView();\n            break;\n\n        case 'calendar':\n            if (!this.view) {\n                this.viewLoading.pop();\n                this.go(Kronolith.conf.login_view);\n                this.go.bind(this, fullloc, data).defer();\n                return;\n            }\n            this.addHistory(fullloc, false);\n            this.editCalendar(locParts.join(':'));\n            this.loadNextView();\n            break;\n\n        default:\n            this.loadNextView();\n            break;\n        }\n    },\n\n    /**\n     * Removes the last loaded view from the stack and loads the last added\n     * view, if the stack is still not empty.\n     *\n     * We want to load views from a LIFO queue, because the queue is only\n     * building up if the user switches to another view while the current view\n     * still loads. In that case we can go directly to the most recently\n     * clicked view and drop the remaining queue.\n     */\n    loadNextView: function()\n    {\n        var current = this.viewLoading.shift();\n        if (this.viewLoading.size()) {\n            var next = this.viewLoading.pop();\n            this.viewLoading = [];\n            if (current[0] != next[0] || current[1] || next[1]) {\n                this.go(next[0], next[1]);\n            }\n        }\n    },\n\n    /**\n     * Rebuilds one of the calendar views for a new date.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's rebuilt.\n     * @param mixed data   Any additional data that might be required.\n     */\n    updateView: function(date, view, data)\n    {\n        this.holidays = [];\n\n        switch (view) {\n        case 'day':\n            var today = Date.today();\n            this.dayEvents = [];\n            this.dayGroups = [];\n            this.allDayEvents = [];\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n            $('kronolithViewDay')\n                .down('.kronolithAllDayContainer')\n                .store('date', date.dateString());\n            $('kronolithEventsDay').store('date', date.dateString());\n            if (date.equals(today)) {\n                this.addTimeMarker('kronolithEventsDay');\n            }\n            break;\n\n        case 'week':\n        case 'workweek':\n            this.dayEvents = [];\n            this.dayGroups = [];\n            this.allDayEvents = [];\n            this.allDays = {};\n            this.eventsWeek = {};\n            var what = view == 'week' ? 'Week' : 'Workweek',\n                div = $('kronolithEvents' + what).down('div'),\n                th = $('kronolithView' + what + 'Head').down('.kronolithWeekDay'),\n                td = $('kronolithView' + what + 'Head').down('tbody td').next('td'),\n                hourRow = $('kronolithView' + what + 'Body').down('tr'),\n                dates = this.viewDates(date, view),\n                today = Date.today(),\n                day, dateString, i, hourCol;\n\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n\n            for (i = 0; i < 24; i++) {\n                day = dates[0].clone();\n                hourCol = hourRow.down('td').next('td');\n                while (hourCol) {\n                    hourCol.removeClassName('kronolith-today');\n                    if (day.equals(today)) {\n                        hourCol.addClassName('kronolith-today');\n                    }\n                    hourCol = hourCol.next('td');\n                    day.next().day();\n                }\n                hourRow = hourRow.next('tr');\n            }\n            day = dates[0].clone();\n\n            for (i = 0; i < (view == 'week' ? 7 : 5); i++) {\n                dateString = day.dateString();\n                this.allDays['kronolithAllDay' + dateString] = td.down('div');\n                this.eventsWeek['kronolithEvents' + what + dateString] = div;\n                div.store('date', dateString)\n                    .writeAttribute('id', 'kronolithEvents' + what + dateString);\n                th.store('date', dateString)\n                    .down('span').update(day.toString('dddd, d'));\n                td.removeClassName('kronolith-today');\n                this.allDays['kronolithAllDay' + dateString]\n                    .writeAttribute('id', 'kronolithAllDay' + dateString)\n                    .store('date', dateString);\n                if (day.equals(today)) {\n                    td.addClassName('kronolith-today');\n                    this.addTimeMarker('kronolithEvents' + what + dateString);\n                }\n                new Drop(td.down('div'));\n                div = div.next('div');\n                th = th.next('td');\n                td = td.next('td');\n                day.next().day();\n            }\n            break;\n\n        case 'month':\n            var tbody = $('kronolith-month-body'),\n                dates = this.viewDates(date, view),\n                day = dates[0].clone();\n\n            $('kronolithCurrent')\n                .update(this.setViewTitle(date, view, data));\n\n            // Remove old rows. Maybe we should only rebuild the calendars if\n            // necessary.\n            tbody.childElements().each(function(row) {\n                if (row.identify() != 'kronolithRowTemplate') {\n                    row.purge();\n                    row.remove();\n                }\n            });\n\n            // Build new calendar view.\n            this.monthDays = {};\n            while (!day.isAfter(dates[1])) {\n                tbody.insert(this.createWeekRow(day, date.getMonth(), dates).show());\n                day.next().week();\n            }\n            this.equalRowHeights(tbody);\n\n            break;\n\n        case 'year':\n            var month;\n\n            $('kronolithCurrent').update(this.setViewTitle(date, view, data));\n\n            // Build new calendar view.\n            for (month = 0; month < 12; month++) {\n                $('kronolithYear' + month).update(this.createYearMonth(date.getFullYear(), month, 'kronolithYear').show());\n            }\n\n            break;\n\n        case 'agenda':\n        case 'search':\n            // Agenda days are only created on demand, if there are any events\n            // to add.\n            if (view == 'agenda') {\n                var dates = this.viewDates(date, view);\n                $('kronolithCurrent')\n                    .update(this.setViewTitle(date, view, data));\n                $('kronolithSearchNavigation').up().up().hide();\n            } else {\n                $('kronolithCurrent')\n                    .update(this.setViewTitle(date, view, data));\n                $('kronolithSearchNavigation').up().up().show();\n            }\n\n            // Remove old rows. Maybe we should only rebuild the calendars if\n            // necessary.\n            tbody = $('kronolithViewAgendaBody').childElements().each(function(row) {\n                if (row.identify() != 'kronolithAgendaTemplate' &&\n                    row.identify() != 'kronolithAgendaNoItems') {\n                    row.purge();\n                    row.remove();\n                }\n            });\n\n            break;\n        }\n    },\n\n    /**\n     * Sets the browser title of the calendar views.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's displayed.\n     * @param mixed data   Any additional data that might be required.\n     */\n    setViewTitle: function(date, view, data)\n    {\n        switch (view) {\n        case 'day':\n            return this.setTitle(date.toString('D'));\n\n        case 'week':\n        case 'workweek':\n            var dates = this.viewDates(date, view);\n            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));\n\n        case 'month':\n            return this.setTitle(date.toString('MMMM yyyy'));\n\n        case 'year':\n            return this.setTitle(date.toString('yyyy'));\n\n        case 'agenda':\n            var dates = this.viewDates(date, view);\n            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));\n\n        case 'search':\n            return this.setTitle(Kronolith.text.searching.interpolate({ term: data })).escapeHTML();\n        }\n    },\n\n    /**\n     * Closes the currently active view.\n     */\n    closeView: function(loc)\n    {\n        $w('Day Workweek Week Month Year Tasks Agenda').each(function(a) {\n            a = $('kronolithNav' + a);\n            if (a) {\n                a.up().removeClassName('horde-active');\n            }\n        });\n        if (this.view && this.view != loc) {\n            $('kronolithView' + this.view.capitalize()).fade({\n                duration: this.effectDur,\n                queue: 'end'\n            });\n            this.view = null;\n        }\n    },\n\n    /**\n     * Creates a single row of day cells for usage in the month and multi-week\n     * views.\n     *\n     * @param Date date        The first day to show in the row.\n     * @param integer month    The current month. Days not from the current\n     *                         month get the kronolith-other-month CSS class\n     *                         assigned.\n     * @param array viewDates  Array of Date objects with the start and end\n     *                         dates of the view.\n     *\n     * @return Element  The element rendering a week row.\n     */\n    createWeekRow: function(date, month, viewDates)\n    {\n        var day = date.clone(), today = new Date().dateString(),\n            row, cell, dateString;\n\n        // Create a copy of the row template.\n        row = $('kronolithRowTemplate').clone(true);\n        row.removeAttribute('id');\n\n        // Fill week number and day cells.\n        cell = row.down()\n            .setText(date.getRealWeek())\n            .store('date', date.dateString())\n            .next();\n        while (cell) {\n            dateString = day.dateString();\n            this.monthDays['kronolithMonthDay' + dateString] = cell;\n            cell.id = 'kronolithMonthDay' + dateString;\n            cell.store('date', dateString);\n            cell.removeClassName('kronolith-other-month').removeClassName('kronolith-today');\n            if (day.getMonth() != month) {\n                cell.addClassName('kronolith-other-month');\n            }\n            if (dateString == today) {\n                cell.addClassName('kronolith-today');\n            }\n            new Drop(cell);\n            cell.store('date', dateString)\n                .down('.kronolith-day')\n                .store('date', dateString)\n                .update(day.getDate());\n\n            cell = cell.next();\n            day.add(1).day();\n        }\n\n        return row;\n    },\n\n    /**\n     * Creates a table row for a single day in the agenda view, if it doesn't\n     * exist yet.\n     *\n     * @param string date    The day to show in the row.\n     *\n     * @return Element  The element rendering a week row.\n     */\n    createAgendaDay: function(date)\n    {\n        // Exit if row exists already.\n        if ($('kronolithAgendaDay' + date)) {\n            return;\n        }\n\n        // Create a copy of the row template.\n        var body = $('kronolithViewAgendaBody'),\n            row = $('kronolithAgendaTemplate').clone(true);\n\n        // Fill week number and day cells.\n        row.store('date', date)\n            .down()\n            .setText(this.parseDate(date).toString('D'))\n            .next()\n            .writeAttribute('id', 'kronolithAgendaDay' + date);\n        row.removeAttribute('id');\n\n        // Insert row.\n        var nextRow;\n        body.childElements().each(function(elm) {\n            if (elm.retrieve('date') > date) {\n                nextRow = elm;\n                throw $break;\n            }\n        });\n        if (nextRow) {\n            nextRow.insert({ before: row.show() });\n        } else {\n            body.insert(row.show());\n        }\n\n        return row;\n    },\n\n    /**\n     * Creates a table for a single month in the year view.\n     *\n     * @param integer year     The year.\n     * @param integer month    The month.\n     * @param string idPrefix  If present, each day will get a DOM ID with this\n     *                         prefix\n     *\n     * @return Element  The element rendering a month table.\n     */\n    createYearMonth: function(year, month, idPrefix)\n    {\n        // Create a copy of the month template.\n        var table = $('kronolithYearTemplate').clone(true),\n            tbody = table.down('tbody');\n        table.removeAttribute('id');\n        tbody.writeAttribute('id', 'kronolithYearTable' + month);\n\n        // Set month name.\n        table.down('tr.kronolith-minical-nav th')\n            .store('date', year.toPaddedString(4) + (month + 1).toPaddedString(2) + '01')\n            .update(Date.CultureInfo.monthNames[month]);\n\n        // Build month table.\n        this.buildMinical(tbody, new Date(year, month, 1), null, idPrefix, year);\n\n        return table;\n    },\n\n    equalRowHeights: function(tbody)\n    {\n        var children = tbody.childElements();\n        children.invoke('setStyle', { height: (100 / (children.size() - 1)) + '%' });\n    },\n\n    /**\n     * Calculates some dimensions for the day and week view.\n     *\n     * @param string storage  Property name where the dimensions are stored.\n     * @param string view     DOM node ID of the view.\n     */\n    calculateRowSizes: function(storage, view)\n    {\n        if (!Object.isUndefined(this[storage])) {\n            return;\n        }\n\n        var td = $(view).down('.kronolithViewBody tr td').next('td'),\n            layout = td.getLayout(),\n            spacing = td.up('table').getStyle('borderSpacing');\n\n        // FIXME: spacing is hardcoded for IE 7 because it doesn't know about\n        // border-spacing, but still uses it. WTF?\n        spacing = spacing ? parseInt($w(spacing)[1], 10) : 2;\n        this[storage] = {};\n        this[storage].height = layout.get('margin-box-height') + spacing;\n        this[storage].spacing = this[storage].height - layout.get('padding-box-height') - layout.get('border-bottom');\n    },\n\n    /**\n     * Adds a horizontal ruler representing the current time to the specified\n     * container.\n     *\n     * @param string|Element  The container of the current day.\n     */\n    addTimeMarker: function(container)\n    {\n        if ($('kronolithTimeMarker')) {\n            $('kronolithTimeMarker').remove();\n            this.timeMarker.stop();\n        }\n        $(container).insert(new Element('div', { id: 'kronolithTimeMarker' }).setStyle({ position: 'absolute' }).hide());\n        this.timeMarker = new PeriodicalExecuter(this.positionTimeMarker.bind(this), 60);\n    },\n\n    /**\n     * Updates the horizontal ruler representing the current time.\n     */\n    positionTimeMarker: function()\n    {\n        var today = Date.today(), now;\n\n        switch (this.view) {\n        case 'day':\n            if (!this.date.equals(today)) {\n                $('kronolithTimeMarker').remove();\n                this.timeMarker.stop();\n                return;\n            }\n            break;\n        case 'week':\n        case 'workweek':\n            if ($('kronolithTimeMarker').up().retrieve('date') != today.dateString()) {\n                var newContainer = this.eventsWeek['kronolithEvents' + (this.view == 'week' ? 'Week' : 'Workweek') + today.dateString()];\n                $('kronolithTimeMarker').remove();\n                if (newContainer) {\n                    this.addTimeMarker(newContainer);\n                } else {\n                    this.timeMarker.stop();\n                }\n                return;\n            }\n            break;\n        default:\n            $('kronolithTimeMarker').remove();\n            this.timeMarker.stop();\n            return;\n        }\n\n        now = new Date();\n        $('kronolithTimeMarker').setStyle({ top: ((now.getHours() * 60 + now.getMinutes()) * this[this.view + 'Sizes'].height / 60 | 0) + 'px' });\n    },\n\n    /**\n     * Rebuilds the mini calendar.\n     *\n     * @param Date date    The date to show in the calendar.\n     * @param string view  The view that's displayed, determines which days in\n     *                     the mini calendar are highlighted.\n     */\n    updateMinical: function(date, view)\n    {\n        // Update header.\n        $('kronolithMinicalDate')\n            .store('date', date.dateString())\n            .update(date.toString('MMMM yyyy'));\n\n        this.buildMinical($('kronolith-minical').down('tbody'), date, view);\n    },\n\n    /**\n     * Creates a mini calendar suitable for the navigation calendar and the\n     * year view.\n     *\n     * @param Element tbody    The table body to add the days to.\n     * @param Date date        The date to show in the calendar.\n     * @param string view      The view that's displayed, determines which days\n     *                         in the mini calendar are highlighted.\n     * @param string idPrefix  If present, each day will get a DOM ID with this\n     *                         prefix\n     * @param integer year     If present, generating mini calendars for the\n     *                         year view of this year.\n     */\n    buildMinical: function(tbody, date, view, idPrefix, year)\n    {\n        var dates = this.viewDates(date, 'month'),\n            day = dates[0].clone(),\n            date7 = date.clone().add(1).week(),\n            today = Date.today(),\n            week = this.viewDates(this.date, 'week'),\n            workweek = this.viewDates(this.date, 'workweek'),\n            dateString, td, tr, i;\n\n        // Remove old calendar rows. Maybe we should only rebuild the minical\n        // if necessary.\n        tbody.childElements().invoke('remove');\n\n        for (i = 0; i < 42; i++) {\n            dateString = day.dateString();\n            // Create calendar row and insert week number.\n            if (day.getDay() == Kronolith.conf.week_start) {\n                tr = new Element('tr');\n                tbody.insert(tr);\n                td = new Element('td', { className: 'kronolith-minical-week' })\n                    .store('weekdate', dateString);\n                td.update(day.getRealWeek());\n                tr.insert(td);\n                weekStart = day.clone();\n                weekEnd = day.clone();\n                weekEnd.add(6).days();\n            }\n\n            // Insert day cell.\n            td = new Element('td').store('date', dateString);\n            if (day.getMonth() != date.getMonth()) {\n                td.addClassName('kronolith-other-month');\n            } else if (!Object.isUndefined(idPrefix)) {\n                td.id = idPrefix + dateString;\n            }\n\n            // Highlight days currently being displayed.\n            if (view &&\n                ((view == 'month' && this.date.between(dates[0], dates[1])) ||\n                 (view == 'week' && day.between(week[0], week[1])) ||\n                 (view == 'workweek' && day.between(workweek[0], workweek[1])) ||\n                 (view == 'day' && day.equals(this.date)) ||\n                 (view == 'agenda' && !day.isBefore(date) && day.isBefore(date7)))) {\n                td.addClassName('kronolith-selected');\n            }\n\n            // Highlight today.\n            if (day.equals(today) &&\n                (Object.isUndefined(year) ||\n                 (day.getYear() + 1900 == year &&\n                  date.getMonth() == day.getMonth()))) {\n                td.addClassName('kronolith-today');\n            }\n            td.insert(new Element('a').update(day.getDate()));\n            tr.insert(td);\n            day.next().day();\n        }\n    },\n\n    /**\n     * Inserts a calendar entry in the sidebar menu.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     * @param object cal   The calendar object.\n     * @param Element div  Container DIV where to add the entry (optional).\n     */\n    insertCalendarInList: function(type, id, cal, div)\n    {\n        var noItems, calendar, link;\n        if (!div) {\n            div = this.getCalendarList(type, cal.owner);\n        }\n        noItems = div.previous();\n        if (noItems &&\n            noItems.tagName == 'DIV' &&\n            noItems.className == 'horde-info') {\n            noItems.hide();\n        }\n        link = new Element('span', { className: type != 'resourcegroup' ? (cal.show ? 'horde-resource-on' : 'horde-resource-off') : 'horde-resource-none' })\n            .insert(cal.name.escapeHTML());\n        calendar = new Element('div')\n            .store('calendar', id)\n            .store('calendarclass', type)\n            .setStyle({ backgroundColor: cal.bg, color: cal.fg });\n        if (type != 'holiday' && type != 'external') {\n            calendar.insert(\n                new Element('span', { className: 'horde-resource-edit-' + cal.fg.substring(1) })\n                    .setStyle({ backgroundColor: cal.bg, color: cal.fg })\n                    .insert('&#9658;'));\n        }\n        calendar.insert(\n            new Element('div', { className: 'horde-resource-link' })\n                .insert(link));\n        this.addShareIcon(cal, link);\n        div.insert(calendar);\n        if (cal.show) {\n            this.addCalendarLegend(type, id, cal);\n        }\n    },\n\n    /**\n     * Add the share icon after the calendar name in the calendar list.\n     *\n     * @param object cal       A calendar object from Kronolith.conf.calendars.\n     * @param Element element  The calendar element in the list.\n     */\n    addShareIcon: function(cal, element)\n    {\n        if (cal.owner && cal.perms) {\n            $H(cal.perms).each(function(perm) {\n                if (perm.key != 'type' &&\n                    ((Object.isArray(perm.value) && perm.value.size()) ||\n                     (!Object.isArray(perm.value) && perm.value))) {\n                    element.insert(' ').insert(new Element('img', { src: Kronolith.conf.images.attendees.replace(/fff/, cal.fg.substring(1)), title: Kronolith.text.shared }));\n                    throw $break;\n                }\n            });\n        }\n    },\n\n    /**\n     * Rebuilds the list of calendars.\n     */\n    updateCalendarList: function()\n    {\n        var ext = $H(), extNames = $H(),\n            extContainer = $('kronolithExternalCalendars');\n\n        $H(Kronolith.conf.calendars.internal).each(function(cal) {\n            this.insertCalendarInList('internal', cal.key, cal.value);\n        }, this);\n\n        if (Kronolith.conf.tasks) {\n            $H(Kronolith.conf.calendars.tasklists).each(function(cal) {\n                this.insertCalendarInList('tasklists', cal.key, cal.value);\n            }, this);\n        }\n\n        if (Kronolith.conf.calendars.resource) {\n            $H(Kronolith.conf.calendars.resource).each(function(cal) {\n               this.insertCalendarInList('resource', cal.key, cal.value);\n            }, this);\n        }\n\n        if (Kronolith.conf.calendars.resourcegroup) {\n            $H(Kronolith.conf.calendars.resourcegroup).each(function(cal) {\n                this.insertCalendarInList('resourcegroup', cal.key, cal.value);\n            }, this);\n        }\n\n        $H(Kronolith.conf.calendars.external).each(function(cal) {\n            var parts = cal.key.split('/'), api = parts.shift();\n            if (!ext.get(api)) {\n                ext.set(api, $H());\n            }\n            ext.get(api).set(parts.join('/'), cal.value);\n            extNames.set(api, cal.value.api ? cal.value.api : Kronolith.text.external_category);\n        });\n        ext.each(function(api) {\n            extContainer\n                .insert(new Element('div', { className: 'horde-sidebar-split' }))\n                .insert(new Element('div')\n                        .insert(new Element('h3')\n                                .insert(new Element('span', { className: 'horde-expand', title: HordeSidebar.text.expand })\n                                        .insert({ bottom: extNames.get(api.key).escapeHTML() })))\n                        .insert(new Element('div', { id: 'kronolithExternalCalendar' + api.key, className: 'horde-resources', style: 'display:none' })));\n            api.value.each(function(cal) {\n                this.insertCalendarInList('external', api.key + '/' + cal.key, cal.value, $('kronolithExternalCalendar' + api.key));\n            }, this);\n        }, this);\n\n        $H(Kronolith.conf.calendars.remote).each(function(cal) {\n            this.insertCalendarInList('remote', cal.key, cal.value);\n        }, this);\n\n        if (Kronolith.conf.calendars.holiday) {\n            $H(Kronolith.conf.calendars.holiday).each(function(cal) {\n                if (cal.value.show) {\n                   this.insertCalendarInList('holiday', cal.key, cal.value);\n                }\n            }, this);\n        } else {\n            $('kronolithAddholiday').up().hide();\n            $('kronolithHolidayCalendars').hide();\n        }\n    },\n\n    /**\n     * Returns the DIV container that holds all calendars of a certain type.\n     *\n     * @param string type  A calendar type\n     *\n     * @return Element  The container of the calendar type.\n     */\n    getCalendarList: function(type, personal)\n    {\n        switch (type) {\n        case 'internal':\n            return personal\n                ? $('kronolithMyCalendars')\n                : $('kronolithSharedCalendars');\n        case 'resource':\n            return $('kronolithResourceCalendars');\n        case 'resourcegroup':\n            return $('kronolithResourceGroups');\n        case 'tasklists':\n            return personal\n                ? $('kronolithMyTasklists')\n                : $('kronolithSharedTasklists');\n        case 'external':\n            return $('kronolithExternalCalendars');\n        case 'remote':\n            return $('kronolithRemoteCalendars');\n        case 'holiday':\n            return $('kronolithHolidayCalendars');\n        }\n    },\n\n    /**\n     * Loads a certain calendar, if the current view is still a calendar view.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    loadCalendar: function(type, calendar)\n    {\n        if (Kronolith.conf.calendars[type][calendar].show &&\n            $w('day workweek week month year agenda').include(this.view)) {\n            var dates = this.viewDates(this.date, this.view);\n            this.deleteCache([type, calendar]);\n            this.loadEvents(dates[0], dates[1], this.view, [[type, calendar]]);\n        }\n    },\n\n    /**\n     * Toggles a calendars visibility.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    toggleCalendar: function(type, calendar)\n    {\n        var elt = $('kronolithMenuCalendars').select('div').find(function(div) {\n            return div.retrieve('calendarclass') == type &&\n            div.retrieve('calendar') == calendar;\n        }).down('.horde-resource-link').down('span');\n\n        Kronolith.conf.calendars[type][calendar].show = !Kronolith.conf.calendars[type][calendar].show;\n        elt.toggleClassName('horde-resource-on');\n        elt.toggleClassName('horde-resource-off');\n\n        if (Kronolith.conf.calendars[type][calendar].show) {\n            this.addCalendarLegend(type, calendar, Kronolith.conf.calendars[type][calendar]);\n        } else {\n            this.deleteCalendarLegend(type, calendar);\n        }\n\n        switch (this.view) {\n        case 'month':\n        case 'agenda':\n            if (Object.isUndefined(this.ecache.get(type)) ||\n                Object.isUndefined(this.ecache.get(type).get(calendar))) {\n                this.loadCalendar(type, calendar);\n            } else {\n                var allEvents = this.kronolithBody.select('div').findAll(function(el) {\n                    return el.retrieve('calendar') == type + '|' + calendar;\n                });\n                if (this.view == 'month' && Kronolith.conf.max_events) {\n                    var dates = this.viewDates(this.date, this.view);\n                    if (elt.hasClassName('horde-resource-off')) {\n                        var day, more, events, calendars = [];\n                        $H(Kronolith.conf.calendars).each(function(type) {\n                            $H(type.value).each(function(cal) {\n                                if (cal.value.show) {\n                                    calendars.push(type.key + '|' + cal.key);\n                                }\n                            });\n                        });\n                        allEvents.each(function(el) {\n                            if (el.retrieve('calendar').startsWith('holiday|')) {\n                                this.holidays = this.holidays.without(el.retrieve('eventid'));\n                            }\n                            el.remove();\n                        }, this);\n                        for (var date = dates[0]; !date.isAfter(dates[1]); date.add(1).days()) {\n                            day = this.monthDays['kronolithMonthDay' + date.dateString()];\n                            more = day.select('.kronolithMore');\n                            events = day.select('.kronolith-event');\n                            if (more.size() &&\n                                events.size() < Kronolith.conf.max_events) {\n                                more[0].purge();\n                                more[0].remove();\n                                events.invoke('remove');\n                                calendars.each(function(calendar) {\n                                    this.insertEvents([date, date], 'month', calendar);\n                                }, this);\n                            }\n                        }\n                    } else {\n                        this.insertEvents(dates, 'month', type + '|' + calendar);\n                    }\n                } else {\n                    allEvents.invoke('toggle');\n                }\n            }\n            break;\n\n        case 'year':\n        case 'week':\n        case 'workweek':\n        case 'day':\n            if (Object.isUndefined(this.ecache.get(type)) ||\n                Object.isUndefined(this.ecache.get(type).get(calendar))) {\n                this.loadCalendar(type, calendar);\n            } else {\n                this.insertEvents(this.viewDates(this.date, this.view), this.view);\n            }\n            break;\n\n        case 'tasks':\n            if (type != 'tasklists') {\n                break;\n            }\n            var tasklist = calendar.substr(6);\n            if (elt.hasClassName('horde-resource-off')) {\n                $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n                    return el.retrieve('tasklist') == tasklist;\n                }).invoke('remove');\n            } else {\n                this.loadTasks(this.tasktype, [ tasklist ]);\n            }\n            break;\n        }\n\n        if ($w('tasklists remote external holiday resource').include(type)) {\n            calendar = type + '_' + calendar;\n        }\n        HordeCore.doAction('saveCalPref', { toggle_calendar: calendar });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the editable calendars.\n     *\n     * @param string id  The id of the SELECT element.\n     */\n    updateCalendarDropDown: function(id)\n    {\n        $(id).update();\n        ['internal', 'remote'].each(function(type) {\n            $H(Kronolith.conf.calendars[type]).each(function(cal) {\n                if (cal.value.edit) {\n                    $(id).insert(new Element('option', { value: type + '|' + cal.key })\n                                 .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })\n                                 .update(cal.value.name.escapeHTML()));\n                }\n            });\n        });\n    },\n\n    /**\n     * Adds a calendar entry to the print legend.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     * @param object cal   The calendar object.\n     */\n    addCalendarLegend: function(type, id, cal)\n    {\n        $('kronolith-legend').insert(\n            new Element('span')\n                .insert(cal.name.escapeHTML())\n                .store('calendar', id)\n                .store('calendarclass', type)\n                .setStyle({ backgroundColor: cal.bg, color: cal.fg })\n        );\n    },\n\n    /**\n     * Deletes a calendar entry from the print legend.\n     *\n     * @param string type  The calendar type.\n     * @param string id    The calendar id.\n     */\n    deleteCalendarLegend: function(type, id)\n    {\n        var legend = $('kronolith-legend').select('span').find(function(span) {\n            return span.retrieve('calendarclass') == type &&\n                span.retrieve('calendar') == id;\n        });\n        if (legend) {\n            legend.remove();\n        }\n    },\n\n    /**\n     * Opens a tab in a form.\n     *\n     * @param Element  The A element of a tab.\n     */\n    openTab: function(elt)\n    {\n        var dialog = elt.up('form'), tab = $(elt.id.replace(/Link/, 'Tab')),\n            field;\n        dialog.select('.kronolithTabsOption').invoke('hide');\n        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');\n        tab.show();\n        elt.up().addClassName('horde-active');\n        if (elt.id == 'kronolithEventLinkMap') {\n            if (!this.mapInitialized) {\n                this.initializeMap();\n            }\n        }\n        field = tab.down('textarea');\n        if (!field) {\n            field = tab.down('input');\n        }\n        if (field) {\n            try {\n                field.focus();\n            } catch (e) {}\n        }\n        switch (tab.identify()) {\n        case 'kronolithEventTabAttendees':\n            this.attendeeStartDateHandler(this.getFBDate());\n            break;\n        case 'kronolithEventTabResources':\n            this.resourceStartDateHandler(this.getFBDate());\n            break;\n        }\n    },\n\n    /**\n     * Sets the load signature and show the loading spinner.\n     *\n     * @param string resource   The loading resource.\n     * @param string signatrue  The signature for this request.\n     */\n    startLoading: function(resource, signature)\n    {\n        this.eventsLoading[resource] = signature;\n        this.loading++;\n        $('kronolithLoading').show();\n    },\n\n    /**\n     */\n    loadEvents: function(firstDay, lastDay, view, calendars)\n    {\n        var loading = false;\n\n        if (typeof calendars == 'undefined') {\n            calendars = [];\n            $H(Kronolith.conf.calendars).each(function(type) {\n                $H(type.value).each(function(cal) {\n                    if (cal.value.show) {\n                        calendars.push([type.key, cal.key]);\n                    }\n                });\n            });\n        }\n\n        calendars.each(function(cal) {\n            var startDay = firstDay.clone(), endDay = lastDay.clone(),\n                cals = this.ecache.get(cal[0]);\n\n            if (typeof cals != 'undefined' &&\n                typeof cals.get(cal[1]) != 'undefined') {\n                cals = cals.get(cal[1]);\n                while (!Object.isUndefined(cals.get(startDay.dateString())) &&\n                       startDay.isBefore(endDay)) {\n                    if (view != 'year') {\n                        this.insertEvents([startDay, startDay], view, cal.join('|'));\n                    }\n                    startDay.add(1).day();\n                }\n                while (!Object.isUndefined(cals.get(endDay.dateString())) &&\n                       (!startDay.isAfter(endDay))) {\n                    if (view != 'year') {\n                        this.insertEvents([endDay, endDay], view, cal.join('|'));\n                    }\n                    endDay.add(-1).day();\n                }\n                if (startDay.compareTo(endDay) > 0) {\n                    return;\n                }\n            }\n            var start = startDay.dateString(), end = endDay.dateString(),\n                calendar = cal.join('|');\n            loading = true;\n            this.startLoading(calendar, start + end);\n            this.storeCache($H(), calendar, null, true);\n\n            HordeCore.doAction('listEvents', {\n                start: start,\n                end: end,\n                cal: calendar,\n                sig: start + end,\n                view: view\n            }, {\n                callback: function(r) {\n                    this.loadEventsCallback(r, true);\n                }.bind(this)\n            });\n        }, this);\n\n        if (!loading && view == 'year') {\n            this.insertEvents([firstDay, lastDay], 'year');\n        }\n    },\n\n    /**\n     * Callback method for inserting events in the current view.\n     *\n     * @param object r             The ajax response object.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet. Useful for\n     *                             (not) adding individual events to the cache\n     *                             if it doesn't match any cached views.\n     */\n    loadEventsCallback: function(r, createCache)\n    {\n        // Hide spinner.\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n\n        var start = this.parseDate(r.sig.substr(0, 8)),\n            end = this.parseDate(r.sig.substr(8, 8)),\n            dates = [start, end],\n            currentDates;\n\n        this.storeCache(r.events || {}, r.cal, dates, createCache);\n\n        // Check if this is the still the result of the most current request.\n        if (r.sig != this.eventsLoading[r.cal]) {\n            return;\n        }\n        delete this.eventsLoading[r.cal];\n\n        // Check if the calendar is still visible.\n        var calendar = r.cal.split('|');\n        if (!Kronolith.conf.calendars[calendar[0]][calendar[1]].show) {\n            return;\n        }\n\n        // Check if the result is still for the current view.\n        currentDates = this.viewDates(this.date, this.view);\n        if (r.view != this.view ||\n            !start.between(currentDates[0], currentDates[1])) {\n\n            return;\n        }\n\n        if (this.view == 'day' ||\n            this.view == 'week' ||\n            this.view == 'workweek' ||\n            this.view == 'month' ||\n            this.view == 'agenda' ||\n            (this.view == 'year' && !$H(this.eventsLoading).size())) {\n            this.insertEvents(dates, this.view, r.cal);\n        }\n    },\n\n    /**\n     * Reads events from the cache and inserts them into the view.\n     *\n     * If inserting events into day and week views, the calendar parameter is\n     * ignored, and events from all visible calendars are inserted instead.\n     * This is necessary because the complete view has to be re-rendered if\n     * events are not in chronological order.\n     * The year view is specially handled too because there are no individual\n     * events, only a summary of all events per day.\n     *\n     * @param Array dates      Start and end of dates to process.\n     * @param string view      The view to update.\n     * @param string calendar  The calendar to update.\n     */\n    insertEvents: function(dates, view, calendar)\n    {\n        switch (view) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n            // The day and week views require the view to be completely\n            // loaded, to correctly calculate the dimensions.\n            if (this.viewLoading.size() || this.view != view) {\n                this.insertEvents.bind(this, [dates[0].clone(), dates[1].clone()], view, calendar).defer();\n                return;\n            }\n            break;\n        }\n\n        var day = dates[0].clone(),\n                  viewDates = this.viewDates(this.date, this.view),\n                  date, more, title, titles, events, monthDay, busyHours;\n        while (!day.isAfter(dates[1])) {\n            // Skip if somehow events slipped in though the view is gone.\n            if (!day.between(viewDates[0], viewDates[1])) {\n                if (window.console) {\n                    window.console.trace();\n                }\n                day.next().day();\n                continue;\n            }\n\n            date = day.dateString();\n            switch (view) {\n            case 'day':\n            case 'week':\n            case 'workweek':\n                this.dayEvents = [];\n                this.dayGroups = [];\n                this.allDayEvents = [];\n                if (view == 'day') {\n                    $$('.kronolith-event').invoke('remove');\n                } else {\n                    this.eventsWeek['kronolithEvents' + (view == 'week' ? 'Week' : 'Workweek') + date]\n                        .select('.kronolith-event')\n                        .invoke('remove');\n                    this.allDays['kronolithAllDay' + date]\n                        .childElements()\n                        .invoke('remove');\n                }\n                break;\n\n            case 'month':\n                monthDay = this.monthDays['kronolithMonthDay' + date];\n                monthDay.select('div')\n                    .findAll(function(el) { return el.retrieve('calendar') == calendar; })\n                    .invoke('remove');\n                break;\n\n            case 'year':\n                titles = [];\n                busyHours = 0;\n            }\n\n            if (view == 'month' || view == 'agenda') {\n                events = this.getCacheForDate(date, calendar);\n            } else {\n                events = this.getCacheForDate(date);\n            }\n            events.sortBy(this.sortEvents).each(function(event) {\n                var insertBefore;\n                switch (view) {\n                case 'month':\n                case 'agenda':\n                    if (calendar.startsWith('holiday|')) {\n                        if (this.holidays.include(event.key)) {\n                            return;\n                        }\n                        this.holidays.push(event.key);\n                    }\n                    if (view == 'month' && Kronolith.conf.max_events) {\n                        more = monthDay.down('.kronolithMore');\n                        if (more) {\n                            more.purge();\n                            more.remove();\n                        }\n                    }\n                    if (view == 'month') {\n                        if (Kronolith.conf.max_events) {\n                        var events = monthDay.select('.kronolith-event');\n                        if (events.size() >= Kronolith.conf.max_events) {\n                            if (date == (new Date().dateString())) {\n                                // This is today.\n                                if (event.value.al || event.value.end.isBefore()) {\n                                    // No room for all-day or finished events.\n                                    this.insertMore(date);\n                                    return;\n                                }\n                                var remove, max;\n                                // Find an event that is earlier than now or\n                                // later then the current event.\n                                events.each(function(elm) {\n                                    var calendar = elm.retrieve('calendar').split('|'),\n                                        event = this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid'));\n                                    if (event.start.isBefore()) {\n                                        remove = elm;\n                                        throw $break;\n                                    }\n                                    if (!max || event.start.isAfter(max)) {\n                                        max = event.start;\n                                        remove = elm;\n                                    }\n                                }, this);\n                                if (remove) {\n                                    remove.purge();\n                                    remove.remove();\n                                    insertBefore = this.findInsertBefore(events.without(remove), event, date);\n                                } else {\n                                    this.insertMore(date);\n                                    return;\n                                }\n                            } else {\n                                // Not today.\n                                var allDays = events.findAll(function(elm) {\n                                    var calendar = elm.retrieve('calendar').split('|');\n                                    return this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).al;\n                                }.bind(this));\n                                if (event.value.al) {\n                                    // We want one all-day event.\n                                    if (allDays.size()) {\n                                        // There already is an all-day event.\n                                        if (event.value.x == Kronolith.conf.status.confirmed ||\n                                            event.value.x == Kronolith.conf.status.tentative) {\n                                            // But is there a less important\n                                            // one?\n                                            var status = [Kronolith.conf.status.free, Kronolith.conf.status.cancelled];\n                                            if (event.value.x == Kronolith.conf.status.confirmed) {\n                                                status.push(Kronolith.conf.status.tentative);\n                                            }\n                                            var free = allDays.detect(function(elm) {\n                                                var calendar = elm.retrieve('calendar').split('|');\n                                                return status.include(this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).x);\n                                            }.bind(this));\n                                            if (!free) {\n                                                this.insertMore(date);\n                                                return;\n                                            }\n                                            insertBefore = free.next();\n                                            free.purge();\n                                            free.remove();\n                                        } else {\n                                            // No.\n                                            this.insertMore(date);\n                                            return;\n                                        }\n                                    } else {\n                                        // Remove the last event to make room\n                                        // for this one.\n                                        var elm = events.pop();\n                                        elm.purge();\n                                        elm.remove();\n                                        insertBefore = events.first();\n                                    }\n                                } else {\n                                    if (allDays.size() > 1) {\n                                        // We don't want more than one all-day\n                                        // event.\n                                        var elm = allDays.pop();\n                                        // Remove element from events as well.\n                                        events = events.without(elm);\n                                        elm.purge();\n                                        elm.remove();\n                                        insertBefore = this.findInsertBefore(events, event, date);\n                                    } else {\n                                        // This day is full.\n                                        this.insertMore(date);\n                                        return;\n                                    }\n                                }\n                            }\n                            this.insertMore(date);\n                        } else {\n                            insertBefore = this.findInsertBefore(events, event, date);\n                        }\n                        } else {\n                            var events = monthDay.select('.kronolith-event');\n                            insertBefore = this.findInsertBefore(events, event, date);\n                        }\n                    }\n                    break;\n\n                case 'year':\n                    title = '';\n                    if (event.value.al) {\n                        title += Kronolith.text.allday;\n                    } else {\n                        title += event.value.start.toString('t') + '-' + event.value.end.toString('t');\n                    }\n                    if (event.value.t) {\n                        title += ': ' + event.value.t.escapeHTML();\n                    }\n                    if (event.value.x == Kronolith.conf.status.tentative ||\n                        event.value.x == Kronolith.conf.status.confirmed) {\n                        busyHours += event.value.start.getElapsed(event.value.end) / 3600000;\n                    }\n                    titles.push(title);\n                    return;\n                }\n                this.insertEvent(event, date, view, insertBefore);\n            }, this);\n\n            switch (view) {\n            case 'agenda':\n                if ($('kronolithViewAgendaBody').select('tr').length > 2) {\n                    $('kronolithAgendaNoItems').hide();\n                } else {\n                    $('kronolithAgendaNoItems').show();\n                }\n                break;\n\n            case 'year':\n                var td = $('kronolithYear' + date);\n                if (td.className == 'kronolith-minical-empty') {\n                    continue;\n                }\n                if (td.hasClassName('kronolith-today')) {\n                    td.className = 'kronolith-today';\n                } else {\n                    td.className = '';\n                }\n                if (titles.length) {\n                    td.addClassName('kronolithHasEvents');\n                    if (busyHours > 0) {\n                        td.addClassName(this.getHeatmapClass(busyHours));\n                        busyHours = 0;\n                    }\n                    td.down('a').writeAttribute('nicetitle', Object.toJSON(titles));\n                }\n            }\n\n            day.next().day();\n        }\n        // Workaround Firebug bug.\n        Prototype.emptyFunction();\n    },\n\n    findInsertBefore: function(events, event, date)\n    {\n        var insertBefore, insertSort;\n        events.each(function(elm) {\n            var calendar = elm.retrieve('calendar').split('|'),\n                existing = this.ecache\n                    .get(calendar[0])\n                    .get(calendar[1])\n                    .get(date)\n                    .get(elm.retrieve('eventid'));\n            if (event.value.sort < existing.sort &&\n                (!insertSort || existing.sort < insertSort)) {\n                insertBefore = elm;\n                insertSort = existing.sort;\n            }\n        }, this);\n        return insertBefore;\n    },\n\n    getHeatmapClass: function(hours)\n    {\n        return 'heat' + Math.min(Math.ceil(hours / 2), 6);\n    },\n\n    /**\n     * Creates the DOM node for an event bubble and inserts it into the view.\n     *\n     * @param object event    A Hash member with the event to insert.\n     * @param string date     The day to update.\n     * @param string view     The view to update.\n     * @param Element before  Insert the event before this element (month view).\n     */\n    insertEvent: function(event, date, view, before)\n    {\n        var calendar = event.value.calendar.split('|');\n        event.value.nodeId = ('kronolithEvent' + view + event.value.calendar + date + event.key).replace(new RegExp('[^a-zA-Z0-9]', 'g'), '');\n\n        var _createElement = function(event) {\n            var className ='kronolith-event';\n            switch (event.value.x) {\n            case 3:\n                className += ' kronolith-event-cancelled';\n                break;\n            case 1:\n            case 4:\n                className += ' kronolith-event-tentative';\n                break;\n            }\n            var el = new Element('div', { id: event.value.nodeId, className: className })\n                .store('calendar', event.value.calendar)\n                .store('eventid', event.key);\n            if (!Object.isUndefined(event.value.aj)) {\n                el.store('ajax', event.value.aj);\n            }\n            return el;\n        };\n\n        switch (view) {\n        case 'day':\n        case 'week':\n        case 'workweek':\n            var storage = view + 'Sizes',\n                what = view == 'week' ? 'Week' : 'Workweek',\n                div = _createElement(event),\n                margin = view == 'day' ? 1 : 3,\n                style = { backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                          color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg };\n\n            div.writeAttribute('title', event.value.t);\n\n            if (event.value.al) {\n                if (view == 'day') {\n                    $('kronolithViewDay').down('.kronolithAllDayContainer').insert(div.setStyle(style));\n                } else {\n                    var allDay = this.allDays['kronolithAllDay' + date],\n                        existing = allDay.childElements(),\n                        weekHead = $('kronolithView' + what + 'Head');\n                    if (existing.size() == 3) {\n                        if (existing[2].className != 'kronolithMore') {\n                            existing[2].purge();\n                            existing[2].remove();\n                            allDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });\n                        }\n                    } else {\n                        allDay.insert(div.setStyle(style));\n                        if (event.value.pe) {\n                            div.addClassName('kronolithEditable');\n                            var layout = div.getLayout(),\n                                minLeft = weekHead.down('.kronolith-first-col').getWidth() + this[storage].spacing + (parseInt(div.getStyle('marginLeft'), 10) || 0),\n                                minTop = weekHead.down('thead').getHeight() + this[storage].spacing + (parseInt(div.getStyle('marginTop'), 10) || 0),\n                                maxLeft = weekHead.getWidth() - layout.get('margin-box-width'),\n                                maxTop = weekHead.down('thead').getHeight() + weekHead.down('.kronolith-all-day').getHeight(),\n                                opts = {\n                                    threshold: 5,\n                                    parentElement: function() {\n                                        return $('kronolithView' + what).down('.kronolith-view-head');\n                                    },\n                                    snap: function(x, y) {\n                                        return [Math.min(Math.max(x, minLeft), maxLeft),\n                                                Math.min(Math.max(y, minTop), maxTop - div.getHeight())];\n                                    }\n                                };\n                            var d = new Drag(event.value.nodeId, opts);\n                            div.store('drags', []);\n                            Object.extend(d, {\n                                event: event,\n                                innerDiv: new Element('div'),\n                                midnight: this.parseDate(date)\n                            });\n                            div.retrieve('drags').push(d);\n                        }\n                    }\n                }\n                break;\n            }\n\n            var midnight = this.parseDate(date),\n                resizable = event.value.pe && (Object.isUndefined(event.value.vl) || event.value.vl),\n                innerDiv = new Element('div', { className: 'kronolith-event-info' }),\n                minHeight = 0, parentElement, draggerTop, draggerBottom,\n                elapsed = (event.value.start.getHours() - midnight.getHours()) * 60 + (event.value.start.getMinutes() - midnight.getMinutes());\n            switch (view) {\n            case 'day':\n                parentElement = $('kronolithEventsDay');\n                break;\n            case 'week':\n                parentElement = this.eventsWeek['kronolithEventsWeek' + date];\n                break;\n            case 'workweek':\n                parentElement = this.eventsWeek['kronolithEventsWorkweek' + date];\n                break;\n            }\n            if (event.value.fi) {\n                div.addClassName('kronolithFirst');\n                if (resizable) {\n                    draggerTop = new Element('div', { id: event.value.nodeId + 'top', className: 'kronolithDragger kronolithDraggerTop' }).setStyle(style);\n                }\n            } else {\n                innerDiv.setStyle({ top: 0 });\n            }\n            if (event.value.la) {\n                div.addClassName('kronolithLast');\n                if (resizable) {\n                    draggerBottom = new Element('div', { id: event.value.nodeId + 'bottom', className: 'kronolithDragger kronolithDraggerBottom' }).setStyle(style);\n                }\n            } else {\n                innerDiv.setStyle({ bottom: 0 });\n            }\n\n            div.setStyle({\n                top: (elapsed * this[storage].height / 60 | 0) + 'px',\n                width: 100 - margin + '%'\n            })\n                .insert(innerDiv.setStyle(style));\n            if (draggerTop) {\n                div.insert(draggerTop);\n            }\n            if (draggerBottom) {\n                div.insert(draggerBottom);\n            }\n            parentElement.insert(div);\n            if (draggerTop) {\n                minHeight += draggerTop.getHeight();\n            }\n            if (draggerBottom) {\n                minHeight += draggerBottom.getHeight();\n            }\n            if (!minHeight) {\n                minHeight = parseInt(innerDiv.getStyle('lineHeight'), 10)\n                    + (parseInt(innerDiv.getStyle('paddingTop'), 10) || 0)\n                    + (parseInt(innerDiv.getStyle('paddingBottom'), 10) || 0);\n            }\n            div.setStyle({ height: Math.max(Math.round(event.value.start.getElapsed(event.value.end) / 60000) * this[storage].height / 60 - this[storage].spacing | 0, minHeight) + 'px' });\n\n            if (event.value.pe) {\n                div.addClassName('kronolithEditable');\n                div.store('drags', []);\n                // Number of pixels that cover 10 minutes.\n                var step = this[storage].height / 6,\n                    stepX, minLeft, maxLeft, maxTop,\n                    minBottom, maxBottom, dragBottomHeight;\n                if (draggerBottom) {\n                    // Height of bottom dragger\n                    dragBottomHeight = draggerBottom.getHeight();\n                }\n                if (draggerTop) {\n                    // Bottom-most position (maximum y) of top dragger\n                    maxTop = div.offsetTop\n                        - draggerTop.getHeight()\n                        - parseInt(innerDiv.getStyle('lineHeight'), 10);\n                    if (draggerBottom) {\n                        maxTop += draggerBottom.offsetTop;\n                    }\n                }\n                if (draggerBottom) {\n                    // Top-most position (minimum y) of bottom dragger (upper\n                    // edge)\n                    minBottom = div.offsetTop\n                        + parseInt(innerDiv.getStyle('lineHeight'), 10);\n                    // Bottom-most position (maximum y) of bottom dragger\n                    // (upper edge)\n                    maxBottom = 24 * this[storage].height\n                        + dragBottomHeight;\n                    if (draggerTop) {\n                        minBottom += draggerTop.getHeight();\n                    }\n                }\n                    // Height of the whole event div\n                var divHeight = div.getHeight(),\n                    // Maximum height of the whole event div\n                    maxDiv = 24 * this[storage].height - divHeight,\n                    // Whether the top dragger is dragged, vs. the bottom\n                    // dragger\n                    opts = {\n                        threshold: 5,\n                        constraint: 'vertical',\n                        scroll: this.kronolithBody,\n                        nodrop: true,\n                        parentElement: function() {\n                            return parentElement;\n                        }\n                    };\n\n                if (draggerTop) {\n                    opts.snap = function(x, y) {\n                        y = Math.max(0, step * (Math.min(maxTop, y - this.scrollTop) / step | 0));\n                        return [0, y];\n                    }.bind(this);\n                    var d = new Drag(event.value.nodeId + 'top', opts);\n                    Object.extend(d, {\n                        event: event,\n                        innerDiv: innerDiv,\n                        midnight: midnight\n                    });\n                    div.retrieve('drags').push(d);\n                }\n\n                if (draggerBottom) {\n                    opts.snap = function(x, y) {\n                        y = Math.min(maxBottom + dragBottomHeight + KronolithCore[storage].spacing, step * ((Math.max(minBottom, y - this.scrollTop) + dragBottomHeight + KronolithCore[storage].spacing) / step | 0)) - dragBottomHeight - KronolithCore[storage].spacing;\n                        return [0, y];\n                    }.bind(this);\n                    var d = new Drag(event.value.nodeId + 'bottom', opts);\n                    Object.extend(d, {\n                        event: event,\n                        innerDiv: innerDiv,\n                        midnight: midnight\n                    });\n                    div.retrieve('drags').push(d);\n                }\n\n                if (view == 'week' || view == 'workweek') {\n                    var dates = this.viewDates(midnight, view);\n                    minLeft = this.eventsWeek['kronolithEvents' + what + dates[0].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;\n                    maxLeft = this.eventsWeek['kronolithEvents' + what + dates[1].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;\n                    stepX = (maxLeft - minLeft) / (view == 'week' ? 6 : 4);\n                }\n                var d = new Drag(div, {\n                    threshold: 5,\n                    nodrop: true,\n                    parentElement: function() { return parentElement; },\n                    snap: function(x, y) {\n                        x = (view == 'week' || view == 'workweek')\n                            ? Math.max(minLeft, stepX * ((Math.min(maxLeft, x - (x < 0 ? stepX : 0)) + stepX / 2) / stepX | 0))\n                            : 0;\n                        y = Math.max(0, step * (Math.min(maxDiv, y - this.scrollTop) / step | 0));\n                        return [x, y];\n                    }.bind(this)\n                });\n                Object.extend(d, {\n                    divHeight: divHeight,\n                    startTop: div.offsetTop,\n                    event: event,\n                    midnight: midnight,\n                    stepX: stepX\n                });\n                div.retrieve('drags').push(d);\n            }\n\n            var\n                // The current column that we're probing for available space.\n                column = 1,\n                // The number of columns in the current conflict group.\n                columns,\n                // The column width in the current conflict group.\n                width,\n                // The first event that conflict with the current event.\n                conflict = false,\n                // The conflict group where this event should go.\n                pos = this.dayGroups.length,\n                // The event below that the current event fits.\n                placeFound = false,\n                // The minimum (virtual) duration of each event, defined by the\n                // minimum height of an event DIV.\n                minMinutes = (minHeight + this[storage].spacing) * 60 / this[storage].height;\n\n            // this.dayEvents contains all events of the current day.\n            // this.dayGroups contains conflict groups, i.e. all events that\n            // conflict with each other and share a set of columns.\n            //\n            // Go through all events that have been added to this day already.\n            this.dayEvents.each(function(ev) {\n                // Due to the minimum height of an event DIV, events might\n                // visually overlap, even if they physically don't.\n                var minEnd = ev.start.clone().add(minMinutes).minutes(),\n                    end = ev.end.isAfter(minEnd) ? ev.end : minEnd;\n\n                // If it doesn't conflict with the current event, go ahead.\n                if (!end.isAfter(event.value.start)) {\n                    return;\n                }\n\n                // Found a conflicting event, now find its conflict group.\n                for (pos = 0; pos < this.dayGroups.length; pos++) {\n                    if (this.dayGroups[pos].indexOf(ev) != -1) {\n                        // Increase column for each conflicting event in this\n                        // group.\n                        this.dayGroups[pos].each(function(ce) {\n                            var minEnd = ce.start.clone().add(minMinutes).minutes(),\n                                end = ce.end.isAfter(minEnd) ? ce.end : minEnd;\n                            if (end.isAfter(event.value.start)) {\n                                column++;\n                            }\n                        });\n                        throw $break;\n                    }\n                }\n            }, this);\n            event.value.column = event.value.columns = column;\n\n            if (Object.isUndefined(this.dayGroups[pos])) {\n                this.dayGroups[pos] = [];\n            }\n            this.dayGroups[pos].push(event.value);\n\n            // See if the current event had to add yet another column.\n            columns = Math.max(this.dayGroups[pos][0].columns, column);\n\n            // Update the widths of all events in a conflict group.\n            width = 100 / columns;\n            this.dayGroups[pos].each(function(ev) {\n                ev.columns = columns;\n                $(ev.nodeId).setStyle({ width: width - margin + '%', left: (width * (ev.column - 1)) + '%' });\n            });\n            this.dayEvents.push(event.value);\n\n            div = innerDiv;\n            break;\n\n        case 'month':\n            var monthDay = this.monthDays['kronolithMonthDay' + date],\n                div = _createElement(event)\n                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });\n            div.writeAttribute('title', event.value.t);\n            if (before) {\n                before.insert({ before: div });\n            } else {\n                monthDay.insert(div);\n            }\n            if (event.value.pe) {\n                div.setStyle({ cursor: 'move' });\n                new Drag(event.value.nodeId, { threshold: 5, parentElement: function() { return $('kronolith-month-body'); }, snapToParent: true });\n            }\n            if (Kronolith.conf.max_events) {\n                var more = monthDay.down('.kronolithMore');\n                if (more) {\n                    monthDay.insert({ bottom: more.remove() });\n                }\n            }\n            break;\n\n        case 'agenda':\n            var div = _createElement(event)\n                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,\n                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });\n            this.createAgendaDay(date);\n            $('kronolithAgendaDay' + date).insert(div);\n            break;\n        }\n\n        this.setEventText(div, event.value,\n                          { time: view == 'agenda' || Kronolith.conf.show_time })\n            .observe('mouseover', div.addClassName.curry('kronolith-selected'))\n            .observe('mouseout', div.removeClassName.curry('kronolith-selected'));\n    },\n\n    /**\n     * Re-renders the necessary parts of the current view, if any event changes\n     * in those parts require re-rendering.\n     *\n     * @param Array dates  The date strings of days to re-render.\n     */\n    reRender: function(dates)\n    {\n        switch (this.view) {\n        case 'week':\n        case 'workweek':\n        case 'day':\n            dates.each(function(date) {\n                date = this.parseDate(date);\n                this.insertEvents([ date, date ], this.view);\n            }, this);\n            break;\n        case 'month':\n            dates.each(function(date) {\n                var day = this.monthDays['kronolithMonthDay' + date];\n                day.select('.kronolith-event').each(function(event) {\n                    if (event.retrieve('calendar').startsWith('holiday')) {\n                        delete this.holidays[event.retrieve('eventid')];\n                    }\n                    event.remove();\n                }, this);\n                day.select('.kronolithMore').invoke('remove');\n                date = this.parseDate(date);\n                this.loadEvents(date, date, 'month');\n            }, this);\n            break;\n        }\n    },\n\n    /**\n     * Returns all dates of the current view that contain (recurrences) of a\n     * certain event.\n     *\n     * @param String cal      A calendar string.\n     * @param String eventid  An event id.\n     *\n     * @return Array  A list of date strings that contain a recurrence of the\n     *                event.\n     */\n    findEventDays: function(cal, eventid)\n    {\n        cal = cal.split('|');\n        var cache = this.ecache.get(cal[0]).get(cal[1]),\n            dates = this.viewDates(this.date, this.view),\n            day = dates[0], days = [], dateString;\n        while (!day.isAfter(dates[1])) {\n            dateString = day.dateString();\n            if (cache.get(dateString).get(eventid)) {\n                days.push(dateString);\n            }\n            day.add(1).days();\n        }\n        return days;\n    },\n\n    /**\n     * Adds a \"more...\" button to the month view cell that links to the days,\n     * or moves it to the buttom.\n     *\n     * @param string date  The date string of the day cell.\n     */\n    insertMore: function(date)\n    {\n        var monthDay = this.monthDays['kronolithMonthDay' + date],\n            more = monthDay.down('.kronolithMore');\n        if (more) {\n            monthDay.insert({ bottom: more.remove() });\n        } else {\n            monthDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });\n        }\n    },\n\n    setEventText: function(div, event, opts)\n    {\n        var calendar = event.calendar.split('|'),\n            span = new Element('span'),\n            time, end;\n        opts = Object.extend({ time: false }, opts || {});\n\n        div.update();\n        if (event.ic) {\n            div.insert(new Element('img', { src: event.ic, className: 'kronolithEventIcon' }));\n        }\n        if (opts.time && !event.al) {\n            time = new Element('span', { className: 'kronolith-time' })\n                .insert(event.start.toString(Kronolith.conf.time_format));\n            if (!event.start.equals(event.end)) {\n                end = event.end.clone();\n                if (end.getHours() == 23 &&\n                    end.getMinutes() == 59 &&\n                    end.getSeconds() == 59) {\n                    end.add(1).second();\n                }\n                time.insert('-' + end.toString(Kronolith.conf.time_format));\n            }\n            div.insert(time).insert(' ');\n        }\n        div.insert(event.t.escapeHTML());\n        div.insert(span);\n        if (event.a) {\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.alarm.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.alarm + ' ' + event.a }));\n        }\n        if (event.r) {\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur[event.r] }));\n        } else if (event.bid) {\n            div.store('bid', event.bid);\n            span.insert(' ')\n                .insert(new Element('img', { src: Kronolith.conf.images.exception.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur.exception }));\n        }\n        return div;\n    },\n\n    /**\n     * Finally removes events from the DOM and the cache.\n     *\n     * @param string calendar  A calendar name.\n     * @param string event     An event id. If empty, all events from the\n     *                         calendar are deleted.\n     */\n    removeEvent: function(calendar, event)\n    {\n        this.deleteCache(calendar, event);\n        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {\n            return el.retrieve('calendar') == calendar &&\n                (!event || el.retrieve('eventid') == event);\n        }).invoke('remove');\n    },\n\n    /**\n     * Removes all events that reprensent exceptions to the event series\n     * represented by uid.\n     *\n     * @param string calendar  A calendar name.\n     * @param string uid       An event uid.\n     */\n    removeException: function(calendar, uid)\n    {\n        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {\n            if (el.retrieve('calendar') == calendar && el.retrieve('bid') == uid) {\n                this.removeEvent(calendar, el.retrieve('eventid'));\n            }\n        }.bind(this));\n    },\n\n    /**\n     * Calculates the event's start and end dates based on some drag and drop\n     * information.\n     */\n    calculateEventDates: function(event, storage, step, offset, height, start, end)\n    {\n        if (!Object.isUndefined(start)) {\n            event.start = start;\n            event.end = end;\n        }\n        event.start.set({\n            hour: offset / this[storage].height | 0,\n            minute: Math.round(offset % this[storage].height / step) * 10\n        });\n        var hour = (offset + height + this[storage].spacing) / this[storage].height | 0,\n            minute = Math.round((offset + height + this[storage].spacing) % this[storage].height / step) * 10,\n            second = 0;\n        if (hour == 24) {\n            hour = 23;\n            minute = 59;\n            second = 59;\n        }\n        event.end.set({\n            hour: hour,\n            minute: minute,\n            second: second\n        });\n    },\n\n    switchTaskView: function(on)\n    {\n        if (on) {\n            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]\n                .replace(Kronolith.conf.new_task);\n            $('kronolithQuickEvent').addClassName('kronolithNewTask');\n            $('kronolithHeader').down('.kronolithPrev').up().addClassName('disabled');\n            $('kronolithHeader').down('.kronolithNext').up().addClassName('disabled');\n        } else {\n            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]\n                .replace(Kronolith.conf.new_event);\n            $('kronolithQuickEvent').removeClassName('kronolithNewTask');\n            $('kronolithHeader').down('.kronolithPrev').up().removeClassName('disabled');\n            $('kronolithHeader').down('.kronolithNext').up().removeClassName('disabled');\n        }\n    },\n\n    /**\n     * Returns the task cache storage names that hold the tasks of the\n     * requested task type.\n     *\n     * @param string tasktype  The task type.\n     *\n     * @return array  The list of task cache storage names.\n     */\n    getTaskStorage: function(tasktype)\n    {\n        var tasktypes;\n        if (tasktype == 'all' || tasktype == 'future') {\n            tasktypes = [ 'complete', 'incomplete' ];\n        } else {\n            tasktypes = [ tasktype ];\n        }\n        return tasktypes;\n    },\n\n    /**\n     * Loads tasks, either from cache or from the server.\n     *\n     * @param integer tasktype  The tasks type (all, incomplete, complete, or\n     *                          future).\n     * @param Array tasksLists  The lists from where to obtain the tasks.\n     */\n    loadTasks: function(tasktype, tasklists)\n    {\n        var tasktypes = this.getTaskStorage(tasktype), loading = false,\n            spinner = $('kronolithLoading');\n\n        if (Object.isUndefined(tasklists)) {\n            tasklists = [];\n            $H(Kronolith.conf.calendars.tasklists).each(function(tasklist) {\n                if (tasklist.value.show)\n                {\n                    tasklists.push(tasklist.key.substring(6));\n                }\n            });\n        }\n\n        tasktypes.each(function(type) {\n            tasklists.each(function(list) {\n                if (Object.isUndefined(this.tcache.get(type)) ||\n                    Object.isUndefined(this.tcache.get(type).get(list))) {\n                    loading = true;\n                    this.loading++;\n                    spinner.show();\n                    HordeCore.doAction('listTasks', {\n                        type: type,\n                        list: list\n                    }, {\n                        callback: function(r) {\n                            this.loadTasksCallback(r, true);\n                        }.bind(this)\n                    });\n                }\n            }, this);\n        }, this);\n\n        if (!loading) {\n            tasklists.each(function(list) {\n                this.insertTasks(tasktype, list);\n            }, this);\n        }\n    },\n\n    /**\n     * Callback method for inserting tasks in the current view.\n     *\n     * @param object r             The ajax response object.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet. Useful for\n     *                             (not) adding individual tasks to the cache\n     *                             without assuming to have all tasks of the\n     *                             list.\n     */\n    loadTasksCallback: function(r, createCache)\n    {\n        // Hide spinner.\n        this.loading--;\n        if (!this.loading) {\n            $('kronolithLoading').hide();\n        }\n\n        this.storeTasksCache(r.tasks || {}, r.type, r.list, createCache);\n\n        // Check if result is still valid for the current view.\n        // There could be a rare race condition where two responses for the\n        // same task(s) arrive in the wrong order. Checking this too, like we\n        // do for events seems not worth it.\n        var tasktypes = this.getTaskStorage(this.tasktype),\n            tasklist = Kronolith.conf.calendars.tasklists['tasks/' + r.list];\n        if (this.view != 'tasks' ||\n            !tasklist || !tasklist.show ||\n            !tasktypes.include(r.type)) {\n            return;\n        }\n        this.insertTasks(this.tasktype, r.list);\n    },\n\n    /**\n     * Reads tasks from the cache and inserts them into the view.\n     *\n     * @param integer tasktype  The tasks type (all, incomplete, complete, or\n     *                          future).\n     * @param string tasksList  The task list to be drawn.\n     */\n    insertTasks: function(tasktype, tasklist)\n    {\n        var tasktypes = this.getTaskStorage(tasktype), now = new Date();\n\n        $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n            return el.retrieve('tasklist') == tasklist;\n        }).invoke('remove');\n\n        tasktypes.each(function(type) {\n            if (!this.tcache.get(type)) {\n                return;\n            }\n            var tasks = this.tcache.get(type).get(tasklist);\n            $H(tasks).each(function(task) {\n                switch (tasktype) {\n                case 'complete':\n                    if (!task.value.cp) {\n                        return;\n                    }\n                    break;\n                case 'incomplete':\n                    if (task.value.cp ||\n                        (!Object.isUndefined(task.value.start) &&\n                         task.value.start.isAfter(now))) {\n                        return;\n                    }\n                    break;\n                case 'future':\n                    if (task.value.cp ||\n                        Object.isUndefined(task.value.start) ||\n                        !task.value.start.isAfter(now)) {\n                        return;\n                    }\n                    break;\n                }\n                this.insertTask(task);\n            }, this);\n        }, this);\n\n        if ($('kronolithViewTasksBody').select('tr').length > 2) {\n            $('kronolithTasksNoItems').hide();\n        } else {\n            $('kronolithTasksNoItems').show();\n        }\n    },\n\n    /**\n     * Creates the DOM node for a task and inserts it into the view.\n     *\n     * @param object task  A Hash with the task to insert\n     */\n    insertTask: function(task)\n    {\n        var row = $('kronolithTasksTemplate').clone(true),\n            col = row.down(), tagc;\n\n\n        row.removeAttribute('id');\n        row.store('tasklist', task.value.l);\n        row.store('taskid', task.key);\n        col.addClassName('kronolithTask' + (!!task.value.cp ? 'Completed' : ''));\n        col.setStyle({\n            backgroundColor: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].bg,\n            color: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg,\n            textIndent: task.value.i + 'em'\n        });\n        col.insert(task.value.n.escapeHTML());\n        if (!Object.isUndefined(task.value.due)) {\n            var now = new Date();\n            if (!now.isBefore(task.value.due)) {\n                col.addClassName('kronolithTaskDue');\n            }\n            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));\n            col.insert(new Element('span', { className: 'kronolithDate' }).update(task.value.due.toString(Kronolith.conf.date_format)));\n            if (task.value.r) {\n                col.insert(' ')\n                    .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg.substr(1)), title: Kronolith.text.recur[task.value.r] }));\n            }\n        }\n\n        if (!Object.isUndefined(task.value.sd)) {\n            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));\n            col.insert(new Element('span', { className: 'kronolithInfo' }).update(task.value.sd.escapeHTML()));\n        }\n\n        if (task.value.t && task.value.t.size() > 0) {\n            tagc = new Element('ul', { className: 'horde-tags' });\n            task.value.t.each(function(x) {\n                tagc.insert(new Element('li').update(x.escapeHTML()));\n            });\n            col.insert(tagc);\n        }\n        row.insert(col.show());\n        this.insertTaskPosition(row, task);\n    },\n\n    /**\n     * Inserts the task row in the correct position.\n     *\n     * @param Element newRow  The new row to be inserted.\n     * @param object newTask  A Hash with the task being added.\n     */\n    insertTaskPosition: function(newRow, newTask)\n    {\n        var rows = $('kronolithViewTasksBody').select('tr'),\n            rowTasklist, rowTaskId, rowTask, parentFound;\n        // The first row is a template, ignoring.\n        for (var i = 2; i < rows.length; i++) {\n            rowTasklist = rows[i].retrieve('tasklist');\n            rowTaskId = rows[i].retrieve('taskid');\n            if (newTask.value.p) {\n                if (rowTaskId == newTask.value.p) {\n                    parentFound = true;\n                    continue;\n                }\n                if (!parentFound) {\n                    continue;\n                }\n            }\n            rowTask = this.tcache.inject(null, function(acc, list) {\n                if (acc) {\n                    return acc;\n                }\n                if (!Object.isUndefined(list.value.get(rowTasklist))) {\n                    return list.value.get(rowTasklist).get(rowTaskId);\n                }\n            });\n\n            if (Object.isUndefined(rowTask)) {\n                // TODO: Throw error\n                return;\n            }\n            if (!this.isTaskAfter(newTask.value, rowTask)) {\n                break;\n            }\n        }\n        rows[--i].insert({ after: newRow.show() });\n    },\n\n    /**\n     * Analyzes which task should be drawn first.\n     *\n     * TODO: Very incomplete, only a dummy version\n     */\n    isTaskAfter: function(taskA, taskB)\n    {\n        // TODO: Make all ordering system\n        if ((taskA.p || taskB.p) && taskA.p != taskB.p) {\n            return !taskA.p;\n        }\n        return (taskA.pr >= taskB.pr);\n    },\n\n    /**\n     * Completes/uncompletes a task.\n     *\n     * @param string tasklist          The task list to which the tasks belongs.\n     * @param string taskid            The id of the task.\n     * @param boolean|string complete  True if the task is completed, a\n     *                                 due date if there are still\n     *                                 incomplete recurrences.\n     */\n    toggleCompletion: function(tasklist, taskid, complete)\n    {\n        // Update the cache.\n        var task = this.tcache.inject(null, function(acc, list) {\n            if (acc) {\n                return acc;\n            }\n            if (!Object.isUndefined(list.value.get(tasklist))) {\n                return list.value.get(tasklist).get(taskid);\n            }\n        });\n        if (Object.isUndefined(task)) {\n            // This shouldn't happen.\n            this.toggleCompletionClass(taskid);\n            return;\n        }\n        if (Object.isUndefined(complete) || complete === true) {\n            task.cp = !task.cp;\n        }\n\n        if (this.tcache.get(task.cp ? 'complete' : 'incomplete')) {\n            this.tcache.get(task.cp ? 'complete' : 'incomplete').get(tasklist).set(taskid, task);\n        }\n        if (this.tcache.get(task.cp ? 'incomplete' : 'complete')) {\n            this.tcache.get(task.cp ? 'incomplete' : 'complete').get(tasklist).unset(taskid);\n        }\n\n        // Remove row if necessary.\n        var row = this.getTaskRow(taskid);\n        if (!row) {\n            return;\n        }\n        if ((this.tasktype == 'complete' && !task.cp) ||\n            ((this.tasktype == 'incomplete' || this.tasktype == 'future_incomplete') && task.cp) ||\n            ((complete === true) && (this.tasktype == 'future'))) {\n\n            row.fade({\n                duration: this.effectDur,\n                afterFinish: function() {\n                    row.purge();\n                    row.remove();\n\n                    //Check if items remained in interface\n                    if ($('kronolithViewTasksBody').select('tr').length < 3) {\n                        $('kronolithTasksNoItems').show();\n                    }\n                }\n            });\n        }\n\n        // Update due date if necessary.\n        if (!Object.isUndefined(complete) && complete !== true) {\n            var now = new Date(), due = Date.parse(complete);\n            row.down('span.kronolithDate')\n                .update(due.toString(Kronolith.conf.date_format));\n            if (now.isBefore(due)) {\n                row.down('td.kronolithTaskCol')\n                    .removeClassName('kronolithTaskDue');\n            }\n        }\n    },\n\n    /**\n     * Toggles the CSS class to show that a task is completed/uncompleted.\n     *\n     * @param string taskid  The id of the task.\n     */\n    toggleCompletionClass: function(taskid)\n    {\n        var row = this.getTaskRow(taskid);\n        if (!row) {\n            return;\n        }\n        var col = row.down('td.kronolithTaskCol');\n        col.toggleClassName('kronolithTask');\n        col.toggleClassName('kronolithTaskCompleted');\n    },\n\n    /**\n     * Returns the table row of a task.\n     *\n     * @param string taskid  The id of the task.\n     *\n     * @return Element  The table row of the task list, if found.\n     */\n    getTaskRow: function(taskid)\n    {\n        return $('kronolithViewTasksBody').select('tr').find(function(el) {\n            return el.retrieve('taskid') == taskid;\n        });\n    },\n\n    editTask: function(tasklist, id, desc)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n\n        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithTaskTags)) {\n            this.editTask.bind(this, tasklist, id, desc).defer();\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithTaskForm').focusFirstElement();\n            } catch(e) {}\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n\n        this.openTab($('kronolithTaskForm').down('.tabset a.kronolithTabLink'));\n        $('kronolithTaskForm').enable();\n        $('kronolithTaskForm').reset();\n        HordeImple.AutoCompleter.kronolithTaskTags.reset();\n        $('kronolithTaskSave').show().enable();\n        $('kronolithTaskDelete').show().enable();\n        $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').show();\n        this.updateTasklistDropDown();\n        this.disableAlarmMethods('Task');\n        this.knl.kronolithTaskDueTime.markSelected();\n        if (id) {\n            RedBox.loading();\n            this.updateTaskParentDropDown(tasklist);\n            this.updateTaskAssigneeDropDown(tasklist);\n            HordeCore.doAction('getTask', {\n                list: tasklist,\n                id: id\n            }, {\n                callback: this.editTaskCallback.bind(this)\n            });\n            $('kronolithTaskTopTags').update();\n        } else {\n            $('kronolithTaskId').clear();\n            $('kronolithTaskOldList').clear();\n            $('kronolithTaskList').setValue(Kronolith.conf.tasks.default_tasklist);\n            this.updateTaskParentDropDown(Kronolith.conf.tasks.default_tasklist);\n            this.updateTaskAssigneeDropDown(Kronolith.conf.tasks.default_tasklist);\n            $('kronolithTaskParent').setValue('');\n            $('kronolithTaskAssignee').setValue('');\n            //$('kronolithTaskLocation').setValue('http://');\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')\n            });\n            $('kronolithTaskPriority').setValue(3);\n            if (Kronolith.conf.tasks.default_due) {\n                this.setDefaultDue();\n            }\n            if (desc) {\n                $('kronolithTaskDescription').setValue(desc);\n            }\n            this.toggleRecurrence(false, 'None');\n            $('kronolithTaskDelete').hide();\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithTaskDialog').show());\n        }\n    },\n\n    /**\n     * Callback method for showing task forms.\n     *\n     * @param object r  The ajax response object.\n     */\n    editTaskCallback: function(r)\n    {\n        if (!r.task) {\n            RedBox.close();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        var task = r.task;\n\n        /* Basic information */\n        $('kronolithTaskId').setValue(task.id);\n        $('kronolithTaskOldList').setValue(task.l);\n        $('kronolithTaskList').setValue(task.l);\n        $('kronolithTaskTitle').setValue(task.n);\n        $('kronolithTaskParent').setValue(task.p);\n        $('kronolithTaskAssignee').setValue(task.as);\n        //$('kronolithTaskLocation').setValue(task.l);\n        if (task.dd) {\n            $('kronolithTaskDueDate').setValue(task.dd);\n        }\n        if (task.dt) {\n            $('kronolithTaskDueTime').setValue(task.dt);\n            this.knl.kronolithTaskDueTime.setSelected(task.dt);\n        }\n        $('kronolithTaskDescription').setValue(task.de);\n        $('kronolithTaskPriority').setValue(task.pr);\n        $('kronolithTaskCompleted').setValue(task.cp);\n\n        /* Alarm */\n        if (task.a) {\n            this.enableAlarm('Task', task.a);\n            if (task.m) {\n                $('kronolithTaskAlarmDefaultOff').checked = true;\n                $H(task.m).each(function(method) {\n                    if (!$('kronolithTaskAlarm' + method.key)) {\n                        return;\n                    }\n                    $('kronolithTaskAlarm' + method.key).setValue(1);\n                    if ($('kronolithTaskAlarm' + method.key + 'Params')) {\n                        $('kronolithTaskAlarm' + method.key + 'Params').show();\n                    }\n                    $H(method.value).each(function(param) {\n                        var input = $('kronolithTaskAlarmParam' + param.key);\n                        if (!input) {\n                            return;\n                        }\n                        if (input.type == 'radio') {\n                            input.up('form').select('input[type=radio]').each(function(radio) {\n                                if (radio.name == input.name &&\n                                    radio.value == param.value) {\n                                    radio.setValue(1);\n                                    throw $break;\n                                }\n                            });\n                        } else {\n                            input.setValue(param.value);\n                        }\n                    });\n                });\n            }\n        } else {\n            $('kronolithTaskAlarmOff').setValue(true);\n        }\n\n        /* Recurrence */\n        if (task.r) {\n            this.setRecurrenceFields(false, task.r);\n        } else {\n            this.toggleRecurrence(false, 'None');\n        }\n\n        HordeImple.AutoCompleter.kronolithTaskTags.reset(task.t);\n\n        if (!task.pe) {\n            $('kronolithTaskSave').hide();\n            $('kronolithTaskForm').disable();\n        } else {\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')\n            });\n        }\n\n        if (!task.pd) {\n            $('kronolithTaskDelete').show();\n        }\n        if (!task.pe && !task.pd) {\n            $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').hide();\n        }\n\n        this.setTitle(task.n);\n        this.redBoxLoading = true;\n        RedBox.showHtml($('kronolithTaskDialog').show());\n\n        /* Hide alarm message for this task. */\n        if (r.msgs) {\n            r.msgs = r.msgs.reject(function(msg) {\n                if (msg.type != 'horde.alarm') {\n                    return false;\n                }\n                var alarm = msg.flags.alarm;\n                if (alarm.params && alarm.params.notify &&\n                    alarm.params.notify.show &&\n                    alarm.params.notify.show.tasklist &&\n                    alarm.params.notify.show.task &&\n                    alarm.params.notify.show.tasklist == task.l &&\n                    alarm.params.notify.show.task == task.id) {\n                    return true;\n                }\n                return false;\n            });\n        }\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the editable task lists.\n     */\n    updateTasklistDropDown: function()\n    {\n        var tasklist = $('kronolithTaskList');\n        tasklist.update();\n        $H(Kronolith.conf.calendars.tasklists).each(function(cal) {\n            if (cal.value.edit) {\n                tasklist.insert(new Element('option', { value: cal.key.substring(6) })\n                                .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })\n                                .update(cal.value.name.escapeHTML()));\n            }\n        });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the tasks of a task list.\n     *\n     * @param string list  A task list ID.\n     */\n    updateTaskParentDropDown: function(list)\n    {\n        var parents = $('kronolithTaskParent');\n        parents.update(new Element('option', { value: '' })\n                       .update(Kronolith.text.no_parent));\n        HordeCore.doAction('listTasks', {\n            type: 'future_incomplete',\n            list: list\n        }, {\n            ajaxopts: { asynchronuous: false },\n            callback: function(r) {\n                $H(r.tasks).each(function(task) {\n                    parents.insert(new Element('option', { value: task.key })\n                                .setStyle({ textIndent: task.value.i + 'em' })\n                                .update(task.value.n.escapeHTML()));\n                });\n            }.bind(this)\n        });\n    },\n\n    /**\n     * Propagates a SELECT drop down list with the users of a task list.\n     *\n     * @param string list  A task list ID.\n     */\n    updateTaskAssigneeDropDown: function(list)\n    {\n        var assignee = $('kronolithTaskAssignee');\n        assignee.update(new Element('option', { value: '' })\n                       .update(Kronolith.text.no_assignee));\n        $H(Kronolith.conf.calendars.tasklists['tasks/' + list].users).each(function(user) {\n            assignee.insert(new Element('option', { value: user.key })\n                            .update(user.value.escapeHTML()));\n        });\n    },\n\n    /**\n     * Sets the default due date and time for tasks.\n     */\n    setDefaultDue: function()\n    {\n        if ($F('kronolithTaskDueDate') || $F('kronolithTaskDueTime')) {\n            return;\n        }\n        $('kronolithTaskDueDate').setValue(new Date().add(Kronolith.conf.tasks.default_due_days).days().toString(Kronolith.conf.date_format));\n        if (Kronolith.conf.tasks.default_due_time == 'now') {\n            $('kronolithTaskDueTime').setValue(new Date().toString(Kronolith.conf.time_format));\n        } else {\n            var date = new Date();\n            date.setHours(Kronolith.conf.tasks.default_due_time.replace(/:.*$/, ''));\n            date.setMinutes(0);\n            $('kronolithTaskDueTime').setValue(date.toString(Kronolith.conf.time_format));\n        }\n    },\n\n    /**\n     * Finally removes tasks from the DOM and the cache.\n     *\n     * @param string list  A task list name.\n     * @param string task  A task id. If empty, all tasks from the list are\n     *                     deleted.\n     */\n    removeTask: function(list, task)\n    {\n        this.deleteTasksCache(list, task);\n        $('kronolithViewTasksBody').select('tr').findAll(function(el) {\n            return el.retrieve('tasklist') == list &&\n                (!task || el.retrieve('taskid') == task);\n        }).invoke('remove');\n        this.removeEvent('tasklists|tasks/' + list, task ? '_tasks' + task : null);\n        if ($('kronolithViewTasksBody').select('tr').length > 2) {\n            $('kronolithTasksNoItems').hide();\n        } else {\n            $('kronolithTasksNoItems').show();\n        }\n    },\n\n    /**\n     * Submits the task edit form to create or update a task.\n     */\n    saveTask: function()\n    {\n        if (this.wrongFormat.size() ||\n            (($F('kronolithTaskAlarmOn')) && $F('kronolithTaskDueDate').length == 0)) {\n            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');\n            return;\n        }\n\n        var tasklist = $F('kronolithTaskOldList'),\n            target = $F('kronolithTaskList'),\n            taskid = $F('kronolithTaskId'),\n            viewDates = this.viewDates(this.date, this.view),\n            start = viewDates[0].dateString(),\n            end = viewDates[1].dateString();\n\n        HordeImple.AutoCompleter.kronolithTaskTags.shutdown();\n        $('kronolithTaskSave').disable();\n        this.startLoading('tasklists|tasks/' + target, start + end + this.tasktype);\n        this.loading++;\n        HordeCore.doAction(\n            'saveTask',\n            $H($('kronolithTaskForm').serialize({ hash: true })).merge({\n                sig: start + end + this.tasktype,\n                view: this.view,\n                view_start: start,\n                view_end: end\n            }), {\n                callback: function(r) {\n                    if (r.tasks && taskid) {\n                        this.removeTask(tasklist, taskid);\n                    }\n                    this.loadTasksCallback(r, false);\n                    this.loadEventsCallback(r, false);\n                    if (r.tasks) {\n                        this.closeRedBox();\n                        this.go(this.lastLocation);\n                    } else {\n                        $('kronolithTaskSave').enable();\n                    }\n                }.bind(this)\n            }\n        );\n    },\n\n    quickSaveTask: function()\n    {\n        var text = $F('kronolithQuicktaskQ'),\n            viewDates = this.viewDates(this.date, 'tasks'),\n            start = viewDates[0].dateString(),\n            end = viewDates[1].dateString(),\n            params = {\n                sig: start + end + this.tasktype,\n                view: 'tasks',\n                view_start: start,\n                view_end: end,\n                tasklist: Kronolith.conf.tasks.default_tasklist,\n                text: text\n            };\n\n        this.closeRedBox();\n        this.startLoading('tasklists|tasks/' + Kronolith.conf.tasks.default_tasklist,\n                          params.sig);\n        this.loading++;\n        HordeCore.doAction('quickSaveTask', params, {\n            callback: function(r) {\n                this.loadTasksCallback(r, false);\n                this.loadEventsCallback(r, false);\n                if (!r.tasks || !$H(r.tasks).size()) {\n                    this.editTask(null, null, text);\n                } else {\n                    $('kronolithQuicktaskQ').value = '';\n                }\n            }.bind(this)\n         });\n    },\n\n    /**\n     * Opens the form for editing a calendar.\n     *\n     * @param string calendar  Calendar type and calendar id, separated by '|'.\n     */\n    editCalendar: function(calendar)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n\n        var type = calendar.split('|')[0], cal = calendar.split('|')[1];\n        if (!$w('internal tasklists remote holiday resource resourcegroup').include(type)) {\n            return;\n        }\n\n        if (cal &&\n            (Object.isUndefined(Kronolith.conf.calendars[type]) ||\n             Object.isUndefined(Kronolith.conf.calendars[type][cal])) &&\n            (type == 'internal' || type == 'tasklists')) {\n            HordeCore.doAction('getCalendar', {\n                cal: cal\n            }, {\n                callback: function(r) {\n                    if (r.calendar) {\n                        Kronolith.conf.calendars[type][cal] = r.calendar;\n                        this.insertCalendarInList(type, cal, r.calendar);\n                        $('kronolithSharedCalendars').show();\n                        this.editCalendar(type + '|' + cal);\n                    } else {\n                        this.go(this.lastLocation);\n                    }\n                }.bind(this)\n            });\n            return;\n        }\n\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithCalendarForm' + type).focusFirstElement();\n            } catch(e) {}\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n\n        if ($('kronolithCalendarDialog')) {\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithCalendarDialog').show());\n            this.editCalendarCallback(calendar);\n        } else {\n            RedBox.loading();\n            HordeCore.doAction('chunkContent', {\n                chunk: 'calendar'\n            }, {\n                callback: function(r) {\n                    if (r.chunk) {\n                        this.redBoxLoading = true;\n                        RedBox.showHtml(r.chunk);\n                        ['internal', 'tasklists'].each(function(type) {\n                            $('kronolithC' + type + 'PGList').observe('change', function() {\n                                $('kronolithC' + type + 'PG').setValue(1);\n                                this.permsClickHandler(type, 'G');\n                            }.bind(this));\n                        }, this);\n                        this.editCalendarCallback(calendar);\n                    } else {\n                        this.closeRedBox();\n                    }\n                }.bind(this)\n            });\n        }\n    },\n\n    /**\n     * Callback for editing a calendar. Fills the edit form with the correct\n     * values.\n     *\n     * @param string calendar  Calendar type and calendar id, separated by '|'.\n     */\n    editCalendarCallback: function(calendar)\n    {\n        calendar = calendar.split('|');\n        var type = calendar[0];\n        calendar = calendar.length == 1 ? null : calendar[1];\n\n        var form = $('kronolithCalendarForm' + type),\n            firstTab = form.down('.tabset a.kronolithTabLink'),\n            info;\n\n        form.enable();\n        form.reset();\n        if (firstTab) {\n            this.openTab(firstTab);\n        }\n        $('kronolithCalendarDialog').select('.kronolithCalendarDiv').invoke('hide');\n        $('kronolithCalendar' + type + '1').show();\n        form.select('.kronolithCalendarContinue').invoke('enable');\n        $('kronolithC' + type + 'PUNew', 'kronolithC' + type + 'PGNew').compact().each(function(elm) {\n            if (elm.tagName == 'SELECT') {\n                $A(elm.options).each(function(option) {\n                    option.writeAttribute('disabled', false);\n                });\n            }\n        });\n\n        var newCalendar = !calendar;\n        if (calendar &&\n            (Object.isUndefined(Kronolith.conf.calendars[type]) ||\n             Object.isUndefined(Kronolith.conf.calendars[type][calendar]))) {\n            if (type != 'remote') {\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                return;\n            }\n            newCalendar = true;\n        }\n        if (type == 'resourcegroup') {\n            this.updateResourcegroupSelect();\n        }\n        if (newCalendar) {\n            switch (type) {\n            case 'internal':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset();\n                // Fall through.\n            case 'tasklists':\n                $('kronolithCalendar' + type + 'LinkExport').up('span').hide();\n                break;\n            case 'remote':\n                if (calendar) {\n                    $('kronolithCalendarremoteUrl').setValue(calendar);\n                    $('kronolithCalendarremoteId').setValue(calendar);\n                }\n                break;\n            case 'holiday':\n                $('kronolithCalendarholidayDriver').update();\n                $H(Kronolith.conf.calendars.holiday).each(function(calendar) {\n                    if (calendar.value.show) {\n                        return;\n                    }\n                    $('kronolithCalendarholidayDriver').insert(\n                        new Element('option', { value: calendar.key })\n                            .setStyle({ color: calendar.value.fg, backgroundColor: calendar.value.bg })\n                            .insert(calendar.value.name.escapeHTML())\n                    );\n                });\n                break;\n            }\n            $('kronolithCalendar' + type + 'Id').clear();\n            var color = '#', i;\n            for (i = 0; i < 3; i++) {\n                color += (Math.random() * 256 | 0).toColorPart();\n            }\n            $('kronolithCalendar' + type + 'Color').setValue(color).setStyle({ backgroundColor: color, color: Color.brightness(Color.hex2rgb(color)) < 125 ? '#fff' : '#000' });\n            form.down('.kronolithCalendarDelete').hide();\n            $('kronolithCalendarinternalImportButton').hide();\n        } else {\n            info = Kronolith.conf.calendars[type][calendar];\n\n            $('kronolithCalendar' + type + 'Id').setValue(calendar);\n            $('kronolithCalendar' + type + 'Name').setValue(info.name);\n            $('kronolithCalendar' + type + 'Color').setValue(info.bg).setStyle({ backgroundColor: info.bg, color: info.fg });\n            $('kronolithCalendarinternalImportButton').hide();\n\n            switch (type) {\n            case 'internal':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset(Kronolith.conf.calendars.internal[calendar].tg);\n                $('kronolithCalendar' + type + 'ImportCal').setValue('internal_' + calendar);\n                if ($('kronolithCalendar' + type + 'LinkImport')) {\n                    if (info.edit) {\n                        $('kronolithCalendar' + type + 'LinkImport').up('li').show();\n                    } else {\n                        $('kronolithCalendar' + type + 'LinkImport').up('li').hide();\n                    }\n                }\n                $('kronolithCalendar' + type + 'UrlFeed').setValue(info.feed);\n                $('kronolithCalendar' + type + 'EmbedUrl').setValue(info.embed);\n                // Fall through.\n            case 'tasklists':\n                $('kronolithCalendar' + type + 'Description').setValue(info.desc);\n                if ($('kronolithCalendar' + type + 'LinkExport')) {\n                    $('kronolithCalendar' + type + 'LinkExport').up('span').show();\n                    $('kronolithCalendar' + type + 'Export').href = type == 'internal'\n                        ? Kronolith.conf.URI_CALENDAR_EXPORT.interpolate({ calendar: calendar })\n                        : Kronolith.conf.tasks.URI_TASKLIST_EXPORT.interpolate({ tasklist: calendar.substring(6) });\n                }\n                $('kronolithCalendar' + type + 'LinkUrls').up().show();\n                if (info.caldav) {\n                    $('kronolithCalendar' + type + 'UrlCaldav').setValue(info.caldav);\n                    $('kronolithCalendar' + type + 'Caldav').show();\n                } else {\n                    $('kronolithCalendar' + type + 'Caldav').hide();\n                }\n                $('kronolithCalendar' + type + 'UrlWebdav').setValue(info.sub);\n                break;\n            case 'remote':\n                $('kronolithCalendarremoteUrl').setValue(calendar);\n                $('kronolithCalendarremoteDescription').setValue(info.desc);\n                $('kronolithCalendarremoteUsername').setValue(info.user);\n                $('kronolithCalendarremotePassword').setValue(info.password);\n                break;\n            case 'resourcegroup':\n                $('kronolithCalendarresourcegroupDescription').setValue(info.desc);\n                $('kronolithCalendarresourcegroupmembers').setValue(info.members);\n                break;\n            case 'resource':\n                $('kronolithCalendarresourceDescription').setValue(info.desc);\n                $('kronolithCalendarresourceResponseType').setValue(info.response_type);\n                $('kronolithCalendarresourceExport').href = Kronolith.conf.URI_RESOURCE_EXPORT.interpolate({ calendar: calendar });\n            }\n        }\n\n        if (newCalendar || info.owner) {\n            if (type == 'internal' || type == 'tasklists') {\n                this.updateGroupDropDown([['kronolithC' + type + 'PGList', this.updateGroupPerms.bind(this, type)],\n                                          ['kronolithC' + type + 'PGNew']]);\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PNone').setValue(1);\n                if ($('kronolithC' + type + 'PAllShow')) {\n                    $('kronolithC' + type + 'PAllShow').disable();\n                }\n                $('kronolithC' + type + 'PGList').disable();\n                $('kronolithC' + type + 'PGPerms').disable();\n                $('kronolithC' + type + 'PUList').disable();\n                $('kronolithC' + type + 'PUPerms').disable();\n                $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {\n                    return tr.retrieve('remove');\n                }).invoke('remove');\n                $('kronolithCalendar' + type + 'LinkUrls').up().show();\n                form.down('.kronolithColorPicker').show();\n                if (type == 'internal') {\n                    HordeCore.doAction('listTopTags', {}, {\n                        callback: this.topTagsCallback.curry('kronolithCalendarinternalTopTags', 'kronolithCalendarTag')\n                    });\n                }\n                form.down('.kronolithCalendarSubscribe').hide();\n                form.down('.kronolithCalendarUnsubscribe').hide();\n                if ($('kronolithCalendar' + type + 'LinkPerms')) {\n                    $('kronolithCalendar' + type + 'LinkPerms').up('span').show();\n                }\n                if (!Object.isUndefined(info) && info.owner) {\n                    this.setPermsFields(type, info.perms);\n                }\n            }\n            if (type == 'remote' || type == 'internal' || type == 'tasklists') {\n                if (newCalendar ||\n                    (type == 'internal' && calendar == Kronolith.conf.user) ||\n                    (type == 'tasklists' && calendar == 'tasks/' + Kronolith.conf.user)) {\n                    form.select('.kronolithCalendarDelete').invoke('hide');\n                } else {\n                    form.select('.kronolithCalendarDelete').invoke('show');\n                }\n            }\n            form.down('.kronolithCalendarSave').show();\n            form.down('.kronolithFormActions .kronolithSeparator').show();\n        } else {\n            form.disable();\n            form.down('.kronolithColorPicker').hide();\n            form.down('.kronolithCalendarDelete').hide();\n            form.down('.kronolithCalendarSave').hide();\n            if (type == 'internal' || type == 'tasklists') {\n                $('kronolithCalendar' + type + 'UrlCaldav').enable();\n                $('kronolithCalendar' + type + 'UrlAccount').enable();\n                $('kronolithCalendar' + type + 'UrlWebdav').enable();\n                if (type == 'internal') {\n                    $('kronolithCalendar' + type + 'UrlFeed').enable();\n                    $('kronolithCalendar' + type + 'EmbedUrl').enable();\n                    if (info.edit) {\n                        $('kronolithCalendarinternalImport').enable();\n                        if (info.del) {\n                            $('kronolithCalendarinternalImportOver').enable();\n                        }\n                        $('kronolithCalendarinternalImportButton').show().enable();\n                    }\n                }\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.disable();\n                if (Kronolith.conf.calendars[type][calendar].show) {\n                    form.down('.kronolithCalendarSubscribe').hide();\n                    form.down('.kronolithCalendarUnsubscribe').show().enable();\n                } else {\n                    form.down('.kronolithCalendarSubscribe').show().enable();\n                    form.down('.kronolithCalendarUnsubscribe').hide();\n                }\n                form.down('.kronolithFormActions .kronolithSeparator').show();\n                if ($('kronolithCalendar' + type + 'LinkPerms')) {\n                    $('kronolithCalendar' + type + 'LinkPerms').up('span').hide();\n                }\n            } else {\n                form.down('.kronolithFormActions .kronolithSeparator').hide();\n            }\n        }\n    },\n\n    /**\n     * Updates the select list in the resourcegroup calendar dialog.\n     */\n    updateResourcegroupSelect: function()\n    {\n        if (!Kronolith.conf.calendars.resource) {\n            return;\n        }\n        $('kronolithCalendarresourcegroupmembers').update();\n        $H(Kronolith.conf.calendars.resource).each(function(r) {\n            var o = new Element('option', { value: r.value.id }).update(r.value.name.escapeHTML());\n            $('kronolithCalendarresourcegroupmembers').insert(o);\n        });\n    },\n\n    /**\n     * Handles clicks on the radio boxes of the basic permissions screen.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     * @param string perm  The permission to activate, 'None', 'All', or\n     *                     'Group'.\n     */\n    permsClickHandler: function(type, perm)\n    {\n        $('kronolithC' + type + 'PAdvanced')\n            .select('input[type=checkbox]')\n            .invoke('setValue', 0);\n        $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {\n            return tr.retrieve('remove');\n        }).invoke('remove');\n\n        switch (perm) {\n        case 'None':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            break;\n        case 'All':\n            $('kronolithC' + type + 'PAllShow').enable();\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            var perms = {\n                'default': Kronolith.conf.perms.read,\n                'guest': Kronolith.conf.perms.read\n            };\n            if ($F('kronolithC' + type + 'PAllShow')) {\n                perms['default'] |= Kronolith.conf.perms.show;\n                perms['guest'] |= Kronolith.conf.perms.show;\n            }\n            this.setPermsFields(type, perms);\n            break;\n        case 'G':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').enable();\n            $('kronolithC' + type + 'PGPerms').enable();\n            $('kronolithC' + type + 'PUList').disable();\n            $('kronolithC' + type + 'PUPerms').disable();\n            var group = $F('kronolithC' + type + 'PGSingle')\n                ? $F('kronolithC' + type + 'PGSingle')\n                : $F('kronolithC' + type + 'PGList');\n            this.insertGroupOrUser(type, 'group', group, true);\n            $('kronolithC' + type + 'PGshow_' + group).setValue(1);\n            $('kronolithC' + type + 'PGread_' + group).setValue(1);\n            if ($F('kronolithC' + type + 'PGPerms') == 'edit') {\n                $('kronolithC' + type + 'PGedit_' + group).setValue(1);\n            } else {\n                $('kronolithC' + type + 'PGedit_' + group).setValue(0);\n            }\n            $('kronolithC' + type + 'PGdel_' + group).setValue(0);\n            if ($('kronolithC' + type + 'PGdelegate_' + group)) {\n                $('kronolithC' + type + 'PGdelegate_' + group).setValue(0);\n            }\n            break;\n        case 'U':\n            if ($('kronolithC' + type + 'PAllShow')) {\n                $('kronolithC' + type + 'PAllShow').disable();\n            }\n            $('kronolithC' + type + 'PGList').disable();\n            $('kronolithC' + type + 'PGPerms').disable();\n            $('kronolithC' + type + 'PUList').enable();\n            $('kronolithC' + type + 'PUPerms').enable();\n            var users = $F('kronolithC' + type + 'PUList').strip();\n            users = users ? users.split(/\\s*(?:,|\\n)\\s*/) : [];\n            users.each(function(user) {\n                if (!this.insertGroupOrUser(type, 'user', user, true)) {\n                    return;\n                }\n                $('kronolithC' + type + 'PUshow_' + user).setValue(1);\n                $('kronolithC' + type + 'PUread_' + user).setValue(1);\n                if ($F('kronolithC' + type + 'PUPerms') == 'edit') {\n                    $('kronolithC' + type + 'PUedit_' + user).setValue(1);\n                } else {\n                    $('kronolithC' + type + 'PUedit_' + user).setValue(0);\n                }\n                $('kronolithC' + type + 'PUdel_' + user).setValue(0);\n                if ($('kronolithC' + type + 'PUdelegate_' + user)) {\n                    $('kronolithC' + type + 'PUdelegate_' + user).setValue(0);\n                }\n            }, this);\n            break;\n        }\n    },\n\n    /**\n     * Populates the permissions field matrix.\n     *\n     * @param string type   The calendar type, 'internal' or 'taskslists'.\n     * @param object perms  An object with the resource permissions.\n     */\n    setPermsFields: function(type, perms)\n    {\n        if (this.groupLoading) {\n            this.setPermsFields.bind(this, type, perms).defer();\n            return;\n        }\n\n        var allperms = $H(Kronolith.conf.perms),\n            advanced = false, users = [],\n            basic, same, groupPerms, groupId, userPerms;\n        $H(perms).each(function(perm) {\n            switch (perm.key) {\n            case 'default':\n            case 'guest':\n                if (Object.isUndefined(same)) {\n                    same = perm.value;\n                } else if (Object.isUndefined(basic) &&\n                           same == perm.value &&\n                           (perm.value == Kronolith.conf.perms.read ||\n                            perm.value == (Kronolith.conf.perms.read | Kronolith.conf.perms.show))) {\n                    basic = perm.value == Kronolith.conf.perms.read ? 'all_read' : 'all_show';\n                } else if (perm.value != 0) {\n                    advanced = true;\n                }\n                break;\n            case 'creator':\n                if (perm.value != 0) {\n                    advanced = true;\n                }\n                break;\n            case 'groups':\n                if (!Object.isArray(perm.value)) {\n                    $H(perm.value).each(function(group) {\n                        if (!this.insertGroupOrUser(type, 'group', group.key)) {\n                            return;\n                        }\n                        if (!$('kronolithC' + type + 'PGshow_' + group.key)) {\n                            // Group doesn't exist anymore.\n                            delete perm.value[group.key];\n                            return;\n                        }\n                        groupPerms = group.value;\n                        groupId = group.key;\n                    }, this);\n                    if (Object.isUndefined(basic) &&\n                        $H(perm.value).size() == 1 &&\n                        (groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||\n                         groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {\n                        basic = groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'group_read' : 'group_edit';\n                    } else {\n                        advanced = true;\n                    }\n                }\n                break;\n            case 'users':\n                if (!Object.isArray(perm.value)) {\n                    $H(perm.value).each(function(user) {\n                        if (user.key != Kronolith.conf.user) {\n                            if (!this.insertGroupOrUser(type, 'user', user.key)) {\n                                return;\n                            }\n                            if (!$('kronolithC' + type + 'PUshow_' + user.key)) {\n                                // User doesn't exist anymore.\n                                delete perm.value[user.key];\n                                return;\n                            }\n                            // Check if we already have other basic permissions.\n                            if (Object.isUndefined(userPerms) &&\n                                !Object.isUndefined(basic)) {\n                                advanced = true;\n                            }\n                            // Check if all users have the same permissions.\n                            if (!Object.isUndefined(userPerms) &&\n                                userPerms != user.value) {\n                                advanced = true;\n                            }\n                            userPerms = user.value;\n                            if (!advanced &&\n                                (userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||\n                                 userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {\n                                basic = userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'user_read' : 'user_edit';\n                                users.push(user.key);\n                            } else {\n                                advanced = true;\n                            }\n                        }\n                    }, this);\n                }\n                break;\n            }\n\n            allperms.each(function(baseperm) {\n                if (baseperm.key == 'all') {\n                    return;\n                }\n                switch (perm.key) {\n                case 'default':\n                case 'guest':\n                case 'creator':\n                    if (baseperm.value & perm.value) {\n                        $('kronolithC' + type + 'P' + perm.key + baseperm.key).setValue(1);\n                    }\n                    break;\n                case 'groups':\n                    $H(perm.value).each(function(group) {\n                        if (baseperm.value & group.value) {\n                            $('kronolithC' + type + 'PG' + baseperm.key + '_' + group.key).setValue(1);\n                        }\n                    });\n                    break;\n                case 'users':\n                    $H(perm.value).each(function(user) {\n                        if (baseperm.value & user.value &&\n                            user.key != Kronolith.conf.user) {\n                            $('kronolithC' + type + 'PU' + baseperm.key + '_' + user.key).setValue(1);\n                        }\n                    });\n                    break;\n                }\n            });\n        }.bind(this));\n\n        if (advanced) {\n            this.activateAdvancedPerms(type);\n        } else {\n            switch (basic) {\n            case 'all_read':\n                $('kronolithC' + type + 'PAll').setValue(1);\n                $('kronolithC' + type + 'PAllShow').setValue(0);\n                $('kronolithC' + type + 'PAllShow').enable();\n                break;\n            case 'all_show':\n                $('kronolithC' + type + 'PAll').setValue(1);\n                $('kronolithC' + type + 'PAllShow').setValue(1);\n                $('kronolithC' + type + 'PAllShow').enable();\n                break;\n            case 'group_read':\n            case 'group_edit':\n                var setGroup = function(group) {\n                    if ($('kronolithC' + type + 'PGList').visible()) {\n                        $('kronolithC' + type + 'PGList').setValue(group);\n                        if ($('kronolithC' + type + 'PGList').getValue() != group) {\n                            // Group no longer exists.\n                            this.permsClickHandler(type, 'None');\n                        }\n                    } else if ($('kronolithC' + type + 'PGSingle').getValue() != group) {\n                        // Group no longer exists.\n                        this.permsClickHandler(type, 'None');\n                    }\n                }.bind(this, groupId);\n                if (this.groupLoading) {\n                    setGroup.defer();\n                } else {\n                    setGroup();\n                }\n                $('kronolithC' + type + 'PG').setValue(1);\n                $('kronolithC' + type + 'PGPerms').setValue(basic.substring(6));\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PGPerms').enable();\n                break;\n            case 'user_read':\n            case 'user_edit':\n                $('kronolithC' + type + 'PUList').enable().setValue(users.join(', '));\n                $('kronolithC' + type + 'PU').setValue(1);\n                $('kronolithC' + type + 'PUPerms').setValue(basic.substring(5));\n                $('kronolithC' + type + 'PAdvanced').hide();\n                $('kronolithC' + type + 'PBasic').show();\n                $('kronolithC' + type + 'PUPerms').enable();\n                break;\n            }\n        }\n   },\n\n    /**\n     * Propagates a SELECT drop down list with the groups.\n     *\n     * @param array params  A two-dimensional array with the following values\n     *                      in each element:\n     *                      - The id of the SELECT element.\n     *                      - A callback method that is invoked with the group\n     *                        list passes as an argument.\n     */\n    updateGroupDropDown: function(params)\n    {\n        this.groupLoading = true;\n        params.each(function(param) {\n            var elm = $(param[0]), options = elm.childElements();\n            options.invoke('remove');\n            elm.up('form').disable();\n        });\n        HordeCore.doAction('listGroups', {}, {\n            callback: function(r) {\n                var groups;\n                if (r.groups) {\n                    groups = $H(r.groups);\n                    params.each(function(param) {\n                        groups.each(function(group) {\n                            $(param[0]).insert(new Element('option', { value: group.key }).update(group.value.escapeHTML()));\n                        });\n                    });\n                }\n                params.each(function(param) {\n                    $(param[0]).up('form').enable();\n                    if (param[1]) {\n                        param[1](groups);\n                    }\n                });\n                this.groupLoading = false;\n            }.bind(this)\n        });\n    },\n\n    /**\n     * Updates the group permission interface after the group list has\n     * been loaded.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     * @param Hash groups  The list of groups.\n     */\n    updateGroupPerms: function(type, groups)\n    {\n        $('kronolithC' + type + 'PGSingle').clear();\n        if (!groups) {\n            $('kronolithC' + type + 'PGNew').up('div').hide();\n            $('kronolithC' + type + 'PG').up('span').hide();\n        } else {\n            $('kronolithC' + type + 'PGNew').up('div').show();\n            $('kronolithC' + type + 'PG').up('span').show();\n            if (groups.size() == 1) {\n                $('kronolithC' + type + 'PGName')\n                    .update('&quot;' + groups.values()[0].escapeHTML() + '&quot;')\n                    .show();\n                $('kronolithC' + type + 'PGSingle').setValue(groups.keys()[0]);\n                $('kronolithC' + type + 'PGList').hide();\n            } else {\n                $('kronolithC' + type + 'PGName').hide();\n                $('kronolithC' + type + 'PGList').show();\n            }\n        }\n    },\n\n    /**\n     * Inserts a group or user row into the advanced permissions interface.\n     *\n     * @param string type          The calendar type, 'internal' or\n     *                             'taskslists'.\n     * @param what string          Either 'group' or 'user'.\n     * @param group string         The group id or user name to insert.\n     *                             Defaults to the value of the drop down.\n     * @param stay_basic boolean   Enforces to NOT switch to the advanced\n     *                             permissions screen.\n     *\n     * @return boolean  Whether a row has been inserted.\n     */\n    insertGroupOrUser: function(type, what, id, stay_basic)\n    {\n        var elm = $(what == 'user' ? 'kronolithC' + type + 'PUNew' : 'kronolithC' + type + 'PGNew');\n        if (id) {\n            elm.setValue(id);\n        }\n        var value = elm.getValue();\n        if (!value) {\n            if (id) {\n                HordeCore.notify(Kronolith.text.invalid_user + ': ' + id, 'horde.error');\n            }\n            return false;\n        }\n\n        var tr = elm.up('tr'),\n            row = tr.clone(true).store('remove', true),\n            td = row.down('td'),\n            clearName = elm.tagName == 'SELECT' ? elm.options[elm.selectedIndex].text: elm.getValue();\n\n        td.update();\n        td.insert(clearName.escapeHTML())\n            .insert(new Element('input', { type: 'hidden', name: (what == 'user' ? 'u' : 'g') + '_names[' + value + ']', value: value }));\n        row.select('input[type=checkbox]').each(function(input) {\n            input.writeAttribute('name', input.name.replace(/\\[.*?$/, '[' + value + ']'))\n                .writeAttribute('id', input.id.replace(/new/, value))\n                .next()\n                .writeAttribute('for', input.id);\n        });\n        tr.insert({ before: row });\n\n        if (elm.tagName == 'SELECT') {\n            elm.options[elm.selectedIndex].writeAttribute('disabled', true);\n            elm.selectedIndex = 0;\n        } else {\n            elm.clear();\n        }\n\n        if (!stay_basic) {\n            this.activateAdvancedPerms(type);\n        }\n\n        return true;\n    },\n\n    /**\n     * Activates the advanced permissions.\n     *\n     * @param string type  The calendar type, 'internal' or 'taskslists'.\n     */\n    activateAdvancedPerms: function(type)\n    {\n        [$('kronolithC' + type + 'PNone'),\n         $('kronolithC' + type + 'PU'),\n         $('kronolithC' + type + 'PG')].each(function(radio) {\n            radio.checked = false;\n        });\n        if ($('kronolithC' + type + 'PAll')) {\n            $('kronolithC' + type + 'PAll').checked = false;\n        }\n        $('kronolithC' + type + 'PBasic').hide();\n        $('kronolithC' + type + 'PAdvanced').show();\n    },\n\n    /**\n     * Opens the next screen of the calendar management wizard.\n     *\n     * @param string type  The calendar type.\n     */\n    calendarNext: function(type)\n    {\n        var i = 1;\n        while (!$('kronolithCalendar' + type + i).visible()) {\n            i++;\n        }\n        $('kronolithCalendar' + type + i).hide();\n        $('kronolithCalendar' + type + (++i)).show();\n        if (this.colorPicker) {\n            this.colorPicker.hide();\n        }\n    },\n\n    /**\n     * Submits the calendar form to save the calendar data.\n     *\n     * @param Element form  The form node.\n     *\n     * @return boolean  Whether the save request was successfully sent.\n     */\n    saveCalendar: function(form)\n    {\n        if (this.colorPicker) {\n            this.colorPicker.hide();\n        }\n        var data = form.serialize({ hash: true });\n\n        if (data.type == 'holiday') {\n            this.insertCalendarInList('holiday', data.driver, Kronolith.conf.calendars.holiday[data.driver]);\n            this.toggleCalendar('holiday', data.driver);\n            form.down('.kronolithCalendarSave').enable();\n            this.closeRedBox();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        if (data.name.empty()) {\n            HordeCore.notify(data.type == 'tasklists' ? Kronolith.text.no_tasklist_title : Kronolith.text.no_calendar_title, 'horde.warning');\n            $('kronolithCalendar' + data.type + 'Name').focus();\n            return false;\n        }\n        HordeCore.doAction('saveCalendar', data, {\n            callback: this.saveCalendarCallback.bind(this, form, data)\n        });\n        return true;\n    },\n\n    calendarImport: function(form, disableForm)\n    {\n        if ($F('kronolithCalendarinternalImport')) {\n            HordeCore.notify(Kronolith.text.import_warning, 'horde.message');\n            this.loading++;\n            $('kronolithLoading').show();\n            var name = 'kronolithIframe' + Math.round(Math.random() * 1000),\n                iframe = new Element('iframe', { src: 'about:blank', name: name, id: name }).setStyle({ display: 'none' });\n            document.body.insert(iframe);\n            form.enable();\n            form.target = name;\n            form.submit();\n            if (disableForm) {\n                form.disable();\n            }\n        }\n    },\n\n    /**\n     * Callback method after saving a calendar.\n     *\n     * @param Element form  The form node.\n     * @param object data   The serialized form data.\n     * @param object r      The ajax response object.\n     */\n    saveCalendarCallback: function(form, data, r)\n    {\n        var type = form.id.replace(/kronolithCalendarForm/, '');\n\n        // If saving the calendar changed the owner, we need to delete\n        // and re-insert the calendar.\n        if (r.deleted) {\n            this.deleteCalendar(type, data.calendar);\n            delete data.calendar;\n        }\n        if (r.saved) {\n            this.calendarImport(form, false);\n            var cal = r.calendar, id;\n            if (data.calendar) {\n                var color = {\n                    backgroundColor: cal.bg,\n                    color: cal.fg\n                },\n                legendSpan;\n                id = data.calendar;\n                this.getCalendarList(type, cal.owner).select('div').each(function(element) {\n                    if (element.retrieve('calendar') == id) {\n                        var link = element.down('.horde-resource-link span');\n                        element.setStyle(color);\n                        link.update(cal.name.escapeHTML());\n                        this.addShareIcon(cal, link);\n                        throw $break;\n                    }\n                }, this);\n                this.kronolithBody.select('div').each(function(el) {\n                    if (el.retrieve('calendar') == type + '|' + id) {\n                        el.setStyle(color);\n                    }\n                });\n                legendSpan = $('kronolith-legend').select('span')\n                    .find(function(span) {\n                        return span.retrieve('calendarclass') == type &&\n                            span.retrieve('calendar') == id;\n                    });\n                if (legendSpan) {\n                    legendSpan.setStyle(color).update(cal.name.escapeHTML());\n                }\n                Kronolith.conf.calendars[type][id] = cal;\n            } else {\n                id = r.id;\n                if (!Kronolith.conf.calendars[type]) {\n                    Kronolith.conf.calendars[type] = [];\n                }\n                Kronolith.conf.calendars[type][id] = cal;\n                this.insertCalendarInList(type, id, cal);\n                this.storeCache($H(), [type, id], this.viewDates(this.date, this.view), true);\n                if (type == 'tasklists') {\n                    this.storeTasksCache($H(), this.tasktype, id.replace(/^tasks\\//, ''), true);\n                }\n            }\n            if (type == 'remote') {\n                this.loadCalendar(type, id);\n            }\n        }\n        form.down('.kronolithCalendarSave').enable();\n        this.closeRedBox();\n        this.go(this.lastLocation);\n    },\n\n    /**\n     * Deletes a calendar and all its events from the interface and cache.\n     *\n     * @param string type      The calendar type.\n     * @param string calendar  The calendar id.\n     */\n    deleteCalendar: function(type, calendar)\n    {\n        var container = this.getCalendarList(type, Kronolith.conf.calendars[type][calendar].owner),\n            noItems = container.previous(),\n            div = container.select('div').find(function(element) {\n                return element.retrieve('calendar') == calendar;\n            }),\n            arrow = div.down('span');\n        arrow.purge();\n        arrow.remove();\n        div.purge();\n        div.remove();\n        if (noItems &&\n            noItems.tagName == 'DIV' &&\n            noItems.className == 'horde-info' &&\n            !container.childElements().size()) {\n            noItems.show();\n        }\n        this.deleteCalendarLegend(type, calendar);\n        this.removeEvent(type + '|' + calendar);\n        this.deleteCache([type, calendar]);\n        if (type == 'tasklists' && this.view == 'tasks') {\n            this.removeTask(calendar.replace(/^tasks\\//, ''));\n        }\n        delete Kronolith.conf.calendars[type][calendar];\n    },\n\n    /**\n     * Parses a date attribute string into a Date object.\n     *\n     * For other strings use Date.parse().\n     *\n     * @param string date  A yyyyMMdd date string.\n     *\n     * @return Date  A date object.\n     */\n    parseDate: function(date)\n    {\n        var d = new Date(date.substr(0, 4), date.substr(4, 2) - 1, date.substr(6, 2));\n        if (date.length == 12) {\n            d.setHours(date.substr(8, 2));\n            d.setMinutes(date.substr(10, 2));\n        }\n        return d;\n    },\n\n    /**\n     * Calculates first and last days being displayed.\n     *\n     * @var Date date    The date of the view.\n     * @var string view  A view name.\n     *\n     * @return array  Array with first and last day of the view.\n     */\n    viewDates: function(date, view)\n    {\n        var start = date.clone(), end = date.clone();\n\n        switch (view) {\n        case 'week':\n        case 'workweek':\n            if (view == 'workweek') {\n                start.add(1).days();\n            }\n            start.moveToBeginOfWeek(view == 'week' ? Kronolith.conf.week_start : 1);\n            end = start.clone();\n            end.moveToEndOfWeek(Kronolith.conf.week_start);\n            if (view == 'workweek') {\n                end.add(Kronolith.conf.week_start == 0 ? -1 : -2).days();\n            }\n            break;\n        case 'month':\n            start.setDate(1);\n            start.moveToBeginOfWeek(Kronolith.conf.week_start);\n            end.moveToLastDayOfMonth();\n            end.moveToEndOfWeek(Kronolith.conf.week_start);\n            break;\n        case 'year':\n            start.setDate(1);\n            start.setMonth(0);\n            end.setMonth(11);\n            end.moveToLastDayOfMonth();\n            break;\n        case 'agenda':\n            end.add(6).days();\n            break;\n        }\n\n        return [start, end];\n    },\n\n    /**\n     * Stores a set of events in the cache.\n     *\n     * For dates in the specified date ranges that don't contain any events,\n     * empty cache entries are created so that those dates aren't re-fetched\n     * each time.\n     *\n     * @param object events        A list of calendars and events as returned\n     *                             from an ajax request.\n     * @param string calendar      A calendar string or array.\n     * @param string dates         A date range in the format yyyymmddyyyymmdd\n     *                             as used in the ajax response signature.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet.\n     */\n    storeCache: function(events, calendar, dates, createCache)\n    {\n        if (Object.isString(calendar)) {\n            calendar = calendar.split('|');\n        }\n\n        // Create cache entry for the calendar.\n        if (!this.ecache.get(calendar[0])) {\n            if (!createCache) {\n                return;\n            }\n            this.ecache.set(calendar[0], $H());\n        }\n        if (!this.ecache.get(calendar[0]).get(calendar[1])) {\n            if (!createCache) {\n                return;\n            }\n            this.ecache.get(calendar[0]).set(calendar[1], $H());\n        }\n        var calHash = this.ecache.get(calendar[0]).get(calendar[1]);\n\n        // Create empty cache entries for all dates.\n        if (!!dates) {\n            var day = dates[0].clone(), date;\n            while (!day.isAfter(dates[1])) {\n                date = day.dateString();\n                if (!calHash.get(date)) {\n                    if (!createCache) {\n                        return;\n                    }\n                    if (!this.cacheStart || this.cacheStart.isAfter(day)) {\n                        this.cacheStart = day.clone();\n                    }\n                    if (!this.cacheEnd || this.cacheEnd.isBefore(day)) {\n                        this.cacheEnd = day.clone();\n                    }\n                    calHash.set(date, $H());\n                }\n                day.add(1).day();\n            }\n        }\n\n        var cal = calendar.join('|');\n        $H(events).each(function(date) {\n            // We might not have a cache for this date if the event lasts\n            // longer than the current view\n            if (!calHash.get(date.key)) {\n                return;\n            }\n\n            // Store calendar string and other useful information in event\n            // objects.\n            $H(date.value).each(function(event) {\n                event.value.calendar = cal;\n                event.value.start = Date.parse(event.value.s);\n                event.value.end = Date.parse(event.value.e);\n            });\n\n            // Store events in cache.\n            calHash.set(date.key, calHash.get(date.key).merge(date.value));\n        });\n    },\n\n    /**\n     * Stores a set of tasks in the cache.\n     *\n     * @param Hash tasks           The tasks to be stored.\n     * @param string tasktypes     The task type that's being stored.\n     * @param string tasklist      The task list to which the tasks belong.\n     * @param boolean createCache  Whether to create a cache list entry for the\n     *                             response, if none exists yet.\n     */\n    storeTasksCache: function(tasks, tasktypes, tasklist, createCache)\n    {\n        var taskHashes = {}, cacheExists = {};\n\n        if (tasktypes == 'all' || tasktypes == 'future') {\n            tasktypes = [ 'complete', 'incomplete' ];\n        } else {\n            tasktypes = [ tasktypes ];\n        }\n\n        tasktypes.each(function(tasktype) {\n            cacheExists[tasktype] = false;\n            if (!this.tcache.get(tasktype)) {\n                if (!createCache) {\n                    return;\n                }\n                this.tcache.set(tasktype, $H());\n            }\n            if (!tasklist) {\n                return;\n            }\n            if (!this.tcache.get(tasktype).get(tasklist)) {\n                if (!createCache) {\n                    return;\n                }\n                this.tcache.get(tasktype).set(tasklist, $H());\n                cacheExists[tasktype] = true;\n            } else {\n                cacheExists[tasktype] = true;\n            }\n            taskHashes[tasktype] = this.tcache.get(tasktype).get(tasklist);\n        }, this);\n\n        $H(tasks).each(function(task) {\n            var tasktype = task.value.cp ? 'complete' : 'incomplete';\n            if (!cacheExists[tasktype]) {\n                return;\n            }\n            if (!Object.isUndefined(task.value.s)) {\n                task.value.start = Date.parse(task.value.s);\n            }\n            if (!Object.isUndefined(task.value.du)) {\n                task.value.due = Date.parse(task.value.du);\n            }\n            taskHashes[tasktype].set(task.key, task.value);\n        });\n    },\n\n    /**\n     * Deletes an event or a complete calendar from the cache.\n     *\n     * @param string calendar  A calendar string or array.\n     * @param string event     An event ID or empty if deleting the calendar.\n     * @param string day       A specific day to delete in yyyyMMdd form.\n     */\n    deleteCache: function(calendar, event, day)\n    {\n        if (Object.isString(calendar)) {\n            calendar = calendar.split('|');\n        }\n        if (!this.ecache.get(calendar[0]) ||\n            !this.ecache.get(calendar[0]).get(calendar[1])) {\n            return;\n        }\n        if (event) {\n            this.ecache.get(calendar[0]).get(calendar[1]).each(function(day) {\n                day.value.unset(event);\n            });\n        } else if (day) {\n            this.ecache.get(calendar[0]).get(calendar[1]).unset(day);\n        } else {\n            this.ecache.get(calendar[0]).unset(calendar[1]);\n        }\n    },\n\n    /**\n     * Deletes tasks from the cache.\n     *\n     * @param string list  A task list string.\n     * @param string task  A task ID. If empty, all tasks from the list are\n     *                     deleted.\n     */\n    deleteTasksCache: function(list, task)\n    {\n        this.deleteCache([ 'external', 'tasks/' + list ], task);\n        $w('complete incomplete').each(function(type) {\n            if (!Object.isUndefined(this.tcache.get(type)) &&\n                !Object.isUndefined(this.tcache.get(type).get(list))) {\n                if (task) {\n                    this.tcache.get(type).get(list).unset(task);\n                } else {\n                    this.tcache.get(type).unset(list);\n                }\n            }\n        }, this);\n    },\n\n    /**\n     * Return all events for a single day from all displayed calendars merged\n     * into a single hash.\n     *\n     * @param string date  A yyyymmdd date string.\n     *\n     * @return Hash  An event hash which event ids as keys and event objects as\n     *               values.\n     */\n    getCacheForDate: function(date, calendar)\n    {\n        if (calendar) {\n            var cals = calendar.split('|');\n            if (!this.ecache.get(cals[0]) ||\n                !this.ecache.get(cals[0]).get(cals[1])) {\n                return $H();\n            }\n            var x = this.ecache.get(cals[0]).get(cals[1]).get(date);\n            return this.ecache.get(cals[0]).get(cals[1]).get(date);\n        }\n\n        var events = $H();\n        this.ecache.each(function(type) {\n            type.value.each(function(cal) {\n                if (!Kronolith.conf.calendars[type.key][cal.key].show) {\n                    return;\n                }\n                events = events.merge(cal.value.get(date));\n            });\n        });\n        return events;\n    },\n\n    /**\n     * Helper method for Enumerable.sortBy to sort events first by start time,\n     * second by end time reversed.\n     *\n     * @param Hash event  A hash entry with the event object as the value.\n     *\n     * @return string  A comparable string.\n     */\n    sortEvents: function(event)\n    {\n        return event.value.sort;\n    },\n\n    /**\n     * Adds a new location to the history and displays it in the URL hash.\n     *\n     * This is not really a history, because only the current and the last\n     * location are stored.\n     *\n     * @param string loc    The location to save.\n     * @param boolean save  Whether to actually save the location. This should\n     *                      be false for any location that are displayed on top\n     *                      of another location, i.e. in a popup view.\n     */\n    addHistory: function(loc, save)\n    {\n        location.hash = encodeURIComponent(loc);\n        this.lastLocation = this.currentLocation;\n        if (Object.isUndefined(save) || save) {\n            this.currentLocation = loc;\n        }\n        this.openLocation = loc;\n    },\n\n    /**\n     * Loads an external page.\n     *\n     * @param string loc  The URL of the page to load.\n     */\n    loadPage: function(loc)\n    {\n        window.location.assign(loc);\n    },\n\n    searchSubmit: function(e)\n    {\n        this.go('search:' + this.search + ':' + $F('horde-search-input'));\n    },\n\n    searchReset: function(e)\n    {\n        HordeTopbar.searchGhost.reset();\n    },\n\n    /**\n     * Event handler for HordeCore:showNotifications events.\n     */\n    showNotification: function(e)\n    {\n        if (!e.memo.flags ||\n            !e.memo.flags.alarm ||\n            !e.memo.flags.growl ||\n            !e.memo.flags.alarm.params.notify.ajax) {\n            return;\n        }\n\n        var growl = e.memo.flags.growl, link = growl.down('A');\n\n        if (link) {\n            link.observe('click', function(ee) {\n                ee.stop();\n                HordeCore.Growler.ungrowl(growl);\n                this.go(e.memo.flags.alarm.params.notify.ajax);\n            }.bind(this));\n        }\n    },\n\n    /* Keydown event handler */\n    keydownHandler: function(e)\n    {\n        if (e.stopped) {\n            return;\n        }\n\n        var kc = e.keyCode || e.charCode,\n            form = e.findElement('FORM'), trigger = e.findElement();\n\n        switch (trigger.id) {\n        case 'kronolithEventLocation':\n            if (kc == Event.KEY_RETURN && $F('kronolithEventLocation')) {\n                this.initializeMap(true);\n                this.geocode($F('kronolithEventLocation'));\n                e.stop();\n                return;\n            }\n            break;\n\n        case 'kronolithCalendarinternalUrlCaldav':\n        case 'kronolithCalendarinternalUrlWebdav':\n        case 'kronolithCalendarinternalUrlAccount':\n        case 'kronolithCalendarinternalUrlFeed':\n        case 'kronolithCalendartasklistsUrlCaldav':\n        case 'kronolithCalendartasklistsUrlWebdav':\n        case 'kronolithCalendartasklistsUrlAccount':\n            if (String.fromCharCode(kc) != 'C' ||\n                (this.macos && !e.metaKey) ||\n                (!this.macos && !e.ctrlKey)) {\n                e.stop();\n                return;\n            }\n            break;\n        }\n\n        if (form) {\n            switch (kc) {\n            case Event.KEY_RETURN:\n                switch (form.identify()) {\n                case 'kronolithEventForm':\n                    if (e.element().tagName != 'TEXTAREA') {\n                        this.saveEvent();\n                        e.stop();\n                    }\n                    break;\n\n                case 'kronolithTaskForm':\n                    if (e.element().tagName != 'TEXTAREA') {\n                        this.saveTask();\n                        e.stop();\n                    }\n                    break;\n\n                case 'kronolithQuickinsertForm':\n                    this.quickSaveEvent();\n                    e.stop();\n                    break;\n\n                case 'kronolithCalendarForminternal':\n                case 'kronolithCalendarFormtasklists':\n                case 'kronolithCalendarFormremote':\n                    // Disabled for now, we have to also catch Continue buttons.\n                    //var saveButton = form.down('.kronolithCalendarSave');\n                    //saveButton.disable();\n                    //if (!this.saveCalendar(form)) {\n                    //    saveButton.enable();\n                    //}\n                    //e.stop();\n                    break;\n                }\n                break;\n\n            case Event.KEY_ESC:\n                switch (form.identify()) {\n                case 'kronolithQuickinsertForm':\n                case 'kronolithQuicktaskForm':\n                    this.quickClose();\n                    break;\n                case 'kronolithEventForm':\n                case 'kronolithTaskForm':\n                    Horde_Calendar.hideCal();\n                    this.closeRedBox();\n                    this.go(this.lastLocation);\n                    break;\n                }\n                break;\n            }\n\n            return;\n        }\n\n        switch (kc) {\n        case Event.KEY_ESC:\n            Horde_Calendar.hideCal();\n            this.closeRedBox();\n            break;\n        }\n    },\n\n    keyupHandler: function(e)\n    {\n        switch (e.element().readAttribute('id')) {\n        case 'kronolithEventLocation':\n            if ($F('kronolithEventLocation') && Kronolith.conf.maps.driver) {\n                $('kronolithEventMapLink').show();\n            } else if (Kronolith.conf.maps.driver) {\n                $('kronolithEventMapLink').hide();\n                this.removeMapMarker();\n            }\n            return;\n\n        case 'kronolithEventStartTime':\n        case 'kronolithEventEndTime':\n            var field = $(e.element().readAttribute('id')), kc = e.keyCode;\n\n            switch(e.keyCode) {\n            case Event.KEY_UP:\n            case Event.KEY_DOWN:\n            case Event.KEY_RIGHT:\n            case Event.KEY_LEFT:\n                return;\n            default:\n                if ($F(field) !== this.knl[field.identify()].getCurrentEntry()) {\n                    this.knl[field.identify()].markSelected(null);\n                }\n                return;\n            }\n        }\n\n    },\n\n    clickHandler: function(e, dblclick)\n    {\n        if (e.isRightClick() || typeof e.element != 'function') {\n            return;\n        }\n\n        var elt = e.element(),\n            orig = e.element(),\n            id, tmp, calendar;\n\n        while (Object.isElement(elt)) {\n            id = elt.readAttribute('id');\n\n            switch (id) {\n            case 'kronolithNewEvent':\n                this.go('event');\n                e.stop();\n                return;\n\n            case 'kronolithNewTask':\n                this.go('task');\n                e.stop();\n                return;\n\n            case 'kronolithQuickEvent':\n                if (this.view == 'tasks') {\n                    RedBox.showHtml($('kronolithQuicktask').show());\n                } else {\n                    this.updateCalendarDropDown('kronolithQuickinsertCalendars');\n                    $('kronolithQuickinsertCalendars').setValue(Kronolith.conf.default_calendar);\n                    RedBox.showHtml($('kronolithQuickinsert').show());\n                }\n                e.stop();\n                return;\n\n            case 'kronolithQuickinsertSave':\n                this.quickSaveEvent();\n                e.stop();\n                return;\n\n            case 'kronolithQuicktaskSave':\n                this.quickSaveTask();\n                e.stop();\n                return;\n\n            case 'kronolithQuickinsertCancel':\n            case 'kronolithQuicktaskCancel':\n                this.quickClose();\n                e.stop();\n                return;\n\n            case 'kronolithGotoToday':\n                var view = this.view;\n                if (!$w('day workweek week month year agenda').include(view)) {\n                    view = Kronolith.conf.login_view;\n                }\n                this.go(view + ':' + new Date().dateString());\n                e.stop();\n                return;\n\n            case 'kronolithEventAllday':\n                this.toggleAllDay();\n                break;\n\n            case 'kronolithEventAlarmDefaultOn':\n                this.disableAlarmMethods('Event');\n                break;\n\n            case 'kronolithTaskAlarmDefaultOn':\n                this.disableAlarmMethods('Task');\n                break;\n\n            case 'kronolithEventAlarmPrefs':\n                HordeCore.redirect(HordeCore.addURLParam(\n                    Kronolith.conf.prefs_url,\n                    {\n                        group: 'notification'\n                    }\n                ));\n                e.stop();\n                break;\n\n            case 'kronolithTaskAlarmPrefs':\n                if (Kronolith.conf.tasks.prefs_url) {\n                    HordeCore.redirect(HordeCore.addURLParam(\n                        Kronolith.conf.tasks.prefs_url,\n                        {\n                            group: 'notification'\n                        }\n                    ));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithEventLinkNone':\n            case 'kronolithEventLinkDaily':\n            case 'kronolithEventLinkWeekly':\n            case 'kronolithEventLinkMonthly':\n            case 'kronolithEventLinkYearly':\n            case 'kronolithEventLinkLength':\n            case 'kronolithTaskLinkNone':\n            case 'kronolithTaskLinkDaily':\n            case 'kronolithTaskLinkWeekly':\n            case 'kronolithTaskLinkMonthly':\n            case 'kronolithTaskLinkYearly':\n            case 'kronolithTaskLinkLength':\n                this.toggleRecurrence(\n                    id.startsWith('kronolithEvent'),\n                    id.substring(id.startsWith('kronolithEvent') ? 18 : 17));\n                break;\n\n            case 'kronolithEventRepeatDaily':\n            case 'kronolithEventRepeatWeekly':\n            case 'kronolithEventRepeatMonthly':\n            case 'kronolithEventRepeatYearly':\n            case 'kronolithEventRepeatLength':\n            case 'kronolithTaskRepeatDaily':\n            case 'kronolithTaskRepeatWeekly':\n            case 'kronolithTaskRepeatMonthly':\n            case 'kronolithTaskRepeatYearly':\n            case 'kronolithTaskRepeatLength':\n                this.toggleRecurrence(\n                    id.startsWith('kronolithEvent'),\n                    id.substring(id.startsWith('kronolithEvent') ? 20 : 19));\n                break;\n\n            case 'kronolithEventSave':\n                if (!elt.disabled) {\n                    this._checkDate($('kronolithEventStartDate'));\n                    this._checkDate($('kronolithEventEndDate'));\n                    if ($F('kronolithEventAttendees') && $F('kronolithEventId')) {\n                        $('kronolithEventSendUpdates').setValue(0);\n                        $('kronolithEventDiv').hide();\n                        $('kronolithUpdateDiv').show();\n                        e.stop();\n                        break;\n                    }\n                }\n            case 'kronolithEventSendUpdateYes':\n                if (this.uatts) {\n                    this.uatts.u = true;\n                } else {\n                    $('kronolithEventSendUpdates').setValue(1);\n                }\n            case 'kronolithEventSendUpdateNo':\n                if (this.uatts) {\n                    this.doDragDropUpdate(this.uatts, this.ucb);\n                    this.uatts = null;\n                    this.ucb = null;\n                    this.closeRedBox();\n                    $('kronolithUpdateDiv').hide();\n                    $('kronolithEventDiv').show();\n                } else if (!elt.disabled) {\n                    this.saveEvent();\n                }\n                e.stop();\n                break;\n            case 'kronolithEventConflictYes':\n                this.doSaveEvent();\n                e.stop();\n                break;\n            case 'kronolithEventConflictNo':\n                $('kronolithConflictDiv').hide();\n                $('kronolithEventDiv').show();\n                e.stop();\n                break;\n            case 'kronolithEventSaveAsNew':\n                if (!elt.disabled) {\n                    $('kronolithEventSendUpdates').setValue(1);\n                    this.saveEvent(true);\n                }\n                e.stop();\n                break;\n\n            case 'kronolithTaskSave':\n                if (!elt.disabled) {\n                    this.saveTask();\n                }\n                e.stop();\n                break;\n\n            case 'kronolithEventDeleteCancel':\n                $('kronolithDeleteDiv').hide();\n                $('kronolithEventDiv').show();\n                e.stop();\n                return;\n\n            case 'kronolithEventSendCancellationYes':\n                $('kronolithRecurDeleteAll').enable();\n                $('kronolithRecurDeleteCurrent').enable();\n                $('kronolithRecurDeleteFuture').enable();\n                this.paramsCache.sendupdates = 1;\n            case 'kronolithEventSendCancellationNo':\n                $('kronolithRecurDeleteAll').enable();\n                $('kronolithRecurDeleteCurrent').enable();\n                $('kronolithRecurDeleteFuture').enable();\n                $('kronolithCancellationDiv').hide();\n                this.delete_verified = true;\n            case 'kronolithEventDelete':\n                if ((Kronolith.conf.confirm_delete || this.recurs) && !this.delete_verified) {\n                    $('kronolithEventDiv').hide();\n                    $('kronolithDeleteDiv').show();\n                    e.stop();\n                    break;\n                } else {\n                    $('kronolithEventDiv').hide();\n                    this.delete_verified = false;\n                }\n                // Fallthrough\n            case 'kronolithRecurDeleteAll':\n            case 'kronolithRecurDeleteCurrent':\n            case 'kronolithRecurDeleteFuture':\n            case 'kronolithEventDeleteConfirm':\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n                elt.disable();\n                var cal = $F('kronolithEventCalendar'),\n                    eventid = $F('kronolithEventId');\n                if (id != 'kronolithEventSendCancellationNo' &&\n                    id != 'kronolithEventSendCancellationYes') {\n                    this.paramsCache = {\n                        cal: cal,\n                        id: eventid,\n                        rstart: $F('kronolithEventRecurOStart'),\n                        cstart: this.cacheStart.toISOString(),\n                        cend: this.cacheEnd.toISOString()\n                    };\n                    switch (id) {\n                    case 'kronolithRecurDeleteAll':\n                        this.paramsCache.r = 'all';\n                        break;\n                    case 'kronolithRecurDeleteCurrent':\n                        this.paramsCache.r = 'current';\n                        break;\n                    case 'kronolithRecurDeleteFuture':\n                        this.paramsCache.r = 'future';\n                        break;\n                    }\n                }\n\n                if (id != 'kronolithEventSendCancellationNo'\n                    && id != 'kronolithEventSendCancellationYes'\n                    && $F('kronolithEventAttendees')) {\n\n                    $('kronolithDeleteDiv').hide();\n                    $('kronolithCancellationDiv').show();\n                    e.stop();\n                    break;\n                }\n\n                this.kronolithBody.select('div').findAll(function(el) {\n                    return el.retrieve('calendar') == cal &&\n                        el.retrieve('eventid') == eventid;\n                }).invoke('hide');\n                var viewDates = this.viewDates(this.date, this.view),\n                start = viewDates[0].toString('yyyyMMdd'),\n                end = viewDates[1].toString('yyyyMMdd');\n                this.paramsCache.sig = start + end + (Math.random() + '').slice(2);\n                this.paramsCache.view_start = start;\n                this.paramsCache.view_end = end;\n\n                HordeCore.doAction('deleteEvent', this.paramsCache, {\n                    callback: function(elt,r) {\n                        if (r.deleted) {\n                            var days;\n                            if (this.view == 'month' ||\n                                this.view == 'week' ||\n                                this.view == 'workweek' ||\n                                this.view == 'day') {\n                                days = this.findEventDays(cal, eventid);\n                                days.each(function(day) {\n                                    this.refreshResources(day, cal, eventid);\n                                }.bind(this));\n                            }\n                            this.removeEvent(cal, eventid);\n                            if (r.uid) {\n                                this.removeException(cal, r.uid);\n                            }\n                            this.loadEventsCallback(r, false);\n                            if (days && days.length) {\n                                this.reRender(days);\n                            }\n                        } else {\n                            this.kronolithBody.select('div').findAll(function(el) {\n                                return el.retrieve('calendar') == cal &&\n                                       el.retrieve('eventid') == eventid;\n                            }).invoke('show');\n                        }\n                        elt.enable();\n                    }.curry(elt).bind(this)\n                });\n\n                $('kronolithDeleteDiv').hide();\n                $('kronolithEventDiv').show();\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithTaskDelete':\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n\n                elt.disable();\n                var tasklist = $F('kronolithTaskOldList'),\n                    taskid = $F('kronolithTaskId');\n\n                HordeCore.doAction('deleteTask', {\n                    list: tasklist,\n                    id: taskid\n                }, {\n                    callback: function(r) {\n                        if (r.deleted) {\n                            this.removeTask(tasklist, taskid);\n                        } else {\n                            elt.enable();\n                            $('kronolithViewTasksBody').select('tr').find(function(el) {\n                                return el.retrieve('tasklist') == tasklist &&\n                                       el.retrieve('taskid') == taskid;\n                            }).toggle();\n                        }\n                    }.bind(this)\n                });\n\n                var taskrow = $('kronolithViewTasksBody').select('tr').find(function(el) {\n                    return el.retrieve('tasklist') == tasklist &&\n                        el.retrieve('taskid') == taskid;\n                });\n                if (taskrow) {\n                    taskrow.hide();\n                }\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithCinternalPMore':\n            case 'kronolithCinternalPLess':\n            case 'kronolithCtasklistsPMore':\n            case 'kronolithCtasklistsPLess':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                $('kronolithC' + type + 'PBasic').toggle();\n                $('kronolithC' + type + 'PAdvanced').toggle();\n                e.stop();\n                break;\n\n            case 'kronolithCinternalPNone':\n            case 'kronolithCinternalPAll':\n            case 'kronolithCinternalPG':\n            case 'kronolithCinternalPU':\n            case 'kronolithCtasklistsPNone':\n            case 'kronolithCtasklistsPAll':\n            case 'kronolithCtasklistsPG':\n            case 'kronolithCtasklistsPU':\n                var info = id.match(/kronolithC(.*)P(.*)/);\n                this.permsClickHandler(info[1], info[2]);\n                break;\n\n            case 'kronolithCinternalPAllShow':\n            case 'kronolithCtasklistsPAllShow':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                this.permsClickHandler(type, 'All');\n                break;\n\n            case 'kronolithCinternalPAdvanced':\n            case 'kronolithCtasklistsPAdvanced':\n                var type = id.match(/kronolithC(.*)P/)[1];\n                if (orig.tagName != 'INPUT') {\n                    break;\n                }\n                this.activateAdvancedPerms(type);\n                if (orig.name.match(/u_.*||new/)) {\n                    this.insertGroupOrUser(type, 'user');\n                }\n                break;\n\n            case 'kronolithCinternalPUAdd':\n            case 'kronolithCinternalPGAdd':\n            case 'kronolithCtasklistsPUAdd':\n            case 'kronolithCtasklistsPGAdd':\n                var info = id.match(/kronolithC(.*)P(.)/);\n                this.insertGroupOrUser(info[1], info[2] == 'U' ? 'user' : 'group');\n                break;\n\n            case 'kronolithNavDay':\n            case 'kronolithNavWeek':\n            case 'kronolithNavWorkweek':\n            case 'kronolithNavMonth':\n            case 'kronolithNavYear':\n            case 'kronolithNavAgenda':\n                this.go(id.substring(12).toLowerCase() + ':' + this.date.dateString());\n                e.stop();\n                return;\n\n            case 'kronolithNavTasks':\n                this.go('tasks');\n                e.stop();\n                return;\n\n            case 'kronolithTasksAll':\n            case 'kronolithTasksComplete':\n            case 'kronolithTasksIncomplete':\n            case 'kronolithTasksFuture':\n                this.go('tasks:' + id.substring(14).toLowerCase());\n                e.stop();\n                return;\n\n            case 'kronolithMinicalDate':\n                this.go('month:' + orig.retrieve('date'));\n                e.stop();\n                return;\n\n            case 'kronolith-minical':\n                if (orig.id == 'kronolith-minical-prev') {\n                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));\n                    date.previous().month();\n                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : undefined);\n                    e.stop();\n                    return;\n                }\n                if (orig.id == 'kronolith-minical-next') {\n                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));\n                    date.next().month();\n                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : null);\n                    e.stop();\n                    return;\n                }\n\n                var tmp = orig;\n                if (tmp.tagName.toLowerCase() != 'td') {\n                    tmp = tmp.up('td');\n                }\n                if (tmp) {\n                    if (tmp.retrieve('weekdate') &&\n                        tmp.hasClassName('kronolith-minical-week')) {\n                        this.go('week:' + tmp.retrieve('weekdate'));\n                    } else if (tmp.retrieve('date') &&\n                               !tmp.hasClassName('empty')) {\n                        this.go('day:' + tmp.retrieve('date'));\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithEventsDay':\n                var date = this.date.clone();\n                date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / this.daySizes.height * 2) * 30).minutes();\n                this.go('event:' + date.toString('yyyyMMddHHmm'));\n                e.stop();\n                return;\n\n            case 'kronolithViewMonth':\n                if (orig.hasClassName('kronolith-first-col')) {\n                    var date = orig.retrieve('date');\n                    if (date) {\n                        this.go('week:' + date);\n                        e.stop();\n                        return;\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithViewYear':\n                var tmp = orig;\n                if (tmp.tagName.toLowerCase() != 'td' && tmp.tagName.toLowerCase() != 'th') {\n                    tmp = tmp.up('td');\n                }\n                if (tmp) {\n                    if (tmp.retrieve('weekdate') &&\n                        tmp.hasClassName('kronolith-minical-week')) {\n                        this.go('week:' + tmp.retrieve('weekdate'));\n                    } else if (tmp.hasClassName('kronolithMinicalDate')) {\n                        this.go('month:' + tmp.retrieve('date'));\n                    } else if (tmp.retrieve('date') &&\n                               !tmp.hasClassName('empty')) {\n                        this.go('day:' + tmp.retrieve('date'));\n                    }\n                }\n                e.stop();\n                return;\n\n            case 'kronolithViewAgendaBody':\n                var tmp = orig;\n                if (tmp.tagName != 'TR') {\n                    tmp = tmp.up('tr');\n                }\n                if (tmp && tmp.retrieve('date')) {\n                    this.go('day:' + tmp.retrieve('date'));\n                }\n                e.stop();\n                return;\n\n            case 'kronolithSearchButton':\n                this.go('search:' + this.search + ':' + $F('horde-search-input'));\n                e.stop();\n                break;\n\n            case 'kronolithSearchFuture':\n                if (this.search != 'future') {\n                    this.go('search:future:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithSearchPast':\n                if (this.search != 'past') {\n                    this.go('search:past:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n\n            case 'kronolithSearchAll':\n                if (this.search != 'all') {\n                    this.go('search:all:' + $F('horde-search-input'));\n                }\n                e.stop();\n                break;\n            case 'kronolithEventToTimeslice':\n                var params = $H();\n                params.set('e', $('kronolithEventId').value);\n                params.set('cal', $('kronolithEventCalendar').value);\n                params.set('t', $('kronolithEventTimesliceType').value);\n                params.set('c', $('kronolithEventTimesliceClient').value);\n                HordeCore.doAction('toTimeslice', params);\n                break;\n            case 'kronolithEventDialog':\n            case 'kronolithTaskDialog':\n                Horde_Calendar.hideCal();\n                return;\n\n            case 'kronolithCalendarDialog':\n                if (this.colorPicker) {\n                    this.colorPicker.hide();\n                }\n                return;\n\n            case 'kronolithEditRecurCurrent':\n            case 'kronolithEditRecurFuture':\n                $('kronolithEventStartDate').setValue(this.orstart);\n                $('kronolithEventEndDate').setValue(this.orend);\n                if (id == 'kronolithEditRecurCurrent') {\n                    this.toggleRecurrence('Exception');\n                } else {\n                    this.toggleRecurrence(this.lastRecurType);\n                }\n                return;\n            case 'kronolithEditRecurAll':\n                this.toggleRecurrence(this.lastRecurType);\n                break;\n            case 'kronolithEventUrlToggle':\n                $('kronolithEventUrlDisplay').hide();\n                $('kronolithEventUrl').show();\n                e.stop();\n                return;\n            case 'kronolithCalendarinternalImportButton':\n                // Used when user has edit perms to a shared calendar.\n                this.calendarImport(elt.up('form'), true);\n                break;\n            }\n\n            // Caution, this only works if the element has definitely only a\n            // single CSS class.\n            switch (elt.className) {\n            case 'kronolithPrev':\n            case 'kronolithNext':\n                var newDate = this.date.clone(),\n                    offset = elt.className == 'kronolithPrev' ? -1 : 1;\n                switch (this.view) {\n                case 'day':\n                case 'agenda':\n                    newDate.add(offset).day();\n                    break;\n                case 'week':\n                case 'workweek':\n                    newDate.add(offset).week();\n                    break;\n                case 'month':\n                    newDate.add(offset).month();\n                    break;\n                case 'year':\n                    newDate.add(offset).year();\n                    break;\n                }\n                this.go(this.view + ':' + newDate.dateString());\n                e.stop();\n                return;\n\n            case 'horde-add':\n                this.go('calendar:' + id.replace(/kronolithAdd/, ''));\n                e.stop();\n                return;\n\n            case 'kronolithTabLink':\n                this.openTab(elt);\n                e.stop();\n                break;\n\n            case 'horde-cancel':\n                this.closeRedBox();\n                this.resetMap();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n\n            case 'kronolithEventTag':\n                HordeImple.AutoCompleter.kronolithEventTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithCalendarTag':\n                HordeImple.AutoCompleter.kronolithCalendarinternalTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithTaskTag':\n                HordeImple.AutoCompleter.kronolithTaskTags.addNewItemNode(elt.getText());\n                e.stop();\n                break;\n\n            case 'kronolithEventGeo':\n                this.initializeMap(true);\n                this.geocode($F('kronolithEventLocation'));\n                e.stop();\n                break;\n\n            case 'kronolithTaskRow':\n                if (elt.retrieve('taskid')) {\n                    this.go('task:' + elt.retrieve('tasklist') + ':' + elt.retrieve('taskid'));\n                }\n                e.stop();\n                return;\n\n            case 'horde-resource-edit-000':\n            case 'horde-resource-edit-fff':\n                this.go('calendar:' + elt.up().retrieve('calendarclass') + '|' + elt.up().retrieve('calendar'));\n                e.stop();\n                return;\n\n            case 'kronolithMore':\n                this.go('day:' + elt.retrieve('date'));\n                e.stop();\n                return;\n\n            case 'kronolithDatePicker':\n                id = elt.readAttribute('id');\n                Horde_Calendar.open(id, Date.parseExact($F(id.replace(/Picker$/, 'Date')), Kronolith.conf.date_format));\n                e.stop();\n                return;\n\n            case 'kronolithColorPicker':\n                var input = elt.previous();\n                this.colorPicker = new ColorPicker({\n                    color: $F(input),\n                    offsetParent: elt,\n                    update: [[input, 'value'],\n                             [input, 'background']]\n                });\n                e.stop();\n                return;\n            }\n\n            if (elt.hasClassName('kronolith-event')) {\n                if (!Object.isUndefined(elt.retrieve('ajax'))) {\n                    this.go(elt.retrieve('ajax'));\n                } else {\n                    this.go('event:' + elt.retrieve('calendar') + ':' + elt.retrieve('eventid') + ':' + elt.up().retrieve('date'));\n                }\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithMonthDay')) {\n                if (orig.hasClassName('kronolith-day')) {\n                    var date = orig.retrieve('date');\n                    if (date) {\n                        this.go('day:' + date);\n                        e.stop();\n                        return;\n                    }\n                }\n                this.go('event:' + elt.retrieve('date'));\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithWeekDay')) {\n                this.go('day:' + elt.retrieve('date'));\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithEventsWeek') ||\n                       elt.hasClassName('kronolithEventsWorkweek') ||\n                       elt.hasClassName('kronolithAllDayContainer')) {\n                var date = elt.retrieve('date');\n                if (elt.hasClassName('kronolithAllDayContainer')) {\n                    date += 'all';\n                } else {\n                    date = this.parseDate(date);\n                    date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / (elt.hasClassName('kronolithEventsWeek') ? this.weekSizes.height : this.workweekSizes.height) * 2) * 30).minutes();\n                    date = date.toString('yyyyMMddHHmm');\n                }\n                this.go('event:' + date);\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithTaskCheckbox')) {\n                var taskid = elt.up('tr.kronolithTaskRow', 0).retrieve('taskid'),\n                    tasklist = elt.up('tr.kronolithTaskRow', 0).retrieve('tasklist');\n                this.toggleCompletionClass(taskid);\n\n                HordeCore.doAction('toggleCompletion', {\n                    list: tasklist,\n                    id: taskid\n                }, {\n                    callback: function(r) {\n                        if (r.toggled) {\n                            this.toggleCompletion(tasklist, taskid, r.toggled);\n                            if (r.toggled !== true) {\n                                this.toggleCompletionClass(taskid);\n                            }\n                        } else {\n                            this.toggleCompletionClass(taskid);\n                        }\n                    }.bind(this)\n                });\n\n                e.stop();\n                return;\n            } else if (elt.hasClassName('kronolithCalendarSave')) {\n                if (!elt.disabled) {\n                    elt.disable();\n                    if (!this.saveCalendar(elt.up('form'))) {\n                        elt.enable();\n                    }\n                }\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarContinue')) {\n                if (elt.disabled) {\n                    e.stop();\n                    break;\n                }\n\n                elt.disable();\n                var form = elt.up('form'),\n                    type = form.id.replace(/kronolithCalendarForm/, ''),\n                    i = 1;\n                while (!$('kronolithCalendar' + type + i).visible()) {\n                    i++;\n                }\n                if (type == 'remote') {\n                    var params = { url: $F('kronolithCalendarremoteUrl') };\n                    if (i == 1) {\n                        if (!$F('kronolithCalendarremoteUrl')) {\n                            HordeCore.notify(Kronolith.text.no_url, 'horde.warning');\n                            e.stop();\n                            break;\n                        }\n\n                        HordeCore.doAction('getRemoteInfo', params, {\n                            asynchronous: false,\n                            callback: function(r) {\n                                if (r.success) {\n                                    if (r.name) {\n                                        $('kronolithCalendarremoteName').setValue(r.name);\n                                    }\n                                    if (r.desc) {\n                                        $('kronolithCalendarremoteDescription').setValue(r.desc);\n                                    }\n                                    this.calendarNext(type);\n                                    this.calendarNext(type);\n                                } else if (r.auth) {\n                                    this.calendarNext(type);\n                                } else {\n                                    elt.enable();\n                                }\n                            }.bind(this)\n                        });\n\n                    }\n                    if (i == 2) {\n                        if ($F('kronolithCalendarremoteUsername')) {\n                            params.user = $F('kronolithCalendarremoteUsername');\n                            params.password =  $F('kronolithCalendarremotePassword');\n                        }\n\n                        HordeCore.doAction('getRemoteInfo', params, {\n                            callback: function(r) {\n                                if (r.success) {\n                                    if (r.name &&\n                                        !$F('kronolithCalendarremoteName')) {\n                                        $('kronolithCalendarremoteName').setValue(r.name);\n                                    }\n                                    if (r.desc &&\n                                        !$F('kronolithCalendarremoteDescription')) {\n                                        $('kronolithCalendarremoteDescription').setValue(r.desc);\n                                    }\n                                    this.calendarNext(type);\n                                } else {\n                                    if (r.auth) {\n                                        HordeCore.notify(Kronolith.text.wrong_auth, 'horde.warning');\n                                    }\n                                    elt.enable();\n                                }\n                            }.bind(this)\n                        });\n                    }\n                    e.stop();\n                    break;\n                }\n                this.calendarNext(type);\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarDelete')) {\n                var form = elt.up('form'),\n                    type = form.id.replace(/kronolithCalendarForm/, ''),\n                    calendar = $F('kronolithCalendar' + type + 'Id');\n\n                if ((type == 'tasklists' &&\n                     !window.confirm(Kronolith.text.delete_tasklist)) ||\n                    (type != 'tasklists' &&\n                     !window.confirm(Kronolith.text.delete_calendar))) {\n                    e.stop();\n                    break;\n                }\n\n                if (!elt.disabled) {\n                    elt.disable();\n\n                    HordeCore.doAction('deleteCalendar', {\n                        type: type,\n                        calendar: calendar\n                    }, {\n                        callback: function(r) {\n                            if (r.deleted) {\n                                this.deleteCalendar(type, calendar);\n                            }\n                            this.closeRedBox();\n                            this.go(this.lastLocation);\n                        }.bind(this)\n                    });\n                }\n                e.stop();\n                break;\n            } else if (elt.hasClassName('kronolithCalendarSubscribe') ||\n                       elt.hasClassName('kronolithCalendarUnsubscribe')) {\n                var form = elt.up('form');\n                this.toggleCalendar($F(form.down('input[name=type]')),\n                                    $F(form.down('input[name=calendar]')));\n                this.closeRedBox();\n                this.go(this.lastLocation);\n                e.stop();\n                break;\n            } else if (elt.tagName == 'INPUT' &&\n                       (elt.name == 'event_alarms[]' ||\n                        elt.name == 'task[alarm_methods][]')) {\n                if (elt.name == 'event_alarms[]') {\n                    $('kronolithEventAlarmOn').setValue(1);\n                    $('kronolithEventAlarmDefaultOff').setValue(1);\n                } else {\n                    $('kronolithTaskAlarmOn').setValue(1);\n                    $('kronolithTaskAlarmDefaultOff').setValue(1);\n                }\n                if ($(elt.id + 'Params')) {\n                    if (elt.getValue()) {\n                        $(elt.id + 'Params').show();\n                    } else {\n                        $(elt.id + 'Params').hide();\n                    }\n                }\n                break;\n            }\n\n            var calClass = elt.retrieve('calendarclass');\n            if (calClass) {\n                this.toggleCalendar(calClass, elt.retrieve('calendar'));\n                e.stop();\n                return;\n            }\n\n            elt = elt.up();\n        }\n        // Workaround Firebug bug.\n        Prototype.emptyFunction();\n    },\n\n    /**\n     * Handles date selections from a date picker.\n     */\n    datePickerHandler: function(e)\n    {\n        var field = e.element().previous();\n        field.setValue(e.memo.toString(Kronolith.conf.date_format));\n        this.updateTimeFields(field.identify());\n    },\n\n    /**\n     * Handles moving an event to a different day in month view and all day\n     * events in weekly/daily views.\n     */\n    onDrop: function(e)\n    {\n        var drop = e.element(),\n            el = e.memo.element;\n\n        if (drop == el.up()) {\n            return;\n        }\n\n        var lastDate = this.parseDate(el.up().retrieve('date')),\n            newDate = this.parseDate(drop.retrieve('date')),\n            diff = newDate.subtract(lastDate),\n            eventid = el.retrieve('eventid'),\n            cal = el.retrieve('calendar'),\n            viewDates = this.viewDates(this.date, this.view),\n            start = viewDates[0].toString('yyyyMMdd'),\n            end = viewDates[1].toString('yyyyMMdd'),\n            sig = start + end + (Math.random() + '').slice(2),\n            events = this.getCacheForDate(lastDate.toString('yyyyMMdd'), cal),\n            attributes = $H({ offDays: diff }),\n            event = events.find(function(e) { return e.key == eventid; });\n\n        drop.insert(el);\n        this.startLoading(cal, sig);\n        if (event.value.r) {\n            attributes.set('rday', lastDate);\n            attributes.set('cstart', this.cacheStart);\n            attributes.set('cend', this.cacheEnd);\n        }\n        var uatts = {\n            cal: cal,\n            id: eventid,\n            view: this.view,\n            sig: sig,\n            view_start: start,\n            view_end: end,\n            att: Object.toJSON(attributes)\n        },\n        callback = function(r) {\n          if (r.events) {\n              // Check if this is the still the result of the\n              // most current request.\n              if (r.sig == this.eventsLoading[r.cal]) {\n                  var days;\n                  if ((this.view == 'month' &&\n                       Kronolith.conf.max_events) ||\n                      this.view == 'week' ||\n                      this.view == 'workweek' ||\n                      this.view == 'day') {\n                      days = this.findEventDays(cal, eventid);\n                  }\n                  this.removeEvent(cal, eventid);\n                  if (days && days.length) {\n                      this.reRender(days);\n                  }\n              }\n              $H(r.events).each(function(days) {\n                  $H(days.value).each(function(event) {\n                      if (event.value.c.startsWith('tasks/')) {\n                          var tasklist = event.value.c.substr(6),\n                              task = event.key.substr(6),\n                              taskObject;\n                          if (this.tcache.get('incomplete') &&\n                              this.tcache.get('incomplete').get(tasklist) &&\n                              this.tcache.get('incomplete').get(tasklist).get(task)) {\n                              taskObject = this.tcache.get('incomplete').get(tasklist).get(task);\n                              taskObject.due = Date.parse(event.value.s);\n                              this.tcache.get('incomplete').get(tasklist).set(task, taskObject);\n                          }\n                      }\n                  }, this);\n              }, this);\n          }\n          this.loadEventsCallback(r, false);\n          $H(r.events).each(function(days) {\n              $H(days.value).each(function(event) {\n                  if (event.key == eventid) {\n                      this.refreshResources(days.key, cal, eventid, lastDate.toString('yyyyMMdd'), event);\n                  }\n              }.bind(this))\n          }.bind(this));\n      }.bind(this);\n\n      if (event.value.mt) {\n          $('kronolithEventDiv').hide();\n          $('kronolithUpdateDiv').show();\n          RedBox.showHtml($('kronolithEventDialog').show());\n          this.uatts = uatts;\n          this.ucb = callback;\n      } else {\n          this.doDragDropUpdate(uatts, callback);\n      }\n    },\n\n    onDragStart: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        var elt = e.element();\n\n        if (elt.hasClassName('kronolithDragger')) {\n            elt.up().addClassName('kronolith-selected');\n            DragDrop.Drags.getDrag(elt).top = elt.cumulativeOffset().top;\n        } else if (elt.hasClassName('kronolithEditable')) {\n            elt.addClassName('kronolith-selected').setStyle({ left: 0, width: (this.view == 'week' || this.view == 'workweek') ? '90%' : '95%', zIndex: 1 });\n        }\n\n        this.scrollTop = $('kronolithView' + this.view.capitalize())\n            .down('.kronolithViewBody')\n            .scrollTop;\n        this.scrollLast = this.scrollTop;\n    },\n\n    onDrag: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        var elt = e.element(),\n            drag = DragDrop.Drags.getDrag(elt);\n            storage = this.view + 'Sizes',\n            step = this[storage].height / 6;\n\n            if (!drag.event) {\n                return;\n            }\n\n        var event = drag.event.value;\n\n        if (elt.hasClassName('kronolithDragger')) {\n            // Resizing the event.\n            var div = elt.up(),\n                top = drag.ghost.cumulativeOffset().top,\n                scrollTop = $('kronolithView' + this.view.capitalize()).down('.kronolithViewBody').scrollTop,\n                offset = 0,\n                height;\n\n            // Check if view has scrolled since last call.\n            if (scrollTop != this.scrollLast) {\n                offset = scrollTop - this.scrollLast;\n                this.scrollLast = scrollTop;\n            }\n            if (elt.hasClassName('kronolithDraggerTop')) {\n                offset += top - drag.top;\n                height = div.offsetHeight - offset;\n                div.setStyle({\n                    top: (div.offsetTop + offset) + 'px'\n                });\n                offset = drag.ghost.offsetTop;\n                drag.top = top;\n            } else {\n                offset += top - drag.top;\n                height = div.offsetHeight + offset;\n                offset = div.offsetTop;\n                drag.top = top;\n            }\n            div.setStyle({\n                height: height + 'px'\n            });\n\n            this.calculateEventDates(event, storage, step, offset, height);\n            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());\n        } else if (elt.hasClassName('kronolithEditable')) {\n            // Moving the event.\n            if (Object.isUndefined(drag.innerDiv)) {\n                drag.innerDiv = drag.ghost.down('.kronolith-event-info');\n            }\n            if ((this.view == 'week') || (this.view == 'workweek')) {\n                var offsetX = Math.round(drag.ghost.offsetLeft / drag.stepX);\n                event.offsetDays = offsetX;\n                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight, event.start.clone().addDays(offsetX), event.end.clone().addDays(offsetX));\n            } else {\n                event.offsetDays = 0;\n                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight);\n            }\n            event.offsetTop = drag.ghost.offsetTop - drag.startTop;\n            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());\n            elt.clonePosition(drag.ghost, { offsetLeft: (this.view == 'week' || this.view == 'workweek') ? -2 : 0 });\n        }\n    },\n\n    onDragEnd: function(e)\n    {\n        if (this.view == 'month') {\n            return;\n        }\n\n        if (!e.element().hasClassName('kronolithDragger') &&\n            !e.element().hasClassName('kronolithEditable')) {\n            return;\n        }\n\n        var div = e.element(),\n            drag = DragDrop.Drags.getDrag(div),\n            event = drag.event;\n\n\n        if (event.value.al) {\n            return;\n        }\n        var date = drag.midnight,\n            storage = this.view + 'Sizes',\n            step = this[storage].height / 6,\n            dates = this.viewDates(date, this.view),\n            start = dates[0].dateString(),\n            end = dates[1].dateString(),\n            sig = start + end + (Math.random() + '').slice(2),\n            element, attributes;\n\n        div.removeClassName('kronolith-selected');\n        if (!Object.isUndefined(drag.innerDiv)) {\n            this.setEventText(drag.innerDiv, event.value);\n        }\n        this.startLoading(event.value.calendar, sig);\n        if (!Object.isUndefined(event.value.offsetTop)) {\n            attributes = $H({ offDays: event.value.offsetDays,\n                              offMins: Math.round(event.value.offsetTop / step) * 10 });\n            element = div;\n        } else if (div.hasClassName('kronolithDraggerTop')) {\n            attributes = $H({ start: event.value.start });\n            element = div.up();\n        } else if (div.hasClassName('kronolithDraggerBottom')) {\n            attributes = $H({ end: event.value.end });\n            element = div.up();\n        } else {\n            attributes = $H({ start: event.value.start,\n                              end: event.value.end });\n            element = div;\n        }\n        if (event.value.r) {\n            attributes.set('rstart', event.value.s);\n            attributes.set('rend', event.value.e);\n            attributes.set('cstart', this.cacheStart);\n            attributes.set('cend', this.cacheEnd);\n        }\n        element.retrieve('drags').invoke('destroy');\n        var uatts = {\n            cal: event.value.calendar,\n            id: event.key,\n            view: this.view,\n            sig: sig,\n            view_start: start,\n            view_end: end,\n            att: Object.toJSON(attributes)\n        },\n        callback = function(r) {\n            // Check if this is the still the result of the most current\n            // request.\n            if (r.events &&\n                r.sig == this.eventsLoading[r.cal]) {\n                if (event.value.rs) {\n                    var d = new Date(event.value.s);\n                    this.refreshResources(d.toString('yyyyMMdd'), event.value.calendar, event.key)\n                }\n                this.removeEvent(event.value.calendar, event.key);\n            }\n            this.loadEventsCallback(r, false);\n        }.bind(this);\n\n        if (event.value.mt) {\n            $('kronolithEventDiv').hide();\n            $('kronolithUpdateDiv').show();\n            RedBox.showHtml($('kronolithEventDialog').show());\n            this.uatts = uatts;\n            this.ucb = callback;\n        } else {\n            this.doDragDropUpdate(uatts, callback);\n        }\n    },\n\n    doDragDropUpdate: function(att, cb)\n    {\n        HordeCore.doAction('updateEvent', att, {\n            callback: cb\n        });\n    },\n\n    /**\n     * Refresh any resource calendars bound to the given just-updated event.\n     * Clears the old resource event from UI and cache, and clears the cache\n     * for the days of the new event, in order to allow listEvents to refresh\n     * the UI.\n     *\n     * @param  string dt       The current/new date for the event (yyyyMMdd).\n     * @param  string cal      The calendar the event exists in.\n     * @param  string eventid  The eventid that is changing.\n     * @param  string last_dt  The previous date for the event, if known. (yyyyMMdd).\n     * @param  object event    The event object (if a new event) dt is ignored.\n     *\n     */\n    refreshResources: function(dt, cal, eventid, last_dt, event)\n    {\n        var events = this.getCacheForDate(dt, cal),\n            update_cals = [], r_dates;\n\n        if (!event) {\n            event = events.find(function(e) { return e.key == eventid; });\n        }\n        if (!dt) {\n            dt = new Date(event.value.s);\n        } else {\n            dt = this.parseDate(dt);\n        }\n        if (event) {\n            $H(event.value.rs).each(function(r) {\n                var r_cal = ['resource', r.value.calendar],\n                    r_events = this.getCacheForDate(last_dt, r_cal.join('|')),\n                    r_event, day, end;\n\n                if (r_events) {\n                    r_event = r_events.find(function(e) { return e.value.uid == event.value.uid });\n                    if (r_event) {\n                        this.removeEvent(r_cal, r_event.key);\n                        day = new Date(r_event.value.s);\n                        end = new Date(r_event.value.s);\n                        while (!day.isAfter(end)) {\n                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));\n                            day.add(1).day();\n                        }\n                        day = new Date(event.value.s);\n                        end = new Date(event.value.e);\n\n                        while (!day.isAfter(end)) {\n                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));\n                            day.add(1).day();\n                        }\n                    } else {\n                        // Don't know the previous date/time so just nuke the cache.\n                       this.deleteCache(r_cal);\n                    }\n                } else {\n                    this.deleteCache(r_cal);\n                }\n                update_cals.push(r_cal);\n            }.bind(this));\n\n            if (update_cals.length) {\n                dates = this.viewDates(dt, this.view);\n                // Ensure we also grab the full length of the events.\n                if (dates[0].isAfter(dt)) {\n                    dates[0] = dt;\n                }\n                var dt_end = new Date(event.value.e);\n                if (dt_end.isAfter(dates[1])) {\n                    dates[1] = dt_end;\n                }\n                this.loadEvents(dates[0], dates[1], this.view, update_cals);\n            }\n        }\n    },\n\n    editEvent: function(calendar, id, date, title)\n    {\n        if (this.redBoxLoading) {\n            return;\n        }\n        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithEventTags)) {\n            this.editEvent.bind(this, calendar, id, date).defer();\n            return;\n        }\n\n        this.closeRedBox();\n        this.quickClose();\n        this.redBoxOnDisplay = RedBox.onDisplay;\n        RedBox.onDisplay = function() {\n            if (this.redBoxOnDisplay) {\n                this.redBoxOnDisplay();\n            }\n            try {\n                $('kronolithEventForm').focusFirstElement();\n            } catch(e) {}\n            if (Kronolith.conf.maps.driver &&\n                $('kronolithEventLinkMap').up().hasClassName('horde-active') &&\n                !this.mapInitialized) {\n\n                this.initializeMap();\n            }\n            RedBox.onDisplay = this.redBoxOnDisplay;\n        }.bind(this);\n        this.attendees = [];\n        this.resources = [];\n        this.updateCalendarDropDown('kronolithEventTarget');\n        this.toggleAllDay(false);\n        this.openTab($('kronolithEventForm').down('.tabset a.kronolithTabLink'));\n        this.disableAlarmMethods('Event');\n        this.knl.kronolithEventStartTime.markSelected();\n        this.knl.kronolithEventEndTime.markSelected();\n        $('kronolithEventForm').reset();\n        this.resetMap();\n        HordeImple.AutoCompleter.kronolithEventAttendees.reset();\n        HordeImple.AutoCompleter.kronolithEventTags.reset();\n        HordeImple.AutoCompleter.kronolithEventResources.reset();\n        if (Kronolith.conf.maps.driver) {\n            $('kronolithEventMapLink').hide();\n        }\n        $('kronolithEventSave').show().enable();\n        $('kronolithEventSaveAsNew').show().enable();\n        $('kronolithEventDelete').show().enable();\n        $('kronolithEventDeleteConfirm').enable();\n        $('kronolithEventTarget').show();\n        $('kronolithEventTargetRO').hide();\n        $('kronolithEventForm').down('.kronolithFormActions .kronolithSeparator').show();\n        $('kronolithEventExceptions').clear();\n        if (id) {\n            // An id passed to this function indicates we are editing an event.\n            RedBox.loading();\n            var attributes = { cal: calendar, id: id, date: date };\n            // Need the current st and et of this instance.\n            var events = this.getCacheForDate(date.toString('yyyyMMdd'), calendar);\n            if (events) {\n                var ev = events.find(function(e) { return e.key == id; });\n                if (ev[1].r) {\n                    attributes.rsd = ev[1].start.dateString();\n                    attributes.red = ev[1].end.dateString();\n                }\n            }\n            HordeCore.doAction('getEvent', attributes, {\n                callback: this.editEventCallback.bind(this)\n            });\n            $('kronolithEventTopTags').update();\n        } else {\n            // This is a new event.\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')\n            });\n            var d;\n            if (date) {\n                if (date.endsWith('all')) {\n                    date = date.substring(0, date.length - 3);\n                    $('kronolithEventAllday').setValue(true);\n                    this.toggleAllDay(true);\n                }\n                d = this.parseDate(date);\n            } else {\n                d = new Date();\n            }\n            if (title) {\n                $('kronolithEventTitle').setValue(title);\n            }\n            $('kronolithEventId').clear();\n            $('kronolithEventCalendar').clear();\n            $('kronolithEventTarget').setValue(Kronolith.conf.default_calendar);\n            $('kronolithEventDelete').hide();\n            $('kronolithEventStartDate').setValue(d.toString(Kronolith.conf.date_format));\n            $('kronolithEventStartTime').setValue(d.toString(Kronolith.conf.time_format));\n            this.updateFBDate(d);\n            d.add(1).hour();\n            this.duration = 60;\n            $('kronolithEventEndDate').setValue(d.toString(Kronolith.conf.date_format));\n            $('kronolithEventEndTime').setValue(d.toString(Kronolith.conf.time_format));\n            $('kronolithEventLinkExport').up('span').hide();\n            $('kronolithEventSaveAsNew').hide();\n            $('kronolithEventUrlDisplay').hide();\n            $('kronolithEventUrl').show();\n            this.toggleRecurrence(true, 'None');\n            $('kronolithEventEditRecur').hide();\n            this.enableAlarm('Event', Kronolith.conf.default_alarm);\n            this.redBoxLoading = true;\n            RedBox.showHtml($('kronolithEventDialog').show());\n        }\n    },\n\n    /**\n     * Generates ajax request parameters for requests to save events.\n     *\n     * @return object  An object with request parameters.\n     */\n    saveEventParams: function()\n    {\n        var viewDates = this.viewDates(this.date, this.view),\n            params = {\n                sig: viewDates[0].dateString() + viewDates[1].dateString(),\n                view: this.view\n            };\n        if (this.cacheStart) {\n            params.view_start = this.cacheStart.dateString();\n            params.view_end = this.cacheEnd.dateString();\n        }\n        return params;\n    },\n\n    /**\n     * Submits the event edit form to create or update an event.\n     */\n    saveEvent: function(asnew)\n    {\n        this.validateEvent(asnew);\n    },\n\n    /**\n     * Perform any preliminary checks necessary. doSaveEvent will be called from\n     * the callback if checks are successful.\n     *\n     */\n    validateEvent: function(asnew)\n    {\n        if (this.wrongFormat.size()) {\n            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');\n            return;\n        }\n\n        // Check that there are no conflicts.\n        if (Kronolith.conf.has_resources && $F('kronolithEventResourceIds')) {\n            HordeCore.doAction(\n                'checkResources',\n                {\n                    s: this.getDate('start').toISOString(),\n                    e: this.getDate('end').toISOString(),\n                    i: $F('kronolithEventId'),\n                    c: $F('kronolithEventCalendar'),\n                    r: $F('kronolithEventResourceIds')\n                },\n                {\n                    callback: this.validateEventCallback.curry(asnew).bind(this)\n                }\n            );\n        } else {\n            this.validateEventCallback(asnew, {});\n        }\n    },\n\n    validateEventCallback: function(asnew, r)\n    {\n        var conflict = false;\n\n        $H(r).each(function(a) {\n            // 3 == Kronolith::RESPONSE_DECLINED\n            if (a.value == 3) {\n                $('kronolithEventDiv').hide();\n                $('kronolithConflictDiv').show();\n                conflict = true;\n                return;\n            }\n        });\n        if (!conflict) {\n            this.doSaveEvent(asnew);\n        }\n    },\n\n    doSaveEvent: function(asnew)\n    {\n        var cal = $F('kronolithEventCalendar'),\n            target = $F('kronolithEventTarget'),\n            eventid = $F('kronolithEventId'),\n            params;\n\n        if (this.mapInitialized) {\n            $('kronolithEventMapZoom').value = this.map.getZoom();\n        }\n\n        params = $H($('kronolithEventForm').serialize({ hash: true }))\n            .merge(this.saveEventParams());\n        params.set('as_new', asnew ? 1 : 0);\n        if (this.cacheStart) {\n            params.set('cstart', this.cacheStart.toISOString());\n            params.set('cend', this.cacheEnd.toISOString());\n        }\n        HordeImple.AutoCompleter.kronolithEventTags.shutdown();\n        $('kronolithEventSave').disable();\n        $('kronolithEventSaveAsNew').disable();\n        $('kronolithEventDelete').disable();\n        this.startLoading(target, params.get('sig'));\n        HordeCore.doAction('saveEvent', params, {\n            callback: function(r) {\n                if (!asnew && r.events && eventid) {\n                    this.removeEvent(cal, eventid);\n                }\n                this.loadEventsCallback(r, false);\n\n                // Refresh bound exceptions\n                var calendar = cal.split('|'), refreshed = false;\n                $H(r.events).each(function(d) {\n                    $H(d.value).each(function(evt) {\n                        if (evt.value.bid) {\n                            var cache = this.getCacheForDate(this.findEventDays(cal, evt.key, cal));\n                            cache.each(function(entry) {\n                                if (entry.value.bid == evt.value.bid && evt.value.c != calendar[1]) {\n                                    this.removeEvent(cal, entry.key);\n                                }\n                            }.bind(this));\n                        }\n                        if (!refreshed && ((evt.key == eventid) || !eventid) && evt.value.rs) {\n                            this.refreshResources(null, cal, eventid, false, evt);\n                            refreshed = true;\n                        }\n                    }.bind(this))\n                }.bind(this));\n\n                if (r.events) {\n                    this.resetMap();\n                    this.closeRedBox();\n                    this.go(this.lastLocation);\n                } else {\n                    $('kronolithEventSave').enable();\n                    $('kronolithEventSaveAsNew').enable();\n                    $('kronolithEventDelete').enable();\n                }\n                $('kronolithUpdateDiv').hide();\n                $('kronolithConflictDiv').hide();\n                $('kronolithEventDiv').show();\n            }.bind(this)\n        });\n    },\n\n    quickSaveEvent: function()\n    {\n        var text = $F('kronolithQuickinsertQ'),\n            cal = $F('kronolithQuickinsertCalendars'),\n            params;\n\n        params = $H($('kronolithEventForm').serialize({ hash: true }))\n            .merge(this.saveEventParams());\n        params.set('text', text);\n        params.set('cal', cal);\n\n        this.closeRedBox();\n        this.startLoading(cal, params.get('sig'));\n        HordeCore.doAction('quickSaveEvent', params, {\n            callback: function(r) {\n                this.loadEventsCallback(r, false);\n                if (r.error) {\n                    this.editEvent(null, null, null, text);\n                } else {\n                    $('kronolithQuickinsertQ').value = '';\n                }\n             }.bind(this)\n         });\n    },\n\n    /**\n     * Closes and resets the quick event form.\n     */\n    quickClose: function()\n    {\n        $('kronolithQuickinsertQ').value = '';\n        if ($('kronolithQuicktaskQ')) {\n            $('kronolithQuicktaskQ').value = '';\n        }\n        this.closeRedBox();\n    },\n\n    topTagsCallback: function(update, tagclass, r)\n    {\n        $('kronolithEventTabTags').select('label').invoke('show');\n        if (!r.tags) {\n            $(update).update();\n            return;\n        }\n\n        var t = new Element('ul', { className: 'horde-tags' });\n        r.tags.each(function(tag) {\n            if (tag == null) {\n                return;\n            }\n            t.insert(new Element('li', { className: tagclass }).update(tag.escapeHTML()));\n        });\n        $(update).update(t);\n    },\n\n    /**\n     * Callback method for showing event forms.\n     *\n     * @param object r  The ajax response object.\n     */\n    editEventCallback: function(r)\n    {\n        if (!r.event) {\n            RedBox.close();\n            this.go(this.lastLocation);\n            return;\n        }\n\n        var ev = r.event;\n\n        if (!Object.isUndefined(ev.ln)) {\n            this.loadPage(ev.ln);\n            this.closeRedBox();\n            return;\n        }\n\n        /* Basic information */\n        $('kronolithEventId').setValue(ev.id);\n        $('kronolithEventCalendar').setValue(ev.ty + '|' + ev.c);\n        $('kronolithEventTarget').setValue(ev.ty + '|' + ev.c);\n        $('kronolithEventTargetRO').update(Kronolith.conf.calendars[ev.ty][ev.c].name.escapeHTML());\n        $('kronolithEventTitle').setValue(ev.t);\n        $('kronolithEventLocation').setValue(ev.l);\n        $('kronolithEventTimezone').setValue(ev.tz);\n        if (ev.l && Kronolith.conf.maps.driver) {\n            $('kronolithEventMapLink').show();\n        }\n        if (ev.uhl) {\n            $('kronolithEventUrlDisplay').down().update(ev.uhl);\n            $('kronolithEventUrlDisplay').show();\n            $('kronolithEventUrl').hide();\n        }\n        else {\n            $('kronolithEventUrlDisplay').hide();\n            $('kronolithEventUrl').show();\n        }\n\n        if (ev.u) {\n            $('kronolithEventUrl').setValue(ev.u);\n        }\n\n        $('kronolithEventAllday').setValue(ev.al);\n\n        if (ev.r && ev.rsd && ev.red) {\n            // Save the original datetime, so we can properly create the\n            // exception.\n            var osd = Date.parse(ev.rsd + ' ' + ev.st);\n            var oed = Date.parse(ev.red + ' ' + ev.et);\n\n            $('kronolithEventRecurOStart').setValue(osd.toString('s'));\n            $('kronolithEventRecurOEnd').setValue(oed.toString('s'));\n\n            // ...and put the same value in the form field to replace the\n            // date of the initial series.\n            $('kronolithEventStartDate').setValue(ev.sd);\n            $('kronolithEventEndDate').setValue(ev.ed);\n            // Save the current datetime in case we are not editing 'all'\n            this.orstart = ev.rsd;\n            this.orend = ev.red;\n        } else {\n            $('kronolithEventStartDate').setValue(ev.sd);\n            $('kronolithEventEndDate').setValue(ev.ed);\n            $('kronolithEventRecurEnd').clear();\n            $('kronolithEventRecurOStart').clear();\n            $('kronolithEventRecurOEnd').clear();\n            this.orstart = null;\n            this.orend = null;\n        }\n\n        $('kronolithEventStartTime').setValue(ev.st);\n        this.knl.kronolithEventStartTime.setSelected(ev.st);\n        this.updateFBDate(Date.parseExact(ev.sd, Kronolith.conf.date_format));\n        $('kronolithEventEndTime').setValue(ev.et);\n        this.knl.kronolithEventEndTime.setSelected(ev.et);\n        this.duration = Math.abs(Date.parse(ev.e).getTime() - Date.parse(ev.s).getTime()) / 60000;\n        this.toggleAllDay(ev.al);\n        $('kronolithEventStatus').setValue(ev.x);\n        $('kronolithEventDescription').setValue(ev.d);\n        $('kronolithEventPrivate').setValue(ev.pv);\n        $('kronolithEventLinkExport').up('span').show();\n        $('kronolithEventExport').href = Kronolith.conf.URI_EVENT_EXPORT.interpolate({ id: ev.id, calendar: ev.c, type: ev.ty });\n\n        /* Alarm */\n        if (ev.a) {\n            this.enableAlarm('Event', ev.a);\n            if (ev.m) {\n                $('kronolithEventAlarmDefaultOff').checked = true;\n                $H(ev.m).each(function(method) {\n                    $('kronolithEventAlarm' + method.key).setValue(1);\n                    if ($('kronolithEventAlarm' + method.key + 'Params')) {\n                        $('kronolithEventAlarm' + method.key + 'Params').show();\n                        $H(method.value).each(function(param) {\n                            var input = $('kronolithEventAlarmParam' + param.key);\n                            if (input.type == 'radio') {\n                                input.up('form').select('input[type=radio]').each(function(radio) {\n                                    if (radio.name == input.name &&\n                                        radio.value == param.value) {\n                                        radio.setValue(1);\n                                        throw $break;\n                                    }\n                                });\n                            } else {\n                                input.setValue(param.value);\n                            }\n                        });\n                    }\n                });\n            }\n        } else {\n            $('kronolithEventAlarmOff').setValue(true);\n        }\n\n        /* Recurrence */\n        if (ev.r) {\n            this.setRecurrenceFields(true, ev.r);\n            $('kronolithRecurDelete').show();\n            $('kronolithNoRecurDelete').hide();\n            $('kronolithEventEditRecur').show();\n            this.recurs = true;\n        } else if (ev.bid) {\n            $('kronolithRecurDelete').hide();\n            $('kronolithNoRecurDelete').show();\n            $('kronolithEventEditRecur').hide();\n            var div = $('kronolithEventRepeatException');\n            div.down('span').update(ev.eod);\n            this.toggleRecurrence(true, 'Exception');\n            this.recurs = false;\n        } else {\n            $('kronolithRecurDelete').hide();\n            $('kronolithNoRecurDelete').show();\n            $('kronolithEventEditRecur').hide();\n            this.toggleRecurrence(true, 'None');\n            this.recurs = false;\n        }\n\n        /* Attendees */\n        if (!Object.isUndefined(ev.at)) {\n            HordeImple.AutoCompleter.kronolithEventAttendees.reset(ev.at.pluck('l'));\n            ev.at.each(this.addAttendee.bind(this));\n            if (this.fbLoading) {\n                $('kronolithFBLoading').show();\n            }\n        }\n\n        /* Resources */\n        if (!Object.isUndefined(ev.rs)) {\n            var rs = $H(ev.rs);\n            HordeImple.AutoCompleter.kronolithEventResources.reset(rs.values().pluck('name'));\n            rs.each(function(r) { this.addResource(r.value, r.key); }.bind(this));\n            if (this.fbLoading) {\n                $('kronolithResourceFBLoading').show();\n            }\n        }\n\n        /* Tags */\n        HordeImple.AutoCompleter.kronolithEventTags.reset(ev.tg);\n\n        /* Geo */\n        if (ev.gl) {\n            $('kronolithEventLocationLat').value = ev.gl.lat;\n            $('kronolithEventLocationLon').value = ev.gl.lon;\n            $('kronolithEventMapZoom').value = Math.max(1, ev.gl.zoom);\n        }\n\n        if (!ev.pe) {\n            $('kronolithEventSave').hide();\n            HordeImple.AutoCompleter.kronolithEventTags.disable();\n            $('kronolithEventTabTags').select('label').invoke('hide');\n        } else {\n            HordeCore.doAction('listTopTags', {}, {\n                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')\n            });\n        }\n        if (!ev.pd) {\n            $('kronolithEventDelete').hide();\n            $('kronolithEventTarget').hide();\n            $('kronolithEventTargetRO').show();\n        }\n\n        this.setTitle(ev.t);\n        this.redBoxLoading = true;\n        RedBox.showHtml($('kronolithEventDialog').show());\n\n        /* Hide alarm message for this event. */\n        if (r.msgs) {\n            r.msgs = r.msgs.reject(function(msg) {\n                if (msg.type != 'horde.alarm') {\n                    return false;\n                }\n                var alarm = msg.flags.alarm;\n                if (alarm.params && alarm.params.notify &&\n                    alarm.params.notify.show &&\n                    alarm.params.notify.show.calendar &&\n                    alarm.params.notify.show.event &&\n                    alarm.params.notify.show.calendar == ev.c &&\n                    alarm.params.notify.show.event == ev.id) {\n                    return true;\n                }\n                return false;\n            });\n        }\n    },\n\n    /**\n     * Adds an attendee row to the free/busy table.\n     *\n     * @param object attendee  An attendee object with the properties:\n     *                         - e: email address\n     *                         - l: the display name of the attendee\n     */\n    addAttendee: function(attendee)\n    {\n        if (typeof attendee == 'string') {\n            if (attendee.include('@')) {\n                HordeCore.doAction('parseEmailAddress', {\n                    email: attendee\n                }, {\n                    callback: function (r) {\n                        if (r.email) {\n                            this.addAttendee({ e: r.email, l: attendee });\n                        }\n                    }.bind(this)\n                });\n                return;\n            } else {\n                attendee = { l: attendee };\n            }\n        }\n\n        if (attendee.e) {\n            this.attendees.push(attendee);\n            this.fbLoading++;\n            HordeCore.doAction('getFreeBusy', {\n                email: attendee.e\n            }, {\n                callback: function(r) {\n                    this.fbLoading--;\n                    if (!this.fbLoading) {\n                        $('kronolithFBLoading').hide();\n                    }\n                    if (!Object.isUndefined(r.fb)) {\n                        this.freeBusy.get(attendee.l)[1] = r.fb;\n                        this.insertFreeBusy(attendee.l, this.getFBDate());\n                    }\n                }.bind(this)\n            });\n        }\n\n        var tr = new Element('tr'), response, i;\n        this.freeBusy.set(attendee.l, [ tr ]);\n        attendee.r = attendee.r || 1;\n        switch (attendee.r) {\n            case 1: response = 'None'; break;\n            case 2: response = 'Accepted'; break;\n            case 3: response = 'Declined'; break;\n            case 4: response = 'Tentative'; break;\n        }\n        tr.insert(new Element('td')\n                  .writeAttribute('title', attendee.l)\n                  .addClassName('kronolithAttendee' + response)\n                  .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));\n        for (i = 0; i < 24; i++) {\n            tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n        }\n        $('kronolithEventAttendeesList').down('tbody').insert(tr);\n    },\n\n    resetFBRows: function()\n    {\n        this.attendees.each(function(attendee) {\n            var row = this.freeBusy.get(attendee.l)[0];\n            row.update();\n\n            attendee.r = attendee.r || 1;\n            switch (attendee.r) {\n                case 1: response = 'None'; break;\n                case 2: response = 'Accepted'; break;\n                case 3: response = 'Declined'; break;\n                case 4: response = 'Tentative'; break;\n            }\n            row.insert(new Element('td')\n                      .writeAttribute('title', attendee.l)\n                      .addClassName('kronolithAttendee' + response)\n                      .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));\n            for (i = 0; i < 24; i++) {\n                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n        }.bind(this));\n        this.resources.each(function(resource) {\n            var row = this.freeBusy.get(resource)[0],\n                tdone = row.down('td');\n            row.update();\n            row.update(tdone);\n            for (i = 0; i < 24; i++) {\n                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n        }.bind(this));\n    },\n\n    addResource: function(resource, id)\n    {\n        var v, response = 1;\n        if (!id) {\n            // User entered\n            this.resourceACCache.choices.each(function(i) {\n                if (i.name == resource) {\n                    v = i.code;\n                    throw $break;\n                } else {\n                    v = false;\n                }\n            }.bind(this));\n        } else {\n            // Populating from an edit event action\n            v = id;\n            response = resource.response;\n            resource = resource.name;\n        }\n\n        switch (response) {\n            case 1: response = 'None'; break;\n            case 2: response = 'Accepted'; break;\n            case 3: response = 'Declined'; break;\n            case 4: response = 'Tentative'; break;\n        }\n        var att = {\n            'resource': v\n        },\n        tr, i;\n        if (att.resource) {\n            this.fbLoading++;\n            HordeCore.doAction('getFreeBusy', att, {\n                callback: this.addResourceCallback.curry(resource).bind(this)\n            });\n            tr = new Element('tr');\n            this.freeBusy.set(resource, [ tr ]);\n            tr.insert(new Element('td')\n                .writeAttribute('title', resource)\n                .addClassName('kronolithAttendee' + response)\n                .insert(resource.escapeHTML()));\n            for (i = 0; i < 24; i++) {\n                tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));\n            }\n            $('kronolithEventResourcesList').down('tbody').insert(tr);\n            this.resourceACCache.map.set(resource, v);\n            $('kronolithEventResourceIds').value = this.resourceACCache.map.values();\n        } else {\n            HordeCore.notify(Kronolith.text.unknown_resource + ': ' + resource, 'horde.error');\n        }\n    },\n\n    removeResource: function(resource)\n    {\n        var row = this.freeBusy.get(resource)[0];\n        row.purge();\n        row.remove();\n        this.resourceACCache.map.unset(resource);\n        $('kronolithEventResourceIds').value = this.resourceACCache.map.values();\n    },\n\n    addResourceCallback: function(resource, r)\n    {\n        this.fbLoading--;\n        if (!this.fbLoading) {\n            $('kronolithResourceFBLoading').hide();\n        }\n        if (Object.isUndefined(r.fb)) {\n            return;\n        }\n        this.resources.push(resource);\n        this.freeBusy.get(resource)[1] = r.fb;\n        this.insertFreeBusy(resource);\n    },\n\n    /**\n     * Removes an attendee row from the free/busy table.\n     *\n     * @param string attendee  The display name of the attendee.\n     */\n    removeAttendee: function(attendee)\n    {\n        var row = this.freeBusy.get(attendee)[0];\n        row.purge();\n        row.remove();\n    },\n\n    normalizeAttendee: function(attendee)\n    {\n        var pattern = /:(.*);/;\n        var match = pattern.exec(attendee);\n        if (match) {\n           return match[1].split(',');\n        }\n        return [attendee];\n    },\n\n    checkOrganizerAsAttendee: function()\n    {\n        if (HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.length == 1 &&\n            HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.first().rawValue != Kronolith.conf.email) {\n            // Invite the organizer of this event to the new event.\n            HordeImple.AutoCompleter.kronolithEventAttendees.addNewItemNode(Kronolith.conf.email);\n            this.addAttendee(Kronolith.conf.email);\n        }\n    },\n\n    getFBDate: function ()\n    {\n        var startDate = $('kronolithFBDate').innerHTML.split(' ');\n        if (startDate.length > 1) {\n            startDate = startDate[1];\n        } else {\n            startDate = startDate[0];\n        }\n        return Date.parseExact(startDate, Kronolith.conf.date_format);\n    },\n\n    /**\n     * Updates rows with free/busy information in the attendees table.\n     *\n     * @param string attendee  An attendee display name as the free/busy\n     *                         identifier.\n     * @param date   start     An optinal start date for f/b info. If omitted,\n     *                         $('kronolithEventStartDate') is used.\n     */\n    insertFreeBusy: function(attendee, start)\n    {\n        if (!$('kronolithEventDialog').visible() ||\n            !this.freeBusy.get(attendee)) {\n            return;\n        }\n        var fb = this.freeBusy.get(attendee)[1],\n            tr = this.freeBusy.get(attendee)[0],\n            td = tr.select('td')[1],\n            div = td.down('div'), start;\n        if (!fb) {\n            return;\n        }\n\n        if (!td.getWidth()) {\n            this.insertFreeBusy.bind(this, attendee, start).defer();\n            return;\n        }\n\n        if (div) {\n            div.purge();\n            div.remove();\n        }\n        if (!start) {\n            start = Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format);\n        }\n        var end = start.clone().add(1).days(),\n            width = td.getWidth(),\n            fbs = this.parseDate(fb.s),\n            fbe = this.parseDate(fb.e);\n\n\n        if (start.isBefore(fbs) || end.isBefore(fbs) || start.isAfter(fbe)) {\n            return;\n        }\n\n        tr.select('td').each(function(td, i) {\n            if (i != 0) {\n                td.className = 'kronolithFBFree';\n            }\n            i++;\n        });\n        div = new Element('div').setStyle({ position: 'relative', height: td.offsetHeight + 'px' });\n        td.insert(div);\n        $H(fb.b).each(function(busy) {\n            var left, from = Date.parse(busy.key).addSeconds(1),\n            to = Date.parse(busy.value).addSeconds(1);\n            if (!end.isAfter(from) || to.isBefore(start)) {\n                return;\n            }\n            if (from.isBefore(start)) {\n                from = start.clone();\n            }\n            if (to.isAfter(end)) {\n                to = end.clone();\n            }\n            if (to.getHours() === 0 && to.getMinutes() === 0) {\n                to.add(-1).minutes();\n            }\n            left = from.getHours() + from.getMinutes() / 60;\n            div.insert(new Element('div', { className: 'kronolithFBBusy' }).setStyle({ zIndex: 1, top: 0, left: (left * width) + 'px', width: (((to.getHours() + to.getMinutes() / 60) - left) * width) + 'px' }));\n        });\n\n    },\n\n    fbStartDateOnChange: function()\n    {\n        if (!$F('kronolithEventStartDate')) {\n          this._checkDate($('kronolithEventStartDate'));\n          return;\n        }\n        this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));\n    },\n\n    /**\n     * @param Date start  The start date.\n     */\n    fbStartDateHandler: function(start)\n    {\n        this.updateFBDate(start);\n        this.resetFBRows();\n        // Need to check visisbility - multiple changes will break the display\n        // due to the use of .defer() in insertFreeBusy().\n        if ($('kronolithEventTabAttendees').visible()) {\n            this.attendeeStartDateHandler(start);\n        }\n        if ($('kronolithEventTabResources').visible()) {\n            this.resourceStartDateHandler(start);\n        }\n    },\n\n    attendeeStartDateHandler: function(start)\n    {\n        this.attendees.each(function(attendee) {\n            this.insertFreeBusy(attendee.l, start);\n        }, this);\n    },\n\n    resourceStartDateHandler: function(start)\n    {\n        this.resources.each(function(resource) {\n            this.insertFreeBusy(resource, start);\n        }, this);\n    },\n\n    nextFreebusy: function()\n    {\n        this.fbStartDateHandler(this.getFBDate().addDays(1));\n    },\n\n    prevFreebusy: function()\n    {\n        this.fbStartDateHandler(this.getFBDate().addDays(-1));\n    },\n\n    /**\n     * @start Date object\n     */\n    updateFBDate: function(start)\n    {\n        $('kronolithFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));\n        $('kronolithResourceFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));\n    },\n\n    /**\n     * Toggles the start and end time fields of the event edit form on and off.\n     *\n     * @param boolean on  Whether the event is an all-day event, i.e. the time\n     *                    fields should be turned off. If not specified, the\n     *                    current state is toggled.\n     */\n    toggleAllDay: function(on)\n    {\n        var end = this.getDate('end'),\n            old = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'hidden';\n        if (Object.isUndefined(on)) {\n            on = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'visible';\n        }\n        if (end) {\n            if (on) {\n                if (end.getHours() == 0 && end.getMinutes() == 0) {\n                    end.add(-1).minute();\n                }\n            } else if (old) {\n                end.setHours(23);\n                end.setMinutes(59);\n            }\n            $('kronolithEventEndDate').setValue(end.toString(Kronolith.conf.date_format));\n            $('kronolithEventEndTime').setValue(end.toString(Kronolith.conf.time_format));\n        }\n        $('kronolithEventStartTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });\n        $('kronolithEventEndTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });\n    },\n\n    /**\n     * Enables the alarm in the event or task form and sets the correct value\n     * and unit.\n     *\n     * @param string type    The object type, either 'Event' or 'Task'.\n     * @param integer alarm  The alarm time in seconds.\n     */\n    enableAlarm: function(type, alarm) {\n        if (!alarm) {\n            return;\n        }\n        type = 'kronolith' + type + 'Alarm';\n        $(type + 'On').setValue(true);\n        [10080, 1440, 60, 1].each(function(unit) {\n            if (alarm % unit === 0) {\n                $(type + 'Value').setValue(alarm / unit);\n                $(type + 'Unit').setValue(unit);\n                throw $break;\n            }\n        });\n    },\n\n    /**\n     * Disables all custom alarm methods in the event form.\n     */\n    disableAlarmMethods: function(type) {\n        $('kronolith' + type + 'TabReminder').select('input').each(function(input) {\n            if (input.name == (type == 'Event' ? 'event_alarms[]' : 'task[alarm_methods][]')) {\n                input.setValue(0);\n                if ($(input.id + 'Params')) {\n                    $(input.id + 'Params').hide();\n                }\n            }\n        });\n    },\n\n    /**\n     * Toggles the recurrence fields of the event and task edit forms.\n     *\n     * @param boolean event  Whether to use the event form.\n     * @param string recur   The recurrence part of the field name, i.e. 'None',\n     *                       'Daily', etc.\n     */\n    toggleRecurrence: function(event, recur)\n    {\n        var prefix = 'kronolith' + (event ? 'Event' : 'Task');\n        if (recur == 'Exception') {\n            if (!$(prefix + 'RepeatException').visible()) {\n                $(prefix + 'TabRecur').select('div').invoke('hide');\n                $(prefix + 'RepeatException').show();\n            }\n        } else if (recur != 'None') {\n            var div = $(prefix + 'Repeat' + recur),\n                length = $(prefix + 'RepeatLength');\n            this.lastRecurType = recur;\n            if (!div.visible()) {\n                $(prefix + 'TabRecur').select('div').invoke('hide');\n                div.show();\n                length.show();\n                $(prefix + 'RepeatType').show();\n            }\n            switch (recur) {\n            case 'Daily':\n            case 'Weekly':\n            case 'Monthly':\n            case 'Yearly':\n                var recurLower = recur.toLowerCase();\n                if (div.down('input[name=recur_' + recurLower + '][value=1]').checked) {\n                    div.down('input[name=recur_' + recurLower + '_interval]').disable();\n                } else {\n                    div.down('input[name=recur_' + recurLower + '_interval]').enable();\n                }\n                break;\n            }\n\n            if (length.down('input[name=recur_end_type][value=date]').checked) {\n                $(prefix + 'RecurDate').enable();\n                $(prefix + 'RecurPicker').setStyle({ visibility: 'visible' });\n            } else {\n                $(prefix + 'RecurDate').disable();\n                $(prefix + 'RecurPicker').setStyle({ visibility: 'hidden' });\n            }\n            if (length.down('input[name=recur_end_type][value=count]').checked) {\n                $(prefix + 'RecurCount').enable();\n            } else {\n                $(prefix + 'RecurCount').disable();\n            }\n        } else {\n            $(prefix + 'TabRecur').select('div').invoke('hide');\n            $(prefix + 'RepeatType').show();\n        }\n    },\n\n    /**\n     * Fills the recurrence fields of the event and task edit forms.\n     *\n     * @param boolean event  Whether to use the event form.\n     * @param object recur   The recurrence object from the ajax response.\n     */\n    setRecurrenceFields: function(event, recur)\n    {\n        var scheme = Kronolith.conf.recur[recur.t],\n            schemeLower = scheme.toLowerCase(),\n            prefix = 'kronolith' + (event ? 'Event' : 'Task'),\n            div = $(prefix + 'Repeat' + scheme);\n        $(prefix + 'Link' + scheme).setValue(true);\n        if (scheme == 'Monthly' || scheme == 'Yearly') {\n            div.down('input[name=recur_' + schemeLower + '_scheme][value=' + recur.t + ']').setValue(true);\n        }\n        if (scheme == 'Weekly') {\n            div.select('input[type=checkbox]').each(function(input) {\n                if (input.name == 'weekly[]' &&\n                    input.value & recur.d) {\n                    input.setValue(true);\n                }\n            });\n        }\n        if (recur.i == 1) {\n            div.down('input[name=recur_' + schemeLower + '][value=1]').setValue(true);\n        } else {\n            div.down('input[name=recur_' + schemeLower + '][value=0]').setValue(true);\n            div.down('input[name=recur_' + schemeLower + '_interval]').setValue(recur.i);\n        }\n        if (!Object.isUndefined(recur.e)) {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=date]').setValue(true);\n            $(prefix + 'RecurDate').setValue(Date.parse(recur.e).toString(Kronolith.conf.date_format));\n        } else if (!Object.isUndefined(recur.c)) {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=count]').setValue(true);\n            $(prefix + 'RecurCount').setValue(recur.c);\n        } else {\n            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=none]').setValue(true);\n        }\n        $(prefix + 'Exceptions').setValue(recur.ex || '');\n        if ($(prefix + 'Completions')) {\n            $(prefix + 'Completions').setValue(recur.co || '');\n        }\n        this.toggleRecurrence(event, scheme);\n    },\n\n    /**\n     * Returns the Date object representing the date and time specified in the\n     * event form's start or end fields.\n     *\n     * @param string what  Which fields to parse, either 'start' or 'end'.\n     *\n     * @return Date  The date object or null if the fields can't be parsed.\n     */\n    getDate: function(what) {\n        var dateElm, timeElm, date, time;\n        if (what == 'start') {\n            dateElm = 'kronolithEventStartDate';\n            timeElm = 'kronolithEventStartTime';\n        } else {\n            dateElm = 'kronolithEventEndDate';\n            timeElm = 'kronolithEventEndTime';\n        }\n        date = Date.parseExact($F(dateElm), Kronolith.conf.date_format)\n            || Date.parse($F(dateElm));\n        if (date) {\n            time = Date.parseExact($F(timeElm), Kronolith.conf.time_format);\n            if (!time) {\n                time = Date.parse($F(timeElm));\n            }\n            if (time) {\n                date.setHours(time.getHours());\n                date.setMinutes(time.getMinutes());\n            }\n        }\n        return date;\n    },\n\n    checkDate: function(e) {\n        this._checkDate(e.element());\n    },\n\n    _checkDate: function(elm)\n    {\n        if ($F(elm)) {\n            var date = Date.parseExact($F(elm), Kronolith.conf.date_format) || Date.parse($F(elm));\n            if (date) {\n                elm.setValue(date.toString(Kronolith.conf.date_format));\n                this.wrongFormat.unset(elm.id);\n            } else {\n                HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');\n                this.wrongFormat.set(elm.id, true);\n            }\n        } else {\n            HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');\n            this.wrongFormat.set(elm.id, true);\n        }\n    },\n\n    /**\n     * Attaches a KeyNavList drop down to one of the time fields.\n     *\n     * @param string|Element field  A time field (id).\n     *\n     * @return KeyNavList  The drop down list object.\n     */\n    attachTimeDropDown: function(field)\n    {\n        var list = [], d = new Date(), time, opts;\n\n        d.setHours(0);\n        d.setMinutes(0);\n        do {\n            time = d.toString(Kronolith.conf.time_format);\n            list.push({ l: time, v: time });\n            d.add(30).minutes();\n        } while (d.getHours() !== 0 || d.getMinutes() !== 0);\n\n        field = $(field);\n        opts = {\n            list: list,\n            domParent: field.up('.kronolithDialog'),\n            onChoose: function(value) {\n                if (value) {\n                    field.setValue(value);\n                }\n                this.updateTimeFields(field.identify());\n            }.bind(this)\n        };\n\n        this.knl[field.id] = new KeyNavList(field, opts);\n\n        return this.knl[field.id];\n    },\n\n    checkTime: function(e) {\n        var elm = e.element();\n        if ($F(elm)) {\n            var time = Date.parseExact(new Date().toString(Kronolith.conf.date_format) + ' ' + $F(elm), Kronolith.conf.date_format + ' ' + Kronolith.conf.time_format) || Date.parse(new Date().toString('yyyy-MM-dd ') + $F(elm));\n            if (time) {\n                elm.setValue(time.toString(Kronolith.conf.time_format));\n                this.wrongFormat.unset(elm.id);\n            } else {\n                HordeCore.notify(Kronolith.text.wrong_time_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.time_format) }), 'horde.warning');\n                this.wrongFormat.set(elm.id, true);\n            }\n        }\n    },\n\n    /**\n     * Updates the start time in the event form after changing the end time.\n     */\n    updateStartTime: function(date) {\n        var start = this.getDate('start'), end = this.getDate('end');\n        if (!start) {\n            return;\n        }\n        if (!date) {\n            date = end;\n        }\n        if (!date) {\n            return;\n        }\n        if (start.isAfter(end)) {\n            $('kronolithEventStartDate').setValue(date.toString(Kronolith.conf.date_format));\n            $('kronolithEventStartTime').setValue($F('kronolithEventEndTime'));\n        }\n        this.duration = Math.abs(date.getTime() - start.getTime()) / 60000;\n    },\n\n    /**\n     * Updates the end time in the event form after changing the start time.\n     */\n    updateEndTime: function() {\n        var date = this.getDate('start');\n        if (!date) {\n            return;\n        }\n        date.add(this.duration).minutes();\n        $('kronolithEventEndDate').setValue(date.toString(Kronolith.conf.date_format));\n        $('kronolithEventEndTime').setValue(date.toString(Kronolith.conf.time_format));\n    },\n\n    /**\n     * Event handler for scrolling the mouse over the date field.\n     *\n     * @param Event e       The mouse event.\n     * @param string field  The field name.\n     */\n    scrollDateField: function(e, field) {\n        var date = Date.parseExact($F(field), Kronolith.conf.date_format);\n        if (!date || (!e.wheelData && !e.detail)) {\n            return;\n        }\n        date.add(e.wheelData > 0 || e.detail < 0 ? 1 : -1).days();\n        $(field).setValue(date.toString(Kronolith.conf.date_format));\n        switch (field) {\n        case 'kronolithEventStartDate':\n            this.updateEndTime();\n            break;\n        case 'kronolithEventEndDate':\n            this.updateStartTime(date);\n            break;\n        }\n    },\n\n    /**\n     * Event handler for scrolling the mouse over the time field.\n     *\n     * @param Event e       The mouse event.\n     * @param string field  The field name.\n     */\n    scrollTimeField: function(e, field) {\n        var time = Date.parseExact($F(field), Kronolith.conf.time_format) || Date.parse($F(field)),\n            newTime, minute;\n        if (!time || (!e.wheelData && !e.detail)) {\n            return;\n        }\n\n        newTime = time.clone();\n        newTime.add(e.wheelData > 0 || e.detail < 0 ? 10 : -10).minutes();\n        minute = newTime.getMinutes();\n        if (minute % 10) {\n            if (e.wheelData > 0 || e.detail < 0) {\n                minute = minute / 10 | 0;\n            } else {\n                minute = (minute - 10) / 10 | 0;\n            }\n            minute *= 10;\n            newTime.setMinutes(minute);\n        }\n        if (newTime.getDate() != time.getDate()) {\n            if (newTime.isAfter(time)) {\n                newTime = time.clone().set({ hour: 23, minute: 59 });\n            } else {\n                newTime = time.clone().set({ hour: 0, minute: 0 });\n            }\n        }\n\n        $(field).setValue(newTime.toString(Kronolith.conf.time_format));\n        this.updateTimeFields(field);\n\n        /* Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=502818\n         * Need to stop or else multiple scroll events may be fired. We\n         * lose the ability to have the mousescroll bubble up, but that is\n         * more desirable than having the wrong scrolling behavior. */\n        if (Prototype.Browser.Gecko && !e.stop) {\n            Event.stop(e);\n        }\n    },\n\n    /**\n     * Updates the time fields of the event dialog after either has been\n     * changed.\n     *\n     * @param string field  The id of the field that has been changed.\n     */\n    updateTimeFields: function(field)\n    {\n        switch (field) {\n        case 'kronolithEventStartDate':\n            this.fbStartDateHandler(Date.parseExact($F(field), Kronolith.conf.date_format));\n        case 'kronolithEventStartTime':\n            this.updateEndTime();\n            break;\n        case 'kronolithEventEndDate':\n        case 'kronolithEventEndTime':\n            this.updateStartTime();\n            this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));\n            break;\n        }\n    },\n\n    /**\n     * Closes a RedBox overlay, after saving its content to the body.\n     */\n    closeRedBox: function()\n    {\n        if (!RedBox.getWindow()) {\n            return;\n        }\n        var content = RedBox.getWindowContents();\n        if (content) {\n            document.body.insert(content.hide());\n        }\n        RedBox.close();\n    },\n\n    // By default, no context onShow action\n    contextOnShow: Prototype.emptyFunction,\n\n    // By default, no context onClick action\n    contextOnClick: Prototype.emptyFunction,\n\n    // Map\n    initializeMap: function(ignoreLL)\n    {\n        if (this.mapInitialized) {\n            return;\n        }\n        var layers = [];\n        if (Kronolith.conf.maps.providers) {\n            Kronolith.conf.maps.providers.each(function(l) {\n                var p = new HordeMap[l]();\n                $H(p.getLayers()).values().each(function(e) {layers.push(e);});\n            });\n        }\n\n        this.map = new HordeMap.Map[Kronolith.conf.maps.driver]({\n            elt: 'kronolithEventMap',\n            delayed: true,\n            layers: layers,\n            markerDragEnd: this.onMarkerDragEnd.bind(this),\n            mapClick: this.afterClickMap.bind(this)\n        });\n\n        if ($('kronolithEventLocationLat').value && !ignoreLL) {\n            var ll = { lat:$('kronolithEventLocationLat').value, lon: $('kronolithEventLocationLon').value };\n            // Note that we need to cast the value of zoom to an integer here,\n            // otherwise the map display breaks.\n            this.placeMapMarker(ll, true, $('kronolithEventMapZoom').value - 0);\n        }\n        //@TODO: check for Location field - and if present, but no lat/lon value, attempt to\n        // geocode it.\n        this.map.display();\n        this.mapInitialized = true;\n    },\n\n    resetMap: function()\n    {\n        this.mapInitialized = false;\n        $('kronolithEventLocationLat').value = null;\n        $('kronolithEventLocationLon').value = null;\n        $('kronolithEventMapZoom').value = null;\n        if (this.mapMarker) {\n            this.map.removeMarker(this.mapMarker, {});\n            this.mapMarker = null;\n        }\n        if (this.map) {\n            this.map.destroy();\n            this.map = null;\n        }\n    },\n\n    /**\n     * Callback for handling marker drag end.\n     *\n     * @param object r  An object that implenents a getLonLat() method to obtain\n     *                  the new location of the marker.\n     */\n    onMarkerDragEnd: function(r)\n    {\n        var ll = r.getLonLat();\n        $('kronolithEventLocationLon').value = ll.lon;\n        $('kronolithEventLocationLat').value = ll.lat;\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.reverseGeocode(ll, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );\n    },\n\n    /**\n     * Callback for handling a reverse geocode request.\n     *\n     * @param array r  An array of objects containing the results. Each object in\n     *                 the array is {lat:, lon:, address}\n     */\n    onReverseGeocode: function(r)\n    {\n        if (!r.length) {\n            return;\n        }\n        $('kronolithEventLocation').value = r[0].address;\n    },\n\n    onGeocodeError: function(r)\n    {\n        $('kronolithEventGeo_loading_img').toggle();\n        HordeCore.notify(Kronolith.text.geocode_error + ' ' + r, 'horde.error');\n    },\n\n    /**\n     * Callback for geocoding calls.\n     */\n    onGeocode: function(r)\n    {\n        $('kronolithEventGeo_loading_img').toggle();\n        r = r.shift();\n        if (r.precision) {\n            zoom = r.precision * 2;\n        } else {\n            zoom = null;\n        }\n        this.ensureMap(true);\n        this.placeMapMarker({ lat: r.lat, lon: r.lon }, true, zoom);\n    },\n\n    geocode: function(a) {\n        if (!a) {\n            return;\n        }\n        $('kronolithEventGeo_loading_img').toggle();\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.geocode(a, this.onGeocode.bind(this), this.onGeocodeError);\n    },\n\n    /**\n     * Place the event marker on the map, at point ll, ensuring it exists.\n     * Optionally center the map on the marker and zoom. Zoom only honored if\n     * center is set, and if center is set, but zoom is null, we zoomToFit().\n     *\n     */\n    placeMapMarker: function(ll, center, zoom)\n    {\n        if (!this.mapMarker) {\n            this.mapMarker = this.map.addMarker(\n                    ll,\n                    { draggable: true },\n                    {\n                        context: this,\n                        dragend: this.onMarkerDragEnd\n                    });\n        } else {\n            this.map.moveMarker(this.mapMarker, ll);\n        }\n\n        if (center) {\n            this.map.setCenter(ll, zoom);\n            if (!zoom) {\n                this.map.zoomToFit();\n            }\n        }\n        $('kronolithEventLocationLon').value = ll.lon;\n        $('kronolithEventLocationLat').value = ll.lat;\n    },\n\n    /**\n     * Remove the event marker from the map. Called after clearing the location\n     * field.\n     */\n    removeMapMarker: function()\n    {\n        if (this.mapMarker) {\n            this.map.removeMarker(this.mapMarker, {});\n            $('kronolithEventLocationLon').value = null;\n            $('kronolithEventLocationLat').value = null;\n        }\n\n        this.mapMarker = false;\n    },\n\n    /**\n     * Ensures the map tab is visible and sets UI elements accordingly.\n     */\n    ensureMap: function(ignoreLL)\n    {\n        if (!this.mapInitialized) {\n            this.initializeMap(ignoreLL);\n        }\n        var dialog = $('kronolithEventForm');\n        dialog.select('.kronolithTabsOption').invoke('hide');\n        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');\n        $('kronolithEventTabMap').show();\n        $('kronolithEventLinkMap').up().addClassName('horde-active');\n    },\n\n    /**\n     * Callback that gets called after a new marker has been placed on the map\n     * due to a single click on the map.\n     *\n     * @return object o  { lonlat: }\n     */\n    afterClickMap: function(o)\n    {\n        this.placeMapMarker(o.lonlat, false);\n        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');\n        gc.reverseGeocode(o.lonlat, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );\n    },\n\n    /* Onload function. */\n    onDomLoad: function()\n    {\n        var dateFields, timeFields;\n\n        /* Initialize the starting page. */\n        var tmp = location.hash;\n        if (!tmp.empty() && tmp.startsWith('#')) {\n            tmp = (tmp.length == 1) ? '' : tmp.substring(1);\n        }\n        if (tmp.empty()) {\n            this.updateView(this.date, Kronolith.conf.login_view);\n            $('kronolithView' + Kronolith.conf.login_view.capitalize()).show();\n        }\n        HordeCore.doAction('listCalendars', {}, { callback: this.initialize.bind(this, tmp) });\n\n        RedBox.onDisplay = function() {\n            this.redBoxLoading = false;\n        }.bind(this);\n        RedBox.duration = this.effectDur;\n\n        $('kronolithEventStartDate', 'kronolithEventEndDate', 'kronolithTaskDueDate').compact().invoke('observe', 'blur', this.checkDate.bind(this));\n        var timeFields = $('kronolithEventStartTime', 'kronolithEventEndTime', 'kronolithTaskDueTime').compact();\n        timeFields.invoke('observe', 'blur', this.checkTime.bind(this));\n        timeFields.each(function(field) {\n            var dropDown = this.attachTimeDropDown(field);\n            field.observe('click', function() { dropDown.show(); });\n        }, this);\n        $('kronolithEventStartDate', 'kronolithEventStartTime').invoke('observe', 'change', this.updateEndTime.bind(this));\n        $('kronolithEventEndDate', 'kronolithEventEndTime').invoke('observe', 'change', function() { this.updateStartTime(); }.bind(this));\n\n        if (Kronolith.conf.has_tasks) {\n            $('kronolithTaskDueDate', 'kronolithTaskDueTime').compact().invoke('observe', 'focus', this.setDefaultDue.bind(this));\n            $('kronolithTaskList').observe('change', function() {\n                this.updateTaskParentDropDown($F('kronolithTaskList'));\n                this.updateTaskAssigneeDropDown($F('kronolithTaskList'));\n            }.bind(this));\n        }\n\n        document.observe('keydown', KronolithCore.keydownHandler.bindAsEventListener(KronolithCore));\n        document.observe('keyup', KronolithCore.keyupHandler.bindAsEventListener(KronolithCore));\n        document.observe('click', KronolithCore.clickHandler.bindAsEventListener(KronolithCore));\n        document.observe('dblclick', KronolithCore.clickHandler.bindAsEventListener(KronolithCore, true));\n\n        // Mouse wheel handler.\n        dateFields = [ 'kronolithEventStartDate', 'kronolithEventEndDate' ];\n        timeFields = [ 'kronolithEventStartTime', 'kronolithEventEndTime' ];\n        if (Kronolith.conf.has_tasks) {\n            dateFields.push('kronolithTaskDueDate');\n            timeFields.push('kronolithTaskDueTime');\n        }\n        dateFields.each(function(field) {\n            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollDateField.bindAsEventListener(this, field));\n        }, this);\n        timeFields.each(function(field) {\n            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollTimeField.bindAsEventListener(this, field));\n        }, this);\n\n        $('kronolithEventStartDate').observe('change', this.fbStartDateOnChange.bind(this));\n        $('kronolithFBDatePrev').observe('click', this.prevFreebusy.bind(this));\n        $('kronolithFBDateNext').observe('click', this.nextFreebusy.bind(this));\n        $('kronolithResourceFBDatePrev').observe('click', this.prevFreebusy.bind(this));\n        $('kronolithResourceFBDateNext').observe('click', this.nextFreebusy.bind(this));\n\n        this.updateMinical(this.date);\n    },\n\n    initialize: function(location, r)\n    {\n        Kronolith.conf.calendars = r.calendars;\n        this.updateCalendarList();\n        HordeSidebar.refreshEvents();\n        $('kronolithLoadingCalendars').hide();\n        $('kronolithMenuCalendars').show();\n        this.initialized = true;\n\n        /* Initialize the starting page. */\n        if (!location.empty()) {\n            this.go(decodeURIComponent(location));\n        } else {\n            this.go(Kronolith.conf.login_view);\n        }\n\n        /* Start polling. */\n        new PeriodicalExecuter(function()\n            {\n                HordeCore.doAction('poll');\n                $(kronolithGotoToday).update(Date.today().toString(Kronolith.conf.date_format));\n            },\n            60\n        );\n    }\n\n};\n\n/* Initialize global event handlers. */\ndocument.observe('dom:loaded', KronolithCore.onDomLoad.bind(KronolithCore));\ndocument.observe('DragDrop2:drag', KronolithCore.onDrag.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:drop', KronolithCore.onDrop.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:end', KronolithCore.onDragEnd.bindAsEventListener(KronolithCore));\ndocument.observe('DragDrop2:start', KronolithCore.onDragStart.bindAsEventListener(KronolithCore));\ndocument.observe('Horde_Calendar:select', KronolithCore.datePickerHandler.bindAsEventListener(KronolithCore));\ndocument.observe('FormGhost:reset', KronolithCore.searchReset.bindAsEventListener(KronolithCore));\ndocument.observe('FormGhost:submit', KronolithCore.searchSubmit.bindAsEventListener(KronolithCore));\ndocument.observe('HordeCore:showNotifications', KronolithCore.showNotification.bindAsEventListener(KronolithCore));\nif (Prototype.Browser.IE) {\n    $('kronolithBody').observe('selectstart', Event.stop);\n}\n\n/* Extend AJAX exception handling. */\nHordeCore.onException = HordeCore.onException.wrap(KronolithCore.onException.bind(KronolithCore));\n"], "filenames": ["js/kronolith.js"], "buggy_code_start_loc": [3325], "buggy_code_end_loc": [3326], "fixing_code_start_loc": [3325], "fixing_code_end_loc": [3326], "type": "CWE-79", "message": "In Horde Groupware 5.2.19, there is XSS via the Name field during creation of a new Resource. This can be leveraged for remote code execution after compromising an administrator account, because the CVE-2015-7984 CSRF protection mechanism can then be bypassed.", "other": {"cve": {"id": "CVE-2017-16908", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-20T20:29:00.480", "lastModified": "2020-08-29T22:15:13.423", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Horde Groupware 5.2.19, there is XSS via the Name field during creation of a new Resource. This can be leveraged for remote code execution after compromising an administrator account, because the CVE-2015-7984 CSRF protection mechanism can then be bypassed."}, {"lang": "es", "value": "En Horde Groupware 5.2.19, existe XSS mediante el campo Name durante la creaci\u00f3n de un nuevo recurso. Esto puede aprovecharse para ejecutar c\u00f3digo de forma remota tras comprometer una cuenta de administrador, ya que se puede omitir el mecanismo de protecci\u00f3n CSRF relacionado con CVE-2015-7984."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:horde:groupware:5.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "E509D906-4D06-4404-B420-523CE6313855"}]}]}], "references": [{"url": "http://code610.blogspot.com/2017/11/rce-via-xss-horde-5219.html", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/horde/kronolith/commit/39f740068ad21618f6f70b6e37855c61cadbd716", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00048.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/horde/kronolith/commit/39f740068ad21618f6f70b6e37855c61cadbd716"}}