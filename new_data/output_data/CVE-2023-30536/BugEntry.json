{"buggy_code": ["<?php\n\n/**\n * Slim Framework (https://slimframework.com)\n *\n * @license https://github.com/slimphp/Slim-Psr7/blob/master/LICENSE.md (MIT License)\n */\n\ndeclare(strict_types=1);\n\nnamespace Slim\\Psr7;\n\nuse InvalidArgumentException;\nuse Slim\\Psr7\\Interfaces\\HeadersInterface;\n\nuse function base64_encode;\nuse function function_exists;\nuse function getallheaders;\nuse function is_array;\nuse function is_numeric;\nuse function is_string;\nuse function preg_match;\nuse function strpos;\nuse function strtolower;\nuse function strtr;\nuse function substr;\nuse function trim;\n\nclass Headers implements HeadersInterface\n{\n    protected array $globals;\n\n    /**\n     * @var Header[]\n     */\n    protected array $headers;\n\n    /**\n     * @param array      $headers\n     * @param array|null $globals\n     */\n    final public function __construct(array $headers = [], ?array $globals = null)\n    {\n        $this->globals = $globals ?? $_SERVER;\n        $this->setHeaders($headers);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function addHeader($name, $value): HeadersInterface\n    {\n        [$values, $originalName, $normalizedName] = $this->prepareHeader($name, $value);\n\n        if (isset($this->headers[$normalizedName])) {\n            $header = $this->headers[$normalizedName];\n            $header->addValues($values);\n        } else {\n            $this->headers[$normalizedName] = new Header($originalName, $normalizedName, $values);\n        }\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function removeHeader(string $name): HeadersInterface\n    {\n        $name = $this->normalizeHeaderName($name);\n        unset($this->headers[$name]);\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getHeader(string $name, $default = []): array\n    {\n        $name = $this->normalizeHeaderName($name);\n\n        if (isset($this->headers[$name])) {\n            $header = $this->headers[$name];\n            return $header->getValues();\n        }\n\n        if (empty($default)) {\n            return $default;\n        }\n\n        $this->validateHeader($name, $default);\n        return $this->trimHeaderValue($default);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setHeader($name, $value): HeadersInterface\n    {\n        [$values, $originalName, $normalizedName] = $this->prepareHeader($name, $value);\n\n        // Ensure we preserve original case if the header already exists in the stack\n        if (isset($this->headers[$normalizedName])) {\n            $existingHeader = $this->headers[$normalizedName];\n            $originalName = $existingHeader->getOriginalName();\n        }\n\n        $this->headers[$normalizedName] = new Header($originalName, $normalizedName, $values);\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setHeaders(array $headers): HeadersInterface\n    {\n        $this->headers = [];\n\n        foreach ($this->parseAuthorizationHeader($headers) as $name => $value) {\n            $this->addHeader($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function hasHeader(string $name): bool\n    {\n        $name = $this->normalizeHeaderName($name);\n        return isset($this->headers[$name]);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getHeaders(bool $originalCase = false): array\n    {\n        $headers = [];\n\n        foreach ($this->headers as $header) {\n            $name = $originalCase ? $header->getOriginalName() : $header->getNormalizedName();\n            $headers[$name] = $header->getValues();\n        }\n\n        return $headers;\n    }\n\n    /**\n     * @param string $name\n     * @param bool   $preserveCase\n     * @return string\n     */\n    protected function normalizeHeaderName(string $name, bool $preserveCase = false): string\n    {\n        $name = strtr($name, '_', '-');\n\n        if (!$preserveCase) {\n            $name = strtolower($name);\n        }\n\n        if (strpos(strtolower($name), 'http-') === 0) {\n            $name = substr($name, 5);\n        }\n\n        return $name;\n    }\n\n    /**\n     * Parse incoming headers and determine Authorization header from original headers\n     *\n     * @param array $headers\n     * @return array\n     */\n    protected function parseAuthorizationHeader(array $headers): array\n    {\n        $hasAuthorizationHeader = false;\n        foreach ($headers as $name => $value) {\n            if (strtolower((string) $name) === 'authorization') {\n                $hasAuthorizationHeader = true;\n                break;\n            }\n        }\n\n        if (!$hasAuthorizationHeader) {\n            if (isset($this->globals['REDIRECT_HTTP_AUTHORIZATION'])) {\n                $headers['Authorization'] = $this->globals['REDIRECT_HTTP_AUTHORIZATION'];\n            } elseif (isset($this->globals['PHP_AUTH_USER'])) {\n                $pw = $this->globals['PHP_AUTH_PW'] ?? '';\n                $headers['Authorization'] = 'Basic ' . base64_encode($this->globals['PHP_AUTH_USER'] . ':' . $pw);\n            } elseif (isset($this->globals['PHP_AUTH_DIGEST'])) {\n                $headers['Authorization'] = $this->globals['PHP_AUTH_DIGEST'];\n            }\n        }\n\n        return $headers;\n    }\n\n    /**\n     * @param array|string $value\n     *\n     * @return array\n     */\n    protected function trimHeaderValue($value): array\n    {\n        $items = is_array($value) ? $value : [$value];\n        $result = [];\n        foreach ($items as $item) {\n            $result[] = trim((string) $item, \" \\t\");\n        }\n        return $result;\n    }\n\n    /**\n     * @param string       $name\n     * @param array|string $value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function prepareHeader($name, $value): array\n    {\n        $this->validateHeader($name, $value);\n        $values = $this->trimHeaderValue($value);\n        $originalName = $this->normalizeHeaderName($name, true);\n        $normalizedName = $this->normalizeHeaderName($name);\n        return [$values, $originalName, $normalizedName];\n    }\n\n    /**\n     * Make sure the header complies with RFC 7230.\n     *\n     * Header names must be a non-empty string consisting of token characters.\n     *\n     * Header values must be strings consisting of visible characters with all optional\n     * leading and trailing whitespace stripped. This method will always strip such\n     * optional whitespace. Note that the method does not allow folding whitespace within\n     * the values as this was deprecated for almost all instances by the RFC.\n     *\n     * header-field = field-name \":\" OWS field-value OWS\n     * field-name   = 1*( \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\"\n     *              / \"_\" / \"`\" / \"|\" / \"~\" / %x30-39 / ( %x41-5A / %x61-7A ) )\n     * OWS          = *( SP / HTAB )\n     * field-value  = *( ( %x21-7E / %x80-FF ) [ 1*( SP / HTAB ) ( %x21-7E / %x80-FF ) ] )\n     *\n     * @see https://tools.ietf.org/html/rfc7230#section-3.2.4\n     *\n     * @param string        $name\n     * @param array|string  $value\n     *\n     * @throws InvalidArgumentException;\n     */\n    protected function validateHeader($name, $value): void\n    {\n        $this->validateHeaderName($name);\n        $this->validateHeaderValue($value);\n    }\n\n    /**\n     * @param mixed $name\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateHeaderName($name): void\n    {\n        if (!is_string($name) || preg_match(\"@^[!#$%&'*+.^_`|~0-9A-Za-z-]+$@\", $name) !== 1) {\n            throw new InvalidArgumentException('Header name must be an RFC 7230 compatible string.');\n        }\n    }\n\n    /**\n     * @param mixed $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateHeaderValue($value): void\n    {\n        $items = is_array($value) ? $value : [$value];\n\n        if (empty($items)) {\n            throw new InvalidArgumentException(\n                'Header values must be a string or an array of strings, empty array given.'\n            );\n        }\n\n        $pattern = \"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@\";\n        foreach ($items as $item) {\n            $hasInvalidType = !is_numeric($item) && !is_string($item);\n            $rejected = $hasInvalidType || preg_match($pattern, (string) $item) !== 1;\n            if ($rejected) {\n                throw new InvalidArgumentException(\n                    'Header values must be RFC 7230 compatible strings.'\n                );\n            }\n        }\n    }\n\n    /**\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        $headers = null;\n\n        if (function_exists('getallheaders')) {\n            $headers = getallheaders();\n        }\n\n        if (!is_array($headers)) {\n            $headers = [];\n        }\n\n        return new static($headers);\n    }\n}\n", "<?php\n\n/**\n * Slim Framework (https://slimframework.com)\n *\n * @license https://github.com/slimphp/Slim-Psr7/blob/master/LICENSE.md (MIT License)\n */\n\ndeclare(strict_types=1);\n\nnamespace Slim\\Tests\\Psr7;\n\nuse InvalidArgumentException;\nuse PHPUnit\\Framework\\TestCase;\nuse Slim\\Psr7\\Headers;\nuse stdClass;\n\nuse function base64_encode;\n\nclass HeadersTest extends TestCase\n{\n    public function testCreateFromGlobals()\n    {\n        $GLOBALS['getallheaders_return'] = [\n            'HTTP_ACCEPT' => 'application/json',\n        ];\n\n        $headers = Headers::createFromGlobals();\n\n        unset($GLOBALS['getallheaders_return']);\n\n        $this->assertEquals(['accept' => ['application/json']], $headers->getHeaders());\n        $this->assertEquals(['ACCEPT' => ['application/json']], $headers->getHeaders(true));\n    }\n\n    public function testCreateFromGlobalsUsesEmptyArrayIfGetAllHeadersReturnsFalse()\n    {\n        $GLOBALS['getallheaders_return'] = false;\n\n        $headers = Headers::createFromGlobals();\n\n        unset($GLOBALS['getallheaders_return']);\n\n        $this->assertEquals([], $headers->getHeaders());\n    }\n\n    public function testAddHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $headers->addHeader('Accept', 'text/html');\n\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('Accept'));\n        $this->assertEquals(['accept' => ['application/json', 'text/html']], $headers->getHeaders());\n        $this->assertEquals(['Accept' => ['application/json', 'text/html']], $headers->getHeaders(true));\n    }\n\n    public function testAddHeaderValueEmptyArray()\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        $headers = new Headers();\n        $headers->addHeader('Header', []);\n    }\n\n    public function testRemoveHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $headers->removeHeader('Accept');\n\n        $this->assertEquals([], $headers->getHeader('Accept'));\n        $this->assertEquals([], $headers->getHeaders());\n    }\n\n    /**\n     * @doesNotPerformAssertions\n     */\n    public function testRemoveHeaderByIncompatibleStringWithRFC()\n    {\n        $headers = new Headers();\n        $headers->removeHeader('<incompatible with RFC>');\n    }\n\n    public function testGetHeader()\n    {\n        $headers = new Headers([\n            'Accept' => ['application/json', 'text/html'],\n        ]);\n\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('accept'));\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('Accept'));\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('HTTP_ACCEPT'));\n    }\n\n    public function testGetHeaderReturnsValidatedAndTrimedHeaderDefaultValue()\n    {\n        $headers = new Headers([]);\n\n        $this->assertEquals(['application/json'], $headers->getHeader('accept', ' application/json'));\n    }\n\n    public function testGetHeaderThrowsExceptionWithInvalidDefaultArgument()\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        $headers = new Headers([]);\n\n        $headers->getHeader('accept', new stdClass());\n    }\n\n    public function testSetHeader()\n    {\n        $headers = new Headers([\n            'Content-Length' => 0,\n        ]);\n\n        $headers->setHeader('Content-Length', 100);\n\n        $this->assertSame(['100'], $headers->getHeader('Content-Length'));\n        $this->assertEquals(['content-length' => ['100']], $headers->getHeaders());\n        $this->assertEquals(['Content-Length' => ['100']], $headers->getHeaders(true));\n    }\n\n    public function testSetHeaderPreservesOriginalCaseIfHeaderAlreadyExists()\n    {\n        $headers = new Headers([\n            'CONTENT-LENGTH' => 0,\n        ]);\n\n        $headers->setHeader('Content-Length', 100);\n\n        $this->assertEquals(['content-length' => ['100']], $headers->getHeaders());\n        $this->assertEquals(['CONTENT-LENGTH' => ['100']], $headers->getHeaders(true));\n    }\n\n    public function testSetHeaders()\n    {\n        $headers = new Headers([\n            'Content-Length' => 0,\n        ]);\n\n        $headers->setHeaders([\n            'Accept' => 'application/json',\n        ]);\n\n        $this->assertEquals(['accept' => ['application/json']], $headers->getHeaders());\n        $this->assertEquals(['Accept' => ['application/json']], $headers->getHeaders(true));\n    }\n\n    public function testHasHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $this->assertTrue($headers->hasHeader('accept'));\n        $this->assertTrue($headers->hasHeader('Accept'));\n        $this->assertTrue($headers->hasHeader('HTTP_ACCEPT'));\n    }\n\n    public function testGetHeaders()\n    {\n        $headers = new Headers([\n            'HTTP_ACCEPT' => 'text/html',\n            'HTTP_CONTENT_TYPE' => 'application/json',\n        ]);\n\n        $expectedNormalizedHeaders = [\n            'accept' => ['text/html'],\n            'content-type' => ['application/json'],\n        ];\n\n        $this->assertEquals($expectedNormalizedHeaders, $headers->getHeaders());\n    }\n\n    public function testGetHeadersPreservesOriginalCase()\n    {\n        $headers = new Headers([\n            'HTTP_ACCEPT' => 'text/html',\n            'HTTP_CONTENT_TYPE' => 'application/json',\n        ]);\n\n        $expectedOriginalHeaders = [\n            'ACCEPT' => ['text/html'],\n            'CONTENT-TYPE' => ['application/json'],\n        ];\n\n        $this->assertEquals($expectedOriginalHeaders, $headers->getHeaders(true));\n    }\n\n    public function testParseAuthorizationHeader()\n    {\n        $expectedValue = 'Basic ' . base64_encode('user:password');\n\n        $headers = new Headers(['Authorization' => $expectedValue]);\n        $this->assertEquals([$expectedValue], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['REDIRECT_HTTP_AUTHORIZATION' => 'cookie']);\n        $this->assertEquals(['cookie'], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['PHP_AUTH_USER' => 'user', 'PHP_AUTH_PW' => 'password']);\n        $this->assertEquals([$expectedValue], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['PHP_AUTH_DIGEST' => 'digest']);\n        $this->assertEquals(['digest'], $headers->getHeader('Authorization'));\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Slim Framework (https://slimframework.com)\n *\n * @license https://github.com/slimphp/Slim-Psr7/blob/master/LICENSE.md (MIT License)\n */\n\ndeclare(strict_types=1);\n\nnamespace Slim\\Psr7;\n\nuse InvalidArgumentException;\nuse Slim\\Psr7\\Interfaces\\HeadersInterface;\n\nuse function base64_encode;\nuse function function_exists;\nuse function getallheaders;\nuse function is_array;\nuse function is_numeric;\nuse function is_string;\nuse function preg_match;\nuse function strpos;\nuse function strtolower;\nuse function strtr;\nuse function substr;\nuse function trim;\n\nclass Headers implements HeadersInterface\n{\n    protected array $globals;\n\n    /**\n     * @var Header[]\n     */\n    protected array $headers;\n\n    /**\n     * @param array      $headers\n     * @param array|null $globals\n     */\n    final public function __construct(array $headers = [], ?array $globals = null)\n    {\n        $this->globals = $globals ?? $_SERVER;\n        $this->setHeaders($headers);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function addHeader($name, $value): HeadersInterface\n    {\n        [$values, $originalName, $normalizedName] = $this->prepareHeader($name, $value);\n\n        if (isset($this->headers[$normalizedName])) {\n            $header = $this->headers[$normalizedName];\n            $header->addValues($values);\n        } else {\n            $this->headers[$normalizedName] = new Header($originalName, $normalizedName, $values);\n        }\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function removeHeader(string $name): HeadersInterface\n    {\n        $name = $this->normalizeHeaderName($name);\n        unset($this->headers[$name]);\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getHeader(string $name, $default = []): array\n    {\n        $name = $this->normalizeHeaderName($name);\n\n        if (isset($this->headers[$name])) {\n            $header = $this->headers[$name];\n            return $header->getValues();\n        }\n\n        if (empty($default)) {\n            return $default;\n        }\n\n        $this->validateHeader($name, $default);\n        return $this->trimHeaderValue($default);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setHeader($name, $value): HeadersInterface\n    {\n        [$values, $originalName, $normalizedName] = $this->prepareHeader($name, $value);\n\n        // Ensure we preserve original case if the header already exists in the stack\n        if (isset($this->headers[$normalizedName])) {\n            $existingHeader = $this->headers[$normalizedName];\n            $originalName = $existingHeader->getOriginalName();\n        }\n\n        $this->headers[$normalizedName] = new Header($originalName, $normalizedName, $values);\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setHeaders(array $headers): HeadersInterface\n    {\n        $this->headers = [];\n\n        foreach ($this->parseAuthorizationHeader($headers) as $name => $value) {\n            $this->addHeader($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function hasHeader(string $name): bool\n    {\n        $name = $this->normalizeHeaderName($name);\n        return isset($this->headers[$name]);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getHeaders(bool $originalCase = false): array\n    {\n        $headers = [];\n\n        foreach ($this->headers as $header) {\n            $name = $originalCase ? $header->getOriginalName() : $header->getNormalizedName();\n            $headers[$name] = $header->getValues();\n        }\n\n        return $headers;\n    }\n\n    /**\n     * @param string $name\n     * @param bool   $preserveCase\n     * @return string\n     */\n    protected function normalizeHeaderName(string $name, bool $preserveCase = false): string\n    {\n        $name = strtr($name, '_', '-');\n\n        if (!$preserveCase) {\n            $name = strtolower($name);\n        }\n\n        if (strpos(strtolower($name), 'http-') === 0) {\n            $name = substr($name, 5);\n        }\n\n        return $name;\n    }\n\n    /**\n     * Parse incoming headers and determine Authorization header from original headers\n     *\n     * @param array $headers\n     * @return array\n     */\n    protected function parseAuthorizationHeader(array $headers): array\n    {\n        $hasAuthorizationHeader = false;\n        foreach ($headers as $name => $value) {\n            if (strtolower((string) $name) === 'authorization') {\n                $hasAuthorizationHeader = true;\n                break;\n            }\n        }\n\n        if (!$hasAuthorizationHeader) {\n            if (isset($this->globals['REDIRECT_HTTP_AUTHORIZATION'])) {\n                $headers['Authorization'] = $this->globals['REDIRECT_HTTP_AUTHORIZATION'];\n            } elseif (isset($this->globals['PHP_AUTH_USER'])) {\n                $pw = $this->globals['PHP_AUTH_PW'] ?? '';\n                $headers['Authorization'] = 'Basic ' . base64_encode($this->globals['PHP_AUTH_USER'] . ':' . $pw);\n            } elseif (isset($this->globals['PHP_AUTH_DIGEST'])) {\n                $headers['Authorization'] = $this->globals['PHP_AUTH_DIGEST'];\n            }\n        }\n\n        return $headers;\n    }\n\n    /**\n     * @param array|string $value\n     *\n     * @return array\n     */\n    protected function trimHeaderValue($value): array\n    {\n        $items = is_array($value) ? $value : [$value];\n        $result = [];\n        foreach ($items as $item) {\n            $result[] = trim((string) $item, \" \\t\");\n        }\n        return $result;\n    }\n\n    /**\n     * @param string       $name\n     * @param array|string $value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function prepareHeader($name, $value): array\n    {\n        $this->validateHeader($name, $value);\n        $values = $this->trimHeaderValue($value);\n        $originalName = $this->normalizeHeaderName($name, true);\n        $normalizedName = $this->normalizeHeaderName($name);\n        return [$values, $originalName, $normalizedName];\n    }\n\n    /**\n     * Make sure the header complies with RFC 7230.\n     *\n     * Header names must be a non-empty string consisting of token characters.\n     *\n     * Header values must be strings consisting of visible characters with all optional\n     * leading and trailing whitespace stripped. This method will always strip such\n     * optional whitespace. Note that the method does not allow folding whitespace within\n     * the values as this was deprecated for almost all instances by the RFC.\n     *\n     * header-field = field-name \":\" OWS field-value OWS\n     * field-name   = 1*( \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\"\n     *              / \"_\" / \"`\" / \"|\" / \"~\" / %x30-39 / ( %x41-5A / %x61-7A ) )\n     * OWS          = *( SP / HTAB )\n     * field-value  = *( ( %x21-7E / %x80-FF ) [ 1*( SP / HTAB ) ( %x21-7E / %x80-FF ) ] )\n     *\n     * @see https://tools.ietf.org/html/rfc7230#section-3.2.4\n     *\n     * @param string        $name\n     * @param array|string  $value\n     *\n     * @throws InvalidArgumentException;\n     */\n    protected function validateHeader($name, $value): void\n    {\n        $this->validateHeaderName($name);\n        $this->validateHeaderValue($value);\n    }\n\n    /**\n     * @param mixed $name\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateHeaderName($name): void\n    {\n        if (!is_string($name) || preg_match(\"@^[!#$%&'*+.^_`|~0-9A-Za-z-]+$@D\", $name) !== 1) {\n            throw new InvalidArgumentException('Header name must be an RFC 7230 compatible string.');\n        }\n    }\n\n    /**\n     * @param mixed $value\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function validateHeaderValue($value): void\n    {\n        $items = is_array($value) ? $value : [$value];\n\n        if (empty($items)) {\n            throw new InvalidArgumentException(\n                'Header values must be a string or an array of strings, empty array given.'\n            );\n        }\n\n        $pattern = \"@^[ \\t\\x21-\\x7E\\x80-\\xFF]*$@D\";\n        foreach ($items as $item) {\n            $hasInvalidType = !is_numeric($item) && !is_string($item);\n            $rejected = $hasInvalidType || preg_match($pattern, (string) $item) !== 1;\n            if ($rejected) {\n                throw new InvalidArgumentException(\n                    'Header values must be RFC 7230 compatible strings.'\n                );\n            }\n        }\n    }\n\n    /**\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        $headers = null;\n\n        if (function_exists('getallheaders')) {\n            $headers = getallheaders();\n        }\n\n        if (!is_array($headers)) {\n            $headers = [];\n        }\n\n        return new static($headers);\n    }\n}\n", "<?php\n\n/**\n * Slim Framework (https://slimframework.com)\n *\n * @license https://github.com/slimphp/Slim-Psr7/blob/master/LICENSE.md (MIT License)\n */\n\ndeclare(strict_types=1);\n\nnamespace Slim\\Tests\\Psr7;\n\nuse InvalidArgumentException;\nuse PHPUnit\\Framework\\TestCase;\nuse Slim\\Psr7\\Headers;\nuse stdClass;\n\nuse function base64_encode;\n\nclass HeadersTest extends TestCase\n{\n    public function testCreateFromGlobals()\n    {\n        $GLOBALS['getallheaders_return'] = [\n            'HTTP_ACCEPT' => 'application/json',\n        ];\n\n        $headers = Headers::createFromGlobals();\n\n        unset($GLOBALS['getallheaders_return']);\n\n        $this->assertEquals(['accept' => ['application/json']], $headers->getHeaders());\n        $this->assertEquals(['ACCEPT' => ['application/json']], $headers->getHeaders(true));\n    }\n\n    public function testCreateFromGlobalsUsesEmptyArrayIfGetAllHeadersReturnsFalse()\n    {\n        $GLOBALS['getallheaders_return'] = false;\n\n        $headers = Headers::createFromGlobals();\n\n        unset($GLOBALS['getallheaders_return']);\n\n        $this->assertEquals([], $headers->getHeaders());\n    }\n\n    public function testAddHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $headers->addHeader('Accept', 'text/html');\n\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('Accept'));\n        $this->assertEquals(['accept' => ['application/json', 'text/html']], $headers->getHeaders());\n        $this->assertEquals(['Accept' => ['application/json', 'text/html']], $headers->getHeaders(true));\n    }\n\n    public function testAddHeaderValueEmptyArray()\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        $headers = new Headers();\n        $headers->addHeader('Header', []);\n    }\n\n    public function testRemoveHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $headers->removeHeader('Accept');\n\n        $this->assertEquals([], $headers->getHeader('Accept'));\n        $this->assertEquals([], $headers->getHeaders());\n    }\n\n    /**\n     * @doesNotPerformAssertions\n     */\n    public function testRemoveHeaderByIncompatibleStringWithRFC()\n    {\n        $headers = new Headers();\n        $headers->removeHeader('<incompatible with RFC>');\n    }\n\n    public function testGetHeader()\n    {\n        $headers = new Headers([\n            'Accept' => ['application/json', 'text/html'],\n        ]);\n\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('accept'));\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('Accept'));\n        $this->assertEquals(['application/json', 'text/html'], $headers->getHeader('HTTP_ACCEPT'));\n    }\n\n    public function testGetHeaderReturnsValidatedAndTrimedHeaderDefaultValue()\n    {\n        $headers = new Headers([]);\n\n        $this->assertEquals(['application/json'], $headers->getHeader('accept', ' application/json'));\n    }\n\n    public function testGetHeaderThrowsExceptionWithInvalidDefaultArgument()\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        $headers = new Headers([]);\n\n        $headers->getHeader('accept', new stdClass());\n    }\n\n    public function testSetHeader()\n    {\n        $headers = new Headers([\n            'Content-Length' => 0,\n        ]);\n\n        $headers->setHeader('Content-Length', 100);\n\n        $this->assertSame(['100'], $headers->getHeader('Content-Length'));\n        $this->assertEquals(['content-length' => ['100']], $headers->getHeaders());\n        $this->assertEquals(['Content-Length' => ['100']], $headers->getHeaders(true));\n    }\n\n    public function testSetHeaderPreservesOriginalCaseIfHeaderAlreadyExists()\n    {\n        $headers = new Headers([\n            'CONTENT-LENGTH' => 0,\n        ]);\n\n        $headers->setHeader('Content-Length', 100);\n\n        $this->assertEquals(['content-length' => ['100']], $headers->getHeaders());\n        $this->assertEquals(['CONTENT-LENGTH' => ['100']], $headers->getHeaders(true));\n    }\n\n    public function testSetHeaders()\n    {\n        $headers = new Headers([\n            'Content-Length' => 0,\n        ]);\n\n        $headers->setHeaders([\n            'Accept' => 'application/json',\n        ]);\n\n        $this->assertEquals(['accept' => ['application/json']], $headers->getHeaders());\n        $this->assertEquals(['Accept' => ['application/json']], $headers->getHeaders(true));\n    }\n\n    public function testHasHeader()\n    {\n        $headers = new Headers([\n            'Accept' => 'application/json',\n        ]);\n\n        $this->assertTrue($headers->hasHeader('accept'));\n        $this->assertTrue($headers->hasHeader('Accept'));\n        $this->assertTrue($headers->hasHeader('HTTP_ACCEPT'));\n    }\n\n    public function testGetHeaders()\n    {\n        $headers = new Headers([\n            'HTTP_ACCEPT' => 'text/html',\n            'HTTP_CONTENT_TYPE' => 'application/json',\n        ]);\n\n        $expectedNormalizedHeaders = [\n            'accept' => ['text/html'],\n            'content-type' => ['application/json'],\n        ];\n\n        $this->assertEquals($expectedNormalizedHeaders, $headers->getHeaders());\n    }\n\n    public function testGetHeadersPreservesOriginalCase()\n    {\n        $headers = new Headers([\n            'HTTP_ACCEPT' => 'text/html',\n            'HTTP_CONTENT_TYPE' => 'application/json',\n        ]);\n\n        $expectedOriginalHeaders = [\n            'ACCEPT' => ['text/html'],\n            'CONTENT-TYPE' => ['application/json'],\n        ];\n\n        $this->assertEquals($expectedOriginalHeaders, $headers->getHeaders(true));\n    }\n\n    public function testParseAuthorizationHeader()\n    {\n        $expectedValue = 'Basic ' . base64_encode('user:password');\n\n        $headers = new Headers(['Authorization' => $expectedValue]);\n        $this->assertEquals([$expectedValue], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['REDIRECT_HTTP_AUTHORIZATION' => 'cookie']);\n        $this->assertEquals(['cookie'], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['PHP_AUTH_USER' => 'user', 'PHP_AUTH_PW' => 'password']);\n        $this->assertEquals([$expectedValue], $headers->getHeader('Authorization'));\n\n        $headers = new Headers([], ['PHP_AUTH_DIGEST' => 'digest']);\n        $this->assertEquals(['digest'], $headers->getHeader('Authorization'));\n    }\n\n    /**\n     * @dataProvider provideInvalidHeaderNames\n     */\n    public function testWithInvalidHeaderName($headerName): void\n    {\n        $headers = new Headers();\n\n        $this->expectException(\\InvalidArgumentException::class);\n\n        $headers->setHeader($headerName, 'foo');\n    }\n\n    public static function provideInvalidHeaderNames(): array\n    {\n        return [\n            [[]],\n            [false],\n            [new \\stdClass()],\n            [\"Content-Type\\r\\n\\r\\n\"],\n            [\"Content-Type\\r\\n\"],\n            [\"Content-Type\\n\"],\n            [\"\\r\\nContent-Type\"],\n            [\"\\nContent-Type\"],\n            [\"\\n\"],\n            [\"\\r\\n\"],\n            [\"\\t\"],\n        ];\n    }\n\n    /**\n     * @dataProvider provideInvalidHeaderValues\n     */\n    public function testSetInvalidHeaderValue($headerValue)\n    {\n        $headers = new Headers();\n\n        $this->expectException(\\InvalidArgumentException::class);\n\n        $headers->setHeader('Content-Type', $headerValue);\n    }\n\n    public static function provideInvalidHeaderValues(): array\n    {\n        // Explicit tests for newlines as the most common exploit vector.\n        $tests = [\n            [\"new\\nline\"],\n            [\"new\\r\\nline\"],\n            [\"new\\rline\"],\n            [\"new\\r\\n line\"],\n            [\"newline\\n\"],\n            [\"\\nnewline\"],\n            [\"newline\\r\\n\"],\n            [\"\\n\\rnewline\"],\n        ];\n\n        for ($i = 0; $i <= 0xff; $i++) {\n            if (\\chr($i) == \"\\t\") {\n                continue;\n            }\n            if (\\chr($i) == \" \") {\n                continue;\n            }\n            if ($i >= 0x21 && $i <= 0x7e) {\n                continue;\n            }\n            if ($i >= 0x80) {\n                continue;\n            }\n\n            $tests[] = [\"foo\" . \\chr($i) . \"bar\"];\n            $tests[] = [\"foo\" . \\chr($i)];\n        }\n\n        return $tests;\n    }\n}\n"], "filenames": ["src/Headers.php", "tests/HeadersTest.php"], "buggy_code_start_loc": [269, 211], "buggy_code_end_loc": [290, 211], "fixing_code_start_loc": [269, 212], "fixing_code_end_loc": [290, 288], "type": "CWE-436", "message": "slim/psr7 is a PSR-7 implementation for use with Slim 4. In versions prior to 1.6.1 an attacker could sneak in a newline (\\n) into both the header names and values. While the specification states that \\r\\n\\r\\n is used to terminate the header list, many servers in the wild will also accept \\n\\n. An attacker that is able to control the header names that are passed to Slilm-Psr7 would be able to intentionally craft invalid messages, possibly causing application errors or invalid HTTP requests being sent out with an PSR-18 HTTP client. The latter might present a denial of service vector if a remote service\u2019s web application firewall bans the application due to the receipt of malformed requests. The issue has been patched in version 1.6.1. There are no known workarounds to this issue. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-30536", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-17T22:15:10.137", "lastModified": "2023-05-01T16:38:35.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "slim/psr7 is a PSR-7 implementation for use with Slim 4. In versions prior to 1.6.1 an attacker could sneak in a newline (\\n) into both the header names and values. While the specification states that \\r\\n\\r\\n is used to terminate the header list, many servers in the wild will also accept \\n\\n. An attacker that is able to control the header names that are passed to Slilm-Psr7 would be able to intentionally craft invalid messages, possibly causing application errors or invalid HTTP requests being sent out with an PSR-18 HTTP client. The latter might present a denial of service vector if a remote service\u2019s web application firewall bans the application due to the receipt of malformed requests. The issue has been patched in version 1.6.1. There are no known workarounds to this issue. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:slimframework:slim_psr-7:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.1", "matchCriteriaId": "1CB325BE-7B88-42C4-ABF2-6AA374A0FE92"}]}]}], "references": [{"url": "https://github.com/slimphp/Slim-Psr7/commit/ed1d553225dd190875d8814c47460daed4b550bb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/slimphp/Slim-Psr7/security/advisories/GHSA-q2qj-628g-vhfw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.rfc-editor.org/rfc/rfc7230#section-3.2.4", "source": "security-advisories@github.com", "tags": ["Technical Description"]}]}, "github_commit_url": "https://github.com/slimphp/Slim-Psr7/commit/ed1d553225dd190875d8814c47460daed4b550bb"}}