{"buggy_code": ["// Copyright 2020 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\n\npackage ast\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"gopkg.in/yaml.v2\"\n\n\t\"github.com/open-policy-agent/opa/ast/internal/scanner\"\n\t\"github.com/open-policy-agent/opa/ast/internal/tokens\"\n\t\"github.com/open-policy-agent/opa/ast/location\"\n)\n\n// Note: This state is kept isolated from the parser so that we\n// can do efficient shallow copies of these values when doing a\n// save() and restore().\ntype state struct {\n\ts         *scanner.Scanner\n\tlastEnd   int\n\tskippedNL bool\n\ttok       tokens.Token\n\ttokEnd    int\n\tlit       string\n\tloc       Location\n\terrors    Errors\n\thints     []string\n\tcomments  []*Comment\n\twildcard  int\n}\n\nfunc (s *state) String() string {\n\treturn fmt.Sprintf(\"<s: %v, tok: %v, lit: %q, loc: %v, errors: %d, comments: %d>\", s.s, s.tok, s.lit, s.loc, len(s.errors), len(s.comments))\n}\n\nfunc (s *state) Loc() *location.Location {\n\tcpy := s.loc\n\treturn &cpy\n}\n\nfunc (s *state) Text(offset, end int) []byte {\n\tbs := s.s.Bytes()\n\tif offset >= 0 && offset < len(bs) {\n\t\tif end >= offset && end <= len(bs) {\n\t\t\treturn bs[offset:end]\n\t\t}\n\t}\n\treturn nil\n}\n\n// Parser is used to parse Rego statements.\ntype Parser struct {\n\tr     io.Reader\n\ts     *state\n\tpo    ParserOptions\n\tcache parsedTermCache\n}\n\ntype parsedTermCacheItem struct {\n\tt      *Term\n\tpost   *state // post is the post-state that's restored on a cache-hit\n\toffset int\n\tnext   *parsedTermCacheItem\n}\n\ntype parsedTermCache struct {\n\tm *parsedTermCacheItem\n}\n\nfunc (c parsedTermCache) String() string {\n\ts := strings.Builder{}\n\ts.WriteRune('{')\n\tvar e *parsedTermCacheItem\n\tfor e = c.m; e != nil; e = e.next {\n\t\tfmt.Fprintf(&s, \"%v\", e)\n\t}\n\ts.WriteRune('}')\n\treturn s.String()\n}\n\nfunc (e *parsedTermCacheItem) String() string {\n\treturn fmt.Sprintf(\"<%d:%v>\", e.offset, e.t)\n}\n\n// ParserOptions defines the options for parsing Rego statements.\ntype ParserOptions struct {\n\tCapabilities       *Capabilities\n\tProcessAnnotation  bool\n\tAllFutureKeywords  bool\n\tFutureKeywords     []string\n\tunreleasedKeywords bool // TODO(sr): cleanup\n}\n\n// NewParser creates and initializes a Parser.\nfunc NewParser() *Parser {\n\tp := &Parser{\n\t\ts:  &state{},\n\t\tpo: ParserOptions{},\n\t}\n\treturn p\n}\n\n// WithFilename provides the filename for Location details\n// on parsed statements.\nfunc (p *Parser) WithFilename(filename string) *Parser {\n\tp.s.loc.File = filename\n\treturn p\n}\n\n// WithReader provides the io.Reader that the parser will\n// use as its source.\nfunc (p *Parser) WithReader(r io.Reader) *Parser {\n\tp.r = r\n\treturn p\n}\n\n// WithProcessAnnotation enables or disables the processing of\n// annotations by the Parser\nfunc (p *Parser) WithProcessAnnotation(processAnnotation bool) *Parser {\n\tp.po.ProcessAnnotation = processAnnotation\n\treturn p\n}\n\n// WithFutureKeywords enables \"future\" keywords, i.e., keywords that can\n// be imported via\n//\n//     import future.keywords.kw\n//     import future.keywords.other\n//\n// but in a more direct way. The equivalent of this import would be\n//\n//     WithFutureKeywords(\"kw\", \"other\")\nfunc (p *Parser) WithFutureKeywords(kws ...string) *Parser {\n\tp.po.FutureKeywords = kws\n\treturn p\n}\n\n// WithAllFutureKeywords enables all \"future\" keywords, i.e., the\n// ParserOption equivalent of\n//\n//     import future.keywords\nfunc (p *Parser) WithAllFutureKeywords(yes bool) *Parser {\n\tp.po.AllFutureKeywords = yes\n\treturn p\n}\n\n// withUnreleasedKeywords allows using keywords that haven't surfaced\n// as future keywords (see above) yet, but have tests that require\n// them to be parsed\nfunc (p *Parser) withUnreleasedKeywords(yes bool) *Parser {\n\tp.po.unreleasedKeywords = yes\n\treturn p\n}\n\n// WithCapabilities sets the capabilities structure on the parser.\nfunc (p *Parser) WithCapabilities(c *Capabilities) *Parser {\n\tp.po.Capabilities = c\n\treturn p\n}\n\nfunc (p *Parser) parsedTermCacheLookup() (*Term, *state) {\n\tl := p.s.loc.Offset\n\t// stop comparing once the cached offsets are lower than l\n\tfor h := p.cache.m; h != nil && h.offset >= l; h = h.next {\n\t\tif h.offset == l {\n\t\t\treturn h.t, h.post\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc (p *Parser) parsedTermCachePush(t *Term, s0 *state) {\n\ts1 := p.save()\n\to0 := s0.loc.Offset\n\tentry := parsedTermCacheItem{t: t, post: s1, offset: o0}\n\n\t// find the first one whose offset is smaller than ours\n\tvar e *parsedTermCacheItem\n\tfor e = p.cache.m; e != nil; e = e.next {\n\t\tif e.offset < o0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tentry.next = e\n\tp.cache.m = &entry\n}\n\n// futureParser returns a shallow copy of `p` with an empty\n// cache, and a scanner that knows all future keywords.\n// It's used to present hints in errors, when statements would\n// only parse successfully if some future keyword is enabled.\nfunc (p *Parser) futureParser() *Parser {\n\tq := *p\n\tq.s = p.save()\n\tq.s.s = p.s.s.WithKeywords(futureKeywords)\n\tq.cache = parsedTermCache{}\n\treturn &q\n}\n\n// presentParser returns a shallow copy of `p` with an empty\n// cache, and a scanner that knows none of the future keywords.\n// It is used to successfully parse keyword imports, like\n//\n//  import future.keywords.in\n//\n// even when the parser has already been informed about the\n// future keyword \"in\". This parser won't error out because\n// \"in\" is an identifier.\nfunc (p *Parser) presentParser() (*Parser, map[string]tokens.Token) {\n\tvar cpy map[string]tokens.Token\n\tq := *p\n\tq.s = p.save()\n\tq.s.s, cpy = p.s.s.WithoutKeywords(futureKeywords)\n\tq.cache = parsedTermCache{}\n\treturn &q, cpy\n}\n\n// Parse will read the Rego source and parse statements and\n// comments as they are found. Any errors encountered while\n// parsing will be accumulated and returned as a list of Errors.\nfunc (p *Parser) Parse() ([]Statement, []*Comment, Errors) {\n\n\tif p.po.Capabilities == nil {\n\t\tp.po.Capabilities = CapabilitiesForThisVersion()\n\t}\n\n\tallowedFutureKeywords := map[string]tokens.Token{}\n\n\tfor _, kw := range p.po.Capabilities.FutureKeywords {\n\t\tvar ok bool\n\t\tallowedFutureKeywords[kw], ok = futureKeywords[kw]\n\t\tif !ok {\n\t\t\treturn nil, nil, Errors{\n\t\t\t\t&Error{\n\t\t\t\t\tCode:     ParseErr,\n\t\t\t\t\tMessage:  fmt.Sprintf(\"illegal capabilities: unknown keyword: %v\", kw),\n\t\t\t\t\tLocation: nil,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tvar err error\n\tp.s.s, err = scanner.New(p.r)\n\tif err != nil {\n\t\treturn nil, nil, Errors{\n\t\t\t&Error{\n\t\t\t\tCode:     ParseErr,\n\t\t\t\tMessage:  err.Error(),\n\t\t\t\tLocation: nil,\n\t\t\t},\n\t\t}\n\t}\n\n\tselected := map[string]tokens.Token{}\n\tif p.po.AllFutureKeywords {\n\t\tfor kw, tok := range allowedFutureKeywords {\n\t\t\tselected[kw] = tok\n\t\t}\n\t} else {\n\t\tfor _, kw := range p.po.FutureKeywords {\n\t\t\ttok, ok := allowedFutureKeywords[kw]\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, Errors{\n\t\t\t\t\t&Error{\n\t\t\t\t\t\tCode:     ParseErr,\n\t\t\t\t\t\tMessage:  fmt.Sprintf(\"unknown future keyword: %v\", kw),\n\t\t\t\t\t\tLocation: nil,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tselected[kw] = tok\n\t\t}\n\t}\n\tp.s.s = p.s.s.WithKeywords(selected)\n\n\t// read the first token to initialize the parser\n\tp.scan()\n\n\tvar stmts []Statement\n\n\t// Read from the scanner until the last token is reached or no statements\n\t// can be parsed. Attempt to parse package statements, import statements,\n\t// rule statements, and then body/query statements (in that order). If a\n\t// statement cannot be parsed, restore the parser state before trying the\n\t// next type of statement. If a statement can be parsed, continue from that\n\t// point trying to parse packages, imports, etc. in the same order.\n\tfor p.s.tok != tokens.EOF {\n\n\t\ts := p.save()\n\n\t\tif pkg := p.parsePackage(); pkg != nil {\n\t\t\tstmts = append(stmts, pkg)\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\t\ts = p.save()\n\n\t\tif imp := p.parseImport(); imp != nil {\n\t\t\tif FutureRootDocument.Equal(imp.Path.Value.(Ref)[0]) {\n\t\t\t\tp.futureImport(imp, allowedFutureKeywords)\n\t\t\t}\n\t\t\tstmts = append(stmts, imp)\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\t\ts = p.save()\n\n\t\tif rules := p.parseRules(); rules != nil {\n\t\t\tfor i := range rules {\n\t\t\t\tstmts = append(stmts, rules[i])\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\n\t\tif body := p.parseQuery(true, tokens.EOF); body != nil {\n\t\t\tstmts = append(stmts, body)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\n\tif p.po.ProcessAnnotation {\n\t\tstmts = p.parseAnnotations(stmts)\n\t}\n\n\treturn stmts, p.s.comments, p.s.errors\n}\n\nfunc (p *Parser) parseAnnotations(stmts []Statement) []Statement {\n\n\tvar hint = []byte(\"METADATA\")\n\tvar curr *metadataParser\n\tvar blocks []*metadataParser\n\n\tfor i := 0; i < len(p.s.comments); i++ {\n\t\tif curr != nil {\n\t\t\tif p.s.comments[i].Location.Row == p.s.comments[i-1].Location.Row+1 && p.s.comments[i].Location.Col == 1 {\n\t\t\t\tcurr.Append(p.s.comments[i])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcurr = nil\n\t\t}\n\t\tif bytes.HasPrefix(bytes.TrimSpace(p.s.comments[i].Text), hint) {\n\t\t\tcurr = newMetadataParser(p.s.comments[i].Location)\n\t\t\tblocks = append(blocks, curr)\n\t\t}\n\t}\n\n\tfor _, b := range blocks {\n\t\ta, err := b.Parse()\n\t\tif err != nil {\n\t\t\tp.error(b.loc, err.Error())\n\t\t} else {\n\t\t\tstmts = append(stmts, a)\n\t\t}\n\t}\n\n\treturn stmts\n}\n\nfunc (p *Parser) parsePackage() *Package {\n\n\tvar pkg Package\n\tpkg.SetLoc(p.s.Loc())\n\n\tif p.s.tok != tokens.Package {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\tif p.s.tok != tokens.Ident {\n\t\tp.illegalToken()\n\t\treturn nil\n\t}\n\n\tterm := p.parseTerm()\n\n\tif term != nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\tpkg.Path = Ref{\n\t\t\t\tDefaultRootDocument.Copy().SetLocation(term.Location),\n\t\t\t\tStringTerm(string(v)).SetLocation(term.Location),\n\t\t\t}\n\t\tcase Ref:\n\t\t\tpkg.Path = make(Ref, len(v)+1)\n\t\t\tpkg.Path[0] = DefaultRootDocument.Copy().SetLocation(v[0].Location)\n\t\t\tfirst, ok := v[0].Value.(Var)\n\t\t\tif !ok {\n\t\t\t\tp.errorf(v[0].Location, \"unexpected %v token: expecting var\", TypeName(v[0].Value))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tpkg.Path[1] = StringTerm(string(first)).SetLocation(v[0].Location)\n\t\t\tfor i := 2; i < len(pkg.Path); i++ {\n\t\t\t\tswitch v[i-1].Value.(type) {\n\t\t\t\tcase String:\n\t\t\t\t\tpkg.Path[i] = v[i-1]\n\t\t\t\tdefault:\n\t\t\t\t\tp.errorf(v[i-1].Location, \"unexpected %v token: expecting string\", TypeName(v[i-1].Value))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tp.illegalToken()\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif pkg.Path == nil {\n\t\tif len(p.s.errors) == 0 {\n\t\t\tp.error(p.s.Loc(), \"expected path\")\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn &pkg\n}\n\nfunc (p *Parser) parseImport() *Import {\n\n\tvar imp Import\n\timp.SetLoc(p.s.Loc())\n\n\tif p.s.tok != tokens.Import {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\tif p.s.tok != tokens.Ident {\n\t\tp.error(p.s.Loc(), \"expected ident\")\n\t\treturn nil\n\t}\n\tq, prev := p.presentParser()\n\tterm := q.parseTerm()\n\tif term != nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\timp.Path = RefTerm(term).SetLocation(term.Location)\n\t\tcase Ref:\n\t\t\tfor i := 1; i < len(v); i++ {\n\t\t\t\tif _, ok := v[i].Value.(String); !ok {\n\t\t\t\t\tp.errorf(v[i].Location, \"unexpected %v token: expecting string\", TypeName(v[i].Value))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\timp.Path = term\n\t\t}\n\t}\n\t// keep advanced parser state, reset known keywords\n\tp.s = q.s\n\tp.s.s = q.s.s.WithKeywords(prev)\n\n\tif imp.Path == nil {\n\t\tp.error(p.s.Loc(), \"expected path\")\n\t\treturn nil\n\t}\n\n\tpath := imp.Path.Value.(Ref)\n\n\tif !RootDocumentNames.Contains(path[0]) && !FutureRootDocument.Equal(path[0]) {\n\t\tp.errorf(imp.Path.Location, \"unexpected import path, must begin with one of: %v, got: %v\",\n\t\t\tRootDocumentNames.Union(NewSet(FutureRootDocument)),\n\t\t\tpath[0])\n\t\treturn nil\n\t}\n\n\tif p.s.tok == tokens.As {\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected var\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif alias := p.parseTerm(); alias != nil {\n\t\t\tv, ok := alias.Value.(Var)\n\t\t\tif ok {\n\t\t\t\timp.Alias = v\n\t\t\t\treturn &imp\n\t\t\t}\n\t\t}\n\t\tp.illegal(\"expected var\")\n\t\treturn nil\n\t}\n\n\treturn &imp\n}\n\nfunc (p *Parser) parseRules() []*Rule {\n\n\tvar rule Rule\n\trule.SetLoc(p.s.Loc())\n\n\tif p.s.tok == tokens.Default {\n\t\tp.scan()\n\t\trule.Default = true\n\t}\n\n\tif p.s.tok != tokens.Ident {\n\t\treturn nil\n\t}\n\n\tif rule.Head = p.parseHead(rule.Default); rule.Head == nil {\n\t\treturn nil\n\t}\n\n\tif rule.Default {\n\t\tif !p.validateDefaultRuleValue(&rule) {\n\t\t\treturn nil\n\t\t}\n\n\t\trule.Body = NewBody(NewExpr(BooleanTerm(true).SetLocation(rule.Location)).SetLocation(rule.Location))\n\t\treturn []*Rule{&rule}\n\t}\n\n\tif p.s.tok == tokens.LBrace {\n\t\tp.scan()\n\t\tif rule.Body = p.parseBody(tokens.RBrace); rule.Body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\t} else {\n\t\treturn nil\n\t}\n\n\tif p.s.tok == tokens.Else {\n\n\t\tif rule.Head.Assign {\n\t\t\tp.error(p.s.Loc(), \"else keyword cannot be used on rule declared with := operator\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif rule.Head.Key != nil {\n\t\t\tp.error(p.s.Loc(), \"else keyword cannot be used on partial rules\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif rule.Else = p.parseElse(rule.Head); rule.Else == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\trule.Location.Text = p.s.Text(rule.Location.Offset, p.s.lastEnd)\n\n\tvar rules []*Rule\n\n\trules = append(rules, &rule)\n\n\tfor p.s.tok == tokens.LBrace {\n\n\t\tif rule.Else != nil {\n\t\t\tp.error(p.s.Loc(), \"expected else keyword\")\n\t\t\treturn nil\n\t\t}\n\n\t\tloc := p.s.Loc()\n\n\t\tp.scan()\n\t\tvar next Rule\n\n\t\tif next.Body = p.parseBody(tokens.RBrace); next.Body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\n\t\tloc.Text = p.s.Text(loc.Offset, p.s.lastEnd)\n\t\tnext.SetLoc(loc)\n\n\t\t// Chained rule head's keep the original\n\t\t// rule's head AST but have their location\n\t\t// set to the rule body.\n\t\tnext.Head = rule.Head.Copy()\n\t\tsetLocRecursive(next.Head, loc)\n\n\t\trules = append(rules, &next)\n\t}\n\n\treturn rules\n}\n\nfunc (p *Parser) parseElse(head *Head) *Rule {\n\n\tvar rule Rule\n\trule.SetLoc(p.s.Loc())\n\n\trule.Head = head.Copy()\n\trule.Head.SetLoc(p.s.Loc())\n\n\tdefer func() {\n\t\trule.Location.Text = p.s.Text(rule.Location.Offset, p.s.lastEnd)\n\t}()\n\n\tp.scan()\n\n\tswitch p.s.tok {\n\tcase tokens.LBrace:\n\t\trule.Head.Value = BooleanTerm(true)\n\tcase tokens.Unify:\n\t\tp.scan()\n\t\trule.Head.Value = p.parseTermInfixCall()\n\t\tif rule.Head.Value == nil {\n\t\t\treturn nil\n\t\t}\n\t\trule.Head.Location.Text = p.s.Text(rule.Head.Location.Offset, p.s.lastEnd)\n\tdefault:\n\t\tp.illegal(\"expected else value term or rule body\")\n\t\treturn nil\n\t}\n\n\tif p.s.tok != tokens.LBrace {\n\t\trule.Body = NewBody(NewExpr(BooleanTerm(true)))\n\t\tsetLocRecursive(rule.Body, rule.Location)\n\t\treturn &rule\n\t}\n\n\tp.scan()\n\n\tif rule.Body = p.parseBody(tokens.RBrace); rule.Body == nil {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\n\tif p.s.tok == tokens.Else {\n\t\tif rule.Else = p.parseElse(head); rule.Else == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn &rule\n}\n\nfunc (p *Parser) parseHead(defaultRule bool) *Head {\n\n\tvar head Head\n\thead.SetLoc(p.s.Loc())\n\n\tdefer func() {\n\t\thead.Location.Text = p.s.Text(head.Location.Offset, p.s.lastEnd)\n\t}()\n\n\tif term := p.parseVar(); term != nil {\n\t\thead.Name = term.Value.(Var)\n\t} else {\n\t\tp.illegal(\"expected rule head name\")\n\t}\n\n\tp.scan()\n\n\tif p.s.tok == tokens.LParen {\n\t\tp.scan()\n\t\tif p.s.tok != tokens.RParen {\n\t\t\thead.Args = p.parseTermList(tokens.RParen, nil)\n\t\t\tif head.Args == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tp.scan()\n\n\t\tif p.s.tok == tokens.LBrack {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif p.s.tok == tokens.LBrack {\n\t\tp.scan()\n\t\thead.Key = p.parseTermInfixCall()\n\t\tif head.Key == nil {\n\t\t\tp.illegal(\"expected rule key term (e.g., %s[<VALUE>] { ... })\", head.Name)\n\t\t}\n\t\tif p.s.tok != tokens.RBrack {\n\t\t\tif _, ok := futureKeywords[head.Name.String()]; ok {\n\t\t\t\tp.hint(\"`import future.keywords.%[1]s` for '%[1]s' keyword\", head.Name.String())\n\t\t\t}\n\t\t\tp.illegal(\"non-terminated rule key\")\n\t\t}\n\t\tp.scan()\n\t}\n\n\tif p.s.tok == tokens.Unify {\n\t\tp.scan()\n\t\thead.Value = p.parseTermInfixCall()\n\t\tif head.Value == nil {\n\t\t\tp.illegal(\"expected rule value term (e.g., %s[%s] = <VALUE> { ... })\", head.Name, head.Key)\n\t\t}\n\t} else if p.s.tok == tokens.Assign {\n\n\t\tif defaultRule {\n\t\t\tp.error(p.s.Loc(), \"default rules must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t} else if head.Key != nil {\n\t\t\tp.error(p.s.Loc(), \"partial rules must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t} else if len(head.Args) > 0 {\n\t\t\tp.error(p.s.Loc(), \"functions must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t}\n\n\t\tp.scan()\n\t\thead.Assign = true\n\t\thead.Value = p.parseTermInfixCall()\n\t\tif head.Value == nil {\n\t\t\tp.illegal(\"expected rule value term (e.g., %s := <VALUE> { ... })\", head.Name)\n\t\t}\n\t}\n\n\tif head.Value == nil && head.Key == nil {\n\t\thead.Value = BooleanTerm(true).SetLocation(head.Location)\n\t}\n\n\treturn &head\n}\n\nfunc (p *Parser) parseBody(end tokens.Token) Body {\n\treturn p.parseQuery(false, end)\n}\n\nfunc (p *Parser) parseQuery(requireSemi bool, end tokens.Token) Body {\n\tbody := Body{}\n\n\tif p.s.tok == end {\n\t\tp.error(p.s.Loc(), \"found empty body\")\n\t\treturn nil\n\t}\n\n\tfor {\n\n\t\texpr := p.parseLiteral()\n\t\tif expr == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tbody.Append(expr)\n\n\t\tif p.s.tok == tokens.Semicolon {\n\t\t\tp.scan()\n\t\t\tcontinue\n\t\t}\n\n\t\tif p.s.tok == end || requireSemi {\n\t\t\treturn body\n\t\t}\n\n\t\tif !p.s.skippedNL {\n\t\t\t// If there was already an error then don't pile this one on\n\t\t\tif len(p.s.errors) == 0 {\n\t\t\t\tp.illegal(`expected \\n or %s or %s`, tokens.Semicolon, end)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (p *Parser) parseLiteral() (expr *Expr) {\n\n\toffset := p.s.loc.Offset\n\tloc := p.s.Loc()\n\n\tdefer func() {\n\t\tif expr != nil {\n\t\t\tloc.Text = p.s.Text(offset, p.s.lastEnd)\n\t\t\texpr.SetLoc(loc)\n\t\t}\n\t}()\n\n\tvar negated bool\n\tif p.s.tok == tokens.Not {\n\t\tp.scan()\n\t\tnegated = true\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.Some:\n\t\tif negated {\n\t\t\tp.illegal(\"illegal negation of 'some'\")\n\t\t\treturn nil\n\t\t}\n\t\treturn p.parseSome()\n\tcase tokens.Every:\n\t\tif negated {\n\t\t\tp.illegal(\"illegal negation of 'every'\")\n\t\t\treturn nil\n\t\t}\n\t\treturn p.parseEvery()\n\tdefault:\n\t\ts := p.save()\n\t\texpr := p.parseExpr()\n\t\tif expr != nil {\n\t\t\texpr.Negated = negated\n\t\t\tif p.s.tok == tokens.With {\n\t\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we find a plain `every` identifier, attempt to parse an every expression,\n\t\t\t// add hint if it succeeds.\n\t\t\tif term, ok := expr.Terms.(*Term); ok && Var(\"every\").Equal(term.Value) {\n\t\t\t\tvar hint bool\n\t\t\t\tt := p.save()\n\t\t\t\tp.restore(s)\n\t\t\t\tif expr := p.futureParser().parseEvery(); expr != nil {\n\t\t\t\t\t_, hint = expr.Terms.(*Every)\n\t\t\t\t}\n\t\t\t\tp.restore(t)\n\t\t\t\tif hint {\n\t\t\t\t\tp.hint(\"`import future.keywords.every` for `every x in xs { ... }` expressions\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseWith() []*With {\n\n\twiths := []*With{}\n\n\tfor {\n\n\t\twith := With{\n\t\t\tLocation: p.s.Loc(),\n\t\t}\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected ident\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif with.Target = p.parseTerm(); with.Target == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch with.Target.Value.(type) {\n\t\tcase Ref, Var:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.illegal(\"expected with target path\")\n\t\t}\n\n\t\tif p.s.tok != tokens.As {\n\t\t\tp.illegal(\"expected as keyword\")\n\t\t\treturn nil\n\t\t}\n\n\t\tp.scan()\n\n\t\tif with.Value = p.parseTermInfixCall(); with.Value == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\twith.Location.Text = p.s.Text(with.Location.Offset, p.s.lastEnd)\n\n\t\twiths = append(withs, &with)\n\n\t\tif p.s.tok != tokens.With {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn withs\n}\n\nfunc (p *Parser) parseSome() *Expr {\n\n\tdecl := &SomeDecl{}\n\tdecl.SetLoc(p.s.Loc())\n\n\t// Attempt to parse \"some x in xs\", which will end up in\n\t//   SomeDecl{Symbols: [\"member(x, xs)\"]}\n\ts := p.save()\n\tp.scan()\n\tif term := p.parseTermInfixCall(); term != nil {\n\t\tif call, ok := term.Value.(Call); ok {\n\t\t\tswitch call[0].String() {\n\t\t\tcase Member.Name, MemberWithKey.Name: // OK\n\t\t\tdefault:\n\t\t\t\tp.illegal(\"expected `x in xs` or `x, y in xs` expression\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tdecl.Symbols = []*Term{term}\n\t\t\texpr := NewExpr(decl).SetLocation(decl.Location)\n\t\t\tif p.s.tok == tokens.With {\n\t\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr\n\t\t}\n\t}\n\n\tp.restore(s)\n\ts = p.save() // new copy for later\n\tvar hint bool\n\tp.scan()\n\tif term := p.futureParser().parseTermInfixCall(); term != nil {\n\t\tif call, ok := term.Value.(Call); ok {\n\t\t\tswitch call[0].String() {\n\t\t\tcase Member.Name, MemberWithKey.Name:\n\t\t\t\thint = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// go on as before, it's `some x[...]` or illegal\n\tp.restore(s)\n\tif hint {\n\t\tp.hint(\"`import future.keywords.in` for `some x in xs` expressions\")\n\t}\n\n\tfor { // collecting var args\n\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected var\")\n\t\t\treturn nil\n\t\t}\n\n\t\tdecl.Symbols = append(decl.Symbols, p.parseVar())\n\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Comma {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn NewExpr(decl).SetLocation(decl.Location)\n}\n\nfunc (p *Parser) parseEvery() *Expr {\n\tqb := &Every{}\n\tqb.SetLoc(p.s.Loc())\n\n\t// TODO(sr): We'd get more accurate error messages if we didn't rely on\n\t// parseTermInfixCall here, but parsed \"var [, var] in term\" manually.\n\tp.scan()\n\tterm := p.parseTermInfixCall()\n\tif term == nil {\n\t\treturn nil\n\t}\n\tcall, ok := term.Value.(Call)\n\tif !ok {\n\t\tp.illegal(\"expected `x[, y] in xs { ... }` expression\")\n\t\treturn nil\n\t}\n\tswitch call[0].String() {\n\tcase Member.Name: // x in xs\n\t\tqb.Value = call[1]\n\t\tqb.Domain = call[2]\n\tcase MemberWithKey.Name: // k, v in xs\n\t\tqb.Key = call[1]\n\t\tqb.Value = call[2]\n\t\tqb.Domain = call[3]\n\t\tif _, ok := qb.Key.Value.(Var); !ok {\n\t\t\tp.illegal(\"expected key to be a variable\")\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\tp.illegal(\"expected `x[, y] in xs { ... }` expression\")\n\t\treturn nil\n\t}\n\tif _, ok := qb.Value.Value.(Var); !ok {\n\t\tp.illegal(\"expected value to be a variable\")\n\t\treturn nil\n\t}\n\tif p.s.tok == tokens.LBrace { // every x in xs { ... }\n\t\tp.scan()\n\t\tbody := p.parseBody(tokens.RBrace)\n\t\tif body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\t\tqb.Body = body\n\t\texpr := NewExpr(qb).SetLocation(qb.Location)\n\n\t\tif p.s.tok == tokens.With {\n\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn expr\n\t}\n\n\tp.illegal(\"missing body\")\n\treturn nil\n}\n\nfunc (p *Parser) parseExpr() *Expr {\n\n\tlhs := p.parseTermInfixCall()\n\tif lhs == nil {\n\t\treturn nil\n\t}\n\n\tif op := p.parseTermOp(tokens.Assign, tokens.Unify); op != nil {\n\t\tif rhs := p.parseTermInfixCall(); rhs != nil {\n\t\t\treturn NewExpr([]*Term{op, lhs, rhs})\n\t\t}\n\t\treturn nil\n\t}\n\n\t// NOTE(tsandall): the top-level call term is converted to an expr because\n\t// the evaluator does not support the call term type (nested calls are\n\t// rewritten by the compiler.)\n\tif call, ok := lhs.Value.(Call); ok {\n\t\treturn NewExpr([]*Term(call))\n\t}\n\n\treturn NewExpr(lhs)\n}\n\n// parseTermInfixCall consumes the next term from the input and returns it. If a\n// term cannot be parsed the return value is nil and error will be recorded. The\n// scanner will be advanced to the next token before returning.\n// By starting out with infix relations (==, !=, <, etc) and further calling the\n// other binary operators (|, &, arithmetics), it constitutes the binding\n// precedence.\nfunc (p *Parser) parseTermInfixCall() *Term {\n\treturn p.parseTermIn(nil, true, p.s.loc.Offset)\n}\n\nfunc (p *Parser) parseTermInfixCallInList() *Term {\n\treturn p.parseTermIn(nil, false, p.s.loc.Offset)\n}\n\nfunc (p *Parser) parseTermIn(lhs *Term, keyVal bool, offset int) *Term {\n\t// NOTE(sr): `in` is a bit special: besides `lhs in rhs`, it also\n\t// supports `key, val in rhs`, so it can have an optional second lhs.\n\t// `keyVal` triggers if we attempt to parse a second lhs argument (`mhs`).\n\tif lhs == nil {\n\t\tlhs = p.parseTermRelation(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif keyVal && p.s.tok == tokens.Comma { // second \"lhs\", or \"middle hand side\"\n\t\t\ts := p.save()\n\t\t\tp.scan()\n\t\t\tif mhs := p.parseTermRelation(nil, offset); mhs != nil {\n\t\t\t\tif op := p.parseTermOpName(MemberWithKey.Ref(), tokens.In); op != nil {\n\t\t\t\t\tif rhs := p.parseTermRelation(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, mhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\t\t\tswitch p.s.tok {\n\t\t\t\t\t\tcase tokens.In:\n\t\t\t\t\t\t\treturn p.parseTermIn(call, keyVal, offset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn call\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.restore(s)\n\t\t\treturn nil\n\t\t}\n\t\tif op := p.parseTermOpName(Member.Ref(), tokens.In); op != nil {\n\t\t\tif rhs := p.parseTermRelation(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.In:\n\t\t\t\t\treturn p.parseTermIn(call, keyVal, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermRelation(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermOr(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Equal, tokens.Neq, tokens.Lt, tokens.Gt, tokens.Lte, tokens.Gte); op != nil {\n\t\t\tif rhs := p.parseTermOr(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Equal, tokens.Neq, tokens.Lt, tokens.Gt, tokens.Lte, tokens.Gte:\n\t\t\t\t\treturn p.parseTermRelation(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermOr(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermAnd(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Or); op != nil {\n\t\t\tif rhs := p.parseTermAnd(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Or:\n\t\t\t\t\treturn p.parseTermOr(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lhs\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermAnd(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermArith(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.And); op != nil {\n\t\t\tif rhs := p.parseTermArith(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.And:\n\t\t\t\t\treturn p.parseTermAnd(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lhs\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermArith(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermFactor(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Add, tokens.Sub); op != nil {\n\t\t\tif rhs := p.parseTermFactor(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Add, tokens.Sub:\n\t\t\t\t\treturn p.parseTermArith(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermFactor(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTerm()\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Mul, tokens.Quo, tokens.Rem); op != nil {\n\t\t\tif rhs := p.parseTerm(); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Mul, tokens.Quo, tokens.Rem:\n\t\t\t\t\treturn p.parseTermFactor(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTerm() *Term {\n\tif term, s := p.parsedTermCacheLookup(); s != nil {\n\t\tp.restore(s)\n\t\treturn term\n\t}\n\ts0 := p.save()\n\n\tvar term *Term\n\tswitch p.s.tok {\n\tcase tokens.Null:\n\t\tterm = NullTerm().SetLocation(p.s.Loc())\n\tcase tokens.True:\n\t\tterm = BooleanTerm(true).SetLocation(p.s.Loc())\n\tcase tokens.False:\n\t\tterm = BooleanTerm(false).SetLocation(p.s.Loc())\n\tcase tokens.Sub, tokens.Dot, tokens.Number:\n\t\tterm = p.parseNumber()\n\tcase tokens.String:\n\t\tterm = p.parseString()\n\tcase tokens.Ident:\n\t\tterm = p.parseVar()\n\tcase tokens.LBrack:\n\t\tterm = p.parseArray()\n\tcase tokens.LBrace:\n\t\tterm = p.parseSetOrObject()\n\tcase tokens.LParen:\n\t\toffset := p.s.loc.Offset\n\t\tp.scan()\n\t\tif r := p.parseTermInfixCall(); r != nil {\n\t\t\tif p.s.tok == tokens.RParen {\n\t\t\t\tr.Location.Text = p.s.Text(offset, p.s.tokEnd)\n\t\t\t\tterm = r\n\t\t\t} else {\n\t\t\t\tp.error(p.s.Loc(), \"non-terminated expression\")\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tp.illegalToken()\n\t}\n\n\tterm = p.parseTermFinish(term)\n\tp.parsedTermCachePush(term, s0)\n\treturn term\n}\n\nfunc (p *Parser) parseTermFinish(head *Term) *Term {\n\tif head == nil {\n\t\treturn nil\n\t}\n\toffset := p.s.loc.Offset\n\tp.scanWS()\n\tswitch p.s.tok {\n\tcase tokens.LParen, tokens.Dot, tokens.LBrack:\n\t\treturn p.parseRef(head, offset)\n\tcase tokens.Whitespace:\n\t\tp.scan()\n\t\tfallthrough\n\tdefault:\n\t\tif _, ok := head.Value.(Var); ok && RootDocumentNames.Contains(head) {\n\t\t\treturn RefTerm(head).SetLocation(head.Location)\n\t\t}\n\t\treturn head\n\t}\n}\n\nfunc (p *Parser) parseNumber() *Term {\n\tvar prefix string\n\tloc := p.s.Loc()\n\tif p.s.tok == tokens.Sub {\n\t\tprefix = \"-\"\n\t\tp.scan()\n\t\tswitch p.s.tok {\n\t\tcase tokens.Number, tokens.Dot:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.illegal(\"expected number\")\n\t\t\treturn nil\n\t\t}\n\t}\n\tif p.s.tok == tokens.Dot {\n\t\tprefix += \".\"\n\t\tp.scan()\n\t\tif p.s.tok != tokens.Number {\n\t\t\tp.illegal(\"expected number\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Check for multiple leading 0's, parsed by math/big.Float.Parse as decimal 0:\n\t// https://golang.org/pkg/math/big/#Float.Parse\n\tif ((len(prefix) != 0 && prefix[0] == '-') || len(prefix) == 0) &&\n\t\tlen(p.s.lit) > 1 && p.s.lit[0] == '0' && p.s.lit[1] == '0' {\n\t\tp.illegal(\"expected number\")\n\t\treturn nil\n\t}\n\n\t// Ensure that the number is valid\n\ts := prefix + p.s.lit\n\tf, ok := new(big.Float).SetString(s)\n\tif !ok {\n\t\tp.illegal(\"invalid float\")\n\t\treturn nil\n\t}\n\n\t// Put limit on size of exponent to prevent non-linear cost of String()\n\t// function on big.Float from causing denial of service: https://github.com/golang/go/issues/11068\n\t//\n\t// n == sign * mantissa * 2^exp\n\t// 0.5 <= mantissa < 1.0\n\t//\n\t// The limit is arbitrary.\n\texp := f.MantExp(nil)\n\tif exp > 1e5 || exp < -1e5 || f.IsInf() { // +/- inf, exp is 0\n\t\tp.error(p.s.Loc(), \"number too big\")\n\t\treturn nil\n\t}\n\n\t// Note: Use the original string, do *not* round trip from\n\t// the big.Float as it can cause precision loss.\n\tr := NumberTerm(json.Number(s)).SetLocation(loc)\n\treturn r\n}\n\nfunc (p *Parser) parseString() *Term {\n\tif p.s.lit[0] == '\"' {\n\t\tvar s string\n\t\terr := json.Unmarshal([]byte(p.s.lit), &s)\n\t\tif err != nil {\n\t\t\tp.errorf(p.s.Loc(), \"illegal string literal: %s\", p.s.lit)\n\t\t\treturn nil\n\t\t}\n\t\tterm := StringTerm(s).SetLocation(p.s.Loc())\n\t\treturn term\n\t}\n\treturn p.parseRawString()\n}\n\nfunc (p *Parser) parseRawString() *Term {\n\tif len(p.s.lit) < 2 {\n\t\treturn nil\n\t}\n\tterm := StringTerm(p.s.lit[1 : len(p.s.lit)-1]).SetLocation(p.s.Loc())\n\treturn term\n}\n\n// this is the name to use for instantiating an empty set, e.g., `set()`.\nvar setConstructor = RefTerm(VarTerm(\"set\"))\n\nfunc (p *Parser) parseCall(operator *Term, offset int) (term *Term) {\n\n\tloc := operator.Location\n\tvar end int\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, end)\n\t}()\n\n\tp.scan() // steps over '('\n\n\tif p.s.tok == tokens.RParen { // no args, i.e. set() or any.func()\n\t\tend = p.s.tokEnd\n\t\tp.scanWS()\n\t\tif operator.Equal(setConstructor) {\n\t\t\treturn SetTerm()\n\t\t}\n\t\treturn CallTerm(operator)\n\t}\n\n\tif r := p.parseTermList(tokens.RParen, []*Term{operator}); r != nil {\n\t\tend = p.s.tokEnd\n\t\tp.scanWS()\n\t\treturn CallTerm(r...)\n\t}\n\n\treturn nil\n}\n\nfunc (p *Parser) parseRef(head *Term, offset int) (term *Term) {\n\n\tloc := head.Location\n\tvar end int\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, end)\n\t}()\n\n\tswitch h := head.Value.(type) {\n\tcase Var, *Array, Object, Set, *ArrayComprehension, *ObjectComprehension, *SetComprehension, Call:\n\t\t// ok\n\tdefault:\n\t\tp.errorf(loc, \"illegal ref (head cannot be %v)\", TypeName(h))\n\t}\n\n\tref := []*Term{head}\n\n\tfor {\n\t\tswitch p.s.tok {\n\t\tcase tokens.Dot:\n\t\t\tp.scanWS()\n\t\t\tif p.s.tok != tokens.Ident {\n\t\t\t\tp.illegal(\"expected %v\", tokens.Ident)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tref = append(ref, StringTerm(p.s.lit).SetLocation(p.s.Loc()))\n\t\t\tp.scanWS()\n\t\tcase tokens.LParen:\n\t\t\tterm = p.parseCall(p.setLoc(RefTerm(ref...), loc, offset, p.s.loc.Offset), offset)\n\t\t\tif term != nil {\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Whitespace:\n\t\t\t\t\tp.scan()\n\t\t\t\t\tend = p.s.lastEnd\n\t\t\t\t\treturn term\n\t\t\t\tcase tokens.Dot, tokens.LBrack:\n\t\t\t\t\tterm = p.parseRef(term, offset)\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = p.s.tokEnd\n\t\t\treturn term\n\t\tcase tokens.LBrack:\n\t\t\tp.scan()\n\t\t\tif term := p.parseTermInfixCall(); term != nil {\n\t\t\t\tif p.s.tok != tokens.RBrack {\n\t\t\t\t\tp.illegal(\"expected %v\", tokens.LBrack)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tref = append(ref, term)\n\t\t\t\tp.scanWS()\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase tokens.Whitespace:\n\t\t\tend = p.s.lastEnd\n\t\t\tp.scan()\n\t\t\treturn RefTerm(ref...)\n\t\tdefault:\n\t\t\tend = p.s.lastEnd\n\t\t\treturn RefTerm(ref...)\n\t\t}\n\t}\n}\n\nfunc (p *Parser) parseArray() (term *Term) {\n\n\tloc := p.s.Loc()\n\toffset := p.s.loc.Offset\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, p.s.tokEnd)\n\t}()\n\n\tp.scan()\n\n\tif p.s.tok == tokens.RBrack {\n\t\treturn ArrayTerm()\n\t}\n\n\tpotentialComprehension := true\n\n\t// Skip leading commas, eg [, x, y]\n\t// Supported for backwards compatibility. In the future\n\t// we should make this a parse error.\n\tif p.s.tok == tokens.Comma {\n\t\tpotentialComprehension = false\n\t\tp.scan()\n\t}\n\n\ts := p.save()\n\n\t// NOTE(tsandall): The parser cannot attempt a relational term here because\n\t// of ambiguity around comprehensions. For example, given:\n\t//\n\t//  {1 | 1}\n\t//\n\t// Does this represent a set comprehension or a set containing binary OR\n\t// call? We resolve the ambiguity by prioritizing comprehensions.\n\thead := p.parseTerm()\n\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.RBrack:\n\t\treturn ArrayTerm(head)\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif terms := p.parseTermList(tokens.RBrack, []*Term{head}); terms != nil {\n\t\t\treturn NewTerm(NewArray(terms...))\n\t\t}\n\t\treturn nil\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\t// Try to parse as if it is an array comprehension\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrack); body != nil {\n\t\t\t\treturn ArrayComprehensionTerm(head, body)\n\t\t\t}\n\t\t\tif p.s.tok != tokens.Comma {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// fall back to parsing as a normal array definition\n\t}\n\n\tp.restore(s)\n\n\tif terms := p.parseTermList(tokens.RBrack, nil); terms != nil {\n\t\treturn NewTerm(NewArray(terms...))\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseSetOrObject() (term *Term) {\n\tloc := p.s.Loc()\n\toffset := p.s.loc.Offset\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, p.s.tokEnd)\n\t}()\n\n\tp.scan()\n\n\tif p.s.tok == tokens.RBrace {\n\t\treturn ObjectTerm()\n\t}\n\n\tpotentialComprehension := true\n\n\t// Skip leading commas, eg {, x, y}\n\t// Supported for backwards compatibility. In the future\n\t// we should make this a parse error.\n\tif p.s.tok == tokens.Comma {\n\t\tpotentialComprehension = false\n\t\tp.scan()\n\t}\n\n\ts := p.save()\n\n\t// Try parsing just a single term first to give comprehensions higher\n\t// priority to \"or\" calls in ambiguous situations. Eg: { a | b }\n\t// will be a set comprehension.\n\t//\n\t// Note: We don't know yet if it is a set or object being defined.\n\thead := p.parseTerm()\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\treturn p.parseSet(s, head, potentialComprehension)\n\t\t}\n\tcase tokens.RBrace, tokens.Comma:\n\t\treturn p.parseSet(s, head, potentialComprehension)\n\tcase tokens.Colon:\n\t\treturn p.parseObject(head, potentialComprehension)\n\t}\n\n\tp.restore(s)\n\n\thead = p.parseTermInfixCallInList()\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.RBrace, tokens.Comma:\n\t\treturn p.parseSet(s, head, false)\n\tcase tokens.Colon:\n\t\t// It still might be an object comprehension, eg { a+1: b | ... }\n\t\treturn p.parseObject(head, potentialComprehension)\n\t}\n\n\tp.illegal(\"non-terminated set\")\n\treturn nil\n}\n\nfunc (p *Parser) parseSet(s *state, head *Term, potentialComprehension bool) *Term {\n\tswitch p.s.tok {\n\tcase tokens.RBrace:\n\t\treturn SetTerm(head)\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif terms := p.parseTermList(tokens.RBrace, []*Term{head}); terms != nil {\n\t\t\treturn SetTerm(terms...)\n\t\t}\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\t// Try to parse as if it is a set comprehension\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrace); body != nil {\n\t\t\t\treturn SetComprehensionTerm(head, body)\n\t\t\t}\n\t\t\tif p.s.tok != tokens.Comma {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// Fall back to parsing as normal set definition\n\t\tp.restore(s)\n\t\tif terms := p.parseTermList(tokens.RBrace, nil); terms != nil {\n\t\t\treturn SetTerm(terms...)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseObject(k *Term, potentialComprehension bool) *Term {\n\t// NOTE(tsandall): Assumption: this function is called after parsing the key\n\t// of the head element and then receiving a colon token from the scanner.\n\t// Advance beyond the colon and attempt to parse an object.\n\tif p.s.tok != tokens.Colon {\n\t\tpanic(\"expected colon\")\n\t}\n\tp.scan()\n\n\ts := p.save()\n\n\t// NOTE(sr): We first try to parse the value as a term (`v`), and see\n\t// if we can parse `{ x: v | ...}` as a comprehension.\n\t// However, if we encounter either a Comma or an RBace, it cannot be\n\t// parsed as a comprehension -- so we save double work further down\n\t// where `parseObjectFinish(k, v, false)` would only exercise the\n\t// same code paths once more.\n\tv := p.parseTerm()\n\tif v == nil {\n\t\treturn nil\n\t}\n\n\tpotentialRelation := true\n\tif potentialComprehension {\n\t\tswitch p.s.tok {\n\t\tcase tokens.RBrace, tokens.Comma:\n\t\t\tpotentialRelation = false\n\t\t\tfallthrough\n\t\tcase tokens.Or:\n\t\t\tif term := p.parseObjectFinish(k, v, true); term != nil {\n\t\t\t\treturn term\n\t\t\t}\n\t\t}\n\t}\n\n\tp.restore(s)\n\n\tif potentialRelation {\n\t\tv := p.parseTermInfixCallInList()\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch p.s.tok {\n\t\tcase tokens.RBrace, tokens.Comma:\n\t\t\treturn p.parseObjectFinish(k, v, false)\n\t\t}\n\t}\n\n\tp.illegal(\"non-terminated object\")\n\treturn nil\n}\n\nfunc (p *Parser) parseObjectFinish(key, val *Term, potentialComprehension bool) *Term {\n\tswitch p.s.tok {\n\tcase tokens.RBrace:\n\t\treturn ObjectTerm([2]*Term{key, val})\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrace); body != nil {\n\t\t\t\treturn ObjectComprehensionTerm(key, val, body)\n\t\t\t}\n\t\t} else {\n\t\t\tp.illegal(\"non-terminated object\")\n\t\t}\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif r := p.parseTermPairList(tokens.RBrace, [][2]*Term{{key, val}}); r != nil {\n\t\t\treturn ObjectTerm(r...)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermList(end tokens.Token, r []*Term) []*Term {\n\tif p.s.tok == end {\n\t\treturn r\n\t}\n\tfor {\n\t\tterm := p.parseTermInfixCallInList()\n\t\tif term != nil {\n\t\t\tr = append(r, term)\n\t\t\tswitch p.s.tok {\n\t\t\tcase end:\n\t\t\t\treturn r\n\t\t\tcase tokens.Comma:\n\t\t\t\tp.scan()\n\t\t\t\tif p.s.tok == end {\n\t\t\t\t\treturn r\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q or %q\", tokens.Comma, end))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseTermPairList(end tokens.Token, r [][2]*Term) [][2]*Term {\n\tif p.s.tok == end {\n\t\treturn r\n\t}\n\tfor {\n\t\tkey := p.parseTermInfixCallInList()\n\t\tif key != nil {\n\t\t\tswitch p.s.tok {\n\t\t\tcase tokens.Colon:\n\t\t\t\tp.scan()\n\t\t\t\tif val := p.parseTermInfixCallInList(); val != nil {\n\t\t\t\t\tr = append(r, [2]*Term{key, val})\n\t\t\t\t\tswitch p.s.tok {\n\t\t\t\t\tcase end:\n\t\t\t\t\t\treturn r\n\t\t\t\t\tcase tokens.Comma:\n\t\t\t\t\t\tp.scan()\n\t\t\t\t\t\tif p.s.tok == end {\n\t\t\t\t\t\t\treturn r\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q or %q\", tokens.Comma, end))\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q\", tokens.Colon))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseTermOp(values ...tokens.Token) *Term {\n\tfor i := range values {\n\t\tif p.s.tok == values[i] {\n\t\t\tr := RefTerm(VarTerm(fmt.Sprint(p.s.tok)).SetLocation(p.s.Loc())).SetLocation(p.s.Loc())\n\t\t\tp.scan()\n\t\t\treturn r\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermOpName(ref Ref, values ...tokens.Token) *Term {\n\tfor i := range values {\n\t\tif p.s.tok == values[i] {\n\t\t\tfor _, r := range ref {\n\t\t\t\tr.SetLocation(p.s.Loc())\n\t\t\t}\n\t\t\tt := RefTerm(ref...)\n\t\t\tt.SetLocation(p.s.Loc())\n\t\t\tp.scan()\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseVar() *Term {\n\n\ts := p.s.lit\n\n\tterm := VarTerm(s).SetLocation(p.s.Loc())\n\n\t// Update wildcard values with unique identifiers\n\tif term.Equal(Wildcard) {\n\t\tterm.Value = Var(p.genwildcard())\n\t}\n\n\treturn term\n}\n\nfunc (p *Parser) genwildcard() string {\n\tc := p.s.wildcard\n\tp.s.wildcard++\n\treturn fmt.Sprintf(\"%v%d\", WildcardPrefix, c)\n}\n\nfunc (p *Parser) error(loc *location.Location, reason string) {\n\tp.errorf(loc, reason)\n}\n\nfunc (p *Parser) errorf(loc *location.Location, f string, a ...interface{}) {\n\tmsg := strings.Builder{}\n\tfmt.Fprintf(&msg, f, a...)\n\n\tswitch len(p.s.hints) {\n\tcase 0: // nothing to do\n\tcase 1:\n\t\tmsg.WriteString(\" (hint: \")\n\t\tmsg.WriteString(p.s.hints[0])\n\t\tmsg.WriteRune(')')\n\tdefault:\n\t\tmsg.WriteString(\" (hints: \")\n\t\tfor i, h := range p.s.hints {\n\t\t\tif i > 0 {\n\t\t\t\tmsg.WriteString(\", \")\n\t\t\t}\n\t\t\tmsg.WriteString(h)\n\t\t}\n\t\tmsg.WriteRune(')')\n\t}\n\n\tp.s.errors = append(p.s.errors, &Error{\n\t\tCode:     ParseErr,\n\t\tMessage:  msg.String(),\n\t\tLocation: loc,\n\t\tDetails:  newParserErrorDetail(p.s.s.Bytes(), loc.Offset),\n\t})\n\tp.s.hints = nil\n}\n\nfunc (p *Parser) hint(f string, a ...interface{}) {\n\tp.s.hints = append(p.s.hints, fmt.Sprintf(f, a...))\n}\n\nfunc (p *Parser) illegal(note string, a ...interface{}) {\n\ttok := p.s.tok.String()\n\n\tif p.s.tok == tokens.Illegal {\n\t\tp.errorf(p.s.Loc(), \"illegal token\")\n\t\treturn\n\t}\n\n\ttokType := \"token\"\n\tif tokens.IsKeyword(p.s.tok) {\n\t\ttokType = \"keyword\"\n\t}\n\tif _, ok := futureKeywords[p.s.tok.String()]; ok {\n\t\ttokType = \"keyword\"\n\t}\n\n\tnote = fmt.Sprintf(note, a...)\n\tif len(note) > 0 {\n\t\tp.errorf(p.s.Loc(), \"unexpected %s %s: %s\", tok, tokType, note)\n\t} else {\n\t\tp.errorf(p.s.Loc(), \"unexpected %s %s\", tok, tokType)\n\t}\n}\n\nfunc (p *Parser) illegalToken() {\n\tp.illegal(\"\")\n}\n\nfunc (p *Parser) scan() {\n\tp.doScan(true)\n}\n\nfunc (p *Parser) scanWS() {\n\tp.doScan(false)\n}\n\nfunc (p *Parser) doScan(skipws bool) {\n\n\t// NOTE(tsandall): the last position is used to compute the \"text\" field for\n\t// complex AST nodes. Whitespace never affects the last position of an AST\n\t// node so do not update it when scanning.\n\tif p.s.tok != tokens.Whitespace {\n\t\tp.s.lastEnd = p.s.tokEnd\n\t\tp.s.skippedNL = false\n\t}\n\n\tvar errs []scanner.Error\n\tfor {\n\t\tvar pos scanner.Position\n\t\tp.s.tok, pos, p.s.lit, errs = p.s.s.Scan()\n\n\t\tp.s.tokEnd = pos.End\n\t\tp.s.loc.Row = pos.Row\n\t\tp.s.loc.Col = pos.Col\n\t\tp.s.loc.Offset = pos.Offset\n\t\tp.s.loc.Text = p.s.Text(pos.Offset, pos.End)\n\n\t\tfor _, err := range errs {\n\t\t\tp.error(p.s.Loc(), err.Message)\n\t\t}\n\n\t\tif len(errs) > 0 {\n\t\t\tp.s.tok = tokens.Illegal\n\t\t}\n\n\t\tif p.s.tok == tokens.Whitespace {\n\t\t\tif p.s.lit == \"\\n\" {\n\t\t\t\tp.s.skippedNL = true\n\t\t\t}\n\t\t\tif skipws {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif p.s.tok != tokens.Comment {\n\t\t\tbreak\n\t\t}\n\n\t\t// For backwards compatibility leave a nil\n\t\t// Text value if there is no text rather than\n\t\t// an empty string.\n\t\tvar commentText []byte\n\t\tif len(p.s.lit) > 1 {\n\t\t\tcommentText = []byte(p.s.lit[1:])\n\t\t}\n\t\tcomment := NewComment(commentText)\n\t\tcomment.SetLoc(p.s.Loc())\n\t\tp.s.comments = append(p.s.comments, comment)\n\t}\n}\n\nfunc (p *Parser) save() *state {\n\tcpy := *p.s\n\ts := *cpy.s\n\tcpy.s = &s\n\treturn &cpy\n}\n\nfunc (p *Parser) restore(s *state) {\n\tp.s = s\n}\n\nfunc setLocRecursive(x interface{}, loc *location.Location) {\n\tNewGenericVisitor(func(x interface{}) bool {\n\t\tif node, ok := x.(Node); ok {\n\t\t\tnode.SetLoc(loc)\n\t\t}\n\t\treturn false\n\t}).Walk(x)\n}\n\nfunc (p *Parser) setLoc(term *Term, loc *location.Location, offset, end int) *Term {\n\tif term != nil {\n\t\tcpy := *loc\n\t\tterm.Location = &cpy\n\t\tterm.Location.Text = p.s.Text(offset, end)\n\t}\n\treturn term\n}\n\nfunc (p *Parser) validateDefaultRuleValue(rule *Rule) bool {\n\tif rule.Head.Value == nil {\n\t\tp.error(rule.Loc(), \"illegal default rule (must have a value)\")\n\t\treturn false\n\t}\n\n\tvalid := true\n\tvis := NewGenericVisitor(func(x interface{}) bool {\n\t\tswitch x.(type) {\n\t\tcase *ArrayComprehension, *ObjectComprehension, *SetComprehension: // skip closures\n\t\t\treturn true\n\t\tcase Ref, Var, Call:\n\t\t\tp.error(rule.Loc(), fmt.Sprintf(\"illegal default rule (value cannot contain %v)\", TypeName(x)))\n\t\t\tvalid = false\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\tvis.Walk(rule.Head.Value.Value)\n\treturn valid\n}\n\n// We explicitly use yaml unmarshalling, to accommodate for the '_' in 'related_resources',\n// which isn't handled properly by json for some reason.\ntype rawAnnotation struct {\n\tScope            string                 `yaml:\"scope\"`\n\tTitle            string                 `yaml:\"title\"`\n\tDescription      string                 `yaml:\"description\"`\n\tOrganizations    []string               `yaml:\"organizations\"`\n\tRelatedResources []interface{}          `yaml:\"related_resources\"`\n\tAuthors          []interface{}          `yaml:\"authors\"`\n\tSchemas          []rawSchemaAnnotation  `yaml:\"schemas\"`\n\tCustom           map[string]interface{} `yaml:\"custom\"`\n}\n\ntype rawSchemaAnnotation map[string]interface{}\n\ntype metadataParser struct {\n\tbuf      *bytes.Buffer\n\tcomments []*Comment\n\tloc      *location.Location\n}\n\nfunc newMetadataParser(loc *Location) *metadataParser {\n\treturn &metadataParser{loc: loc, buf: bytes.NewBuffer(nil)}\n}\n\nfunc (b *metadataParser) Append(c *Comment) {\n\tb.buf.Write(bytes.TrimPrefix(c.Text, []byte(\" \")))\n\tb.buf.WriteByte('\\n')\n\tb.comments = append(b.comments, c)\n}\n\nvar yamlLineErrRegex = regexp.MustCompile(`^yaml: line ([[:digit:]]+):`)\n\nfunc (b *metadataParser) Parse() (*Annotations, error) {\n\n\tvar raw rawAnnotation\n\n\tif len(bytes.TrimSpace(b.buf.Bytes())) == 0 {\n\t\treturn nil, fmt.Errorf(\"expected METADATA block, found whitespace\")\n\t}\n\n\tif err := yaml.Unmarshal(b.buf.Bytes(), &raw); err != nil {\n\t\tmatch := yamlLineErrRegex.FindStringSubmatch(err.Error())\n\t\tif len(match) == 2 {\n\t\t\tn, err2 := strconv.Atoi(match[1])\n\t\t\tif err2 == nil {\n\t\t\t\tindex := n - 1 // line numbering is 1-based so subtract one from row\n\t\t\t\tif index >= len(b.comments) {\n\t\t\t\t\tb.loc = b.comments[len(b.comments)-1].Location\n\t\t\t\t} else {\n\t\t\t\t\tb.loc = b.comments[index].Location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tvar result Annotations\n\tresult.Scope = raw.Scope\n\tresult.Title = raw.Title\n\tresult.Description = raw.Description\n\tresult.Organizations = raw.Organizations\n\n\tfor _, v := range raw.RelatedResources {\n\t\trr, err := parseRelatedResource(v)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid related-resource definition %s: %w\", v, err)\n\t\t}\n\t\tresult.RelatedResources = append(result.RelatedResources, rr)\n\t}\n\n\tfor _, pair := range raw.Schemas {\n\t\tk, v := unwrapPair(pair)\n\n\t\tvar a SchemaAnnotation\n\t\tvar err error\n\n\t\ta.Path, err = ParseRef(k)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid document reference\")\n\t\t}\n\n\t\tswitch v := v.(type) {\n\t\tcase string:\n\t\t\ta.Schema, err = parseSchemaRef(v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase map[interface{}]interface{}:\n\t\t\tw, err := convertYAMLMapKeyTypes(v, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, \"invalid schema definition\")\n\t\t\t}\n\t\t\ta.Definition = &w\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"invalid schema declaration for path %q\", k)\n\t\t}\n\n\t\tresult.Schemas = append(result.Schemas, &a)\n\t}\n\n\tfor _, v := range raw.Authors {\n\t\tauthor, err := parseAuthor(v)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid author definition %s: %w\", v, err)\n\t\t}\n\t\tresult.Authors = append(result.Authors, author)\n\t}\n\n\tresult.Custom = make(map[string]interface{})\n\tfor k, v := range raw.Custom {\n\t\tval, err := convertYAMLMapKeyTypes(v, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult.Custom[k] = val\n\t}\n\n\tresult.Location = b.loc\n\treturn &result, nil\n}\n\nfunc unwrapPair(pair map[string]interface{}) (k string, v interface{}) {\n\tfor k, v = range pair {\n\t}\n\treturn\n}\n\nvar errInvalidSchemaRef = fmt.Errorf(\"invalid schema reference\")\n\n// NOTE(tsandall): 'schema' is not registered as a root because it's not\n// supported by the compiler or evaluator today. Once we fix that, we can remove\n// this function.\nfunc parseSchemaRef(s string) (Ref, error) {\n\n\tterm, err := ParseTerm(s)\n\tif err == nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\tif term.Equal(SchemaRootDocument) {\n\t\t\t\treturn SchemaRootRef.Copy(), nil\n\t\t\t}\n\t\tcase Ref:\n\t\t\tif v.HasPrefix(SchemaRootRef) {\n\t\t\t\treturn v, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errInvalidSchemaRef\n}\n\nfunc parseRelatedResource(rr interface{}) (*RelatedResourceAnnotation, error) {\n\trr, err := convertYAMLMapKeyTypes(rr, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch rr := rr.(type) {\n\tcase string:\n\t\tif len(rr) > 0 {\n\t\t\tu, err := url.Parse(rr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &RelatedResourceAnnotation{Ref: *u}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"ref URL may not be empty string\")\n\tcase map[string]interface{}:\n\t\tdescription := strings.TrimSpace(getSafeString(rr, \"description\"))\n\t\tref := strings.TrimSpace(getSafeString(rr, \"ref\"))\n\t\tif len(ref) > 0 {\n\t\t\tu, err := url.Parse(ref)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &RelatedResourceAnnotation{Description: description, Ref: *u}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"'ref' value required in object\")\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid value type, must be string or map\")\n}\n\nfunc parseAuthor(a interface{}) (*AuthorAnnotation, error) {\n\ta, err := convertYAMLMapKeyTypes(a, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch a := a.(type) {\n\tcase string:\n\t\treturn parseAuthorString(a)\n\tcase map[string]interface{}:\n\t\tname := strings.TrimSpace(getSafeString(a, \"name\"))\n\t\temail := strings.TrimSpace(getSafeString(a, \"email\"))\n\t\tif len(name) > 0 || len(email) > 0 {\n\t\t\treturn &AuthorAnnotation{name, email}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"'name' and/or 'email' values required in object\")\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid value type, must be string or map\")\n}\n\nfunc getSafeString(m map[string]interface{}, k string) string {\n\tif v, found := m[k]; found {\n\t\tif s, ok := v.(string); ok {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn \"\"\n}\n\nconst emailPrefix = \"<\"\nconst emailSuffix = \">\"\n\n// parseAuthor parses a string into an AuthorAnnotation. If the last word of the input string is enclosed within <>,\n// it is extracted as the author's email. The email may not contain whitelines, as it then will be interpreted as\n// multiple words.\nfunc parseAuthorString(s string) (*AuthorAnnotation, error) {\n\tparts := strings.Fields(s)\n\n\tif len(parts) == 0 {\n\t\treturn nil, fmt.Errorf(\"author is an empty string\")\n\t}\n\n\tnamePartCount := len(parts)\n\ttrailing := parts[namePartCount-1]\n\tvar email string\n\tif len(trailing) >= len(emailPrefix)+len(emailSuffix) && strings.HasPrefix(trailing, emailPrefix) &&\n\t\tstrings.HasSuffix(trailing, emailSuffix) {\n\t\temail = trailing[len(emailPrefix):]\n\t\temail = email[0 : len(email)-len(emailSuffix)]\n\t\tnamePartCount = namePartCount - 1\n\t}\n\n\tname := strings.Join(parts[0:namePartCount], \" \")\n\n\treturn &AuthorAnnotation{Name: name, Email: email}, nil\n}\n\nfunc convertYAMLMapKeyTypes(x interface{}, path []string) (interface{}, error) {\n\tvar err error\n\tswitch x := x.(type) {\n\tcase map[interface{}]interface{}:\n\t\tresult := make(map[string]interface{}, len(x))\n\t\tfor k, v := range x {\n\t\t\tstr, ok := k.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid map key type(s): %v\", strings.Join(path, \"/\"))\n\t\t\t}\n\t\t\tresult[str], err = convertYAMLMapKeyTypes(v, append(path, str))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn result, nil\n\tcase []interface{}:\n\t\tfor i := range x {\n\t\t\tx[i], err = convertYAMLMapKeyTypes(x[i], append(path, fmt.Sprintf(\"%d\", i)))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn x, nil\n\tdefault:\n\t\treturn x, nil\n\t}\n}\n\n// futureKeywords is the source of truth for future keywords that will\n// eventually become standard keywords inside of Rego.\nvar futureKeywords = map[string]tokens.Token{\n\t\"in\":    tokens.In,\n\t\"every\": tokens.Every,\n}\n\nfunc (p *Parser) futureImport(imp *Import, allowedFutureKeywords map[string]tokens.Token) {\n\tpath := imp.Path.Value.(Ref)\n\n\tif len(path) == 1 || !path[1].Equal(StringTerm(\"keywords\")) {\n\t\tp.errorf(imp.Path.Location, \"invalid import, must be `future.keywords`\")\n\t\treturn\n\t}\n\n\tif imp.Alias != \"\" {\n\t\tp.errorf(imp.Path.Location, \"future keyword imports cannot be aliased\")\n\t\treturn\n\t}\n\n\tkwds := make([]string, 0, len(allowedFutureKeywords))\n\tfor k := range allowedFutureKeywords {\n\t\tkwds = append(kwds, k)\n\t}\n\n\tswitch len(path) {\n\tcase 2: // all keywords imported, nothing to do\n\tcase 3: // one keyword imported\n\t\tkw, ok := path[2].Value.(String)\n\t\tif !ok {\n\t\t\tp.errorf(imp.Path.Location, \"invalid import, must be `future.keywords.x`, e.g. `import future.keywords.in`\")\n\t\t\treturn\n\t\t}\n\t\tkeyword := string(kw)\n\t\t_, ok = allowedFutureKeywords[keyword]\n\t\tif !ok {\n\t\t\tsort.Strings(kwds) // so the error message is stable\n\t\t\tp.errorf(imp.Path.Location, \"unexpected keyword, must be one of %v\", kwds)\n\t\t\treturn\n\t\t}\n\n\t\tkwds = []string{keyword} // overwrite\n\t}\n\tfor _, kw := range kwds {\n\t\tp.s.s.AddKeyword(kw, allowedFutureKeywords[kw])\n\t}\n}\n", "// Copyright 2016 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\n\npackage ast\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/open-policy-agent/opa/ast/internal/tokens\"\n)\n\nconst (\n\ttestModule = `\n# This policy module belongs the opa.example package.\npackage opa.examples\n\n# Refer to data.servers as servers.\nimport data.servers\n# Refer to the data.networks as networks.\nimport data.networks\n# Refer to the data.ports as ports.\nimport data.ports\n\n# A server exists in the violations set if...\nviolations[server] {\n    # ...the server exists\n    server = servers[i]\n    # ...and any of the server\u2019s protocols is HTTP\n    server.protocols[j] = \"http\"\n    # ...and the server is public.\n    public_servers[server]\n}\n\n# A server exists in the public_servers set if...\npublic_servers[server] {\n\t# Semicolons are optional. Can group expressions onto one line.\n    server = servers[i]; server.ports[j] = ports[k].id \t# ...and the server is connected to a port\n    ports[k].networks[l] = networks[m].id; \t\t\t\t# ...and the port is connected to a network\n    networks[m].public = true\t\t\t\t\t\t\t# ...and the network is public.\n}`\n)\n\nfunc TestNumberTerms(t *testing.T) {\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"0\", \"0\"},\n\t\t{\"100\", \"100\"},\n\t\t{\"-1\", \"-1\"},\n\t\t{\"1e6\", \"1e6\"},\n\t\t{\"1.1e6\", \"1.1e6\"},\n\t\t{\"-1e-6\", \"-1e-6\"},\n\t\t{\"1E6\", \"1E6\"},\n\t\t{\"0.1\", \"0.1\"},\n\t\t{\".1\", \"0.1\"},\n\t\t{\".0001\", \"0.0001\"},\n\t\t{\"-.1\", \"-0.1\"},\n\t\t{\"-0.0001\", \"-0.0001\"},\n\t\t{\"1e1000\", \"1e1000\"},\n\t\t{\"0e1\", \"0\"},\n\t\t{\"-0.1\", \"-0.1\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult, err := ParseTerm(tc.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", tc.input, err)\n\t\t} else {\n\t\t\te := NumberTerm(json.Number(tc.expected))\n\t\t\tif !result.Equal(e) {\n\t\t\t\tt.Errorf(\"Expected %v for %v but got: %v\", e, tc.input, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStringTerms(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"\"`, \"\"},                   // empty\n\t\t{`\" \"`, \" \"},                 // whitespace\n\t\t{`\"\\\"\"`, `\"`},                // escaped quote\n\t\t{`\"http:\\/\\/\"`, `http://`},   // escaped solidus\n\t\t{`\"\\u0001\"`, \"\\x01\"},         // control code\n\t\t{`\"foo\\u005C\"`, \"foo\\u005c\"}, // unicode (upper hex)\n\t\t{`\"foo\\u005c\"`, \"foo\\u005C\"}, // unicode (lower hex)\n\t\t{`\"\\uD834\\uDD1E\"`, `\ud834\udd1e`},      // g-clef\n\t\t{\"`hi\\\\there`\", `hi\\there`},  // basic raw string\n\t\t{\"`foo\\nbar\\n    baz`\", `foo\nbar\n    baz`}, // multi-line raw string\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult, err := ParseTerm(tc.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", tc.input, err)\n\t\t} else {\n\t\t\ts := StringTerm(tc.expected)\n\t\t\tif !result.Equal(s) {\n\t\t\t\tt.Errorf(\"Expected %v for %v but got: %v\", s, tc.input, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestScalarTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"null\", \"null\", NullTerm())\n\tassertParseOneTerm(t, \"true\", \"true\", BooleanTerm(true))\n\tassertParseOneTerm(t, \"false\", \"false\", BooleanTerm(false))\n\tassertParseOneTerm(t, \"integer\", \"53\", IntNumberTerm(53))\n\tassertParseOneTerm(t, \"integer2\", \"-53\", IntNumberTerm(-53))\n\tassertParseOneTerm(t, \"float\", \"16.7\", FloatNumberTerm(16.7))\n\tassertParseOneTerm(t, \"float2\", \"-16.7\", FloatNumberTerm(-16.7))\n\tassertParseOneTerm(t, \"exponent\", \"6e7\", FloatNumberTerm(6e7))\n\tassertParseOneTerm(t, \"string\", \"\\\"a string\\\"\", StringTerm(\"a string\"))\n\tassertParseOneTerm(t, \"string\", \"\\\"a string u6abc7def8abc0def with unicode\\\"\", StringTerm(\"a string u6abc7def8abc0def with unicode\"))\n\tassertParseErrorContains(t, \"hex\", \"6abc\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-terminated\", \"\\\"foo\", \"non-terminated string\")\n\tassertParseErrorContains(t, \"non-terminated-raw\", \"`foo\", \"non-terminated string\")\n\tassertParseErrorContains(t, \"non-string\", \"'a string'\", \"illegal token\")\n\tassertParseErrorContains(t, \"non-number\", \"6zxy\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number2\", \"6d7\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number3\", \"6\\\"foo\\\"\", \"expected exactly one statement\") // ??\n\tassertParseErrorContains(t, \"non-number4\", \"6true\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number5\", \"6false\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number6\", \"6[null, null]\", \"illegal ref (head cannot be number)\") // ??\n\tassertParseErrorContains(t, \"non-number7\", \"6{\\\"foo\\\": \\\"bar\\\"}\", \"expected exactly one statement\")\n\tassertParseErrorContains(t, \"non-number8\", \".0.\", \"expected fraction\")\n\tassertParseErrorContains(t, \"non-number9\", \"0e\", \"expected exponent\")\n\tassertParseErrorContains(t, \"non-number10\", \"0e.\", \"expected exponent\")\n\tassertParseErrorContains(t, \"non-number11\", \"0F\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number12\", \"00\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number13\", \"00.1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number14\", \"-00\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number15\", \"-00.1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number16\", \"-00.01\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number17\", \"00e1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number18\", \"-00e1\", \"expected number\")\n\tassertParseErrorContains(t, \"parsing float fails\", \"7e3000000000\", \"invalid float\")\n\tassertParseErrorContains(t, \"float is +inf\", \"10245423601e680507880\", \"number too big\")\n\tassertParseErrorContains(t, \"float is -inf\", \"-10245423601e680507880\", \"number too big\")\n\n\t// f := big.NewFloat(1); f.SetMantExp(f, -1e6); f.String() // => 1.010034059e-301030 (this takes ~9s)\n\tassertParseErrorContains(t, \"float exp < -1e5\", \"1.010034059e-301030\", \"number too big\")\n\n\t// g := big.NewFloat(1); g.SetMantExp(g, 1e6); g.String() // => 9.900656229e+301029\n\tassertParseErrorContains(t, \"float exp > 1e5\", \"9.900656229e+301029\", \"number too big\")\n}\n\nfunc TestVarTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"var\", \"foo\", VarTerm(\"foo\"))\n\tassertParseOneTerm(t, \"var\", \"foo_bar\", VarTerm(\"foo_bar\"))\n\tassertParseOneTerm(t, \"var\", \"foo0\", VarTerm(\"foo0\"))\n\tassertParseOneTerm(t, \"import prefix\", \"imports\", VarTerm(\"imports\"))\n\tassertParseOneTerm(t, \"not prefix\", \"not_foo\", VarTerm(\"not_foo\"))\n\tassertParseOneTerm(t, `package prefix`, \"packages\", VarTerm(\"packages\"))\n\tassertParseOneTerm(t, `true prefix`, \"trueish\", VarTerm(\"trueish\"))\n\tassertParseOneTerm(t, `false prefix`, \"false_flag\", VarTerm(\"false_flag\"))\n\tassertParseOneTerm(t, `null prefix`, \"nullable\", VarTerm(\"nullable\"))\n\tassertParseError(t, \"illegal token\", `\ufa7d`)\n\tassertParseError(t, \"not keyword\", \"not\")\n\tassertParseError(t, `package keyword`, \"package\")\n\tassertParseError(t, \"import keyword\", \"import\")\n\tassertParseError(t, \"import invalid path\", \"import x.\")\n}\n\nfunc TestRefTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"constants\", \"foo.bar.baz\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"baz\")))\n\tassertParseOneTerm(t, \"constants 2\", \"foo.bar[0].baz\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), IntNumberTerm(0), StringTerm(\"baz\")))\n\tassertParseOneTerm(t, \"variables\", \"foo.bar[0].baz[i]\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), IntNumberTerm(0), StringTerm(\"baz\"), VarTerm(\"i\")))\n\tassertParseOneTerm(t, \"spaces\", \"foo[\\\"white space\\\"].bar\", RefTerm(VarTerm(\"foo\"), StringTerm(\"white space\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"nested\", \"foo[baz[1][borge[i]]].bar\", RefTerm(\n\t\tVarTerm(\"foo\"),\n\t\tRefTerm(\n\t\t\tVarTerm(\"baz\"), IntNumberTerm(1), RefTerm(\n\t\t\t\tVarTerm(\"borge\"), VarTerm(\"i\"),\n\t\t\t),\n\t\t),\n\t\tStringTerm(\"bar\"),\n\t))\n\tassertParseOneTerm(t, \"composite operand 1\", \"foo[[1,2,3]].bar\", RefTerm(VarTerm(\"foo\"), ArrayTerm(NumberTerm(\"1\"), NumberTerm(\"2\"), NumberTerm(\"3\")), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"composite operand 2\", `foo[{\"foo\": 2}].bar`, RefTerm(VarTerm(\"foo\"), ObjectTerm(Item(StringTerm(\"foo\"), NumberTerm(\"2\"))), StringTerm(\"bar\")))\n\n\tassertParseError(t, \"missing component 1\", \"foo.\")\n\tassertParseError(t, \"missing component 2\", \"foo[].bar\")\n\tassertParseError(t, \"invalid composite operand\", \"foo[1,2]\")\n\tassertParseError(t, \"invalid call\", \"bar(..\")\n\tassertParseError(t, \"invalid ref\", \"bar[..\")\n\tassertParseError(t, \"invalid ref head type number\", \"0[0]\")\n\tassertParseError(t, \"invalid ref head type boolean\", \"true[0]\")\n\tassertParseError(t, \"invalid ref head type string\", `\"foo\"[0]`)\n\tassertParseError(t, \"invalid ref head type null\", `null[0]`)\n}\n\nfunc TestObjectWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"{\\\"abc\\\": 7, \\\"def\\\": 8}\", ObjectTerm(Item(StringTerm(\"abc\"), IntNumberTerm(7)), Item(StringTerm(\"def\"), IntNumberTerm(8))))\n\tassertParseOneTerm(t, \"bool\", \"{\\\"abc\\\": false, \\\"def\\\": true}\", ObjectTerm(Item(StringTerm(\"abc\"), BooleanTerm(false)), Item(StringTerm(\"def\"), BooleanTerm(true))))\n\tassertParseOneTerm(t, \"string\", \"{\\\"abc\\\": \\\"foo\\\", \\\"def\\\": \\\"bar\\\"}\", ObjectTerm(Item(StringTerm(\"abc\"), StringTerm(\"foo\")), Item(StringTerm(\"def\"), StringTerm(\"bar\"))))\n\tassertParseOneTerm(t, \"mixed\", \"{\\\"abc\\\": 7, \\\"def\\\": null}\", ObjectTerm(Item(StringTerm(\"abc\"), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"number key\", \"{8: 7, \\\"def\\\": null}\", ObjectTerm(Item(IntNumberTerm(8), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"number key 2\", \"{8.5: 7, \\\"def\\\": null}\", ObjectTerm(Item(FloatNumberTerm(8.5), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"bool key\", \"{true: false}\", ObjectTerm(Item(BooleanTerm(true), BooleanTerm(false))))\n\tassertParseOneTerm(t, \"trailing comma\", `{\"a\": \"bar\", \"b\": 64, }`, ObjectTerm(Item(StringTerm(\"a\"), StringTerm(\"bar\")), Item(StringTerm(\"b\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"leading comma\", `{, \"a\": \"bar\", \"b\": 64 }`, ObjectTerm(Item(StringTerm(\"a\"), StringTerm(\"bar\")), Item(StringTerm(\"b\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", `{, 1 | 1: \"bar\"}`, ObjectTerm(Item(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\")), StringTerm(\"bar\"))))\n}\n\nfunc TestObjectWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var keys\", \"{foo: \\\"bar\\\", bar: 64}\", ObjectTerm(Item(VarTerm(\"foo\"), StringTerm(\"bar\")), Item(VarTerm(\"bar\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"nested var keys\", \"{baz: {foo: \\\"bar\\\", bar: qux}}\", ObjectTerm(Item(VarTerm(\"baz\"), ObjectTerm(Item(VarTerm(\"foo\"), StringTerm(\"bar\")), Item(VarTerm(\"bar\"), VarTerm(\"qux\"))))))\n\tassertParseOneTerm(t, \"ambiguous or\", `{ a: b+c | d }`, ObjectTerm(Item(VarTerm(\"a\"), CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), VarTerm(\"b\"), VarTerm(\"c\")), VarTerm(\"d\")))))\n}\n\nfunc TestObjectWithRelation(t *testing.T) {\n\tassertParseOneTerm(t, \"relation term value\", `{\"x\": 1+1}`, ObjectTerm(\n\t\tItem(StringTerm(\"x\"), CallTerm(RefTerm(VarTerm(\"plus\")), IntNumberTerm(1), IntNumberTerm(1))),\n\t))\n\tassertParseError(t, \"invalid relation term value\", `{\"x\": 0= }`)\n}\n\nfunc TestObjectFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"{foo: bar, baz: [], qux: corge\")\n\tassertParseError(t, \"non-terminated 2\", \"{foo: bar, baz: [], qux: \")\n\tassertParseError(t, \"non-terminated 3\", \"{foo: bar, baz: [], qux \")\n\tassertParseError(t, \"non-terminated 4\", \"{foo: bar, baz: [], \")\n\tassertParseError(t, \"missing separator\", \"{foo: bar baz: []}\")\n\tassertParseError(t, \"missing start\", \"foo: bar, baz: [], qux: corge}\")\n\tassertParseError(t, \"double comma\", \"{a:1,,b:2}\")\n\tassertParseError(t, \"leading double comma\", \"{,,a:1}\")\n\tassertParseError(t, \"trailing double comma\", \"{a:1,,}\")\n}\n\nfunc TestArrayWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"[1,2,3,4.5]\", ArrayTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), FloatNumberTerm(4.5)))\n\tassertParseOneTerm(t, \"bool\", \"[true, false, true]\", ArrayTerm(BooleanTerm(true), BooleanTerm(false), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"string\", \"[\\\"foo\\\", \\\"bar\\\"]\", ArrayTerm(StringTerm(\"foo\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"mixed\", \"[null, true, 42]\", ArrayTerm(NullTerm(), BooleanTerm(true), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"trailing comma - one element\", \"[null, ]\", ArrayTerm(NullTerm()))\n\tassertParseOneTerm(t, \"trailing comma\", \"[null, true, ]\", ArrayTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma\", \"[, null, true]\", ArrayTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", \"[, 1 | 1]\", ArrayTerm(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\"))))\n\tassertParseOneTerm(t, \"ambiguous or\", \"[ 1 + 2 | 3 ]\", ArrayTerm(CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")), NumberTerm(\"3\"))))\n}\n\nfunc TestArrayWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var elements\", \"[foo, bar, 42]\", ArrayTerm(VarTerm(\"foo\"), VarTerm(\"bar\"), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"nested var elements\", \"[[foo, true], [null, bar], 42]\", ArrayTerm(ArrayTerm(VarTerm(\"foo\"), BooleanTerm(true)), ArrayTerm(NullTerm(), VarTerm(\"bar\")), IntNumberTerm(42)))\n}\n\nfunc TestArrayFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"[foo, bar\")\n\tassertParseError(t, \"non-terminated 2\", \"[foo, bar, \")\n\tassertParseError(t, \"missing separator\", \"[foo bar]\")\n\tassertParseError(t, \"missing start\", \"foo, bar, baz]\")\n\tassertParseError(t, \"bad term\", \"[!!!]\")\n\tassertParseError(t, \"double comma\", \"[a,,b]\")\n\tassertParseError(t, \"leading double comma\", \"[,,a]\")\n\tassertParseError(t, \"trailing double comma\", \"[a,,]\")\n}\n\nfunc TestSetWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"{1,2,3,4.5}\", SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), FloatNumberTerm(4.5)))\n\tassertParseOneTerm(t, \"bool\", \"{true, false, true}\", SetTerm(BooleanTerm(true), BooleanTerm(false), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"string\", \"{\\\"foo\\\", \\\"bar\\\"}\", SetTerm(StringTerm(\"foo\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"mixed\", \"{null, true, 42}\", SetTerm(NullTerm(), BooleanTerm(true), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"trailing comma\", \"{null, true,}\", SetTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma\", \"{, null, true}\", SetTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", \"{, 1 | 1}\", SetTerm(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\"))))\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ 1 + 2 | 3}\", SetTerm(CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")), NumberTerm(\"3\"))))\n}\n\nfunc TestSetWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var elements\", \"{foo, bar, 42}\", SetTerm(VarTerm(\"foo\"), VarTerm(\"bar\"), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"nested var elements\", \"{[foo, true], {null, bar}, set()}\", SetTerm(ArrayTerm(VarTerm(\"foo\"), BooleanTerm(true)), SetTerm(NullTerm(), VarTerm(\"bar\")), SetTerm()))\n}\n\nfunc TestSetFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"set(\")\n\tassertParseError(t, \"non-terminated 2\", \"{foo, bar\")\n\tassertParseError(t, \"non-terminated 3\", \"{foo, bar, \")\n\tassertParseError(t, \"missing separator\", \"{foo bar}\")\n\tassertParseError(t, \"missing start\", \"foo, bar, baz}\")\n\tassertParseError(t, \"bad term\", \"{!!!}\")\n\tassertParseError(t, \"double comma\", \"{a,,b}\")\n\tassertParseError(t, \"leading double comma\", \"{,,a}\")\n\tassertParseError(t, \"trailing double comma\", \"{a,,}\")\n}\n\nfunc TestEmptyComposites(t *testing.T) {\n\tassertParseOneTerm(t, \"empty object\", \"{}\", ObjectTerm())\n\tassertParseOneTerm(t, \"empty array\", \"[]\", ArrayTerm())\n\tassertParseOneTerm(t, \"empty set\", \"set()\", SetTerm())\n}\n\nfunc TestNestedComposites(t *testing.T) {\n\tassertParseOneTerm(t, \"nested composites\", \"[{foo: [\\\"bar\\\", {baz}]}]\", ArrayTerm(ObjectTerm(Item(VarTerm(\"foo\"), ArrayTerm(StringTerm(\"bar\"), SetTerm(VarTerm(\"baz\")))))))\n}\n\nfunc TestCompositesWithRefs(t *testing.T) {\n\tref1 := RefTerm(VarTerm(\"a\"), VarTerm(\"i\"), StringTerm(\"b\"))\n\tref2 := RefTerm(VarTerm(\"c\"), IntNumberTerm(0), StringTerm(\"d\"), StringTerm(\"e\"), VarTerm(\"j\"))\n\tassertParseOneTerm(t, \"ref keys\", \"[{a[i].b: 8, c[0][\\\"d\\\"].e[j]: f}]\", ArrayTerm(ObjectTerm(Item(ref1, IntNumberTerm(8)), Item(ref2, VarTerm(\"f\")))))\n\tassertParseOneTerm(t, \"ref values\", \"[{8: a[i].b, f: c[0][\\\"d\\\"].e[j]}]\", ArrayTerm(ObjectTerm(Item(IntNumberTerm(8), ref1), Item(VarTerm(\"f\"), ref2))))\n\tassertParseOneTerm(t, \"ref values (sets)\", `{a[i].b, {c[0][\"d\"].e[j]}}`, SetTerm(ref1, SetTerm(ref2)))\n}\n\nfunc TestArrayComprehensions(t *testing.T) {\n\n\tnestedTerm := `[{\"x\": [a[i] | xs = [{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"]; xs[j].a[k] = \"foo\"]}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tArrayComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tArrayComprehensionTerm(\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"[ a | b ]\", ArrayComprehensionTerm(\n\t\tVarTerm(\"a\"),\n\t\tMustParseBody(\"b\"),\n\t))\n}\n\nfunc TestObjectComprehensions(t *testing.T) {\n\tnestedTerm := `[{\"x\": {a[i]: b[i] | xs = {\"foo\":{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"}; xs[j].a[k] = \"foo\"}}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tObjectComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tRefTerm(VarTerm(\"b\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tObjectComprehensionTerm(\n\t\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ 1+2: 3 | 4}\", ObjectComprehensionTerm(\n\t\tCallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")),\n\t\tNumberTerm(\"3\"),\n\t\tMustParseBody(\"4\"),\n\t))\n}\n\nfunc TestObjectComprehensionError(t *testing.T) {\n\tassertParseError(t, \"bad body\", \"{x: y|!!!}\")\n}\n\nfunc TestSetComprehensions(t *testing.T) {\n\tnestedTerm := `[{\"x\": {a[i] | xs = {{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"}; xs[j].a[k] = \"foo\"}}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tSetComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tSetComprehensionTerm(\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ a | b }\", SetComprehensionTerm(\n\t\tVarTerm(\"a\"),\n\t\tMustParseBody(\"b\"),\n\t))\n}\n\nfunc TestSetComprehensionError(t *testing.T) {\n\tassertParseError(t, \"bad body\", \"{x|!!!}\")\n}\n\nfunc TestSetComprehensionsAlone(t *testing.T) {\n\tinput := `{k | a = [1,2,3]; a[k]}`\n\n\texpected := SetComprehensionTerm(\n\t\tVarTerm(\"k\"),\n\t\tNewBody(\n\t\t\tEquality.Expr(\n\t\t\t\tVarTerm(\"a\"),\n\t\t\t\tArrayTerm(NumberTerm(\"1\"), NumberTerm(\"2\"), NumberTerm(\"3\")),\n\t\t\t),\n\t\t\t&Expr{\n\t\t\t\tTerms: RefTerm(VarTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t},\n\t\t),\n\t)\n\n\tassertParseOneTerm(t, \"alone\", input, expected)\n}\n\nfunc TestCalls(t *testing.T) {\n\n\tassertParseOneExpr(t, \"ne\", \"100 != 200\", NotEqual.Expr(IntNumberTerm(100), IntNumberTerm(200)))\n\tassertParseOneExpr(t, \"gt\", \"17.4 > \\\"hello\\\"\", GreaterThan.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"lt\", \"17.4 < \\\"hello\\\"\", LessThan.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"gte\", \"17.4 >= \\\"hello\\\"\", GreaterThanEq.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"lte\", \"17.4 <= \\\"hello\\\"\", LessThanEq.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\n\tleft2 := ArrayTerm(ObjectTerm(Item(FloatNumberTerm(14.2), BooleanTerm(true)), Item(StringTerm(\"a\"), NullTerm())))\n\tright2 := ObjectTerm(Item(VarTerm(\"foo\"), ObjectTerm(Item(RefTerm(VarTerm(\"a\"), StringTerm(\"b\"), IntNumberTerm(0)), ArrayTerm(IntNumberTerm(10))))))\n\tassertParseOneExpr(t, \"composites\", \"[{14.2: true, \\\"a\\\": null}] != {foo: {a.b[0]: [10]}}\", NotEqual.Expr(left2, right2))\n\n\tassertParseOneExpr(t, \"plus\", \"1 + 2\", Plus.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"minus\", \"1 - 2\", Minus.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"mul\", \"1 * 2\", Multiply.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"div\", \"1 / 2\", Divide.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"rem\", \"3 % 2\", Rem.Expr(IntNumberTerm(3), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"and\", \"{1,2,3} & {2,3,4}\", And.Expr(SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3)), SetTerm(IntNumberTerm(2), IntNumberTerm(3), IntNumberTerm(4))))\n\tassertParseOneExpr(t, \"or\", \"{1,2,3} | {3,4,5}\", Or.Expr(SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3)), SetTerm(IntNumberTerm(3), IntNumberTerm(4), IntNumberTerm(5))))\n\n\tassertParseOneExpr(t, \"call\", \"count([true, false])\", Count.Expr(ArrayTerm(BooleanTerm(true), BooleanTerm(false))))\n\tassertParseOneExpr(t, \"call-ref\", \"foo.bar(1)\", NewExpr(\n\t\t[]*Term{RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\tIntNumberTerm(1)}))\n\tassertParseOneExpr(t, \"call-void\", \"foo()\", NewExpr(\n\t\t[]*Term{RefTerm(VarTerm(\"foo\"))}))\n\n\topts := ParserOptions{FutureKeywords: []string{\"in\"}}\n\tassertParseOneExpr(t, \"internal.member_2\", \"x in xs\", Member.Expr(VarTerm(\"x\"), VarTerm(\"xs\")), opts)\n\tassertParseOneExpr(t, \"internal.member_3\", \"x, y in xs\", MemberWithKey.Expr(VarTerm(\"x\"), VarTerm(\"y\"), VarTerm(\"xs\")), opts)\n}\n\nfunc TestInfixExpr(t *testing.T) {\n\tassertParseOneExpr(t, \"scalars 1\", \"true = false\", Equality.Expr(BooleanTerm(true), BooleanTerm(false)))\n\tassertParseOneExpr(t, \"scalars 2\", \"3.14 = null\", Equality.Expr(FloatNumberTerm(3.14), NullTerm()))\n\tassertParseOneExpr(t, \"scalars 3\", \"42 = \\\"hello world\\\"\", Equality.Expr(IntNumberTerm(42), StringTerm(\"hello world\")))\n\tassertParseOneExpr(t, \"vars 1\", \"hello = world\", Equality.Expr(VarTerm(\"hello\"), VarTerm(\"world\")))\n\tassertParseOneExpr(t, \"vars 2\", \"42 = hello\", Equality.Expr(IntNumberTerm(42), VarTerm(\"hello\")))\n\n\tref1 := RefTerm(VarTerm(\"foo\"), IntNumberTerm(0), StringTerm(\"bar\"), VarTerm(\"x\"))\n\tref2 := RefTerm(VarTerm(\"baz\"), BooleanTerm(false), StringTerm(\"qux\"), StringTerm(\"hello\"))\n\tassertParseOneExpr(t, \"refs 1\", \"foo[0].bar[x] = baz[false].qux[\\\"hello\\\"]\", Equality.Expr(ref1, ref2))\n\n\tleft1 := ObjectTerm(Item(VarTerm(\"a\"), ArrayTerm(ref1)))\n\tright1 := ArrayTerm(ObjectTerm(Item(IntNumberTerm(42), BooleanTerm(true))))\n\tassertParseOneExpr(t, \"composites\", \"{a: [foo[0].bar[x]]} = [{42: true}]\", Equality.Expr(left1, right1))\n\n\tassertParseOneExpr(t, \"plus\", \"x = 1 + 2\", Equality.Expr(VarTerm(\"x\"), Plus.Call(IntNumberTerm(1), IntNumberTerm(2))))\n\tassertParseOneExpr(t, \"plus reverse\", \"1 + 2 = x\", Equality.Expr(Plus.Call(IntNumberTerm(1), IntNumberTerm(2)), VarTerm(\"x\")))\n\n\tassertParseOneExpr(t, \"call\", \"count([true, false]) = x\", Equality.Expr(Count.Call(ArrayTerm(BooleanTerm(true), BooleanTerm(false))), VarTerm(\"x\")))\n\tassertParseOneExpr(t, \"call-reverse\", \"x = count([true, false])\", Equality.Expr(VarTerm(\"x\"), Count.Call(ArrayTerm(BooleanTerm(true), BooleanTerm(false)))))\n}\n\nfunc TestNegatedExpr(t *testing.T) {\n\tassertParseOneTermNegated(t, \"scalars 1\", \"not true\", BooleanTerm(true))\n\tassertParseOneTermNegated(t, \"scalars 2\", \"not \\\"hello\\\"\", StringTerm(\"hello\"))\n\tassertParseOneTermNegated(t, \"scalars 3\", \"not 100\", IntNumberTerm(100))\n\tassertParseOneTermNegated(t, \"scalars 4\", \"not null\", NullTerm())\n\tassertParseOneTermNegated(t, \"var\", \"not x\", VarTerm(\"x\"))\n\tassertParseOneTermNegated(t, \"ref\", \"not x[y].z\", RefTerm(VarTerm(\"x\"), VarTerm(\"y\"), StringTerm(\"z\")))\n\tassertParseOneExprNegated(t, \"vars\", \"not x = y\", Equality.Expr(VarTerm(\"x\"), VarTerm(\"y\")))\n\n\tref1 := RefTerm(VarTerm(\"x\"), VarTerm(\"y\"), StringTerm(\"z\"), VarTerm(\"a\"))\n\n\tassertParseOneExprNegated(t, \"membership\", \"not x[y].z[a] = \\\"b\\\"\", Equality.Expr(ref1, StringTerm(\"b\")))\n\tassertParseOneExprNegated(t, \"misc. builtin\", \"not sorted(x[y].z[a])\", NewExpr([]*Term{RefTerm(VarTerm(\"sorted\")), ref1}))\n}\n\nfunc TestExprWith(t *testing.T) {\n\tassertParseOneExpr(t, \"input\", \"data.foo with input as baz\", &Expr{\n\t\tTerms: MustParseTerm(\"data.foo\"),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: NewTerm(InputRootRef),\n\t\t\t\tValue:  VarTerm(\"baz\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"builtin/ref target/composites\", `plus(data.foo, 1, x) with input.com.acmecorp.obj as {\"count\": [{1,2,3}]}`, &Expr{\n\t\tTerms: MustParseExpr(\"plus(data.foo, 1, x)\").Terms,\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.com.acmecorp.obj\"),\n\t\t\t\tValue:  MustParseTerm(`{\"count\": [{1,2,3}]}`),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"multiple\", `data.foo with input.obj as baz with input.com.acmecorp.obj as {\"count\": [{1,2,3}]}`, &Expr{\n\t\tTerms: MustParseTerm(\"data.foo\"),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.obj\"),\n\t\t\t\tValue:  VarTerm(\"baz\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.com.acmecorp.obj\"),\n\t\t\t\tValue:  MustParseTerm(`{\"count\": [{1,2,3}]}`),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"variable target\", \"true with x as 1\", &Expr{\n\t\tTerms: BooleanTerm(true),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: VarTerm(\"x\"),\n\t\t\t\tValue:  IntNumberTerm(1),\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestExprWithLocation(t *testing.T) {\n\tcases := []struct {\n\t\tnote     string\n\t\tinput    string\n\t\texpected []*Location\n\t}{\n\t\t{\n\t\t\tnote:  \"base\",\n\t\t\tinput: \"a with b as c\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"with line break\",\n\t\t\tinput: \"a with b\\nas c\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b\\nas c\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"multiple withs on single line\",\n\t\t\tinput: \"a with b as c with d as e\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    15,\n\t\t\t\t\tOffset: 14,\n\t\t\t\t\tText:   []byte(\"with d as e\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"multiple withs on multiple line\",\n\t\t\tinput: \"a with b as c\\n\\t\\twith d as e\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tRow:    2,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 16,\n\t\t\t\t\tText:   []byte(\"with d as e\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := ParseStatement(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error on %s: %s\", tc.input, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbody := parsed.(Body)\n\t\t\tif len(body) != 1 {\n\t\t\t\tt.Errorf(\"Parser returned multiple expressions: %v\", body)\n\t\t\t\treturn\n\t\t\t}\n\t\t\texpr := body[0]\n\t\t\tif len(expr.With) != len(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected %d with statements, got %d\", len(expr.With), len(tc.expected))\n\t\t\t}\n\t\t\tfor i, with := range expr.With {\n\t\t\t\tif !with.Location.Equal(tc.expected[i]) {\n\t\t\t\t\tt.Errorf(\"Expected location %+v for '%v' but got %+v \", *(tc.expected[i]), with.String(), *with.Location)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSomeDeclExpr(t *testing.T) {\n\topts := ParserOptions{FutureKeywords: []string{\"in\"}}\n\n\tassertParseOneExpr(t, \"one\", \"some x\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"internal.member_2\", \"some x in xs\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tMember.Call(\n\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseOneExpr(t, \"internal.member_3\", \"some x, y in xs\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tMemberWithKey.Call(\n\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\tVarTerm(\"y\"),\n\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseErrorContains(t, \"not some\", \"not some x, y in xs\",\n\t\t\"unexpected some keyword: illegal negation of 'some'\",\n\t\topts)\n\n\tassertParseErrorContains(t, \"some + function call\", \"some f(x)\",\n\t\t\"expected `x in xs` or `x, y in xs` expression\")\n\n\tassertParseOneExpr(t, \"multiple\", \"some x, y\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t\tVarTerm(\"y\"),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseOneExpr(t, \"multiple split across lines\", `some x, y,\n\t\tz`, &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t\tVarTerm(\"y\"),\n\t\t\t\tVarTerm(\"z\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseRule(t, \"whitespace separated\", `\n\n\t\tp[x] {\n\t\t\tsome x\n\t\t\tq[x]\n\t\t}\n\t`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"x\"))),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"whitespace separated, following `in` rule ref\", `\n\tp[x] {\n\t\tsome x\n\t\tin[x]\n\t}\n`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(RefTerm(VarTerm(\"in\"), VarTerm(\"x\"))),\n\t\t),\n\t})\n\n\tassertParseErrorContains(t, \"some x in ... usage is hinted properly\", `\n\tp[x] {\n\t\tsome x in {\"foo\": \"bar\"}\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.in` for `some x in xs` expressions)\")\n\n\tassertParseErrorContains(t, \"some x, y in ... usage is hinted properly\", `\n\tp[y] = x {\n\t\tsome x, y in {\"foo\": \"bar\"}\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.in` for `some x in xs` expressions)\")\n\n\tassertParseRule(t, \"whitespace terminated\", `\n\n\tp[x] {\n\t\tsome x\n\t\tx\n\t}\n`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(VarTerm(\"x\")),\n\t\t),\n\t})\n\n\tassertParseOneExpr(t, \"with modifier on expr\", \"some x, y in input with input as []\",\n\t\t&Expr{\n\t\t\tTerms: &SomeDecl{\n\t\t\t\tSymbols: []*Term{\n\t\t\t\t\tMemberWithKey.Call(\n\t\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\t\tVarTerm(\"y\"),\n\t\t\t\t\t\tNewTerm(MustParseRef(\"input\")),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWith: []*With{{Value: ArrayTerm(), Target: NewTerm(MustParseRef(\"input\"))}},\n\t\t}, opts)\n}\n\nfunc TestEvery(t *testing.T) {\n\topts := ParserOptions{unreleasedKeywords: true, FutureKeywords: []string{\"every\"}}\n\tassertParseOneExpr(t, \"simple\", \"every x in xs { true }\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tValue:  VarTerm(\"x\"),\n\t\t\t\tDomain: VarTerm(\"xs\"),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(BooleanTerm(true)),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\topts)\n\n\tassertParseOneExpr(t, \"with key\", \"every k, v in [1,2] { true }\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tKey:    VarTerm(\"k\"),\n\t\t\t\tValue:  VarTerm(\"v\"),\n\t\t\t\tDomain: ArrayTerm(IntNumberTerm(1), IntNumberTerm(2)),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(BooleanTerm(true)),\n\t\t\t\t},\n\t\t\t},\n\t\t}, opts)\n\n\tassertParseErrorContains(t, \"arbitrary term\", \"every 10\", \"expected `x[, y] in xs { ... }` expression\", opts)\n\tassertParseErrorContains(t, \"non-var value\", \"every 10 in xs { true }\", \"unexpected { token: expected value to be a variable\", opts)\n\tassertParseErrorContains(t, \"non-var key\", \"every 10, x in xs { true }\", \"unexpected { token: expected key to be a variable\", opts)\n\tassertParseErrorContains(t, \"arbitrary call\", \"every f(10)\", \"expected `x[, y] in xs { ... }` expression\", opts)\n\tassertParseErrorContains(t, \"no body\", \"every x in xs\", \"missing body\", opts)\n\tassertParseErrorContains(t, \"invalid body\", \"every x in xs { + }\", \"unexpected plus token\", opts)\n\tassertParseErrorContains(t, \"not every\", \"not every x in xs { true }\", \"unexpected every keyword: illegal negation of 'every'\", opts)\n\n\tassertParseOneExpr(t, `\"every\" kw implies \"in\" kw`, \"x in xs\", Member.Expr(\n\t\tVarTerm(\"x\"),\n\t\tVarTerm(\"xs\"),\n\t), opts)\n\n\tassertParseOneExpr(t, \"with modifier on expr\", \"every x in input { x } with input as []\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tValue:  VarTerm(\"x\"),\n\t\t\t\tDomain: NewTerm(MustParseRef(\"input\")),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(VarTerm(\"x\")),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWith: []*With{{Value: ArrayTerm(), Target: NewTerm(MustParseRef(\"input\"))}},\n\t\t}, opts)\n\n\tassertParseErrorContains(t, \"every x, y in ... usage is hinted properly\", `\n\tp {\n\t\tevery x, y in {\"foo\": \"bar\"} { is_string(x); is_string(y) }\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.every` for `every x in xs { ... }` expressions)\")\n\n\tassertParseErrorContains(t, \"not every 'every' gets a hint\", `\n\tp {\n\t\tevery x\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or }\\n\\tevery x\\n\", // this asserts that the tail of the error message doesn't contain a hint\n\t)\n\n}\n\nfunc TestNestedExpressions(t *testing.T) {\n\n\tn1 := IntNumberTerm(1)\n\tn2 := IntNumberTerm(2)\n\tn3 := IntNumberTerm(3)\n\tn4 := IntNumberTerm(4)\n\tn6 := IntNumberTerm(6)\n\tx := VarTerm(\"x\")\n\ty := VarTerm(\"y\")\n\tz := VarTerm(\"z\")\n\tw := VarTerm(\"w\")\n\tf := RefTerm(VarTerm(\"f\"))\n\tg := RefTerm(VarTerm(\"g\"))\n\n\ttests := []struct {\n\t\tnote     string\n\t\tinput    string\n\t\texpected *Expr\n\t}{\n\t\t{\"associativity\", \"1 + 2 * 6 / 3\",\n\t\t\tPlus.Expr(\n\t\t\t\tn1,\n\t\t\t\tDivide.Call(\n\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\tn6),\n\t\t\t\t\tn3))},\n\t\t{\"associativity - factors\", \"x * y / z % w\",\n\t\t\tRem.Expr(Divide.Call(Multiply.Call(x, y), z), w)},\n\t\t{\"associativity - factors\", \"w % z / x * y\",\n\t\t\tMultiply.Expr(Divide.Call(Rem.Call(w, z), x), y)},\n\t\t{\"associativity - arithetic\", \"x + y - z\",\n\t\t\tMinus.Expr(Plus.Call(x, y), z)},\n\t\t{\"associativity - arithmetic\", \"z - x + y\",\n\t\t\tPlus.Expr(Minus.Call(z, x), y)},\n\t\t{\"associativity - and\", \"z & x & y\",\n\t\t\tAnd.Expr(And.Call(z, x), y)},\n\t\t{\"associativity - or\", \"z | x | y\",\n\t\t\tOr.Expr(Or.Call(z, x), y)},\n\t\t{\"associativity - relations\", \"x == y != z\",\n\t\t\tNotEqual.Expr(Equal.Call(x, y), z)},\n\t\t{\"grouping\", \"(1 + 2 * 6 / 3) > 4\",\n\t\t\tGreaterThan.Expr(\n\t\t\t\tPlus.Call(\n\t\t\t\t\tn1,\n\t\t\t\t\tDivide.Call(\n\t\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\t\tn2,\n\t\t\t\t\t\t\tn6),\n\t\t\t\t\t\tn3)),\n\t\t\t\tn4)},\n\t\t{\"nested parens\", \"(((1 + 2) * (6 / (3))) > 4) != false\",\n\t\t\tNotEqual.Expr(\n\t\t\t\tGreaterThan.Call(\n\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\tPlus.Call(\n\t\t\t\t\t\t\tn1,\n\t\t\t\t\t\t\tn2),\n\t\t\t\t\t\tDivide.Call(\n\t\t\t\t\t\t\tn6,\n\t\t\t\t\t\t\tn3)),\n\t\t\t\t\tn4,\n\t\t\t\t),\n\t\t\t\tBooleanTerm(false))},\n\t\t{\"bitwise or\", \"x + 1 | 2\", Or.Expr(Plus.Call(x, n1), n2)},\n\t\t{\"bitwise and\", \"x + 1 | 2 & 3\", Or.Expr(Plus.Call(x, n1), And.Call(n2, n3))},\n\t\t{\"array\", \"[x + 1, y > 2, z]\", NewExpr(ArrayTerm(Plus.Call(x, n1), GreaterThan.Call(y, n2), z))},\n\t\t{\"object\", \"{x * 2: y < 2, z[3]: 1 + 6/2}\", NewExpr(\n\t\t\tObjectTerm(\n\t\t\t\tItem(Multiply.Call(x, n2), LessThan.Call(y, n2)),\n\t\t\t\tItem(RefTerm(z, n3), Plus.Call(n1, Divide.Call(n6, n2))),\n\t\t\t),\n\t\t)},\n\t\t{\"set\", \"{x + 1, y + 2, set()}\", NewExpr(\n\t\t\tSetTerm(\n\t\t\t\tPlus.Call(x, n1),\n\t\t\t\tPlus.Call(y, n2),\n\t\t\t\tSetTerm(),\n\t\t\t),\n\t\t)},\n\t\t{\"ref\", `x[1][y + z[w + 1]].b`, NewExpr(\n\t\t\tRefTerm(\n\t\t\t\tx,\n\t\t\t\tn1,\n\t\t\t\tPlus.Call(\n\t\t\t\t\ty,\n\t\t\t\t\tRefTerm(\n\t\t\t\t\t\tz,\n\t\t\t\t\t\tPlus.Call(w, n1))),\n\t\t\t\tStringTerm(\"b\"),\n\t\t\t),\n\t\t)},\n\t\t{\"call void\", \"f()\", NewExpr([]*Term{f})},\n\t\t{\"call unary\", \"f(x)\", NewExpr([]*Term{f, x})},\n\t\t{\"call binary\", \"f(x, y)\", NewExpr([]*Term{f, x, y})},\n\t\t{\"call embedded\", \"f([g(x), y+1])\", NewExpr([]*Term{\n\t\t\tf,\n\t\t\tArrayTerm(\n\t\t\t\tCallTerm(g, x),\n\t\t\t\tPlus.Call(y, n1))})},\n\t\t{\"call fqn\", \"foo.bar(1)\", NewExpr([]*Term{\n\t\t\tRefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\tn1,\n\t\t})},\n\t\t{\"unify\", \"x = 1\", Equality.Expr(x, n1)},\n\t\t{\"unify embedded\", \"1 + x = 2 - y\", Equality.Expr(Plus.Call(n1, x), Minus.Call(n2, y))},\n\t\t{\"not keyword\", \"not x = y\", Equality.Expr(x, y).Complement()},\n\t\t{\"with keyword\", \"x with p[q] as f([x+1])\", NewExpr(x).IncludeWith(\n\t\t\tRefTerm(VarTerm(\"p\"), VarTerm(\"q\")),\n\t\t\tCallTerm(f, ArrayTerm(Plus.Call(x, n1))),\n\t\t)},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\texpr, err := ParseExpr(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !expr.Equal(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected %v but got %v\", tc.expected, expr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestChainedCall(t *testing.T) {\n\tresult, err := ParseExpr(\"foo.bar(1)[0](1).baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texp := NewExpr(RefTerm(\n\t\tCallTerm(\n\t\t\tRefTerm(\n\t\t\t\tCallTerm(\n\t\t\t\t\tRefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\t\t\tIntNumberTerm(1)),\n\t\t\t\tIntNumberTerm(0)),\n\t\t\tIntNumberTerm(1)),\n\t\tStringTerm(\"baz\")))\n\n\tif !result.Equal(exp) {\n\t\tt.Fatalf(\"expected %v but got: %v\", exp, result)\n\t}\n}\n\nfunc TestMultiLineBody(t *testing.T) {\n\n\tinput1 := `\n\t\tx = 1\n\t\ty = 2\n\t\tz = [ i | [x,y] = arr\n\t\t\t\t   arr[_] = i]\n\t`\n\n\tbody1, err := ParseBody(input1)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error on enclosed body: %v\", err)\n\t}\n\n\texpected1 := MustParseBody(`x = 1; y = 2; z = [i | [x,y] = arr; arr[_] = i]`)\n\n\tif !body1.Equal(expected1) {\n\t\tt.Errorf(\"Expected enclosed body to equal %v but got: %v\", expected1, body1)\n\t}\n\n\t// Check that parser can handle multiple expressions w/o enclosing braces.\n\tinput2 := `\n\t\tx = 1 ; # comment after semicolon\n\t\ty = 2   # comment without semicolon\n\t\tz = [ i | [x,y] = arr  # comment in comprehension\n\t\t\t\t   arr[_] = i]\n\t`\n\n\tbody2, err := ParseBody(input2)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error on enclosed body: %v\", err)\n\t}\n\n\tif !body2.Equal(expected1) {\n\t\tt.Errorf(\"Expected unenclosed body to equal %v but got: %v\", expected1, body1)\n\t}\n\n\tassertParseOneBody(t, \"whitespace following call\", \"f(x)\\t\\n [1]\", NewBody(\n\t\tNewExpr(\n\t\t\t[]*Term{\n\t\t\t\tRefTerm(VarTerm(\"f\")),\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t},\n\t\t),\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(1)),\n\t\t),\n\t))\n\n\tassertParseOneBody(t, \"whitespace following array\", \"[1]\\t\\n [2]\", NewBody(\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(1)),\n\t\t),\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(2)),\n\t\t),\n\t))\n\n\tassertParseOneBody(t, \"whitespace following set\", \"{1}\\t\\n {2}\", NewBody(\n\t\tNewExpr(\n\t\t\tSetTerm(IntNumberTerm(1)),\n\t\t),\n\t\tNewExpr(\n\t\t\tSetTerm(IntNumberTerm(2)),\n\t\t),\n\t))\n}\n\nfunc TestBitwiseOrVsComprehension(t *testing.T) {\n\n\tx := VarTerm(\"x\")\n\ty := VarTerm(\"y\")\n\tz := VarTerm(\"z\")\n\ta := VarTerm(\"a\")\n\tb := VarTerm(\"b\")\n\n\ttests := []struct {\n\t\tnote  string\n\t\tinput string\n\t\texp   *Term\n\t}{\n\t\t{\n\t\t\tnote:  \"array containing bitwise or\",\n\t\t\tinput: \"[x|y,z]\",\n\t\t\texp:   ArrayTerm(Or.Call(x, y), z),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing bitwise or - last element\",\n\t\t\tinput: \"[z,x|y]\",\n\t\t\texp:   ArrayTerm(z, Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing bitwise or - middle\",\n\t\t\tinput: \"[z,x|y,a]\",\n\t\t\texp:   ArrayTerm(z, Or.Call(x, y), a),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing single bitwise or\",\n\t\t\tinput: \"[x|y,]\",\n\t\t\texp:   ArrayTerm(Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or\",\n\t\t\tinput: \"{x|y,z}\",\n\t\t\texp:   SetTerm(Or.Call(x, y), z),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or - last element\",\n\t\t\tinput: \"{z,x|y}\",\n\t\t\texp:   SetTerm(z, Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or - middle\",\n\t\t\tinput: \"{z,x|y,a}\",\n\t\t\texp:   SetTerm(z, Or.Call(x, y), a),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing single bitwise or\",\n\t\t\tinput: \"{x|y,}\",\n\t\t\texp:   SetTerm(Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"object containing bitwise or\",\n\t\t\tinput: \"{x:y|z,a:b}\",\n\t\t\texp:   ObjectTerm([2]*Term{x, Or.Call(y, z)}, [2]*Term{a, b}),\n\t\t},\n\t\t{\n\t\t\tnote:  \"object containing single bitwise or\",\n\t\t\tinput: \"{x:y|z,}\",\n\t\t\texp:   ObjectTerm([2]*Term{x, Or.Call(y, z)}),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\n\t\t\tterm, err := ParseTerm(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif !term.Equal(tc.exp) {\n\t\t\t\tt.Fatalf(\"Expected %v but got %v\", tc.exp, term)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc TestPackage(t *testing.T) {\n\tref1 := RefTerm(DefaultRootDocument, StringTerm(\"foo\"))\n\tassertParsePackage(t, \"single\", `package foo`, &Package{Path: ref1.Value.(Ref)})\n\tref2 := RefTerm(DefaultRootDocument, StringTerm(\"f00\"), StringTerm(\"bar_baz\"), StringTerm(\"qux\"))\n\tassertParsePackage(t, \"multiple\", `package f00.bar_baz.qux`, &Package{Path: ref2.Value.(Ref)})\n\tref3 := RefTerm(DefaultRootDocument, StringTerm(\"foo\"), StringTerm(\"bar baz\"))\n\tassertParsePackage(t, \"space\", `package foo[\"bar baz\"]`, &Package{Path: ref3.Value.(Ref)})\n\tassertParseError(t, \"non-ground ref\", \"package foo[x]\")\n\tassertParseError(t, \"non-string value\", \"package foo.bar[42].baz\")\n\tassertParseError(t, \"invalid term\", \"package 42\")\n\tassertParseError(t, \"scanner error\", \"package foo.\")\n\tassertParseError(t, \"non-string first value\", \"package e().s\")\n}\n\nfunc TestImport(t *testing.T) {\n\tfoo := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"))\n\tfoobarbaz := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"baz\"))\n\twhitespace := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"white space\"))\n\tassertParseImport(t, \"single-input\", \"import input\", &Import{Path: RefTerm(InputRootDocument)})\n\tassertParseImport(t, \"single-data\", \"import data\", &Import{Path: RefTerm(DefaultRootDocument)})\n\tassertParseImport(t, \"multiple\", \"import input.foo.bar.baz\", &Import{Path: foobarbaz})\n\tassertParseImport(t, \"single alias\", \"import input.foo as bar\", &Import{Path: foo, Alias: Var(\"bar\")})\n\tassertParseImport(t, \"multiple alias\", \"import input.foo.bar.baz as qux\", &Import{Path: foobarbaz, Alias: Var(\"qux\")})\n\tassertParseImport(t, \"white space\", \"import input.foo.bar[\\\"white space\\\"]\", &Import{Path: whitespace})\n\tassertParseErrorContains(t, \"non-ground ref\", \"import data.foo[x]\", \"rego_parse_error: unexpected var token: expecting string\")\n\tassertParseErrorContains(t, \"non-string\", \"import input.foo[0]\", \"rego_parse_error: unexpected number token: expecting string\")\n\tassertParseErrorContains(t, \"unknown root\", \"import foo.bar\", \"rego_parse_error: unexpected import path, must begin with one of: {data, future, input}, got: foo\")\n\tassertParseErrorContains(t, \"bad variable term\", \"import input as A(\", \"rego_parse_error: unexpected eof token: expected var\")\n\n\t_, _, err := ParseStatements(\"\", \"package foo\\nimport bar.data\\ndefault foo=1\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error, but got nil\")\n\t}\n\tif len(err.(Errors)) > 1 {\n\t\tt.Fatalf(\"Expected a single error, got %s\", err)\n\t}\n\ttxt := err.(Errors)[0].Details.Lines()[0]\n\texpected := \"import bar.data\"\n\tif txt != expected {\n\t\tt.Fatalf(\"Expected error detail text '%s' but got '%s'\", expected, txt)\n\t}\n}\n\nfunc TestFutureImports(t *testing.T) {\n\tassertParseErrorContains(t, \"future\", \"import future\", \"invalid import, must be `future.keywords`\")\n\tassertParseErrorContains(t, \"future.a\", \"import future.a\", \"invalid import, must be `future.keywords`\")\n\tassertParseErrorContains(t, \"unknown keyword\", \"import future.keywords.xyz\", \"unexpected keyword, must be one of [every in]\")\n\tassertParseErrorContains(t, \"all keyword import + alias\", \"import future.keywords as xyz\", \"future keyword imports cannot be aliased\")\n\tassertParseErrorContains(t, \"keyword import + alias\", \"import future.keywords.in as xyz\", \"future keyword imports cannot be aliased\")\n\n\tassertParseImport(t, \"import kw with kw in options\",\n\t\t\"import future.keywords.in\", &Import{Path: RefTerm(VarTerm(\"future\"), StringTerm(\"keywords\"), StringTerm(\"in\"))},\n\t\tParserOptions{FutureKeywords: []string{\"in\"}})\n\tassertParseImport(t, \"import kw with all kw in options\",\n\t\t\"import future.keywords.in\", &Import{Path: RefTerm(VarTerm(\"future\"), StringTerm(\"keywords\"), StringTerm(\"in\"))},\n\t\tParserOptions{AllFutureKeywords: true})\n\n\tmod := `\n\t\tpackage p\n\t\timport future.keywords\n\t\timport future.keywords.in\n\t`\n\tparsed := Module{\n\t\tPackage: MustParseStatement(`package p`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import future.keywords\").(*Import),\n\t\t\tMustParseStatement(\"import future.keywords.in\").(*Import),\n\t\t},\n\t}\n\tassertParseModule(t, \"multiple imports, all kw in options\", mod, &parsed, ParserOptions{AllFutureKeywords: true})\n\tassertParseModule(t, \"multiple imports, single in options\", mod, &parsed, ParserOptions{FutureKeywords: []string{\"in\"}})\n}\n\nfunc TestFutureImportsExtraction(t *testing.T) {\n\t// These tests assert that \"import future...\" statements in policies cause\n\t// the proper keywords to be added to the parser's list of known keywords.\n\ttests := []struct {\n\t\tnote, imp string\n\t\texp       map[string]tokens.Token\n\t}{\n\t\t{\n\t\t\tnote: \"simple import\",\n\t\t\timp:  \"import future.keywords.in\",\n\t\t\texp:  map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t\t{\n\t\t\tnote: \"all keywords imported\",\n\t\t\timp:  \"import future.keywords\",\n\t\t\texp:  map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t\t{\n\t\t\tnote: \"all keywords + single keyword imported\",\n\t\t\timp: `\n\t\t\t\timport future.keywords\n\t\t\t\timport future.keywords.in`,\n\t\t\texp: map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparser := NewParser().WithFilename(\"\").WithReader(bytes.NewBufferString(tc.imp))\n\t\t\t_, _, errs := parser.Parse()\n\t\t\tif exp, act := 0, len(errs); exp != act {\n\t\t\t\tt.Fatalf(\"expected %d errors, got %d: %v\", exp, act, errs)\n\t\t\t}\n\t\t\tfor kw, exp := range tc.exp {\n\t\t\t\tact := parser.s.s.Keyword(kw)\n\t\t\t\tif act != exp {\n\t\t\t\t\tt.Errorf(\"expected keyword %q to yield token %v, got %v\", kw, exp, act)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsValidImportPath(t *testing.T) {\n\ttests := []struct {\n\t\tpath     string\n\t\texpected error\n\t}{\n\t\t{\"[1,2,3]\", fmt.Errorf(\"invalid path [1, 2, 3]: path must be ref or var\")},\n\t}\n\n\tfor _, tc := range tests {\n\t\tpath := MustParseTerm(tc.path).Value\n\t\tresult := IsValidImportPath(path)\n\t\tif tc.expected == nil && result != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", path, result)\n\t\t} else if !reflect.DeepEqual(tc.expected, result) {\n\t\t\tt.Errorf(\"For %v expected %v but got: %v\", path, tc.expected, result)\n\t\t}\n\t}\n\n}\n\nfunc TestRule(t *testing.T) {\n\n\tassertParseRule(t, \"constant\", `p = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, BooleanTerm(true)),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"set\", `p[x] { x = 42 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"x\"), IntNumberTerm(42)),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"object\", `p[x] = y { x = 42; y = \"hello\" }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\"), VarTerm(\"y\")),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"x\"), IntNumberTerm(42)),\n\t\t\tEquality.Expr(VarTerm(\"y\"), StringTerm(\"hello\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"constant composite\", `p = [{\"foo\": [1, 2, 3, 4]}] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, ArrayTerm(\n\t\t\tObjectTerm(Item(StringTerm(\"foo\"), ArrayTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), IntNumberTerm(4)))))),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"true\", `p = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, BooleanTerm(true)),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composites in head\", `p[[{\"x\": [a, b]}]] { a = 1; b = 2 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), ArrayTerm(\n\t\t\tObjectTerm(\n\t\t\t\tItem(StringTerm(\"x\"), ArrayTerm(VarTerm(\"a\"), VarTerm(\"b\"))),\n\t\t\t),\n\t\t)),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"a\"), IntNumberTerm(1)),\n\t\t\tEquality.Expr(VarTerm(\"b\"), IntNumberTerm(2)),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p = data.foo[x] { x = 1 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"x = 1\"),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p[data.foo[x]] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p[data.foo[x]] = data.bar[y] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}, &Term{\n\t\t\tValue: MustParseRef(\"data.bar[y]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"data\", `data = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"data\"), nil, MustParseTerm(\"true\")),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"input\", `input = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"input\"), nil, MustParseTerm(\"true\")),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"default\", `default allow = false`, &Rule{\n\t\tDefault: true,\n\t\tHead:    NewHead(Var(\"allow\"), nil, MustParseTerm(\"false\")),\n\t\tBody:    NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"default w/ comprehension\", `default widgets = [x | x = data.fooz[_]]`, &Rule{\n\t\tDefault: true,\n\t\tHead:    NewHead(Var(\"widgets\"), nil, MustParseTerm(`[x | x = data.fooz[_]]`)),\n\t\tBody:    NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"one line with braces\", `p[x] { x = data.a[_]; count(x, 3) }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: MustParseBody(`x = data.a[_]; count(x, 3)`),\n\t})\n\n\tassertParseRule(t, \"multiple lines with braces\", `p[[x, y]] { [data.a[0]] = [{\"x\": x}]; count(x, 3); sum(x, y); y > 100 }`,\n\n\t\t&Rule{\n\t\t\tHead: NewHead(Var(\"p\"), MustParseTerm(\"[x, y]\")),\n\t\t\tBody: MustParseBody(`[data.a[0]] = [{\"x\": x}]; count(x, 3); sum(x, y); y > 100`),\n\t\t})\n\n\tfxy := &Head{\n\t\tName:  Var(\"f\"),\n\t\tArgs:  Args{VarTerm(\"x\")},\n\t\tValue: VarTerm(\"y\"),\n\t}\n\n\tassertParseRule(t, \"identity\", `f(x) = y { y = x }`, &Rule{\n\t\tHead: fxy,\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"y\"), VarTerm(\"x\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composite arg\", `f([x, y]) = z { split(x, y, z) }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  Var(\"f\"),\n\t\t\tArgs:  Args{ArrayTerm(VarTerm(\"x\"), VarTerm(\"y\"))},\n\t\t\tValue: VarTerm(\"z\"),\n\t\t},\n\t\tBody: NewBody(\n\t\t\tSplit.Expr(VarTerm(\"x\"), VarTerm(\"y\"), VarTerm(\"z\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composite result\", `f(1) = [x, y] { split(\"foo.bar\", x, y) }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  Var(\"f\"),\n\t\t\tArgs:  Args{IntNumberTerm(1)},\n\t\t\tValue: ArrayTerm(VarTerm(\"x\"), VarTerm(\"y\")),\n\t\t},\n\t\tBody: NewBody(\n\t\t\tSplit.Expr(StringTerm(\"foo.bar\"), VarTerm(\"x\"), VarTerm(\"y\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"expr terms: key\", `p[f(x) + g(x)] { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tKey: Plus.Call(\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"expr terms: value\", `p = f(x) + g(x) { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tValue: Plus.Call(\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"expr terms: args\", `p(f(x) + g(x)) { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tArgs: Args{\n\t\t\t\tPlus.Call(\n\t\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t\t),\n\t\t\t},\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"assignment operator\", `x := 1 { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:   Var(\"x\"),\n\t\t\tValue:  IntNumberTerm(1),\n\t\t\tAssign: true,\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\t// TODO: expect expressions instead?\n\tassertParseErrorContains(t, \"empty body\", `f(_) = y {}`, \"rego_parse_error: found empty body\")\n\tassertParseErrorContains(t, \"empty rule body\", \"p {}\", \"rego_parse_error: found empty body\")\n\tassertParseErrorContains(t, \"unmatched braces\", `f(x) = y { trim(x, \".\", y) `, `rego_parse_error: unexpected eof token: expected \\n or ; or }`)\n\n\t// TODO: how to highlight that assignment is incorrect here?\n\tassertParseErrorContains(t, \"no output\", `f(_) = { \"foo\" = \"bar\" }`, \"rego_parse_error: unexpected eq token: expected rule value term\")\n\n\t// TODO(tsandall): improve error checking here. This is a common mistake\n\t// and the current error message is not very good. Need to investigate if the\n\t// parser can be improved.\n\tassertParseError(t, \"dangling semicolon\", \"p { true; false; }\")\n\n\tassertParseErrorContains(t, \"default assignment\", \"default p := 1\", `default rules must use = operator (not := operator)`)\n\tassertParseErrorContains(t, \"partial assignment\", `p[x] := y { true }`, \"partial rules must use = operator (not := operator)\")\n\tassertParseErrorContains(t, \"function assignment\", `f(x) := y { true }`, \"functions must use = operator (not := operator)\")\n\tassertParseErrorContains(t, \"else assignment\", `p := y { true } else = 2 { true } `, \"else keyword cannot be used on rule declared with := operator\")\n\n\tassertParseErrorContains(t, \"default invalid rule name\", `default 0[0`, \"unexpected default keyword\")\n\tassertParseErrorContains(t, \"default invalid rule value\", `default a[0`, \"illegal default rule (must have a value)\")\n\tassertParseRule(t, \"default missing value\", `default a`, &Rule{\n\t\tDefault: true,\n\t\tHead: &Head{\n\t\t\tName:  Var(\"a\"),\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\tassertParseRule(t, \"empty arguments\", `f() { x := 1 }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"f\",\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: MustParseBody(`x := 1`),\n\t})\n\n\tassertParseErrorContains(t, \"default invalid rule head ref\", `default a = b.c.d`, \"illegal default rule (value cannot contain ref)\")\n\tassertParseErrorContains(t, \"default invalid rule head call\", `default a = g(x)`, \"illegal default rule (value cannot contain call)\")\n\tassertParseErrorContains(t, \"default invalid rule head builtin call\", `default a = upper(\"foo\")`, \"illegal default rule (value cannot contain call)\")\n\tassertParseErrorContains(t, \"default invalid rule head call\", `default a = b`, \"illegal default rule (value cannot contain var)\")\n\n\tassertParseError(t, \"extra braces\", `{ a := 1 }`)\n\tassertParseError(t, \"invalid rule name dots\", `a.b = x { x := 1 }`)\n\tassertParseError(t, \"invalid rule name dots and call\", `a.b(x) { x := 1 }`)\n\tassertParseError(t, \"invalid rule name hyphen\", `a-b = x { x := 1 }`)\n\n\tassertParseRule(t, \"wildcard name\", `_ { x == 1 }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"$0\",\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: MustParseBody(`x == 1`),\n\t})\n\n\tassertParseRule(t, \"partial object array key\", `p[[a, 1, 2]] = x { a := 1; x := \"foo\" }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"p\",\n\t\t\tKey:   ArrayTerm(VarTerm(\"a\"), NumberTerm(\"1\"), NumberTerm(\"2\")),\n\t\t\tValue: VarTerm(\"x\"),\n\t\t},\n\t\tBody: MustParseBody(`a := 1; x := \"foo\"`),\n\t})\n\tassertParseError(t, \"invalid rule body no separator\", `p { a = \"foo\"bar }`)\n\tassertParseError(t, \"invalid rule body no newline\", `p { a b c }`)\n}\n\nfunc TestRuleElseKeyword(t *testing.T) {\n\tmod := `package test\n\n\tp {\n\t\t\"p0\"\n\t}\n\n\tp {\n\t\t\"p1\"\n\t} else {\n\t\t\"p1_e1\"\n\t} else = [null] {\n\t\t\"p1_e2\"\n\t} else = x {\n\t\tx = \"p1_e3\"\n\t}\n\n\tp {\n\t\t\"p2\"\n\t}\n\n\tf(x) {\n\t\tx < 100\n\t} else = false {\n\t\tx > 200\n\t} else {\n\t\tx != 150\n\t}\n\n\t_ {\n\t\tx > 0\n\t} else {\n\t    x == -1\n\t} else {\n\t\tx > -100\n\t}\n\n\tnobody = 1 {\n\t\tfalse\n\t} else = 7\n\n\tnobody_f(x) = 1 {\n\t\tfalse\n\t} else = 7\n\t`\n\n\tparsed, err := ParseModule(\"\", mod)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\tname := Var(\"p\")\n\ttr := BooleanTerm(true)\n\thead := &Head{Name: name, Value: tr}\n\n\texpected := &Module{\n\t\tPackage: MustParsePackage(`package test`),\n\t\tRules: []*Rule{\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p0\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p1\"`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: head,\n\t\t\t\t\tBody: MustParseBody(`\"p1_e1\"`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"p\"),\n\t\t\t\t\t\t\tValue: ArrayTerm(NullTerm()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`\"p1_e2\"`),\n\t\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\t\tName:  name,\n\t\t\t\t\t\t\t\tValue: VarTerm(\"x\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBody: MustParseBody(`x = \"p1_e3\"`),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p2\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(`x < 100`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\tValue: BooleanTerm(false),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(`x > 200`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`x != 150`),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(`x > 0`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(`x == -1`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`x > -100`),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"nobody\"),\n\t\t\t\t\tValue: IntNumberTerm(1),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(\"false\"),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"nobody\"),\n\t\t\t\t\t\tValue: IntNumberTerm(7),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(\"true\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"nobody_f\"),\n\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\tValue: IntNumberTerm(1),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(\"false\"),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"nobody_f\"),\n\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\tValue: IntNumberTerm(7),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(\"true\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif parsed.Compare(expected) != 0 {\n\t\tt.Fatalf(\"Expected:\\n%v\\n\\nGot:\\n%v\", expected, parsed)\n\t}\n\n\tnotExpected := &Module{\n\t\tPackage: MustParsePackage(`package test`),\n\t\tRules: []*Rule{\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p0\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p1\"`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: head,\n\t\t\t\t\tBody: MustParseBody(`\"p1_e1\"`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"p\"),\n\t\t\t\t\t\t\tValue: ArrayTerm(NullTerm()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`\"p1_e2\"`),\n\t\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\t\tName:  name,\n\t\t\t\t\t\t\t\tValue: VarTerm(\"x\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBody: MustParseBody(`x = \"p1_e4\"`),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p2\"`),\n\t\t\t},\n\t\t},\n\t}\n\n\tif parsed.Compare(notExpected) != -1 {\n\t\tt.Fatalf(\"Expected not equal:\\n%v\\n\\nGot:\\n%v\", parsed, notExpected)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp[1] { false } else { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"else keyword cannot be used on partial rules\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp { false } { false } else { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"unexpected else keyword\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp { false } else { false } { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"expected else keyword\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n}\n\nfunc TestMultipleEnclosedBodies(t *testing.T) {\n\n\tresult, err := ParseModule(\"\", `package ex\n\np[x] = y {\n\tx = \"a\"\n\ty = 1\n} {\n\tx = \"b\"\n\ty = 2\n}\n\nq = 1\n\nf(x) {\n\tx < 10\n} {\n\tx > 1000\n}\n`,\n\t)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\texpected := MustParseModule(`package ex\n\np[x] = y { x = \"a\"; y = 1 }\np[x] = y { x = \"b\"; y = 2 }\nq = 1 { true }\nf(x) { x < 10 }\nf(x) { x > 1000 }`,\n\t)\n\n\tif !expected.Equal(result) {\n\t\tt.Fatal(\"Expected modules to be equal but got:\\n\\n\", result, \"\\n\\nExpected:\\n\\n\", expected)\n\t}\n\n}\n\nfunc TestEmptyModule(t *testing.T) {\n\tr, err := ParseModule(\"\", \"    \")\n\tif err == nil {\n\t\tt.Error(\"Expected error for empty module\")\n\t\treturn\n\t}\n\tif r != nil {\n\t\tt.Errorf(\"Expected nil for empty module: %v\", r)\n\t}\n}\n\nfunc TestComments(t *testing.T) {\n\n\ttestModule := `package a.b.c\n\n    import input.e.f as g  # end of line\n    import input.h\n\n    # by itself\n\n    p[x] = y { y = \"foo\";\n        # inside a rule\n        x = \"bar\";\n        x != y;\n        q[x]\n\t}\n\n    import input.xyz.abc\n\n    q # interrupting\n\n\t[a] # the head of a rule\n\n\t{ m = [1,2,\n    3, ];\n    a = m[i]\n\n\t}\n\n\tr[x] { x = [ a | # inside comprehension\n\t\t\t\t\t  a = z[i]\n\t                  b[i].a = a ]\n\n\t\ty = { a | # inside set comprehension\n\t\t\t\ta = z[i]\n\t\t\tb[i].a = a}\n\n\t\tz = {a: i | # inside object comprehension\n\t\t\t\ta = z[i]\n\t\t\tb[i].a = a}\n\t\t\t\t\t  }`\n\n\tassertParseModule(t, \"module comments\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package a.b.c`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import input.e.f as g\").(*Import),\n\t\t\tMustParseStatement(\"import input.h\").(*Import),\n\t\t\tMustParseStatement(\"import input.xyz.abc\").(*Import),\n\t\t},\n\t\tRules: []*Rule{\n\t\t\tMustParseStatement(`p[x] = y { y = \"foo\"; x = \"bar\"; x != y; q[x] }`).(*Rule),\n\t\t\tMustParseStatement(`q[a] { m = [1, 2, 3]; a = m[i] }`).(*Rule),\n\t\t\tMustParseStatement(`r[x] { x = [a | a = z[i]; b[i].a = a]; y = {a |  a = z[i]; b[i].a = a}; z = {a: i | a = z[i]; b[i].a = a} }`).(*Rule),\n\t\t},\n\t})\n\n\tmodule, err := ParseModule(\"test.rego\", testModule)\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\n\texp := []struct {\n\t\ttext string\n\t\trow  int\n\t\tcol  int\n\t}{\n\t\t{text: \"end of line\", row: 3, col: 28},\n\t\t{text: \"by itself\", row: 6, col: 5},\n\t\t{text: \"inside a rule\", row: 9, col: 9},\n\t\t{text: \"interrupting\", row: 17, col: 7},\n\t\t{text: \"the head of a rule\", row: 19, col: 6},\n\t\t{text: \"inside comprehension\", row: 27, col: 19},\n\t\t{text: \"inside set comprehension\", row: 31, col: 13},\n\t\t{text: \"inside object comprehension\", row: 35, col: 15},\n\t}\n\n\tif len(module.Comments) != len(exp) {\n\t\tt.Fatalf(\"Expected %v comments but got %v\", len(exp), len(module.Comments))\n\t}\n\n\tfor i := range exp {\n\n\t\texpc := &Comment{\n\t\t\tText: []byte(\" \" + exp[i].text),\n\t\t\tLocation: &Location{\n\t\t\t\tFile: \"test.rego\",\n\t\t\t\tText: []byte(\"# \" + exp[i].text),\n\t\t\t\tRow:  exp[i].row,\n\t\t\t\tCol:  exp[i].col,\n\t\t\t},\n\t\t}\n\n\t\tif !expc.Equal(module.Comments[i]) {\n\t\t\tcomment := module.Comments[i]\n\t\t\tfmt.Printf(\"comment: %v %v %v %v\\n\", comment.Location.File, comment.Location.Text, comment.Location.Col, comment.Location.Row)\n\t\t\tfmt.Printf(\"expcomm: %v %v %v %v\\n\", expc.Location.File, expc.Location.Text, expc.Location.Col, expc.Location.Row)\n\t\t\tt.Errorf(\"Expected %q but got: %q (want: %d:%d, got: %d:%d)\", expc, comment, exp[i].row, exp[i].col, comment.Location.Row, comment.Location.Col)\n\t\t}\n\t}\n}\n\nfunc TestCommentsWhitespace(t *testing.T) {\n\tcases := []struct {\n\t\tnote     string\n\t\tmodule   string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tnote:     \"trailing spaces\",\n\t\t\tmodule:   \"# a comment    \\t   \\n\",\n\t\t\texpected: []string{\" a comment    \\t   \"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"trailing carriage return\",\n\t\t\tmodule:   \"# a comment\\r\\n\",\n\t\t\texpected: []string{\" a comment\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"trailing carriage return double newline\",\n\t\t\tmodule:   \"# a comment\\r\\n\\n\",\n\t\t\texpected: []string{\" a comment\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"double trailing carriage return newline\",\n\t\t\tmodule:   \"#\\r\\r\\n\",\n\t\t\texpected: []string{\"\\r\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"double trailing carriage return\",\n\t\t\tmodule:   \"#\\r\\r\",\n\t\t\texpected: []string{\"\\r\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"carriage return\",\n\t\t\tmodule:   \"#\\r\",\n\t\t\texpected: []string{\"\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"carriage return in comment\",\n\t\t\tmodule:   \"# abc\\rdef\\r\\n\",\n\t\t\texpected: []string{\" abc\\rdef\"},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\t_, comments, err := ParseStatements(\"\", tc.module)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected parse error: %s\", err)\n\t\t\t}\n\n\t\t\tfor i, exp := range tc.expected {\n\t\t\t\tactual := string(comments[i].Text)\n\t\t\t\tif exp != actual {\n\t\t\t\t\tt.Errorf(\"Expected comment text (len %d):\\n\\n\\t%q\\n\\nbut got (len %d):\\n\\n\\t%q\\n\\n\", len(exp), exp, len(actual), actual)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExample(t *testing.T) {\n\tassertParseModule(t, \"example module\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package opa.examples`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import data.servers\").(*Import),\n\t\t\tMustParseStatement(\"import data.networks\").(*Import),\n\t\t\tMustParseStatement(\"import data.ports\").(*Import),\n\t\t},\n\t\tRules: []*Rule{\n\t\t\tMustParseStatement(`violations[server] { server = servers[i]; server.protocols[j] = \"http\"; public_servers[server] }`).(*Rule),\n\t\t\tMustParseStatement(`public_servers[server] { server = servers[i]; server.ports[j] = ports[k].id; ports[k].networks[l] = networks[m].id; networks[m].public = true }`).(*Rule),\n\t\t},\n\t})\n}\n\nfunc TestModuleParseErrors(t *testing.T) {\n\tinput := `\n\tx = 1\t\t\t# expect package\n\tpackage a  \t\t# unexpected package\n\t1 = 2\t\t\t# non-var head\n\t1 != 2\t\t\t# non-equality expr\n\tx = y; x = 1    # multiple exprs\n\t`\n\n\tmod, err := ParseModule(\"test.rego\", input)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error but got: %v\", mod)\n\t}\n\n\terrs, ok := err.(Errors)\n\tif !ok {\n\t\tpanic(\"unexpected error value\")\n\t}\n\n\tif len(errs) != 5 {\n\t\tt.Fatalf(\"Expected exactly 5 errors but got: %v\", err)\n\t}\n}\n\nfunc TestLocation(t *testing.T) {\n\tmod, err := ParseModule(\"test\", testModule)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error while parsing test module: %v\", err)\n\t\treturn\n\t}\n\texpr := mod.Rules[0].Body[0]\n\tif expr.Location.Col != 5 {\n\t\tt.Errorf(\"Expected column of %v to be 5 but got: %v\", expr, expr.Location.Col)\n\t}\n\tif expr.Location.Row != 15 {\n\t\tt.Errorf(\"Expected row of %v to be 8 but got: %v\", expr, expr.Location.Row)\n\t}\n\tif expr.Location.File != \"test\" {\n\t\tt.Errorf(\"Expected file of %v to be test but got: %v\", expr, expr.Location.File)\n\t}\n}\n\nfunc TestRuleFromBody(t *testing.T) {\n\ttestModule := `package a.b.c\n\npi = 3.14159\np[x] { x = 1 }\ngreeting = \"hello\"\ncores = [{0: 1}, {1: 2}]\nwrapper = cores[0][1]\npi = [3, 1, 4, x, y, z]\nfoo[\"bar\"] = \"buz\"\nfoo[\"9\"] = \"10\"\nfoo.buz = \"bar\"\nbar[1]\nbar[[{\"foo\":\"baz\"}]]\nbar.qux\ninput = 1\ndata = 2\nf(1) = 2\nf(1)\nd1 := 1234\n`\n\n\tassertParseModule(t, \"rules from bodies\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package a.b.c`).(*Package),\n\t\tRules: []*Rule{\n\t\t\tMustParseRule(`pi = 3.14159 { true }`),\n\t\t\tMustParseRule(`p[x] { x = 1 }`),\n\t\t\tMustParseRule(`greeting = \"hello\" { true }`),\n\t\t\tMustParseRule(`cores = [{0: 1}, {1: 2}] { true }`),\n\t\t\tMustParseRule(`wrapper = cores[0][1] { true }`),\n\t\t\tMustParseRule(`pi = [3, 1, 4, x, y, z] { true }`),\n\t\t\tMustParseRule(`foo[\"bar\"] = \"buz\" { true }`),\n\t\t\tMustParseRule(`foo[\"9\"] = \"10\" { true }`),\n\t\t\tMustParseRule(`foo[\"buz\"] = \"bar\" { true }`),\n\t\t\tMustParseRule(`bar[1] { true }`),\n\t\t\tMustParseRule(`bar[[{\"foo\":\"baz\"}]] { true }`),\n\t\t\tMustParseRule(`bar[\"qux\"] { true }`),\n\t\t\tMustParseRule(`input = 1 { true }`),\n\t\t\tMustParseRule(`data = 2 { true }`),\n\t\t\tMustParseRule(`f(1) = 2 { true }`),\n\t\t\tMustParseRule(`f(1) = true { true }`),\n\t\t\tMustParseRule(\"d1 := 1234 { true }\"),\n\t\t},\n\t})\n\n\t// Verify the rule and rule and rule head col/loc values\n\tmodule, err := ParseModule(\"test.rego\", testModule)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i := range module.Rules {\n\t\tcol := module.Rules[i].Location.Col\n\t\tif col != 1 {\n\t\t\tt.Fatalf(\"expected rule %v column to be 1 but got %v\", module.Rules[i].Head.Name, col)\n\t\t}\n\t\trow := module.Rules[i].Location.Row\n\t\tif row != 3+i { // 'pi' rule stats on row 3\n\t\t\tt.Fatalf(\"expected rule %v row to be %v but got %v\", module.Rules[i].Head.Name, 3+i, row)\n\t\t}\n\t\tcol = module.Rules[i].Head.Location.Col\n\t\tif col != 1 {\n\t\t\tt.Fatalf(\"expected rule head %v column to be 1 but got %v\", module.Rules[i].Head.Name, col)\n\t\t}\n\t\trow = module.Rules[i].Head.Location.Row\n\t\tif row != 3+i { // 'pi' rule stats on row 3\n\t\t\tt.Fatalf(\"expected rule head %v row to be %v but got %v\", module.Rules[i].Head.Name, 3+i, row)\n\t\t}\n\t}\n\n\tmockModule := `package ex\n\ninput = {\"foo\": 1}\ndata = {\"bar\": 2}`\n\n\tassertParseModule(t, \"rule name: input/data\", mockModule, &Module{\n\t\tPackage: MustParsePackage(`package ex`),\n\t\tRules: []*Rule{\n\t\t\tMustParseRule(`input = {\"foo\": 1} { true }`),\n\t\t\tMustParseRule(`data = {\"bar\": 2} { true }`),\n\t\t},\n\t})\n\n\tmultipleExprs := `\n    package a.b.c\n\n    pi = 3.14159; pi > 3\n    `\n\n\tnonEquality := `\n    package a.b.c\n\n    pi > 3\n    `\n\n\tnonVarName := `\n    package a.b.c\n\n    \"pi\" = 3\n    `\n\n\twithExpr := `\n\tpackage a.b.c\n\n\tfoo = input with input as 1\n\t`\n\n\tbadRefLen1 := `\n\tpackage a.b.c\n\n\tp[\"x\"].y = 1`\n\n\tbadRefLen2 := `\n\tpackage a.b.c\n\n\tp[\"x\"].y`\n\n\tnegated := `\n\tpackage a.b.c\n\n\tnot p = 1`\n\n\tnonRefTerm := `\n\tpackage a.b.c\n\n\tp`\n\n\tzeroArgs := `\n\tpackage a.b.c\n\n\tp()`\n\n\tassignToTerm := `\n\tpackage a.b.c\n\n\t\"foo\" := 1`\n\n\tsomeDecl := `\n\tpackage a\n\n\tsome x`\n\n\tarrayTerm := `\n\tpackage a\n\t[][0]\n\t`\n\n\tcallWithRuleKeyPartialSet := `\n\tpackage a\n\tf(x)[x] { true }`\n\n\tcallWithRuleKeyPartialObject := `\n\tpackage a\n\tf(x)[x] = x { true }`\n\n\tassignNoOperands := `\n\tpackage a\n\tassign()`\n\n\tassignOneOperand := `\n\tpackage a\n\tassign(x)`\n\n\teqNoOperands := `\n\tpackage a\n\teq()`\n\n\teqOneOperand := `\n\tpackage a\n\teq(x)`\n\n\tassertParseModuleError(t, \"multiple expressions\", multipleExprs)\n\tassertParseModuleError(t, \"non-equality\", nonEquality)\n\tassertParseModuleError(t, \"non-var name\", nonVarName)\n\tassertParseModuleError(t, \"with expr\", withExpr)\n\tassertParseModuleError(t, \"bad ref (too long)\", badRefLen1)\n\tassertParseModuleError(t, \"bad ref (too long)\", badRefLen2)\n\tassertParseModuleError(t, \"negated\", negated)\n\tassertParseModuleError(t, \"non ref term\", nonRefTerm)\n\tassertParseModuleError(t, \"zero args\", zeroArgs)\n\tassertParseModuleError(t, \"assign to term\", assignToTerm)\n\tassertParseModuleError(t, \"some decl\", someDecl)\n\tassertParseModuleError(t, \"array term\", arrayTerm)\n\tassertParseModuleError(t, \"call in ref partial set\", \"package test\\nf().x {}\")\n\tassertParseModuleError(t, \"call in ref partial object\", \"package test\\nf().x = y {}\")\n\tassertParseModuleError(t, \"number in ref\", \"package a\\n12[3]()=4\")\n\tassertParseModuleError(t, \"rule with args and key\", callWithRuleKeyPartialObject)\n\tassertParseModuleError(t, \"rule with args and key\", callWithRuleKeyPartialSet)\n\tassertParseModuleError(t, \"assign without operands\", assignNoOperands)\n\tassertParseModuleError(t, \"assign with only one operand\", assignOneOperand)\n\tassertParseModuleError(t, \"eq without operands\", eqNoOperands)\n\tassertParseModuleError(t, \"eq with only one operand\", eqOneOperand)\n\n\tif _, err := ParseRuleFromExpr(&Module{}, &Expr{\n\t\tTerms: struct{}{},\n\t}); err == nil {\n\t\tt.Fatal(\"expected error for unknown expression term type\")\n\t}\n}\n\nfunc TestWildcards(t *testing.T) {\n\n\tassertParseOneTerm(t, \"ref\", \"a.b[_].c[_]\", RefTerm(\n\t\tVarTerm(\"a\"),\n\t\tStringTerm(\"b\"),\n\t\tVarTerm(\"$0\"),\n\t\tStringTerm(\"c\"),\n\t\tVarTerm(\"$1\"),\n\t))\n\n\tassertParseOneTerm(t, \"nested\", `[{\"a\": a[_]}, _, {\"b\": _}]`, ArrayTerm(\n\t\tObjectTerm(\n\t\t\tItem(StringTerm(\"a\"), RefTerm(VarTerm(\"a\"), VarTerm(\"$0\"))),\n\t\t),\n\t\tVarTerm(\"$1\"),\n\t\tObjectTerm(\n\t\t\tItem(StringTerm(\"b\"), VarTerm(\"$2\")),\n\t\t),\n\t))\n\n\tassertParseOneExpr(t, \"expr\", `_ = [a[_]]`, Equality.Expr(\n\t\tVarTerm(\"$0\"),\n\t\tArrayTerm(\n\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"$1\")),\n\t\t)))\n\n\tassertParseOneExpr(t, \"comprehension\", `_ = [x | a = a[_]]`, Equality.Expr(\n\t\tVarTerm(\"$0\"),\n\t\tArrayComprehensionTerm(\n\t\t\tVarTerm(\"x\"),\n\t\t\tNewBody(\n\t\t\t\tEquality.Expr(\n\t\t\t\t\tVarTerm(\"a\"),\n\t\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"$1\")),\n\t\t\t\t),\n\t\t\t),\n\t\t)))\n\n\tassertParseRule(t, \"functions\", `f(_) = y { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"f\"),\n\t\t\tArgs: Args{\n\t\t\t\tVarTerm(\"$0\"),\n\t\t\t},\n\t\t\tValue: VarTerm(\"y\"),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n}\n\nfunc TestRuleModulePtr(t *testing.T) {\n\tmod := `package test\n\n\tp { true }\n\tp { true }\n\tq { true }\n\tr = 1\n\tdefault s = 2\n\t`\n\n\tparsed, err := ParseModule(\"\", mod)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\tfor _, rule := range parsed.Rules {\n\t\tif rule.Module != parsed {\n\t\t\tt.Fatalf(\"Expected module ptr to be %p but got %p\", parsed, rule.Module)\n\t\t}\n\t}\n}\n\nfunc TestNoMatchError(t *testing.T) {\n\tmod := `package test\n\n\tp { true;\n\t\t 1 != 0; # <-- parse error: no match\n\t}`\n\n\t_, err := ParseModule(\"foo.rego\", mod)\n\n\texpected := \"1 error occurred: foo.rego:5: rego_parse_error: unexpected } token\"\n\n\tif !strings.HasPrefix(err.Error(), expected) {\n\t\tt.Fatalf(\"Bad parse error, expected %v but got: %v\", expected, err)\n\t}\n\n\tmod = `package test\n\n\tp { true // <-- parse error: no match`\n\n\t_, err = ParseModule(\"foo.rego\", mod)\n\n\tloc := NewLocation([]byte{'/'}, \"foo.rego\", 3, 12)\n\n\tif !loc.Equal(err.(Errors)[0].Location) {\n\t\tt.Fatalf(\"Expected %v but got: %v\", loc, err)\n\t}\n}\n\nfunc TestParseErrorDetails(t *testing.T) {\n\n\ttests := []struct {\n\t\tnote  string\n\t\texp   *ParserErrorDetail\n\t\terr   string\n\t\tinput string\n\t}{\n\t\t{\n\t\t\tnote: \"no match: bad rule name\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \".\",\n\t\t\t\tIdx:  0,\n\t\t\t},\n\t\t\tinput: `\npackage test\n.`,\n\t\t},\n\t\t{\n\t\t\tnote: \"no match: bad termination for comprehension\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p = [true | true}\",\n\t\t\t\tIdx:  16,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = [true | true}`},\n\t\t{\n\t\t\tnote: \"no match: non-terminated comprehension\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p = [true | true\",\n\t\t\t\tIdx:  15,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = [true | true`},\n\t\t{\n\t\t\tnote: \"no match: expected expression\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p { true; }\",\n\t\t\t\tIdx:  10,\n\t\t\t},\n\t\t\tinput: `\npackage test\np { true; }`},\n\t\t{\n\t\t\tnote: \"empty body\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p { }\",\n\t\t\t\tIdx:  4,\n\t\t\t},\n\t\t\tinput: `\npackage test\np { }`},\n\t\t{\n\t\t\tnote: \"non-terminated string\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: `p = \"foo`,\n\t\t\t\tIdx:  4,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = \"foo`},\n\t\t{\n\t\t\tnote: \"rule with error begins with one tab\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\tas\",\n\t\t\t\tIdx:  1,\n\t\t\t},\n\t\t\tinput: `\npackage test\n\tas`,\n\t\t\terr: `1 error occurred: test.rego:3: rego_parse_error: unexpected as keyword\n\tas\n\t^`},\n\t\t{\n\t\t\tnote: \"rule term with error begins with two tabs\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\t\\tas\",\n\t\t\t\tIdx:  2,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = true {\n\t\tas\n}`,\n\t\t\terr: `1 error occurred: test.rego:4: rego_parse_error: unexpected as keyword\n\tas\n\t^`},\n\t\t{\n\t\t\tnote: \"input is tab and space tokens only\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\t\\v\\f \",\n\t\t\t\tIdx:  0,\n\t\t\t},\n\t\t\tinput: \"\\t\\v\\f \",\n\t\t\t// NOTE(sr): With the unprintable control characters, the output is pretty\n\t\t\t// useless. But it's also quite an edge case.\n\t\t\terr: \"1 error occurred: test.rego:1: rego_parse_error: illegal token\\n\\t\\v\\f \\n\\t^\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\t_, err := ParseModule(\"test.rego\", tc.input)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Expected error\")\n\t\t\t}\n\t\t\tdetail := err.(Errors)[0].Details\n\t\t\tif !reflect.DeepEqual(detail, tc.exp) {\n\t\t\t\tt.Errorf(\"Expected %v but got: %v\", tc.exp, detail)\n\t\t\t}\n\t\t\tif tc.err != \"\" && tc.err != err.Error() {\n\t\t\t\tt.Fatalf(\"Expected error string %q but got: %q\", tc.err, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNamespacedBuiltins(t *testing.T) {\n\n\ttests := []struct {\n\t\texpr     string\n\t\texpected *Term\n\t\twantErr  bool\n\t}{\n\t\t{`foo.bar.baz(1, 2)`, MustParseTerm(\"foo.bar.baz\"), false},\n\t\t{`foo.(1,2)`, nil, true},\n\t\t{`foo.#.bar(1,2)`, nil, true},\n\t}\n\n\tfor _, tc := range tests {\n\t\texpr, err := ParseExpr(tc.expr)\n\t\tif !tc.wantErr {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t\t\t}\n\t\t\tterms, ok := expr.Terms.([]*Term)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Expected terms not: %T\", expr.Terms)\n\t\t\t}\n\t\t\tif !terms[0].Equal(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected builtin-name to equal %v but got: %v\", tc.expected, terms)\n\t\t\t}\n\t\t} else if err == nil {\n\t\t\tt.Fatalf(\"Expected error from %v but got: %v\", tc.expr, expr)\n\t\t}\n\t}\n}\n\nfunc TestRuleHeadLocation(t *testing.T) {\n\n\tconst input = `package pkg\n\np[x] {\n\tx = \"hi\"\n} {\n\tx = \"bye\"\n}\n\nf(x) {\n\tfalse\n} else = false {\n\ttrue\n}\n`\n\n\tmodule := MustParseModule(input)\n\n\tfor _, tc := range []struct {\n\t\tnote         string\n\t\tlocation     *Location\n\t\texpectedRow  int\n\t\texpectedText string\n\t}{\n\t\t{\n\t\t\tnote:        \"partial rule\",\n\t\t\tlocation:    module.Rules[0].Location,\n\t\t\texpectedRow: 3,\n\t\t\texpectedText: `\np[x] {\n\tx = \"hi\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"partial rule head\",\n\t\t\tlocation:     module.Rules[0].Head.Location,\n\t\t\texpectedRow:  3,\n\t\t\texpectedText: `p[x]`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"partial rule head key\",\n\t\t\tlocation:     module.Rules[0].Head.Key.Location,\n\t\t\texpectedRow:  3,\n\t\t\texpectedText: `x`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule\",\n\t\t\tlocation:    module.Rules[1].Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule head\",\n\t\t\tlocation:    module.Rules[1].Head.Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule head key\",\n\t\t\tlocation:    module.Rules[1].Head.Key.Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"rule with args\",\n\t\t\tlocation:    module.Rules[2].Location,\n\t\t\texpectedRow: 9,\n\t\t\texpectedText: `\nf(x) {\n\tfalse\n} else = false {\n\ttrue\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"rule with args head\",\n\t\t\tlocation:     module.Rules[2].Head.Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `f(x)`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"rule with args head arg 0\",\n\t\t\tlocation:     module.Rules[2].Head.Args[0].Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `x`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"else with args\",\n\t\t\tlocation:    module.Rules[2].Else.Location,\n\t\t\texpectedRow: 11,\n\t\t\texpectedText: `\nelse = false {\n\ttrue\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"else with args head\",\n\t\t\tlocation:     module.Rules[2].Else.Head.Location,\n\t\t\texpectedRow:  11,\n\t\t\texpectedText: `else = false`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"else with args head arg 0\",\n\t\t\tlocation:     module.Rules[2].Else.Head.Args[0].Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `x`,\n\t\t},\n\t} {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tif tc.location.Row != tc.expectedRow {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", tc.expectedRow, tc.location.Row)\n\t\t\t}\n\t\t\texp := strings.TrimSpace(tc.expectedText)\n\t\t\tif string(tc.location.Text) != exp {\n\t\t\t\tt.Errorf(\"Expected text:\\n%s\\n\\ngot:\\n%s\\n\\n\", exp, tc.location.Text)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParserText(t *testing.T) {\n\n\ttests := []struct {\n\t\tnote  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tnote:  \"relational term\",\n\t\t\tinput: `(1 == (2 > 3))`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - empty\",\n\t\t\tinput: `[ ]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - one element\",\n\t\t\tinput: `[ 1 ]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - multiple elements\",\n\t\t\tinput: `[1 , 2 , 3]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - empty\",\n\t\t\tinput: `{ }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - one element\",\n\t\t\tinput: `{ \"foo\": 1 }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - multiple elements\",\n\t\t\tinput: `{\"foo\": 1, \"bar\": 2}`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"set - one element\",\n\t\t\tinput: `{ 1 }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"set - multiple elements\",\n\t\t\tinput: `{1 , 2 , 3}`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"idents\",\n\t\t\tinput: \"foo\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"ref\",\n\t\t\tinput: `data.foo[x].bar`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"call\",\n\t\t\tinput: `data.foo.bar(x)`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"ref and call\",\n\t\t\tinput: `data.foo[1](x).bar(y)[z]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"infix\",\n\t\t\tinput: \"input = 1\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"negated\",\n\t\t\tinput: \"not x = 1\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"expr with statements\",\n\t\t\tinput: \"x = 1 with input as 2 with input as 3\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tfor _, suffix := range []string{\"\", \"\\t\\n \"} {\n\t\t\t\tinput := tc.input + suffix\n\n\t\t\t\tstmts, _, err := ParseStatements(\"test.rego\", input)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif len(stmts) != 1 {\n\t\t\t\t\tt.Fatal(\"expected exactly one statement but got:\", stmts)\n\t\t\t\t}\n\n\t\t\t\tresult := string(stmts[0].Loc().Text)\n\n\t\t\t\tif result != tc.input {\n\t\t\t\t\tt.Fatalf(\"expected %q but got: %q\", tc.input, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleText(t *testing.T) {\n\tinput := ` package test\n\nr[x] = y {\n\tx = input.a\n\tx = \"foo\"\n} {\n\tx = input.b\n\tx = \"bar\"\n} {\n\tx = input.c\n\tx = \"baz\"\n}\n\nr[x] = y {\n\tx = input.d\n\tx = \"qux\"\n}\n`\n\n\tmod := MustParseModule(input)\n\trules := mod.Rules\n\n\tif len(rules) != 4 {\n\t\tt.Fatalf(\"Expected 4 rules, got %d\", len(rules))\n\t}\n\n\texpectedRuleText := []string{\n\t\t`\nr[x] = y {\n\tx = input.a\n\tx = \"foo\"\n}\n\t\t`,\n\t\t`\n{\n\tx = input.b\n\tx = \"bar\"\n}\n\t\t`,\n\t\t`\n{\n\tx = input.c\n\tx = \"baz\"\n}\n\t\t`,\n\t\t`\nr[x] = y {\n\tx = input.d\n\tx = \"qux\"\n}\n\t\t`,\n\t}\n\n\tassertLocationText(t, strings.TrimSpace(expectedRuleText[0]), rules[0].Location)\n\tassertLocationText(t, \"r[x] = y\", rules[0].Head.Location)\n\tassertLocationText(t, \"y\", rules[0].Head.Value.Location)\n\n\t// Chained rules recursively set text on heads to be the full rule\n\tfor i := 1; i < len(expectedRuleText)-1; i++ {\n\t\ttext := strings.TrimSpace(expectedRuleText[i])\n\t\tassertLocationText(t, text, rules[i].Location)\n\t\tassertLocationText(t, text, rules[i].Head.Location)\n\t\tassertLocationText(t, text, rules[i].Head.Value.Location)\n\t}\n\n\tassertLocationText(t, strings.TrimSpace(expectedRuleText[3]), rules[3].Location)\n\tassertLocationText(t, \"r[x] = y\", rules[3].Head.Location)\n\tassertLocationText(t, \"y\", rules[3].Head.Value.Location)\n}\n\nfunc TestRuleElseText(t *testing.T) {\n\tinput := `\nr1 = x {\n\ta == \"foo\"\n} else = y {\n\tb == \"bar\"\n}\n\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n`\n\n\trule := MustParseRule(input)\n\tassertLocationText(t, strings.TrimSpace(input), rule.Location)\n\tassertLocationText(t, \"r1 = x\", rule.Head.Location)\n\tassertLocationText(t, \"x\", rule.Head.Value.Location)\n\n\tcurElse := rule.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse = y {\n\tb == \"bar\"\n}\n\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, \"else = y\", curElse.Head.Location)\n\tassertLocationText(t, \"y\", curElse.Head.Value.Location)\n\n\tcurElse = curElse.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, \"else\", curElse.Head.Location)\n\tif curElse.Head.Value.Location != nil {\n\t\tt.Errorf(\"Expected a nil location\")\n\t}\n\n\tcurElse = curElse.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, strings.TrimSpace(`\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n}\n\t`), curElse.Head.Location)\n\tassertLocationText(t, strings.TrimSpace(`\n{\n\t\"k1\": 1,\n\t\"k2\": 2\n}\n\t`), curElse.Head.Value.Location)\n}\n\nfunc TestAnnotations(t *testing.T) {\n\n\tdataServers := MustParseRef(\"data.servers\")\n\tdataNetworks := MustParseRef(\"data.networks\")\n\tdataPorts := MustParseRef(\"data.ports\")\n\n\tschemaServers := MustParseRef(\"schema.servers\")\n\tschemaNetworks := MustParseRef(\"schema.networks\")\n\tschemaPorts := MustParseRef(\"schema.ports\")\n\n\tstringSchemaAsMap := map[string]interface{}{\n\t\t\"type\": \"string\",\n\t}\n\tvar stringSchema interface{} = stringSchemaAsMap\n\n\ttests := []struct {\n\t\tnote           string\n\t\tmodule         string\n\t\texpNumComments int\n\t\texpAnnotations []*Annotations\n\t\texpError       string\n\t}{\n\t\t{\n\t\t\tnote: \"Single valid annotation\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple annotations on multiple lines\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 6,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Comment in between metadata and rule (valid)\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n\n# This is a comment after the metadata YAML\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Empty comment line in between metadata and rule (valid)\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n#\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) metadata start\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n# METADATA\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpError: \"test.rego:14: rego_parse_error: yaml: line 7: could not find expected ':'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation document path\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data/servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpError:       \"rego_parse_error: invalid document reference\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation schema path\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema/servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpError:       \"rego_parse_error: invalid schema reference\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers= schema\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 5,\n\t\t\texpError:       \"rego_parse_error: yaml: unmarshal errors:\\n  line 3: cannot unmarshal !!str\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Indentation error in yaml\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n# - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 6,\n\t\t\texpError:       \"rego_parse_error: yaml: line 3: did not find expected key\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple rules with and without metadata\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}\n\npublic_servers_1[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n\tserver.typo  # won't catch this type error since rule has no schema metadata\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple rules with metadata\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]\n}\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers_1[server] {\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 9,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tnode:  MustParseRule(`public_servers[server] { server = servers[i] }`),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tnode:  MustParseRule(`public_servers_1[server] { ports[k].networks[l] = networks[m].id; networks[m].public = true }`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"multiple metadata blocks on a single rule\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My rule\n\n# METADATA\n# title: My rule 2\np { input = \"str\" }`,\n\t\t\texpNumComments: 4,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tTitle: \"My rule\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tTitle: \"My rule 2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Empty annotation error due to whitespace following METADATA hint\",\n\t\t\tmodule: `package test\n\n# METADATA\n\n# scope: rule\np { input.x > 7 }`,\n\t\t\texpError: \"test.rego:3: rego_parse_error: expected METADATA block, found whitespace\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Annotation on constant\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# scope: rule\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{Scope: annotationScopeRule},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"annotation on package\",\n\t\t\tmodule: `# METADATA\n# title: My package\npackage test\n\np { input = \"str\" }`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopePackage,\n\t\t\t\t\tTitle: \"My package\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"annotation on import\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My import\nimport input.foo\n\np { input = \"str\" }`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"1 error occurred: test.rego:3: rego_parse_error: invalid annotation scope 'import'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Default rule scope\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# {}\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{Scope: annotationScopeRule},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Unknown scope\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# scope: deadbeef\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"invalid annotation scope 'deadbeef'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Invalid rule scope/attachment\",\n\t\t\tmodule: `\n# METADATA\n# scope: rule\npackage test\n\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"test.rego:2: rego_parse_error: annotation scope 'rule' must be applied to rule (have package)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: document on import\",\n\t\t\tmodule: `package test\n# METADATA\n# scope: document\nimport data.foo.bar`,\n\t\t\texpError: \"test.rego:2: rego_parse_error: annotation scope 'document' must be applied to rule (have import)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: unattached\",\n\t\t\tmodule: `package test\n\n# METADATA\n# scope: package`,\n\t\t\texpError: \"test.rego:3: rego_parse_error: annotation scope 'package' must be applied to package\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: package on non-package\",\n\t\t\tmodule: `package test\n# METADATA\n# scope: package\nimport data.foo`,\n\t\t\texpError: \"test.rego:2: rego_parse_error: annotation scope 'package' must be applied to package (have import)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Inline schema definition\",\n\t\t\tmodule: `package test\n\n# METADATA\n# schemas:\n# - input: {\"type\": \"string\"}\np { input = \"str\" }`,\n\t\t\texpNumComments: 3,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: InputRootRef, Definition: &stringSchema},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Rich meta\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My rule\n# description: |\n#  My rule has a\n#  multiline description.\n# organizations:\n# - Acme Corp.\n# - Soylent Corp.\n# - Tyrell Corp.\n# related_resources:\n# - https://example.com\n# - \n#  ref: http://john:123@do.re/mi?foo=bar#baz\n#  description: foo bar\n# authors:\n# - John Doe <john@example.com>\n# - name: Jane Doe\n#   email: jane@example.com\n# custom:\n#  list:\n#   - a\n#   - b\n#  map:\n#   a: 1\n#   b: 2.2\n#   c:\n#    \"3\": d\n#    \"4\": e\n#  number: 42\n#  string: foo bar baz\n#  flag:\np { input = \"str\" }`,\n\t\t\texpNumComments: 31,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope:         annotationScopeRule,\n\t\t\t\t\tTitle:         \"My rule\",\n\t\t\t\t\tDescription:   \"My rule has a\\nmultiline description.\\n\",\n\t\t\t\t\tOrganizations: []string{\"Acme Corp.\", \"Soylent Corp.\", \"Tyrell Corp.\"},\n\t\t\t\t\tRelatedResources: []*RelatedResourceAnnotation{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRef: mustParseURL(\"https://example.com\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRef:         mustParseURL(\"http://john:123@do.re/mi?foo=bar#baz\"),\n\t\t\t\t\t\t\tDescription: \"foo bar\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAuthors: []*AuthorAnnotation{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"John Doe\",\n\t\t\t\t\t\t\tEmail: \"john@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"Jane Doe\",\n\t\t\t\t\t\t\tEmail: \"jane@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tCustom: map[string]interface{}{\n\t\t\t\t\t\t\"list\": []interface{}{\n\t\t\t\t\t\t\t\"a\", \"b\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"map\": map[string]interface{}{\n\t\t\t\t\t\t\t\"a\": 1,\n\t\t\t\t\t\t\t\"b\": 2.2,\n\t\t\t\t\t\t\t\"c\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"3\": \"d\",\n\t\t\t\t\t\t\t\t\"4\": \"e\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"number\": 42,\n\t\t\t\t\t\t\"string\": \"foo bar baz\",\n\t\t\t\t\t\t\"flag\":   nil,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tmod, err := ParseModuleWithOpts(\"test.rego\", tc.module, ParserOptions{\n\t\t\t\tProcessAnnotation: true,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif tc.expError == \"\" || !strings.Contains(err.Error(), tc.expError) {\n\t\t\t\t\tt.Fatalf(\"Unexpected parse error when getting annotations: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if tc.expError != \"\" {\n\t\t\t\tt.Fatalf(\"Expected err: %v but no error from parse module\", tc.expError)\n\t\t\t}\n\n\t\t\tif len(mod.Comments) != tc.expNumComments {\n\t\t\t\tt.Fatalf(\"Expected %v comments but got %v\", tc.expNumComments, len(mod.Comments))\n\t\t\t}\n\n\t\t\tif annotationsCompare(tc.expAnnotations, mod.Annotations) != 0 {\n\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expAnnotations, mod.Annotations)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthorAnnotation(t *testing.T) {\n\ttests := []struct {\n\t\tnote     string\n\t\traw      interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tnote:     \"no name\",\n\t\t\traw:      \"\",\n\t\t\texpected: fmt.Errorf(\"author is an empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"only whitespaces\",\n\t\t\traw:      \" \\t\",\n\t\t\texpected: fmt.Errorf(\"author is an empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"one name only\",\n\t\t\traw:      \"John\",\n\t\t\texpected: AuthorAnnotation{Name: \"John\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"multiple names\",\n\t\t\traw:      \"John Jr.\\tDoe\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Jr. Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"email only\",\n\t\t\traw:      \"<john@example.com>\",\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name and email\",\n\t\t\traw:      \"John Doe <john@example.com>\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty email\",\n\t\t\traw:      \"John Doe <>\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name with reserved characters\",\n\t\t\traw:      \"John Doe < >\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe < >\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name with reserved characters (email with space)\",\n\t\t\traw:      \"<john@ example.com>\",\n\t\t\texpected: AuthorAnnotation{Name: \"<john@ example.com>\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\": \"John Doe\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name and email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with extra entry\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t\t\"foo\":   \"bar\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty map\",\n\t\t\traw:      map[string]interface{}{},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with email and empty name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"email\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name and empty email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := parseAuthor(tc.raw)\n\n\t\t\tswitch expected := tc.expected.(type) {\n\t\t\tcase AuthorAnnotation:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif parsed.Compare(&expected) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\t\t\tcase error:\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected '%v' error but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\n\t\t\t\tif strings.Compare(expected.Error(), err.Error()) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected result type: %T\", expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRelatedResourceAnnotation(t *testing.T) {\n\ttests := []struct {\n\t\tnote     string\n\t\traw      interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tnote:     \"empty ref URL\",\n\t\t\traw:      \"\",\n\t\t\texpected: fmt.Errorf(\"ref URL may not be empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"only whitespaces in ref URL\",\n\t\t\traw:      \" \\t\",\n\t\t\texpected: fmt.Errorf(\"parse \\\" \\\\t\\\": net/url: invalid control character in URL\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"invalid ref URL\",\n\t\t\traw:      \"https://foo:bar\",\n\t\t\texpected: fmt.Errorf(\"parse \\\"https://foo:bar\\\": invalid port \\\":bar\\\" after host\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"ref URL as string\",\n\t\t\traw:      \"https://example.com/foo?bar#baz\",\n\t\t\texpected: RelatedResourceAnnotation{Ref: mustParseURL(\"https://example.com/foo?bar#baz\")},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \"https://example.com/foo?bar#baz\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{Ref: mustParseURL(\"https://example.com/foo?bar#baz\")},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with ref and description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\":         \"https://example.com/foo?bar#baz\",\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{\n\t\t\t\tRef:         mustParseURL(\"https://example.com/foo?bar#baz\"),\n\t\t\t\tDescription: \"foo bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with ref and description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\":         \"https://example.com/foo?bar#baz\",\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t\t\"foo\":         \"bar\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{\n\t\t\t\tRef:         mustParseURL(\"https://example.com/foo?bar#baz\"),\n\t\t\t\tDescription: \"foo bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty map\",\n\t\t\traw:      map[string]interface{}{},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only whitespace in ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \" \\t\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := parseRelatedResource(tc.raw)\n\n\t\t\tswitch expected := tc.expected.(type) {\n\t\t\tcase RelatedResourceAnnotation:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif parsed.Compare(&expected) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\t\t\tcase error:\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected '%v' error but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\n\t\t\t\tif strings.Compare(expected.Error(), err.Error()) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected result type: %T\", expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc assertLocationText(t *testing.T, expected string, actual *Location) {\n\tt.Helper()\n\tif actual == nil || actual.Text == nil {\n\t\tt.Errorf(\"Expected a non nil location and text\")\n\t\treturn\n\t}\n\tif string(actual.Text) != expected {\n\t\tt.Errorf(\"Unexpected Location text, got:\\n%s\\n\\nExpected:\\n%s\\n\\n\", actual.Text, expected)\n\t}\n}\n\nfunc assertParseError(t *testing.T, msg string, input string) {\n\tt.Helper()\n\tt.Run(msg, func(t *testing.T) {\n\t\tassertParseErrorFunc(t, msg, input, func(string) {})\n\t})\n}\n\nfunc assertParseErrorContains(t *testing.T, msg string, input string, expected string, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseErrorFunc(t, msg, input, func(result string) {\n\t\tt.Helper()\n\t\tif !strings.Contains(result, expected) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error to contain:\\n\\n%v\\n\\nbut got:\\n\\n%v\", msg, expected, result)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseErrorFunc(t *testing.T, msg string, input string, f func(string), opts ...ParserOptions) {\n\tt.Helper()\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tstmts, _, err := ParseStatementsWithOpts(\"\", input, opt)\n\tif err == nil && len(stmts) != 1 {\n\t\terr = fmt.Errorf(\"expected exactly one statement\")\n\t}\n\tif err == nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error on %s: expected no statements, got %d: %v\", msg, input, len(stmts), stmts)\n\t\treturn\n\t}\n\tresult := err.Error()\n\t// error occurred: <line>:<col>: <message>\n\tparts := strings.SplitN(result, \":\", 4)\n\tresult = strings.TrimSpace(parts[len(parts)-1])\n\tf(result)\n}\n\nfunc assertParseImport(t *testing.T, msg string, input string, correct *Import, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\timp := parsed.(*Import)\n\t\tif !imp.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": imports not equal: %v (parsed), %v (correct)\", msg, imp, correct)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseModule(t *testing.T, msg string, input string, correct *Module, opts ...ParserOptions) {\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tm, err := ParseModuleWithOpts(\"\", input, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: %s\", msg, input, err)\n\t\treturn\n\t}\n\n\tif !m.Equal(correct) {\n\t\tt.Errorf(\"Error on test %s: modules not equal: %v (parsed), %v (correct)\", msg, m, correct)\n\t}\n\n}\n\nfunc assertParseModuleError(t *testing.T, msg, input string) {\n\tm, err := ParseModule(\"\", input)\n\tif err == nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error: %v (parsed)\", msg, m)\n\t}\n}\n\nfunc assertParsePackage(t *testing.T, msg string, input string, correct *Package) {\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tpkg := parsed.(*Package)\n\t\tif !pkg.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": packages not equal: %v (parsed), %v (correct)\", msg, pkg, correct)\n\t\t}\n\t})\n}\n\nfunc assertParseOne(t *testing.T, msg string, input string, correct func(interface{}), opts ...ParserOptions) {\n\tt.Helper()\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tstmts, _, err := ParseStatementsWithOpts(\"\", input, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: %s\", msg, input, err)\n\t\treturn\n\t}\n\tif len(stmts) != 1 {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: expected exactly one statement, got %d\", msg, input, len(stmts))\n\t\treturn\n\t}\n\tcorrect(stmts[0])\n}\n\nfunc assertParseOneBody(t *testing.T, msg string, input string, correct Body) {\n\tt.Helper()\n\tbody, err := ParseBody(input)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !body.Equal(correct) {\n\t\tt.Fatalf(\"Error on test \\\"%s\\\": bodies not equal:\\n%v (parsed)\\n%v (correct)\", msg, body, correct)\n\t}\n}\n\nfunc assertParseOneExpr(t *testing.T, msg string, input string, correct *Expr, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\tbody := parsed.(Body)\n\t\tif len(body) != 1 {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": parser returned multiple expressions: %v\", msg, body)\n\t\t\treturn\n\t\t}\n\t\texpr := body[0]\n\t\tif !expr.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": expressions not equal:\\n%v (parsed)\\n%v (correct)\", msg, expr, correct)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseOneExprNegated(t *testing.T, msg string, input string, correct *Expr) {\n\tcorrect.Negated = true\n\tassertParseOneExpr(t, msg, input, correct)\n}\n\nfunc assertParseOneTerm(t *testing.T, msg string, input string, correct *Term) {\n\tt.Helper()\n\tt.Run(msg, func(t *testing.T) {\n\t\tassertParseOneExpr(t, msg, input, &Expr{Terms: correct})\n\t})\n}\n\nfunc assertParseOneTermNegated(t *testing.T, msg string, input string, correct *Term) {\n\tt.Helper()\n\tassertParseOneExprNegated(t, msg, input, &Expr{Terms: correct})\n}\n\nfunc assertParseRule(t *testing.T, msg string, input string, correct *Rule) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\trule := parsed.(*Rule)\n\t\tif !rule.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": rules not equal: %v (parsed), %v (correct)\", msg, rule, correct)\n\t\t}\n\t})\n}\n"], "fixing_code": ["// Copyright 2020 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\n\npackage ast\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"gopkg.in/yaml.v2\"\n\n\t\"github.com/open-policy-agent/opa/ast/internal/scanner\"\n\t\"github.com/open-policy-agent/opa/ast/internal/tokens\"\n\t\"github.com/open-policy-agent/opa/ast/location\"\n)\n\n// Note: This state is kept isolated from the parser so that we\n// can do efficient shallow copies of these values when doing a\n// save() and restore().\ntype state struct {\n\ts         *scanner.Scanner\n\tlastEnd   int\n\tskippedNL bool\n\ttok       tokens.Token\n\ttokEnd    int\n\tlit       string\n\tloc       Location\n\terrors    Errors\n\thints     []string\n\tcomments  []*Comment\n\twildcard  int\n}\n\nfunc (s *state) String() string {\n\treturn fmt.Sprintf(\"<s: %v, tok: %v, lit: %q, loc: %v, errors: %d, comments: %d>\", s.s, s.tok, s.lit, s.loc, len(s.errors), len(s.comments))\n}\n\nfunc (s *state) Loc() *location.Location {\n\tcpy := s.loc\n\treturn &cpy\n}\n\nfunc (s *state) Text(offset, end int) []byte {\n\tbs := s.s.Bytes()\n\tif offset >= 0 && offset < len(bs) {\n\t\tif end >= offset && end <= len(bs) {\n\t\t\treturn bs[offset:end]\n\t\t}\n\t}\n\treturn nil\n}\n\n// Parser is used to parse Rego statements.\ntype Parser struct {\n\tr     io.Reader\n\ts     *state\n\tpo    ParserOptions\n\tcache parsedTermCache\n}\n\ntype parsedTermCacheItem struct {\n\tt      *Term\n\tpost   *state // post is the post-state that's restored on a cache-hit\n\toffset int\n\tnext   *parsedTermCacheItem\n}\n\ntype parsedTermCache struct {\n\tm *parsedTermCacheItem\n}\n\nfunc (c parsedTermCache) String() string {\n\ts := strings.Builder{}\n\ts.WriteRune('{')\n\tvar e *parsedTermCacheItem\n\tfor e = c.m; e != nil; e = e.next {\n\t\tfmt.Fprintf(&s, \"%v\", e)\n\t}\n\ts.WriteRune('}')\n\treturn s.String()\n}\n\nfunc (e *parsedTermCacheItem) String() string {\n\treturn fmt.Sprintf(\"<%d:%v>\", e.offset, e.t)\n}\n\n// ParserOptions defines the options for parsing Rego statements.\ntype ParserOptions struct {\n\tCapabilities       *Capabilities\n\tProcessAnnotation  bool\n\tAllFutureKeywords  bool\n\tFutureKeywords     []string\n\tunreleasedKeywords bool // TODO(sr): cleanup\n}\n\n// NewParser creates and initializes a Parser.\nfunc NewParser() *Parser {\n\tp := &Parser{\n\t\ts:  &state{},\n\t\tpo: ParserOptions{},\n\t}\n\treturn p\n}\n\n// WithFilename provides the filename for Location details\n// on parsed statements.\nfunc (p *Parser) WithFilename(filename string) *Parser {\n\tp.s.loc.File = filename\n\treturn p\n}\n\n// WithReader provides the io.Reader that the parser will\n// use as its source.\nfunc (p *Parser) WithReader(r io.Reader) *Parser {\n\tp.r = r\n\treturn p\n}\n\n// WithProcessAnnotation enables or disables the processing of\n// annotations by the Parser\nfunc (p *Parser) WithProcessAnnotation(processAnnotation bool) *Parser {\n\tp.po.ProcessAnnotation = processAnnotation\n\treturn p\n}\n\n// WithFutureKeywords enables \"future\" keywords, i.e., keywords that can\n// be imported via\n//\n//     import future.keywords.kw\n//     import future.keywords.other\n//\n// but in a more direct way. The equivalent of this import would be\n//\n//     WithFutureKeywords(\"kw\", \"other\")\nfunc (p *Parser) WithFutureKeywords(kws ...string) *Parser {\n\tp.po.FutureKeywords = kws\n\treturn p\n}\n\n// WithAllFutureKeywords enables all \"future\" keywords, i.e., the\n// ParserOption equivalent of\n//\n//     import future.keywords\nfunc (p *Parser) WithAllFutureKeywords(yes bool) *Parser {\n\tp.po.AllFutureKeywords = yes\n\treturn p\n}\n\n// withUnreleasedKeywords allows using keywords that haven't surfaced\n// as future keywords (see above) yet, but have tests that require\n// them to be parsed\nfunc (p *Parser) withUnreleasedKeywords(yes bool) *Parser {\n\tp.po.unreleasedKeywords = yes\n\treturn p\n}\n\n// WithCapabilities sets the capabilities structure on the parser.\nfunc (p *Parser) WithCapabilities(c *Capabilities) *Parser {\n\tp.po.Capabilities = c\n\treturn p\n}\n\nfunc (p *Parser) parsedTermCacheLookup() (*Term, *state) {\n\tl := p.s.loc.Offset\n\t// stop comparing once the cached offsets are lower than l\n\tfor h := p.cache.m; h != nil && h.offset >= l; h = h.next {\n\t\tif h.offset == l {\n\t\t\treturn h.t, h.post\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc (p *Parser) parsedTermCachePush(t *Term, s0 *state) {\n\ts1 := p.save()\n\to0 := s0.loc.Offset\n\tentry := parsedTermCacheItem{t: t, post: s1, offset: o0}\n\n\t// find the first one whose offset is smaller than ours\n\tvar e *parsedTermCacheItem\n\tfor e = p.cache.m; e != nil; e = e.next {\n\t\tif e.offset < o0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tentry.next = e\n\tp.cache.m = &entry\n}\n\n// futureParser returns a shallow copy of `p` with an empty\n// cache, and a scanner that knows all future keywords.\n// It's used to present hints in errors, when statements would\n// only parse successfully if some future keyword is enabled.\nfunc (p *Parser) futureParser() *Parser {\n\tq := *p\n\tq.s = p.save()\n\tq.s.s = p.s.s.WithKeywords(futureKeywords)\n\tq.cache = parsedTermCache{}\n\treturn &q\n}\n\n// presentParser returns a shallow copy of `p` with an empty\n// cache, and a scanner that knows none of the future keywords.\n// It is used to successfully parse keyword imports, like\n//\n//  import future.keywords.in\n//\n// even when the parser has already been informed about the\n// future keyword \"in\". This parser won't error out because\n// \"in\" is an identifier.\nfunc (p *Parser) presentParser() (*Parser, map[string]tokens.Token) {\n\tvar cpy map[string]tokens.Token\n\tq := *p\n\tq.s = p.save()\n\tq.s.s, cpy = p.s.s.WithoutKeywords(futureKeywords)\n\tq.cache = parsedTermCache{}\n\treturn &q, cpy\n}\n\n// Parse will read the Rego source and parse statements and\n// comments as they are found. Any errors encountered while\n// parsing will be accumulated and returned as a list of Errors.\nfunc (p *Parser) Parse() ([]Statement, []*Comment, Errors) {\n\n\tif p.po.Capabilities == nil {\n\t\tp.po.Capabilities = CapabilitiesForThisVersion()\n\t}\n\n\tallowedFutureKeywords := map[string]tokens.Token{}\n\n\tfor _, kw := range p.po.Capabilities.FutureKeywords {\n\t\tvar ok bool\n\t\tallowedFutureKeywords[kw], ok = futureKeywords[kw]\n\t\tif !ok {\n\t\t\treturn nil, nil, Errors{\n\t\t\t\t&Error{\n\t\t\t\t\tCode:     ParseErr,\n\t\t\t\t\tMessage:  fmt.Sprintf(\"illegal capabilities: unknown keyword: %v\", kw),\n\t\t\t\t\tLocation: nil,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tvar err error\n\tp.s.s, err = scanner.New(p.r)\n\tif err != nil {\n\t\treturn nil, nil, Errors{\n\t\t\t&Error{\n\t\t\t\tCode:     ParseErr,\n\t\t\t\tMessage:  err.Error(),\n\t\t\t\tLocation: nil,\n\t\t\t},\n\t\t}\n\t}\n\n\tselected := map[string]tokens.Token{}\n\tif p.po.AllFutureKeywords {\n\t\tfor kw, tok := range allowedFutureKeywords {\n\t\t\tselected[kw] = tok\n\t\t}\n\t} else {\n\t\tfor _, kw := range p.po.FutureKeywords {\n\t\t\ttok, ok := allowedFutureKeywords[kw]\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, Errors{\n\t\t\t\t\t&Error{\n\t\t\t\t\t\tCode:     ParseErr,\n\t\t\t\t\t\tMessage:  fmt.Sprintf(\"unknown future keyword: %v\", kw),\n\t\t\t\t\t\tLocation: nil,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tselected[kw] = tok\n\t\t}\n\t}\n\tp.s.s = p.s.s.WithKeywords(selected)\n\n\t// read the first token to initialize the parser\n\tp.scan()\n\n\tvar stmts []Statement\n\n\t// Read from the scanner until the last token is reached or no statements\n\t// can be parsed. Attempt to parse package statements, import statements,\n\t// rule statements, and then body/query statements (in that order). If a\n\t// statement cannot be parsed, restore the parser state before trying the\n\t// next type of statement. If a statement can be parsed, continue from that\n\t// point trying to parse packages, imports, etc. in the same order.\n\tfor p.s.tok != tokens.EOF {\n\n\t\ts := p.save()\n\n\t\tif pkg := p.parsePackage(); pkg != nil {\n\t\t\tstmts = append(stmts, pkg)\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\t\ts = p.save()\n\n\t\tif imp := p.parseImport(); imp != nil {\n\t\t\tif FutureRootDocument.Equal(imp.Path.Value.(Ref)[0]) {\n\t\t\t\tp.futureImport(imp, allowedFutureKeywords)\n\t\t\t}\n\t\t\tstmts = append(stmts, imp)\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\t\ts = p.save()\n\n\t\tif rules := p.parseRules(); rules != nil {\n\t\t\tfor i := range rules {\n\t\t\t\tstmts = append(stmts, rules[i])\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if len(p.s.errors) > 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tp.restore(s)\n\n\t\tif body := p.parseQuery(true, tokens.EOF); body != nil {\n\t\t\tstmts = append(stmts, body)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\n\tif p.po.ProcessAnnotation {\n\t\tstmts = p.parseAnnotations(stmts)\n\t}\n\n\treturn stmts, p.s.comments, p.s.errors\n}\n\nfunc (p *Parser) parseAnnotations(stmts []Statement) []Statement {\n\n\tvar hint = []byte(\"METADATA\")\n\tvar curr *metadataParser\n\tvar blocks []*metadataParser\n\n\tfor i := 0; i < len(p.s.comments); i++ {\n\t\tif curr != nil {\n\t\t\tif p.s.comments[i].Location.Row == p.s.comments[i-1].Location.Row+1 && p.s.comments[i].Location.Col == 1 {\n\t\t\t\tcurr.Append(p.s.comments[i])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcurr = nil\n\t\t}\n\t\tif bytes.HasPrefix(bytes.TrimSpace(p.s.comments[i].Text), hint) {\n\t\t\tcurr = newMetadataParser(p.s.comments[i].Location)\n\t\t\tblocks = append(blocks, curr)\n\t\t}\n\t}\n\n\tfor _, b := range blocks {\n\t\ta, err := b.Parse()\n\t\tif err != nil {\n\t\t\tp.error(b.loc, err.Error())\n\t\t} else {\n\t\t\tstmts = append(stmts, a)\n\t\t}\n\t}\n\n\treturn stmts\n}\n\nfunc (p *Parser) parsePackage() *Package {\n\n\tvar pkg Package\n\tpkg.SetLoc(p.s.Loc())\n\n\tif p.s.tok != tokens.Package {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\tif p.s.tok != tokens.Ident {\n\t\tp.illegalToken()\n\t\treturn nil\n\t}\n\n\tterm := p.parseTerm()\n\n\tif term != nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\tpkg.Path = Ref{\n\t\t\t\tDefaultRootDocument.Copy().SetLocation(term.Location),\n\t\t\t\tStringTerm(string(v)).SetLocation(term.Location),\n\t\t\t}\n\t\tcase Ref:\n\t\t\tpkg.Path = make(Ref, len(v)+1)\n\t\t\tpkg.Path[0] = DefaultRootDocument.Copy().SetLocation(v[0].Location)\n\t\t\tfirst, ok := v[0].Value.(Var)\n\t\t\tif !ok {\n\t\t\t\tp.errorf(v[0].Location, \"unexpected %v token: expecting var\", TypeName(v[0].Value))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tpkg.Path[1] = StringTerm(string(first)).SetLocation(v[0].Location)\n\t\t\tfor i := 2; i < len(pkg.Path); i++ {\n\t\t\t\tswitch v[i-1].Value.(type) {\n\t\t\t\tcase String:\n\t\t\t\t\tpkg.Path[i] = v[i-1]\n\t\t\t\tdefault:\n\t\t\t\t\tp.errorf(v[i-1].Location, \"unexpected %v token: expecting string\", TypeName(v[i-1].Value))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tp.illegalToken()\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif pkg.Path == nil {\n\t\tif len(p.s.errors) == 0 {\n\t\t\tp.error(p.s.Loc(), \"expected path\")\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn &pkg\n}\n\nfunc (p *Parser) parseImport() *Import {\n\n\tvar imp Import\n\timp.SetLoc(p.s.Loc())\n\n\tif p.s.tok != tokens.Import {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\tif p.s.tok != tokens.Ident {\n\t\tp.error(p.s.Loc(), \"expected ident\")\n\t\treturn nil\n\t}\n\tq, prev := p.presentParser()\n\tterm := q.parseTerm()\n\tif term != nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\timp.Path = RefTerm(term).SetLocation(term.Location)\n\t\tcase Ref:\n\t\t\tfor i := 1; i < len(v); i++ {\n\t\t\t\tif _, ok := v[i].Value.(String); !ok {\n\t\t\t\t\tp.errorf(v[i].Location, \"unexpected %v token: expecting string\", TypeName(v[i].Value))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\timp.Path = term\n\t\t}\n\t}\n\t// keep advanced parser state, reset known keywords\n\tp.s = q.s\n\tp.s.s = q.s.s.WithKeywords(prev)\n\n\tif imp.Path == nil {\n\t\tp.error(p.s.Loc(), \"expected path\")\n\t\treturn nil\n\t}\n\n\tpath := imp.Path.Value.(Ref)\n\n\tif !RootDocumentNames.Contains(path[0]) && !FutureRootDocument.Equal(path[0]) {\n\t\tp.errorf(imp.Path.Location, \"unexpected import path, must begin with one of: %v, got: %v\",\n\t\t\tRootDocumentNames.Union(NewSet(FutureRootDocument)),\n\t\t\tpath[0])\n\t\treturn nil\n\t}\n\n\tif p.s.tok == tokens.As {\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected var\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif alias := p.parseTerm(); alias != nil {\n\t\t\tv, ok := alias.Value.(Var)\n\t\t\tif ok {\n\t\t\t\timp.Alias = v\n\t\t\t\treturn &imp\n\t\t\t}\n\t\t}\n\t\tp.illegal(\"expected var\")\n\t\treturn nil\n\t}\n\n\treturn &imp\n}\n\nfunc (p *Parser) parseRules() []*Rule {\n\n\tvar rule Rule\n\trule.SetLoc(p.s.Loc())\n\n\tif p.s.tok == tokens.Default {\n\t\tp.scan()\n\t\trule.Default = true\n\t}\n\n\tif p.s.tok != tokens.Ident {\n\t\treturn nil\n\t}\n\n\tif rule.Head = p.parseHead(rule.Default); rule.Head == nil {\n\t\treturn nil\n\t}\n\n\tif rule.Default {\n\t\tif !p.validateDefaultRuleValue(&rule) {\n\t\t\treturn nil\n\t\t}\n\n\t\trule.Body = NewBody(NewExpr(BooleanTerm(true).SetLocation(rule.Location)).SetLocation(rule.Location))\n\t\treturn []*Rule{&rule}\n\t}\n\n\tif p.s.tok == tokens.LBrace {\n\t\tp.scan()\n\t\tif rule.Body = p.parseBody(tokens.RBrace); rule.Body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\t} else {\n\t\treturn nil\n\t}\n\n\tif p.s.tok == tokens.Else {\n\n\t\tif rule.Head.Assign {\n\t\t\tp.error(p.s.Loc(), \"else keyword cannot be used on rule declared with := operator\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif rule.Head.Key != nil {\n\t\t\tp.error(p.s.Loc(), \"else keyword cannot be used on partial rules\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif rule.Else = p.parseElse(rule.Head); rule.Else == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\trule.Location.Text = p.s.Text(rule.Location.Offset, p.s.lastEnd)\n\n\tvar rules []*Rule\n\n\trules = append(rules, &rule)\n\n\tfor p.s.tok == tokens.LBrace {\n\n\t\tif rule.Else != nil {\n\t\t\tp.error(p.s.Loc(), \"expected else keyword\")\n\t\t\treturn nil\n\t\t}\n\n\t\tloc := p.s.Loc()\n\n\t\tp.scan()\n\t\tvar next Rule\n\n\t\tif next.Body = p.parseBody(tokens.RBrace); next.Body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\n\t\tloc.Text = p.s.Text(loc.Offset, p.s.lastEnd)\n\t\tnext.SetLoc(loc)\n\n\t\t// Chained rule head's keep the original\n\t\t// rule's head AST but have their location\n\t\t// set to the rule body.\n\t\tnext.Head = rule.Head.Copy()\n\t\tsetLocRecursive(next.Head, loc)\n\n\t\trules = append(rules, &next)\n\t}\n\n\treturn rules\n}\n\nfunc (p *Parser) parseElse(head *Head) *Rule {\n\n\tvar rule Rule\n\trule.SetLoc(p.s.Loc())\n\n\trule.Head = head.Copy()\n\trule.Head.SetLoc(p.s.Loc())\n\n\tdefer func() {\n\t\trule.Location.Text = p.s.Text(rule.Location.Offset, p.s.lastEnd)\n\t}()\n\n\tp.scan()\n\n\tswitch p.s.tok {\n\tcase tokens.LBrace:\n\t\trule.Head.Value = BooleanTerm(true)\n\tcase tokens.Unify:\n\t\tp.scan()\n\t\trule.Head.Value = p.parseTermInfixCall()\n\t\tif rule.Head.Value == nil {\n\t\t\treturn nil\n\t\t}\n\t\trule.Head.Location.Text = p.s.Text(rule.Head.Location.Offset, p.s.lastEnd)\n\tdefault:\n\t\tp.illegal(\"expected else value term or rule body\")\n\t\treturn nil\n\t}\n\n\tif p.s.tok != tokens.LBrace {\n\t\trule.Body = NewBody(NewExpr(BooleanTerm(true)))\n\t\tsetLocRecursive(rule.Body, rule.Location)\n\t\treturn &rule\n\t}\n\n\tp.scan()\n\n\tif rule.Body = p.parseBody(tokens.RBrace); rule.Body == nil {\n\t\treturn nil\n\t}\n\n\tp.scan()\n\n\tif p.s.tok == tokens.Else {\n\t\tif rule.Else = p.parseElse(head); rule.Else == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn &rule\n}\n\nfunc (p *Parser) parseHead(defaultRule bool) *Head {\n\n\tvar head Head\n\thead.SetLoc(p.s.Loc())\n\n\tdefer func() {\n\t\thead.Location.Text = p.s.Text(head.Location.Offset, p.s.lastEnd)\n\t}()\n\n\tif term := p.parseVar(); term != nil {\n\t\thead.Name = term.Value.(Var)\n\t} else {\n\t\tp.illegal(\"expected rule head name\")\n\t}\n\n\tp.scan()\n\n\tif p.s.tok == tokens.LParen {\n\t\tp.scan()\n\t\tif p.s.tok != tokens.RParen {\n\t\t\thead.Args = p.parseTermList(tokens.RParen, nil)\n\t\t\tif head.Args == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tp.scan()\n\n\t\tif p.s.tok == tokens.LBrack {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif p.s.tok == tokens.LBrack {\n\t\tp.scan()\n\t\thead.Key = p.parseTermInfixCall()\n\t\tif head.Key == nil {\n\t\t\tp.illegal(\"expected rule key term (e.g., %s[<VALUE>] { ... })\", head.Name)\n\t\t}\n\t\tif p.s.tok != tokens.RBrack {\n\t\t\tif _, ok := futureKeywords[head.Name.String()]; ok {\n\t\t\t\tp.hint(\"`import future.keywords.%[1]s` for '%[1]s' keyword\", head.Name.String())\n\t\t\t}\n\t\t\tp.illegal(\"non-terminated rule key\")\n\t\t}\n\t\tp.scan()\n\t}\n\n\tif p.s.tok == tokens.Unify {\n\t\tp.scan()\n\t\thead.Value = p.parseTermInfixCall()\n\t\tif head.Value == nil {\n\t\t\tp.illegal(\"expected rule value term (e.g., %s[%s] = <VALUE> { ... })\", head.Name, head.Key)\n\t\t}\n\t} else if p.s.tok == tokens.Assign {\n\n\t\tif defaultRule {\n\t\t\tp.error(p.s.Loc(), \"default rules must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t} else if head.Key != nil {\n\t\t\tp.error(p.s.Loc(), \"partial rules must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t} else if len(head.Args) > 0 {\n\t\t\tp.error(p.s.Loc(), \"functions must use = operator (not := operator)\")\n\t\t\treturn nil\n\t\t}\n\n\t\tp.scan()\n\t\thead.Assign = true\n\t\thead.Value = p.parseTermInfixCall()\n\t\tif head.Value == nil {\n\t\t\tp.illegal(\"expected rule value term (e.g., %s := <VALUE> { ... })\", head.Name)\n\t\t}\n\t}\n\n\tif head.Value == nil && head.Key == nil {\n\t\thead.Value = BooleanTerm(true).SetLocation(head.Location)\n\t}\n\n\treturn &head\n}\n\nfunc (p *Parser) parseBody(end tokens.Token) Body {\n\treturn p.parseQuery(false, end)\n}\n\nfunc (p *Parser) parseQuery(requireSemi bool, end tokens.Token) Body {\n\tbody := Body{}\n\n\tif p.s.tok == end {\n\t\tp.error(p.s.Loc(), \"found empty body\")\n\t\treturn nil\n\t}\n\n\tfor {\n\n\t\texpr := p.parseLiteral()\n\t\tif expr == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tbody.Append(expr)\n\n\t\tif p.s.tok == tokens.Semicolon {\n\t\t\tp.scan()\n\t\t\tcontinue\n\t\t}\n\n\t\tif p.s.tok == end || requireSemi {\n\t\t\treturn body\n\t\t}\n\n\t\tif !p.s.skippedNL {\n\t\t\t// If there was already an error then don't pile this one on\n\t\t\tif len(p.s.errors) == 0 {\n\t\t\t\tp.illegal(`expected \\n or %s or %s`, tokens.Semicolon, end)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (p *Parser) parseLiteral() (expr *Expr) {\n\n\toffset := p.s.loc.Offset\n\tloc := p.s.Loc()\n\n\tdefer func() {\n\t\tif expr != nil {\n\t\t\tloc.Text = p.s.Text(offset, p.s.lastEnd)\n\t\t\texpr.SetLoc(loc)\n\t\t}\n\t}()\n\n\tvar negated bool\n\tif p.s.tok == tokens.Not {\n\t\tp.scan()\n\t\tnegated = true\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.Some:\n\t\tif negated {\n\t\t\tp.illegal(\"illegal negation of 'some'\")\n\t\t\treturn nil\n\t\t}\n\t\treturn p.parseSome()\n\tcase tokens.Every:\n\t\tif negated {\n\t\t\tp.illegal(\"illegal negation of 'every'\")\n\t\t\treturn nil\n\t\t}\n\t\treturn p.parseEvery()\n\tdefault:\n\t\ts := p.save()\n\t\texpr := p.parseExpr()\n\t\tif expr != nil {\n\t\t\texpr.Negated = negated\n\t\t\tif p.s.tok == tokens.With {\n\t\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we find a plain `every` identifier, attempt to parse an every expression,\n\t\t\t// add hint if it succeeds.\n\t\t\tif term, ok := expr.Terms.(*Term); ok && Var(\"every\").Equal(term.Value) {\n\t\t\t\tvar hint bool\n\t\t\t\tt := p.save()\n\t\t\t\tp.restore(s)\n\t\t\t\tif expr := p.futureParser().parseEvery(); expr != nil {\n\t\t\t\t\t_, hint = expr.Terms.(*Every)\n\t\t\t\t}\n\t\t\t\tp.restore(t)\n\t\t\t\tif hint {\n\t\t\t\t\tp.hint(\"`import future.keywords.every` for `every x in xs { ... }` expressions\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseWith() []*With {\n\n\twiths := []*With{}\n\n\tfor {\n\n\t\twith := With{\n\t\t\tLocation: p.s.Loc(),\n\t\t}\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected ident\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif with.Target = p.parseTerm(); with.Target == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch with.Target.Value.(type) {\n\t\tcase Ref, Var:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.illegal(\"expected with target path\")\n\t\t}\n\n\t\tif p.s.tok != tokens.As {\n\t\t\tp.illegal(\"expected as keyword\")\n\t\t\treturn nil\n\t\t}\n\n\t\tp.scan()\n\n\t\tif with.Value = p.parseTermInfixCall(); with.Value == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\twith.Location.Text = p.s.Text(with.Location.Offset, p.s.lastEnd)\n\n\t\twiths = append(withs, &with)\n\n\t\tif p.s.tok != tokens.With {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn withs\n}\n\nfunc (p *Parser) parseSome() *Expr {\n\n\tdecl := &SomeDecl{}\n\tdecl.SetLoc(p.s.Loc())\n\n\t// Attempt to parse \"some x in xs\", which will end up in\n\t//   SomeDecl{Symbols: [\"member(x, xs)\"]}\n\ts := p.save()\n\tp.scan()\n\tif term := p.parseTermInfixCall(); term != nil {\n\t\tif call, ok := term.Value.(Call); ok {\n\t\t\tswitch call[0].String() {\n\t\t\tcase Member.Name:\n\t\t\t\tif len(call) != 3 {\n\t\t\t\t\tp.illegal(\"illegal domain\")\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\tcase MemberWithKey.Name:\n\t\t\t\tif len(call) != 4 {\n\t\t\t\t\tp.illegal(\"illegal domain\")\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tp.illegal(\"expected `x in xs` or `x, y in xs` expression\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tdecl.Symbols = []*Term{term}\n\t\t\texpr := NewExpr(decl).SetLocation(decl.Location)\n\t\t\tif p.s.tok == tokens.With {\n\t\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr\n\t\t}\n\t}\n\n\tp.restore(s)\n\ts = p.save() // new copy for later\n\tvar hint bool\n\tp.scan()\n\tif term := p.futureParser().parseTermInfixCall(); term != nil {\n\t\tif call, ok := term.Value.(Call); ok {\n\t\t\tswitch call[0].String() {\n\t\t\tcase Member.Name, MemberWithKey.Name:\n\t\t\t\thint = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// go on as before, it's `some x[...]` or illegal\n\tp.restore(s)\n\tif hint {\n\t\tp.hint(\"`import future.keywords.in` for `some x in xs` expressions\")\n\t}\n\n\tfor { // collecting var args\n\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Ident {\n\t\t\tp.illegal(\"expected var\")\n\t\t\treturn nil\n\t\t}\n\n\t\tdecl.Symbols = append(decl.Symbols, p.parseVar())\n\n\t\tp.scan()\n\n\t\tif p.s.tok != tokens.Comma {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn NewExpr(decl).SetLocation(decl.Location)\n}\n\nfunc (p *Parser) parseEvery() *Expr {\n\tqb := &Every{}\n\tqb.SetLoc(p.s.Loc())\n\n\t// TODO(sr): We'd get more accurate error messages if we didn't rely on\n\t// parseTermInfixCall here, but parsed \"var [, var] in term\" manually.\n\tp.scan()\n\tterm := p.parseTermInfixCall()\n\tif term == nil {\n\t\treturn nil\n\t}\n\tcall, ok := term.Value.(Call)\n\tif !ok {\n\t\tp.illegal(\"expected `x[, y] in xs { ... }` expression\")\n\t\treturn nil\n\t}\n\tswitch call[0].String() {\n\tcase Member.Name: // x in xs\n\t\tif len(call) != 3 {\n\t\t\tp.illegal(\"illegal domain\")\n\t\t\treturn nil\n\t\t}\n\t\tqb.Value = call[1]\n\t\tqb.Domain = call[2]\n\tcase MemberWithKey.Name: // k, v in xs\n\t\tif len(call) != 4 {\n\t\t\tp.illegal(\"illegal domain\")\n\t\t\treturn nil\n\t\t}\n\t\tqb.Key = call[1]\n\t\tqb.Value = call[2]\n\t\tqb.Domain = call[3]\n\t\tif _, ok := qb.Key.Value.(Var); !ok {\n\t\t\tp.illegal(\"expected key to be a variable\")\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\tp.illegal(\"expected `x[, y] in xs { ... }` expression\")\n\t\treturn nil\n\t}\n\tif _, ok := qb.Value.Value.(Var); !ok {\n\t\tp.illegal(\"expected value to be a variable\")\n\t\treturn nil\n\t}\n\tif p.s.tok == tokens.LBrace { // every x in xs { ... }\n\t\tp.scan()\n\t\tbody := p.parseBody(tokens.RBrace)\n\t\tif body == nil {\n\t\t\treturn nil\n\t\t}\n\t\tp.scan()\n\t\tqb.Body = body\n\t\texpr := NewExpr(qb).SetLocation(qb.Location)\n\n\t\tif p.s.tok == tokens.With {\n\t\t\tif expr.With = p.parseWith(); expr.With == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn expr\n\t}\n\n\tp.illegal(\"missing body\")\n\treturn nil\n}\n\nfunc (p *Parser) parseExpr() *Expr {\n\n\tlhs := p.parseTermInfixCall()\n\tif lhs == nil {\n\t\treturn nil\n\t}\n\n\tif op := p.parseTermOp(tokens.Assign, tokens.Unify); op != nil {\n\t\tif rhs := p.parseTermInfixCall(); rhs != nil {\n\t\t\treturn NewExpr([]*Term{op, lhs, rhs})\n\t\t}\n\t\treturn nil\n\t}\n\n\t// NOTE(tsandall): the top-level call term is converted to an expr because\n\t// the evaluator does not support the call term type (nested calls are\n\t// rewritten by the compiler.)\n\tif call, ok := lhs.Value.(Call); ok {\n\t\treturn NewExpr([]*Term(call))\n\t}\n\n\treturn NewExpr(lhs)\n}\n\n// parseTermInfixCall consumes the next term from the input and returns it. If a\n// term cannot be parsed the return value is nil and error will be recorded. The\n// scanner will be advanced to the next token before returning.\n// By starting out with infix relations (==, !=, <, etc) and further calling the\n// other binary operators (|, &, arithmetics), it constitutes the binding\n// precedence.\nfunc (p *Parser) parseTermInfixCall() *Term {\n\treturn p.parseTermIn(nil, true, p.s.loc.Offset)\n}\n\nfunc (p *Parser) parseTermInfixCallInList() *Term {\n\treturn p.parseTermIn(nil, false, p.s.loc.Offset)\n}\n\nfunc (p *Parser) parseTermIn(lhs *Term, keyVal bool, offset int) *Term {\n\t// NOTE(sr): `in` is a bit special: besides `lhs in rhs`, it also\n\t// supports `key, val in rhs`, so it can have an optional second lhs.\n\t// `keyVal` triggers if we attempt to parse a second lhs argument (`mhs`).\n\tif lhs == nil {\n\t\tlhs = p.parseTermRelation(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif keyVal && p.s.tok == tokens.Comma { // second \"lhs\", or \"middle hand side\"\n\t\t\ts := p.save()\n\t\t\tp.scan()\n\t\t\tif mhs := p.parseTermRelation(nil, offset); mhs != nil {\n\t\t\t\tif op := p.parseTermOpName(MemberWithKey.Ref(), tokens.In); op != nil {\n\t\t\t\t\tif rhs := p.parseTermRelation(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, mhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\t\t\tswitch p.s.tok {\n\t\t\t\t\t\tcase tokens.In:\n\t\t\t\t\t\t\treturn p.parseTermIn(call, keyVal, offset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn call\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.restore(s)\n\t\t\treturn nil\n\t\t}\n\t\tif op := p.parseTermOpName(Member.Ref(), tokens.In); op != nil {\n\t\t\tif rhs := p.parseTermRelation(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.In:\n\t\t\t\t\treturn p.parseTermIn(call, keyVal, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermRelation(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermOr(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Equal, tokens.Neq, tokens.Lt, tokens.Gt, tokens.Lte, tokens.Gte); op != nil {\n\t\t\tif rhs := p.parseTermOr(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Equal, tokens.Neq, tokens.Lt, tokens.Gt, tokens.Lte, tokens.Gte:\n\t\t\t\t\treturn p.parseTermRelation(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermOr(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermAnd(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Or); op != nil {\n\t\t\tif rhs := p.parseTermAnd(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Or:\n\t\t\t\t\treturn p.parseTermOr(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lhs\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermAnd(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermArith(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.And); op != nil {\n\t\t\tif rhs := p.parseTermArith(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.And:\n\t\t\t\t\treturn p.parseTermAnd(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lhs\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermArith(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTermFactor(nil, offset)\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Add, tokens.Sub); op != nil {\n\t\t\tif rhs := p.parseTermFactor(nil, p.s.loc.Offset); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Add, tokens.Sub:\n\t\t\t\t\treturn p.parseTermArith(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTermFactor(lhs *Term, offset int) *Term {\n\tif lhs == nil {\n\t\tlhs = p.parseTerm()\n\t}\n\tif lhs != nil {\n\t\tif op := p.parseTermOp(tokens.Mul, tokens.Quo, tokens.Rem); op != nil {\n\t\t\tif rhs := p.parseTerm(); rhs != nil {\n\t\t\t\tcall := p.setLoc(CallTerm(op, lhs, rhs), lhs.Location, offset, p.s.lastEnd)\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Mul, tokens.Quo, tokens.Rem:\n\t\t\t\t\treturn p.parseTermFactor(call, offset)\n\t\t\t\tdefault:\n\t\t\t\t\treturn call\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lhs\n}\n\nfunc (p *Parser) parseTerm() *Term {\n\tif term, s := p.parsedTermCacheLookup(); s != nil {\n\t\tp.restore(s)\n\t\treturn term\n\t}\n\ts0 := p.save()\n\n\tvar term *Term\n\tswitch p.s.tok {\n\tcase tokens.Null:\n\t\tterm = NullTerm().SetLocation(p.s.Loc())\n\tcase tokens.True:\n\t\tterm = BooleanTerm(true).SetLocation(p.s.Loc())\n\tcase tokens.False:\n\t\tterm = BooleanTerm(false).SetLocation(p.s.Loc())\n\tcase tokens.Sub, tokens.Dot, tokens.Number:\n\t\tterm = p.parseNumber()\n\tcase tokens.String:\n\t\tterm = p.parseString()\n\tcase tokens.Ident:\n\t\tterm = p.parseVar()\n\tcase tokens.LBrack:\n\t\tterm = p.parseArray()\n\tcase tokens.LBrace:\n\t\tterm = p.parseSetOrObject()\n\tcase tokens.LParen:\n\t\toffset := p.s.loc.Offset\n\t\tp.scan()\n\t\tif r := p.parseTermInfixCall(); r != nil {\n\t\t\tif p.s.tok == tokens.RParen {\n\t\t\t\tr.Location.Text = p.s.Text(offset, p.s.tokEnd)\n\t\t\t\tterm = r\n\t\t\t} else {\n\t\t\t\tp.error(p.s.Loc(), \"non-terminated expression\")\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tp.illegalToken()\n\t}\n\n\tterm = p.parseTermFinish(term)\n\tp.parsedTermCachePush(term, s0)\n\treturn term\n}\n\nfunc (p *Parser) parseTermFinish(head *Term) *Term {\n\tif head == nil {\n\t\treturn nil\n\t}\n\toffset := p.s.loc.Offset\n\tp.scanWS()\n\tswitch p.s.tok {\n\tcase tokens.LParen, tokens.Dot, tokens.LBrack:\n\t\treturn p.parseRef(head, offset)\n\tcase tokens.Whitespace:\n\t\tp.scan()\n\t\tfallthrough\n\tdefault:\n\t\tif _, ok := head.Value.(Var); ok && RootDocumentNames.Contains(head) {\n\t\t\treturn RefTerm(head).SetLocation(head.Location)\n\t\t}\n\t\treturn head\n\t}\n}\n\nfunc (p *Parser) parseNumber() *Term {\n\tvar prefix string\n\tloc := p.s.Loc()\n\tif p.s.tok == tokens.Sub {\n\t\tprefix = \"-\"\n\t\tp.scan()\n\t\tswitch p.s.tok {\n\t\tcase tokens.Number, tokens.Dot:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.illegal(\"expected number\")\n\t\t\treturn nil\n\t\t}\n\t}\n\tif p.s.tok == tokens.Dot {\n\t\tprefix += \".\"\n\t\tp.scan()\n\t\tif p.s.tok != tokens.Number {\n\t\t\tp.illegal(\"expected number\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Check for multiple leading 0's, parsed by math/big.Float.Parse as decimal 0:\n\t// https://golang.org/pkg/math/big/#Float.Parse\n\tif ((len(prefix) != 0 && prefix[0] == '-') || len(prefix) == 0) &&\n\t\tlen(p.s.lit) > 1 && p.s.lit[0] == '0' && p.s.lit[1] == '0' {\n\t\tp.illegal(\"expected number\")\n\t\treturn nil\n\t}\n\n\t// Ensure that the number is valid\n\ts := prefix + p.s.lit\n\tf, ok := new(big.Float).SetString(s)\n\tif !ok {\n\t\tp.illegal(\"invalid float\")\n\t\treturn nil\n\t}\n\n\t// Put limit on size of exponent to prevent non-linear cost of String()\n\t// function on big.Float from causing denial of service: https://github.com/golang/go/issues/11068\n\t//\n\t// n == sign * mantissa * 2^exp\n\t// 0.5 <= mantissa < 1.0\n\t//\n\t// The limit is arbitrary.\n\texp := f.MantExp(nil)\n\tif exp > 1e5 || exp < -1e5 || f.IsInf() { // +/- inf, exp is 0\n\t\tp.error(p.s.Loc(), \"number too big\")\n\t\treturn nil\n\t}\n\n\t// Note: Use the original string, do *not* round trip from\n\t// the big.Float as it can cause precision loss.\n\tr := NumberTerm(json.Number(s)).SetLocation(loc)\n\treturn r\n}\n\nfunc (p *Parser) parseString() *Term {\n\tif p.s.lit[0] == '\"' {\n\t\tvar s string\n\t\terr := json.Unmarshal([]byte(p.s.lit), &s)\n\t\tif err != nil {\n\t\t\tp.errorf(p.s.Loc(), \"illegal string literal: %s\", p.s.lit)\n\t\t\treturn nil\n\t\t}\n\t\tterm := StringTerm(s).SetLocation(p.s.Loc())\n\t\treturn term\n\t}\n\treturn p.parseRawString()\n}\n\nfunc (p *Parser) parseRawString() *Term {\n\tif len(p.s.lit) < 2 {\n\t\treturn nil\n\t}\n\tterm := StringTerm(p.s.lit[1 : len(p.s.lit)-1]).SetLocation(p.s.Loc())\n\treturn term\n}\n\n// this is the name to use for instantiating an empty set, e.g., `set()`.\nvar setConstructor = RefTerm(VarTerm(\"set\"))\n\nfunc (p *Parser) parseCall(operator *Term, offset int) (term *Term) {\n\n\tloc := operator.Location\n\tvar end int\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, end)\n\t}()\n\n\tp.scan() // steps over '('\n\n\tif p.s.tok == tokens.RParen { // no args, i.e. set() or any.func()\n\t\tend = p.s.tokEnd\n\t\tp.scanWS()\n\t\tif operator.Equal(setConstructor) {\n\t\t\treturn SetTerm()\n\t\t}\n\t\treturn CallTerm(operator)\n\t}\n\n\tif r := p.parseTermList(tokens.RParen, []*Term{operator}); r != nil {\n\t\tend = p.s.tokEnd\n\t\tp.scanWS()\n\t\treturn CallTerm(r...)\n\t}\n\n\treturn nil\n}\n\nfunc (p *Parser) parseRef(head *Term, offset int) (term *Term) {\n\n\tloc := head.Location\n\tvar end int\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, end)\n\t}()\n\n\tswitch h := head.Value.(type) {\n\tcase Var, *Array, Object, Set, *ArrayComprehension, *ObjectComprehension, *SetComprehension, Call:\n\t\t// ok\n\tdefault:\n\t\tp.errorf(loc, \"illegal ref (head cannot be %v)\", TypeName(h))\n\t}\n\n\tref := []*Term{head}\n\n\tfor {\n\t\tswitch p.s.tok {\n\t\tcase tokens.Dot:\n\t\t\tp.scanWS()\n\t\t\tif p.s.tok != tokens.Ident {\n\t\t\t\tp.illegal(\"expected %v\", tokens.Ident)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tref = append(ref, StringTerm(p.s.lit).SetLocation(p.s.Loc()))\n\t\t\tp.scanWS()\n\t\tcase tokens.LParen:\n\t\t\tterm = p.parseCall(p.setLoc(RefTerm(ref...), loc, offset, p.s.loc.Offset), offset)\n\t\t\tif term != nil {\n\t\t\t\tswitch p.s.tok {\n\t\t\t\tcase tokens.Whitespace:\n\t\t\t\t\tp.scan()\n\t\t\t\t\tend = p.s.lastEnd\n\t\t\t\t\treturn term\n\t\t\t\tcase tokens.Dot, tokens.LBrack:\n\t\t\t\t\tterm = p.parseRef(term, offset)\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = p.s.tokEnd\n\t\t\treturn term\n\t\tcase tokens.LBrack:\n\t\t\tp.scan()\n\t\t\tif term := p.parseTermInfixCall(); term != nil {\n\t\t\t\tif p.s.tok != tokens.RBrack {\n\t\t\t\t\tp.illegal(\"expected %v\", tokens.LBrack)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tref = append(ref, term)\n\t\t\t\tp.scanWS()\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase tokens.Whitespace:\n\t\t\tend = p.s.lastEnd\n\t\t\tp.scan()\n\t\t\treturn RefTerm(ref...)\n\t\tdefault:\n\t\t\tend = p.s.lastEnd\n\t\t\treturn RefTerm(ref...)\n\t\t}\n\t}\n}\n\nfunc (p *Parser) parseArray() (term *Term) {\n\n\tloc := p.s.Loc()\n\toffset := p.s.loc.Offset\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, p.s.tokEnd)\n\t}()\n\n\tp.scan()\n\n\tif p.s.tok == tokens.RBrack {\n\t\treturn ArrayTerm()\n\t}\n\n\tpotentialComprehension := true\n\n\t// Skip leading commas, eg [, x, y]\n\t// Supported for backwards compatibility. In the future\n\t// we should make this a parse error.\n\tif p.s.tok == tokens.Comma {\n\t\tpotentialComprehension = false\n\t\tp.scan()\n\t}\n\n\ts := p.save()\n\n\t// NOTE(tsandall): The parser cannot attempt a relational term here because\n\t// of ambiguity around comprehensions. For example, given:\n\t//\n\t//  {1 | 1}\n\t//\n\t// Does this represent a set comprehension or a set containing binary OR\n\t// call? We resolve the ambiguity by prioritizing comprehensions.\n\thead := p.parseTerm()\n\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.RBrack:\n\t\treturn ArrayTerm(head)\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif terms := p.parseTermList(tokens.RBrack, []*Term{head}); terms != nil {\n\t\t\treturn NewTerm(NewArray(terms...))\n\t\t}\n\t\treturn nil\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\t// Try to parse as if it is an array comprehension\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrack); body != nil {\n\t\t\t\treturn ArrayComprehensionTerm(head, body)\n\t\t\t}\n\t\t\tif p.s.tok != tokens.Comma {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// fall back to parsing as a normal array definition\n\t}\n\n\tp.restore(s)\n\n\tif terms := p.parseTermList(tokens.RBrack, nil); terms != nil {\n\t\treturn NewTerm(NewArray(terms...))\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseSetOrObject() (term *Term) {\n\tloc := p.s.Loc()\n\toffset := p.s.loc.Offset\n\n\tdefer func() {\n\t\tp.setLoc(term, loc, offset, p.s.tokEnd)\n\t}()\n\n\tp.scan()\n\n\tif p.s.tok == tokens.RBrace {\n\t\treturn ObjectTerm()\n\t}\n\n\tpotentialComprehension := true\n\n\t// Skip leading commas, eg {, x, y}\n\t// Supported for backwards compatibility. In the future\n\t// we should make this a parse error.\n\tif p.s.tok == tokens.Comma {\n\t\tpotentialComprehension = false\n\t\tp.scan()\n\t}\n\n\ts := p.save()\n\n\t// Try parsing just a single term first to give comprehensions higher\n\t// priority to \"or\" calls in ambiguous situations. Eg: { a | b }\n\t// will be a set comprehension.\n\t//\n\t// Note: We don't know yet if it is a set or object being defined.\n\thead := p.parseTerm()\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\treturn p.parseSet(s, head, potentialComprehension)\n\t\t}\n\tcase tokens.RBrace, tokens.Comma:\n\t\treturn p.parseSet(s, head, potentialComprehension)\n\tcase tokens.Colon:\n\t\treturn p.parseObject(head, potentialComprehension)\n\t}\n\n\tp.restore(s)\n\n\thead = p.parseTermInfixCallInList()\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\tswitch p.s.tok {\n\tcase tokens.RBrace, tokens.Comma:\n\t\treturn p.parseSet(s, head, false)\n\tcase tokens.Colon:\n\t\t// It still might be an object comprehension, eg { a+1: b | ... }\n\t\treturn p.parseObject(head, potentialComprehension)\n\t}\n\n\tp.illegal(\"non-terminated set\")\n\treturn nil\n}\n\nfunc (p *Parser) parseSet(s *state, head *Term, potentialComprehension bool) *Term {\n\tswitch p.s.tok {\n\tcase tokens.RBrace:\n\t\treturn SetTerm(head)\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif terms := p.parseTermList(tokens.RBrace, []*Term{head}); terms != nil {\n\t\t\treturn SetTerm(terms...)\n\t\t}\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\t// Try to parse as if it is a set comprehension\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrace); body != nil {\n\t\t\t\treturn SetComprehensionTerm(head, body)\n\t\t\t}\n\t\t\tif p.s.tok != tokens.Comma {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// Fall back to parsing as normal set definition\n\t\tp.restore(s)\n\t\tif terms := p.parseTermList(tokens.RBrace, nil); terms != nil {\n\t\t\treturn SetTerm(terms...)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseObject(k *Term, potentialComprehension bool) *Term {\n\t// NOTE(tsandall): Assumption: this function is called after parsing the key\n\t// of the head element and then receiving a colon token from the scanner.\n\t// Advance beyond the colon and attempt to parse an object.\n\tif p.s.tok != tokens.Colon {\n\t\tpanic(\"expected colon\")\n\t}\n\tp.scan()\n\n\ts := p.save()\n\n\t// NOTE(sr): We first try to parse the value as a term (`v`), and see\n\t// if we can parse `{ x: v | ...}` as a comprehension.\n\t// However, if we encounter either a Comma or an RBace, it cannot be\n\t// parsed as a comprehension -- so we save double work further down\n\t// where `parseObjectFinish(k, v, false)` would only exercise the\n\t// same code paths once more.\n\tv := p.parseTerm()\n\tif v == nil {\n\t\treturn nil\n\t}\n\n\tpotentialRelation := true\n\tif potentialComprehension {\n\t\tswitch p.s.tok {\n\t\tcase tokens.RBrace, tokens.Comma:\n\t\t\tpotentialRelation = false\n\t\t\tfallthrough\n\t\tcase tokens.Or:\n\t\t\tif term := p.parseObjectFinish(k, v, true); term != nil {\n\t\t\t\treturn term\n\t\t\t}\n\t\t}\n\t}\n\n\tp.restore(s)\n\n\tif potentialRelation {\n\t\tv := p.parseTermInfixCallInList()\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch p.s.tok {\n\t\tcase tokens.RBrace, tokens.Comma:\n\t\t\treturn p.parseObjectFinish(k, v, false)\n\t\t}\n\t}\n\n\tp.illegal(\"non-terminated object\")\n\treturn nil\n}\n\nfunc (p *Parser) parseObjectFinish(key, val *Term, potentialComprehension bool) *Term {\n\tswitch p.s.tok {\n\tcase tokens.RBrace:\n\t\treturn ObjectTerm([2]*Term{key, val})\n\tcase tokens.Or:\n\t\tif potentialComprehension {\n\t\t\tp.scan()\n\t\t\tif body := p.parseBody(tokens.RBrace); body != nil {\n\t\t\t\treturn ObjectComprehensionTerm(key, val, body)\n\t\t\t}\n\t\t} else {\n\t\t\tp.illegal(\"non-terminated object\")\n\t\t}\n\tcase tokens.Comma:\n\t\tp.scan()\n\t\tif r := p.parseTermPairList(tokens.RBrace, [][2]*Term{{key, val}}); r != nil {\n\t\t\treturn ObjectTerm(r...)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermList(end tokens.Token, r []*Term) []*Term {\n\tif p.s.tok == end {\n\t\treturn r\n\t}\n\tfor {\n\t\tterm := p.parseTermInfixCallInList()\n\t\tif term != nil {\n\t\t\tr = append(r, term)\n\t\t\tswitch p.s.tok {\n\t\t\tcase end:\n\t\t\t\treturn r\n\t\t\tcase tokens.Comma:\n\t\t\t\tp.scan()\n\t\t\t\tif p.s.tok == end {\n\t\t\t\t\treturn r\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q or %q\", tokens.Comma, end))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseTermPairList(end tokens.Token, r [][2]*Term) [][2]*Term {\n\tif p.s.tok == end {\n\t\treturn r\n\t}\n\tfor {\n\t\tkey := p.parseTermInfixCallInList()\n\t\tif key != nil {\n\t\t\tswitch p.s.tok {\n\t\t\tcase tokens.Colon:\n\t\t\t\tp.scan()\n\t\t\t\tif val := p.parseTermInfixCallInList(); val != nil {\n\t\t\t\t\tr = append(r, [2]*Term{key, val})\n\t\t\t\t\tswitch p.s.tok {\n\t\t\t\t\tcase end:\n\t\t\t\t\t\treturn r\n\t\t\t\t\tcase tokens.Comma:\n\t\t\t\t\t\tp.scan()\n\t\t\t\t\t\tif p.s.tok == end {\n\t\t\t\t\t\t\treturn r\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q or %q\", tokens.Comma, end))\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tp.illegal(fmt.Sprintf(\"expected %q\", tokens.Colon))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (p *Parser) parseTermOp(values ...tokens.Token) *Term {\n\tfor i := range values {\n\t\tif p.s.tok == values[i] {\n\t\t\tr := RefTerm(VarTerm(fmt.Sprint(p.s.tok)).SetLocation(p.s.Loc())).SetLocation(p.s.Loc())\n\t\t\tp.scan()\n\t\t\treturn r\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseTermOpName(ref Ref, values ...tokens.Token) *Term {\n\tfor i := range values {\n\t\tif p.s.tok == values[i] {\n\t\t\tfor _, r := range ref {\n\t\t\t\tr.SetLocation(p.s.Loc())\n\t\t\t}\n\t\t\tt := RefTerm(ref...)\n\t\t\tt.SetLocation(p.s.Loc())\n\t\t\tp.scan()\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Parser) parseVar() *Term {\n\n\ts := p.s.lit\n\n\tterm := VarTerm(s).SetLocation(p.s.Loc())\n\n\t// Update wildcard values with unique identifiers\n\tif term.Equal(Wildcard) {\n\t\tterm.Value = Var(p.genwildcard())\n\t}\n\n\treturn term\n}\n\nfunc (p *Parser) genwildcard() string {\n\tc := p.s.wildcard\n\tp.s.wildcard++\n\treturn fmt.Sprintf(\"%v%d\", WildcardPrefix, c)\n}\n\nfunc (p *Parser) error(loc *location.Location, reason string) {\n\tp.errorf(loc, reason)\n}\n\nfunc (p *Parser) errorf(loc *location.Location, f string, a ...interface{}) {\n\tmsg := strings.Builder{}\n\tfmt.Fprintf(&msg, f, a...)\n\n\tswitch len(p.s.hints) {\n\tcase 0: // nothing to do\n\tcase 1:\n\t\tmsg.WriteString(\" (hint: \")\n\t\tmsg.WriteString(p.s.hints[0])\n\t\tmsg.WriteRune(')')\n\tdefault:\n\t\tmsg.WriteString(\" (hints: \")\n\t\tfor i, h := range p.s.hints {\n\t\t\tif i > 0 {\n\t\t\t\tmsg.WriteString(\", \")\n\t\t\t}\n\t\t\tmsg.WriteString(h)\n\t\t}\n\t\tmsg.WriteRune(')')\n\t}\n\n\tp.s.errors = append(p.s.errors, &Error{\n\t\tCode:     ParseErr,\n\t\tMessage:  msg.String(),\n\t\tLocation: loc,\n\t\tDetails:  newParserErrorDetail(p.s.s.Bytes(), loc.Offset),\n\t})\n\tp.s.hints = nil\n}\n\nfunc (p *Parser) hint(f string, a ...interface{}) {\n\tp.s.hints = append(p.s.hints, fmt.Sprintf(f, a...))\n}\n\nfunc (p *Parser) illegal(note string, a ...interface{}) {\n\ttok := p.s.tok.String()\n\n\tif p.s.tok == tokens.Illegal {\n\t\tp.errorf(p.s.Loc(), \"illegal token\")\n\t\treturn\n\t}\n\n\ttokType := \"token\"\n\tif tokens.IsKeyword(p.s.tok) {\n\t\ttokType = \"keyword\"\n\t}\n\tif _, ok := futureKeywords[p.s.tok.String()]; ok {\n\t\ttokType = \"keyword\"\n\t}\n\n\tnote = fmt.Sprintf(note, a...)\n\tif len(note) > 0 {\n\t\tp.errorf(p.s.Loc(), \"unexpected %s %s: %s\", tok, tokType, note)\n\t} else {\n\t\tp.errorf(p.s.Loc(), \"unexpected %s %s\", tok, tokType)\n\t}\n}\n\nfunc (p *Parser) illegalToken() {\n\tp.illegal(\"\")\n}\n\nfunc (p *Parser) scan() {\n\tp.doScan(true)\n}\n\nfunc (p *Parser) scanWS() {\n\tp.doScan(false)\n}\n\nfunc (p *Parser) doScan(skipws bool) {\n\n\t// NOTE(tsandall): the last position is used to compute the \"text\" field for\n\t// complex AST nodes. Whitespace never affects the last position of an AST\n\t// node so do not update it when scanning.\n\tif p.s.tok != tokens.Whitespace {\n\t\tp.s.lastEnd = p.s.tokEnd\n\t\tp.s.skippedNL = false\n\t}\n\n\tvar errs []scanner.Error\n\tfor {\n\t\tvar pos scanner.Position\n\t\tp.s.tok, pos, p.s.lit, errs = p.s.s.Scan()\n\n\t\tp.s.tokEnd = pos.End\n\t\tp.s.loc.Row = pos.Row\n\t\tp.s.loc.Col = pos.Col\n\t\tp.s.loc.Offset = pos.Offset\n\t\tp.s.loc.Text = p.s.Text(pos.Offset, pos.End)\n\n\t\tfor _, err := range errs {\n\t\t\tp.error(p.s.Loc(), err.Message)\n\t\t}\n\n\t\tif len(errs) > 0 {\n\t\t\tp.s.tok = tokens.Illegal\n\t\t}\n\n\t\tif p.s.tok == tokens.Whitespace {\n\t\t\tif p.s.lit == \"\\n\" {\n\t\t\t\tp.s.skippedNL = true\n\t\t\t}\n\t\t\tif skipws {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif p.s.tok != tokens.Comment {\n\t\t\tbreak\n\t\t}\n\n\t\t// For backwards compatibility leave a nil\n\t\t// Text value if there is no text rather than\n\t\t// an empty string.\n\t\tvar commentText []byte\n\t\tif len(p.s.lit) > 1 {\n\t\t\tcommentText = []byte(p.s.lit[1:])\n\t\t}\n\t\tcomment := NewComment(commentText)\n\t\tcomment.SetLoc(p.s.Loc())\n\t\tp.s.comments = append(p.s.comments, comment)\n\t}\n}\n\nfunc (p *Parser) save() *state {\n\tcpy := *p.s\n\ts := *cpy.s\n\tcpy.s = &s\n\treturn &cpy\n}\n\nfunc (p *Parser) restore(s *state) {\n\tp.s = s\n}\n\nfunc setLocRecursive(x interface{}, loc *location.Location) {\n\tNewGenericVisitor(func(x interface{}) bool {\n\t\tif node, ok := x.(Node); ok {\n\t\t\tnode.SetLoc(loc)\n\t\t}\n\t\treturn false\n\t}).Walk(x)\n}\n\nfunc (p *Parser) setLoc(term *Term, loc *location.Location, offset, end int) *Term {\n\tif term != nil {\n\t\tcpy := *loc\n\t\tterm.Location = &cpy\n\t\tterm.Location.Text = p.s.Text(offset, end)\n\t}\n\treturn term\n}\n\nfunc (p *Parser) validateDefaultRuleValue(rule *Rule) bool {\n\tif rule.Head.Value == nil {\n\t\tp.error(rule.Loc(), \"illegal default rule (must have a value)\")\n\t\treturn false\n\t}\n\n\tvalid := true\n\tvis := NewGenericVisitor(func(x interface{}) bool {\n\t\tswitch x.(type) {\n\t\tcase *ArrayComprehension, *ObjectComprehension, *SetComprehension: // skip closures\n\t\t\treturn true\n\t\tcase Ref, Var, Call:\n\t\t\tp.error(rule.Loc(), fmt.Sprintf(\"illegal default rule (value cannot contain %v)\", TypeName(x)))\n\t\t\tvalid = false\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\tvis.Walk(rule.Head.Value.Value)\n\treturn valid\n}\n\n// We explicitly use yaml unmarshalling, to accommodate for the '_' in 'related_resources',\n// which isn't handled properly by json for some reason.\ntype rawAnnotation struct {\n\tScope            string                 `yaml:\"scope\"`\n\tTitle            string                 `yaml:\"title\"`\n\tDescription      string                 `yaml:\"description\"`\n\tOrganizations    []string               `yaml:\"organizations\"`\n\tRelatedResources []interface{}          `yaml:\"related_resources\"`\n\tAuthors          []interface{}          `yaml:\"authors\"`\n\tSchemas          []rawSchemaAnnotation  `yaml:\"schemas\"`\n\tCustom           map[string]interface{} `yaml:\"custom\"`\n}\n\ntype rawSchemaAnnotation map[string]interface{}\n\ntype metadataParser struct {\n\tbuf      *bytes.Buffer\n\tcomments []*Comment\n\tloc      *location.Location\n}\n\nfunc newMetadataParser(loc *Location) *metadataParser {\n\treturn &metadataParser{loc: loc, buf: bytes.NewBuffer(nil)}\n}\n\nfunc (b *metadataParser) Append(c *Comment) {\n\tb.buf.Write(bytes.TrimPrefix(c.Text, []byte(\" \")))\n\tb.buf.WriteByte('\\n')\n\tb.comments = append(b.comments, c)\n}\n\nvar yamlLineErrRegex = regexp.MustCompile(`^yaml: line ([[:digit:]]+):`)\n\nfunc (b *metadataParser) Parse() (*Annotations, error) {\n\n\tvar raw rawAnnotation\n\n\tif len(bytes.TrimSpace(b.buf.Bytes())) == 0 {\n\t\treturn nil, fmt.Errorf(\"expected METADATA block, found whitespace\")\n\t}\n\n\tif err := yaml.Unmarshal(b.buf.Bytes(), &raw); err != nil {\n\t\tmatch := yamlLineErrRegex.FindStringSubmatch(err.Error())\n\t\tif len(match) == 2 {\n\t\t\tn, err2 := strconv.Atoi(match[1])\n\t\t\tif err2 == nil {\n\t\t\t\tindex := n - 1 // line numbering is 1-based so subtract one from row\n\t\t\t\tif index >= len(b.comments) {\n\t\t\t\t\tb.loc = b.comments[len(b.comments)-1].Location\n\t\t\t\t} else {\n\t\t\t\t\tb.loc = b.comments[index].Location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tvar result Annotations\n\tresult.Scope = raw.Scope\n\tresult.Title = raw.Title\n\tresult.Description = raw.Description\n\tresult.Organizations = raw.Organizations\n\n\tfor _, v := range raw.RelatedResources {\n\t\trr, err := parseRelatedResource(v)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid related-resource definition %s: %w\", v, err)\n\t\t}\n\t\tresult.RelatedResources = append(result.RelatedResources, rr)\n\t}\n\n\tfor _, pair := range raw.Schemas {\n\t\tk, v := unwrapPair(pair)\n\n\t\tvar a SchemaAnnotation\n\t\tvar err error\n\n\t\ta.Path, err = ParseRef(k)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid document reference\")\n\t\t}\n\n\t\tswitch v := v.(type) {\n\t\tcase string:\n\t\t\ta.Schema, err = parseSchemaRef(v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase map[interface{}]interface{}:\n\t\t\tw, err := convertYAMLMapKeyTypes(v, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, \"invalid schema definition\")\n\t\t\t}\n\t\t\ta.Definition = &w\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"invalid schema declaration for path %q\", k)\n\t\t}\n\n\t\tresult.Schemas = append(result.Schemas, &a)\n\t}\n\n\tfor _, v := range raw.Authors {\n\t\tauthor, err := parseAuthor(v)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid author definition %s: %w\", v, err)\n\t\t}\n\t\tresult.Authors = append(result.Authors, author)\n\t}\n\n\tresult.Custom = make(map[string]interface{})\n\tfor k, v := range raw.Custom {\n\t\tval, err := convertYAMLMapKeyTypes(v, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult.Custom[k] = val\n\t}\n\n\tresult.Location = b.loc\n\treturn &result, nil\n}\n\nfunc unwrapPair(pair map[string]interface{}) (k string, v interface{}) {\n\tfor k, v = range pair {\n\t}\n\treturn\n}\n\nvar errInvalidSchemaRef = fmt.Errorf(\"invalid schema reference\")\n\n// NOTE(tsandall): 'schema' is not registered as a root because it's not\n// supported by the compiler or evaluator today. Once we fix that, we can remove\n// this function.\nfunc parseSchemaRef(s string) (Ref, error) {\n\n\tterm, err := ParseTerm(s)\n\tif err == nil {\n\t\tswitch v := term.Value.(type) {\n\t\tcase Var:\n\t\t\tif term.Equal(SchemaRootDocument) {\n\t\t\t\treturn SchemaRootRef.Copy(), nil\n\t\t\t}\n\t\tcase Ref:\n\t\t\tif v.HasPrefix(SchemaRootRef) {\n\t\t\t\treturn v, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errInvalidSchemaRef\n}\n\nfunc parseRelatedResource(rr interface{}) (*RelatedResourceAnnotation, error) {\n\trr, err := convertYAMLMapKeyTypes(rr, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch rr := rr.(type) {\n\tcase string:\n\t\tif len(rr) > 0 {\n\t\t\tu, err := url.Parse(rr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &RelatedResourceAnnotation{Ref: *u}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"ref URL may not be empty string\")\n\tcase map[string]interface{}:\n\t\tdescription := strings.TrimSpace(getSafeString(rr, \"description\"))\n\t\tref := strings.TrimSpace(getSafeString(rr, \"ref\"))\n\t\tif len(ref) > 0 {\n\t\t\tu, err := url.Parse(ref)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &RelatedResourceAnnotation{Description: description, Ref: *u}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"'ref' value required in object\")\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid value type, must be string or map\")\n}\n\nfunc parseAuthor(a interface{}) (*AuthorAnnotation, error) {\n\ta, err := convertYAMLMapKeyTypes(a, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch a := a.(type) {\n\tcase string:\n\t\treturn parseAuthorString(a)\n\tcase map[string]interface{}:\n\t\tname := strings.TrimSpace(getSafeString(a, \"name\"))\n\t\temail := strings.TrimSpace(getSafeString(a, \"email\"))\n\t\tif len(name) > 0 || len(email) > 0 {\n\t\t\treturn &AuthorAnnotation{name, email}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"'name' and/or 'email' values required in object\")\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid value type, must be string or map\")\n}\n\nfunc getSafeString(m map[string]interface{}, k string) string {\n\tif v, found := m[k]; found {\n\t\tif s, ok := v.(string); ok {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn \"\"\n}\n\nconst emailPrefix = \"<\"\nconst emailSuffix = \">\"\n\n// parseAuthor parses a string into an AuthorAnnotation. If the last word of the input string is enclosed within <>,\n// it is extracted as the author's email. The email may not contain whitelines, as it then will be interpreted as\n// multiple words.\nfunc parseAuthorString(s string) (*AuthorAnnotation, error) {\n\tparts := strings.Fields(s)\n\n\tif len(parts) == 0 {\n\t\treturn nil, fmt.Errorf(\"author is an empty string\")\n\t}\n\n\tnamePartCount := len(parts)\n\ttrailing := parts[namePartCount-1]\n\tvar email string\n\tif len(trailing) >= len(emailPrefix)+len(emailSuffix) && strings.HasPrefix(trailing, emailPrefix) &&\n\t\tstrings.HasSuffix(trailing, emailSuffix) {\n\t\temail = trailing[len(emailPrefix):]\n\t\temail = email[0 : len(email)-len(emailSuffix)]\n\t\tnamePartCount = namePartCount - 1\n\t}\n\n\tname := strings.Join(parts[0:namePartCount], \" \")\n\n\treturn &AuthorAnnotation{Name: name, Email: email}, nil\n}\n\nfunc convertYAMLMapKeyTypes(x interface{}, path []string) (interface{}, error) {\n\tvar err error\n\tswitch x := x.(type) {\n\tcase map[interface{}]interface{}:\n\t\tresult := make(map[string]interface{}, len(x))\n\t\tfor k, v := range x {\n\t\t\tstr, ok := k.(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid map key type(s): %v\", strings.Join(path, \"/\"))\n\t\t\t}\n\t\t\tresult[str], err = convertYAMLMapKeyTypes(v, append(path, str))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn result, nil\n\tcase []interface{}:\n\t\tfor i := range x {\n\t\t\tx[i], err = convertYAMLMapKeyTypes(x[i], append(path, fmt.Sprintf(\"%d\", i)))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn x, nil\n\tdefault:\n\t\treturn x, nil\n\t}\n}\n\n// futureKeywords is the source of truth for future keywords that will\n// eventually become standard keywords inside of Rego.\nvar futureKeywords = map[string]tokens.Token{\n\t\"in\":    tokens.In,\n\t\"every\": tokens.Every,\n}\n\nfunc (p *Parser) futureImport(imp *Import, allowedFutureKeywords map[string]tokens.Token) {\n\tpath := imp.Path.Value.(Ref)\n\n\tif len(path) == 1 || !path[1].Equal(StringTerm(\"keywords\")) {\n\t\tp.errorf(imp.Path.Location, \"invalid import, must be `future.keywords`\")\n\t\treturn\n\t}\n\n\tif imp.Alias != \"\" {\n\t\tp.errorf(imp.Path.Location, \"future keyword imports cannot be aliased\")\n\t\treturn\n\t}\n\n\tkwds := make([]string, 0, len(allowedFutureKeywords))\n\tfor k := range allowedFutureKeywords {\n\t\tkwds = append(kwds, k)\n\t}\n\n\tswitch len(path) {\n\tcase 2: // all keywords imported, nothing to do\n\tcase 3: // one keyword imported\n\t\tkw, ok := path[2].Value.(String)\n\t\tif !ok {\n\t\t\tp.errorf(imp.Path.Location, \"invalid import, must be `future.keywords.x`, e.g. `import future.keywords.in`\")\n\t\t\treturn\n\t\t}\n\t\tkeyword := string(kw)\n\t\t_, ok = allowedFutureKeywords[keyword]\n\t\tif !ok {\n\t\t\tsort.Strings(kwds) // so the error message is stable\n\t\t\tp.errorf(imp.Path.Location, \"unexpected keyword, must be one of %v\", kwds)\n\t\t\treturn\n\t\t}\n\n\t\tkwds = []string{keyword} // overwrite\n\t}\n\tfor _, kw := range kwds {\n\t\tp.s.s.AddKeyword(kw, allowedFutureKeywords[kw])\n\t}\n}\n", "// Copyright 2016 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\n\npackage ast\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/open-policy-agent/opa/ast/internal/tokens\"\n)\n\nconst (\n\ttestModule = `\n# This policy module belongs the opa.example package.\npackage opa.examples\n\n# Refer to data.servers as servers.\nimport data.servers\n# Refer to the data.networks as networks.\nimport data.networks\n# Refer to the data.ports as ports.\nimport data.ports\n\n# A server exists in the violations set if...\nviolations[server] {\n    # ...the server exists\n    server = servers[i]\n    # ...and any of the server\u2019s protocols is HTTP\n    server.protocols[j] = \"http\"\n    # ...and the server is public.\n    public_servers[server]\n}\n\n# A server exists in the public_servers set if...\npublic_servers[server] {\n\t# Semicolons are optional. Can group expressions onto one line.\n    server = servers[i]; server.ports[j] = ports[k].id \t# ...and the server is connected to a port\n    ports[k].networks[l] = networks[m].id; \t\t\t\t# ...and the port is connected to a network\n    networks[m].public = true\t\t\t\t\t\t\t# ...and the network is public.\n}`\n)\n\nfunc TestNumberTerms(t *testing.T) {\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"0\", \"0\"},\n\t\t{\"100\", \"100\"},\n\t\t{\"-1\", \"-1\"},\n\t\t{\"1e6\", \"1e6\"},\n\t\t{\"1.1e6\", \"1.1e6\"},\n\t\t{\"-1e-6\", \"-1e-6\"},\n\t\t{\"1E6\", \"1E6\"},\n\t\t{\"0.1\", \"0.1\"},\n\t\t{\".1\", \"0.1\"},\n\t\t{\".0001\", \"0.0001\"},\n\t\t{\"-.1\", \"-0.1\"},\n\t\t{\"-0.0001\", \"-0.0001\"},\n\t\t{\"1e1000\", \"1e1000\"},\n\t\t{\"0e1\", \"0\"},\n\t\t{\"-0.1\", \"-0.1\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult, err := ParseTerm(tc.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", tc.input, err)\n\t\t} else {\n\t\t\te := NumberTerm(json.Number(tc.expected))\n\t\t\tif !result.Equal(e) {\n\t\t\t\tt.Errorf(\"Expected %v for %v but got: %v\", e, tc.input, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStringTerms(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"\"`, \"\"},                   // empty\n\t\t{`\" \"`, \" \"},                 // whitespace\n\t\t{`\"\\\"\"`, `\"`},                // escaped quote\n\t\t{`\"http:\\/\\/\"`, `http://`},   // escaped solidus\n\t\t{`\"\\u0001\"`, \"\\x01\"},         // control code\n\t\t{`\"foo\\u005C\"`, \"foo\\u005c\"}, // unicode (upper hex)\n\t\t{`\"foo\\u005c\"`, \"foo\\u005C\"}, // unicode (lower hex)\n\t\t{`\"\\uD834\\uDD1E\"`, `\ud834\udd1e`},      // g-clef\n\t\t{\"`hi\\\\there`\", `hi\\there`},  // basic raw string\n\t\t{\"`foo\\nbar\\n    baz`\", `foo\nbar\n    baz`}, // multi-line raw string\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult, err := ParseTerm(tc.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", tc.input, err)\n\t\t} else {\n\t\t\ts := StringTerm(tc.expected)\n\t\t\tif !result.Equal(s) {\n\t\t\t\tt.Errorf(\"Expected %v for %v but got: %v\", s, tc.input, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestScalarTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"null\", \"null\", NullTerm())\n\tassertParseOneTerm(t, \"true\", \"true\", BooleanTerm(true))\n\tassertParseOneTerm(t, \"false\", \"false\", BooleanTerm(false))\n\tassertParseOneTerm(t, \"integer\", \"53\", IntNumberTerm(53))\n\tassertParseOneTerm(t, \"integer2\", \"-53\", IntNumberTerm(-53))\n\tassertParseOneTerm(t, \"float\", \"16.7\", FloatNumberTerm(16.7))\n\tassertParseOneTerm(t, \"float2\", \"-16.7\", FloatNumberTerm(-16.7))\n\tassertParseOneTerm(t, \"exponent\", \"6e7\", FloatNumberTerm(6e7))\n\tassertParseOneTerm(t, \"string\", \"\\\"a string\\\"\", StringTerm(\"a string\"))\n\tassertParseOneTerm(t, \"string\", \"\\\"a string u6abc7def8abc0def with unicode\\\"\", StringTerm(\"a string u6abc7def8abc0def with unicode\"))\n\tassertParseErrorContains(t, \"hex\", \"6abc\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-terminated\", \"\\\"foo\", \"non-terminated string\")\n\tassertParseErrorContains(t, \"non-terminated-raw\", \"`foo\", \"non-terminated string\")\n\tassertParseErrorContains(t, \"non-string\", \"'a string'\", \"illegal token\")\n\tassertParseErrorContains(t, \"non-number\", \"6zxy\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number2\", \"6d7\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number3\", \"6\\\"foo\\\"\", \"expected exactly one statement\") // ??\n\tassertParseErrorContains(t, \"non-number4\", \"6true\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number5\", \"6false\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number6\", \"6[null, null]\", \"illegal ref (head cannot be number)\") // ??\n\tassertParseErrorContains(t, \"non-number7\", \"6{\\\"foo\\\": \\\"bar\\\"}\", \"expected exactly one statement\")\n\tassertParseErrorContains(t, \"non-number8\", \".0.\", \"expected fraction\")\n\tassertParseErrorContains(t, \"non-number9\", \"0e\", \"expected exponent\")\n\tassertParseErrorContains(t, \"non-number10\", \"0e.\", \"expected exponent\")\n\tassertParseErrorContains(t, \"non-number11\", \"0F\", \"illegal number format\")\n\tassertParseErrorContains(t, \"non-number12\", \"00\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number13\", \"00.1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number14\", \"-00\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number15\", \"-00.1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number16\", \"-00.01\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number17\", \"00e1\", \"expected number\")\n\tassertParseErrorContains(t, \"non-number18\", \"-00e1\", \"expected number\")\n\tassertParseErrorContains(t, \"parsing float fails\", \"7e3000000000\", \"invalid float\")\n\tassertParseErrorContains(t, \"float is +inf\", \"10245423601e680507880\", \"number too big\")\n\tassertParseErrorContains(t, \"float is -inf\", \"-10245423601e680507880\", \"number too big\")\n\n\t// f := big.NewFloat(1); f.SetMantExp(f, -1e6); f.String() // => 1.010034059e-301030 (this takes ~9s)\n\tassertParseErrorContains(t, \"float exp < -1e5\", \"1.010034059e-301030\", \"number too big\")\n\n\t// g := big.NewFloat(1); g.SetMantExp(g, 1e6); g.String() // => 9.900656229e+301029\n\tassertParseErrorContains(t, \"float exp > 1e5\", \"9.900656229e+301029\", \"number too big\")\n}\n\nfunc TestVarTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"var\", \"foo\", VarTerm(\"foo\"))\n\tassertParseOneTerm(t, \"var\", \"foo_bar\", VarTerm(\"foo_bar\"))\n\tassertParseOneTerm(t, \"var\", \"foo0\", VarTerm(\"foo0\"))\n\tassertParseOneTerm(t, \"import prefix\", \"imports\", VarTerm(\"imports\"))\n\tassertParseOneTerm(t, \"not prefix\", \"not_foo\", VarTerm(\"not_foo\"))\n\tassertParseOneTerm(t, `package prefix`, \"packages\", VarTerm(\"packages\"))\n\tassertParseOneTerm(t, `true prefix`, \"trueish\", VarTerm(\"trueish\"))\n\tassertParseOneTerm(t, `false prefix`, \"false_flag\", VarTerm(\"false_flag\"))\n\tassertParseOneTerm(t, `null prefix`, \"nullable\", VarTerm(\"nullable\"))\n\tassertParseError(t, \"illegal token\", `\ufa7d`)\n\tassertParseError(t, \"not keyword\", \"not\")\n\tassertParseError(t, `package keyword`, \"package\")\n\tassertParseError(t, \"import keyword\", \"import\")\n\tassertParseError(t, \"import invalid path\", \"import x.\")\n}\n\nfunc TestRefTerms(t *testing.T) {\n\tassertParseOneTerm(t, \"constants\", \"foo.bar.baz\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"baz\")))\n\tassertParseOneTerm(t, \"constants 2\", \"foo.bar[0].baz\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), IntNumberTerm(0), StringTerm(\"baz\")))\n\tassertParseOneTerm(t, \"variables\", \"foo.bar[0].baz[i]\", RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\"), IntNumberTerm(0), StringTerm(\"baz\"), VarTerm(\"i\")))\n\tassertParseOneTerm(t, \"spaces\", \"foo[\\\"white space\\\"].bar\", RefTerm(VarTerm(\"foo\"), StringTerm(\"white space\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"nested\", \"foo[baz[1][borge[i]]].bar\", RefTerm(\n\t\tVarTerm(\"foo\"),\n\t\tRefTerm(\n\t\t\tVarTerm(\"baz\"), IntNumberTerm(1), RefTerm(\n\t\t\t\tVarTerm(\"borge\"), VarTerm(\"i\"),\n\t\t\t),\n\t\t),\n\t\tStringTerm(\"bar\"),\n\t))\n\tassertParseOneTerm(t, \"composite operand 1\", \"foo[[1,2,3]].bar\", RefTerm(VarTerm(\"foo\"), ArrayTerm(NumberTerm(\"1\"), NumberTerm(\"2\"), NumberTerm(\"3\")), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"composite operand 2\", `foo[{\"foo\": 2}].bar`, RefTerm(VarTerm(\"foo\"), ObjectTerm(Item(StringTerm(\"foo\"), NumberTerm(\"2\"))), StringTerm(\"bar\")))\n\n\tassertParseError(t, \"missing component 1\", \"foo.\")\n\tassertParseError(t, \"missing component 2\", \"foo[].bar\")\n\tassertParseError(t, \"invalid composite operand\", \"foo[1,2]\")\n\tassertParseError(t, \"invalid call\", \"bar(..\")\n\tassertParseError(t, \"invalid ref\", \"bar[..\")\n\tassertParseError(t, \"invalid ref head type number\", \"0[0]\")\n\tassertParseError(t, \"invalid ref head type boolean\", \"true[0]\")\n\tassertParseError(t, \"invalid ref head type string\", `\"foo\"[0]`)\n\tassertParseError(t, \"invalid ref head type null\", `null[0]`)\n}\n\nfunc TestObjectWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"{\\\"abc\\\": 7, \\\"def\\\": 8}\", ObjectTerm(Item(StringTerm(\"abc\"), IntNumberTerm(7)), Item(StringTerm(\"def\"), IntNumberTerm(8))))\n\tassertParseOneTerm(t, \"bool\", \"{\\\"abc\\\": false, \\\"def\\\": true}\", ObjectTerm(Item(StringTerm(\"abc\"), BooleanTerm(false)), Item(StringTerm(\"def\"), BooleanTerm(true))))\n\tassertParseOneTerm(t, \"string\", \"{\\\"abc\\\": \\\"foo\\\", \\\"def\\\": \\\"bar\\\"}\", ObjectTerm(Item(StringTerm(\"abc\"), StringTerm(\"foo\")), Item(StringTerm(\"def\"), StringTerm(\"bar\"))))\n\tassertParseOneTerm(t, \"mixed\", \"{\\\"abc\\\": 7, \\\"def\\\": null}\", ObjectTerm(Item(StringTerm(\"abc\"), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"number key\", \"{8: 7, \\\"def\\\": null}\", ObjectTerm(Item(IntNumberTerm(8), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"number key 2\", \"{8.5: 7, \\\"def\\\": null}\", ObjectTerm(Item(FloatNumberTerm(8.5), IntNumberTerm(7)), Item(StringTerm(\"def\"), NullTerm())))\n\tassertParseOneTerm(t, \"bool key\", \"{true: false}\", ObjectTerm(Item(BooleanTerm(true), BooleanTerm(false))))\n\tassertParseOneTerm(t, \"trailing comma\", `{\"a\": \"bar\", \"b\": 64, }`, ObjectTerm(Item(StringTerm(\"a\"), StringTerm(\"bar\")), Item(StringTerm(\"b\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"leading comma\", `{, \"a\": \"bar\", \"b\": 64 }`, ObjectTerm(Item(StringTerm(\"a\"), StringTerm(\"bar\")), Item(StringTerm(\"b\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", `{, 1 | 1: \"bar\"}`, ObjectTerm(Item(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\")), StringTerm(\"bar\"))))\n}\n\nfunc TestObjectWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var keys\", \"{foo: \\\"bar\\\", bar: 64}\", ObjectTerm(Item(VarTerm(\"foo\"), StringTerm(\"bar\")), Item(VarTerm(\"bar\"), IntNumberTerm(64))))\n\tassertParseOneTerm(t, \"nested var keys\", \"{baz: {foo: \\\"bar\\\", bar: qux}}\", ObjectTerm(Item(VarTerm(\"baz\"), ObjectTerm(Item(VarTerm(\"foo\"), StringTerm(\"bar\")), Item(VarTerm(\"bar\"), VarTerm(\"qux\"))))))\n\tassertParseOneTerm(t, \"ambiguous or\", `{ a: b+c | d }`, ObjectTerm(Item(VarTerm(\"a\"), CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), VarTerm(\"b\"), VarTerm(\"c\")), VarTerm(\"d\")))))\n}\n\nfunc TestObjectWithRelation(t *testing.T) {\n\tassertParseOneTerm(t, \"relation term value\", `{\"x\": 1+1}`, ObjectTerm(\n\t\tItem(StringTerm(\"x\"), CallTerm(RefTerm(VarTerm(\"plus\")), IntNumberTerm(1), IntNumberTerm(1))),\n\t))\n\tassertParseError(t, \"invalid relation term value\", `{\"x\": 0= }`)\n}\n\nfunc TestObjectFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"{foo: bar, baz: [], qux: corge\")\n\tassertParseError(t, \"non-terminated 2\", \"{foo: bar, baz: [], qux: \")\n\tassertParseError(t, \"non-terminated 3\", \"{foo: bar, baz: [], qux \")\n\tassertParseError(t, \"non-terminated 4\", \"{foo: bar, baz: [], \")\n\tassertParseError(t, \"missing separator\", \"{foo: bar baz: []}\")\n\tassertParseError(t, \"missing start\", \"foo: bar, baz: [], qux: corge}\")\n\tassertParseError(t, \"double comma\", \"{a:1,,b:2}\")\n\tassertParseError(t, \"leading double comma\", \"{,,a:1}\")\n\tassertParseError(t, \"trailing double comma\", \"{a:1,,}\")\n}\n\nfunc TestArrayWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"[1,2,3,4.5]\", ArrayTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), FloatNumberTerm(4.5)))\n\tassertParseOneTerm(t, \"bool\", \"[true, false, true]\", ArrayTerm(BooleanTerm(true), BooleanTerm(false), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"string\", \"[\\\"foo\\\", \\\"bar\\\"]\", ArrayTerm(StringTerm(\"foo\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"mixed\", \"[null, true, 42]\", ArrayTerm(NullTerm(), BooleanTerm(true), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"trailing comma - one element\", \"[null, ]\", ArrayTerm(NullTerm()))\n\tassertParseOneTerm(t, \"trailing comma\", \"[null, true, ]\", ArrayTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma\", \"[, null, true]\", ArrayTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", \"[, 1 | 1]\", ArrayTerm(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\"))))\n\tassertParseOneTerm(t, \"ambiguous or\", \"[ 1 + 2 | 3 ]\", ArrayTerm(CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")), NumberTerm(\"3\"))))\n}\n\nfunc TestArrayWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var elements\", \"[foo, bar, 42]\", ArrayTerm(VarTerm(\"foo\"), VarTerm(\"bar\"), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"nested var elements\", \"[[foo, true], [null, bar], 42]\", ArrayTerm(ArrayTerm(VarTerm(\"foo\"), BooleanTerm(true)), ArrayTerm(NullTerm(), VarTerm(\"bar\")), IntNumberTerm(42)))\n}\n\nfunc TestArrayFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"[foo, bar\")\n\tassertParseError(t, \"non-terminated 2\", \"[foo, bar, \")\n\tassertParseError(t, \"missing separator\", \"[foo bar]\")\n\tassertParseError(t, \"missing start\", \"foo, bar, baz]\")\n\tassertParseError(t, \"bad term\", \"[!!!]\")\n\tassertParseError(t, \"double comma\", \"[a,,b]\")\n\tassertParseError(t, \"leading double comma\", \"[,,a]\")\n\tassertParseError(t, \"trailing double comma\", \"[a,,]\")\n}\n\nfunc TestSetWithScalars(t *testing.T) {\n\tassertParseOneTerm(t, \"number\", \"{1,2,3,4.5}\", SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), FloatNumberTerm(4.5)))\n\tassertParseOneTerm(t, \"bool\", \"{true, false, true}\", SetTerm(BooleanTerm(true), BooleanTerm(false), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"string\", \"{\\\"foo\\\", \\\"bar\\\"}\", SetTerm(StringTerm(\"foo\"), StringTerm(\"bar\")))\n\tassertParseOneTerm(t, \"mixed\", \"{null, true, 42}\", SetTerm(NullTerm(), BooleanTerm(true), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"trailing comma\", \"{null, true,}\", SetTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma\", \"{, null, true}\", SetTerm(NullTerm(), BooleanTerm(true)))\n\tassertParseOneTerm(t, \"leading comma not comprehension\", \"{, 1 | 1}\", SetTerm(CallTerm(RefTerm(VarTerm(\"or\")), NumberTerm(\"1\"), NumberTerm(\"1\"))))\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ 1 + 2 | 3}\", SetTerm(CallTerm(RefTerm(VarTerm(\"or\")), CallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")), NumberTerm(\"3\"))))\n}\n\nfunc TestSetWithVars(t *testing.T) {\n\tassertParseOneTerm(t, \"var elements\", \"{foo, bar, 42}\", SetTerm(VarTerm(\"foo\"), VarTerm(\"bar\"), IntNumberTerm(42)))\n\tassertParseOneTerm(t, \"nested var elements\", \"{[foo, true], {null, bar}, set()}\", SetTerm(ArrayTerm(VarTerm(\"foo\"), BooleanTerm(true)), SetTerm(NullTerm(), VarTerm(\"bar\")), SetTerm()))\n}\n\nfunc TestSetFail(t *testing.T) {\n\tassertParseError(t, \"non-terminated 1\", \"set(\")\n\tassertParseError(t, \"non-terminated 2\", \"{foo, bar\")\n\tassertParseError(t, \"non-terminated 3\", \"{foo, bar, \")\n\tassertParseError(t, \"missing separator\", \"{foo bar}\")\n\tassertParseError(t, \"missing start\", \"foo, bar, baz}\")\n\tassertParseError(t, \"bad term\", \"{!!!}\")\n\tassertParseError(t, \"double comma\", \"{a,,b}\")\n\tassertParseError(t, \"leading double comma\", \"{,,a}\")\n\tassertParseError(t, \"trailing double comma\", \"{a,,}\")\n}\n\nfunc TestEmptyComposites(t *testing.T) {\n\tassertParseOneTerm(t, \"empty object\", \"{}\", ObjectTerm())\n\tassertParseOneTerm(t, \"empty array\", \"[]\", ArrayTerm())\n\tassertParseOneTerm(t, \"empty set\", \"set()\", SetTerm())\n}\n\nfunc TestNestedComposites(t *testing.T) {\n\tassertParseOneTerm(t, \"nested composites\", \"[{foo: [\\\"bar\\\", {baz}]}]\", ArrayTerm(ObjectTerm(Item(VarTerm(\"foo\"), ArrayTerm(StringTerm(\"bar\"), SetTerm(VarTerm(\"baz\")))))))\n}\n\nfunc TestCompositesWithRefs(t *testing.T) {\n\tref1 := RefTerm(VarTerm(\"a\"), VarTerm(\"i\"), StringTerm(\"b\"))\n\tref2 := RefTerm(VarTerm(\"c\"), IntNumberTerm(0), StringTerm(\"d\"), StringTerm(\"e\"), VarTerm(\"j\"))\n\tassertParseOneTerm(t, \"ref keys\", \"[{a[i].b: 8, c[0][\\\"d\\\"].e[j]: f}]\", ArrayTerm(ObjectTerm(Item(ref1, IntNumberTerm(8)), Item(ref2, VarTerm(\"f\")))))\n\tassertParseOneTerm(t, \"ref values\", \"[{8: a[i].b, f: c[0][\\\"d\\\"].e[j]}]\", ArrayTerm(ObjectTerm(Item(IntNumberTerm(8), ref1), Item(VarTerm(\"f\"), ref2))))\n\tassertParseOneTerm(t, \"ref values (sets)\", `{a[i].b, {c[0][\"d\"].e[j]}}`, SetTerm(ref1, SetTerm(ref2)))\n}\n\nfunc TestArrayComprehensions(t *testing.T) {\n\n\tnestedTerm := `[{\"x\": [a[i] | xs = [{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"]; xs[j].a[k] = \"foo\"]}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tArrayComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tArrayComprehensionTerm(\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"[ a | b ]\", ArrayComprehensionTerm(\n\t\tVarTerm(\"a\"),\n\t\tMustParseBody(\"b\"),\n\t))\n}\n\nfunc TestObjectComprehensions(t *testing.T) {\n\tnestedTerm := `[{\"x\": {a[i]: b[i] | xs = {\"foo\":{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"}; xs[j].a[k] = \"foo\"}}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tObjectComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tRefTerm(VarTerm(\"b\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tObjectComprehensionTerm(\n\t\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ 1+2: 3 | 4}\", ObjectComprehensionTerm(\n\t\tCallTerm(RefTerm(VarTerm(\"plus\")), NumberTerm(\"1\"), NumberTerm(\"2\")),\n\t\tNumberTerm(\"3\"),\n\t\tMustParseBody(\"4\"),\n\t))\n}\n\nfunc TestObjectComprehensionError(t *testing.T) {\n\tassertParseError(t, \"bad body\", \"{x: y|!!!}\")\n}\n\nfunc TestSetComprehensions(t *testing.T) {\n\tnestedTerm := `[{\"x\": {a[i] | xs = {{\"a\": [\"baz\", j]} | q[p]; p.a != \"bar\"; j = \"foo\"}; xs[j].a[k] = \"foo\"}}]`\n\tnestedExpected := ArrayTerm(\n\t\tObjectTerm(Item(\n\t\t\tStringTerm(\"x\"),\n\t\t\tSetComprehensionTerm(\n\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"i\")),\n\t\t\t\tNewBody(\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t\t\tSetComprehensionTerm(\n\t\t\t\t\t\t\tObjectTerm(Item(StringTerm(\"a\"), ArrayTerm(StringTerm(\"baz\"), VarTerm(\"j\")))),\n\t\t\t\t\t\t\tNewBody(\n\t\t\t\t\t\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"p\"))),\n\t\t\t\t\t\t\t\tNotEqual.Expr(RefTerm(VarTerm(\"p\"), StringTerm(\"a\")), StringTerm(\"bar\")),\n\t\t\t\t\t\t\t\tEquality.Expr(VarTerm(\"j\"), StringTerm(\"foo\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\tEquality.Expr(\n\t\t\t\t\t\tRefTerm(VarTerm(\"xs\"), VarTerm(\"j\"), StringTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t\t\t\tStringTerm(\"foo\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)),\n\t)\n\n\tassertParseOneTerm(t, \"nested\", nestedTerm, nestedExpected)\n\tassertParseOneTerm(t, \"ambiguous or\", \"{ a | b }\", SetComprehensionTerm(\n\t\tVarTerm(\"a\"),\n\t\tMustParseBody(\"b\"),\n\t))\n}\n\nfunc TestSetComprehensionError(t *testing.T) {\n\tassertParseError(t, \"bad body\", \"{x|!!!}\")\n}\n\nfunc TestSetComprehensionsAlone(t *testing.T) {\n\tinput := `{k | a = [1,2,3]; a[k]}`\n\n\texpected := SetComprehensionTerm(\n\t\tVarTerm(\"k\"),\n\t\tNewBody(\n\t\t\tEquality.Expr(\n\t\t\t\tVarTerm(\"a\"),\n\t\t\t\tArrayTerm(NumberTerm(\"1\"), NumberTerm(\"2\"), NumberTerm(\"3\")),\n\t\t\t),\n\t\t\t&Expr{\n\t\t\t\tTerms: RefTerm(VarTerm(\"a\"), VarTerm(\"k\")),\n\t\t\t},\n\t\t),\n\t)\n\n\tassertParseOneTerm(t, \"alone\", input, expected)\n}\n\nfunc TestCalls(t *testing.T) {\n\n\tassertParseOneExpr(t, \"ne\", \"100 != 200\", NotEqual.Expr(IntNumberTerm(100), IntNumberTerm(200)))\n\tassertParseOneExpr(t, \"gt\", \"17.4 > \\\"hello\\\"\", GreaterThan.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"lt\", \"17.4 < \\\"hello\\\"\", LessThan.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"gte\", \"17.4 >= \\\"hello\\\"\", GreaterThanEq.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\tassertParseOneExpr(t, \"lte\", \"17.4 <= \\\"hello\\\"\", LessThanEq.Expr(FloatNumberTerm(17.4), StringTerm(\"hello\")))\n\n\tleft2 := ArrayTerm(ObjectTerm(Item(FloatNumberTerm(14.2), BooleanTerm(true)), Item(StringTerm(\"a\"), NullTerm())))\n\tright2 := ObjectTerm(Item(VarTerm(\"foo\"), ObjectTerm(Item(RefTerm(VarTerm(\"a\"), StringTerm(\"b\"), IntNumberTerm(0)), ArrayTerm(IntNumberTerm(10))))))\n\tassertParseOneExpr(t, \"composites\", \"[{14.2: true, \\\"a\\\": null}] != {foo: {a.b[0]: [10]}}\", NotEqual.Expr(left2, right2))\n\n\tassertParseOneExpr(t, \"plus\", \"1 + 2\", Plus.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"minus\", \"1 - 2\", Minus.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"mul\", \"1 * 2\", Multiply.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"div\", \"1 / 2\", Divide.Expr(IntNumberTerm(1), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"rem\", \"3 % 2\", Rem.Expr(IntNumberTerm(3), IntNumberTerm(2)))\n\tassertParseOneExpr(t, \"and\", \"{1,2,3} & {2,3,4}\", And.Expr(SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3)), SetTerm(IntNumberTerm(2), IntNumberTerm(3), IntNumberTerm(4))))\n\tassertParseOneExpr(t, \"or\", \"{1,2,3} | {3,4,5}\", Or.Expr(SetTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3)), SetTerm(IntNumberTerm(3), IntNumberTerm(4), IntNumberTerm(5))))\n\n\tassertParseOneExpr(t, \"call\", \"count([true, false])\", Count.Expr(ArrayTerm(BooleanTerm(true), BooleanTerm(false))))\n\tassertParseOneExpr(t, \"call-ref\", \"foo.bar(1)\", NewExpr(\n\t\t[]*Term{RefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\tIntNumberTerm(1)}))\n\tassertParseOneExpr(t, \"call-void\", \"foo()\", NewExpr(\n\t\t[]*Term{RefTerm(VarTerm(\"foo\"))}))\n\n\topts := ParserOptions{FutureKeywords: []string{\"in\"}}\n\tassertParseOneExpr(t, \"internal.member_2\", \"x in xs\", Member.Expr(VarTerm(\"x\"), VarTerm(\"xs\")), opts)\n\tassertParseOneExpr(t, \"internal.member_3\", \"x, y in xs\", MemberWithKey.Expr(VarTerm(\"x\"), VarTerm(\"y\"), VarTerm(\"xs\")), opts)\n}\n\nfunc TestInfixExpr(t *testing.T) {\n\tassertParseOneExpr(t, \"scalars 1\", \"true = false\", Equality.Expr(BooleanTerm(true), BooleanTerm(false)))\n\tassertParseOneExpr(t, \"scalars 2\", \"3.14 = null\", Equality.Expr(FloatNumberTerm(3.14), NullTerm()))\n\tassertParseOneExpr(t, \"scalars 3\", \"42 = \\\"hello world\\\"\", Equality.Expr(IntNumberTerm(42), StringTerm(\"hello world\")))\n\tassertParseOneExpr(t, \"vars 1\", \"hello = world\", Equality.Expr(VarTerm(\"hello\"), VarTerm(\"world\")))\n\tassertParseOneExpr(t, \"vars 2\", \"42 = hello\", Equality.Expr(IntNumberTerm(42), VarTerm(\"hello\")))\n\n\tref1 := RefTerm(VarTerm(\"foo\"), IntNumberTerm(0), StringTerm(\"bar\"), VarTerm(\"x\"))\n\tref2 := RefTerm(VarTerm(\"baz\"), BooleanTerm(false), StringTerm(\"qux\"), StringTerm(\"hello\"))\n\tassertParseOneExpr(t, \"refs 1\", \"foo[0].bar[x] = baz[false].qux[\\\"hello\\\"]\", Equality.Expr(ref1, ref2))\n\n\tleft1 := ObjectTerm(Item(VarTerm(\"a\"), ArrayTerm(ref1)))\n\tright1 := ArrayTerm(ObjectTerm(Item(IntNumberTerm(42), BooleanTerm(true))))\n\tassertParseOneExpr(t, \"composites\", \"{a: [foo[0].bar[x]]} = [{42: true}]\", Equality.Expr(left1, right1))\n\n\tassertParseOneExpr(t, \"plus\", \"x = 1 + 2\", Equality.Expr(VarTerm(\"x\"), Plus.Call(IntNumberTerm(1), IntNumberTerm(2))))\n\tassertParseOneExpr(t, \"plus reverse\", \"1 + 2 = x\", Equality.Expr(Plus.Call(IntNumberTerm(1), IntNumberTerm(2)), VarTerm(\"x\")))\n\n\tassertParseOneExpr(t, \"call\", \"count([true, false]) = x\", Equality.Expr(Count.Call(ArrayTerm(BooleanTerm(true), BooleanTerm(false))), VarTerm(\"x\")))\n\tassertParseOneExpr(t, \"call-reverse\", \"x = count([true, false])\", Equality.Expr(VarTerm(\"x\"), Count.Call(ArrayTerm(BooleanTerm(true), BooleanTerm(false)))))\n}\n\nfunc TestNegatedExpr(t *testing.T) {\n\tassertParseOneTermNegated(t, \"scalars 1\", \"not true\", BooleanTerm(true))\n\tassertParseOneTermNegated(t, \"scalars 2\", \"not \\\"hello\\\"\", StringTerm(\"hello\"))\n\tassertParseOneTermNegated(t, \"scalars 3\", \"not 100\", IntNumberTerm(100))\n\tassertParseOneTermNegated(t, \"scalars 4\", \"not null\", NullTerm())\n\tassertParseOneTermNegated(t, \"var\", \"not x\", VarTerm(\"x\"))\n\tassertParseOneTermNegated(t, \"ref\", \"not x[y].z\", RefTerm(VarTerm(\"x\"), VarTerm(\"y\"), StringTerm(\"z\")))\n\tassertParseOneExprNegated(t, \"vars\", \"not x = y\", Equality.Expr(VarTerm(\"x\"), VarTerm(\"y\")))\n\n\tref1 := RefTerm(VarTerm(\"x\"), VarTerm(\"y\"), StringTerm(\"z\"), VarTerm(\"a\"))\n\n\tassertParseOneExprNegated(t, \"membership\", \"not x[y].z[a] = \\\"b\\\"\", Equality.Expr(ref1, StringTerm(\"b\")))\n\tassertParseOneExprNegated(t, \"misc. builtin\", \"not sorted(x[y].z[a])\", NewExpr([]*Term{RefTerm(VarTerm(\"sorted\")), ref1}))\n}\n\nfunc TestExprWith(t *testing.T) {\n\tassertParseOneExpr(t, \"input\", \"data.foo with input as baz\", &Expr{\n\t\tTerms: MustParseTerm(\"data.foo\"),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: NewTerm(InputRootRef),\n\t\t\t\tValue:  VarTerm(\"baz\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"builtin/ref target/composites\", `plus(data.foo, 1, x) with input.com.acmecorp.obj as {\"count\": [{1,2,3}]}`, &Expr{\n\t\tTerms: MustParseExpr(\"plus(data.foo, 1, x)\").Terms,\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.com.acmecorp.obj\"),\n\t\t\t\tValue:  MustParseTerm(`{\"count\": [{1,2,3}]}`),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"multiple\", `data.foo with input.obj as baz with input.com.acmecorp.obj as {\"count\": [{1,2,3}]}`, &Expr{\n\t\tTerms: MustParseTerm(\"data.foo\"),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.obj\"),\n\t\t\t\tValue:  VarTerm(\"baz\"),\n\t\t\t},\n\t\t\t{\n\t\t\t\tTarget: MustParseTerm(\"input.com.acmecorp.obj\"),\n\t\t\t\tValue:  MustParseTerm(`{\"count\": [{1,2,3}]}`),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"variable target\", \"true with x as 1\", &Expr{\n\t\tTerms: BooleanTerm(true),\n\t\tWith: []*With{\n\t\t\t{\n\t\t\t\tTarget: VarTerm(\"x\"),\n\t\t\t\tValue:  IntNumberTerm(1),\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestExprWithLocation(t *testing.T) {\n\tcases := []struct {\n\t\tnote     string\n\t\tinput    string\n\t\texpected []*Location\n\t}{\n\t\t{\n\t\t\tnote:  \"base\",\n\t\t\tinput: \"a with b as c\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"with line break\",\n\t\t\tinput: \"a with b\\nas c\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b\\nas c\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"multiple withs on single line\",\n\t\t\tinput: \"a with b as c with d as e\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    15,\n\t\t\t\t\tOffset: 14,\n\t\t\t\t\tText:   []byte(\"with d as e\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:  \"multiple withs on multiple line\",\n\t\t\tinput: \"a with b as c\\n\\t\\twith d as e\",\n\t\t\texpected: []*Location{\n\t\t\t\t{\n\t\t\t\t\tRow:    1,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 2,\n\t\t\t\t\tText:   []byte(\"with b as c\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tRow:    2,\n\t\t\t\t\tCol:    3,\n\t\t\t\t\tOffset: 16,\n\t\t\t\t\tText:   []byte(\"with d as e\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := ParseStatement(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error on %s: %s\", tc.input, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbody := parsed.(Body)\n\t\t\tif len(body) != 1 {\n\t\t\t\tt.Errorf(\"Parser returned multiple expressions: %v\", body)\n\t\t\t\treturn\n\t\t\t}\n\t\t\texpr := body[0]\n\t\t\tif len(expr.With) != len(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected %d with statements, got %d\", len(expr.With), len(tc.expected))\n\t\t\t}\n\t\t\tfor i, with := range expr.With {\n\t\t\t\tif !with.Location.Equal(tc.expected[i]) {\n\t\t\t\t\tt.Errorf(\"Expected location %+v for '%v' but got %+v \", *(tc.expected[i]), with.String(), *with.Location)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSomeDeclExpr(t *testing.T) {\n\topts := ParserOptions{FutureKeywords: []string{\"in\"}}\n\n\tassertParseOneExpr(t, \"one\", \"some x\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseOneExpr(t, \"internal.member_2\", \"some x in xs\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tMember.Call(\n\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseOneExpr(t, \"internal.member_3\", \"some x, y in xs\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tMemberWithKey.Call(\n\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\tVarTerm(\"y\"),\n\t\t\t\t\tVarTerm(\"xs\"),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseErrorContains(t, \"not some\", \"not some x, y in xs\",\n\t\t\"unexpected some keyword: illegal negation of 'some'\",\n\t\topts)\n\n\tassertParseErrorContains(t, \"some + function call\", \"some f(x)\",\n\t\t\"expected `x in xs` or `x, y in xs` expression\")\n\n\tassertParseOneExpr(t, \"multiple\", \"some x, y\", &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t\tVarTerm(\"y\"),\n\t\t\t},\n\t\t},\n\t}, opts)\n\n\tassertParseOneExpr(t, \"multiple split across lines\", `some x, y,\n\t\tz`, &Expr{\n\t\tTerms: &SomeDecl{\n\t\t\tSymbols: []*Term{\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t\tVarTerm(\"y\"),\n\t\t\t\tVarTerm(\"z\"),\n\t\t\t},\n\t\t},\n\t})\n\n\tassertParseRule(t, \"whitespace separated\", `\n\n\t\tp[x] {\n\t\t\tsome x\n\t\t\tq[x]\n\t\t}\n\t`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(RefTerm(VarTerm(\"q\"), VarTerm(\"x\"))),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"whitespace separated, following `in` rule ref\", `\n\tp[x] {\n\t\tsome x\n\t\tin[x]\n\t}\n`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(RefTerm(VarTerm(\"in\"), VarTerm(\"x\"))),\n\t\t),\n\t})\n\n\tassertParseErrorContains(t, \"some x in ... usage is hinted properly\", `\n\tp[x] {\n\t\tsome x in {\"foo\": \"bar\"}\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.in` for `some x in xs` expressions)\")\n\n\tassertParseErrorContains(t, \"some x, y in ... usage is hinted properly\", `\n\tp[y] = x {\n\t\tsome x, y in {\"foo\": \"bar\"}\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.in` for `some x in xs` expressions)\")\n\n\tassertParseRule(t, \"whitespace terminated\", `\n\n\tp[x] {\n\t\tsome x\n\t\tx\n\t}\n`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tNewExpr(&SomeDecl{Symbols: []*Term{VarTerm(\"x\")}}),\n\t\t\tNewExpr(VarTerm(\"x\")),\n\t\t),\n\t})\n\n\tassertParseOneExpr(t, \"with modifier on expr\", \"some x, y in input with input as []\",\n\t\t&Expr{\n\t\t\tTerms: &SomeDecl{\n\t\t\t\tSymbols: []*Term{\n\t\t\t\t\tMemberWithKey.Call(\n\t\t\t\t\t\tVarTerm(\"x\"),\n\t\t\t\t\t\tVarTerm(\"y\"),\n\t\t\t\t\t\tNewTerm(MustParseRef(\"input\")),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWith: []*With{{Value: ArrayTerm(), Target: NewTerm(MustParseRef(\"input\"))}},\n\t\t}, opts)\n\n\tassertParseErrorContains(t, \"invalid domain (internal.member_2)\", \"some internal.member_2()\", \"illegal domain\", opts)\n\tassertParseErrorContains(t, \"invalid domain (internal.member_3)\", \"some internal.member_3()\", \"illegal domain\", opts)\n\n}\n\nfunc TestEvery(t *testing.T) {\n\topts := ParserOptions{unreleasedKeywords: true, FutureKeywords: []string{\"every\"}}\n\tassertParseOneExpr(t, \"simple\", \"every x in xs { true }\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tValue:  VarTerm(\"x\"),\n\t\t\t\tDomain: VarTerm(\"xs\"),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(BooleanTerm(true)),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\topts)\n\n\tassertParseOneExpr(t, \"with key\", \"every k, v in [1,2] { true }\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tKey:    VarTerm(\"k\"),\n\t\t\t\tValue:  VarTerm(\"v\"),\n\t\t\t\tDomain: ArrayTerm(IntNumberTerm(1), IntNumberTerm(2)),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(BooleanTerm(true)),\n\t\t\t\t},\n\t\t\t},\n\t\t}, opts)\n\n\tassertParseErrorContains(t, \"arbitrary term\", \"every 10\", \"expected `x[, y] in xs { ... }` expression\", opts)\n\tassertParseErrorContains(t, \"non-var value\", \"every 10 in xs { true }\", \"unexpected { token: expected value to be a variable\", opts)\n\tassertParseErrorContains(t, \"non-var key\", \"every 10, x in xs { true }\", \"unexpected { token: expected key to be a variable\", opts)\n\tassertParseErrorContains(t, \"arbitrary call\", \"every f(10)\", \"expected `x[, y] in xs { ... }` expression\", opts)\n\tassertParseErrorContains(t, \"no body\", \"every x in xs\", \"missing body\", opts)\n\tassertParseErrorContains(t, \"invalid body\", \"every x in xs { + }\", \"unexpected plus token\", opts)\n\tassertParseErrorContains(t, \"not every\", \"not every x in xs { true }\", \"unexpected every keyword: illegal negation of 'every'\", opts)\n\n\tassertParseOneExpr(t, `\"every\" kw implies \"in\" kw`, \"x in xs\", Member.Expr(\n\t\tVarTerm(\"x\"),\n\t\tVarTerm(\"xs\"),\n\t), opts)\n\n\tassertParseOneExpr(t, \"with modifier on expr\", \"every x in input { x } with input as []\",\n\t\t&Expr{\n\t\t\tTerms: &Every{\n\t\t\t\tValue:  VarTerm(\"x\"),\n\t\t\t\tDomain: NewTerm(MustParseRef(\"input\")),\n\t\t\t\tBody: []*Expr{\n\t\t\t\t\tNewExpr(VarTerm(\"x\")),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWith: []*With{{Value: ArrayTerm(), Target: NewTerm(MustParseRef(\"input\"))}},\n\t\t}, opts)\n\n\tassertParseErrorContains(t, \"every x, y in ... usage is hinted properly\", `\n\tp {\n\t\tevery x, y in {\"foo\": \"bar\"} { is_string(x); is_string(y) }\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or } (hint: `import future.keywords.every` for `every x in xs { ... }` expressions)\")\n\n\tassertParseErrorContains(t, \"not every 'every' gets a hint\", `\n\tp {\n\t\tevery x\n\t}`,\n\t\t\"unexpected ident token: expected \\\\n or ; or }\\n\\tevery x\\n\", // this asserts that the tail of the error message doesn't contain a hint\n\t)\n\n\tassertParseErrorContains(t, \"invalid domain (internal.member_2)\", \"every internal.member_2()\", \"illegal domain\", opts)\n\tassertParseErrorContains(t, \"invalid domain (internal.member_3)\", \"every internal.member_3()\", \"illegal domain\", opts)\n}\n\nfunc TestNestedExpressions(t *testing.T) {\n\n\tn1 := IntNumberTerm(1)\n\tn2 := IntNumberTerm(2)\n\tn3 := IntNumberTerm(3)\n\tn4 := IntNumberTerm(4)\n\tn6 := IntNumberTerm(6)\n\tx := VarTerm(\"x\")\n\ty := VarTerm(\"y\")\n\tz := VarTerm(\"z\")\n\tw := VarTerm(\"w\")\n\tf := RefTerm(VarTerm(\"f\"))\n\tg := RefTerm(VarTerm(\"g\"))\n\n\ttests := []struct {\n\t\tnote     string\n\t\tinput    string\n\t\texpected *Expr\n\t}{\n\t\t{\"associativity\", \"1 + 2 * 6 / 3\",\n\t\t\tPlus.Expr(\n\t\t\t\tn1,\n\t\t\t\tDivide.Call(\n\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\tn6),\n\t\t\t\t\tn3))},\n\t\t{\"associativity - factors\", \"x * y / z % w\",\n\t\t\tRem.Expr(Divide.Call(Multiply.Call(x, y), z), w)},\n\t\t{\"associativity - factors\", \"w % z / x * y\",\n\t\t\tMultiply.Expr(Divide.Call(Rem.Call(w, z), x), y)},\n\t\t{\"associativity - arithetic\", \"x + y - z\",\n\t\t\tMinus.Expr(Plus.Call(x, y), z)},\n\t\t{\"associativity - arithmetic\", \"z - x + y\",\n\t\t\tPlus.Expr(Minus.Call(z, x), y)},\n\t\t{\"associativity - and\", \"z & x & y\",\n\t\t\tAnd.Expr(And.Call(z, x), y)},\n\t\t{\"associativity - or\", \"z | x | y\",\n\t\t\tOr.Expr(Or.Call(z, x), y)},\n\t\t{\"associativity - relations\", \"x == y != z\",\n\t\t\tNotEqual.Expr(Equal.Call(x, y), z)},\n\t\t{\"grouping\", \"(1 + 2 * 6 / 3) > 4\",\n\t\t\tGreaterThan.Expr(\n\t\t\t\tPlus.Call(\n\t\t\t\t\tn1,\n\t\t\t\t\tDivide.Call(\n\t\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\t\tn2,\n\t\t\t\t\t\t\tn6),\n\t\t\t\t\t\tn3)),\n\t\t\t\tn4)},\n\t\t{\"nested parens\", \"(((1 + 2) * (6 / (3))) > 4) != false\",\n\t\t\tNotEqual.Expr(\n\t\t\t\tGreaterThan.Call(\n\t\t\t\t\tMultiply.Call(\n\t\t\t\t\t\tPlus.Call(\n\t\t\t\t\t\t\tn1,\n\t\t\t\t\t\t\tn2),\n\t\t\t\t\t\tDivide.Call(\n\t\t\t\t\t\t\tn6,\n\t\t\t\t\t\t\tn3)),\n\t\t\t\t\tn4,\n\t\t\t\t),\n\t\t\t\tBooleanTerm(false))},\n\t\t{\"bitwise or\", \"x + 1 | 2\", Or.Expr(Plus.Call(x, n1), n2)},\n\t\t{\"bitwise and\", \"x + 1 | 2 & 3\", Or.Expr(Plus.Call(x, n1), And.Call(n2, n3))},\n\t\t{\"array\", \"[x + 1, y > 2, z]\", NewExpr(ArrayTerm(Plus.Call(x, n1), GreaterThan.Call(y, n2), z))},\n\t\t{\"object\", \"{x * 2: y < 2, z[3]: 1 + 6/2}\", NewExpr(\n\t\t\tObjectTerm(\n\t\t\t\tItem(Multiply.Call(x, n2), LessThan.Call(y, n2)),\n\t\t\t\tItem(RefTerm(z, n3), Plus.Call(n1, Divide.Call(n6, n2))),\n\t\t\t),\n\t\t)},\n\t\t{\"set\", \"{x + 1, y + 2, set()}\", NewExpr(\n\t\t\tSetTerm(\n\t\t\t\tPlus.Call(x, n1),\n\t\t\t\tPlus.Call(y, n2),\n\t\t\t\tSetTerm(),\n\t\t\t),\n\t\t)},\n\t\t{\"ref\", `x[1][y + z[w + 1]].b`, NewExpr(\n\t\t\tRefTerm(\n\t\t\t\tx,\n\t\t\t\tn1,\n\t\t\t\tPlus.Call(\n\t\t\t\t\ty,\n\t\t\t\t\tRefTerm(\n\t\t\t\t\t\tz,\n\t\t\t\t\t\tPlus.Call(w, n1))),\n\t\t\t\tStringTerm(\"b\"),\n\t\t\t),\n\t\t)},\n\t\t{\"call void\", \"f()\", NewExpr([]*Term{f})},\n\t\t{\"call unary\", \"f(x)\", NewExpr([]*Term{f, x})},\n\t\t{\"call binary\", \"f(x, y)\", NewExpr([]*Term{f, x, y})},\n\t\t{\"call embedded\", \"f([g(x), y+1])\", NewExpr([]*Term{\n\t\t\tf,\n\t\t\tArrayTerm(\n\t\t\t\tCallTerm(g, x),\n\t\t\t\tPlus.Call(y, n1))})},\n\t\t{\"call fqn\", \"foo.bar(1)\", NewExpr([]*Term{\n\t\t\tRefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\tn1,\n\t\t})},\n\t\t{\"unify\", \"x = 1\", Equality.Expr(x, n1)},\n\t\t{\"unify embedded\", \"1 + x = 2 - y\", Equality.Expr(Plus.Call(n1, x), Minus.Call(n2, y))},\n\t\t{\"not keyword\", \"not x = y\", Equality.Expr(x, y).Complement()},\n\t\t{\"with keyword\", \"x with p[q] as f([x+1])\", NewExpr(x).IncludeWith(\n\t\t\tRefTerm(VarTerm(\"p\"), VarTerm(\"q\")),\n\t\t\tCallTerm(f, ArrayTerm(Plus.Call(x, n1))),\n\t\t)},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\texpr, err := ParseExpr(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !expr.Equal(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected %v but got %v\", tc.expected, expr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestChainedCall(t *testing.T) {\n\tresult, err := ParseExpr(\"foo.bar(1)[0](1).baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texp := NewExpr(RefTerm(\n\t\tCallTerm(\n\t\t\tRefTerm(\n\t\t\t\tCallTerm(\n\t\t\t\t\tRefTerm(VarTerm(\"foo\"), StringTerm(\"bar\")),\n\t\t\t\t\tIntNumberTerm(1)),\n\t\t\t\tIntNumberTerm(0)),\n\t\t\tIntNumberTerm(1)),\n\t\tStringTerm(\"baz\")))\n\n\tif !result.Equal(exp) {\n\t\tt.Fatalf(\"expected %v but got: %v\", exp, result)\n\t}\n}\n\nfunc TestMultiLineBody(t *testing.T) {\n\n\tinput1 := `\n\t\tx = 1\n\t\ty = 2\n\t\tz = [ i | [x,y] = arr\n\t\t\t\t   arr[_] = i]\n\t`\n\n\tbody1, err := ParseBody(input1)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error on enclosed body: %v\", err)\n\t}\n\n\texpected1 := MustParseBody(`x = 1; y = 2; z = [i | [x,y] = arr; arr[_] = i]`)\n\n\tif !body1.Equal(expected1) {\n\t\tt.Errorf(\"Expected enclosed body to equal %v but got: %v\", expected1, body1)\n\t}\n\n\t// Check that parser can handle multiple expressions w/o enclosing braces.\n\tinput2 := `\n\t\tx = 1 ; # comment after semicolon\n\t\ty = 2   # comment without semicolon\n\t\tz = [ i | [x,y] = arr  # comment in comprehension\n\t\t\t\t   arr[_] = i]\n\t`\n\n\tbody2, err := ParseBody(input2)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error on enclosed body: %v\", err)\n\t}\n\n\tif !body2.Equal(expected1) {\n\t\tt.Errorf(\"Expected unenclosed body to equal %v but got: %v\", expected1, body1)\n\t}\n\n\tassertParseOneBody(t, \"whitespace following call\", \"f(x)\\t\\n [1]\", NewBody(\n\t\tNewExpr(\n\t\t\t[]*Term{\n\t\t\t\tRefTerm(VarTerm(\"f\")),\n\t\t\t\tVarTerm(\"x\"),\n\t\t\t},\n\t\t),\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(1)),\n\t\t),\n\t))\n\n\tassertParseOneBody(t, \"whitespace following array\", \"[1]\\t\\n [2]\", NewBody(\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(1)),\n\t\t),\n\t\tNewExpr(\n\t\t\tArrayTerm(IntNumberTerm(2)),\n\t\t),\n\t))\n\n\tassertParseOneBody(t, \"whitespace following set\", \"{1}\\t\\n {2}\", NewBody(\n\t\tNewExpr(\n\t\t\tSetTerm(IntNumberTerm(1)),\n\t\t),\n\t\tNewExpr(\n\t\t\tSetTerm(IntNumberTerm(2)),\n\t\t),\n\t))\n}\n\nfunc TestBitwiseOrVsComprehension(t *testing.T) {\n\n\tx := VarTerm(\"x\")\n\ty := VarTerm(\"y\")\n\tz := VarTerm(\"z\")\n\ta := VarTerm(\"a\")\n\tb := VarTerm(\"b\")\n\n\ttests := []struct {\n\t\tnote  string\n\t\tinput string\n\t\texp   *Term\n\t}{\n\t\t{\n\t\t\tnote:  \"array containing bitwise or\",\n\t\t\tinput: \"[x|y,z]\",\n\t\t\texp:   ArrayTerm(Or.Call(x, y), z),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing bitwise or - last element\",\n\t\t\tinput: \"[z,x|y]\",\n\t\t\texp:   ArrayTerm(z, Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing bitwise or - middle\",\n\t\t\tinput: \"[z,x|y,a]\",\n\t\t\texp:   ArrayTerm(z, Or.Call(x, y), a),\n\t\t},\n\t\t{\n\t\t\tnote:  \"array containing single bitwise or\",\n\t\t\tinput: \"[x|y,]\",\n\t\t\texp:   ArrayTerm(Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or\",\n\t\t\tinput: \"{x|y,z}\",\n\t\t\texp:   SetTerm(Or.Call(x, y), z),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or - last element\",\n\t\t\tinput: \"{z,x|y}\",\n\t\t\texp:   SetTerm(z, Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing bitwise or - middle\",\n\t\t\tinput: \"{z,x|y,a}\",\n\t\t\texp:   SetTerm(z, Or.Call(x, y), a),\n\t\t},\n\t\t{\n\t\t\tnote:  \"set containing single bitwise or\",\n\t\t\tinput: \"{x|y,}\",\n\t\t\texp:   SetTerm(Or.Call(x, y)),\n\t\t},\n\t\t{\n\t\t\tnote:  \"object containing bitwise or\",\n\t\t\tinput: \"{x:y|z,a:b}\",\n\t\t\texp:   ObjectTerm([2]*Term{x, Or.Call(y, z)}, [2]*Term{a, b}),\n\t\t},\n\t\t{\n\t\t\tnote:  \"object containing single bitwise or\",\n\t\t\tinput: \"{x:y|z,}\",\n\t\t\texp:   ObjectTerm([2]*Term{x, Or.Call(y, z)}),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\n\t\t\tterm, err := ParseTerm(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif !term.Equal(tc.exp) {\n\t\t\t\tt.Fatalf(\"Expected %v but got %v\", tc.exp, term)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc TestPackage(t *testing.T) {\n\tref1 := RefTerm(DefaultRootDocument, StringTerm(\"foo\"))\n\tassertParsePackage(t, \"single\", `package foo`, &Package{Path: ref1.Value.(Ref)})\n\tref2 := RefTerm(DefaultRootDocument, StringTerm(\"f00\"), StringTerm(\"bar_baz\"), StringTerm(\"qux\"))\n\tassertParsePackage(t, \"multiple\", `package f00.bar_baz.qux`, &Package{Path: ref2.Value.(Ref)})\n\tref3 := RefTerm(DefaultRootDocument, StringTerm(\"foo\"), StringTerm(\"bar baz\"))\n\tassertParsePackage(t, \"space\", `package foo[\"bar baz\"]`, &Package{Path: ref3.Value.(Ref)})\n\tassertParseError(t, \"non-ground ref\", \"package foo[x]\")\n\tassertParseError(t, \"non-string value\", \"package foo.bar[42].baz\")\n\tassertParseError(t, \"invalid term\", \"package 42\")\n\tassertParseError(t, \"scanner error\", \"package foo.\")\n\tassertParseError(t, \"non-string first value\", \"package e().s\")\n}\n\nfunc TestImport(t *testing.T) {\n\tfoo := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"))\n\tfoobarbaz := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"baz\"))\n\twhitespace := RefTerm(VarTerm(\"input\"), StringTerm(\"foo\"), StringTerm(\"bar\"), StringTerm(\"white space\"))\n\tassertParseImport(t, \"single-input\", \"import input\", &Import{Path: RefTerm(InputRootDocument)})\n\tassertParseImport(t, \"single-data\", \"import data\", &Import{Path: RefTerm(DefaultRootDocument)})\n\tassertParseImport(t, \"multiple\", \"import input.foo.bar.baz\", &Import{Path: foobarbaz})\n\tassertParseImport(t, \"single alias\", \"import input.foo as bar\", &Import{Path: foo, Alias: Var(\"bar\")})\n\tassertParseImport(t, \"multiple alias\", \"import input.foo.bar.baz as qux\", &Import{Path: foobarbaz, Alias: Var(\"qux\")})\n\tassertParseImport(t, \"white space\", \"import input.foo.bar[\\\"white space\\\"]\", &Import{Path: whitespace})\n\tassertParseErrorContains(t, \"non-ground ref\", \"import data.foo[x]\", \"rego_parse_error: unexpected var token: expecting string\")\n\tassertParseErrorContains(t, \"non-string\", \"import input.foo[0]\", \"rego_parse_error: unexpected number token: expecting string\")\n\tassertParseErrorContains(t, \"unknown root\", \"import foo.bar\", \"rego_parse_error: unexpected import path, must begin with one of: {data, future, input}, got: foo\")\n\tassertParseErrorContains(t, \"bad variable term\", \"import input as A(\", \"rego_parse_error: unexpected eof token: expected var\")\n\n\t_, _, err := ParseStatements(\"\", \"package foo\\nimport bar.data\\ndefault foo=1\")\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error, but got nil\")\n\t}\n\tif len(err.(Errors)) > 1 {\n\t\tt.Fatalf(\"Expected a single error, got %s\", err)\n\t}\n\ttxt := err.(Errors)[0].Details.Lines()[0]\n\texpected := \"import bar.data\"\n\tif txt != expected {\n\t\tt.Fatalf(\"Expected error detail text '%s' but got '%s'\", expected, txt)\n\t}\n}\n\nfunc TestFutureImports(t *testing.T) {\n\tassertParseErrorContains(t, \"future\", \"import future\", \"invalid import, must be `future.keywords`\")\n\tassertParseErrorContains(t, \"future.a\", \"import future.a\", \"invalid import, must be `future.keywords`\")\n\tassertParseErrorContains(t, \"unknown keyword\", \"import future.keywords.xyz\", \"unexpected keyword, must be one of [every in]\")\n\tassertParseErrorContains(t, \"all keyword import + alias\", \"import future.keywords as xyz\", \"future keyword imports cannot be aliased\")\n\tassertParseErrorContains(t, \"keyword import + alias\", \"import future.keywords.in as xyz\", \"future keyword imports cannot be aliased\")\n\n\tassertParseImport(t, \"import kw with kw in options\",\n\t\t\"import future.keywords.in\", &Import{Path: RefTerm(VarTerm(\"future\"), StringTerm(\"keywords\"), StringTerm(\"in\"))},\n\t\tParserOptions{FutureKeywords: []string{\"in\"}})\n\tassertParseImport(t, \"import kw with all kw in options\",\n\t\t\"import future.keywords.in\", &Import{Path: RefTerm(VarTerm(\"future\"), StringTerm(\"keywords\"), StringTerm(\"in\"))},\n\t\tParserOptions{AllFutureKeywords: true})\n\n\tmod := `\n\t\tpackage p\n\t\timport future.keywords\n\t\timport future.keywords.in\n\t`\n\tparsed := Module{\n\t\tPackage: MustParseStatement(`package p`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import future.keywords\").(*Import),\n\t\t\tMustParseStatement(\"import future.keywords.in\").(*Import),\n\t\t},\n\t}\n\tassertParseModule(t, \"multiple imports, all kw in options\", mod, &parsed, ParserOptions{AllFutureKeywords: true})\n\tassertParseModule(t, \"multiple imports, single in options\", mod, &parsed, ParserOptions{FutureKeywords: []string{\"in\"}})\n}\n\nfunc TestFutureImportsExtraction(t *testing.T) {\n\t// These tests assert that \"import future...\" statements in policies cause\n\t// the proper keywords to be added to the parser's list of known keywords.\n\ttests := []struct {\n\t\tnote, imp string\n\t\texp       map[string]tokens.Token\n\t}{\n\t\t{\n\t\t\tnote: \"simple import\",\n\t\t\timp:  \"import future.keywords.in\",\n\t\t\texp:  map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t\t{\n\t\t\tnote: \"all keywords imported\",\n\t\t\timp:  \"import future.keywords\",\n\t\t\texp:  map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t\t{\n\t\t\tnote: \"all keywords + single keyword imported\",\n\t\t\timp: `\n\t\t\t\timport future.keywords\n\t\t\t\timport future.keywords.in`,\n\t\t\texp: map[string]tokens.Token{\"in\": tokens.In},\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparser := NewParser().WithFilename(\"\").WithReader(bytes.NewBufferString(tc.imp))\n\t\t\t_, _, errs := parser.Parse()\n\t\t\tif exp, act := 0, len(errs); exp != act {\n\t\t\t\tt.Fatalf(\"expected %d errors, got %d: %v\", exp, act, errs)\n\t\t\t}\n\t\t\tfor kw, exp := range tc.exp {\n\t\t\t\tact := parser.s.s.Keyword(kw)\n\t\t\t\tif act != exp {\n\t\t\t\t\tt.Errorf(\"expected keyword %q to yield token %v, got %v\", kw, exp, act)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsValidImportPath(t *testing.T) {\n\ttests := []struct {\n\t\tpath     string\n\t\texpected error\n\t}{\n\t\t{\"[1,2,3]\", fmt.Errorf(\"invalid path [1, 2, 3]: path must be ref or var\")},\n\t}\n\n\tfor _, tc := range tests {\n\t\tpath := MustParseTerm(tc.path).Value\n\t\tresult := IsValidImportPath(path)\n\t\tif tc.expected == nil && result != nil {\n\t\t\tt.Errorf(\"Unexpected error for %v: %v\", path, result)\n\t\t} else if !reflect.DeepEqual(tc.expected, result) {\n\t\t\tt.Errorf(\"For %v expected %v but got: %v\", path, tc.expected, result)\n\t\t}\n\t}\n\n}\n\nfunc TestRule(t *testing.T) {\n\n\tassertParseRule(t, \"constant\", `p = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, BooleanTerm(true)),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"set\", `p[x] { x = 42 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"x\"), IntNumberTerm(42)),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"object\", `p[x] = y { x = 42; y = \"hello\" }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\"), VarTerm(\"y\")),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"x\"), IntNumberTerm(42)),\n\t\t\tEquality.Expr(VarTerm(\"y\"), StringTerm(\"hello\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"constant composite\", `p = [{\"foo\": [1, 2, 3, 4]}] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, ArrayTerm(\n\t\t\tObjectTerm(Item(StringTerm(\"foo\"), ArrayTerm(IntNumberTerm(1), IntNumberTerm(2), IntNumberTerm(3), IntNumberTerm(4)))))),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"true\", `p = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, BooleanTerm(true)),\n\t\tBody: NewBody(\n\t\t\t&Expr{Terms: BooleanTerm(true)},\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composites in head\", `p[[{\"x\": [a, b]}]] { a = 1; b = 2 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), ArrayTerm(\n\t\t\tObjectTerm(\n\t\t\t\tItem(StringTerm(\"x\"), ArrayTerm(VarTerm(\"a\"), VarTerm(\"b\"))),\n\t\t\t),\n\t\t)),\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"a\"), IntNumberTerm(1)),\n\t\t\tEquality.Expr(VarTerm(\"b\"), IntNumberTerm(2)),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p = data.foo[x] { x = 1 }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), nil, &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"x = 1\"),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p[data.foo[x]] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"refs in head\", `p[data.foo[x]] = data.bar[y] { true }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), &Term{\n\t\t\tValue: MustParseRef(\"data.foo[x]\"),\n\t\t}, &Term{\n\t\t\tValue: MustParseRef(\"data.bar[y]\"),\n\t\t}),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"data\", `data = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"data\"), nil, MustParseTerm(\"true\")),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"input\", `input = true { true }`, &Rule{\n\t\tHead: NewHead(Var(\"input\"), nil, MustParseTerm(\"true\")),\n\t\tBody: MustParseBody(\"true\"),\n\t})\n\n\tassertParseRule(t, \"default\", `default allow = false`, &Rule{\n\t\tDefault: true,\n\t\tHead:    NewHead(Var(\"allow\"), nil, MustParseTerm(\"false\")),\n\t\tBody:    NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"default w/ comprehension\", `default widgets = [x | x = data.fooz[_]]`, &Rule{\n\t\tDefault: true,\n\t\tHead:    NewHead(Var(\"widgets\"), nil, MustParseTerm(`[x | x = data.fooz[_]]`)),\n\t\tBody:    NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"one line with braces\", `p[x] { x = data.a[_]; count(x, 3) }`, &Rule{\n\t\tHead: NewHead(Var(\"p\"), VarTerm(\"x\")),\n\t\tBody: MustParseBody(`x = data.a[_]; count(x, 3)`),\n\t})\n\n\tassertParseRule(t, \"multiple lines with braces\", `p[[x, y]] { [data.a[0]] = [{\"x\": x}]; count(x, 3); sum(x, y); y > 100 }`,\n\n\t\t&Rule{\n\t\t\tHead: NewHead(Var(\"p\"), MustParseTerm(\"[x, y]\")),\n\t\t\tBody: MustParseBody(`[data.a[0]] = [{\"x\": x}]; count(x, 3); sum(x, y); y > 100`),\n\t\t})\n\n\tfxy := &Head{\n\t\tName:  Var(\"f\"),\n\t\tArgs:  Args{VarTerm(\"x\")},\n\t\tValue: VarTerm(\"y\"),\n\t}\n\n\tassertParseRule(t, \"identity\", `f(x) = y { y = x }`, &Rule{\n\t\tHead: fxy,\n\t\tBody: NewBody(\n\t\t\tEquality.Expr(VarTerm(\"y\"), VarTerm(\"x\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composite arg\", `f([x, y]) = z { split(x, y, z) }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  Var(\"f\"),\n\t\t\tArgs:  Args{ArrayTerm(VarTerm(\"x\"), VarTerm(\"y\"))},\n\t\t\tValue: VarTerm(\"z\"),\n\t\t},\n\t\tBody: NewBody(\n\t\t\tSplit.Expr(VarTerm(\"x\"), VarTerm(\"y\"), VarTerm(\"z\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"composite result\", `f(1) = [x, y] { split(\"foo.bar\", x, y) }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  Var(\"f\"),\n\t\t\tArgs:  Args{IntNumberTerm(1)},\n\t\t\tValue: ArrayTerm(VarTerm(\"x\"), VarTerm(\"y\")),\n\t\t},\n\t\tBody: NewBody(\n\t\t\tSplit.Expr(StringTerm(\"foo.bar\"), VarTerm(\"x\"), VarTerm(\"y\")),\n\t\t),\n\t})\n\n\tassertParseRule(t, \"expr terms: key\", `p[f(x) + g(x)] { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tKey: Plus.Call(\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"expr terms: value\", `p = f(x) + g(x) { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tValue: Plus.Call(\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"expr terms: args\", `p(f(x) + g(x)) { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"p\"),\n\t\t\tArgs: Args{\n\t\t\t\tPlus.Call(\n\t\t\t\t\tCallTerm(RefTerm(VarTerm(\"f\")), VarTerm(\"x\")),\n\t\t\t\t\tCallTerm(RefTerm(VarTerm(\"g\")), VarTerm(\"x\")),\n\t\t\t\t),\n\t\t\t},\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\tassertParseRule(t, \"assignment operator\", `x := 1 { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:   Var(\"x\"),\n\t\t\tValue:  IntNumberTerm(1),\n\t\t\tAssign: true,\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\n\t// TODO: expect expressions instead?\n\tassertParseErrorContains(t, \"empty body\", `f(_) = y {}`, \"rego_parse_error: found empty body\")\n\tassertParseErrorContains(t, \"empty rule body\", \"p {}\", \"rego_parse_error: found empty body\")\n\tassertParseErrorContains(t, \"unmatched braces\", `f(x) = y { trim(x, \".\", y) `, `rego_parse_error: unexpected eof token: expected \\n or ; or }`)\n\n\t// TODO: how to highlight that assignment is incorrect here?\n\tassertParseErrorContains(t, \"no output\", `f(_) = { \"foo\" = \"bar\" }`, \"rego_parse_error: unexpected eq token: expected rule value term\")\n\n\t// TODO(tsandall): improve error checking here. This is a common mistake\n\t// and the current error message is not very good. Need to investigate if the\n\t// parser can be improved.\n\tassertParseError(t, \"dangling semicolon\", \"p { true; false; }\")\n\n\tassertParseErrorContains(t, \"default assignment\", \"default p := 1\", `default rules must use = operator (not := operator)`)\n\tassertParseErrorContains(t, \"partial assignment\", `p[x] := y { true }`, \"partial rules must use = operator (not := operator)\")\n\tassertParseErrorContains(t, \"function assignment\", `f(x) := y { true }`, \"functions must use = operator (not := operator)\")\n\tassertParseErrorContains(t, \"else assignment\", `p := y { true } else = 2 { true } `, \"else keyword cannot be used on rule declared with := operator\")\n\n\tassertParseErrorContains(t, \"default invalid rule name\", `default 0[0`, \"unexpected default keyword\")\n\tassertParseErrorContains(t, \"default invalid rule value\", `default a[0`, \"illegal default rule (must have a value)\")\n\tassertParseRule(t, \"default missing value\", `default a`, &Rule{\n\t\tDefault: true,\n\t\tHead: &Head{\n\t\t\tName:  Var(\"a\"),\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n\tassertParseRule(t, \"empty arguments\", `f() { x := 1 }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"f\",\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: MustParseBody(`x := 1`),\n\t})\n\n\tassertParseErrorContains(t, \"default invalid rule head ref\", `default a = b.c.d`, \"illegal default rule (value cannot contain ref)\")\n\tassertParseErrorContains(t, \"default invalid rule head call\", `default a = g(x)`, \"illegal default rule (value cannot contain call)\")\n\tassertParseErrorContains(t, \"default invalid rule head builtin call\", `default a = upper(\"foo\")`, \"illegal default rule (value cannot contain call)\")\n\tassertParseErrorContains(t, \"default invalid rule head call\", `default a = b`, \"illegal default rule (value cannot contain var)\")\n\n\tassertParseError(t, \"extra braces\", `{ a := 1 }`)\n\tassertParseError(t, \"invalid rule name dots\", `a.b = x { x := 1 }`)\n\tassertParseError(t, \"invalid rule name dots and call\", `a.b(x) { x := 1 }`)\n\tassertParseError(t, \"invalid rule name hyphen\", `a-b = x { x := 1 }`)\n\n\tassertParseRule(t, \"wildcard name\", `_ { x == 1 }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"$0\",\n\t\t\tValue: BooleanTerm(true),\n\t\t},\n\t\tBody: MustParseBody(`x == 1`),\n\t})\n\n\tassertParseRule(t, \"partial object array key\", `p[[a, 1, 2]] = x { a := 1; x := \"foo\" }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName:  \"p\",\n\t\t\tKey:   ArrayTerm(VarTerm(\"a\"), NumberTerm(\"1\"), NumberTerm(\"2\")),\n\t\t\tValue: VarTerm(\"x\"),\n\t\t},\n\t\tBody: MustParseBody(`a := 1; x := \"foo\"`),\n\t})\n\tassertParseError(t, \"invalid rule body no separator\", `p { a = \"foo\"bar }`)\n\tassertParseError(t, \"invalid rule body no newline\", `p { a b c }`)\n}\n\nfunc TestRuleElseKeyword(t *testing.T) {\n\tmod := `package test\n\n\tp {\n\t\t\"p0\"\n\t}\n\n\tp {\n\t\t\"p1\"\n\t} else {\n\t\t\"p1_e1\"\n\t} else = [null] {\n\t\t\"p1_e2\"\n\t} else = x {\n\t\tx = \"p1_e3\"\n\t}\n\n\tp {\n\t\t\"p2\"\n\t}\n\n\tf(x) {\n\t\tx < 100\n\t} else = false {\n\t\tx > 200\n\t} else {\n\t\tx != 150\n\t}\n\n\t_ {\n\t\tx > 0\n\t} else {\n\t    x == -1\n\t} else {\n\t\tx > -100\n\t}\n\n\tnobody = 1 {\n\t\tfalse\n\t} else = 7\n\n\tnobody_f(x) = 1 {\n\t\tfalse\n\t} else = 7\n\t`\n\n\tparsed, err := ParseModule(\"\", mod)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\tname := Var(\"p\")\n\ttr := BooleanTerm(true)\n\thead := &Head{Name: name, Value: tr}\n\n\texpected := &Module{\n\t\tPackage: MustParsePackage(`package test`),\n\t\tRules: []*Rule{\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p0\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p1\"`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: head,\n\t\t\t\t\tBody: MustParseBody(`\"p1_e1\"`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"p\"),\n\t\t\t\t\t\t\tValue: ArrayTerm(NullTerm()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`\"p1_e2\"`),\n\t\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\t\tName:  name,\n\t\t\t\t\t\t\t\tValue: VarTerm(\"x\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBody: MustParseBody(`x = \"p1_e3\"`),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p2\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(`x < 100`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\tValue: BooleanTerm(false),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(`x > 200`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"f\"),\n\t\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`x != 150`),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(`x > 0`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(`x == -1`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"$0\"),\n\t\t\t\t\t\t\tValue: BooleanTerm(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`x > -100`),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"nobody\"),\n\t\t\t\t\tValue: IntNumberTerm(1),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(\"false\"),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"nobody\"),\n\t\t\t\t\t\tValue: IntNumberTerm(7),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(\"true\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: &Head{\n\t\t\t\t\tName:  Var(\"nobody_f\"),\n\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\tValue: IntNumberTerm(1),\n\t\t\t\t},\n\t\t\t\tBody: MustParseBody(\"false\"),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\tName:  Var(\"nobody_f\"),\n\t\t\t\t\t\tArgs:  Args{VarTerm(\"x\")},\n\t\t\t\t\t\tValue: IntNumberTerm(7),\n\t\t\t\t\t},\n\t\t\t\t\tBody: MustParseBody(\"true\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif parsed.Compare(expected) != 0 {\n\t\tt.Fatalf(\"Expected:\\n%v\\n\\nGot:\\n%v\", expected, parsed)\n\t}\n\n\tnotExpected := &Module{\n\t\tPackage: MustParsePackage(`package test`),\n\t\tRules: []*Rule{\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p0\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p1\"`),\n\t\t\t\tElse: &Rule{\n\t\t\t\t\tHead: head,\n\t\t\t\t\tBody: MustParseBody(`\"p1_e1\"`),\n\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\tName:  Var(\"p\"),\n\t\t\t\t\t\t\tValue: ArrayTerm(NullTerm()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tBody: MustParseBody(`\"p1_e2\"`),\n\t\t\t\t\t\tElse: &Rule{\n\t\t\t\t\t\t\tHead: &Head{\n\t\t\t\t\t\t\t\tName:  name,\n\t\t\t\t\t\t\t\tValue: VarTerm(\"x\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBody: MustParseBody(`x = \"p1_e4\"`),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tHead: head,\n\t\t\t\tBody: MustParseBody(`\"p2\"`),\n\t\t\t},\n\t\t},\n\t}\n\n\tif parsed.Compare(notExpected) != -1 {\n\t\tt.Fatalf(\"Expected not equal:\\n%v\\n\\nGot:\\n%v\", parsed, notExpected)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp[1] { false } else { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"else keyword cannot be used on partial rules\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp { false } { false } else { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"unexpected else keyword\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n\t_, err = ParseModule(\"\", `\n\tpackage test\n\tp { false } else { false } { true }\n\t`)\n\n\tif err == nil || !strings.Contains(err.Error(), \"expected else keyword\") {\n\t\tt.Fatalf(\"Expected parse error but got: %v\", err)\n\t}\n\n}\n\nfunc TestMultipleEnclosedBodies(t *testing.T) {\n\n\tresult, err := ParseModule(\"\", `package ex\n\np[x] = y {\n\tx = \"a\"\n\ty = 1\n} {\n\tx = \"b\"\n\ty = 2\n}\n\nq = 1\n\nf(x) {\n\tx < 10\n} {\n\tx > 1000\n}\n`,\n\t)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\texpected := MustParseModule(`package ex\n\np[x] = y { x = \"a\"; y = 1 }\np[x] = y { x = \"b\"; y = 2 }\nq = 1 { true }\nf(x) { x < 10 }\nf(x) { x > 1000 }`,\n\t)\n\n\tif !expected.Equal(result) {\n\t\tt.Fatal(\"Expected modules to be equal but got:\\n\\n\", result, \"\\n\\nExpected:\\n\\n\", expected)\n\t}\n\n}\n\nfunc TestEmptyModule(t *testing.T) {\n\tr, err := ParseModule(\"\", \"    \")\n\tif err == nil {\n\t\tt.Error(\"Expected error for empty module\")\n\t\treturn\n\t}\n\tif r != nil {\n\t\tt.Errorf(\"Expected nil for empty module: %v\", r)\n\t}\n}\n\nfunc TestComments(t *testing.T) {\n\n\ttestModule := `package a.b.c\n\n    import input.e.f as g  # end of line\n    import input.h\n\n    # by itself\n\n    p[x] = y { y = \"foo\";\n        # inside a rule\n        x = \"bar\";\n        x != y;\n        q[x]\n\t}\n\n    import input.xyz.abc\n\n    q # interrupting\n\n\t[a] # the head of a rule\n\n\t{ m = [1,2,\n    3, ];\n    a = m[i]\n\n\t}\n\n\tr[x] { x = [ a | # inside comprehension\n\t\t\t\t\t  a = z[i]\n\t                  b[i].a = a ]\n\n\t\ty = { a | # inside set comprehension\n\t\t\t\ta = z[i]\n\t\t\tb[i].a = a}\n\n\t\tz = {a: i | # inside object comprehension\n\t\t\t\ta = z[i]\n\t\t\tb[i].a = a}\n\t\t\t\t\t  }`\n\n\tassertParseModule(t, \"module comments\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package a.b.c`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import input.e.f as g\").(*Import),\n\t\t\tMustParseStatement(\"import input.h\").(*Import),\n\t\t\tMustParseStatement(\"import input.xyz.abc\").(*Import),\n\t\t},\n\t\tRules: []*Rule{\n\t\t\tMustParseStatement(`p[x] = y { y = \"foo\"; x = \"bar\"; x != y; q[x] }`).(*Rule),\n\t\t\tMustParseStatement(`q[a] { m = [1, 2, 3]; a = m[i] }`).(*Rule),\n\t\t\tMustParseStatement(`r[x] { x = [a | a = z[i]; b[i].a = a]; y = {a |  a = z[i]; b[i].a = a}; z = {a: i | a = z[i]; b[i].a = a} }`).(*Rule),\n\t\t},\n\t})\n\n\tmodule, err := ParseModule(\"test.rego\", testModule)\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\n\texp := []struct {\n\t\ttext string\n\t\trow  int\n\t\tcol  int\n\t}{\n\t\t{text: \"end of line\", row: 3, col: 28},\n\t\t{text: \"by itself\", row: 6, col: 5},\n\t\t{text: \"inside a rule\", row: 9, col: 9},\n\t\t{text: \"interrupting\", row: 17, col: 7},\n\t\t{text: \"the head of a rule\", row: 19, col: 6},\n\t\t{text: \"inside comprehension\", row: 27, col: 19},\n\t\t{text: \"inside set comprehension\", row: 31, col: 13},\n\t\t{text: \"inside object comprehension\", row: 35, col: 15},\n\t}\n\n\tif len(module.Comments) != len(exp) {\n\t\tt.Fatalf(\"Expected %v comments but got %v\", len(exp), len(module.Comments))\n\t}\n\n\tfor i := range exp {\n\n\t\texpc := &Comment{\n\t\t\tText: []byte(\" \" + exp[i].text),\n\t\t\tLocation: &Location{\n\t\t\t\tFile: \"test.rego\",\n\t\t\t\tText: []byte(\"# \" + exp[i].text),\n\t\t\t\tRow:  exp[i].row,\n\t\t\t\tCol:  exp[i].col,\n\t\t\t},\n\t\t}\n\n\t\tif !expc.Equal(module.Comments[i]) {\n\t\t\tcomment := module.Comments[i]\n\t\t\tfmt.Printf(\"comment: %v %v %v %v\\n\", comment.Location.File, comment.Location.Text, comment.Location.Col, comment.Location.Row)\n\t\t\tfmt.Printf(\"expcomm: %v %v %v %v\\n\", expc.Location.File, expc.Location.Text, expc.Location.Col, expc.Location.Row)\n\t\t\tt.Errorf(\"Expected %q but got: %q (want: %d:%d, got: %d:%d)\", expc, comment, exp[i].row, exp[i].col, comment.Location.Row, comment.Location.Col)\n\t\t}\n\t}\n}\n\nfunc TestCommentsWhitespace(t *testing.T) {\n\tcases := []struct {\n\t\tnote     string\n\t\tmodule   string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tnote:     \"trailing spaces\",\n\t\t\tmodule:   \"# a comment    \\t   \\n\",\n\t\t\texpected: []string{\" a comment    \\t   \"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"trailing carriage return\",\n\t\t\tmodule:   \"# a comment\\r\\n\",\n\t\t\texpected: []string{\" a comment\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"trailing carriage return double newline\",\n\t\t\tmodule:   \"# a comment\\r\\n\\n\",\n\t\t\texpected: []string{\" a comment\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"double trailing carriage return newline\",\n\t\t\tmodule:   \"#\\r\\r\\n\",\n\t\t\texpected: []string{\"\\r\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"double trailing carriage return\",\n\t\t\tmodule:   \"#\\r\\r\",\n\t\t\texpected: []string{\"\\r\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"carriage return\",\n\t\t\tmodule:   \"#\\r\",\n\t\t\texpected: []string{\"\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"carriage return in comment\",\n\t\t\tmodule:   \"# abc\\rdef\\r\\n\",\n\t\t\texpected: []string{\" abc\\rdef\"},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\t_, comments, err := ParseStatements(\"\", tc.module)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected parse error: %s\", err)\n\t\t\t}\n\n\t\t\tfor i, exp := range tc.expected {\n\t\t\t\tactual := string(comments[i].Text)\n\t\t\t\tif exp != actual {\n\t\t\t\t\tt.Errorf(\"Expected comment text (len %d):\\n\\n\\t%q\\n\\nbut got (len %d):\\n\\n\\t%q\\n\\n\", len(exp), exp, len(actual), actual)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExample(t *testing.T) {\n\tassertParseModule(t, \"example module\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package opa.examples`).(*Package),\n\t\tImports: []*Import{\n\t\t\tMustParseStatement(\"import data.servers\").(*Import),\n\t\t\tMustParseStatement(\"import data.networks\").(*Import),\n\t\t\tMustParseStatement(\"import data.ports\").(*Import),\n\t\t},\n\t\tRules: []*Rule{\n\t\t\tMustParseStatement(`violations[server] { server = servers[i]; server.protocols[j] = \"http\"; public_servers[server] }`).(*Rule),\n\t\t\tMustParseStatement(`public_servers[server] { server = servers[i]; server.ports[j] = ports[k].id; ports[k].networks[l] = networks[m].id; networks[m].public = true }`).(*Rule),\n\t\t},\n\t})\n}\n\nfunc TestModuleParseErrors(t *testing.T) {\n\tinput := `\n\tx = 1\t\t\t# expect package\n\tpackage a  \t\t# unexpected package\n\t1 = 2\t\t\t# non-var head\n\t1 != 2\t\t\t# non-equality expr\n\tx = y; x = 1    # multiple exprs\n\t`\n\n\tmod, err := ParseModule(\"test.rego\", input)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error but got: %v\", mod)\n\t}\n\n\terrs, ok := err.(Errors)\n\tif !ok {\n\t\tpanic(\"unexpected error value\")\n\t}\n\n\tif len(errs) != 5 {\n\t\tt.Fatalf(\"Expected exactly 5 errors but got: %v\", err)\n\t}\n}\n\nfunc TestLocation(t *testing.T) {\n\tmod, err := ParseModule(\"test\", testModule)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error while parsing test module: %v\", err)\n\t\treturn\n\t}\n\texpr := mod.Rules[0].Body[0]\n\tif expr.Location.Col != 5 {\n\t\tt.Errorf(\"Expected column of %v to be 5 but got: %v\", expr, expr.Location.Col)\n\t}\n\tif expr.Location.Row != 15 {\n\t\tt.Errorf(\"Expected row of %v to be 8 but got: %v\", expr, expr.Location.Row)\n\t}\n\tif expr.Location.File != \"test\" {\n\t\tt.Errorf(\"Expected file of %v to be test but got: %v\", expr, expr.Location.File)\n\t}\n}\n\nfunc TestRuleFromBody(t *testing.T) {\n\ttestModule := `package a.b.c\n\npi = 3.14159\np[x] { x = 1 }\ngreeting = \"hello\"\ncores = [{0: 1}, {1: 2}]\nwrapper = cores[0][1]\npi = [3, 1, 4, x, y, z]\nfoo[\"bar\"] = \"buz\"\nfoo[\"9\"] = \"10\"\nfoo.buz = \"bar\"\nbar[1]\nbar[[{\"foo\":\"baz\"}]]\nbar.qux\ninput = 1\ndata = 2\nf(1) = 2\nf(1)\nd1 := 1234\n`\n\n\tassertParseModule(t, \"rules from bodies\", testModule, &Module{\n\t\tPackage: MustParseStatement(`package a.b.c`).(*Package),\n\t\tRules: []*Rule{\n\t\t\tMustParseRule(`pi = 3.14159 { true }`),\n\t\t\tMustParseRule(`p[x] { x = 1 }`),\n\t\t\tMustParseRule(`greeting = \"hello\" { true }`),\n\t\t\tMustParseRule(`cores = [{0: 1}, {1: 2}] { true }`),\n\t\t\tMustParseRule(`wrapper = cores[0][1] { true }`),\n\t\t\tMustParseRule(`pi = [3, 1, 4, x, y, z] { true }`),\n\t\t\tMustParseRule(`foo[\"bar\"] = \"buz\" { true }`),\n\t\t\tMustParseRule(`foo[\"9\"] = \"10\" { true }`),\n\t\t\tMustParseRule(`foo[\"buz\"] = \"bar\" { true }`),\n\t\t\tMustParseRule(`bar[1] { true }`),\n\t\t\tMustParseRule(`bar[[{\"foo\":\"baz\"}]] { true }`),\n\t\t\tMustParseRule(`bar[\"qux\"] { true }`),\n\t\t\tMustParseRule(`input = 1 { true }`),\n\t\t\tMustParseRule(`data = 2 { true }`),\n\t\t\tMustParseRule(`f(1) = 2 { true }`),\n\t\t\tMustParseRule(`f(1) = true { true }`),\n\t\t\tMustParseRule(\"d1 := 1234 { true }\"),\n\t\t},\n\t})\n\n\t// Verify the rule and rule and rule head col/loc values\n\tmodule, err := ParseModule(\"test.rego\", testModule)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i := range module.Rules {\n\t\tcol := module.Rules[i].Location.Col\n\t\tif col != 1 {\n\t\t\tt.Fatalf(\"expected rule %v column to be 1 but got %v\", module.Rules[i].Head.Name, col)\n\t\t}\n\t\trow := module.Rules[i].Location.Row\n\t\tif row != 3+i { // 'pi' rule stats on row 3\n\t\t\tt.Fatalf(\"expected rule %v row to be %v but got %v\", module.Rules[i].Head.Name, 3+i, row)\n\t\t}\n\t\tcol = module.Rules[i].Head.Location.Col\n\t\tif col != 1 {\n\t\t\tt.Fatalf(\"expected rule head %v column to be 1 but got %v\", module.Rules[i].Head.Name, col)\n\t\t}\n\t\trow = module.Rules[i].Head.Location.Row\n\t\tif row != 3+i { // 'pi' rule stats on row 3\n\t\t\tt.Fatalf(\"expected rule head %v row to be %v but got %v\", module.Rules[i].Head.Name, 3+i, row)\n\t\t}\n\t}\n\n\tmockModule := `package ex\n\ninput = {\"foo\": 1}\ndata = {\"bar\": 2}`\n\n\tassertParseModule(t, \"rule name: input/data\", mockModule, &Module{\n\t\tPackage: MustParsePackage(`package ex`),\n\t\tRules: []*Rule{\n\t\t\tMustParseRule(`input = {\"foo\": 1} { true }`),\n\t\t\tMustParseRule(`data = {\"bar\": 2} { true }`),\n\t\t},\n\t})\n\n\tmultipleExprs := `\n    package a.b.c\n\n    pi = 3.14159; pi > 3\n    `\n\n\tnonEquality := `\n    package a.b.c\n\n    pi > 3\n    `\n\n\tnonVarName := `\n    package a.b.c\n\n    \"pi\" = 3\n    `\n\n\twithExpr := `\n\tpackage a.b.c\n\n\tfoo = input with input as 1\n\t`\n\n\tbadRefLen1 := `\n\tpackage a.b.c\n\n\tp[\"x\"].y = 1`\n\n\tbadRefLen2 := `\n\tpackage a.b.c\n\n\tp[\"x\"].y`\n\n\tnegated := `\n\tpackage a.b.c\n\n\tnot p = 1`\n\n\tnonRefTerm := `\n\tpackage a.b.c\n\n\tp`\n\n\tzeroArgs := `\n\tpackage a.b.c\n\n\tp()`\n\n\tassignToTerm := `\n\tpackage a.b.c\n\n\t\"foo\" := 1`\n\n\tsomeDecl := `\n\tpackage a\n\n\tsome x`\n\n\tarrayTerm := `\n\tpackage a\n\t[][0]\n\t`\n\n\tcallWithRuleKeyPartialSet := `\n\tpackage a\n\tf(x)[x] { true }`\n\n\tcallWithRuleKeyPartialObject := `\n\tpackage a\n\tf(x)[x] = x { true }`\n\n\tassignNoOperands := `\n\tpackage a\n\tassign()`\n\n\tassignOneOperand := `\n\tpackage a\n\tassign(x)`\n\n\teqNoOperands := `\n\tpackage a\n\teq()`\n\n\teqOneOperand := `\n\tpackage a\n\teq(x)`\n\n\tassertParseModuleError(t, \"multiple expressions\", multipleExprs)\n\tassertParseModuleError(t, \"non-equality\", nonEquality)\n\tassertParseModuleError(t, \"non-var name\", nonVarName)\n\tassertParseModuleError(t, \"with expr\", withExpr)\n\tassertParseModuleError(t, \"bad ref (too long)\", badRefLen1)\n\tassertParseModuleError(t, \"bad ref (too long)\", badRefLen2)\n\tassertParseModuleError(t, \"negated\", negated)\n\tassertParseModuleError(t, \"non ref term\", nonRefTerm)\n\tassertParseModuleError(t, \"zero args\", zeroArgs)\n\tassertParseModuleError(t, \"assign to term\", assignToTerm)\n\tassertParseModuleError(t, \"some decl\", someDecl)\n\tassertParseModuleError(t, \"array term\", arrayTerm)\n\tassertParseModuleError(t, \"call in ref partial set\", \"package test\\nf().x {}\")\n\tassertParseModuleError(t, \"call in ref partial object\", \"package test\\nf().x = y {}\")\n\tassertParseModuleError(t, \"number in ref\", \"package a\\n12[3]()=4\")\n\tassertParseModuleError(t, \"rule with args and key\", callWithRuleKeyPartialObject)\n\tassertParseModuleError(t, \"rule with args and key\", callWithRuleKeyPartialSet)\n\tassertParseModuleError(t, \"assign without operands\", assignNoOperands)\n\tassertParseModuleError(t, \"assign with only one operand\", assignOneOperand)\n\tassertParseModuleError(t, \"eq without operands\", eqNoOperands)\n\tassertParseModuleError(t, \"eq with only one operand\", eqOneOperand)\n\n\tif _, err := ParseRuleFromExpr(&Module{}, &Expr{\n\t\tTerms: struct{}{},\n\t}); err == nil {\n\t\tt.Fatal(\"expected error for unknown expression term type\")\n\t}\n}\n\nfunc TestWildcards(t *testing.T) {\n\n\tassertParseOneTerm(t, \"ref\", \"a.b[_].c[_]\", RefTerm(\n\t\tVarTerm(\"a\"),\n\t\tStringTerm(\"b\"),\n\t\tVarTerm(\"$0\"),\n\t\tStringTerm(\"c\"),\n\t\tVarTerm(\"$1\"),\n\t))\n\n\tassertParseOneTerm(t, \"nested\", `[{\"a\": a[_]}, _, {\"b\": _}]`, ArrayTerm(\n\t\tObjectTerm(\n\t\t\tItem(StringTerm(\"a\"), RefTerm(VarTerm(\"a\"), VarTerm(\"$0\"))),\n\t\t),\n\t\tVarTerm(\"$1\"),\n\t\tObjectTerm(\n\t\t\tItem(StringTerm(\"b\"), VarTerm(\"$2\")),\n\t\t),\n\t))\n\n\tassertParseOneExpr(t, \"expr\", `_ = [a[_]]`, Equality.Expr(\n\t\tVarTerm(\"$0\"),\n\t\tArrayTerm(\n\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"$1\")),\n\t\t)))\n\n\tassertParseOneExpr(t, \"comprehension\", `_ = [x | a = a[_]]`, Equality.Expr(\n\t\tVarTerm(\"$0\"),\n\t\tArrayComprehensionTerm(\n\t\t\tVarTerm(\"x\"),\n\t\t\tNewBody(\n\t\t\t\tEquality.Expr(\n\t\t\t\t\tVarTerm(\"a\"),\n\t\t\t\t\tRefTerm(VarTerm(\"a\"), VarTerm(\"$1\")),\n\t\t\t\t),\n\t\t\t),\n\t\t)))\n\n\tassertParseRule(t, \"functions\", `f(_) = y { true }`, &Rule{\n\t\tHead: &Head{\n\t\t\tName: Var(\"f\"),\n\t\t\tArgs: Args{\n\t\t\t\tVarTerm(\"$0\"),\n\t\t\t},\n\t\t\tValue: VarTerm(\"y\"),\n\t\t},\n\t\tBody: NewBody(NewExpr(BooleanTerm(true))),\n\t})\n}\n\nfunc TestRuleModulePtr(t *testing.T) {\n\tmod := `package test\n\n\tp { true }\n\tp { true }\n\tq { true }\n\tr = 1\n\tdefault s = 2\n\t`\n\n\tparsed, err := ParseModule(\"\", mod)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t}\n\n\tfor _, rule := range parsed.Rules {\n\t\tif rule.Module != parsed {\n\t\t\tt.Fatalf(\"Expected module ptr to be %p but got %p\", parsed, rule.Module)\n\t\t}\n\t}\n}\n\nfunc TestNoMatchError(t *testing.T) {\n\tmod := `package test\n\n\tp { true;\n\t\t 1 != 0; # <-- parse error: no match\n\t}`\n\n\t_, err := ParseModule(\"foo.rego\", mod)\n\n\texpected := \"1 error occurred: foo.rego:5: rego_parse_error: unexpected } token\"\n\n\tif !strings.HasPrefix(err.Error(), expected) {\n\t\tt.Fatalf(\"Bad parse error, expected %v but got: %v\", expected, err)\n\t}\n\n\tmod = `package test\n\n\tp { true // <-- parse error: no match`\n\n\t_, err = ParseModule(\"foo.rego\", mod)\n\n\tloc := NewLocation([]byte{'/'}, \"foo.rego\", 3, 12)\n\n\tif !loc.Equal(err.(Errors)[0].Location) {\n\t\tt.Fatalf(\"Expected %v but got: %v\", loc, err)\n\t}\n}\n\nfunc TestParseErrorDetails(t *testing.T) {\n\n\ttests := []struct {\n\t\tnote  string\n\t\texp   *ParserErrorDetail\n\t\terr   string\n\t\tinput string\n\t}{\n\t\t{\n\t\t\tnote: \"no match: bad rule name\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \".\",\n\t\t\t\tIdx:  0,\n\t\t\t},\n\t\t\tinput: `\npackage test\n.`,\n\t\t},\n\t\t{\n\t\t\tnote: \"no match: bad termination for comprehension\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p = [true | true}\",\n\t\t\t\tIdx:  16,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = [true | true}`},\n\t\t{\n\t\t\tnote: \"no match: non-terminated comprehension\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p = [true | true\",\n\t\t\t\tIdx:  15,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = [true | true`},\n\t\t{\n\t\t\tnote: \"no match: expected expression\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p { true; }\",\n\t\t\t\tIdx:  10,\n\t\t\t},\n\t\t\tinput: `\npackage test\np { true; }`},\n\t\t{\n\t\t\tnote: \"empty body\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"p { }\",\n\t\t\t\tIdx:  4,\n\t\t\t},\n\t\t\tinput: `\npackage test\np { }`},\n\t\t{\n\t\t\tnote: \"non-terminated string\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: `p = \"foo`,\n\t\t\t\tIdx:  4,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = \"foo`},\n\t\t{\n\t\t\tnote: \"rule with error begins with one tab\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\tas\",\n\t\t\t\tIdx:  1,\n\t\t\t},\n\t\t\tinput: `\npackage test\n\tas`,\n\t\t\terr: `1 error occurred: test.rego:3: rego_parse_error: unexpected as keyword\n\tas\n\t^`},\n\t\t{\n\t\t\tnote: \"rule term with error begins with two tabs\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\t\\tas\",\n\t\t\t\tIdx:  2,\n\t\t\t},\n\t\t\tinput: `\npackage test\np = true {\n\t\tas\n}`,\n\t\t\terr: `1 error occurred: test.rego:4: rego_parse_error: unexpected as keyword\n\tas\n\t^`},\n\t\t{\n\t\t\tnote: \"input is tab and space tokens only\",\n\t\t\texp: &ParserErrorDetail{\n\t\t\t\tLine: \"\\t\\v\\f \",\n\t\t\t\tIdx:  0,\n\t\t\t},\n\t\t\tinput: \"\\t\\v\\f \",\n\t\t\t// NOTE(sr): With the unprintable control characters, the output is pretty\n\t\t\t// useless. But it's also quite an edge case.\n\t\t\terr: \"1 error occurred: test.rego:1: rego_parse_error: illegal token\\n\\t\\v\\f \\n\\t^\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\t_, err := ParseModule(\"test.rego\", tc.input)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Expected error\")\n\t\t\t}\n\t\t\tdetail := err.(Errors)[0].Details\n\t\t\tif !reflect.DeepEqual(detail, tc.exp) {\n\t\t\t\tt.Errorf(\"Expected %v but got: %v\", tc.exp, detail)\n\t\t\t}\n\t\t\tif tc.err != \"\" && tc.err != err.Error() {\n\t\t\t\tt.Fatalf(\"Expected error string %q but got: %q\", tc.err, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNamespacedBuiltins(t *testing.T) {\n\n\ttests := []struct {\n\t\texpr     string\n\t\texpected *Term\n\t\twantErr  bool\n\t}{\n\t\t{`foo.bar.baz(1, 2)`, MustParseTerm(\"foo.bar.baz\"), false},\n\t\t{`foo.(1,2)`, nil, true},\n\t\t{`foo.#.bar(1,2)`, nil, true},\n\t}\n\n\tfor _, tc := range tests {\n\t\texpr, err := ParseExpr(tc.expr)\n\t\tif !tc.wantErr {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected parse error: %v\", err)\n\t\t\t}\n\t\t\tterms, ok := expr.Terms.([]*Term)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Expected terms not: %T\", expr.Terms)\n\t\t\t}\n\t\t\tif !terms[0].Equal(tc.expected) {\n\t\t\t\tt.Fatalf(\"Expected builtin-name to equal %v but got: %v\", tc.expected, terms)\n\t\t\t}\n\t\t} else if err == nil {\n\t\t\tt.Fatalf(\"Expected error from %v but got: %v\", tc.expr, expr)\n\t\t}\n\t}\n}\n\nfunc TestRuleHeadLocation(t *testing.T) {\n\n\tconst input = `package pkg\n\np[x] {\n\tx = \"hi\"\n} {\n\tx = \"bye\"\n}\n\nf(x) {\n\tfalse\n} else = false {\n\ttrue\n}\n`\n\n\tmodule := MustParseModule(input)\n\n\tfor _, tc := range []struct {\n\t\tnote         string\n\t\tlocation     *Location\n\t\texpectedRow  int\n\t\texpectedText string\n\t}{\n\t\t{\n\t\t\tnote:        \"partial rule\",\n\t\t\tlocation:    module.Rules[0].Location,\n\t\t\texpectedRow: 3,\n\t\t\texpectedText: `\np[x] {\n\tx = \"hi\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"partial rule head\",\n\t\t\tlocation:     module.Rules[0].Head.Location,\n\t\t\texpectedRow:  3,\n\t\t\texpectedText: `p[x]`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"partial rule head key\",\n\t\t\tlocation:     module.Rules[0].Head.Key.Location,\n\t\t\texpectedRow:  3,\n\t\t\texpectedText: `x`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule\",\n\t\t\tlocation:    module.Rules[1].Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule head\",\n\t\t\tlocation:    module.Rules[1].Head.Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"chained rule head key\",\n\t\t\tlocation:    module.Rules[1].Head.Key.Location,\n\t\t\texpectedRow: 5,\n\t\t\texpectedText: `\n{\n\tx = \"bye\"\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"rule with args\",\n\t\t\tlocation:    module.Rules[2].Location,\n\t\t\texpectedRow: 9,\n\t\t\texpectedText: `\nf(x) {\n\tfalse\n} else = false {\n\ttrue\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"rule with args head\",\n\t\t\tlocation:     module.Rules[2].Head.Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `f(x)`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"rule with args head arg 0\",\n\t\t\tlocation:     module.Rules[2].Head.Args[0].Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `x`,\n\t\t},\n\t\t{\n\t\t\tnote:        \"else with args\",\n\t\t\tlocation:    module.Rules[2].Else.Location,\n\t\t\texpectedRow: 11,\n\t\t\texpectedText: `\nelse = false {\n\ttrue\n}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"else with args head\",\n\t\t\tlocation:     module.Rules[2].Else.Head.Location,\n\t\t\texpectedRow:  11,\n\t\t\texpectedText: `else = false`,\n\t\t},\n\t\t{\n\t\t\tnote:         \"else with args head arg 0\",\n\t\t\tlocation:     module.Rules[2].Else.Head.Args[0].Location,\n\t\t\texpectedRow:  9,\n\t\t\texpectedText: `x`,\n\t\t},\n\t} {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tif tc.location.Row != tc.expectedRow {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", tc.expectedRow, tc.location.Row)\n\t\t\t}\n\t\t\texp := strings.TrimSpace(tc.expectedText)\n\t\t\tif string(tc.location.Text) != exp {\n\t\t\t\tt.Errorf(\"Expected text:\\n%s\\n\\ngot:\\n%s\\n\\n\", exp, tc.location.Text)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParserText(t *testing.T) {\n\n\ttests := []struct {\n\t\tnote  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tnote:  \"relational term\",\n\t\t\tinput: `(1 == (2 > 3))`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - empty\",\n\t\t\tinput: `[ ]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - one element\",\n\t\t\tinput: `[ 1 ]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"array - multiple elements\",\n\t\t\tinput: `[1 , 2 , 3]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - empty\",\n\t\t\tinput: `{ }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - one element\",\n\t\t\tinput: `{ \"foo\": 1 }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"object - multiple elements\",\n\t\t\tinput: `{\"foo\": 1, \"bar\": 2}`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"set - one element\",\n\t\t\tinput: `{ 1 }`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"set - multiple elements\",\n\t\t\tinput: `{1 , 2 , 3}`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"idents\",\n\t\t\tinput: \"foo\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"ref\",\n\t\t\tinput: `data.foo[x].bar`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"call\",\n\t\t\tinput: `data.foo.bar(x)`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"ref and call\",\n\t\t\tinput: `data.foo[1](x).bar(y)[z]`,\n\t\t},\n\t\t{\n\t\t\tnote:  \"infix\",\n\t\t\tinput: \"input = 1\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"negated\",\n\t\t\tinput: \"not x = 1\",\n\t\t},\n\t\t{\n\t\t\tnote:  \"expr with statements\",\n\t\t\tinput: \"x = 1 with input as 2 with input as 3\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tfor _, suffix := range []string{\"\", \"\\t\\n \"} {\n\t\t\t\tinput := tc.input + suffix\n\n\t\t\t\tstmts, _, err := ParseStatements(\"test.rego\", input)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif len(stmts) != 1 {\n\t\t\t\t\tt.Fatal(\"expected exactly one statement but got:\", stmts)\n\t\t\t\t}\n\n\t\t\t\tresult := string(stmts[0].Loc().Text)\n\n\t\t\t\tif result != tc.input {\n\t\t\t\t\tt.Fatalf(\"expected %q but got: %q\", tc.input, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleText(t *testing.T) {\n\tinput := ` package test\n\nr[x] = y {\n\tx = input.a\n\tx = \"foo\"\n} {\n\tx = input.b\n\tx = \"bar\"\n} {\n\tx = input.c\n\tx = \"baz\"\n}\n\nr[x] = y {\n\tx = input.d\n\tx = \"qux\"\n}\n`\n\n\tmod := MustParseModule(input)\n\trules := mod.Rules\n\n\tif len(rules) != 4 {\n\t\tt.Fatalf(\"Expected 4 rules, got %d\", len(rules))\n\t}\n\n\texpectedRuleText := []string{\n\t\t`\nr[x] = y {\n\tx = input.a\n\tx = \"foo\"\n}\n\t\t`,\n\t\t`\n{\n\tx = input.b\n\tx = \"bar\"\n}\n\t\t`,\n\t\t`\n{\n\tx = input.c\n\tx = \"baz\"\n}\n\t\t`,\n\t\t`\nr[x] = y {\n\tx = input.d\n\tx = \"qux\"\n}\n\t\t`,\n\t}\n\n\tassertLocationText(t, strings.TrimSpace(expectedRuleText[0]), rules[0].Location)\n\tassertLocationText(t, \"r[x] = y\", rules[0].Head.Location)\n\tassertLocationText(t, \"y\", rules[0].Head.Value.Location)\n\n\t// Chained rules recursively set text on heads to be the full rule\n\tfor i := 1; i < len(expectedRuleText)-1; i++ {\n\t\ttext := strings.TrimSpace(expectedRuleText[i])\n\t\tassertLocationText(t, text, rules[i].Location)\n\t\tassertLocationText(t, text, rules[i].Head.Location)\n\t\tassertLocationText(t, text, rules[i].Head.Value.Location)\n\t}\n\n\tassertLocationText(t, strings.TrimSpace(expectedRuleText[3]), rules[3].Location)\n\tassertLocationText(t, \"r[x] = y\", rules[3].Head.Location)\n\tassertLocationText(t, \"y\", rules[3].Head.Value.Location)\n}\n\nfunc TestRuleElseText(t *testing.T) {\n\tinput := `\nr1 = x {\n\ta == \"foo\"\n} else = y {\n\tb == \"bar\"\n}\n\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n`\n\n\trule := MustParseRule(input)\n\tassertLocationText(t, strings.TrimSpace(input), rule.Location)\n\tassertLocationText(t, \"r1 = x\", rule.Head.Location)\n\tassertLocationText(t, \"x\", rule.Head.Value.Location)\n\n\tcurElse := rule.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse = y {\n\tb == \"bar\"\n}\n\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, \"else = y\", curElse.Head.Location)\n\tassertLocationText(t, \"y\", curElse.Head.Value.Location)\n\n\tcurElse = curElse.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse {\n\tc == \"baz\"\n}\n\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, \"else\", curElse.Head.Location)\n\tif curElse.Head.Value.Location != nil {\n\t\tt.Errorf(\"Expected a nil location\")\n\t}\n\n\tcurElse = curElse.Else\n\tif curElse == nil {\n\t\tt.Fatalf(\"Expected an else block, got nil\")\n\t}\n\tassertLocationText(t, strings.TrimSpace(`\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n} {\n\ttrue\n}\n\t`), curElse.Location)\n\tassertLocationText(t, strings.TrimSpace(`\nelse = {\n\t\"k1\": 1,\n\t\"k2\": 2\n}\n\t`), curElse.Head.Location)\n\tassertLocationText(t, strings.TrimSpace(`\n{\n\t\"k1\": 1,\n\t\"k2\": 2\n}\n\t`), curElse.Head.Value.Location)\n}\n\nfunc TestAnnotations(t *testing.T) {\n\n\tdataServers := MustParseRef(\"data.servers\")\n\tdataNetworks := MustParseRef(\"data.networks\")\n\tdataPorts := MustParseRef(\"data.ports\")\n\n\tschemaServers := MustParseRef(\"schema.servers\")\n\tschemaNetworks := MustParseRef(\"schema.networks\")\n\tschemaPorts := MustParseRef(\"schema.ports\")\n\n\tstringSchemaAsMap := map[string]interface{}{\n\t\t\"type\": \"string\",\n\t}\n\tvar stringSchema interface{} = stringSchemaAsMap\n\n\ttests := []struct {\n\t\tnote           string\n\t\tmodule         string\n\t\texpNumComments int\n\t\texpAnnotations []*Annotations\n\t\texpError       string\n\t}{\n\t\t{\n\t\t\tnote: \"Single valid annotation\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple annotations on multiple lines\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 6,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Comment in between metadata and rule (valid)\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n\n# This is a comment after the metadata YAML\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Empty comment line in between metadata and rule (valid)\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n#\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) metadata start\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\n# METADATA\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpError: \"test.rego:14: rego_parse_error: yaml: line 7: could not find expected ':'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation document path\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data/servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpError:       \"rego_parse_error: invalid document reference\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation schema path\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema/servers\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 4,\n\t\t\texpError:       \"rego_parse_error: invalid schema reference\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Ill-structured (invalid) annotation\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers= schema\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 5,\n\t\t\texpError:       \"rego_parse_error: yaml: unmarshal errors:\\n  line 3: cannot unmarshal !!str\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Indentation error in yaml\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n# - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 6,\n\t\t\texpError:       \"rego_parse_error: yaml: line 3: did not find expected key\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple rules with and without metadata\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}\n\npublic_servers_1[server] {\n\tserver = servers[i]; server.ports[j] = ports[k].id\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n\tserver.typo  # won't catch this type error since rule has no schema metadata\n}`,\n\t\t\texpNumComments: 7,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Multiple rules with metadata\",\n\t\t\tmodule: `\npackage opa.examples\n\nimport data.servers\nimport data.networks\nimport data.ports\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.servers: schema.servers\npublic_servers[server] {\n\tserver = servers[i]\n}\n\n# METADATA\n# scope: rule\n# schemas:\n#   - data.networks: schema.networks\n#   - data.ports: schema.ports\npublic_servers_1[server] {\n\tports[k].networks[l] = networks[m].id;\n\tnetworks[m].public = true\n}`,\n\t\t\texpNumComments: 9,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: dataServers, Schema: schemaServers},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tnode:  MustParseRule(`public_servers[server] { server = servers[i] }`),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\n\t\t\t\t\t\t{Path: dataNetworks, Schema: schemaNetworks},\n\t\t\t\t\t\t{Path: dataPorts, Schema: schemaPorts},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tnode:  MustParseRule(`public_servers_1[server] { ports[k].networks[l] = networks[m].id; networks[m].public = true }`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"multiple metadata blocks on a single rule\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My rule\n\n# METADATA\n# title: My rule 2\np { input = \"str\" }`,\n\t\t\texpNumComments: 4,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tTitle: \"My rule\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t\tTitle: \"My rule 2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Empty annotation error due to whitespace following METADATA hint\",\n\t\t\tmodule: `package test\n\n# METADATA\n\n# scope: rule\np { input.x > 7 }`,\n\t\t\texpError: \"test.rego:3: rego_parse_error: expected METADATA block, found whitespace\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Annotation on constant\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# scope: rule\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{Scope: annotationScopeRule},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"annotation on package\",\n\t\t\tmodule: `# METADATA\n# title: My package\npackage test\n\np { input = \"str\" }`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope: annotationScopePackage,\n\t\t\t\t\tTitle: \"My package\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"annotation on import\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My import\nimport input.foo\n\np { input = \"str\" }`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"1 error occurred: test.rego:3: rego_parse_error: invalid annotation scope 'import'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Default rule scope\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# {}\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{Scope: annotationScopeRule},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Unknown scope\",\n\t\t\tmodule: `\npackage test\n\n# METADATA\n# scope: deadbeef\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"invalid annotation scope 'deadbeef'\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Invalid rule scope/attachment\",\n\t\t\tmodule: `\n# METADATA\n# scope: rule\npackage test\n\np := 7`,\n\t\t\texpNumComments: 2,\n\t\t\texpError:       \"test.rego:2: rego_parse_error: annotation scope 'rule' must be applied to rule (have package)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: document on import\",\n\t\t\tmodule: `package test\n# METADATA\n# scope: document\nimport data.foo.bar`,\n\t\t\texpError: \"test.rego:2: rego_parse_error: annotation scope 'document' must be applied to rule (have import)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: unattached\",\n\t\t\tmodule: `package test\n\n# METADATA\n# scope: package`,\n\t\t\texpError: \"test.rego:3: rego_parse_error: annotation scope 'package' must be applied to package\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Scope attachment error: package on non-package\",\n\t\t\tmodule: `package test\n# METADATA\n# scope: package\nimport data.foo`,\n\t\t\texpError: \"test.rego:2: rego_parse_error: annotation scope 'package' must be applied to package (have import)\",\n\t\t},\n\t\t{\n\t\t\tnote: \"Inline schema definition\",\n\t\t\tmodule: `package test\n\n# METADATA\n# schemas:\n# - input: {\"type\": \"string\"}\np { input = \"str\" }`,\n\t\t\texpNumComments: 3,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tSchemas: []*SchemaAnnotation{\n\t\t\t\t\t\t{Path: InputRootRef, Definition: &stringSchema},\n\t\t\t\t\t},\n\t\t\t\t\tScope: annotationScopeRule,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"Rich meta\",\n\t\t\tmodule: `package test\n\n# METADATA\n# title: My rule\n# description: |\n#  My rule has a\n#  multiline description.\n# organizations:\n# - Acme Corp.\n# - Soylent Corp.\n# - Tyrell Corp.\n# related_resources:\n# - https://example.com\n# - \n#  ref: http://john:123@do.re/mi?foo=bar#baz\n#  description: foo bar\n# authors:\n# - John Doe <john@example.com>\n# - name: Jane Doe\n#   email: jane@example.com\n# custom:\n#  list:\n#   - a\n#   - b\n#  map:\n#   a: 1\n#   b: 2.2\n#   c:\n#    \"3\": d\n#    \"4\": e\n#  number: 42\n#  string: foo bar baz\n#  flag:\np { input = \"str\" }`,\n\t\t\texpNumComments: 31,\n\t\t\texpAnnotations: []*Annotations{\n\t\t\t\t{\n\t\t\t\t\tScope:         annotationScopeRule,\n\t\t\t\t\tTitle:         \"My rule\",\n\t\t\t\t\tDescription:   \"My rule has a\\nmultiline description.\\n\",\n\t\t\t\t\tOrganizations: []string{\"Acme Corp.\", \"Soylent Corp.\", \"Tyrell Corp.\"},\n\t\t\t\t\tRelatedResources: []*RelatedResourceAnnotation{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRef: mustParseURL(\"https://example.com\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRef:         mustParseURL(\"http://john:123@do.re/mi?foo=bar#baz\"),\n\t\t\t\t\t\t\tDescription: \"foo bar\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAuthors: []*AuthorAnnotation{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"John Doe\",\n\t\t\t\t\t\t\tEmail: \"john@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"Jane Doe\",\n\t\t\t\t\t\t\tEmail: \"jane@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tCustom: map[string]interface{}{\n\t\t\t\t\t\t\"list\": []interface{}{\n\t\t\t\t\t\t\t\"a\", \"b\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"map\": map[string]interface{}{\n\t\t\t\t\t\t\t\"a\": 1,\n\t\t\t\t\t\t\t\"b\": 2.2,\n\t\t\t\t\t\t\t\"c\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"3\": \"d\",\n\t\t\t\t\t\t\t\t\"4\": \"e\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"number\": 42,\n\t\t\t\t\t\t\"string\": \"foo bar baz\",\n\t\t\t\t\t\t\"flag\":   nil,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tmod, err := ParseModuleWithOpts(\"test.rego\", tc.module, ParserOptions{\n\t\t\t\tProcessAnnotation: true,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif tc.expError == \"\" || !strings.Contains(err.Error(), tc.expError) {\n\t\t\t\t\tt.Fatalf(\"Unexpected parse error when getting annotations: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if tc.expError != \"\" {\n\t\t\t\tt.Fatalf(\"Expected err: %v but no error from parse module\", tc.expError)\n\t\t\t}\n\n\t\t\tif len(mod.Comments) != tc.expNumComments {\n\t\t\t\tt.Fatalf(\"Expected %v comments but got %v\", tc.expNumComments, len(mod.Comments))\n\t\t\t}\n\n\t\t\tif annotationsCompare(tc.expAnnotations, mod.Annotations) != 0 {\n\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expAnnotations, mod.Annotations)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthorAnnotation(t *testing.T) {\n\ttests := []struct {\n\t\tnote     string\n\t\traw      interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tnote:     \"no name\",\n\t\t\traw:      \"\",\n\t\t\texpected: fmt.Errorf(\"author is an empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"only whitespaces\",\n\t\t\traw:      \" \\t\",\n\t\t\texpected: fmt.Errorf(\"author is an empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"one name only\",\n\t\t\traw:      \"John\",\n\t\t\texpected: AuthorAnnotation{Name: \"John\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"multiple names\",\n\t\t\traw:      \"John Jr.\\tDoe\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Jr. Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"email only\",\n\t\t\traw:      \"<john@example.com>\",\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name and email\",\n\t\t\traw:      \"John Doe <john@example.com>\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty email\",\n\t\t\traw:      \"John Doe <>\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name with reserved characters\",\n\t\t\traw:      \"John Doe < >\",\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe < >\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"name with reserved characters (email with space)\",\n\t\t\traw:      \"<john@ example.com>\",\n\t\t\texpected: AuthorAnnotation{Name: \"<john@ example.com>\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\": \"John Doe\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name and email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with extra entry\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t\t\"foo\":   \"bar\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\", Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty map\",\n\t\t\traw:      map[string]interface{}{},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with email and empty name\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"\",\n\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Email: \"john@example.com\"},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"email\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'name' and/or 'email' values required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with name and empty email\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"name\":  \"John Doe\",\n\t\t\t\t\"email\": \"\",\n\t\t\t},\n\t\t\texpected: AuthorAnnotation{Name: \"John Doe\"},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := parseAuthor(tc.raw)\n\n\t\t\tswitch expected := tc.expected.(type) {\n\t\t\tcase AuthorAnnotation:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif parsed.Compare(&expected) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\t\t\tcase error:\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected '%v' error but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\n\t\t\t\tif strings.Compare(expected.Error(), err.Error()) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected result type: %T\", expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRelatedResourceAnnotation(t *testing.T) {\n\ttests := []struct {\n\t\tnote     string\n\t\traw      interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tnote:     \"empty ref URL\",\n\t\t\traw:      \"\",\n\t\t\texpected: fmt.Errorf(\"ref URL may not be empty string\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"only whitespaces in ref URL\",\n\t\t\traw:      \" \\t\",\n\t\t\texpected: fmt.Errorf(\"parse \\\" \\\\t\\\": net/url: invalid control character in URL\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"invalid ref URL\",\n\t\t\traw:      \"https://foo:bar\",\n\t\t\texpected: fmt.Errorf(\"parse \\\"https://foo:bar\\\": invalid port \\\":bar\\\" after host\"),\n\t\t},\n\t\t{\n\t\t\tnote:     \"ref URL as string\",\n\t\t\traw:      \"https://example.com/foo?bar#baz\",\n\t\t\texpected: RelatedResourceAnnotation{Ref: mustParseURL(\"https://example.com/foo?bar#baz\")},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \"https://example.com/foo?bar#baz\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{Ref: mustParseURL(\"https://example.com/foo?bar#baz\")},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with ref and description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\":         \"https://example.com/foo?bar#baz\",\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{\n\t\t\t\tRef:         mustParseURL(\"https://example.com/foo?bar#baz\"),\n\t\t\t\tDescription: \"foo bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote: \"map with ref and description\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\":         \"https://example.com/foo?bar#baz\",\n\t\t\t\t\"description\": \"foo bar\",\n\t\t\t\t\"foo\":         \"bar\",\n\t\t\t},\n\t\t\texpected: RelatedResourceAnnotation{\n\t\t\t\tRef:         mustParseURL(\"https://example.com/foo?bar#baz\"),\n\t\t\t\tDescription: \"foo bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tnote:     \"empty map\",\n\t\t\traw:      map[string]interface{}{},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with empty ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \"\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t\t{\n\t\t\tnote: \"map with only whitespace in ref\",\n\t\t\traw: map[string]interface{}{\n\t\t\t\t\"ref\": \" \\t\",\n\t\t\t},\n\t\t\texpected: fmt.Errorf(\"'ref' value required in object\"),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.note, func(t *testing.T) {\n\t\t\tparsed, err := parseRelatedResource(tc.raw)\n\n\t\t\tswitch expected := tc.expected.(type) {\n\t\t\tcase RelatedResourceAnnotation:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif parsed.Compare(&expected) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\t\t\tcase error:\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected '%v' error but got %v\", tc.expected, parsed)\n\t\t\t\t}\n\n\t\t\t\tif strings.Compare(expected.Error(), err.Error()) != 0 {\n\t\t\t\t\tt.Fatalf(\"expected %v but got %v\", tc.expected, err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected result type: %T\", expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc assertLocationText(t *testing.T, expected string, actual *Location) {\n\tt.Helper()\n\tif actual == nil || actual.Text == nil {\n\t\tt.Errorf(\"Expected a non nil location and text\")\n\t\treturn\n\t}\n\tif string(actual.Text) != expected {\n\t\tt.Errorf(\"Unexpected Location text, got:\\n%s\\n\\nExpected:\\n%s\\n\\n\", actual.Text, expected)\n\t}\n}\n\nfunc assertParseError(t *testing.T, msg string, input string) {\n\tt.Helper()\n\tt.Run(msg, func(t *testing.T) {\n\t\tassertParseErrorFunc(t, msg, input, func(string) {})\n\t})\n}\n\nfunc assertParseErrorContains(t *testing.T, msg string, input string, expected string, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseErrorFunc(t, msg, input, func(result string) {\n\t\tt.Helper()\n\t\tif !strings.Contains(result, expected) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error to contain:\\n\\n%v\\n\\nbut got:\\n\\n%v\", msg, expected, result)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseErrorFunc(t *testing.T, msg string, input string, f func(string), opts ...ParserOptions) {\n\tt.Helper()\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tstmts, _, err := ParseStatementsWithOpts(\"\", input, opt)\n\tif err == nil && len(stmts) != 1 {\n\t\terr = fmt.Errorf(\"expected exactly one statement\")\n\t}\n\tif err == nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error on %s: expected no statements, got %d: %v\", msg, input, len(stmts), stmts)\n\t\treturn\n\t}\n\tresult := err.Error()\n\t// error occurred: <line>:<col>: <message>\n\tparts := strings.SplitN(result, \":\", 4)\n\tresult = strings.TrimSpace(parts[len(parts)-1])\n\tf(result)\n}\n\nfunc assertParseImport(t *testing.T, msg string, input string, correct *Import, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\timp := parsed.(*Import)\n\t\tif !imp.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": imports not equal: %v (parsed), %v (correct)\", msg, imp, correct)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseModule(t *testing.T, msg string, input string, correct *Module, opts ...ParserOptions) {\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tm, err := ParseModuleWithOpts(\"\", input, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: %s\", msg, input, err)\n\t\treturn\n\t}\n\n\tif !m.Equal(correct) {\n\t\tt.Errorf(\"Error on test %s: modules not equal: %v (parsed), %v (correct)\", msg, m, correct)\n\t}\n\n}\n\nfunc assertParseModuleError(t *testing.T, msg, input string) {\n\tm, err := ParseModule(\"\", input)\n\tif err == nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": expected parse error: %v (parsed)\", msg, m)\n\t}\n}\n\nfunc assertParsePackage(t *testing.T, msg string, input string, correct *Package) {\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tpkg := parsed.(*Package)\n\t\tif !pkg.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": packages not equal: %v (parsed), %v (correct)\", msg, pkg, correct)\n\t\t}\n\t})\n}\n\nfunc assertParseOne(t *testing.T, msg string, input string, correct func(interface{}), opts ...ParserOptions) {\n\tt.Helper()\n\topt := ParserOptions{}\n\tif len(opts) == 1 {\n\t\topt = opts[0]\n\t}\n\tstmts, _, err := ParseStatementsWithOpts(\"\", input, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: %s\", msg, input, err)\n\t\treturn\n\t}\n\tif len(stmts) != 1 {\n\t\tt.Errorf(\"Error on test \\\"%s\\\": parse error on %s: expected exactly one statement, got %d\", msg, input, len(stmts))\n\t\treturn\n\t}\n\tcorrect(stmts[0])\n}\n\nfunc assertParseOneBody(t *testing.T, msg string, input string, correct Body) {\n\tt.Helper()\n\tbody, err := ParseBody(input)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !body.Equal(correct) {\n\t\tt.Fatalf(\"Error on test \\\"%s\\\": bodies not equal:\\n%v (parsed)\\n%v (correct)\", msg, body, correct)\n\t}\n}\n\nfunc assertParseOneExpr(t *testing.T, msg string, input string, correct *Expr, opts ...ParserOptions) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\tbody := parsed.(Body)\n\t\tif len(body) != 1 {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": parser returned multiple expressions: %v\", msg, body)\n\t\t\treturn\n\t\t}\n\t\texpr := body[0]\n\t\tif !expr.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": expressions not equal:\\n%v (parsed)\\n%v (correct)\", msg, expr, correct)\n\t\t}\n\t}, opts...)\n}\n\nfunc assertParseOneExprNegated(t *testing.T, msg string, input string, correct *Expr) {\n\tcorrect.Negated = true\n\tassertParseOneExpr(t, msg, input, correct)\n}\n\nfunc assertParseOneTerm(t *testing.T, msg string, input string, correct *Term) {\n\tt.Helper()\n\tt.Run(msg, func(t *testing.T) {\n\t\tassertParseOneExpr(t, msg, input, &Expr{Terms: correct})\n\t})\n}\n\nfunc assertParseOneTermNegated(t *testing.T, msg string, input string, correct *Term) {\n\tt.Helper()\n\tassertParseOneExprNegated(t, msg, input, &Expr{Terms: correct})\n}\n\nfunc assertParseRule(t *testing.T, msg string, input string, correct *Rule) {\n\tt.Helper()\n\tassertParseOne(t, msg, input, func(parsed interface{}) {\n\t\tt.Helper()\n\t\trule := parsed.(*Rule)\n\t\tif !rule.Equal(correct) {\n\t\t\tt.Errorf(\"Error on test \\\"%s\\\": rules not equal: %v (parsed), %v (correct)\", msg, rule, correct)\n\t\t}\n\t})\n}\n"], "filenames": ["ast/parser.go", "ast/parser_test.go"], "buggy_code_start_loc": [900, 787], "buggy_code_end_loc": [977, 853], "fixing_code_start_loc": [900, 788], "fixing_code_end_loc": [995, 860], "type": "NVD-CWE-Other", "message": "An issue in the component ast/parser.go of Open Policy Agent v0.39.0 causes the application to incorrectly interpret every expression, causing a Denial of Service (DoS) via triggering out-of-range memory access.", "other": {"cve": {"id": "CVE-2022-28946", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-19T19:15:07.737", "lastModified": "2022-05-26T20:00:37.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in the component ast/parser.go of Open Policy Agent v0.39.0 causes the application to incorrectly interpret every expression, causing a Denial of Service (DoS) via triggering out-of-range memory access."}, {"lang": "es", "value": "Un problema en el componente ast/parser.go de Open Policy Agent versi\u00f3n v0.39.0, causa que la aplicaci\u00f3n interprete incorrectamente cada expresi\u00f3n, causando una Denegaci\u00f3n de Servicio (DoS) por medio de un desencadenamiento de accesos a memoria fuera de rango"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openpolicyagent:open_policy_agent:0.39.0:*:*:*:*:*:*:*", "matchCriteriaId": "199D4276-A268-44E5-9F8B-169BE19430C7"}]}]}], "references": [{"url": "https://github.com/open-policy-agent/opa/commit/e9d3828db670cbe11129885f37f08cbf04935264", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open-policy-agent/opa/commit/e9d3828db670cbe11129885f37f08cbf04935264"}}