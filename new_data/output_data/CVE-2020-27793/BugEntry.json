{"buggy_code": ["/* radare - Apache - Copyright 2014-2019 - dso, pancake */\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_cmd.h>\n#include <r_core.h>\n#include <r_cons.h>\n#include <string.h>\n#include <r_anal.h>\n\n#include \"../../../shlr/java/ops.h\"\n#include \"../../../shlr/java/class.h\"\n#include \"../../../shlr/java/code.h\"\n#include \"../../../shlr/java/dsojson.h\"\n\n#define DO_THE_DBG 0\n#undef IFDBG\n#define IFDBG if (DO_THE_DBG)\n\n\ntypedef struct found_idx_t {\n\tut16 idx;\n\tut64 addr;\n\tconst RBinJavaCPTypeObj *obj;\n} RCmdJavaCPResult;\n\ntypedef int (*RCMDJavaCmdHandler) (RCore *core, const char *cmd);\n\nstatic const char * r_cmd_java_strtok (const char *str1, const char b, size_t len);\nstatic const char * r_cmd_java_consumetok (const char *str1, const char b, size_t len);\nstatic int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* buffer, ut64 len);\n\nstatic int r_cmd_java_print_json_definitions( RBinJavaObj *obj  );\nstatic int r_cmd_java_print_all_definitions( RAnal *anal );\nstatic int r_cmd_java_print_class_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_field_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_method_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_import_definitions( RBinJavaObj *obj );\n\nstatic int r_cmd_java_resolve_cp_idx (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_summary (RBinJavaObj *obj, ut16 idx);\n\nstatic int r_cmd_java_print_class_access_flags_value( const char * flags );\nstatic int r_cmd_java_print_field_access_flags_value( const char * flags );\nstatic int r_cmd_java_print_method_access_flags_value( const char * flags );\nstatic int r_cmd_java_get_all_access_flags_value (const char *cmd);\n\nstatic int r_cmd_java_set_acc_flags (RCore *core, ut64 addr, ut16 num_acc_flag);\n\n#define _(x) UNUSED_FUNCTION(x)\nstatic int r_cmd_java_print_field_summary (RBinJavaObj *obj, ut16 idx);\nstatic int _(r_cmd_java_print_field_count) (RBinJavaObj *obj);\nstatic int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_print_field_num_name (RBinJavaObj *obj);\nstatic int r_cmd_java_print_method_summary (RBinJavaObj *obj, ut16 idx);\nstatic int _(r_cmd_java_print_method_count) (RBinJavaObj *obj);\nstatic int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_print_method_num_name (RBinJavaObj *obj);\n\nstatic RBinJavaObj * r_cmd_java_get_bin_obj(RAnal *anal);\nstatic RList * r_cmd_java_get_bin_obj_list(RAnal *anal);\nstatic ut64 r_cmd_java_get_input_num_value(RCore *core, const char *input_value);\nstatic int r_cmd_java_is_valid_input_num_value(RCore *core, const char *input_value);\n\n\nstatic int r_cmd_java_call(void *user, const char *input);\nstatic int r_cmd_java_handle_help (RCore * core, const char * input);\nstatic int r_cmd_java_handle_set_flags (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_prototypes (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_resolve_cp (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_calc_flags (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_flags_str (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_field_info (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_method_info (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd);\n\nstatic RList * cpfind_float (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_double (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_long (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_int (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_str (RCore *core, RBinJavaObj *obj, const char *cmd);\n\nstatic int cpfind (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut16 idx, ut64 addr, const ut8* buf, const ut64 len);\nstatic int r_cmd_java_handle_replace_cp_value_float (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_long (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_int (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_str (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_replace_classname_value (RCore *core, const char *cmd);\nstatic char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len);\nstatic char * r_cmd_replace_name (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len);\nstatic int r_cmd_is_object_descriptor (const char *name, ut32 name_len);\nstatic ut32 r_cmd_get_num_classname_str_occ (const char * str, const char *match_me);\nstatic const char * r_cmd_get_next_classname_str (const char * str, const char *match_me);\n\nstatic int r_cmd_java_handle_summary_info (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_print_exceptions (RCore *core, const char *input);\nstatic int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input);\nstatic int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char *input);\n\nstatic int r_cmd_java_handle_isvalid (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd);\n\ntypedef struct r_cmd_java_cms_t {\n\tconst char *name;\n\tconst char *args;\n\tconst char *desc;\n\tconst ut32 name_len;\n\tRCMDJavaCmdHandler handler;\n} RCmdJavaCmd;\n\n/* XXX : Most of those command arguments are absurd, must be reviewed + changed */\n\n#define CALC_SZ \"calc_sz\"\n#define CALC_SZ_ARGS \" <addr>\"\n#define CALC_SZ_DESC \"calculate class file size at location\"\n#define CALC_SZ_LEN 7\n\n#define ISVALID \"is_valid\"\n#define ISVALID_ARGS \" <addr> <sz>\"\n#define ISVALID_DESC \"check buffer to see if it is a valid class file\"\n#define ISVALID_LEN 8\n\n#define SET_ACC_FLAGS \"set_flags\"\n#define SET_ACC_FLAGS_ARGS \" [addr cmf <value>]\" //[<addr> <c | m | f> <num_flag_val>] | [<addr> < c | m | f> <flag value separated by space> ]\"\n#define SET_ACC_FLAGS_DESC \"set the access flags attributes for a field or method\"\n#define SET_ACC_FLAGS_LEN 9\n\n#define PROTOTYPES \"prototypes\"\n#define PROTOTYPES_ARGS \" <jaicmf>\" // < j | a | i | c | m | f>\n#define PROTOTYPES_DESC \"show in JSON, or All,Imports,Class,Methods,Fields\"\n#define PROTOTYPES_LEN 10\n\n#define RESOLVE_CP \"resolve_cp\"\n#define RESOLVE_CP_ARGS \" [<stecadg> idx]\"\n#define RESOLVE_CP_DESC \"cp type or value @ idx. Summary,Type,b64Encode,Const,Addr,Dump,Gsumarize\"\n//d = dump all,  g = summarize all, s = summary, a = address, t = type, c = get value, e = base64 enode the result\"\n#define RESOLVE_CP_LEN 10\n\n#define CALC_FLAGS \"calc_flags\"\n#define CALC_FLAGS_ARGS \" <lcfm> [visib.]\"\n//[ <l <[c|f|m]>> | <c [public,private,static...]>  | <f [public,private,static...]> | <m c [public,private,static...]>]\"\n#define CALC_FLAGS_DESC \"value from access flags: ListAll, flags, Class, Field, Method\"\n#define CALC_FLAGS_LEN 10\n\n#define FLAGS_STR_AT \"flags_str_at\"\n#define FLAGS_STR_AT_ARGS \" <cfm> [addr]\"\n#define FLAGS_STR_AT_DESC \"string value from access flags @ addr: Class, Field, Method\"\n#define FLAGS_STR_AT_LEN 12\n\n#define FLAGS_STR \"flags_str\"\n#define FLAGS_STR_ARGS \" [<cfm> <access>]\" //acc_flags_value>]\"\n#define FLAGS_STR_DESC \"string value for the flags number: Class, Field, Method\"\n#define FLAGS_STR_LEN 9\n\n#define METHOD_INFO \"m_info\"\n#define METHOD_INFO_ARGS \" [<p,c,s idx> | <n idx>]\"\n//#define METHOD_INFO_DESC \"method index info: c = dump methods and ord , s = dump of all meta-data, n = method\"\n#define METHOD_INFO_DESC \"method information at index (c:method+ord, s:metadata)\"\n#define METHOD_INFO_LEN 6\n\n#define FIELD_INFO \"f_info\"\n#define FIELD_INFO_ARGS \" [<p,c,s idx> | #idx]\"\n#define FIELD_INFO_DESC \"field information at index (c:field+ord, s:metadata)\"\n// : c = dump field and ord , s = dump of all meta-data, n = method\"\n#define FIELD_INFO_LEN 6\n\n#define HELP \"help\"\n#define HELP_DESC \"displays this message\"\n#define HELP_ARGS \"\"\n#define HELP_LEN 4\n\n#define FIND_CP_CONST \"find_cp_const\"\n#define FIND_CP_CONST_ARGS \" [a|#idx]\"\n#define FIND_CP_CONST_DESC \"find references to constant CP Object in code: AllReferences\"\n#define FIND_CP_CONST_LEN 13\n\n#define FIND_CP_VALUE \"find_cp_value\"\n#define FIND_CP_VALUE_ARGS \" [<silfd> V]\"\n#define FIND_CP_VALUE_DESC \"find references to CP constants by value\"\n#define FIND_CP_VALUE_LEN 13\n\n#define REPLACE_CP_VALUE \"replace_cp_value\"\n#define REPLACE_CP_VALUE_ARGS \" [<idx> V]\"\n#define REPLACE_CP_VALUE_DESC \"replace CP constants with value if the no resizing is required\"\n#define REPLACE_CP_VALUE_LEN 16\n\n#define REPLACE_CLASS_NAME \"replace_classname_value\"\n#define REPLACE_CLASS_NAME_ARGS \" <c> <nc>\"\n#define REPLACE_CLASS_NAME_DESC \"rename class name\" //\"replace CP constants with value if no resize needed\"\n#define REPLACE_CLASS_NAME_LEN 23\n\n#define RELOAD_BIN \"reload_bin\"\n#define RELOAD_BIN_ARGS \" addr [size]\"\n#define RELOAD_BIN_DESC \"reload and reanalyze the Java class file starting at address\"\n#define RELOAD_BIN_LEN 10\n\n#define SUMMARY_INFO \"summary\"\n#define SUMMARY_INFO_ARGS \"\"\n#define SUMMARY_INFO_DESC \"print summary information for the current java class file\"\n#define SUMMARY_INFO_LEN 7\n\n#define LIST_CODE_REFS \"lcr\"\n#define LIST_CODE_REFS_ARGS \" [addr]\"\n#define LIST_CODE_REFS_DESC \"list all references to fields and methods in code sections\"\n#define LIST_CODE_REFS_LEN 3\n\n#define PRINT_EXC \"exc\"\n#define PRINT_EXC_ARGS \" [<addr>]\"\n#define PRINT_EXC_DESC \"list all exceptions to fields and methods in code sections\"\n#define PRINT_EXC_LEN 3\n\n#define YARA_CODE_REFS \"yc_w_refs\"\n#define YARA_CODE_REFS_ARGS \" [name] [start] [count]\"\n#define YARA_CODE_REFS_DESC \"yara code bytes extraction with a name starting at <start> to <count>\"\n#define YARA_CODE_REFS_LEN 9\n\n#define INSERT_MREF \"i_mref\"\n#define INSERT_MREF_ARGS \" C M S\" //<meth> <desc>\" //descriptor in form of (Lpref;)Lref;\"\n#define INSERT_MREF_DESC \"add Method to Class with given method signature\" //append a method reference CP object to the end of the CP object array (creates all requisite objects)\"\n#define INSERT_MREF_LEN 6\n\n\nstatic RCmdJavaCmd JAVA_CMDS[] = {\n\t{HELP, HELP_ARGS, HELP_DESC, HELP_LEN, r_cmd_java_handle_help},\n\t{SET_ACC_FLAGS, SET_ACC_FLAGS_ARGS, SET_ACC_FLAGS_DESC, SET_ACC_FLAGS_LEN, r_cmd_java_handle_set_flags},\n\t{PROTOTYPES, PROTOTYPES_ARGS, PROTOTYPES_DESC, PROTOTYPES_LEN, r_cmd_java_handle_prototypes},\n\t{RESOLVE_CP, RESOLVE_CP_ARGS, RESOLVE_CP_DESC, RESOLVE_CP_LEN, r_cmd_java_handle_resolve_cp},\n\t{CALC_FLAGS, CALC_FLAGS_ARGS, CALC_FLAGS_DESC, CALC_FLAGS_LEN, r_cmd_java_handle_calc_flags},\n\t{FLAGS_STR_AT, FLAGS_STR_AT_ARGS, FLAGS_STR_AT_DESC, FLAGS_STR_AT_LEN, r_cmd_java_handle_flags_str_at},\n\t{FLAGS_STR, FLAGS_STR_ARGS, FLAGS_STR_DESC, FLAGS_STR_LEN, r_cmd_java_handle_flags_str},\n\t{METHOD_INFO, METHOD_INFO_ARGS, METHOD_INFO_DESC, METHOD_INFO_LEN, r_cmd_java_handle_method_info},\n\t{FIELD_INFO, FIELD_INFO_ARGS, FIELD_INFO_DESC, FIELD_INFO_LEN, r_cmd_java_handle_field_info},\n\t{FIND_CP_CONST, FIND_CP_CONST_ARGS, FIND_CP_CONST_DESC, FIND_CP_CONST_LEN, r_cmd_java_handle_find_cp_const},\n\t{FIND_CP_VALUE, FIND_CP_VALUE_ARGS, FIND_CP_VALUE_DESC, FIND_CP_VALUE_LEN, cpfind},\n\t{REPLACE_CP_VALUE, REPLACE_CP_VALUE_ARGS, REPLACE_CP_VALUE_DESC, REPLACE_CP_VALUE_LEN, r_cmd_java_handle_replace_cp_value},\n\t{REPLACE_CLASS_NAME, REPLACE_CLASS_NAME_ARGS, REPLACE_CLASS_NAME_DESC, REPLACE_CLASS_NAME_LEN, r_cmd_java_handle_replace_classname_value},\n\t{RELOAD_BIN, RELOAD_BIN_ARGS, RELOAD_BIN_DESC, RELOAD_BIN_LEN, r_cmd_java_handle_reload_bin},\n\t{SUMMARY_INFO, SUMMARY_INFO_ARGS, SUMMARY_INFO_DESC, SUMMARY_INFO_LEN, r_cmd_java_handle_summary_info},\n\t{PRINT_EXC, PRINT_EXC_ARGS, PRINT_EXC_DESC, PRINT_EXC_LEN, r_cmd_java_handle_print_exceptions},\n\t{YARA_CODE_REFS, YARA_CODE_REFS_ARGS, YARA_CODE_REFS_DESC, YARA_CODE_REFS_LEN, r_cmd_java_handle_yara_code_extraction_refs},\n\t{INSERT_MREF, INSERT_MREF_ARGS, INSERT_MREF_DESC, INSERT_MREF_LEN, r_cmd_java_handle_insert_method_ref},\n\t{CALC_SZ, CALC_SZ_ARGS, CALC_SZ_DESC, CALC_SZ_LEN, r_cmd_java_handle_calc_class_sz},\n\t{ISVALID, ISVALID_ARGS, ISVALID_DESC, ISVALID_LEN, r_cmd_java_handle_isvalid},\n};\n\nenum {\n\tHELP_IDX = 0,\n\tSET_ACC_FLAGS_IDX = 1,\n\tPROTOTYPES_IDX = 2,\n\tRESOLVE_CP_IDX = 3,\n\tCALC_FLAGS_IDX = 4,\n\tFLAGS_STR_AT_IDX = 5,\n\tFLAGS_STR_IDX = 6,\n\tMETHOD_INFO_IDX = 7,\n\tFIELD_INFO_IDX = 8,\n\tFIND_CP_CONST_IDX = 9,\n\tFIND_CP_VALUE_IDX = 10,\n\tREPLACE_CP_VALUE_IDX = 11,\n\tREPLACE_CLASS_NAME_IDX = 12,\n\tRELOAD_BIN_IDX = 13,\n\tSUMMARY_INFO_IDX = 14,\n\tLIST_CODE_REFS_IDX = 15,\n\tPRINT_EXC_IDX = 16,\n\tYARA_CODE_REFS_IDX = 17,\n\tINSERT_MREF_IDX = 18,\n\tCALC_SZ_IDX = 19,\n\tISVALID_IDX = 20,\n\tEND_CMDS = 21,\n};\n\nstatic ut8 _(r_cmd_java_obj_ref)(const char *name, const char *class_name, ut32 len) {\n\tif (!name || !class_name) {\n\t\treturn false;\n\t}\n\tif (strncmp (class_name, name, len)) {\n\t\treturn false;\n\t}\n\tif (*(name - 1) == 'L' && *(name + len) == ';') {\n\t\treturn true;\n\t}\n\tif (!strncmp (class_name, name, len) && !*(name + len)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char * r_cmd_get_next_classname_str (const char * str, const char *match_me) {\n\tconst char *result = NULL;\n\tut32 len = match_me && *match_me ? strlen (match_me) : 0;\n\tif (len && str && *str) {\n\t\tresult = str;\n\t\twhile (result && *result && (result - str < len)) {\n\t\t\tresult = strstr (result, match_me);\n\t\t\tif (result) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut32 r_cmd_get_num_classname_str_occ (const char * str, const char *match_me) {\n\tconst char *result = NULL;\n\tut32 len = match_me && *match_me ? strlen (match_me) : 0;\n\tut32 occ = 0;\n\n\tif (len == 0 || !str || !*str) {\n\t\treturn 0;\n\t}\n\tresult = str;\n\twhile (result && *result && (result - str < len)) {\n\t\tresult = strstr (result, match_me);\n\t\tif (result) {\n\t\t\tIFDBG eprintf (\"result: %s\\n\", result);\n\t\t\tresult+=len;\n\t\t\tocc++;\n\t\t}\n\t}\n\treturn occ;\n}\n\nstatic const char * r_cmd_java_consumetok (const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p != b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic const char * r_cmd_java_strtok (const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tIFDBG r_cons_printf (\"Looking for char (%c) in (%s) up to %d\\n\", b, p, len);\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tIFDBG r_cons_printf (\"Found? for char (%c) @ %d: (%s)\\n\", b, i, p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\tIFDBG r_cons_printf (\"Found? for char (%c) @ %d: (%s)\\n\", b, len, p);\n\treturn p;\n}\n\nstatic RAnal * get_anal (RCore *core) {\n\treturn core? core->anal: NULL;\n}\n\nstatic void r_cmd_java_print_cmd_help (RCmdJavaCmd *cmd) {\n\teprintf (\"[*] %s %s\\n[+] %s\\n\\n\", cmd->name, cmd->args, cmd->desc);\n}\n\nstatic int r_cmd_java_handle_help (RCore * core, const char * input) {\n\tut32 i = 0;\n\tconst char **help_msg = (const char**)malloc (sizeof(char *) * END_CMDS*4);\n\thelp_msg[0] = \"Usage:\";\n\thelp_msg[1] = \"java [cmd] [arg..] \";\n\thelp_msg[2] = r_core_plugin_java.desc;\n\tfor (i = 0; i <END_CMDS; i++) {\n\t\tRCmdJavaCmd *cmd = &JAVA_CMDS[i];\n\t\thelp_msg[3+(i*3)+0] = cmd->name;\n\t\thelp_msg[3+(i*3)+1] = cmd->args;\n\t\thelp_msg[3+(i*3)+2] = cmd->desc;\n\t}\n\thelp_msg[3+(i*3)] = NULL;\n\tr_core_cmd_help (core, help_msg);\n\tfree (help_msg);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_prototypes (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'm': return r_cmd_java_print_method_definitions (obj);\n\tcase 'f': return r_cmd_java_print_field_definitions (obj);\n\tcase 'i': return r_cmd_java_print_import_definitions (obj);\n\tcase 'c': return r_cmd_java_print_class_definitions (obj);\n\tcase 'a': return r_cmd_java_print_all_definitions (anal);\n\tcase 'j': return r_cmd_java_print_json_definitions (obj);\n\t}\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_summary_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\n\tr_cons_printf (\"Summary for %s:\\n\", obj->file);\n\tr_cons_printf (\"  Size 0x%\"PFMT64x\":\\n\", obj->size);\n\tr_cons_printf (\"  Constants  size: 0x%\"PFMT64x\" count: %d:\\n\", obj->cp_size, obj->cp_count);\n\tr_cons_printf (\"  Methods    size: 0x%\"PFMT64x\" count: %d:\\n\", obj->methods_size, obj->methods_count);\n\tr_cons_printf (\"  Fields     size: 0x%\"PFMT64x\" count: %d:\\n\", obj->fields_size, obj->fields_count);\n\tr_cons_printf (\"  Attributes size: 0x%\"PFMT64x\" count: %d:\\n\", obj->attrs_size, obj->attrs_count);\n\tr_cons_printf (\"  Interfaces size: 0x%\"PFMT64x\" count: %d:\\n\", obj->interfaces_size, obj->interfaces_count);\n\n\treturn true;\n}\n\nstatic int _(r_cmd_java_check_op_idx) (const ut8 *op_bytes, ut16 idx) {\n\treturn R_BIN_JAVA_USHORT (op_bytes, 0) == idx;\n}\n\n/* Find stuff in the constant pool */\nstatic RList * cpfind_double (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tdouble value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;\n\tif (value == 0.0 && !(cmd && cmd[0] == '0' && cmd[1] == '.' && cmd[2] == '0')) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 8, R_BIN_JAVA_CP_DOUBLE);\n}\n\nstatic RList * cpfind_float (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tfloat value = cmd && *cmd ? atof (cmd) : 0.0;\n\tif (value == 0.0 && !(cmd && cmd[0] == '0' && cmd[1] == '.' && cmd[2] == '0')) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 4, R_BIN_JAVA_CP_FLOAT);\n}\n\nstatic RList * cpfind_long (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tut64 value = r_cmd_java_get_input_num_value (core, cmd);\n\tif (!r_cmd_java_is_valid_input_num_value (core, cmd)) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 8, R_BIN_JAVA_CP_LONG);\n}\n\nstatic RList * cpfind_int (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tut32 value = (ut32) r_cmd_java_get_input_num_value (core, cmd);\n\tif (!r_cmd_java_is_valid_input_num_value (core, cmd)) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 4, R_BIN_JAVA_CP_INTEGER);\n}\n\nstatic RList * cpfind_str (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tif (!cmd) {\n\t\treturn r_list_new ();\n\t}\n\tIFDBG r_cons_printf (\"Looking for str: %s (%d)\\n\", cmd, strlen (cmd));\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) cmd, strlen (cmd), R_BIN_JAVA_CP_UTF8);\n}\n\nstatic int cpfind (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tconst char *p = cmd;\n\tchar f_type = 0;\n\tRList *find_list = NULL;\n\tRListIter *iter;\n\tut32 *idx;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tif (p && *p) {\n\t\tp = r_cmd_java_consumetok (cmd, ' ', -1);\n\t\tf_type = *p;\n\t\tp+=2;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tswitch (f_type) {\n\tcase 's': find_list = cpfind_str (core, obj, p); break;\n\tcase 'i': find_list = cpfind_int (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'l': find_list = cpfind_long (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'f': find_list = cpfind_float (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'd': find_list = cpfind_double (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tdefault:\n\t\teprintf (\"[-] r_cmd_java: invalid java type to search for.\\n\");\n\t\treturn true;\n\t}\n\n\tr_list_foreach (find_list, iter, idx) {\n\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, (ut16) *idx);\n\t\tr_cons_printf (\"Offset: 0x%\"PFMT64x\" idx: %d\\n\", addr, *idx);\n\t}\n\tr_list_free (find_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* buffer, ut64 len) {\n\tif (!buffer || len < 10) {\n\t\treturn false;\n\t}\n\tint res = r_bin_java_load_bin (obj, buffer, len);\n\n\tif (res == true) {\n\t\t//RBinPlugin *cp = NULL;\n\t\tRBinPlugin *tmp;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->bin->plugins, iter, tmp) {\n\t\t\tif (!strncmp (\"java\", tmp->name, 4)) {\n\t\t\t\t//cp = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// XXX - this API is no longer valid.\n\t\t// need a function that will re-read bin bytes\n\t\t// and parse the file\n\t\t//if (cp) r_bin_update_items (core->bin, cp);\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut16 idx, ut64 addr, const ut8 * buf, const ut64 len) {\n\tint res = false;\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);\n\tut64 c_file_sz = r_io_size (core->io);\n\tut32 n_sz = 0, c_sz = obj ? r_bin_java_cp_get_size (obj, idx): -1;\n\tut8 * bytes = NULL;\n\n\tif (c_sz == -1) {\n\t\treturn res;\n\t}\n\n\tbytes = r_bin_java_cp_get_bytes (cp_obj->tag, &n_sz, buf, len);\n\n\tif (n_sz < c_sz) {\n\t\tres = r_core_shift_block (core, addr+c_sz, 0, (int)n_sz - (int)c_sz) &&\n\t\tr_io_resize(core->io, c_file_sz + (int) n_sz - (int) c_sz);\n\t} else if (n_sz > c_sz) {\n\t\tres = r_core_extend_at(core, addr,  (int)n_sz - (int)c_sz);\n\t} else {\n\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to resize the file correctly aborting.\\n\");\n\t\treturn res;\n\t}\n\n\tif (n_sz > 0 && bytes) {\n\t\tres = r_core_write_at(core, addr, (const ut8 *)bytes, n_sz) && r_core_seek (core, addr, 1);\n\t}\n\n\tif (res == false) {\n\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to write the bytes to the file correctly aborting.\\n\");\n\t\treturn res;\n\t}\n\n\tR_FREE (bytes);\n\n\tif (res == true) {\n\t\tut64 n_file_sz = 0;\n\t\tut8 * bin_buffer = NULL;\n\t\tres = r_io_use_fd (core->io, core->file->fd);\n\t\tn_file_sz = r_io_size (core->io);\n\t\tbin_buffer = n_file_sz > 0 ? malloc (n_file_sz) : NULL;\n\t\tif (bin_buffer) {\n\t\t\tmemset (bin_buffer, 0, n_file_sz);\n\t\t\tres = n_file_sz == r_io_read_at (core->io, obj->loadaddr,\n\t\t\t\tbin_buffer, n_file_sz) ? true : false;\n\t\t\tif (res == true) {\n\t\t\t\tres = r_cmd_java_reload_bin_from_buf (\n\t\t\t\t\tcore, obj, bin_buffer, n_file_sz);\n\t\t\t} else {\n\t\t\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to read the file in aborted, bin reload.\\n\");\n\t\t\t}\n\t\t\tfree (bin_buffer);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_float (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tfloat value = cmd && *cmd ? atof (cmd) : 0.0;\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tdouble value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_long (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tut64 value = r_cmd_java_get_input_num_value (core, cmd);\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_int (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tut32 value = (ut32) r_cmd_java_get_input_num_value (core, cmd);\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_str (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tint res = false;\n\tut32 len = cmd && *cmd ? strlen (cmd) : 0;\n\tif (len > 0 && cmd && *cmd == '\"') {\n\t\tcmd++;\n\t\tlen = cmd && *cmd ? strlen (cmd) : 0;\n\t}\n\tif (cmd && len > 0) {\n\t\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) cmd, len);\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tut16 idx = -1;\n\tut64 addr = 0;\n\tconst char *p = cmd;\n\tchar cp_type = 0;\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tif (p && *p) {\n\t\tp = r_cmd_java_consumetok (cmd, ' ', -1);\n\t\tif (r_cmd_java_is_valid_input_num_value (core, p)) {\n\t\t\tidx = r_cmd_java_get_input_num_value (core, p);\n\t\t\tp = r_cmd_java_strtok (p, ' ', strlen(p));\n\t\t}\n\t}\n\tif (idx == (ut16) -1 ) {\n\t\teprintf (\"[-] r_cmd_java: Invalid index value.\\n\");\n\t} else if (!obj) {\n\t\teprintf (\"[-] r_cmd_java: The current binary is not a Java Bin Object.\\n\");\n\t} else if (!p || (p && !*p)) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CP_VALUE_IDX);\n\t\treturn true;\n\t} else {\n\t\tcp_type = r_bin_java_resolve_cp_idx_tag(obj, idx);\n\t\taddr = r_bin_java_resolve_cp_idx_address (obj, idx);\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\t\tswitch (cp_type) {\n\t\tcase R_BIN_JAVA_CP_UTF8: return r_cmd_java_handle_replace_cp_value_str (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_INTEGER: return r_cmd_java_handle_replace_cp_value_int (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_LONG: return r_cmd_java_handle_replace_cp_value_long (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_FLOAT: return r_cmd_java_handle_replace_cp_value_float (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_DOUBLE: return r_cmd_java_handle_replace_cp_value_double (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tdefault:\n\t\t\teprintf (\"[-] r_cmd_java: invalid java type to search for.\\n\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {\n\tconst char * fmt = \"L%s;\";\n\tchar *s_new_ref = s_new && replace_len > 0 ? malloc (3 + replace_len) : NULL;\n\tchar *s_old_ref = s_old && match_len > 0 ? malloc (3 + match_len) : NULL;\n\tchar *result = NULL;\n\t*res_len = 0;\n\tif (s_new_ref && s_old_ref) {\n\t\tsnprintf (s_new_ref, replace_len+3, fmt, s_new);\n\t\tsnprintf (s_old_ref, match_len+3, fmt, s_old);\n\t\tresult = r_cmd_replace_name (s_new_ref, replace_len+2, s_old_ref, match_len+2, buffer, buf_len, res_len);\n\t}\n\tfree (s_new_ref);\n\tfree (s_old_ref);\n\treturn result;\n}\n\nstatic int r_cmd_is_object_descriptor (const char *name, ut32 name_len) {\n\tint found_L = false, found_Semi = false;\n\tut32 idx = 0, L_pos = 0, Semi_pos = 0;\n\tconst char *p_name = name;\n\n\tfor (idx = 0, L_pos = 0; idx < name_len; idx++,p_name++) {\n\t\tif (*p_name == 'L') {\n\t\t\tfound_L = true;\n\t\t\tL_pos = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (idx = 0, Semi_pos = 0; idx < name_len; idx++,p_name++) {\n\t\tif (*p_name == ';') {\n\t\t\tfound_Semi = true;\n\t\t\tSemi_pos = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true ? found_L == found_Semi && found_L == true && L_pos < Semi_pos : false;\n}\n\nstatic char * r_cmd_replace_name (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {\n\tut32 num_occurrences = 0, i = 0;\n\tchar * result = NULL, *p_result = NULL;\n\n\tnum_occurrences = r_cmd_get_num_classname_str_occ (buffer, s_old);\n\t*res_len = 0;\n\tif (num_occurrences > 0 && replace_len > 0 && s_old) {\n\t\tut32 consumed = 0;\n\t\tconst char * next = r_cmd_get_next_classname_str (buffer+consumed, s_old);\n\t\tIFDBG r_cons_printf (\"Replacing \\\"%s\\\" with \\\"%s\\\" in: %s\\n\", s_old, s_new, buffer);\n\t\tresult = malloc (num_occurrences*replace_len + buf_len);\n\t\tmemset (result, 0, num_occurrences*replace_len + buf_len);\n\t\tp_result = result;\n\t\twhile (next && consumed < buf_len) {\n\t\t\t// replace up to next\n\t\t\tIFDBG r_cons_printf (\"next: \\\"%s\\\", len to: %d\\n\", next, next-buffer );\n\t\t\tfor (; buffer + consumed < next  && consumed < buf_len; consumed++, p_result++) {\n\t\t\t\t*p_result = *(buffer + consumed);\n\t\t\t\t(*res_len)++;\n\t\t\t}\n\n\t\t\tfor (i=0; i < replace_len; i++,  p_result++){\n\t\t\t\t*p_result = *(s_new + i);\n\t\t\t\t(*res_len)++;\n\t\t\t}\n\t\t\tconsumed += match_len;\n\t\t\tnext = r_cmd_get_next_classname_str (buffer+consumed, s_old);\n\t\t}\n\t\tIFDBG r_cons_printf (\"Found last occurrence of: \\\"%s\\\", remaining: %s\\n\", s_old, buffer+consumed);\n\t\tIFDBG r_cons_printf (\"result is: \\\"%s\\\"\\n\", result);\n\t\tfor (; consumed < buf_len; consumed++, p_result++, (*res_len)++) {\n\t\t\t*p_result = *(buffer + consumed);\n\t\t}\n\t\tIFDBG r_cons_printf (\"Old: %s\\nNew: %s\\n\", buffer, result);\n\t}\n\treturn result;\n}\n\n\nstatic int r_cmd_java_get_class_names_from_input (const char *input, char **class_name, ut32 *class_name_len, char **new_class_name, ut32 *new_class_name_len) {\n\tconst char *p = input;\n\n\tut32 cmd_sz = input && *input ? strlen (input) : 0;\n\tint res = false;\n\n\tif (!class_name || *class_name) {\n\t\treturn res;\n\t} else if (!new_class_name || *new_class_name) {\n\t\treturn res;\n\t} else if (!new_class_name_len || !class_name_len) {\n\t\treturn res;\n\t}\n\n\t*new_class_name = NULL;\n\t*class_name_len = 0;\n\n\tif (p && *p && cmd_sz > 1) {\n\t\tconst char *end;\n\t\tp = r_cmd_java_consumetok (p, ' ', cmd_sz);\n\t\tend = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\n\t\tif (p && end && p != end) {\n\t\t\t*class_name_len = end - p + 1;\n\t\t\t*class_name = malloc (*class_name_len);\n\t\t\tsnprintf (*class_name, *class_name_len, \"%s\", p );\n\t\t\tcmd_sz = *class_name_len - 1 < cmd_sz ? cmd_sz - *class_name_len : 0;\n\t\t}\n\n\t\tif (*class_name && cmd_sz > 0) {\n\t\t\tp = r_cmd_java_consumetok (end+1, ' ', cmd_sz);\n\t\t\tend = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\n\t\t\tif (!end && p && *p) {\n\t\t\t\tend = p + cmd_sz;\n\t\t\t}\n\n\t\t\tif (p && end && p != end) {\n\t\t\t\t*new_class_name_len = end - p + 1;\n\t\t\t\t*new_class_name = malloc (*new_class_name_len);\n\t\t\t\tsnprintf (*new_class_name, *new_class_name_len, \"%s\", p );\n\t\t\t\tres = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_classname_value (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj;\n\tchar *class_name = NULL, *new_class_name = NULL;\n\tut32 class_name_len = 0, new_class_name_len = 0;\n\tRAnal *anal = get_anal (core);\n\tconst char *p = cmd;\n\tint res = false;\n\tut16 idx = -1;\n\n\tif (!core || !anal || !cmd) {\n\t\treturn false;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tobj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tif (!obj) {\n\t\teprintf (\"The current binary is not a Java Bin Object.\\n\");\n\t\treturn true;\n\t}\n\tres = r_cmd_java_get_class_names_from_input (cmd, &class_name,\n\t\t&class_name_len, &new_class_name, &new_class_name_len);\n\n\tif (!res || !class_name || !new_class_name) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CLASS_NAME_IDX);\n\t\tfree (class_name);\n\t\tfree (new_class_name);\n\t\treturn true;\n\t}\n\tfor (idx = 1; idx <=obj->cp_count; idx++) {\n\t\tRBinJavaCPTypeObj* cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);\n\t\tchar *name = NULL;\n\t\tut8 * buffer = NULL;\n\t\tut32 buffer_sz = 0;\n\t\tut16 len = 0;\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_UTF8 &&\n\t\t\tcp_obj->info.cp_utf8.length && cp_obj->info.cp_utf8.length >= class_name_len-1) {\n\t\t\tut32 num_occurrences = 0;\n\t\t\tut64 addr = cp_obj->file_offset + cp_obj->loadaddr;\n\t\t\tbuffer = r_bin_java_cp_get_idx_bytes (obj, idx, &buffer_sz);\n\n\t\t\tif (!buffer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = R_BIN_JAVA_USHORT ( buffer, 1);\n\t\t\tname = malloc (len+3);\n\t\t\tmemcpy (name, buffer+3, len);\n\t\t\tname[len] = 0;\n\n\t\t\tnum_occurrences = r_cmd_get_num_classname_str_occ (name, class_name);\n\n\t\t\tif (num_occurrences > 0) {\n\t\t\t\t// perform inplace replacement\n\t\t\t\tut32 res_len = 0;\n\t\t\t\tchar * result = NULL;\n\n\t\t\t\tif (r_cmd_is_object_descriptor (name, len) == true) {\n\t\t\t\t\tresult = r_cmd_replace_name_def (new_class_name,\n\t\t\t\t\t\tnew_class_name_len-1, class_name,\n\t\t\t\t\t\tclass_name_len-1, name, len, &res_len);\n\t\t\t\t} else {\n\t\t\t\t\tresult = r_cmd_replace_name (new_class_name,\n\t\t\t\t\t\tnew_class_name_len-1, class_name,\n\t\t\t\t\t\tclass_name_len-1, name, len, &res_len);\n\t\t\t\t}\n\t\t\t\tif (result) {\n\t\t\t\t\tres = r_cmd_java_get_cp_bytes_and_write (\n\t\t\t\t\t\tcore, obj, idx, addr,\n\t\t\t\t\t\t(const ut8*)result, res_len);\n\t\t\t\t\tif  (res == false) {\n\t\t\t\t\t\teprintf (\"ERROR: r_cmd_java: Failed to write bytes or reload the binary.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (result);\n\t\t\t}\n\t\t\tfree (buffer);\n\t\t\tfree (name);\n\t\t}\n\n\t}\n\tfree (class_name);\n\tfree (new_class_name);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tconst char *p = cmd;\n\tut64 addr = 0LL; //cur_offset = core->offset, addr = 0;\n\tut64 buf_size = 0;\n\tut8 * buf = NULL;\n\tint res = false;\n\n\tif (*cmd == ' ') {\n\t\tp = r_cmd_java_consumetok (p, ' ', -1);\n\t}\n\tif (!*cmd) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+RELOAD_BIN_IDX);\n\t\treturn true;\n\t}\n\n\taddr = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\tif (*cmd == ' ') {\n\t\tp = r_cmd_java_consumetok (p, ' ', -1);\n\t}\n\tbuf_size = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\t// XXX this may cause problems cause the file we are looking at may not be the bin we want.\n\t// lets pretend it is for now\n\tif (buf_size == 0) {\n\t\tres = r_io_use_fd (core->io, core->file->fd);\n\t\tbuf_size = r_io_size (core->io);\n\t\tbuf = malloc (buf_size);\n\t\tmemset (buf, 0, buf_size);\n\t\tr_io_read_at (core->io, addr, buf, buf_size);\n\t}\n\tif (buf && obj) {\n\t\tres = r_cmd_java_reload_bin_from_buf (core, obj, buf, buf_size);\n\t}\n\tfree (buf);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd) {\n\tconst char *p = (cmd && *cmd == ' ')?  r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tRAnalFunction *fcn = NULL;\n\tRAnalBlock *bb = NULL;\n\tRListIter *bb_iter, *fn_iter, *iter;\n\tRCmdJavaCPResult *cp_res = NULL;\n\tut16 idx = -1;\n\tRList *find_list;\n\n\tif (p && *p == 'a') {\n\t\tidx = -1;\n\t} else {\n\t\tidx = r_cmd_java_get_input_num_value (core, p);\n\t}\n\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\tif (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIND_CP_CONST_IDX);\n\t\treturn true;\n\t}\n\tif (idx == 0) {\n\t\teprintf (\"[-] r_cmd_java: invalid CP Obj Index Supplied.\\n\");\n\t\treturn true;\n\t}\n\tfind_list = r_list_new ();\n\tfind_list->free = free;\n\t// XXX - this will break once RAnal moves to sdb\n\tr_list_foreach (core->anal->fcns, fn_iter, fcn) {\n\t\tr_list_foreach (fcn->bbs, bb_iter, bb) {\n\t\t\tchar op = bb->op_bytes[0];\n\t\t\tcp_res = NULL;\n\t\t\tswitch (op) {\n\t\t\tcase 0x12:\n\t\t\t\tcp_res = (idx == (ut16) -1) || (bb->op_bytes[1] == idx) ?\n\t\t\t\t\t\t\tR_NEW0(RCmdJavaCPResult) : NULL;\n\t\t\t\tif (cp_res) {\n\t\t\t\t\tcp_res->idx = bb->op_bytes[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\tcase 0x14:\n\t\t\t\tcp_res = (idx == (ut16) -1) || (R_BIN_JAVA_USHORT (bb->op_bytes, 1) == idx) ?\n\t\t\t\t\t\t\tR_NEW0(RCmdJavaCPResult) : NULL;\n\t\t\t\tif (cp_res) {\n\t\t\t\t\tcp_res->idx = R_BIN_JAVA_USHORT (bb->op_bytes, 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp_res) {\n\t\t\t\tcp_res->addr = bb->addr;\n\t\t\t\tcp_res->obj = r_bin_java_get_item_from_cp (obj, cp_res->idx);\n\t\t\t\tr_list_append (find_list, cp_res);\n\t\t\t}\n\t\t}\n\t}\n\tif (idx == (ut16) -1) {\n\t\tr_list_foreach (find_list, iter, cp_res) {\n\t\t\tconst char *t = ((RBinJavaCPTypeMetas *) cp_res->obj->metas->type_info)->name;\n\t\t\tr_cons_printf (\"@0x%\"PFMT64x\" idx = %d Type = %s\\n\", cp_res->addr, cp_res->idx, t);\n\t\t}\n\n\t} else {\n\t\tr_list_foreach (find_list, iter, cp_res) {\n\t\t\tr_cons_printf (\"@0x%\"PFMT64x\"\\n\", cp_res->addr);\n\t\t}\n\t}\n\tr_list_free (find_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_field_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tut16 idx = -1;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t} else if (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);\n\t\treturn true;\n\t}\n\n\tif (*(cmd) == 's' || *(cmd) == 'n') {\n\t\tidx = r_cmd_java_get_input_num_value (core, cmd+1);\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'c': return r_cmd_java_print_field_num_name (obj);\n\tcase 's': return r_cmd_java_print_field_summary (obj, idx);\n\tcase 'n': return r_cmd_java_print_field_name (obj, idx);\n\t}\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_method_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\tut16 idx = -1;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t} else if (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);\n\t\treturn false;\n\t}\n\n\tif (*(cmd) == 's' || *(cmd) == 'n') {\n\t\tidx = r_cmd_java_get_input_num_value (core, cmd+1);\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'c': return r_cmd_java_print_method_num_name (obj);\n\tcase 's': return r_cmd_java_print_method_summary (obj, idx);\n\tcase 'n': return r_cmd_java_print_method_name (obj, idx);\n\t}\n\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\tr_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd) {\n\tint res = false;\n\tut64 sz = UT64_MAX;\n\tut64 addr = UT64_MAX;\n\tut64 res_size = UT64_MAX,\n\tcur_fsz = r_io_fd_size (core->io, r_core_file_cur (core)->fd);\n\tut8 *tbuf, *buf = NULL;\n\tut32 init_size = (1 << 16);\n\tconst char *p = cmd ? r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : UT64_MAX;\n\n\t// TODO add a size parameter to the command to skip the guessing part.\n\n\tif (addr != UT64_MAX && sz == UT64_MAX) {\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\t\tIFDBG r_cons_printf (\"Attempting to calculate class file size @ : 0x%\"PFMT64x\".\\n\", addr);\n\t\tsz = cur_fsz < init_size ? cur_fsz : init_size;\n\t\twhile (sz <= cur_fsz) {\n\t\t\ttbuf = realloc (buf, sz);\n\t\t\tif (!tbuf) {\n\t\t\t\teprintf (\"Memory allocation failed.\\n\");\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = tbuf;\n\t\t\tut64 r_sz = r_io_read_at (core->io, addr, buf, sz) ? sz : 0LL;\n\t\t\t// check the return read on the read\n\t\t\tif (r_sz == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres_size = r_bin_java_calc_class_size (buf, sz);\n\t\t\t// if the data buffer contains a class starting\n\t\t\t// at address, then the res_size will be the size\n\t\t\t// if the r_sz is less than the sz, then we are near\n\t\t\t// the end of the core buffer, and there is no need\n\t\t\t// to continue trying to find the class size.\n\t\t\tif (res_size != UT64_MAX ||\n\t\t\t\tr_sz < sz) {\n\t\t\t\tres = r_sz < sz ? false : true;\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tsz += (1 << 16);\n\t\t\t}\n\t\t}\n\t\tif (res) {\n\t\t\tr_cons_printf (\"%\" PFMT64d, res_size);\n\t\t} else {\n\t\t\tr_cons_printf (\"-1\\n\");\n\t\t}\n\n\t\t//snprintf (cmd_buf, 50, fmt, num_acc_flag, addr);\n\t\t//res = r_core_cmd0(core, y);\n\t} else {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_SZ_IDX);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_isvalid (RCore *core, const char *cmd) {\n\tint res = false;\n\tut64 res_size = UT64_MAX;\n\tut8 *tbuf, *buf = NULL;\n\tut32 cur_fsz =  r_io_fd_size (core->io, r_core_file_cur (core)->fd);\n\tut64 sz = UT64_MAX;\n\tconst char *p = cmd ? r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\tut64 addr = UT64_MAX;\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : UT64_MAX;\n\n\t// TODO add a size parameter to the command to skip the guessing part.\n\n\tif (addr != UT64_MAX && sz == UT64_MAX) {\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\t\tIFDBG r_cons_printf (\"Attempting to calculate class file size @ : 0x%\"PFMT64x\".\\n\", addr);\n\n\t\twhile (sz <= cur_fsz) {\n\t\t\ttbuf = realloc (buf, sz);\n\t\t\tif (!tbuf) {\n\t\t\t\teprintf (\"Memory allocation failed.\\n\");\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = tbuf;\n\t\t\tut64 r_sz = r_io_read_at (core->io, addr, buf, sz) ? sz : 0LL;\n\t\t\t// check the return read on the read\n\t\t\tif (r_sz == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres_size = r_bin_java_calc_class_size (buf, sz);\n\t\t\t// if the data buffer contains a class starting\n\t\t\t// at address, then the res_size will be the size\n\t\t\t// if the r_sz is less than the sz, then we are near\n\t\t\t// the end of the core buffer, and there is no need\n\t\t\t// to continue trying to find the class size.\n\t\t\tif (res_size != UT64_MAX ||\n\t\t\t\tr_sz < sz) {\n\t\t\t\tres = r_sz < sz ? false : true;\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsz <<= 1;\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"%s\\n\", r_str_bool (res));\n\t} else {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + ISVALID_IDX);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tchar c_type = cmd && *cmd ? *cmd : 0;\n\tRBinJavaObj *obj = r_cmd_java_get_bin_obj (anal);\n\tut16 idx = r_cmd_java_get_input_num_value (core, cmd+2);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tIFDBG r_cons_printf (\"Ctype: %d (%c) RBinJavaObj points to: %p and the idx is (%s): %d\\n\", c_type, c_type, obj, cmd+2, idx);\n\tint res = false;\n\tif (idx > 0 && obj) {\n\t\tswitch (c_type) {\n\t\tcase 't': return r_cmd_java_resolve_cp_type (obj, idx);\n\t\tcase 'c': return r_cmd_java_resolve_cp_idx (obj, idx);\n\t\tcase 'e': return r_cmd_java_resolve_cp_idx_b64 (obj, idx);\n\t\tcase 'a': return r_cmd_java_resolve_cp_address (obj, idx);\n\t\tcase 's': return r_cmd_java_resolve_cp_summary (obj, idx);\n\t\tcase 'k': return r_cmd_java_resolve_cp_to_key (obj, idx);\n\t\t}\n\t} else if (obj && c_type == 'g') {\n\t\tfor (idx = 1; idx <=obj->cp_count; idx++) {\n\t\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, idx) ;\n\t\t\tchar * str = r_bin_java_resolve_cp_idx_type (obj, idx);\n\t\t\tr_cons_printf (\"CP_OBJ Type %d =  %s @ 0x%\"PFMT64x\"\\n\", idx, str, addr);\n\t\t\tfree (str);\n\t\t}\n\t\tres = true;\n\t} else if (obj && c_type == 'd') {\n\t\tfor (idx = 1; idx <= obj->cp_count; idx++) {\n\t\t\tr_cmd_java_resolve_cp_summary (obj, idx);\n\t\t}\n\t\tres = true;\n\t} else {\n\t\tif (!obj) {\n\t\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\t} else {\n\t\t\teprintf (\"[-] r_cmd_java: invalid cp index given, must idx > 1.\\n\");\n\t\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+RESOLVE_CP_IDX);\n\t\t}\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_get_all_access_flags_value (const char *cmd) {\n\tRList *the_list = NULL;\n\tRListIter *iter = NULL;\n\tchar *str = NULL;\n\n\tswitch (*(cmd)) {\n\tcase 'f': the_list = retrieve_all_field_access_string_and_value (); break;\n\tcase 'm': the_list = retrieve_all_method_access_string_and_value (); break;\n\tcase 'c': the_list = retrieve_all_class_access_string_and_value (); break;\n\t}\n\tif (!the_list) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);\n\t\treturn false;\n\t}\n\tswitch (*(cmd)) {\n\tcase 'f': r_cons_printf (\"[=] Fields Access Flags List\\n\"); break;\n\tcase 'm': r_cons_printf (\"[=] Methods Access Flags List\\n\"); break;\n\tcase 'c': r_cons_printf (\"[=] Class Access Flags List\\n\");; break;\n\t}\n\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_calc_flags (RCore *core, const char *cmd) {\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tint res = false;\n\n\tswitch (*(cmd)) {\n\t\tcase 'f': return r_cmd_java_print_field_access_flags_value (cmd+2);\n\t\tcase 'm': return r_cmd_java_print_method_access_flags_value (cmd+2);\n\t\tcase 'c': return r_cmd_java_print_class_access_flags_value (cmd+2);\n\t}\n\n\tif ( *(cmd) == 'l') {\n\t\tconst char *lcmd = *cmd+1 == ' '? cmd+2 : cmd+1;\n\t\tIFDBG eprintf (\"Seeing %s and accepting %s\\n\", cmd, lcmd);\n\t\tswitch (*(lcmd)) {\n\t\tcase 'f':\n\t\tcase 'm':\n\t\tcase 'c': res = r_cmd_java_get_all_access_flags_value (lcmd); break;\n\t\t}\n\t\t// Just print them all out\n\t\tif (res == false) {\n\t\t\tr_cmd_java_get_all_access_flags_value (\"c\");\n\t\t\tr_cmd_java_get_all_access_flags_value (\"m\");\n\t\t\tres = r_cmd_java_get_all_access_flags_value (\"f\");\n\t\t}\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_flags_str (RCore *core, const char *cmd) {\n\n\tint res = false;\n\tut32 flag_value = -1;\n\tconst char f_type = cmd ? *cmd : 0;\n\tconst char *p = cmd ? cmd + 2: NULL;\n\tchar * flags_str = NULL;\n\n\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str: ftype = %c, idx = %s\\n\", f_type, p);\n\tif (p) {\n\t\tflag_value = r_cmd_java_is_valid_input_num_value (core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t}\n\n\tif (p && f_type) {\n\t\tswitch (f_type) {\n\t\tcase 'm': flags_str = retrieve_method_access_string((ut16) flag_value); break;\n\t\tcase 'f': flags_str = retrieve_field_access_string((ut16) flag_value); break;\n\t\tcase 'c': flags_str = retrieve_class_method_access_string((ut16) flag_value); break;\n\t\tdefault: flags_str = NULL;\n\t\t}\n\t}\n\n\tif (flags_str) {\n\t\tswitch (f_type) {\n\t\tcase 'm': r_cons_printf (\"Method Access Flags String: \"); break;\n\t\tcase 'f': r_cons_printf (\"Field Access Flags String: \"); break;\n\t\tcase 'c': r_cons_printf (\"Class Access Flags String: \"); break;\n\t\t}\n\t\tr_cons_println (flags_str);\n\t\tfree (flags_str);\n\t\tres = true;\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd) {\n\n\tint res = false;\n\tut64 flag_value_addr = -1;\n\tut32 flag_value = -1;\n\tconst char f_type = cmd ? *r_cmd_java_consumetok (cmd, ' ', -1) : 0;\n\tconst char *p = cmd ? cmd + 2: NULL;\n\tchar * flags_str = NULL;\n\n\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str_at: ftype = 0x%02x, idx = %s\\n\", f_type, p);\n\tif (p) {\n\t\tflag_value = 0;\n\t\tut64 cur_offset = core->offset;\n\t\tflag_value_addr = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t\tr_io_read_at (core->io, flag_value_addr, (ut8 *) &flag_value, 2);\n\t\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str_at: read = 0x%04x\\n\", flag_value);\n\t\tif (cur_offset != core->offset) {\n\t\t\tr_core_seek (core, cur_offset - 2, 1);\n\t\t}\n\t\tflag_value = R_BIN_JAVA_USHORT (((ut8 *) &flag_value), 0);\n\t}\n\n\tif (p && f_type) {\n\t\tswitch (f_type) {\n\t\tcase 'm': flags_str = retrieve_method_access_string((ut16) flag_value); break;\n\t\tcase 'f': flags_str = retrieve_field_access_string((ut16) flag_value); break;\n\t\tcase 'c': flags_str = retrieve_class_method_access_string((ut16) flag_value); break;\n\t\tdefault: flags_str = NULL;\n\t\t}\n\t}\n\n\tif (flags_str) {\n\t\tswitch (f_type) {\n\t\tcase 'm': r_cons_printf (\"Method Access Flags String: \"); break;\n\t\tcase 'f': r_cons_printf (\"Field Access Flags String: \"); break;\n\t\tcase 'c': r_cons_printf (\"Class Access Flags String: \"); break;\n\t\t}\n\t\tr_cons_println (flags_str);\n\t\tfree (flags_str);\n\t\tres = true;\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\n\nstatic char r_cmd_java_is_valid_java_mcf (char b) {\n\tchar c = 0;\n\tswitch (b) {\n\t\tcase 'c':\n\t\tcase 'f':\n\t\tcase 'm': c = b;\n\t}\n\treturn c;\n}\n\nstatic int r_cmd_java_handle_set_flags (RCore * core, const char * input) {\n\t//#define SET_ACC_FLAGS_ARGS \"< c | m | f> <addr> <d | <s <flag value separated by space> >\"\n\tconst char *p = r_cmd_java_consumetok (input, ' ', -1);\n\tut64 addr = p && r_cmd_java_is_valid_input_num_value (core, p)\n\t\t? r_cmd_java_get_input_num_value (core, p) : -1;\n\tp = r_cmd_java_strtok (p + 1, ' ', -1);\n\tif (!p || !*p) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+SET_ACC_FLAGS_IDX);\n\t\treturn true;\n\t}\n\tconst char f_type = p && *p ? r_cmd_java_is_valid_java_mcf (*(++p)) : '?';\n\n\tint flag_value = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (flag_value == 16 && f_type == 'f') {\n\t\tflag_value = -1;\n\t}\n\tIFDBG r_cons_printf (\"Converting %s to flags\\n\",p);\n\n\tif (p) {\n\t\tp += 2;\n\t}\n\tif (flag_value == -1) {\n\t\tflag_value = r_cmd_java_is_valid_input_num_value (core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t}\n\tbool res = false;\n\tif (!input) {\n\t\teprintf (\"[-] r_cmd_java: no address provided .\\n\");\n\t\tres = true;\n\t} else if (addr == -1) {\n\t\teprintf (\"[-] r_cmd_java: no address provided .\\n\");\n\t\tres = true;\n\t} else if (f_type == '?' && flag_value == -1) {\n\t\teprintf (\"[-] r_cmd_java: no flag type provided .\\n\");\n\t\tres = true;\n\t}\n\n\tif (res) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + SET_ACC_FLAGS_IDX);\n\t\treturn res;\n\t}\n\n\tIFDBG r_cons_printf (\"Writing ftype '%c' to 0x%\"PFMT64x\", %s.\\n\", f_type, addr, p);\n\n\t// handling string based access flags (otherwise skip ahead)\n\tIFDBG r_cons_printf (\"Converting %s to flags\\n\",p);\n\tif (f_type && flag_value != -1) {\n\t\tswitch (f_type) {\n\t\tcase 'f': flag_value = r_bin_java_calculate_field_access_value (p); break;\n\t\tcase 'm': flag_value = r_bin_java_calculate_method_access_value (p); break;\n\t\tcase 'c': flag_value = r_bin_java_calculate_class_access_value (p); break;\n\t\tdefault: flag_value = -1;\n\t\t}\n\t}\n\tIFDBG r_cons_printf (\"Current args: (flag_value: 0x%04x addr: 0x%\"PFMT64x\")\\n.\", flag_value, addr, res);\n\tif (flag_value != -1) {\n\t\tres = r_cmd_java_set_acc_flags (core, addr, ((ut16) flag_value) & 0xffff);\n\t\tIFDBG r_cons_printf (\"Writing 0x%04x to 0x%\"PFMT64x\": %d.\", flag_value, addr, res);\n\t} else {\n\t\teprintf (\"[-] r_cmd_java: invalid flag value or type provided .\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + SET_ACC_FLAGS_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\t//IFDBG r_cons_printf (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\t//IFDBG r_cons_printf (\"Executing cmd: %s (%s)\\n\", JAVA_CMDS[i].name, cmd+5+JAVA_CMDS[i].name_len );\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}\n\n\nstatic int r_cmd_java_print_method_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_method_definitions (obj),\n\t\t\t* off_list = r_bin_java_get_method_offsets (obj);\n\tchar * str = NULL;\n\tut32 idx = 0, end = r_list_length (the_list);\n\n\twhile (idx < end) {\n\t\tut64 *addr = r_list_get_n (off_list, idx);\n\t\tstr = r_list_get_n (the_list, idx);\n\t\tr_cons_printf(\"%s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\tidx++;\n\t}\n\n\tr_list_free (the_list);\n\tr_list_free (off_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_field_definitions (obj),\n\t\t\t* off_list = r_bin_java_get_field_offsets (obj);\n\tchar * str = NULL;\n\tut32 idx = 0, end = r_list_length (the_list);\n\n\twhile (idx < end) {\n\t\tut64 *addr = r_list_get_n (off_list, idx);\n\t\tstr = r_list_get_n (the_list, idx);\n\t\tr_cons_printf(\"%s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\tidx++;\n\t}\n\n\tr_list_free (the_list);\n\tr_list_free (off_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_import_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_import_definitions (obj);\n\tchar * str = NULL;\n\tRListIter *iter;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_printf(\"import %s;\\n\", str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_all_definitions( RAnal *anal ) {\n\tRList * obj_list  = r_cmd_java_get_bin_obj_list (anal);\n\tRListIter *iter;\n\tRBinJavaObj *obj;\n\n\tif (!obj_list) {\n\t\treturn 1;\n\t}\n\tr_list_foreach (obj_list, iter, obj) {\n\t\tr_cmd_java_print_class_definitions (obj);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_print_json_definitions( RBinJavaObj *obj ) {\n\tDsoJsonObj *json_obj = r_bin_java_get_bin_obj_json (obj);\n\tchar *str = dso_json_obj_to_str (json_obj);\n\tdso_json_obj_del (json_obj); // XXX memleak\n\tr_cons_println (str);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_class_definitions( RBinJavaObj *obj ) {\n\tRList * the_fields = r_bin_java_get_field_definitions (obj),\n\t\t\t* the_methods = r_bin_java_get_method_definitions (obj),\n\t\t\t* the_imports = r_bin_java_get_import_definitions (obj),\n\t\t\t* the_moffsets = r_bin_java_get_method_offsets (obj),\n\t\t\t* the_foffsets = r_bin_java_get_field_offsets (obj);\n\n\tchar * class_name = r_bin_java_get_this_class_name(obj);\n\tchar * str = NULL;\n\n\tr_cmd_java_print_import_definitions (obj);\n\tr_cons_printf (\"\\nclass %s { // @0x%04\"PFMT64x\"\\n\", class_name, obj->loadaddr);\n\n\tif (the_fields && the_foffsets && r_list_length (the_fields) > 0) {\n\t\tr_cons_printf (\"\\n  // Fields defined in the class\\n\");\n\t\tut32 idx = 0, end = r_list_length (the_fields);\n\n\t\twhile (idx < end) {\n\t\t\tut64 *addr = r_list_get_n (the_foffsets, idx);\n\t\t\tstr = r_list_get_n (the_fields, idx);\n\t\t\tr_cons_printf(\"  %s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (the_methods && the_moffsets && r_list_length (the_methods) > 0) {\n\t\tr_cons_printf (\"\\n  // Methods defined in the class\\n\");\n\t\tut32 idx = 0, end = r_list_length (the_methods);\n\n\t\twhile (idx < end) {\n\t\t\tut64 *addr = r_list_get_n (the_moffsets, idx);\n\t\t\tstr = r_list_get_n (the_methods, idx);\n\t\t\tr_cons_printf (\"  %s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\t\tidx++;\n\t\t}\n\t}\n\tr_cons_printf (\"}\\n\");\n\n\tr_list_free (the_imports);\n\tr_list_free (the_fields);\n\tr_list_free (the_methods);\n\tr_list_free (the_foffsets);\n\tr_list_free (the_moffsets);\n\n\tfree(class_name);\n\treturn true;\n}\n\nstatic RList * r_cmd_java_get_bin_obj_list(RAnal *anal) {\n\tRBinJavaObj *bin_obj = (RBinJavaObj * ) r_cmd_java_get_bin_obj(anal);\n\t// See libr/bin/p/bin_java.c to see what is happening here.  The original intention\n\t// was to use a shared global db variable from shlr/java/class.c, but the\n\t// BIN_OBJS_ADDRS variable kept getting corrupted on Mac, so I (deeso) switched the\n\t// way the access to the db was taking place by using the bin_obj as a proxy back\n\t// to the BIN_OBJS_ADDRS which is instantiated in libr/bin/p/bin_java.c\n\t// not the easiest way to make sausage, but its getting made.\n\treturn  r_bin_java_get_bin_obj_list_thru_obj (bin_obj);\n}\n\nstatic RBinJavaObj * r_cmd_java_get_bin_obj(RAnal *anal) {\n\tRBin *b;\n\tint is_java;\n\tRBinPlugin *plugin;\n\tif (!anal || !anal->binb.bin) {\n\t\treturn NULL;\n\t}\n\tb = anal->binb.bin;\n\tif (!b->cur || !b->cur->o) {\n\t\treturn NULL;\n\t}\n\tplugin = b->cur->o->plugin;\n\tis_java = (plugin  && strcmp (plugin->name, \"java\") == 0) ? 1 : 0;\n\treturn is_java ? b->cur->o->bin_obj : NULL;\n}\n\nstatic int r_cmd_java_resolve_cp_idx (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_without_space (obj, idx);\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_cp_idx_type (obj, idx);\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_b64_encode (obj, idx) ;\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, idx) ;\n\t\tif (addr == -1) {\n\t\t\tr_cons_printf (\"Unable to resolve CP Object @ index: 0x%04x\\n\", idx);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", addr);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_cp_idx_to_string (obj, idx) ;\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\nstatic int r_cmd_java_resolve_cp_summary (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tr_bin_java_resolve_cp_idx_print_summary (obj, idx) ;\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_is_valid_input_num_value(RCore *core, const char *input_value){\n\tut64 value = input_value ? r_num_math (core->num, input_value) : 0;\n\treturn !(value == 0 && input_value && *input_value == '0');\n}\n\nstatic ut64 r_cmd_java_get_input_num_value(RCore *core, const char *input_value){\n\tut64 value = input_value ? r_num_math (core->num, input_value) : 0;\n\treturn value;\n}\n\nstatic int r_cmd_java_print_class_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_class_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags, result);\n\treturn true;\n}\nstatic int r_cmd_java_print_field_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_field_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags,  result);\n\treturn true;\n}\nstatic int r_cmd_java_print_method_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_method_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags,  result);\n\treturn true;\n}\n\nstatic int r_cmd_java_set_acc_flags (RCore *core, ut64 addr, ut16 num_acc_flag) {\n\tchar cmd_buf [50];\n\t//const char * fmt = \"wx %04x @ 0x%\"PFMT64x;\n\n\tint res = false;\n\t//ut64 cur_offset = core->offset;\n\tnum_acc_flag = R_BIN_JAVA_USHORT (((ut8*) &num_acc_flag), 0);\n\tres = r_core_write_at(core, addr, (const ut8 *)&num_acc_flag, 2);\n\tif (!res) {\n\t\teprintf (\"[X] r_cmd_java_set_acc_flags: Failed to write.\\n\");\n\t\treturn res;\n\t}\n\t//snprintf (cmd_buf, 50, fmt, num_acc_flag, addr);\n\t//res = r_core_cmd0(core, cmd_buf);\n\tres = true;\n\tIFDBG r_cons_printf (\"Executed cmd: %s == %d\\n\", cmd_buf, res);\n\t/*if (cur_offset != core->offset) {\n\t\tIFDBG eprintf (\"Ooops, write advanced the cursor, moving it back.\");\n\t\tr_core_seek (core, cur_offset-2, 1);\n\t}*/\n\treturn res;\n}\nstatic int r_cmd_java_print_field_num_name (RBinJavaObj *obj) {\n\tRList * the_list = r_bin_java_get_field_num_name (obj);\n\tchar * str;\n\tRListIter *iter = NULL;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_num_name (RBinJavaObj *obj) {\n\tRList * the_list = r_bin_java_get_method_num_name (obj);\n\tchar * str;\n\tRListIter *iter = NULL;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_summary (RBinJavaObj *obj, ut16 idx) {\n\tint res = r_bin_java_print_field_idx_summary (obj, idx);\n\tif (res == false) {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int UNUSED_FUNCTION(r_cmd_java_print_field_count) (RBinJavaObj *obj) {\n\tut32 res = r_bin_java_get_field_count (obj);\n\tr_cons_printf (\"%d\\n\", res);\n\tr_cons_flush();\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx) {\n\tchar * res = r_bin_java_get_field_name (obj, idx);\n\tif (res) {\n\t\tr_cons_println (res);\n\t} else {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t}\n\tfree (res);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_summary (RBinJavaObj *obj, ut16 idx) {\n\tint res = r_bin_java_print_method_idx_summary (obj, idx);\n\tif (res == false) {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int _(r_cmd_java_print_method_count)(RBinJavaObj *obj) {\n\tut32 res = r_bin_java_get_method_count (obj);\n\tr_cons_printf (\"%d\\n\", res);\n\tr_cons_flush();\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx) {\n\tchar * res = r_bin_java_get_method_name (obj, idx);\n\tif (res) {\n\t\tr_cons_println (res);\n\t} else {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t}\n\tfree (res);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = anal ? (RBinJavaObj *) r_cmd_java_get_bin_obj (anal) : NULL;\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;\n\tchar *name = NULL;\n\tut64 addr = -1, count = -1;\n\tint res = false;\n\n\tif (!bin) {\n\t\treturn res;\n\t} else if (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {\n\t\teprintf (\"Unable to access the current analysis, perform 'af' for function analysis.\\n\");\n\t\treturn true;\n\t}\n\n\tif (!p) {\n\t\treturn res;\n\t}\n\n\tn = *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tname = n && p && p != n ? malloc (n - p + 2) : NULL;\n\n\tif (!name) {\n\t\treturn res;\n\t}\n\n\tmemset (name, 0, n-p);\n\tmemcpy (name, p, n-p);\n\n\tp = r_cmd_java_strtok (p, ' ', -1);\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tp = r_cmd_java_strtok (p, ' ', -1);\n\tcount = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (name && count != (ut64) -1 && addr != (ut64) -1) {\n\t\t// find function at addr\n\n\t\t// find the start basic block\n\n\t\t// read the bytes\n\n\t\t// hexlify the bytes\n\n\t\t// set the name = bytes\n\n\t\t// print t\n\t}\n\tfree (name);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = anal ? (RBinJavaObj *) r_cmd_java_get_bin_obj (anal) : NULL;\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;\n\tchar  *classname=NULL, *name = NULL, *descriptor = NULL;\n\tut32 cn_sz = 0, n_sz = 0, d_sz = 0;\n\tint res = false;\n\n\tif (!bin) {\n\t\treturn res;\n\t}\n\tif (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {\n\t\teprintf (\"Unable to access the current analysis, perform 'af' for function analysis.\\n\");\n\t\treturn true;\n\t}\n\tif (!p) {\n\t\treturn res;\n\t}\n\n\tn = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tclassname = n && p && p != n ? malloc (n-p+1) : NULL;\n\tcn_sz = n && p ? n-p +1 : 0;\n\tif (!classname) {\n\t\treturn res;\n\t}\n\n\tsnprintf (classname, cn_sz, \"%s\", p);\n\t//memset (classname, 0, cn_sz);\n\t//memcpy (classname, p, n-p);\n\tp = n+1;\n\tn = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tname = n && p && p != n ? malloc (n-p+1) : NULL;\n\tn_sz = n && p ? n-p +1 : 0;\n\tif (!name) {\n\t\tfree (classname);\n\t\treturn res;\n\t}\n\tsnprintf (name, n_sz, \"%s\", p);\n\t//memset (name, 0, n_sz);\n\t//memcpy (name, p, n-p);\n\n\tp = n + 1;\n\tn =  p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tif (n) {\n\t\tdescriptor = n && p && p != n ? malloc (n-p+1) : NULL;\n\t\td_sz = n-p +1;\n\t} else if (p && *p) {\n\t\td_sz = strlen (p) + 1;\n\t\tdescriptor = d_sz > 1 ? malloc (d_sz) : NULL;\n\t}\n\n\tif (!descriptor) {\n\t\tfree (classname);\n\t\tfree (name);\n\t\treturn res;\n\t}\n\tsnprintf (descriptor, d_sz, \"%s\", p);\n\t//memset (descriptor, 0, d_sz);\n\t//memcpy (descriptor, p, n-p);\n\n\tr_cons_printf (\"Would be adding class name:%s, name: %s, descriptor: %s\\n\", classname, name, descriptor);\n\tfree (classname);\n\tfree (name);\n\tfree (descriptor);\n\tres = true;\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_print_exceptions (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tRListIter *exc_iter = NULL, *methods_iter=NULL;\n\tRBinJavaField *method;\n\tut64 func_addr = -1;\n\tRBinJavaExceptionEntry *exc_entry;\n\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL;\n\tfunc_addr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (!bin) {\n\t\treturn false;\n\t}\n\n\tr_list_foreach (bin->methods_list, methods_iter, method) {\n\t\tut64 start = r_bin_java_get_method_start(bin, method),\n\t\t\tend = r_bin_java_get_method_end(bin, method);\n\t\tut8 do_this_one = start <= func_addr && func_addr <= end;\tRList * exc_table = NULL;\n\t\tdo_this_one = func_addr == -1 ? 1 : do_this_one;\n\t\tif (!do_this_one) {\n\t\t\tcontinue;\n\t\t}\n\t\texc_table = r_bin_java_get_method_exception_table_with_addr (bin, start);\n\n\t\tif (r_list_length (exc_table) == 0){\n\t\t\tr_cons_printf (\" Exception table for %s @ 0x%\"PFMT64x\":\\n\", method->name, start);\n\t\t\tr_cons_printf (\" [ NONE ]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\" Exception table for %s (%d entries) @ 0x%\"PFMT64x\":\\n\", method->name,\n\t\t\t\tr_list_length (exc_table) , start);\n\t\t}\n\t\tr_list_foreach (exc_table, exc_iter, exc_entry) {\n\t\t\tchar *class_info = r_bin_java_resolve_without_space (bin, exc_entry->catch_type);\n\t\t\tr_cons_printf (\"  Catch Type: %d, %s @ 0x%\"PFMT64x\"\\n\", exc_entry->catch_type,\n\t\t\t\tclass_info, exc_entry->file_offset+6);\n\t\t\tr_cons_printf (\"  Start PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" @ 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->start_pc, exc_entry->start_pc+start, exc_entry->file_offset);\n\t\t\tr_cons_printf (\"  End PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->end_pc, exc_entry->end_pc+start, exc_entry->file_offset + 2);\n\t\t\tr_cons_printf (\"  Handler PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->handler_pc, exc_entry->handler_pc+start, exc_entry->file_offset+4);\n\t\t\tfree (class_info);\n\t\t}\n\t}\n\treturn true;\n}\n\n// PLUGIN Definition Info\nRCorePlugin r_core_plugin_java = {\n\t.name = \"java\",\n\t.desc = \"Suite of java commands, java help for more info\",\n\t.license = \"Apache\",\n\t.call = r_cmd_java_call,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_CORE,\n\t.data = &r_core_plugin_java,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - Apache - Copyright 2014-2019 - dso, pancake */\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_cmd.h>\n#include <r_core.h>\n#include <r_cons.h>\n#include <string.h>\n#include <r_anal.h>\n\n#include \"../../../shlr/java/ops.h\"\n#include \"../../../shlr/java/class.h\"\n#include \"../../../shlr/java/code.h\"\n#include \"../../../shlr/java/dsojson.h\"\n\n#define DO_THE_DBG 0\n#undef IFDBG\n#define IFDBG if (DO_THE_DBG)\n\n\ntypedef struct found_idx_t {\n\tut16 idx;\n\tut64 addr;\n\tconst RBinJavaCPTypeObj *obj;\n} RCmdJavaCPResult;\n\ntypedef int (*RCMDJavaCmdHandler) (RCore *core, const char *cmd);\n\nstatic const char * r_cmd_java_strtok (const char *str1, const char b, size_t len);\nstatic const char * r_cmd_java_consumetok (const char *str1, const char b, size_t len);\nstatic int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* buffer, ut64 len);\n\nstatic int r_cmd_java_print_json_definitions( RBinJavaObj *obj  );\nstatic int r_cmd_java_print_all_definitions( RAnal *anal );\nstatic int r_cmd_java_print_class_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_field_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_method_definitions( RBinJavaObj *obj );\nstatic int r_cmd_java_print_import_definitions( RBinJavaObj *obj );\n\nstatic int r_cmd_java_resolve_cp_idx (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_resolve_cp_summary (RBinJavaObj *obj, ut16 idx);\n\nstatic int r_cmd_java_print_class_access_flags_value( const char * flags );\nstatic int r_cmd_java_print_field_access_flags_value( const char * flags );\nstatic int r_cmd_java_print_method_access_flags_value( const char * flags );\nstatic int r_cmd_java_get_all_access_flags_value (const char *cmd);\n\nstatic int r_cmd_java_set_acc_flags (RCore *core, ut64 addr, ut16 num_acc_flag);\n\n#define _(x) UNUSED_FUNCTION(x)\nstatic int r_cmd_java_print_field_summary (RBinJavaObj *obj, ut16 idx);\nstatic int _(r_cmd_java_print_field_count) (RBinJavaObj *obj);\nstatic int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_print_field_num_name (RBinJavaObj *obj);\nstatic int r_cmd_java_print_method_summary (RBinJavaObj *obj, ut16 idx);\nstatic int _(r_cmd_java_print_method_count) (RBinJavaObj *obj);\nstatic int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx);\nstatic int r_cmd_java_print_method_num_name (RBinJavaObj *obj);\n\nstatic RBinJavaObj * r_cmd_java_get_bin_obj(RAnal *anal);\nstatic RList * r_cmd_java_get_bin_obj_list(RAnal *anal);\nstatic ut64 r_cmd_java_get_input_num_value(RCore *core, const char *input_value);\nstatic int r_cmd_java_is_valid_input_num_value(RCore *core, const char *input_value);\n\n\nstatic int r_cmd_java_call(void *user, const char *input);\nstatic int r_cmd_java_handle_help (RCore * core, const char * input);\nstatic int r_cmd_java_handle_set_flags (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_prototypes (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_resolve_cp (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_calc_flags (RCore * core, const char * cmd);\nstatic int r_cmd_java_handle_flags_str (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_field_info (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_method_info (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd);\n\nstatic RList * cpfind_float (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_double (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_long (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_int (RCore *core, RBinJavaObj *obj, const char *cmd);\nstatic RList * cpfind_str (RCore *core, RBinJavaObj *obj, const char *cmd);\n\nstatic int cpfind (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut16 idx, ut64 addr, const ut8* buf, const ut64 len);\nstatic int r_cmd_java_handle_replace_cp_value_float (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_long (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_int (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value_str (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr);\nstatic int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_replace_classname_value (RCore *core, const char *cmd);\nstatic char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len);\nstatic char * r_cmd_replace_name (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len);\nstatic int r_cmd_is_object_descriptor (const char *name, ut32 name_len);\nstatic ut32 r_cmd_get_num_classname_str_occ (const char * str, const char *match_me);\nstatic const char * r_cmd_get_next_classname_str (const char * str, const char *match_me);\n\nstatic int r_cmd_java_handle_summary_info (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd);\n\nstatic int r_cmd_java_handle_print_exceptions (RCore *core, const char *input);\nstatic int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input);\nstatic int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char *input);\n\nstatic int r_cmd_java_handle_isvalid (RCore *core, const char *cmd);\nstatic int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd);\n\ntypedef struct r_cmd_java_cms_t {\n\tconst char *name;\n\tconst char *args;\n\tconst char *desc;\n\tconst ut32 name_len;\n\tRCMDJavaCmdHandler handler;\n} RCmdJavaCmd;\n\n/* XXX : Most of those command arguments are absurd, must be reviewed + changed */\n\n#define CALC_SZ \"calc_sz\"\n#define CALC_SZ_ARGS \" <addr>\"\n#define CALC_SZ_DESC \"calculate class file size at location\"\n#define CALC_SZ_LEN 7\n\n#define ISVALID \"is_valid\"\n#define ISVALID_ARGS \" <addr> <sz>\"\n#define ISVALID_DESC \"check buffer to see if it is a valid class file\"\n#define ISVALID_LEN 8\n\n#define SET_ACC_FLAGS \"set_flags\"\n#define SET_ACC_FLAGS_ARGS \" [addr cmf <value>]\" //[<addr> <c | m | f> <num_flag_val>] | [<addr> < c | m | f> <flag value separated by space> ]\"\n#define SET_ACC_FLAGS_DESC \"set the access flags attributes for a field or method\"\n#define SET_ACC_FLAGS_LEN 9\n\n#define PROTOTYPES \"prototypes\"\n#define PROTOTYPES_ARGS \" <jaicmf>\" // < j | a | i | c | m | f>\n#define PROTOTYPES_DESC \"show in JSON, or All,Imports,Class,Methods,Fields\"\n#define PROTOTYPES_LEN 10\n\n#define RESOLVE_CP \"resolve_cp\"\n#define RESOLVE_CP_ARGS \" [<stecadg> idx]\"\n#define RESOLVE_CP_DESC \"cp type or value @ idx. Summary,Type,b64Encode,Const,Addr,Dump,Gsumarize\"\n//d = dump all,  g = summarize all, s = summary, a = address, t = type, c = get value, e = base64 enode the result\"\n#define RESOLVE_CP_LEN 10\n\n#define CALC_FLAGS \"calc_flags\"\n#define CALC_FLAGS_ARGS \" <lcfm> [visib.]\"\n//[ <l <[c|f|m]>> | <c [public,private,static...]>  | <f [public,private,static...]> | <m c [public,private,static...]>]\"\n#define CALC_FLAGS_DESC \"value from access flags: ListAll, flags, Class, Field, Method\"\n#define CALC_FLAGS_LEN 10\n\n#define FLAGS_STR_AT \"flags_str_at\"\n#define FLAGS_STR_AT_ARGS \" <cfm> [addr]\"\n#define FLAGS_STR_AT_DESC \"string value from access flags @ addr: Class, Field, Method\"\n#define FLAGS_STR_AT_LEN 12\n\n#define FLAGS_STR \"flags_str\"\n#define FLAGS_STR_ARGS \" [<cfm> <access>]\" //acc_flags_value>]\"\n#define FLAGS_STR_DESC \"string value for the flags number: Class, Field, Method\"\n#define FLAGS_STR_LEN 9\n\n#define METHOD_INFO \"m_info\"\n#define METHOD_INFO_ARGS \" [<p,c,s idx> | <n idx>]\"\n//#define METHOD_INFO_DESC \"method index info: c = dump methods and ord , s = dump of all meta-data, n = method\"\n#define METHOD_INFO_DESC \"method information at index (c:method+ord, s:metadata)\"\n#define METHOD_INFO_LEN 6\n\n#define FIELD_INFO \"f_info\"\n#define FIELD_INFO_ARGS \" [<p,c,s idx> | #idx]\"\n#define FIELD_INFO_DESC \"field information at index (c:field+ord, s:metadata)\"\n// : c = dump field and ord , s = dump of all meta-data, n = method\"\n#define FIELD_INFO_LEN 6\n\n#define HELP \"help\"\n#define HELP_DESC \"displays this message\"\n#define HELP_ARGS \"\"\n#define HELP_LEN 4\n\n#define FIND_CP_CONST \"find_cp_const\"\n#define FIND_CP_CONST_ARGS \" [a|#idx]\"\n#define FIND_CP_CONST_DESC \"find references to constant CP Object in code: AllReferences\"\n#define FIND_CP_CONST_LEN 13\n\n#define FIND_CP_VALUE \"find_cp_value\"\n#define FIND_CP_VALUE_ARGS \" [<silfd> V]\"\n#define FIND_CP_VALUE_DESC \"find references to CP constants by value\"\n#define FIND_CP_VALUE_LEN 13\n\n#define REPLACE_CP_VALUE \"replace_cp_value\"\n#define REPLACE_CP_VALUE_ARGS \" [<idx> V]\"\n#define REPLACE_CP_VALUE_DESC \"replace CP constants with value if the no resizing is required\"\n#define REPLACE_CP_VALUE_LEN 16\n\n#define REPLACE_CLASS_NAME \"replace_classname_value\"\n#define REPLACE_CLASS_NAME_ARGS \" <c> <nc>\"\n#define REPLACE_CLASS_NAME_DESC \"rename class name\" //\"replace CP constants with value if no resize needed\"\n#define REPLACE_CLASS_NAME_LEN 23\n\n#define RELOAD_BIN \"reload_bin\"\n#define RELOAD_BIN_ARGS \" addr [size]\"\n#define RELOAD_BIN_DESC \"reload and reanalyze the Java class file starting at address\"\n#define RELOAD_BIN_LEN 10\n\n#define SUMMARY_INFO \"summary\"\n#define SUMMARY_INFO_ARGS \"\"\n#define SUMMARY_INFO_DESC \"print summary information for the current java class file\"\n#define SUMMARY_INFO_LEN 7\n\n#define LIST_CODE_REFS \"lcr\"\n#define LIST_CODE_REFS_ARGS \" [addr]\"\n#define LIST_CODE_REFS_DESC \"list all references to fields and methods in code sections\"\n#define LIST_CODE_REFS_LEN 3\n\n#define PRINT_EXC \"exc\"\n#define PRINT_EXC_ARGS \" [<addr>]\"\n#define PRINT_EXC_DESC \"list all exceptions to fields and methods in code sections\"\n#define PRINT_EXC_LEN 3\n\n#define YARA_CODE_REFS \"yc_w_refs\"\n#define YARA_CODE_REFS_ARGS \" [name] [start] [count]\"\n#define YARA_CODE_REFS_DESC \"yara code bytes extraction with a name starting at <start> to <count>\"\n#define YARA_CODE_REFS_LEN 9\n\n#define INSERT_MREF \"i_mref\"\n#define INSERT_MREF_ARGS \" C M S\" //<meth> <desc>\" //descriptor in form of (Lpref;)Lref;\"\n#define INSERT_MREF_DESC \"add Method to Class with given method signature\" //append a method reference CP object to the end of the CP object array (creates all requisite objects)\"\n#define INSERT_MREF_LEN 6\n\n\nstatic RCmdJavaCmd JAVA_CMDS[] = {\n\t{HELP, HELP_ARGS, HELP_DESC, HELP_LEN, r_cmd_java_handle_help},\n\t{SET_ACC_FLAGS, SET_ACC_FLAGS_ARGS, SET_ACC_FLAGS_DESC, SET_ACC_FLAGS_LEN, r_cmd_java_handle_set_flags},\n\t{PROTOTYPES, PROTOTYPES_ARGS, PROTOTYPES_DESC, PROTOTYPES_LEN, r_cmd_java_handle_prototypes},\n\t{RESOLVE_CP, RESOLVE_CP_ARGS, RESOLVE_CP_DESC, RESOLVE_CP_LEN, r_cmd_java_handle_resolve_cp},\n\t{CALC_FLAGS, CALC_FLAGS_ARGS, CALC_FLAGS_DESC, CALC_FLAGS_LEN, r_cmd_java_handle_calc_flags},\n\t{FLAGS_STR_AT, FLAGS_STR_AT_ARGS, FLAGS_STR_AT_DESC, FLAGS_STR_AT_LEN, r_cmd_java_handle_flags_str_at},\n\t{FLAGS_STR, FLAGS_STR_ARGS, FLAGS_STR_DESC, FLAGS_STR_LEN, r_cmd_java_handle_flags_str},\n\t{METHOD_INFO, METHOD_INFO_ARGS, METHOD_INFO_DESC, METHOD_INFO_LEN, r_cmd_java_handle_method_info},\n\t{FIELD_INFO, FIELD_INFO_ARGS, FIELD_INFO_DESC, FIELD_INFO_LEN, r_cmd_java_handle_field_info},\n\t{FIND_CP_CONST, FIND_CP_CONST_ARGS, FIND_CP_CONST_DESC, FIND_CP_CONST_LEN, r_cmd_java_handle_find_cp_const},\n\t{FIND_CP_VALUE, FIND_CP_VALUE_ARGS, FIND_CP_VALUE_DESC, FIND_CP_VALUE_LEN, cpfind},\n\t{REPLACE_CP_VALUE, REPLACE_CP_VALUE_ARGS, REPLACE_CP_VALUE_DESC, REPLACE_CP_VALUE_LEN, r_cmd_java_handle_replace_cp_value},\n\t{REPLACE_CLASS_NAME, REPLACE_CLASS_NAME_ARGS, REPLACE_CLASS_NAME_DESC, REPLACE_CLASS_NAME_LEN, r_cmd_java_handle_replace_classname_value},\n\t{RELOAD_BIN, RELOAD_BIN_ARGS, RELOAD_BIN_DESC, RELOAD_BIN_LEN, r_cmd_java_handle_reload_bin},\n\t{SUMMARY_INFO, SUMMARY_INFO_ARGS, SUMMARY_INFO_DESC, SUMMARY_INFO_LEN, r_cmd_java_handle_summary_info},\n\t{PRINT_EXC, PRINT_EXC_ARGS, PRINT_EXC_DESC, PRINT_EXC_LEN, r_cmd_java_handle_print_exceptions},\n\t{YARA_CODE_REFS, YARA_CODE_REFS_ARGS, YARA_CODE_REFS_DESC, YARA_CODE_REFS_LEN, r_cmd_java_handle_yara_code_extraction_refs},\n\t{INSERT_MREF, INSERT_MREF_ARGS, INSERT_MREF_DESC, INSERT_MREF_LEN, r_cmd_java_handle_insert_method_ref},\n\t{CALC_SZ, CALC_SZ_ARGS, CALC_SZ_DESC, CALC_SZ_LEN, r_cmd_java_handle_calc_class_sz},\n\t{ISVALID, ISVALID_ARGS, ISVALID_DESC, ISVALID_LEN, r_cmd_java_handle_isvalid},\n};\n\nenum {\n\tHELP_IDX = 0,\n\tSET_ACC_FLAGS_IDX = 1,\n\tPROTOTYPES_IDX = 2,\n\tRESOLVE_CP_IDX = 3,\n\tCALC_FLAGS_IDX = 4,\n\tFLAGS_STR_AT_IDX = 5,\n\tFLAGS_STR_IDX = 6,\n\tMETHOD_INFO_IDX = 7,\n\tFIELD_INFO_IDX = 8,\n\tFIND_CP_CONST_IDX = 9,\n\tFIND_CP_VALUE_IDX = 10,\n\tREPLACE_CP_VALUE_IDX = 11,\n\tREPLACE_CLASS_NAME_IDX = 12,\n\tRELOAD_BIN_IDX = 13,\n\tSUMMARY_INFO_IDX = 14,\n\tLIST_CODE_REFS_IDX = 15,\n\tPRINT_EXC_IDX = 16,\n\tYARA_CODE_REFS_IDX = 17,\n\tINSERT_MREF_IDX = 18,\n\tCALC_SZ_IDX = 19,\n\tISVALID_IDX = 20,\n\tEND_CMDS = 21,\n};\n\nstatic ut8 _(r_cmd_java_obj_ref)(const char *name, const char *class_name, ut32 len) {\n\tif (!name || !class_name) {\n\t\treturn false;\n\t}\n\tif (strncmp (class_name, name, len)) {\n\t\treturn false;\n\t}\n\tif (*(name - 1) == 'L' && *(name + len) == ';') {\n\t\treturn true;\n\t}\n\tif (!strncmp (class_name, name, len) && !*(name + len)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char * r_cmd_get_next_classname_str (const char * str, const char *match_me) {\n\tconst char *result = NULL;\n\tut32 len = match_me && *match_me ? strlen (match_me) : 0;\n\tif (len && str && *str) {\n\t\tresult = str;\n\t\twhile (result && *result && (result - str < len)) {\n\t\t\tresult = strstr (result, match_me);\n\t\t\tif (result) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut32 r_cmd_get_num_classname_str_occ (const char * str, const char *match_me) {\n\tconst char *result = NULL;\n\tut32 len = match_me && *match_me ? strlen (match_me) : 0;\n\tut32 occ = 0;\n\n\tif (len == 0 || !str || !*str) {\n\t\treturn 0;\n\t}\n\tresult = str;\n\twhile (result && *result && (result - str < len)) {\n\t\tresult = strstr (result, match_me);\n\t\tif (result) {\n\t\t\tIFDBG eprintf (\"result: %s\\n\", result);\n\t\t\tresult+=len;\n\t\t\tocc++;\n\t\t}\n\t}\n\treturn occ;\n}\n\nstatic const char * r_cmd_java_consumetok (const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p != b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic const char * r_cmd_java_strtok (const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tIFDBG r_cons_printf (\"Looking for char (%c) in (%s) up to %d\\n\", b, p, len);\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tIFDBG r_cons_printf (\"Found? for char (%c) @ %d: (%s)\\n\", b, i, p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\tIFDBG r_cons_printf (\"Found? for char (%c) @ %d: (%s)\\n\", b, len, p);\n\treturn p;\n}\n\nstatic RAnal * get_anal (RCore *core) {\n\treturn core? core->anal: NULL;\n}\n\nstatic void r_cmd_java_print_cmd_help (RCmdJavaCmd *cmd) {\n\teprintf (\"[*] %s %s\\n[+] %s\\n\\n\", cmd->name, cmd->args, cmd->desc);\n}\n\nstatic int r_cmd_java_handle_help (RCore * core, const char * input) {\n\tut32 i = 0;\n\tconst char **help_msg = (const char**)malloc (sizeof(char *) * END_CMDS*4);\n\thelp_msg[0] = \"Usage:\";\n\thelp_msg[1] = \"java [cmd] [arg..] \";\n\thelp_msg[2] = r_core_plugin_java.desc;\n\tfor (i = 0; i <END_CMDS; i++) {\n\t\tRCmdJavaCmd *cmd = &JAVA_CMDS[i];\n\t\thelp_msg[3+(i*3)+0] = cmd->name;\n\t\thelp_msg[3+(i*3)+1] = cmd->args;\n\t\thelp_msg[3+(i*3)+2] = cmd->desc;\n\t}\n\thelp_msg[3+(i*3)] = NULL;\n\tr_core_cmd_help (core, help_msg);\n\tfree (help_msg);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_prototypes (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'm': return r_cmd_java_print_method_definitions (obj);\n\tcase 'f': return r_cmd_java_print_field_definitions (obj);\n\tcase 'i': return r_cmd_java_print_import_definitions (obj);\n\tcase 'c': return r_cmd_java_print_class_definitions (obj);\n\tcase 'a': return r_cmd_java_print_all_definitions (anal);\n\tcase 'j': return r_cmd_java_print_json_definitions (obj);\n\t}\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_summary_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\n\tr_cons_printf (\"Summary for %s:\\n\", obj->file);\n\tr_cons_printf (\"  Size 0x%\"PFMT64x\":\\n\", obj->size);\n\tr_cons_printf (\"  Constants  size: 0x%\"PFMT64x\" count: %d:\\n\", obj->cp_size, obj->cp_count);\n\tr_cons_printf (\"  Methods    size: 0x%\"PFMT64x\" count: %d:\\n\", obj->methods_size, obj->methods_count);\n\tr_cons_printf (\"  Fields     size: 0x%\"PFMT64x\" count: %d:\\n\", obj->fields_size, obj->fields_count);\n\tr_cons_printf (\"  Attributes size: 0x%\"PFMT64x\" count: %d:\\n\", obj->attrs_size, obj->attrs_count);\n\tr_cons_printf (\"  Interfaces size: 0x%\"PFMT64x\" count: %d:\\n\", obj->interfaces_size, obj->interfaces_count);\n\n\treturn true;\n}\n\nstatic int _(r_cmd_java_check_op_idx) (const ut8 *op_bytes, ut16 idx) {\n\treturn R_BIN_JAVA_USHORT (op_bytes, 0) == idx;\n}\n\n/* Find stuff in the constant pool */\nstatic RList * cpfind_double (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tdouble value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;\n\tif (value == 0.0 && !(cmd && cmd[0] == '0' && cmd[1] == '.' && cmd[2] == '0')) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 8, R_BIN_JAVA_CP_DOUBLE);\n}\n\nstatic RList * cpfind_float (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tfloat value = cmd && *cmd ? atof (cmd) : 0.0;\n\tif (value == 0.0 && !(cmd && cmd[0] == '0' && cmd[1] == '.' && cmd[2] == '0')) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 4, R_BIN_JAVA_CP_FLOAT);\n}\n\nstatic RList * cpfind_long (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tut64 value = r_cmd_java_get_input_num_value (core, cmd);\n\tif (!r_cmd_java_is_valid_input_num_value (core, cmd)) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 8, R_BIN_JAVA_CP_LONG);\n}\n\nstatic RList * cpfind_int (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tut32 value = (ut32) r_cmd_java_get_input_num_value (core, cmd);\n\tif (!r_cmd_java_is_valid_input_num_value (core, cmd)) {\n\t\treturn r_list_new ();\n\t}\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) &value, 4, R_BIN_JAVA_CP_INTEGER);\n}\n\nstatic RList * cpfind_str (RCore *core, RBinJavaObj *obj, const char *cmd) {\n\tif (!cmd) {\n\t\treturn r_list_new ();\n\t}\n\tIFDBG r_cons_printf (\"Looking for str: %s (%d)\\n\", cmd, strlen (cmd));\n\treturn r_bin_java_find_cp_const_by_val ( obj, (const ut8 *) cmd, strlen (cmd), R_BIN_JAVA_CP_UTF8);\n}\n\nstatic int cpfind (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tconst char *p = cmd;\n\tchar f_type = 0;\n\tRList *find_list = NULL;\n\tRListIter *iter;\n\tut32 *idx;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tif (p && *p) {\n\t\tp = r_cmd_java_consumetok (cmd, ' ', -1);\n\t\tf_type = *p;\n\t\tp+=2;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tswitch (f_type) {\n\tcase 's': find_list = cpfind_str (core, obj, p); break;\n\tcase 'i': find_list = cpfind_int (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'l': find_list = cpfind_long (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'f': find_list = cpfind_float (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tcase 'd': find_list = cpfind_double (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;\n\tdefault:\n\t\teprintf (\"[-] r_cmd_java: invalid java type to search for.\\n\");\n\t\treturn true;\n\t}\n\n\tr_list_foreach (find_list, iter, idx) {\n\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, (ut16) *idx);\n\t\tr_cons_printf (\"Offset: 0x%\"PFMT64x\" idx: %d\\n\", addr, *idx);\n\t}\n\tr_list_free (find_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* buffer, ut64 len) {\n\tif (!buffer || len < 10) {\n\t\treturn false;\n\t}\n\tint res = r_bin_java_load_bin (obj, buffer, len);\n\n\tif (res == true) {\n\t\t//RBinPlugin *cp = NULL;\n\t\tRBinPlugin *tmp;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->bin->plugins, iter, tmp) {\n\t\t\tif (!strncmp (\"java\", tmp->name, 4)) {\n\t\t\t\t//cp = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// XXX - this API is no longer valid.\n\t\t// need a function that will re-read bin bytes\n\t\t// and parse the file\n\t\t//if (cp) r_bin_update_items (core->bin, cp);\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut16 idx, ut64 addr, const ut8 * buf, const ut64 len) {\n\tint res = false;\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);\n\tut64 c_file_sz = r_io_size (core->io);\n\tut32 n_sz = 0, c_sz = obj ? r_bin_java_cp_get_size (obj, idx): -1;\n\tut8 * bytes = NULL;\n\n\tif (c_sz == -1) {\n\t\treturn res;\n\t}\n\n\tbytes = r_bin_java_cp_get_bytes (cp_obj->tag, &n_sz, buf, len);\n\n\tif (n_sz < c_sz) {\n\t\tres = r_core_shift_block (core, addr+c_sz, 0, (int)n_sz - (int)c_sz) &&\n\t\tr_io_resize(core->io, c_file_sz + (int) n_sz - (int) c_sz);\n\t} else if (n_sz > c_sz) {\n\t\tres = r_core_extend_at(core, addr,  (int)n_sz - (int)c_sz);\n\t} else {\n\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to resize the file correctly aborting.\\n\");\n\t\treturn res;\n\t}\n\n\tif (n_sz > 0 && bytes) {\n\t\tres = r_core_write_at(core, addr, (const ut8 *)bytes, n_sz) && r_core_seek (core, addr, 1);\n\t}\n\n\tif (res == false) {\n\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to write the bytes to the file correctly aborting.\\n\");\n\t\treturn res;\n\t}\n\n\tR_FREE (bytes);\n\n\tif (res == true) {\n\t\tut64 n_file_sz = 0;\n\t\tut8 * bin_buffer = NULL;\n\t\tres = r_io_use_fd (core->io, core->file->fd);\n\t\tn_file_sz = r_io_size (core->io);\n\t\tbin_buffer = n_file_sz > 0 ? malloc (n_file_sz) : NULL;\n\t\tif (bin_buffer) {\n\t\t\tmemset (bin_buffer, 0, n_file_sz);\n\t\t\tres = n_file_sz == r_io_read_at (core->io, obj->loadaddr,\n\t\t\t\tbin_buffer, n_file_sz) ? true : false;\n\t\t\tif (res == true) {\n\t\t\t\tres = r_cmd_java_reload_bin_from_buf (\n\t\t\t\t\tcore, obj, bin_buffer, n_file_sz);\n\t\t\t} else {\n\t\t\t\teprintf (\"[X] r_cmd_java_get_cp_bytes_and_write: Failed to read the file in aborted, bin reload.\\n\");\n\t\t\t}\n\t\t\tfree (bin_buffer);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_float (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tfloat value = cmd && *cmd ? atof (cmd) : 0.0;\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tdouble value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_long (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tut64 value = r_cmd_java_get_input_num_value (core, cmd);\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_int (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tut32 value = (ut32) r_cmd_java_get_input_num_value (core, cmd);\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value_str (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tint res = false;\n\tut32 len = cmd && *cmd ? strlen (cmd) : 0;\n\tif (len > 0 && cmd && *cmd == '\"') {\n\t\tcmd++;\n\t\tlen = cmd && *cmd ? strlen (cmd) : 0;\n\t}\n\tif (cmd && len > 0) {\n\t\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) cmd, len);\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tut16 idx = -1;\n\tut64 addr = 0;\n\tconst char *p = cmd;\n\tchar cp_type = 0;\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tif (p && *p) {\n\t\tp = r_cmd_java_consumetok (cmd, ' ', -1);\n\t\tif (r_cmd_java_is_valid_input_num_value (core, p)) {\n\t\t\tidx = r_cmd_java_get_input_num_value (core, p);\n\t\t\tp = r_cmd_java_strtok (p, ' ', strlen(p));\n\t\t}\n\t}\n\tif (idx == (ut16) -1 ) {\n\t\teprintf (\"[-] r_cmd_java: Invalid index value.\\n\");\n\t} else if (!obj) {\n\t\teprintf (\"[-] r_cmd_java: The current binary is not a Java Bin Object.\\n\");\n\t} else if (!p || (p && !*p)) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CP_VALUE_IDX);\n\t\treturn true;\n\t} else {\n\t\tcp_type = r_bin_java_resolve_cp_idx_tag(obj, idx);\n\t\taddr = r_bin_java_resolve_cp_idx_address (obj, idx);\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\t\tswitch (cp_type) {\n\t\tcase R_BIN_JAVA_CP_UTF8: return r_cmd_java_handle_replace_cp_value_str (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_INTEGER: return r_cmd_java_handle_replace_cp_value_int (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_LONG: return r_cmd_java_handle_replace_cp_value_long (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_FLOAT: return r_cmd_java_handle_replace_cp_value_float (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tcase R_BIN_JAVA_CP_DOUBLE: return r_cmd_java_handle_replace_cp_value_double (\n\t\t\tcore, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);\n\t\tdefault:\n\t\t\teprintf (\"[-] r_cmd_java: invalid java type to search for.\\n\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {\n\tconst char * fmt = \"L%s;\";\n\tchar *s_new_ref = s_new && replace_len > 0 ? malloc (3 + replace_len) : NULL;\n\tchar *s_old_ref = s_old && match_len > 0 ? malloc (3 + match_len) : NULL;\n\tchar *result = NULL;\n\t*res_len = 0;\n\tif (s_new_ref && s_old_ref) {\n\t\tsnprintf (s_new_ref, replace_len+3, fmt, s_new);\n\t\tsnprintf (s_old_ref, match_len+3, fmt, s_old);\n\t\tresult = r_cmd_replace_name (s_new_ref, replace_len+2, s_old_ref, match_len+2, buffer, buf_len, res_len);\n\t}\n\tfree (s_new_ref);\n\tfree (s_old_ref);\n\treturn result;\n}\n\nstatic int r_cmd_is_object_descriptor (const char *name, ut32 name_len) {\n\tint found_L = false, found_Semi = false;\n\tut32 idx = 0, L_pos = 0, Semi_pos = 0;\n\tconst char *p_name = name;\n\n\tfor (idx = 0, L_pos = 0; idx < name_len; idx++,p_name++) {\n\t\tif (*p_name == 'L') {\n\t\t\tfound_L = true;\n\t\t\tL_pos = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (idx = 0, Semi_pos = 0; idx < name_len; idx++,p_name++) {\n\t\tif (*p_name == ';') {\n\t\t\tfound_Semi = true;\n\t\t\tSemi_pos = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true ? found_L == found_Semi && found_L == true && L_pos < Semi_pos : false;\n}\n\nstatic char * r_cmd_replace_name (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {\n\tut32 num_occurrences = 0, i = 0;\n\tchar * result = NULL, *p_result = NULL;\n\n\tnum_occurrences = r_cmd_get_num_classname_str_occ (buffer, s_old);\n\t*res_len = 0;\n\tif (num_occurrences > 0 && replace_len > 0 && s_old) {\n\t\tut32 consumed = 0;\n\t\tconst char * next = r_cmd_get_next_classname_str (buffer+consumed, s_old);\n\t\tIFDBG r_cons_printf (\"Replacing \\\"%s\\\" with \\\"%s\\\" in: %s\\n\", s_old, s_new, buffer);\n\t\tresult = malloc (num_occurrences*replace_len + buf_len);\n\t\tmemset (result, 0, num_occurrences*replace_len + buf_len);\n\t\tp_result = result;\n\t\twhile (next && consumed < buf_len) {\n\t\t\t// replace up to next\n\t\t\tIFDBG r_cons_printf (\"next: \\\"%s\\\", len to: %d\\n\", next, next-buffer );\n\t\t\tfor (; buffer + consumed < next  && consumed < buf_len; consumed++, p_result++) {\n\t\t\t\t*p_result = *(buffer + consumed);\n\t\t\t\t(*res_len)++;\n\t\t\t}\n\n\t\t\tfor (i=0; i < replace_len; i++,  p_result++){\n\t\t\t\t*p_result = *(s_new + i);\n\t\t\t\t(*res_len)++;\n\t\t\t}\n\t\t\tconsumed += match_len;\n\t\t\tnext = r_cmd_get_next_classname_str (buffer+consumed, s_old);\n\t\t}\n\t\tIFDBG r_cons_printf (\"Found last occurrence of: \\\"%s\\\", remaining: %s\\n\", s_old, buffer+consumed);\n\t\tIFDBG r_cons_printf (\"result is: \\\"%s\\\"\\n\", result);\n\t\tfor (; consumed < buf_len; consumed++, p_result++, (*res_len)++) {\n\t\t\t*p_result = *(buffer + consumed);\n\t\t}\n\t\tIFDBG r_cons_printf (\"Old: %s\\nNew: %s\\n\", buffer, result);\n\t}\n\treturn result;\n}\n\n\nstatic int r_cmd_java_get_class_names_from_input (const char *input, char **class_name, ut32 *class_name_len, char **new_class_name, ut32 *new_class_name_len) {\n\tconst char *p = input;\n\n\tut32 cmd_sz = input && *input ? strlen (input) : 0;\n\tint res = false;\n\n\tif (!class_name || *class_name) {\n\t\treturn res;\n\t} else if (!new_class_name || *new_class_name) {\n\t\treturn res;\n\t} else if (!new_class_name_len || !class_name_len) {\n\t\treturn res;\n\t}\n\n\t*new_class_name = NULL;\n\t*class_name_len = 0;\n\n\tif (p && *p && cmd_sz > 1) {\n\t\tconst char *end;\n\t\tp = r_cmd_java_consumetok (p, ' ', cmd_sz);\n\t\tend = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\n\t\tif (p && end && p != end) {\n\t\t\t*class_name_len = end - p + 1;\n\t\t\t*class_name = malloc (*class_name_len);\n\t\t\tsnprintf (*class_name, *class_name_len, \"%s\", p );\n\t\t\tcmd_sz = *class_name_len - 1 < cmd_sz ? cmd_sz - *class_name_len : 0;\n\t\t}\n\n\t\tif (*class_name && cmd_sz > 0) {\n\t\t\tp = r_cmd_java_consumetok (end+1, ' ', cmd_sz);\n\t\t\tend = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\n\t\t\tif (!end && p && *p) {\n\t\t\t\tend = p + cmd_sz;\n\t\t\t}\n\n\t\t\tif (p && end && p != end) {\n\t\t\t\t*new_class_name_len = end - p + 1;\n\t\t\t\t*new_class_name = malloc (*new_class_name_len);\n\t\t\t\tsnprintf (*new_class_name, *new_class_name_len, \"%s\", p );\n\t\t\t\tres = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_replace_classname_value (RCore *core, const char *cmd) {\n\tRBinJavaObj *obj;\n\tchar *class_name = NULL, *new_class_name = NULL;\n\tut32 class_name_len = 0, new_class_name_len = 0;\n\tRAnal *anal = get_anal (core);\n\tconst char *p = cmd;\n\tint res = false;\n\tut16 idx = -1;\n\n\tif (!core || !anal || !cmd) {\n\t\treturn false;\n\t}\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", p);\n\tobj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tif (!obj) {\n\t\teprintf (\"The current binary is not a Java Bin Object.\\n\");\n\t\treturn true;\n\t}\n\tres = r_cmd_java_get_class_names_from_input (cmd, &class_name,\n\t\t&class_name_len, &new_class_name, &new_class_name_len);\n\n\tif (!res || !class_name || !new_class_name) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CLASS_NAME_IDX);\n\t\tfree (class_name);\n\t\tfree (new_class_name);\n\t\treturn true;\n\t}\n\tfor (idx = 1; idx <=obj->cp_count; idx++) {\n\t\tRBinJavaCPTypeObj* cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);\n\t\tchar *name = NULL;\n\t\tut8 * buffer = NULL;\n\t\tut32 buffer_sz = 0;\n\t\tut16 len = 0;\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_UTF8 &&\n\t\t\tcp_obj->info.cp_utf8.length && cp_obj->info.cp_utf8.length >= class_name_len-1) {\n\t\t\tut32 num_occurrences = 0;\n\t\t\tut64 addr = cp_obj->file_offset + cp_obj->loadaddr;\n\t\t\tbuffer = r_bin_java_cp_get_idx_bytes (obj, idx, &buffer_sz);\n\n\t\t\tif (!buffer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = R_BIN_JAVA_USHORT ( buffer, 1);\n\t\t\tname = malloc (len+3);\n\t\t\tmemcpy (name, buffer+3, len);\n\t\t\tname[len] = 0;\n\n\t\t\tnum_occurrences = r_cmd_get_num_classname_str_occ (name, class_name);\n\n\t\t\tif (num_occurrences > 0) {\n\t\t\t\t// perform inplace replacement\n\t\t\t\tut32 res_len = 0;\n\t\t\t\tchar * result = NULL;\n\n\t\t\t\tif (r_cmd_is_object_descriptor (name, len) == true) {\n\t\t\t\t\tresult = r_cmd_replace_name_def (new_class_name,\n\t\t\t\t\t\tnew_class_name_len-1, class_name,\n\t\t\t\t\t\tclass_name_len-1, name, len, &res_len);\n\t\t\t\t} else {\n\t\t\t\t\tresult = r_cmd_replace_name (new_class_name,\n\t\t\t\t\t\tnew_class_name_len-1, class_name,\n\t\t\t\t\t\tclass_name_len-1, name, len, &res_len);\n\t\t\t\t}\n\t\t\t\tif (result) {\n\t\t\t\t\tres = r_cmd_java_get_cp_bytes_and_write (\n\t\t\t\t\t\tcore, obj, idx, addr,\n\t\t\t\t\t\t(const ut8*)result, res_len);\n\t\t\t\t\tif  (res == false) {\n\t\t\t\t\t\teprintf (\"ERROR: r_cmd_java: Failed to write bytes or reload the binary.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (result);\n\t\t\t}\n\t\t\tfree (buffer);\n\t\t\tfree (name);\n\t\t}\n\n\t}\n\tfree (class_name);\n\tfree (new_class_name);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tconst char *p = cmd;\n\tut64 addr = 0LL; //cur_offset = core->offset, addr = 0;\n\tut64 buf_size = 0;\n\tut8 * buf = NULL;\n\tint res = false;\n\n\tif (*cmd == ' ') {\n\t\tp = r_cmd_java_consumetok (p, ' ', -1);\n\t}\n\tif (!*cmd) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+RELOAD_BIN_IDX);\n\t\treturn true;\n\t}\n\n\taddr = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\tif (*cmd == ' ') {\n\t\tp = r_cmd_java_consumetok (p, ' ', -1);\n\t}\n\tbuf_size = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\t// XXX this may cause problems cause the file we are looking at may not be the bin we want.\n\t// lets pretend it is for now\n\tif (buf_size == 0) {\n\t\tres = r_io_use_fd (core->io, core->file->fd);\n\t\tbuf_size = r_io_size (core->io);\n\t\tbuf = malloc (buf_size);\n\t\tmemset (buf, 0, buf_size);\n\t\tr_io_read_at (core->io, addr, buf, buf_size);\n\t}\n\tif (buf && obj) {\n\t\tres = r_cmd_java_reload_bin_from_buf (core, obj, buf, buf_size);\n\t}\n\tfree (buf);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd) {\n\tconst char *p = (cmd && *cmd == ' ')?  r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (get_anal (core));\n\tRAnalFunction *fcn = NULL;\n\tRAnalBlock *bb = NULL;\n\tRListIter *bb_iter, *fn_iter, *iter;\n\tRCmdJavaCPResult *cp_res = NULL;\n\tut16 idx = -1;\n\tRList *find_list;\n\n\tif (p && *p == 'a') {\n\t\tidx = -1;\n\t} else {\n\t\tidx = r_cmd_java_get_input_num_value (core, p);\n\t}\n\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t}\n\tif (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIND_CP_CONST_IDX);\n\t\treturn true;\n\t}\n\tif (idx == 0) {\n\t\teprintf (\"[-] r_cmd_java: invalid CP Obj Index Supplied.\\n\");\n\t\treturn true;\n\t}\n\tfind_list = r_list_new ();\n\tfind_list->free = free;\n\t// XXX - this will break once RAnal moves to sdb\n\tr_list_foreach (core->anal->fcns, fn_iter, fcn) {\n\t\tr_list_foreach (fcn->bbs, bb_iter, bb) {\n\t\t\tchar op = bb->op_bytes[0];\n\t\t\tcp_res = NULL;\n\t\t\tswitch (op) {\n\t\t\tcase 0x12:\n\t\t\t\tcp_res = (idx == (ut16) -1) || (bb->op_bytes[1] == idx) ?\n\t\t\t\t\t\t\tR_NEW0(RCmdJavaCPResult) : NULL;\n\t\t\t\tif (cp_res) {\n\t\t\t\t\tcp_res->idx = bb->op_bytes[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\tcase 0x14:\n\t\t\t\tcp_res = (idx == (ut16) -1) || (R_BIN_JAVA_USHORT (bb->op_bytes, 1) == idx) ?\n\t\t\t\t\t\t\tR_NEW0(RCmdJavaCPResult) : NULL;\n\t\t\t\tif (cp_res) {\n\t\t\t\t\tcp_res->idx = R_BIN_JAVA_USHORT (bb->op_bytes, 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp_res) {\n\t\t\t\tcp_res->addr = bb->addr;\n\t\t\t\tcp_res->obj = r_bin_java_get_item_from_cp (obj, cp_res->idx);\n\t\t\t\tr_list_append (find_list, cp_res);\n\t\t\t}\n\t\t}\n\t}\n\tif (idx == (ut16) -1) {\n\t\tr_list_foreach (find_list, iter, cp_res) {\n\t\t\tconst char *t = ((RBinJavaCPTypeMetas *) cp_res->obj->metas->type_info)->name;\n\t\t\tr_cons_printf (\"@0x%\"PFMT64x\" idx = %d Type = %s\\n\", cp_res->addr, cp_res->idx, t);\n\t\t}\n\n\t} else {\n\t\tr_list_foreach (find_list, iter, cp_res) {\n\t\t\tr_cons_printf (\"@0x%\"PFMT64x\"\\n\", cp_res->addr);\n\t\t}\n\t}\n\tr_list_free (find_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_field_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tut16 idx = -1;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t} else if (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);\n\t\treturn true;\n\t}\n\n\tif (*(cmd) == 's' || *(cmd) == 'n') {\n\t\tidx = r_cmd_java_get_input_num_value (core, cmd+1);\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'c': return r_cmd_java_print_field_num_name (obj);\n\tcase 's': return r_cmd_java_print_field_summary (obj, idx);\n\tcase 'n': return r_cmd_java_print_field_name (obj, idx);\n\t}\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\tr_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_method_info (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\tut16 idx = -1;\n\n\tif (!obj) {\n\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\treturn true;\n\t} else if (!cmd || !*cmd) {\n\t\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);\n\t\treturn false;\n\t}\n\n\tif (*(cmd) == 's' || *(cmd) == 'n') {\n\t\tidx = r_cmd_java_get_input_num_value (core, cmd+1);\n\t}\n\n\tswitch (*(cmd)) {\n\tcase 'c': return r_cmd_java_print_method_num_name (obj);\n\tcase 's': return r_cmd_java_print_method_summary (obj, idx);\n\tcase 'n': return r_cmd_java_print_method_name (obj, idx);\n\t}\n\n\tIFDBG r_cons_printf (\"Command is (%s)\\n\", cmd);\n\teprintf (\"[-] r_cmd_java: invalid command syntax.\\n\");\n\tr_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);\n\treturn false;\n}\n\nstatic int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd) {\n\tint res = false;\n\tut64 sz = UT64_MAX;\n\tut64 addr = UT64_MAX;\n\tut64 res_size = UT64_MAX,\n\tcur_fsz = r_io_fd_size (core->io, r_core_file_cur (core)->fd);\n\tut8 *tbuf, *buf = NULL;\n\tut32 init_size = (1 << 16);\n\tconst char *p = cmd ? r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : UT64_MAX;\n\n\t// TODO add a size parameter to the command to skip the guessing part.\n\n\tif (addr != UT64_MAX && sz == UT64_MAX) {\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\t\tIFDBG r_cons_printf (\"Attempting to calculate class file size @ : 0x%\"PFMT64x\".\\n\", addr);\n\t\tsz = cur_fsz < init_size ? cur_fsz : init_size;\n\t\twhile (sz <= cur_fsz) {\n\t\t\ttbuf = realloc (buf, sz);\n\t\t\tif (!tbuf) {\n\t\t\t\teprintf (\"Memory allocation failed.\\n\");\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = tbuf;\n\t\t\tut64 r_sz = r_io_read_at (core->io, addr, buf, sz) ? sz : 0LL;\n\t\t\t// check the return read on the read\n\t\t\tif (r_sz == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres_size = r_bin_java_calc_class_size (buf, sz);\n\t\t\t// if the data buffer contains a class starting\n\t\t\t// at address, then the res_size will be the size\n\t\t\t// if the r_sz is less than the sz, then we are near\n\t\t\t// the end of the core buffer, and there is no need\n\t\t\t// to continue trying to find the class size.\n\t\t\tif (res_size != UT64_MAX ||\n\t\t\t\tr_sz < sz) {\n\t\t\t\tres = r_sz < sz ? false : true;\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tsz += (1 << 16);\n\t\t\t}\n\t\t}\n\t\tif (res) {\n\t\t\tr_cons_printf (\"%\" PFMT64d, res_size);\n\t\t} else {\n\t\t\tr_cons_printf (\"-1\\n\");\n\t\t}\n\n\t\t//snprintf (cmd_buf, 50, fmt, num_acc_flag, addr);\n\t\t//res = r_core_cmd0(core, y);\n\t} else {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_SZ_IDX);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_isvalid (RCore *core, const char *cmd) {\n\tint res = false;\n\tut64 res_size = UT64_MAX;\n\tut8 *tbuf, *buf = NULL;\n\tut32 cur_fsz =  r_io_fd_size (core->io, r_core_file_cur (core)->fd);\n\tut64 sz = UT64_MAX;\n\tconst char *p = cmd ? r_cmd_java_consumetok (cmd, ' ', -1): NULL;\n\tut64 addr = UT64_MAX;\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : UT64_MAX;\n\n\t// TODO add a size parameter to the command to skip the guessing part.\n\n\tif (addr != UT64_MAX && sz == UT64_MAX) {\n\t\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\t\tIFDBG r_cons_printf (\"Attempting to calculate class file size @ : 0x%\"PFMT64x\".\\n\", addr);\n\n\t\twhile (sz <= cur_fsz) {\n\t\t\ttbuf = realloc (buf, sz);\n\t\t\tif (!tbuf) {\n\t\t\t\teprintf (\"Memory allocation failed.\\n\");\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = tbuf;\n\t\t\tut64 r_sz = r_io_read_at (core->io, addr, buf, sz) ? sz : 0LL;\n\t\t\t// check the return read on the read\n\t\t\tif (r_sz == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres_size = r_bin_java_calc_class_size (buf, sz);\n\t\t\t// if the data buffer contains a class starting\n\t\t\t// at address, then the res_size will be the size\n\t\t\t// if the r_sz is less than the sz, then we are near\n\t\t\t// the end of the core buffer, and there is no need\n\t\t\t// to continue trying to find the class size.\n\t\t\tif (res_size != UT64_MAX ||\n\t\t\t\tr_sz < sz) {\n\t\t\t\tres = r_sz < sz ? false : true;\n\t\t\t\tfree (buf);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsz <<= 1;\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"%s\\n\", r_str_bool (res));\n\t} else {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + ISVALID_IDX);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {\n\tRAnal *anal = get_anal (core);\n\tchar c_type = cmd && *cmd ? *cmd : 0;\n\tRBinJavaObj *obj = r_cmd_java_get_bin_obj (anal);\n\tut16 idx = r_cmd_java_get_input_num_value (core, cmd+2);\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tIFDBG r_cons_printf (\"Ctype: %d (%c) RBinJavaObj points to: %p and the idx is (%s): %d\\n\", c_type, c_type, obj, cmd+2, idx);\n\tint res = false;\n\tif (idx > 0 && obj) {\n\t\tswitch (c_type) {\n\t\tcase 't': return r_cmd_java_resolve_cp_type (obj, idx);\n\t\tcase 'c': return r_cmd_java_resolve_cp_idx (obj, idx);\n\t\tcase 'e': return r_cmd_java_resolve_cp_idx_b64 (obj, idx);\n\t\tcase 'a': return r_cmd_java_resolve_cp_address (obj, idx);\n\t\tcase 's': return r_cmd_java_resolve_cp_summary (obj, idx);\n\t\tcase 'k': return r_cmd_java_resolve_cp_to_key (obj, idx);\n\t\t}\n\t} else if (obj && c_type == 'g') {\n\t\tfor (idx = 1; idx <=obj->cp_count; idx++) {\n\t\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, idx) ;\n\t\t\tchar * str = r_bin_java_resolve_cp_idx_type (obj, idx);\n\t\t\tr_cons_printf (\"CP_OBJ Type %d =  %s @ 0x%\"PFMT64x\"\\n\", idx, str, addr);\n\t\t\tfree (str);\n\t\t}\n\t\tres = true;\n\t} else if (obj && c_type == 'd') {\n\t\tfor (idx = 1; idx <= obj->cp_count; idx++) {\n\t\t\tr_cmd_java_resolve_cp_summary (obj, idx);\n\t\t}\n\t\tres = true;\n\t} else {\n\t\tif (!obj) {\n\t\t\teprintf (\"[-] r_cmd_java: no valid java bins found.\\n\");\n\t\t} else {\n\t\t\teprintf (\"[-] r_cmd_java: invalid cp index given, must idx > 1.\\n\");\n\t\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+RESOLVE_CP_IDX);\n\t\t}\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_get_all_access_flags_value (const char *cmd) {\n\tRList *the_list = NULL;\n\tRListIter *iter = NULL;\n\tchar *str = NULL;\n\n\tswitch (*(cmd)) {\n\tcase 'f': the_list = retrieve_all_field_access_string_and_value (); break;\n\tcase 'm': the_list = retrieve_all_method_access_string_and_value (); break;\n\tcase 'c': the_list = retrieve_all_class_access_string_and_value (); break;\n\t}\n\tif (!the_list) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);\n\t\treturn false;\n\t}\n\tswitch (*(cmd)) {\n\tcase 'f': r_cons_printf (\"[=] Fields Access Flags List\\n\"); break;\n\tcase 'm': r_cons_printf (\"[=] Methods Access Flags List\\n\"); break;\n\tcase 'c': r_cons_printf (\"[=] Class Access Flags List\\n\");; break;\n\t}\n\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_calc_flags (RCore *core, const char *cmd) {\n\tIFDBG r_cons_printf (\"Function call made: %s\\n\", cmd);\n\tint res = false;\n\n\tswitch (*(cmd)) {\n\t\tcase 'f': return r_cmd_java_print_field_access_flags_value (cmd+2);\n\t\tcase 'm': return r_cmd_java_print_method_access_flags_value (cmd+2);\n\t\tcase 'c': return r_cmd_java_print_class_access_flags_value (cmd+2);\n\t}\n\n\tif ( *(cmd) == 'l') {\n\t\tconst char *lcmd = *cmd+1 == ' '? cmd+2 : cmd+1;\n\t\tIFDBG eprintf (\"Seeing %s and accepting %s\\n\", cmd, lcmd);\n\t\tswitch (*(lcmd)) {\n\t\tcase 'f':\n\t\tcase 'm':\n\t\tcase 'c': res = r_cmd_java_get_all_access_flags_value (lcmd); break;\n\t\t}\n\t\t// Just print them all out\n\t\tif (res == false) {\n\t\t\tr_cmd_java_get_all_access_flags_value (\"c\");\n\t\t\tr_cmd_java_get_all_access_flags_value (\"m\");\n\t\t\tres = r_cmd_java_get_all_access_flags_value (\"f\");\n\t\t}\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_flags_str (RCore *core, const char *cmd) {\n\n\tint res = false;\n\tut32 flag_value = -1;\n\tconst char f_type = cmd ? *cmd : 0;\n\tconst char *p = cmd ? cmd + 2: NULL;\n\tchar * flags_str = NULL;\n\n\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str: ftype = %c, idx = %s\\n\", f_type, p);\n\tif (p) {\n\t\tflag_value = r_cmd_java_is_valid_input_num_value (core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t}\n\n\tif (p && f_type) {\n\t\tswitch (f_type) {\n\t\tcase 'm': flags_str = retrieve_method_access_string((ut16) flag_value); break;\n\t\tcase 'f': flags_str = retrieve_field_access_string((ut16) flag_value); break;\n\t\tcase 'c': flags_str = retrieve_class_method_access_string((ut16) flag_value); break;\n\t\tdefault: flags_str = NULL;\n\t\t}\n\t}\n\n\tif (flags_str) {\n\t\tswitch (f_type) {\n\t\tcase 'm': r_cons_printf (\"Method Access Flags String: \"); break;\n\t\tcase 'f': r_cons_printf (\"Field Access Flags String: \"); break;\n\t\tcase 'c': r_cons_printf (\"Class Access Flags String: \"); break;\n\t\t}\n\t\tr_cons_println (flags_str);\n\t\tfree (flags_str);\n\t\tres = true;\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd) {\n\n\tint res = false;\n\tut64 flag_value_addr = -1;\n\tut32 flag_value = -1;\n\tconst char f_type = cmd ? *r_cmd_java_consumetok (cmd, ' ', -1) : 0;\n\tconst char *p = cmd ? cmd + 2: NULL;\n\tchar * flags_str = NULL;\n\n\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str_at: ftype = 0x%02x, idx = %s\\n\", f_type, p);\n\tif (p) {\n\t\tflag_value = 0;\n\t\tut64 cur_offset = core->offset;\n\t\tflag_value_addr = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t\tr_io_read_at (core->io, flag_value_addr, (ut8 *) &flag_value, 2);\n\t\tIFDBG r_cons_printf (\"r_cmd_java_handle_flags_str_at: read = 0x%04x\\n\", flag_value);\n\t\tif (cur_offset != core->offset) {\n\t\t\tr_core_seek (core, cur_offset - 2, 1);\n\t\t}\n\t\tflag_value = R_BIN_JAVA_USHORT (((ut8 *) &flag_value), 0);\n\t}\n\n\tif (p && f_type) {\n\t\tswitch (f_type) {\n\t\tcase 'm': flags_str = retrieve_method_access_string((ut16) flag_value); break;\n\t\tcase 'f': flags_str = retrieve_field_access_string((ut16) flag_value); break;\n\t\tcase 'c': flags_str = retrieve_class_method_access_string((ut16) flag_value); break;\n\t\tdefault: flags_str = NULL;\n\t\t}\n\t}\n\n\tif (flags_str) {\n\t\tswitch (f_type) {\n\t\tcase 'm': r_cons_printf (\"Method Access Flags String: \"); break;\n\t\tcase 'f': r_cons_printf (\"Field Access Flags String: \"); break;\n\t\tcase 'c': r_cons_printf (\"Class Access Flags String: \"); break;\n\t\t}\n\t\tr_cons_println (flags_str);\n\t\tfree (flags_str);\n\t\tres = true;\n\t}\n\tif (res == false) {\n\t\teprintf (\"[-] r_cmd_java: incorrect syntax for the flags calculation.\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\n\nstatic char r_cmd_java_is_valid_java_mcf (char b) {\n\tchar c = 0;\n\tswitch (b) {\n\t\tcase 'c':\n\t\tcase 'f':\n\t\tcase 'm': c = b;\n\t}\n\treturn c;\n}\n\nstatic int r_cmd_java_handle_set_flags (RCore * core, const char * input) {\n\t//#define SET_ACC_FLAGS_ARGS \"< c | m | f> <addr> <d | <s <flag value separated by space> >\"\n\tconst char *p = r_cmd_java_consumetok (input, ' ', -1);\n\tut64 addr = p && r_cmd_java_is_valid_input_num_value (core, p)\n\t\t? r_cmd_java_get_input_num_value (core, p) : -1;\n\tp = r_cmd_java_strtok (p + 1, ' ', -1);\n\tif (!p || !*p) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS+SET_ACC_FLAGS_IDX);\n\t\treturn true;\n\t}\n\tconst char f_type = p && *p ? r_cmd_java_is_valid_java_mcf (*(++p)) : '?';\n\n\tint flag_value = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (flag_value == 16 && f_type == 'f') {\n\t\tflag_value = -1;\n\t}\n\tIFDBG r_cons_printf (\"Converting %s to flags\\n\",p);\n\n\tif (p) {\n\t\tp += 2;\n\t}\n\tif (flag_value == -1) {\n\t\tflag_value = r_cmd_java_is_valid_input_num_value (core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\t}\n\tbool res = false;\n\tif (!input) {\n\t\teprintf (\"[-] r_cmd_java: no address provided .\\n\");\n\t\tres = true;\n\t} else if (addr == -1) {\n\t\teprintf (\"[-] r_cmd_java: no address provided .\\n\");\n\t\tres = true;\n\t} else if (f_type == '?' && flag_value == -1) {\n\t\teprintf (\"[-] r_cmd_java: no flag type provided .\\n\");\n\t\tres = true;\n\t}\n\n\tif (res) {\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + SET_ACC_FLAGS_IDX);\n\t\treturn res;\n\t}\n\n\tIFDBG r_cons_printf (\"Writing ftype '%c' to 0x%\"PFMT64x\", %s.\\n\", f_type, addr, p);\n\n\t// handling string based access flags (otherwise skip ahead)\n\tIFDBG r_cons_printf (\"Converting %s to flags\\n\",p);\n\tif (f_type && flag_value != -1) {\n\t\tswitch (f_type) {\n\t\tcase 'f': flag_value = r_bin_java_calculate_field_access_value (p); break;\n\t\tcase 'm': flag_value = r_bin_java_calculate_method_access_value (p); break;\n\t\tcase 'c': flag_value = r_bin_java_calculate_class_access_value (p); break;\n\t\tdefault: flag_value = -1;\n\t\t}\n\t}\n\tIFDBG r_cons_printf (\"Current args: (flag_value: 0x%04x addr: 0x%\"PFMT64x\")\\n.\", flag_value, addr, res);\n\tif (flag_value != -1) {\n\t\tres = r_cmd_java_set_acc_flags (core, addr, ((ut16) flag_value) & 0xffff);\n\t\tIFDBG r_cons_printf (\"Writing 0x%04x to 0x%\"PFMT64x\": %d.\", flag_value, addr, res);\n\t} else {\n\t\teprintf (\"[-] r_cmd_java: invalid flag value or type provided .\\n\");\n\t\tr_cmd_java_print_cmd_help (JAVA_CMDS + SET_ACC_FLAGS_IDX);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS - 1; i++) {\n\t\t//IFDBG r_cons_printf (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\t//IFDBG r_cons_printf (\"Executing cmd: %s (%s)\\n\", JAVA_CMDS[i].name, cmd+5+JAVA_CMDS[i].name_len );\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}\n\n\nstatic int r_cmd_java_print_method_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_method_definitions (obj),\n\t\t\t* off_list = r_bin_java_get_method_offsets (obj);\n\tchar * str = NULL;\n\tut32 idx = 0, end = r_list_length (the_list);\n\n\twhile (idx < end) {\n\t\tut64 *addr = r_list_get_n (off_list, idx);\n\t\tstr = r_list_get_n (the_list, idx);\n\t\tr_cons_printf(\"%s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\tidx++;\n\t}\n\n\tr_list_free (the_list);\n\tr_list_free (off_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_field_definitions (obj),\n\t\t\t* off_list = r_bin_java_get_field_offsets (obj);\n\tchar * str = NULL;\n\tut32 idx = 0, end = r_list_length (the_list);\n\n\twhile (idx < end) {\n\t\tut64 *addr = r_list_get_n (off_list, idx);\n\t\tstr = r_list_get_n (the_list, idx);\n\t\tr_cons_printf(\"%s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\tidx++;\n\t}\n\n\tr_list_free (the_list);\n\tr_list_free (off_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_import_definitions ( RBinJavaObj *obj ) {\n\tRList * the_list = r_bin_java_get_import_definitions (obj);\n\tchar * str = NULL;\n\tRListIter *iter;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_printf(\"import %s;\\n\", str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_all_definitions( RAnal *anal ) {\n\tRList * obj_list  = r_cmd_java_get_bin_obj_list (anal);\n\tRListIter *iter;\n\tRBinJavaObj *obj;\n\n\tif (!obj_list) {\n\t\treturn 1;\n\t}\n\tr_list_foreach (obj_list, iter, obj) {\n\t\tr_cmd_java_print_class_definitions (obj);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_print_json_definitions( RBinJavaObj *obj ) {\n\tDsoJsonObj *json_obj = r_bin_java_get_bin_obj_json (obj);\n\tchar *str = dso_json_obj_to_str (json_obj);\n\tdso_json_obj_del (json_obj); // XXX memleak\n\tr_cons_println (str);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_class_definitions( RBinJavaObj *obj ) {\n\tRList * the_fields = r_bin_java_get_field_definitions (obj),\n\t\t\t* the_methods = r_bin_java_get_method_definitions (obj),\n\t\t\t* the_imports = r_bin_java_get_import_definitions (obj),\n\t\t\t* the_moffsets = r_bin_java_get_method_offsets (obj),\n\t\t\t* the_foffsets = r_bin_java_get_field_offsets (obj);\n\n\tchar * class_name = r_bin_java_get_this_class_name(obj);\n\tchar * str = NULL;\n\n\tr_cmd_java_print_import_definitions (obj);\n\tr_cons_printf (\"\\nclass %s { // @0x%04\"PFMT64x\"\\n\", class_name, obj->loadaddr);\n\n\tif (the_fields && the_foffsets && r_list_length (the_fields) > 0) {\n\t\tr_cons_printf (\"\\n  // Fields defined in the class\\n\");\n\t\tut32 idx = 0, end = r_list_length (the_fields);\n\n\t\twhile (idx < end) {\n\t\t\tut64 *addr = r_list_get_n (the_foffsets, idx);\n\t\t\tstr = r_list_get_n (the_fields, idx);\n\t\t\tr_cons_printf(\"  %s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (the_methods && the_moffsets && r_list_length (the_methods) > 0) {\n\t\tr_cons_printf (\"\\n  // Methods defined in the class\\n\");\n\t\tut32 idx = 0, end = r_list_length (the_methods);\n\n\t\twhile (idx < end) {\n\t\t\tut64 *addr = r_list_get_n (the_moffsets, idx);\n\t\t\tstr = r_list_get_n (the_methods, idx);\n\t\t\tr_cons_printf (\"  %s; // @0x%04\"PFMT64x\"\\n\", str, *addr);\n\t\t\tidx++;\n\t\t}\n\t}\n\tr_cons_printf (\"}\\n\");\n\n\tr_list_free (the_imports);\n\tr_list_free (the_fields);\n\tr_list_free (the_methods);\n\tr_list_free (the_foffsets);\n\tr_list_free (the_moffsets);\n\n\tfree(class_name);\n\treturn true;\n}\n\nstatic RList * r_cmd_java_get_bin_obj_list(RAnal *anal) {\n\tRBinJavaObj *bin_obj = (RBinJavaObj * ) r_cmd_java_get_bin_obj(anal);\n\t// See libr/bin/p/bin_java.c to see what is happening here.  The original intention\n\t// was to use a shared global db variable from shlr/java/class.c, but the\n\t// BIN_OBJS_ADDRS variable kept getting corrupted on Mac, so I (deeso) switched the\n\t// way the access to the db was taking place by using the bin_obj as a proxy back\n\t// to the BIN_OBJS_ADDRS which is instantiated in libr/bin/p/bin_java.c\n\t// not the easiest way to make sausage, but its getting made.\n\treturn  r_bin_java_get_bin_obj_list_thru_obj (bin_obj);\n}\n\nstatic RBinJavaObj * r_cmd_java_get_bin_obj(RAnal *anal) {\n\tRBin *b;\n\tint is_java;\n\tRBinPlugin *plugin;\n\tif (!anal || !anal->binb.bin) {\n\t\treturn NULL;\n\t}\n\tb = anal->binb.bin;\n\tif (!b->cur || !b->cur->o) {\n\t\treturn NULL;\n\t}\n\tplugin = b->cur->o->plugin;\n\tis_java = (plugin  && strcmp (plugin->name, \"java\") == 0) ? 1 : 0;\n\treturn is_java ? b->cur->o->bin_obj : NULL;\n}\n\nstatic int r_cmd_java_resolve_cp_idx (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_without_space (obj, idx);\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_cp_idx_type (obj, idx);\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_b64_encode (obj, idx) ;\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tut64 addr = r_bin_java_resolve_cp_idx_address (obj, idx) ;\n\t\tif (addr == -1) {\n\t\t\tr_cons_printf (\"Unable to resolve CP Object @ index: 0x%04x\\n\", idx);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", addr);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tchar * str = r_bin_java_resolve_cp_idx_to_string (obj, idx) ;\n\t\tr_cons_println (str);\n\t\tfree (str);\n\t}\n\treturn true;\n}\nstatic int r_cmd_java_resolve_cp_summary (RBinJavaObj *obj, ut16 idx) {\n\tif (obj && idx){\n\t\tr_bin_java_resolve_cp_idx_print_summary (obj, idx) ;\n\t}\n\treturn true;\n}\n\nstatic int r_cmd_java_is_valid_input_num_value(RCore *core, const char *input_value){\n\tut64 value = input_value ? r_num_math (core->num, input_value) : 0;\n\treturn !(value == 0 && input_value && *input_value == '0');\n}\n\nstatic ut64 r_cmd_java_get_input_num_value(RCore *core, const char *input_value){\n\tut64 value = input_value ? r_num_math (core->num, input_value) : 0;\n\treturn value;\n}\n\nstatic int r_cmd_java_print_class_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_class_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags, result);\n\treturn true;\n}\nstatic int r_cmd_java_print_field_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_field_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags,  result);\n\treturn true;\n}\nstatic int r_cmd_java_print_method_access_flags_value( const char * flags ){\n\tut16 result = r_bin_java_calculate_method_access_value (flags);\n\tr_cons_printf (\"Access Value for %s = 0x%04x\\n\", flags,  result);\n\treturn true;\n}\n\nstatic int r_cmd_java_set_acc_flags (RCore *core, ut64 addr, ut16 num_acc_flag) {\n\tchar cmd_buf [50];\n\t//const char * fmt = \"wx %04x @ 0x%\"PFMT64x;\n\n\tint res = false;\n\t//ut64 cur_offset = core->offset;\n\tnum_acc_flag = R_BIN_JAVA_USHORT (((ut8*) &num_acc_flag), 0);\n\tres = r_core_write_at(core, addr, (const ut8 *)&num_acc_flag, 2);\n\tif (!res) {\n\t\teprintf (\"[X] r_cmd_java_set_acc_flags: Failed to write.\\n\");\n\t\treturn res;\n\t}\n\t//snprintf (cmd_buf, 50, fmt, num_acc_flag, addr);\n\t//res = r_core_cmd0(core, cmd_buf);\n\tres = true;\n\tIFDBG r_cons_printf (\"Executed cmd: %s == %d\\n\", cmd_buf, res);\n\t/*if (cur_offset != core->offset) {\n\t\tIFDBG eprintf (\"Ooops, write advanced the cursor, moving it back.\");\n\t\tr_core_seek (core, cur_offset-2, 1);\n\t}*/\n\treturn res;\n}\nstatic int r_cmd_java_print_field_num_name (RBinJavaObj *obj) {\n\tRList * the_list = r_bin_java_get_field_num_name (obj);\n\tchar * str;\n\tRListIter *iter = NULL;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_num_name (RBinJavaObj *obj) {\n\tRList * the_list = r_bin_java_get_method_num_name (obj);\n\tchar * str;\n\tRListIter *iter = NULL;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_summary (RBinJavaObj *obj, ut16 idx) {\n\tint res = r_bin_java_print_field_idx_summary (obj, idx);\n\tif (res == false) {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int UNUSED_FUNCTION(r_cmd_java_print_field_count) (RBinJavaObj *obj) {\n\tut32 res = r_bin_java_get_field_count (obj);\n\tr_cons_printf (\"%d\\n\", res);\n\tr_cons_flush();\n\treturn true;\n}\n\nstatic int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx) {\n\tchar * res = r_bin_java_get_field_name (obj, idx);\n\tif (res) {\n\t\tr_cons_println (res);\n\t} else {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t}\n\tfree (res);\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_summary (RBinJavaObj *obj, ut16 idx) {\n\tint res = r_bin_java_print_method_idx_summary (obj, idx);\n\tif (res == false) {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nstatic int _(r_cmd_java_print_method_count)(RBinJavaObj *obj) {\n\tut32 res = r_bin_java_get_method_count (obj);\n\tr_cons_printf (\"%d\\n\", res);\n\tr_cons_flush();\n\treturn true;\n}\n\nstatic int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx) {\n\tchar * res = r_bin_java_get_method_name (obj, idx);\n\tif (res) {\n\t\tr_cons_println (res);\n\t} else {\n\t\teprintf (\"Error: Field or Method @ index (%d) not found in the RBinJavaObj.\\n\", idx);\n\t}\n\tfree (res);\n\treturn true;\n}\n\nstatic int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = anal ? (RBinJavaObj *) r_cmd_java_get_bin_obj (anal) : NULL;\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;\n\tchar *name = NULL;\n\tut64 addr = -1, count = -1;\n\tint res = false;\n\n\tif (!bin) {\n\t\treturn res;\n\t} else if (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {\n\t\teprintf (\"Unable to access the current analysis, perform 'af' for function analysis.\\n\");\n\t\treturn true;\n\t}\n\n\tif (!p) {\n\t\treturn res;\n\t}\n\n\tn = *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tname = n && p && p != n ? malloc (n - p + 2) : NULL;\n\n\tif (!name) {\n\t\treturn res;\n\t}\n\n\tmemset (name, 0, n-p);\n\tmemcpy (name, p, n-p);\n\n\tp = r_cmd_java_strtok (p, ' ', -1);\n\taddr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tp = r_cmd_java_strtok (p, ' ', -1);\n\tcount = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (name && count != (ut64) -1 && addr != (ut64) -1) {\n\t\t// find function at addr\n\n\t\t// find the start basic block\n\n\t\t// read the bytes\n\n\t\t// hexlify the bytes\n\n\t\t// set the name = bytes\n\n\t\t// print t\n\t}\n\tfree (name);\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = anal ? (RBinJavaObj *) r_cmd_java_get_bin_obj (anal) : NULL;\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;\n\tchar  *classname=NULL, *name = NULL, *descriptor = NULL;\n\tut32 cn_sz = 0, n_sz = 0, d_sz = 0;\n\tint res = false;\n\n\tif (!bin) {\n\t\treturn res;\n\t}\n\tif (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {\n\t\teprintf (\"Unable to access the current analysis, perform 'af' for function analysis.\\n\");\n\t\treturn true;\n\t}\n\tif (!p) {\n\t\treturn res;\n\t}\n\n\tn = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tclassname = n && p && p != n ? malloc (n-p+1) : NULL;\n\tcn_sz = n && p ? n-p +1 : 0;\n\tif (!classname) {\n\t\treturn res;\n\t}\n\n\tsnprintf (classname, cn_sz, \"%s\", p);\n\t//memset (classname, 0, cn_sz);\n\t//memcpy (classname, p, n-p);\n\tp = n+1;\n\tn = p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tname = n && p && p != n ? malloc (n-p+1) : NULL;\n\tn_sz = n && p ? n-p +1 : 0;\n\tif (!name) {\n\t\tfree (classname);\n\t\treturn res;\n\t}\n\tsnprintf (name, n_sz, \"%s\", p);\n\t//memset (name, 0, n_sz);\n\t//memcpy (name, p, n-p);\n\n\tp = n + 1;\n\tn =  p && *p ? r_cmd_java_strtok (p, ' ', -1) : NULL;\n\tif (n) {\n\t\tdescriptor = n && p && p != n ? malloc (n-p+1) : NULL;\n\t\td_sz = n-p +1;\n\t} else if (p && *p) {\n\t\td_sz = strlen (p) + 1;\n\t\tdescriptor = d_sz > 1 ? malloc (d_sz) : NULL;\n\t}\n\n\tif (!descriptor) {\n\t\tfree (classname);\n\t\tfree (name);\n\t\treturn res;\n\t}\n\tsnprintf (descriptor, d_sz, \"%s\", p);\n\t//memset (descriptor, 0, d_sz);\n\t//memcpy (descriptor, p, n-p);\n\n\tr_cons_printf (\"Would be adding class name:%s, name: %s, descriptor: %s\\n\", classname, name, descriptor);\n\tfree (classname);\n\tfree (name);\n\tfree (descriptor);\n\tres = true;\n\treturn res;\n}\n\nstatic int r_cmd_java_handle_print_exceptions (RCore *core, const char *input) {\n\tRAnal *anal = get_anal (core);\n\tRBinJavaObj *bin = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);\n\tRListIter *exc_iter = NULL, *methods_iter=NULL;\n\tRBinJavaField *method;\n\tut64 func_addr = -1;\n\tRBinJavaExceptionEntry *exc_entry;\n\n\tconst char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL;\n\tfunc_addr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;\n\n\tif (!bin) {\n\t\treturn false;\n\t}\n\n\tr_list_foreach (bin->methods_list, methods_iter, method) {\n\t\tut64 start = r_bin_java_get_method_start(bin, method),\n\t\t\tend = r_bin_java_get_method_end(bin, method);\n\t\tut8 do_this_one = start <= func_addr && func_addr <= end;\tRList * exc_table = NULL;\n\t\tdo_this_one = func_addr == -1 ? 1 : do_this_one;\n\t\tif (!do_this_one) {\n\t\t\tcontinue;\n\t\t}\n\t\texc_table = r_bin_java_get_method_exception_table_with_addr (bin, start);\n\n\t\tif (r_list_length (exc_table) == 0){\n\t\t\tr_cons_printf (\" Exception table for %s @ 0x%\"PFMT64x\":\\n\", method->name, start);\n\t\t\tr_cons_printf (\" [ NONE ]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\" Exception table for %s (%d entries) @ 0x%\"PFMT64x\":\\n\", method->name,\n\t\t\t\tr_list_length (exc_table) , start);\n\t\t}\n\t\tr_list_foreach (exc_table, exc_iter, exc_entry) {\n\t\t\tchar *class_info = r_bin_java_resolve_without_space (bin, exc_entry->catch_type);\n\t\t\tr_cons_printf (\"  Catch Type: %d, %s @ 0x%\"PFMT64x\"\\n\", exc_entry->catch_type,\n\t\t\t\tclass_info, exc_entry->file_offset+6);\n\t\t\tr_cons_printf (\"  Start PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" @ 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->start_pc, exc_entry->start_pc+start, exc_entry->file_offset);\n\t\t\tr_cons_printf (\"  End PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->end_pc, exc_entry->end_pc+start, exc_entry->file_offset + 2);\n\t\t\tr_cons_printf (\"  Handler PC: (0x%\"PFMT64x\") 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\",\n\t\t\t\texc_entry->handler_pc, exc_entry->handler_pc+start, exc_entry->file_offset+4);\n\t\t\tfree (class_info);\n\t\t}\n\t}\n\treturn true;\n}\n\n// PLUGIN Definition Info\nRCorePlugin r_core_plugin_java = {\n\t.name = \"java\",\n\t.desc = \"Suite of java commands, java help for more info\",\n\t.license = \"Apache\",\n\t.call = r_cmd_java_call,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_CORE,\n\t.data = &r_core_plugin_java,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/core/p/core_java.c"], "buggy_code_start_loc": [1468], "buggy_code_end_loc": [1469], "fixing_code_start_loc": [1468], "fixing_code_end_loc": [1469], "type": "CWE-193", "message": "An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack.", "other": {"cve": {"id": "CVE-2020-27793", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-19T23:15:08.367", "lastModified": "2022-08-22T19:45:18.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack."}, {"lang": "es", "value": "Se ha detectado un fallo de desbordamiento de memoria uno a uno en radare2 debido a una longitud de matriz no coincidente en el archivo core_java.c. Esto podr\u00eda permitir a un atacante causar un fallo y llevar a cabo un ataque de denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.0", "matchCriteriaId": "EEE8DA49-FB7A-4416-8942-56DD67E62CD9"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/issues/16304", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc"}}