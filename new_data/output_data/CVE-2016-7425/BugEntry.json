{"buggy_code": ["/*\n*******************************************************************************\n**        O.S   : Linux\n**   FILE NAME  : arcmsr_hba.c\n**        BY    : Nick Cheng, C.L. Huang\n**   Description: SCSI RAID Device Driver for Areca RAID Controller\n*******************************************************************************\n** Copyright (C) 2002 - 2014, Areca Technology Corporation All rights reserved\n**\n**     Web site: www.areca.com.tw\n**       E-mail: support@areca.com.tw\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License version 2 as\n** published by the Free Software Foundation.\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n*******************************************************************************\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions\n** are met:\n** 1. Redistributions of source code must retain the above copyright\n**    notice, this list of conditions and the following disclaimer.\n** 2. Redistributions in binary form must reproduce the above copyright\n**    notice, this list of conditions and the following disclaimer in the\n**    documentation and/or other materials provided with the distribution.\n** 3. The name of the author may not be used to endorse or promote products\n**    derived from this software without specific prior written permission.\n**\n** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT\n** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF\n** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*******************************************************************************\n** For history of changes, see Documentation/scsi/ChangeLog.arcmsr\n**     Firmware Specification, see Documentation/scsi/arcmsr_spec.txt\n*******************************************************************************\n*/\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/pci_ids.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/circ_buf.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsicam.h>\n#include \"arcmsr.h\"\nMODULE_AUTHOR(\"Nick Cheng, C.L. Huang <support@areca.com.tw>\");\nMODULE_DESCRIPTION(\"Areca ARC11xx/12xx/16xx/188x SAS/SATA RAID Controller Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(ARCMSR_DRIVER_VERSION);\n\n#define\tARCMSR_SLEEPTIME\t10\n#define\tARCMSR_RETRYCOUNT\t12\n\nstatic wait_queue_head_t wait_q;\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct scsi_cmnd *cmd);\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb);\nstatic int arcmsr_abort(struct scsi_cmnd *);\nstatic int arcmsr_bus_reset(struct scsi_cmnd *);\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *info);\nstatic int arcmsr_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic int arcmsr_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id);\nstatic int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state);\nstatic int arcmsr_resume(struct pci_dev *pdev);\nstatic void arcmsr_remove(struct pci_dev *pdev);\nstatic void arcmsr_shutdown(struct pci_dev *pdev);\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb);\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb);\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\tu32 intmask_org);\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_request_device_map(unsigned long pacb);\nstatic void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work);\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb);\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *pACB);\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb);\nstatic const char *arcmsr_info(struct Scsi_Host *);\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_irq(struct pci_dev *, struct AdapterControlBlock *);\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb);\nstatic int arcmsr_adjust_disk_queue_depth(struct scsi_device *sdev, int queue_depth)\n{\n\tif (queue_depth > ARCMSR_MAX_CMD_PERLUN)\n\t\tqueue_depth = ARCMSR_MAX_CMD_PERLUN;\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\n\nstatic struct scsi_host_template arcmsr_scsi_host_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Areca SAS/SATA RAID driver\",\n\t.info\t\t\t= arcmsr_info,\n\t.queuecommand\t\t= arcmsr_queue_command,\n\t.eh_abort_handler\t\t= arcmsr_abort,\n\t.eh_bus_reset_handler\t= arcmsr_bus_reset,\n\t.bios_param\t\t= arcmsr_bios_param,\n\t.change_queue_depth\t= arcmsr_adjust_disk_queue_depth,\n\t.can_queue\t\t= ARCMSR_MAX_OUTSTANDING_CMD,\n\t.this_id\t\t\t= ARCMSR_SCSI_INITIATOR_ID,\n\t.sg_tablesize\t        \t= ARCMSR_DEFAULT_SG_ENTRIES, \n\t.max_sectors    \t    \t= ARCMSR_MAX_XFER_SECTORS_C, \n\t.cmd_per_lun\t\t= ARCMSR_MAX_CMD_PERLUN,\n\t.use_clustering\t\t= ENABLE_CLUSTERING,\n\t.shost_attrs\t\t= arcmsr_host_attrs,\n\t.no_write_same\t\t= 1,\n};\n\nstatic struct pci_device_id arcmsr_device_id_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1110),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1120),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1130),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1160),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1170),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1200),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1201),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1202),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1203),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1210),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1214),\n\t\t.driver_data = ACB_ADAPTER_TYPE_D},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1220),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1230),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1260),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1270),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1280),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1380),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1381),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1680),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1681),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1880),\n\t\t.driver_data = ACB_ADAPTER_TYPE_C},\n\t{0, 0}, /* Terminating entry */\n};\nMODULE_DEVICE_TABLE(pci, arcmsr_device_id_table);\n\nstatic struct pci_driver arcmsr_pci_driver = {\n\t.name\t\t\t= \"arcmsr\",\n\t.id_table\t\t\t= arcmsr_device_id_table,\n\t.probe\t\t\t= arcmsr_probe,\n\t.remove\t\t\t= arcmsr_remove,\n\t.suspend\t\t= arcmsr_suspend,\n\t.resume\t\t\t= arcmsr_resume,\n\t.shutdown\t\t= arcmsr_shutdown,\n};\n/*\n****************************************************************************\n****************************************************************************\n*/\n\nstatic void arcmsr_free_mu(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tdma_free_coherent(&acb->pdev->dev, acb->roundup_ccbsize,\n\t\t\tacb->dma_coherent2, acb->dma_coherent_handle2);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tswitch (acb->adapter_type){\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tacb->pmuA = ioremap(pci_resource_start(pdev,0), pci_resource_len(pdev,0));\n\t\tif (!acb->pmuA) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tvoid __iomem *mem_base0, *mem_base1;\n\t\tmem_base0 = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\n\t\tif (!mem_base0) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tmem_base1 = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));\n\t\tif (!mem_base1) {\n\t\t\tiounmap(mem_base0);\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tacb->mem_base1 = mem_base1;\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tacb->pmuC = ioremap_nocache(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\n\t\tif (!acb->pmuC) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tif (readl(&acb->pmuC->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &acb->pmuC->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tvoid __iomem *mem_base0;\n\t\tunsigned long addr, range, flags;\n\n\t\taddr = (unsigned long)pci_resource_start(pdev, 0);\n\t\trange = pci_resource_len(pdev, 0);\n\t\tflags = pci_resource_flags(pdev, 0);\n\t\tmem_base0 = ioremap(addr, range);\n\t\tif (!mem_base0) {\n\t\t\tpr_notice(\"arcmsr%d: memory mapping region fail\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void arcmsr_unmap_pciregion(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tiounmap(acb->pmuA);\n\t}\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tiounmap(acb->mem_base0);\n\t\tiounmap(acb->mem_base1);\n\t}\n\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tiounmap(acb->pmuC);\n\t}\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tiounmap(acb->mem_base0);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t arcmsr_do_interrupt(int irq, void *dev_id)\n{\n\tirqreturn_t handle_state;\n\tstruct AdapterControlBlock *acb = dev_id;\n\n\thandle_state = arcmsr_interrupt(acb);\n\treturn handle_state;\n}\n\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *geom)\n{\n\tint ret, heads, sectors, cylinders, total_capacity;\n\tunsigned char *buffer;/* return copy of block device's partition table */\n\n\tbuffer = scsi_bios_ptable(bdev);\n\tif (buffer) {\n\t\tret = scsi_partsize(buffer, capacity, &geom[2], &geom[0], &geom[1]);\n\t\tkfree(buffer);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n\ttotal_capacity = capacity;\n\theads = 64;\n\tsectors = 32;\n\tcylinders = total_capacity / (heads * sectors);\n\tif (cylinders > 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = total_capacity / (heads * sectors);\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\treturn 0;\n}\n\nstatic uint8_t arcmsr_hbaA_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&reg->outbound_intstatus) &\n\t\t\t\tARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\n\t\t\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT,\n\t\t\t\t&reg->outbound_intstatus);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaB_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->iop2drv_doorbell)\n\t\t\t& ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN,\n\t\t\t\t\treg->iop2drv_doorbell);\n\t\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT,\n\t\t\t\t\treg->drv2iop_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaC_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&phbcmu->outbound_doorbell)\n\t\t\t\t& ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR,\n\t\t\t\t&phbcmu->outbound_doorbell_clear); /*clear interrupt*/\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic bool arcmsr_hbaD_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->outbound_doorbell)\n\t\t\t& ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\t\treg->outbound_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\treturn false;\n}\n\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint retry_count = 30;\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaA_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout, retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint retry_count = 30;\n\twritel(ARCMSR_MESSAGE_FLUSH_CACHE, reg->drv2iop_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaB_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaC_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tint retry_count = 30;/* enlarge wait flush adapter cache time: 10 minute */\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", pACB->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n\treturn;\n}\n\nstatic void arcmsr_hbaD_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tint retry_count = 15;\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\t\tbreak;\n\n\t\tretry_count--;\n\t\tpr_notice(\"arcmsr%d: wait 'flush adapter \"\n\t\t\t\"cache' timeout, retry count down = %d\\n\",\n\t\t\tpACB->host->host_no, retry_count);\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_flush_adapter_cache(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tarcmsr_hbaA_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tarcmsr_hbaB_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tarcmsr_hbaC_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_flush_cache(acb);\n\t\tbreak;\n\t}\n}\n\nstatic bool arcmsr_alloc_io_queue(struct AdapterControlBlock *acb)\n{\n\tbool rtn = true;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct pci_dev *pdev = acb->pdev;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg;\n\t\tacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_B), 32);\n\t\tdma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\treg = (struct MessageUnit_B *)dma_coherent;\n\t\tacb->pmuB = reg;\n\t\tif (acb->pdev->device == PCI_DEVICE_ID_ARECA_1203) {\n\t\t\treg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_1203);\n\t\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK_1203);\n\t\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_1203);\n\t\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK_1203);\n\t\t} else {\n\t\t\treg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL);\n\t\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK);\n\t\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL);\n\t\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK);\n\t\t}\n\t\treg->message_wbuffer = MEM_BASE1(ARCMSR_MESSAGE_WBUFFER);\n\t\treg->message_rbuffer = MEM_BASE1(ARCMSR_MESSAGE_RBUFFER);\n\t\treg->message_rwbuffer = MEM_BASE1(ARCMSR_MESSAGE_RWBUFFER);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg;\n\n\t\tacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_D), 32);\n\t\tdma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\treg = (struct MessageUnit_D *)dma_coherent;\n\t\tacb->pmuD = reg;\n\t\treg->chip_id = MEM_BASE0(ARCMSR_ARC1214_CHIP_ID);\n\t\treg->cpu_mem_config = MEM_BASE0(ARCMSR_ARC1214_CPU_MEMORY_CONFIGURATION);\n\t\treg->i2o_host_interrupt_mask = MEM_BASE0(ARCMSR_ARC1214_I2_HOST_INTERRUPT_MASK);\n\t\treg->sample_at_reset = MEM_BASE0(ARCMSR_ARC1214_SAMPLE_RESET);\n\t\treg->reset_request = MEM_BASE0(ARCMSR_ARC1214_RESET_REQUEST);\n\t\treg->host_int_status = MEM_BASE0(ARCMSR_ARC1214_MAIN_INTERRUPT_STATUS);\n\t\treg->pcief0_int_enable = MEM_BASE0(ARCMSR_ARC1214_PCIE_F0_INTERRUPT_ENABLE);\n\t\treg->inbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE0);\n\t\treg->inbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE1);\n\t\treg->outbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE0);\n\t\treg->outbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE1);\n\t\treg->inbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_INBOUND_DOORBELL);\n\t\treg->outbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL);\n\t\treg->outbound_doorbell_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL_ENABLE);\n\t\treg->inboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_LOW);\n\t\treg->inboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_HIGH);\n\t\treg->inboundlist_write_pointer = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_WRITE_POINTER);\n\t\treg->outboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_LOW);\n\t\treg->outboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_HIGH);\n\t\treg->outboundlist_copy_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_COPY_POINTER);\n\t\treg->outboundlist_read_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_READ_POINTER);\n\t\treg->outboundlist_interrupt_cause = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_CAUSE);\n\t\treg->outboundlist_interrupt_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_ENABLE);\n\t\treg->message_wbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_WBUFFER);\n\t\treg->message_rbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RBUFFER);\n\t\treg->msgcode_rwbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RWBUFFER);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct CommandControlBlock *ccb_tmp;\n\tint i = 0, j = 0;\n\tdma_addr_t cdb_phyaddr;\n\tunsigned long roundup_ccbsize;\n\tunsigned long max_xfer_len;\n\tunsigned long max_sg_entrys;\n\tuint32_t  firm_config_version;\n\n\tfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\n\t\tfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\n\t\t\tacb->devstate[i][j] = ARECA_RAID_GONE;\n\n\tmax_xfer_len = ARCMSR_MAX_XFER_LEN;\n\tmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\n\tfirm_config_version = acb->firm_cfg_version;\n\tif((firm_config_version & 0xFF) >= 3){\n\t\tmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;/* max 4M byte */\n\t\tmax_sg_entrys = (max_xfer_len/4096);\n\t}\n\tacb->host->max_sectors = max_xfer_len/512;\n\tacb->host->sg_tablesize = max_sg_entrys;\n\troundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\n\tacb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\n\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\n\tif(!dma_coherent){\n\t\tprintk(KERN_NOTICE \"arcmsr%d: dma_alloc_coherent got error\\n\", acb->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\tacb->dma_coherent = dma_coherent;\n\tacb->dma_coherent_handle = dma_coherent_handle;\n\tmemset(dma_coherent, 0, acb->uncache_size);\n\tccb_tmp = dma_coherent;\n\tacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\n\tfor(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\n\t\tcdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\n\t\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A:\n\t\tcase ACB_ADAPTER_TYPE_B:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\n\t\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C:\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr;\n\t\t\tbreak;\n\t\t}\n\t\tacb->pccb_pool[i] = ccb_tmp;\n\t\tccb_tmp->acb = acb;\n\t\tINIT_LIST_HEAD(&ccb_tmp->list);\n\t\tlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\n\t\tccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\n\t\tdma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\n\t}\n\treturn 0;\n}\n\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work) \n{\n\tstruct AdapterControlBlock *acb = container_of(work,\n\t\tstruct AdapterControlBlock, arcmsr_do_message_isr_bh);\n\tchar *acb_dev_map = (char *)acb->device_map;\n\tuint32_t __iomem *signature = NULL;\n\tchar __iomem *devicemap = NULL;\n\tint target, lun;\n\tstruct scsi_device *psdev;\n\tchar diff, temp;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\t}\n\tatomic_inc(&acb->rq_map_token);\n\tif (readl(signature) != ARCMSR_SIGNATURE_GET_CONFIG)\n\t\treturn;\n\tfor (target = 0; target < ARCMSR_MAX_TARGETID - 1;\n\t\ttarget++) {\n\t\ttemp = readb(devicemap);\n\t\tdiff = (*acb_dev_map) ^ temp;\n\t\tif (diff != 0) {\n\t\t\t*acb_dev_map = temp;\n\t\t\tfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN;\n\t\t\t\tlun++) {\n\t\t\t\tif ((diff & 0x01) == 1 &&\n\t\t\t\t\t(temp & 0x01) == 1) {\n\t\t\t\t\tscsi_add_device(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t} else if ((diff & 0x01) == 1\n\t\t\t\t\t&& (temp & 0x01) == 0) {\n\t\t\t\t\tpsdev = scsi_device_lookup(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t\tif (psdev != NULL) {\n\t\t\t\t\t\tscsi_remove_device(psdev);\n\t\t\t\t\t\tscsi_device_put(psdev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemp >>= 1;\n\t\t\t\tdiff >>= 1;\n\t\t\t}\n\t\t}\n\t\tdevicemap++;\n\t\tacb_dev_map++;\n\t}\n}\n\nstatic int\narcmsr_request_irq(struct pci_dev *pdev, struct AdapterControlBlock *acb)\n{\n\tint\ti, j, r;\n\tstruct msix_entry entries[ARCMST_NUM_MSIX_VECTORS];\n\n\tfor (i = 0; i < ARCMST_NUM_MSIX_VECTORS; i++)\n\t\tentries[i].entry = i;\n\tr = pci_enable_msix_range(pdev, entries, 1, ARCMST_NUM_MSIX_VECTORS);\n\tif (r < 0)\n\t\tgoto msi_int;\n\tacb->msix_vector_count = r;\n\tfor (i = 0; i < r; i++) {\n\t\tif (request_irq(entries[i].vector,\n\t\t\tarcmsr_do_interrupt, 0, \"arcmsr\", acb)) {\n\t\t\tpr_warn(\"arcmsr%d: request_irq =%d failed!\\n\",\n\t\t\t\tacb->host->host_no, entries[i].vector);\n\t\t\tfor (j = 0 ; j < i ; j++)\n\t\t\t\tfree_irq(entries[j].vector, acb);\n\t\t\tpci_disable_msix(pdev);\n\t\t\tgoto msi_int;\n\t\t}\n\t\tacb->entries[i] = entries[i];\n\t}\n\tacb->acb_flags |= ACB_F_MSIX_ENABLED;\n\tpr_info(\"arcmsr%d: msi-x enabled\\n\", acb->host->host_no);\n\treturn SUCCESS;\nmsi_int:\n\tif (pci_enable_msi_exact(pdev, 1) < 0)\n\t\tgoto legacy_int;\n\tif (request_irq(pdev->irq, arcmsr_do_interrupt,\n\t\tIRQF_SHARED, \"arcmsr\", acb)) {\n\t\tpr_warn(\"arcmsr%d: request_irq =%d failed!\\n\",\n\t\t\tacb->host->host_no, pdev->irq);\n\t\tpci_disable_msi(pdev);\n\t\tgoto legacy_int;\n\t}\n\tacb->acb_flags |= ACB_F_MSI_ENABLED;\n\tpr_info(\"arcmsr%d: msi enabled\\n\", acb->host->host_no);\n\treturn SUCCESS;\nlegacy_int:\n\tif (request_irq(pdev->irq, arcmsr_do_interrupt,\n\t\tIRQF_SHARED, \"arcmsr\", acb)) {\n\t\tpr_warn(\"arcmsr%d: request_irq = %d failed!\\n\",\n\t\t\tacb->host->host_no, pdev->irq);\n\t\treturn FAILED;\n\t}\n\treturn SUCCESS;\n}\n\nstatic int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct AdapterControlBlock *acb;\n\tuint8_t bus,dev_fun;\n\tint error;\n\terror = pci_enable_device(pdev);\n\tif(error){\n\t\treturn -ENODEV;\n\t}\n\thost = scsi_host_alloc(&arcmsr_scsi_host_template, sizeof(struct AdapterControlBlock));\n\tif(!host){\n    \t\tgoto pci_disable_dev;\n\t}\n\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\n\tif(error){\n\t\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif(error){\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"scsi%d: No suitable DMA mask available\\n\",\n\t\t\t       host->host_no);\n\t\t\tgoto scsi_host_release;\n\t\t}\n\t}\n\tinit_waitqueue_head(&wait_q);\n\tbus = pdev->bus->number;\n\tdev_fun = pdev->devfn;\n\tacb = (struct AdapterControlBlock *) host->hostdata;\n\tmemset(acb,0,sizeof(struct AdapterControlBlock));\n\tacb->pdev = pdev;\n\tacb->host = host;\n\thost->max_lun = ARCMSR_MAX_TARGETLUN;\n\thost->max_id = ARCMSR_MAX_TARGETID;\t\t/*16:8*/\n\thost->max_cmd_len = 16;\t \t\t\t/*this is issue of 64bit LBA ,over 2T byte*/\n\thost->can_queue = ARCMSR_MAX_OUTSTANDING_CMD;\n\thost->cmd_per_lun = ARCMSR_MAX_CMD_PERLUN;\t    \n\thost->this_id = ARCMSR_SCSI_INITIATOR_ID;\n\thost->unique_id = (bus << 8) | dev_fun;\n\tpci_set_drvdata(pdev, host);\n\tpci_set_master(pdev);\n\terror = pci_request_regions(pdev, \"arcmsr\");\n\tif(error){\n\t\tgoto scsi_host_release;\n\t}\n\tspin_lock_init(&acb->eh_lock);\n\tspin_lock_init(&acb->ccblist_lock);\n\tspin_lock_init(&acb->postq_lock);\n\tspin_lock_init(&acb->doneq_lock);\n\tspin_lock_init(&acb->rqbuffer_lock);\n\tspin_lock_init(&acb->wqbuffer_lock);\n\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_RQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\tacb->acb_flags &= ~ACB_F_SCSISTOPADAPTER;\n\tINIT_LIST_HEAD(&acb->ccb_free_list);\n\tacb->adapter_type = id->driver_data;\n\terror = arcmsr_remap_pciregion(acb);\n\tif(!error){\n\t\tgoto pci_release_regs;\n\t}\n\terror = arcmsr_alloc_io_queue(acb);\n\tif (!error)\n\t\tgoto unmap_pci_region;\n\terror = arcmsr_get_firmware_spec(acb);\n\tif(!error){\n\t\tgoto free_hbb_mu;\n\t}\n\terror = arcmsr_alloc_ccb_pool(acb);\n\tif(error){\n\t\tgoto free_hbb_mu;\n\t}\n\terror = scsi_add_host(host, &pdev->dev);\n\tif(error){\n\t\tgoto free_ccb_pool;\n\t}\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto scsi_host_remove;\n\tarcmsr_iop_init(acb);\n\tINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\n\tatomic_set(&acb->rq_map_token, 16);\n\tatomic_set(&acb->ante_token_value, 16);\n\tacb->fw_flag = FW_NORMAL;\n\tinit_timer(&acb->eternal_timer);\n\tacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\n\tacb->eternal_timer.data = (unsigned long) acb;\n\tacb->eternal_timer.function = &arcmsr_request_device_map;\n\tadd_timer(&acb->eternal_timer);\n\tif(arcmsr_alloc_sysfs_attr(acb))\n\t\tgoto out_free_sysfs;\n\tscsi_scan_host(host);\n\treturn 0;\nout_free_sysfs:\n\tdel_timer_sync(&acb->eternal_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\tarcmsr_free_irq(pdev, acb);\nscsi_host_remove:\n\tscsi_remove_host(host);\nfree_ccb_pool:\n\tarcmsr_free_ccb_pool(acb);\nfree_hbb_mu:\n\tarcmsr_free_mu(acb);\nunmap_pci_region:\n\tarcmsr_unmap_pciregion(acb);\npci_release_regs:\n\tpci_release_regions(pdev);\nscsi_host_release:\n\tscsi_host_put(host);\npci_disable_dev:\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic void arcmsr_free_irq(struct pci_dev *pdev,\n\t\tstruct AdapterControlBlock *acb)\n{\n\tint i;\n\n\tif (acb->acb_flags & ACB_F_MSI_ENABLED) {\n\t\tfree_irq(pdev->irq, acb);\n\t\tpci_disable_msi(pdev);\n\t} else if (acb->acb_flags & ACB_F_MSIX_ENABLED) {\n\t\tfor (i = 0; i < acb->msix_vector_count; i++)\n\t\t\tfree_irq(acb->entries[i].vector, acb);\n\t\tpci_disable_msix(pdev);\n\t} else\n\t\tfree_irq(pdev->irq, acb);\n}\n\nstatic int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tuint32_t intmask_org;\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tdel_timer_sync(&acb->eternal_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\tpci_set_drvdata(pdev, host);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\treturn 0;\n}\n\nstatic int arcmsr_resume(struct pci_dev *pdev)\n{\n\tint error;\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\tif (pci_enable_device(pdev)) {\n\t\tpr_warn(\"%s: pci_enable_device error\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\n\tif (error) {\n\t\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (error) {\n\t\t\tpr_warn(\"scsi%d: No suitable DMA mask available\\n\",\n\t\t\t       host->host_no);\n\t\t\tgoto controller_unregister;\n\t\t}\n\t}\n\tpci_set_master(pdev);\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto controller_stop;\n\tarcmsr_iop_init(acb);\n\tINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\n\tatomic_set(&acb->rq_map_token, 16);\n\tatomic_set(&acb->ante_token_value, 16);\n\tacb->fw_flag = FW_NORMAL;\n\tinit_timer(&acb->eternal_timer);\n\tacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\n\tacb->eternal_timer.data = (unsigned long) acb;\n\tacb->eternal_timer.function = &arcmsr_request_device_map;\n\tadd_timer(&acb->eternal_timer);\n\treturn 0;\ncontroller_stop:\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\ncontroller_unregister:\n\tscsi_remove_host(host);\n\tarcmsr_free_ccb_pool(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaB_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\n\twritel(ARCMSR_MESSAGE_ABORT_CMD, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic uint8_t arcmsr_hbaC_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaD_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'abort all outstanding \"\n\t\t\t\"command' timeout\\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tuint8_t rtnval = 0;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\trtnval = arcmsr_hbaA_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\trtnval = arcmsr_hbaB_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\trtnval = arcmsr_hbaC_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtnval = arcmsr_hbaD_abort_allcmd(acb);\n\t\tbreak;\n\t}\n\treturn rtnval;\n}\n\nstatic void arcmsr_pci_unmap_dma(struct CommandControlBlock *ccb)\n{\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\n\tscsi_dma_unmap(pcmd);\n}\n\nstatic void arcmsr_ccb_complete(struct CommandControlBlock *ccb)\n{\n\tstruct AdapterControlBlock *acb = ccb->acb;\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\tunsigned long flags;\n\tatomic_dec(&acb->ccboutstandingcount);\n\tarcmsr_pci_unmap_dma(ccb);\n\tccb->startdone = ARCMSR_CCB_DONE;\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\tpcmd->scsi_done(pcmd);\n}\n\nstatic void arcmsr_report_sense_info(struct CommandControlBlock *ccb)\n{\n\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\tstruct SENSE_DATA *sensebuffer = (struct SENSE_DATA *)pcmd->sense_buffer;\n\tpcmd->result = DID_OK << 16;\n\tif (sensebuffer) {\n\t\tint sense_data_length =\n\t\t\tsizeof(struct SENSE_DATA) < SCSI_SENSE_BUFFERSIZE\n\t\t\t? sizeof(struct SENSE_DATA) : SCSI_SENSE_BUFFERSIZE;\n\t\tmemset(sensebuffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tmemcpy(sensebuffer, ccb->arcmsr_cdb.SenseData, sense_data_length);\n\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\tsensebuffer->Valid = 1;\n\t}\n}\n\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb)\n{\n\tu32 orig_mask = 0;\n\tswitch (acb->adapter_type) {\t\n\tcase ACB_ADAPTER_TYPE_A : {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\torig_mask = readl(&reg->outbound_intmask);\n\t\twritel(orig_mask|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE, \\\n\t\t\t\t\t\t&reg->outbound_intmask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B : {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\torig_mask = readl(reg->iop2drv_doorbell_mask);\n\t\twritel(0, reg->iop2drv_doorbell_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t/* disable all outbound interrupt */\n\t\torig_mask = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\t\twritel(orig_mask|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\t/* disable all outbound interrupt */\n\t\twritel(ARCMSR_ARC1214_ALL_INT_DISABLE, reg->pcief0_int_enable);\n\t\t}\n\t\tbreak;\n\t}\n\treturn orig_mask;\n}\n\nstatic void arcmsr_report_ccb_state(struct AdapterControlBlock *acb, \n\t\t\tstruct CommandControlBlock *ccb, bool error)\n{\n\tuint8_t id, lun;\n\tid = ccb->pcmd->device->id;\n\tlun = ccb->pcmd->device->lun;\n\tif (!error) {\n\t\tif (acb->devstate[id][lun] == ARECA_RAID_GONE)\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\tccb->pcmd->result = DID_OK << 16;\n\t\tarcmsr_ccb_complete(ccb);\n\t}else{\n\t\tswitch (ccb->arcmsr_cdb.DeviceStatus) {\n\t\tcase ARCMSR_DEV_SELECT_TIMEOUT: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_ABORTED:\n\n\t\tcase ARCMSR_DEV_INIT_FAIL: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_BAD_TARGET << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_CHECK_CONDITION: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\t\tarcmsr_report_sense_info(ccb);\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"arcmsr%d: scsi id = %d lun = %d isr get command error done, \\\n\t\t\t\tbut got unknown DeviceStatus = 0x%x \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, id\n\t\t\t\t, lun\n\t\t\t\t, ccb->arcmsr_cdb.DeviceStatus);\n\t\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error)\n{\n\tint id, lun;\n\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\tstruct scsi_cmnd *abortcmd = pCCB->pcmd;\n\t\t\tif (abortcmd) {\n\t\t\t\tid = abortcmd->device->id;\n\t\t\t\tlun = abortcmd->device->lun;\t\t\t\t\n\t\t\t\tabortcmd->result |= DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: pCCB ='0x%p' isr got aborted command \\n\",\n\t\t\t\tacb->host->host_no, pCCB);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprintk(KERN_NOTICE \"arcmsr%d: isr get an illegal ccb command \\\n\t\t\t\tdone acb = '0x%p'\"\n\t\t\t\t\"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x\"\n\t\t\t\t\" ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, acb\n\t\t\t\t, pCCB\n\t\t\t\t, pCCB->acb\n\t\t\t\t, pCCB->startdone\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t  return;\n\t}\n\tarcmsr_report_ccb_state(acb, pCCB, error);\n}\n\nstatic void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)\n{\n\tint i = 0;\n\tuint32_t flag_ccb, ccb_cdb_phy;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_intstatus;\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\t\t\tacb->outbound_int_enable;\n\t\t/*clear and abort all outbound posted Q*/\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\t\twhile(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)\n\t\t\t\t&& (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\n\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*clear all outbound posted Q*/\n\t\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell); /* clear doorbell interrupt */\n\t\tfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\n\t\t\tflag_ccb = reg->done_qbuffer[i];\n\t\t\tif (flag_ccb != 0) {\n\t\t\t\treg->done_qbuffer[i] = 0;\n\t\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t}\n\t\t\treg->post_qbuffer[i] = 0;\n\t\t}\n\t\treg->doneq_index = 0;\n\t\treg->postq_index = 0;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\twhile ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\n\t\t\t/*need to do*/\n\t\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)(acb->vir2phy_offset+ccb_cdb_phy);/*frame must be 32 bytes aligned*/\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tuint32_t outbound_write_pointer;\n\t\tuint32_t doneq_index, index_stripped, addressLow, residual, toggle;\n\t\tunsigned long flags;\n\n\t\tresidual = atomic_read(&acb->ccboutstandingcount);\n\t\tfor (i = 0; i < residual; i++) {\n\t\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\t\toutbound_write_pointer =\n\t\t\t\tpmu->done_qbuffer[0].addressLow + 1;\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\tif ((doneq_index & 0xFFF) !=\n\t\t\t\t(outbound_write_pointer & 0xFFF)) {\n\t\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t\t0xFFF].addressLow;\n\t\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)\n\t\t\t\t\t(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\t\tpCCB = container_of(pARCMSR_CDB,\n\t\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (addressLow &\n\t\t\t\t\tARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ?\n\t\t\t\t\ttrue : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t\twritel(doneq_index,\n\t\t\t\t\tpmu->outboundlist_read_pointer);\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\tmdelay(10);\n\t\t\t}\n\t\t}\n\t\tpmu->postq_index = 0;\n\t\tpmu->doneq_index = 0x40FF;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tint poll_count = 0;\n\tarcmsr_free_sysfs_attr(acb);\n\tscsi_remove_host(host);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tdel_timer_sync(&acb->eternal_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\t\n\tacb->acb_flags |= ACB_F_SCSISTOPADAPTER;\n\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\n\tfor (poll_count = 0; poll_count < ARCMSR_MAX_OUTSTANDING_CMD; poll_count++){\n\t\tif (!atomic_read(&acb->ccboutstandingcount))\n\t\t\tbreak;\n\t\tarcmsr_interrupt(acb);/* FIXME: need spinlock */\n\t\tmsleep(25);\n\t}\n\n\tif (atomic_read(&acb->ccboutstandingcount)) {\n\t\tint i;\n\n\t\tarcmsr_abort_allcmd(acb);\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t}\n\t}\n\tarcmsr_free_irq(pdev, acb);\n\tarcmsr_free_ccb_pool(acb);\n\tarcmsr_free_mu(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}\n\nstatic void arcmsr_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\tdel_timer_sync(&acb->eternal_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n}\n\nstatic int arcmsr_module_init(void)\n{\n\tint error = 0;\n\terror = pci_register_driver(&arcmsr_pci_driver);\n\treturn error;\n}\n\nstatic void arcmsr_module_exit(void)\n{\n\tpci_unregister_driver(&arcmsr_pci_driver);\n}\nmodule_init(arcmsr_module_init);\nmodule_exit(arcmsr_module_exit);\n\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\t\t\t\t\t\tu32 intmask_org)\n{\n\tu32 mask;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tmask = intmask_org & ~(ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE |\n\t\t\t     ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE|\n\t\t\t     ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE);\n\t\twritel(mask, &reg->outbound_intmask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x000000ff;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tmask = intmask_org | (ARCMSR_IOP2DRV_DATA_WRITE_OK |\n\t\t\tARCMSR_IOP2DRV_DATA_READ_OK |\n\t\t\tARCMSR_IOP2DRV_CDB_DONE |\n\t\t\tARCMSR_IOP2DRV_MESSAGE_CMD_DONE);\n\t\twritel(mask, reg->iop2drv_doorbell_mask);\n\t\tacb->outbound_int_enable = (intmask_org | mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tmask = ~(ARCMSR_HBCMU_UTILITY_A_ISR_MASK | ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK);\n\t\twritel(intmask_org & mask, &reg->host_int_mask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\t\tmask = ARCMSR_ARC1214_ALL_INT_ENABLE;\n\t\twritel(intmask_org | mask, reg->pcief0_int_enable);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_build_ccb(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *ccb, struct scsi_cmnd *pcmd)\n{\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tint8_t *psge = (int8_t *)&arcmsr_cdb->u;\n\t__le32 address_lo, address_hi;\n\tint arccdbsize = 0x30;\n\t__le32 length = 0;\n\tint i;\n\tstruct scatterlist *sg;\n\tint nseg;\n\tccb->pcmd = pcmd;\n\tmemset(arcmsr_cdb, 0, sizeof(struct ARCMSR_CDB));\n\tarcmsr_cdb->TargetID = pcmd->device->id;\n\tarcmsr_cdb->LUN = pcmd->device->lun;\n\tarcmsr_cdb->Function = 1;\n\tarcmsr_cdb->msgContext = 0;\n\tmemcpy(arcmsr_cdb->Cdb, pcmd->cmnd, pcmd->cmd_len);\n\n\tnseg = scsi_dma_map(pcmd);\n\tif (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))\n\t\treturn FAILED;\n\tscsi_for_each_sg(pcmd, sg, nseg, i) {\n\t\t/* Get the physical address of the current data pointer */\n\t\tlength = cpu_to_le32(sg_dma_len(sg));\n\t\taddress_lo = cpu_to_le32(dma_addr_lo32(sg_dma_address(sg)));\n\t\taddress_hi = cpu_to_le32(dma_addr_hi32(sg_dma_address(sg)));\n\t\tif (address_hi == 0) {\n\t\t\tstruct SG32ENTRY *pdma_sg = (struct SG32ENTRY *)psge;\n\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length;\n\t\t\tpsge += sizeof (struct SG32ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG32ENTRY);\n\t\t} else {\n\t\t\tstruct SG64ENTRY *pdma_sg = (struct SG64ENTRY *)psge;\n\n\t\t\tpdma_sg->addresshigh = address_hi;\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length|cpu_to_le32(IS_SG64_ADDR);\n\t\t\tpsge += sizeof (struct SG64ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG64ENTRY);\n\t\t}\n\t}\n\tarcmsr_cdb->sgcount = (uint8_t)nseg;\n\tarcmsr_cdb->DataLength = scsi_bufflen(pcmd);\n\tarcmsr_cdb->msgPages = arccdbsize/0x100 + (arccdbsize % 0x100 ? 1 : 0);\n\tif ( arccdbsize > 256)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE;\n\tif (pcmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_WRITE;\n\tccb->arc_cdb_size = arccdbsize;\n\treturn SUCCESS;\n}\n\nstatic void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\n{\n\tuint32_t cdb_phyaddr = ccb->cdb_phyaddr;\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tatomic_inc(&acb->ccboutstandingcount);\n\tccb->startdone = ARCMSR_CCB_START;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\n\t\t\twritel(cdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\n\t\t\t&reg->inbound_queueport);\n\t\telse\n\t\t\twritel(cdb_phyaddr, &reg->inbound_queueport);\n\t\tbreak;\n\t}\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t ending_index, index = reg->postq_index;\n\n\t\tending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\n\t\treg->post_qbuffer[ending_index] = 0;\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\n\t\t\treg->post_qbuffer[index] =\n\t\t\t\tcdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE;\n\t\t} else {\n\t\t\treg->post_qbuffer[index] = cdb_phyaddr;\n\t\t}\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;/*if last index number set it to 0 */\n\t\treg->postq_index = index;\n\t\twritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tuint32_t ccb_post_stamp, arc_cdb_size;\n\n\t\tarc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\n\t\tccb_post_stamp = (cdb_phyaddr | ((arc_cdb_size - 1) >> 6) | 1);\n\t\tif (acb->cdb_phyaddr_hi32) {\n\t\t\twritel(acb->cdb_phyaddr_hi32, &phbcmu->inbound_queueport_high);\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t} else {\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tu16 index_stripped;\n\t\tu16 postq_index, toggle;\n\t\tunsigned long flags;\n\t\tstruct InBound_SRB *pinbound_srb;\n\n\t\tspin_lock_irqsave(&acb->postq_lock, flags);\n\t\tpostq_index = pmu->postq_index;\n\t\tpinbound_srb = (struct InBound_SRB *)&(pmu->post_qbuffer[postq_index & 0xFF]);\n\t\tpinbound_srb->addressHigh = dma_addr_hi32(cdb_phyaddr);\n\t\tpinbound_srb->addressLow = dma_addr_lo32(cdb_phyaddr);\n\t\tpinbound_srb->length = ccb->arc_cdb_size >> 2;\n\t\tarcmsr_cdb->msgContext = dma_addr_lo32(cdb_phyaddr);\n\t\ttoggle = postq_index & 0x4000;\n\t\tindex_stripped = postq_index + 1;\n\t\tindex_stripped &= (ARCMSR_MAX_ARC1214_POSTQUEUE - 1);\n\t\tpmu->postq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t(toggle ^ 0x4000);\n\t\twritel(postq_index, pmu->inboundlist_write_pointer);\n\t\tspin_unlock_irqrestore(&acb->postq_lock, flags);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaA_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_STOP_BGRB, reg->drv2iop_doorbell);\n\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\tpr_notice(\"arcmsr%d: wait 'stop adapter background rebulid' \"\n\t\t\t\"timeout\\n\", pACB->host->host_no);\n}\n\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tarcmsr_hbaA_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tarcmsr_hbaB_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tarcmsr_hbaC_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_stop_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tdma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);\n}\n\nstatic void arcmsr_iop_message_read(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_DRV2IOP_DATA_WRITE_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstruct QBUFFER __iomem *arcmsr_get_iop_rqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *qbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tqbuffer = (struct QBUFFER __iomem *)&phbcmu->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\t}\n\treturn qbuffer;\n}\n\nstatic struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *pqbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tpqbuffer = (struct QBUFFER __iomem *) &reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B  *reg = acb->pmuB;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tpqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\t}\n\treturn pqbuffer;\n}\n\nstatic uint32_t\narcmsr_Read_iop_rqbuffer_in_DWORD(struct AdapterControlBlock *acb,\n\t\tstruct QBUFFER __iomem *prbuffer)\n{\n\tuint8_t *pQbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t iop_len, data_len, *buf2 = NULL;\n\n\tiop_data = (uint32_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\tif (iop_len > 0) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn 0;\n\t\tdata_len = iop_len;\n\t\twhile (data_len >= 4) {\n\t\t\t*buf2++ = readl(iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len)\n\t\t\t*buf2 = readl(iop_data);\n\t\tbuf2 = (uint32_t *)buf1;\n\t}\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = *buf1;\n\t\tacb->rqbuf_putIndex++;\n\t\t/* if last, index number set it to 0 */\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tbuf1++;\n\t\tiop_len--;\n\t}\n\tkfree(buf2);\n\t/* let IOP know data has been read */\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nuint32_t\narcmsr_Read_iop_rqbuffer_data(struct AdapterControlBlock *acb,\n\tstruct QBUFFER __iomem *prbuffer) {\n\n\tuint8_t *pQbuffer;\n\tuint8_t __iomem *iop_data;\n\tuint32_t iop_len;\n\n\tif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D))\n\t\treturn arcmsr_Read_iop_rqbuffer_in_DWORD(acb, prbuffer);\n\tiop_data = (uint8_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = readb(iop_data);\n\t\tacb->rqbuf_putIndex++;\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tiop_data++;\n\t\tiop_len--;\n\t}\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nstatic void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\tstruct QBUFFER __iomem  *prbuffer;\n\tint32_t buf_empty_len;\n\n\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\tbuf_empty_len = (acb->rqbuf_putIndex - acb->rqbuf_getIndex - 1) &\n\t\t(ARCMSR_MAX_QBUFFER - 1);\n\tif (buf_empty_len >= readl(&prbuffer->data_len)) {\n\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t} else\n\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n}\n\nstatic void arcmsr_write_ioctldata2iop_in_DWORD(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t allxfer_len = 0, data_len, *buf2 = NULL, data;\n\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn;\n\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint32_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\t*buf1 = *pQbuffer;\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tbuf1++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\tdata_len = allxfer_len;\n\t\tbuf1 = (uint8_t *)buf2;\n\t\twhile (data_len >= 4) {\n\t\t\tdata = *buf2++;\n\t\t\twritel(data, iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len) {\n\t\t\tdata = *buf2;\n\t\t\twritel(data, iop_data);\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tkfree(buf1);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nvoid\narcmsr_write_ioctldata2iop(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t __iomem *iop_data;\n\tint32_t allxfer_len = 0;\n\n\tif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D)) {\n\t\tarcmsr_write_ioctldata2iop_in_DWORD(acb);\n\t\treturn;\n\t}\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint8_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\twriteb(*pQbuffer, iop_data);\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tiop_data++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nstatic void arcmsr_iop2drv_data_read_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_READED;\n\tif (acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\tarcmsr_write_ioctldata2iop(acb);\n\tif (acb->wqbuf_getIndex == acb->wqbuf_putIndex)\n\t\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n}\n\nstatic void arcmsr_hbaA_doorbell_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK\n\t\t| ARCMSR_OUTBOUND_IOP331_DATA_READ_OK));\n}\nstatic void arcmsr_hbaC_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\t/*\n\t*******************************************************************\n\t**  Maybe here we need to check wrqbuffer_lock is lock or not\n\t**  DOORBELL: din! don!\n\t**  check if there are any mail need to pack from firmware\n\t*******************************************************************\n\t*/\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\treadl(&reg->outbound_doorbell_clear);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaC_message_isr(pACB);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaD_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, pmu->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaD_message_isr(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaA_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\twhile ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t}\n}\nstatic void arcmsr_hbaB_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t index;\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\tindex = reg->doneq_index;\n\twhile ((flag_ccb = reg->done_qbuffer[index]) != 0) {\n\t\treg->done_qbuffer[index] = 0;\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t}\n}\n\nstatic void arcmsr_hbaC_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *phbcmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, ccb_cdb_phy, throttling = 0;\n\tint error;\n\n\tphbcmu = acb->pmuC;\n\t/* areca cdb command done */\n\t/* Use correct offset and size for syncing */\n\n\twhile ((flag_ccb = readl(&phbcmu->outbound_queueport_low)) !=\n\t\t\t0xFFFFFFFF) {\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t+ ccb_cdb_phy);\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\t/* check if command done with no error */\n\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\tthrottling++;\n\t\tif (throttling == ARCMSR_HBC_ISR_THROTTLING_LEVEL) {\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING,\n\t\t\t\t&phbcmu->inbound_doorbell);\n\t\t\tthrottling = 0;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaD_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tu32 outbound_write_pointer, doneq_index, index_stripped, toggle;\n\tuint32_t addressLow, ccb_cdb_phy;\n\tint error;\n\tstruct MessageUnit_D  *pmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\tpmu = acb->pmuD;\n\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\tdoneq_index = pmu->doneq_index;\n\tif ((doneq_index & 0xFFF) != (outbound_write_pointer & 0xFFF)) {\n\t\tdo {\n\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t0xFFF].addressLow;\n\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t\t+ ccb_cdb_phy);\n\t\t\tccb = container_of(arcmsr_cdb,\n\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (addressLow & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t\t? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\t\twritel(doneq_index, pmu->outboundlist_read_pointer);\n\t\t} while ((doneq_index & 0xFFF) !=\n\t\t\t(outbound_write_pointer & 0xFFF));\n\t}\n\twritel(ARCMSR_ARC1214_OUTBOUND_LIST_INTERRUPT_CLEAR,\n\t\tpmu->outboundlist_interrupt_cause);\n\treadl(pmu->outboundlist_interrupt_cause);\n\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n}\n\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the current adapter config.  \n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaA_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT, &reg->outbound_intstatus);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\nstatic void arcmsr_hbaB_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the\n** current adapter config.\n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE, reg->outbound_doorbell);\n\treadl(reg->outbound_doorbell);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_intstatus;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\tacb->outbound_int_enable;\n\tif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\n\t\t\tarcmsr_hbaA_doorbell_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\n\t\t\tarcmsr_hbaA_postqueue_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\n\t\t\tarcmsr_hbaA_message_isr(acb);\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\n\t\t| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\n\t\t| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaB_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\t\tacb->outbound_int_enable;\n\tif (!outbound_doorbell)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(~outbound_doorbell, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_CDB_DONE)\n\t\t\tarcmsr_hbaB_postqueue_isr(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaB_message_isr(acb);\n\t\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_doorbell & (ARCMSR_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_IOP2DRV_CDB_DONE\n\t\t| ARCMSR_IOP2DRV_MESSAGE_CMD_DONE));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaC_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t host_interrupt_status;\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\t/*\n\t*********************************************\n\t**   check outbound intstatus\n\t*********************************************\n\t*/\n\thost_interrupt_status = readl(&phbcmu->host_int_status) &\n\t\t(ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaC_doorbell_isr(pACB);\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaC_postqueue_isr(pACB);\n\t\thost_interrupt_status = readl(&phbcmu->host_int_status);\n\t} while (host_interrupt_status & (ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_hbaD_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tu32 host_interrupt_status;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\thost_interrupt_status = readl(pmu->host_int_status) &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaD_postqueue_isr(pACB);\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaD_doorbell_isr(pACB);\n\t\thost_interrupt_status = readl(pmu->host_int_status);\n\t} while (host_interrupt_status &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn arcmsr_hbaA_handle_isr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\treturn arcmsr_hbaB_handle_isr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn arcmsr_hbaC_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_D:\n\t\treturn arcmsr_hbaD_handle_isr(acb);\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic void arcmsr_iop_parking(struct AdapterControlBlock *acb)\n{\n\tif (acb) {\n\t\t/* stop adapter background rebuild */\n\t\tif (acb->acb_flags & ACB_F_MSG_START_BGRB) {\n\t\t\tuint32_t intmask_org;\n\t\t\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\tarcmsr_stop_adapter_bgrb(acb);\n\t\t\tarcmsr_flush_adapter_cache(acb);\n\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t}\n\t}\n}\n\n\nvoid arcmsr_clear_iop2drv_rqueue_buffer(struct AdapterControlBlock *acb)\n{\n\tuint32_t\ti;\n\n\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\tfor (i = 0; i < 15; i++) {\n\t\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tarcmsr_iop_message_read(acb);\n\t\t\t\tmdelay(30);\n\t\t\t} else if (acb->rqbuf_getIndex !=\n\t\t\t\t   acb->rqbuf_putIndex) {\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tmdelay(30);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tint32_t user_len, cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}\n\nstatic struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb)\n{\n\tstruct list_head *head = &acb->ccb_free_list;\n\tstruct CommandControlBlock *ccb = NULL;\n\tunsigned long flags;\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\tif (!list_empty(head)) {\n\t\tccb = list_entry(head->next, struct CommandControlBlock, list);\n\t\tlist_del_init(&ccb->list);\n\t}else{\n\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\treturn ccb;\n}\n\nstatic void arcmsr_handle_virtual_command(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tswitch (cmd->cmnd[0]) {\n\tcase INQUIRY: {\n\t\tunsigned char inqdata[36];\n\t\tchar *buffer;\n\t\tstruct scatterlist *sg;\n\n\t\tif (cmd->device->lun) {\n\t\t\tcmd->result = (DID_TIME_OUT << 16);\n\t\t\tcmd->scsi_done(cmd);\n\t\t\treturn;\n\t\t}\n\t\tinqdata[0] = TYPE_PROCESSOR;\n\t\t/* Periph Qualifier & Periph Dev Type */\n\t\tinqdata[1] = 0;\n\t\t/* rem media bit & Dev Type Modifier */\n\t\tinqdata[2] = 0;\n\t\t/* ISO, ECMA, & ANSI versions */\n\t\tinqdata[4] = 31;\n\t\t/* length of additional data */\n\t\tstrncpy(&inqdata[8], \"Areca   \", 8);\n\t\t/* Vendor Identification */\n\t\tstrncpy(&inqdata[16], \"RAID controller \", 16);\n\t\t/* Product Identification */\n\t\tstrncpy(&inqdata[32], \"R001\", 4); /* Product Revision */\n\n\t\tsg = scsi_sglist(cmd);\n\t\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\n\t\tmemcpy(buffer, inqdata, sizeof(inqdata));\n\t\tsg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\n\t\tcmd->scsi_done(cmd);\n\t}\n\tbreak;\n\tcase WRITE_BUFFER:\n\tcase READ_BUFFER: {\n\t\tif (arcmsr_iop_message_xfer(acb, cmd))\n\t\t\tcmd->result = (DID_ERROR << 16);\n\t\tcmd->scsi_done(cmd);\n\t}\n\tbreak;\n\tdefault:\n\t\tcmd->scsi_done(cmd);\n\t}\n}\n\nstatic int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,\n\tvoid (* done)(struct scsi_cmnd *))\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tstruct CommandControlBlock *ccb;\n\tint target = cmd->device->id;\n\tint lun = cmd->device->lun;\n\tuint8_t scsicmd = cmd->cmnd[0];\n\tcmd->scsi_done = done;\n\tcmd->host_scribble = NULL;\n\tcmd->result = 0;\n\tif ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){\n\t\tif(acb->devstate[target][lun] == ARECA_RAID_GONE) {\n    \t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t}\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\tif (target == 16) {\n\t\t/* virtual device for iop message transfer */\n\t\tarcmsr_handle_virtual_command(acb, cmd);\n\t\treturn 0;\n\t}\n\tccb = arcmsr_get_freeccb(acb);\n\tif (!ccb)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif (arcmsr_build_ccb( acb, ccb, cmd ) == FAILED) {\n\t\tcmd->result = (DID_ERROR << 16) | (RESERVATION_CONFLICT << 1);\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\tarcmsr_post_ccb(acb, ccb);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(arcmsr_queue_command)\n\nstatic bool arcmsr_hbaA_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\n\tchar __iomem *iop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\n\tint count;\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count){\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\n\tcount = 16;\n\twhile (count){\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\n\tcount=16;\n\twhile(count){\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\tacb->signature = readl(&reg->message_rwbuffer[0]);\n\tacb->firm_request_len = readl(&reg->message_rwbuffer[1]);\n\tacb->firm_numbers_queue = readl(&reg->message_rwbuffer[2]);\n\tacb->firm_sdram_size = readl(&reg->message_rwbuffer[3]);\n\tacb->firm_hd_channels = readl(&reg->message_rwbuffer[4]);\n\tacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\treturn true;\n}\nstatic bool arcmsr_hbaB_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model;\n\t/*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version;\n\t/*firm_version,17,68-83*/\n\tchar __iomem *iop_device_map;\n\t/*firm_version,21,84-99*/\n\tint count;\n\n\tiop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\t/*firm_model,15,60-67*/\n\tiop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\t/*firm_version,17,68-83*/\n\tiop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\t/*firm_version,21,84-99*/\n\n\tarcmsr_wait_firmware_ready(acb);\n\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_ERR \"arcmsr%d: can't set driver mode.\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count){\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count){\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\n\tcount = 16;\n\twhile(count){\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\t\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\n\tacb->signature = readl(&reg->message_rwbuffer[0]);\n\t/*firm_signature,1,00-03*/\n\tacb->firm_request_len = readl(&reg->message_rwbuffer[1]);\n\t/*firm_request_len,1,04-07*/\n\tacb->firm_numbers_queue = readl(&reg->message_rwbuffer[2]);\n\t/*firm_numbers_queue,2,08-11*/\n\tacb->firm_sdram_size = readl(&reg->message_rwbuffer[3]);\n\t/*firm_sdram_size,3,12-15*/\n\tacb->firm_hd_channels = readl(&reg->message_rwbuffer[4]);\n\t/*firm_ide_channels,4,16-19*/\n\tacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*firm_ide_channels,4,16-19*/\n\treturn true;\n}\n\nstatic bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\n{\n\tuint32_t intmask_org, Index, firmware_state = 0;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tchar *acb_firm_model = pACB->firm_model;\n\tchar *acb_firm_version = pACB->firm_version;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);    /*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);  /*firm_version,17,68-83*/\n\tint count;\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tdo {\n\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t/* wait message ready */\n\tfor (Index = 0; Index < 2000; Index++) {\n\t\tif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t} /*max 1 seconds*/\n\tif (Index >= 2000) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tpACB->host->host_no,\n\t\tpACB->firm_model,\n\t\tpACB->firm_version);\n\tpACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);   /*firm_request_len,1,04-07*/\n\tpACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]); /*firm_numbers_queue,2,08-11*/\n\tpACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);    /*firm_sdram_size,3,12-15*/\n\tpACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);  /*firm_ide_channels,4,16-19*/\n\tpACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*all interrupt service will be enable at arcmsr_iop_init*/\n\treturn true;\n}\n\nstatic bool arcmsr_hbaD_get_config(struct AdapterControlBlock *acb)\n{\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model;\n\tchar __iomem *iop_firm_version;\n\tchar __iomem *iop_device_map;\n\tu32 count;\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\tiop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);\n\tiop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);\n\tiop_device_map = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\tif (readl(acb->pmuD->outbound_doorbell) &\n\t\tARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\tacb->pmuD->outbound_doorbell);/*clear interrupt*/\n\t}\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, reg->inbound_msgaddr0);\n\t/* wait message ready */\n\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\tpr_notice(\"arcmsr%d: wait get adapter firmware \"\n\t\t\t\"miscellaneous data timeout\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\tacb->signature = readl(&reg->msgcode_rwbuffer[0]);\n\t/*firm_signature,1,00-03*/\n\tacb->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);\n\t/*firm_request_len,1,04-07*/\n\tacb->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]);\n\t/*firm_numbers_queue,2,08-11*/\n\tacb->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);\n\t/*firm_sdram_size,3,12-15*/\n\tacb->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);\n\t/*firm_hd_channels,4,16-19*/\n\tacb->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\treturn true;\n}\n\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb)\n{\n\tbool rtn = false;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\trtn = arcmsr_hbaA_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\trtn = arcmsr_hbaB_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\trtn = arcmsr_hbaC_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_get_config(acb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (acb->firm_numbers_queue > ARCMSR_MAX_OUTSTANDING_CMD)\n\t\tacb->maxOutstanding = ARCMSR_MAX_OUTSTANDING_CMD;\n\telse\n\t\tacb->maxOutstanding = acb->firm_numbers_queue - 1;\n\tacb->host->can_queue = acb->maxOutstanding;\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaA_polling_ccbdone(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct CommandControlBlock *ccb;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tuint32_t flag_ccb, outbound_intstatus, poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\n\tbool error;\n\tpolling_hba_ccb_retry:\n\tpoll_count++;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) & acb->outbound_int_enable;\n\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\twhile (1) {\n\t\tif ((flag_ccb = readl(&reg->outbound_queueport)) == 0xFFFFFFFF) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hba_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, ccb->pcmd->device->id\n\t\t\t\t\t, (u32)ccb->pcmd->device->lun\n\t\t\t\t\t, ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaB_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, poll_ccb_done = 0, poll_count = 0;\n\tint index, rtn;\n\tbool error;\n\tpolling_hbb_ccb_retry:\n\n\tpoll_count++;\n\t/* clear doorbell interrupt */\n\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\twhile(1){\n\t\tindex = reg->doneq_index;\n\t\tflag_ccb = reg->done_qbuffer[index];\n\t\tif (flag_ccb == 0) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbb_ccb_retry;\n\t\t\t}\n\t\t}\n\t\treg->done_qbuffer[index] = 0;\n\t\tindex++;\n\t\t/*if last index number set it to 0 */\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t\t/* check if command done with no error*/\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t,acb->host->host_no\n\t\t\t\t\t,ccb->pcmd->device->id\n\t\t\t\t\t,(u32)ccb->pcmd->device->lun\n\t\t\t\t\t,ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t} \n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaC_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\tuint32_t flag_ccb, ccb_cdb_phy;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tuint32_t poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\npolling_hbc_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tif ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) == 0) {\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbc_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\t/* check ifcommand done with no error*/\n\t\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaD_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tbool error;\n\tuint32_t poll_ccb_done = 0, poll_count = 0, flag_ccb, ccb_cdb_phy;\n\tint rtn, doneq_index, index_stripped, outbound_write_pointer, toggle;\n\tunsigned long flags;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *pCCB;\n\tstruct MessageUnit_D *pmu = acb->pmuD;\n\npolling_hbaD_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\t\tdoneq_index = pmu->doneq_index;\n\t\tif ((outbound_write_pointer & 0xFFF) == (doneq_index & 0xFFF)) {\n\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 40) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbaD_ccb_retry;\n\t\t\t}\n\t\t}\n\t\ttoggle = doneq_index & 0x4000;\n\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\tdoneq_index = pmu->doneq_index;\n\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\tflag_ccb = pmu->done_qbuffer[doneq_index & 0xFFF].addressLow;\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset +\n\t\t\tccb_cdb_phy);\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\tif ((pCCB->acb != acb) ||\n\t\t\t(pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tpr_notice(\"arcmsr%d: scsi id = %d \"\n\t\t\t\t\t\"lun = %d ccb = '0x%p' poll command \"\n\t\t\t\t\t\"abort successfully\\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_notice(\"arcmsr%d: polling an illegal \"\n\t\t\t\t\"ccb command done ccb = '0x%p' \"\n\t\t\t\t\"ccboutstandingcount = %d\\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tint rtn = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\trtn = arcmsr_hbaA_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\trtn = arcmsr_hbaB_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\trtn = arcmsr_hbaC_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\n{\n\tuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\n\tdma_addr_t dma_coherent_handle;\n\n\t/*\n\t********************************************************************\n\t** here we need to tell iop 331 our freeccb.HighPart\n\t** if freeccb.HighPart is not zero\n\t********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tdma_coherent_handle = acb->dma_coherent_handle2;\n\t\tbreak;\n\tdefault:\n\t\tdma_coherent_handle = acb->dma_coherent_handle;\n\t\tbreak;\n\t}\n\tcdb_phyaddr = lower_32_bits(dma_coherent_handle);\n\tcdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\n\tacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\n\t/*\n\t***********************************************************************\n\t**    if adapter type B, set window of \"post command Q\"\n\t***********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, \\\n\t\t\t\t\t\t&reg->message_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\\n\t\t\t\t\t\t\t&reg->inbound_msgaddr0);\n\t\t\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: \"\"set ccb high \\\n\t\t\t\tpart physical address timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tuint32_t __iomem *rwbuffer;\n\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\twritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cannot set driver mode\\n\", \\\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\trwbuffer = reg->message_rwbuffer;\n\t\t/* driver \"set config\" signature */\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\t/* normal should be zero */\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\t/* postQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\t/* doneQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr + 1056, rwbuffer++);\n\t\t/* ccb maxQ size must be --> [(256 + 8)*4]*/\n\t\twritel(1056, rwbuffer);\n\n\t\twritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\ttimeout \\n\",acb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tpr_err(\"arcmsr%d: can't set driver mode.\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cdb_phyaddr_hi32=0x%x\\n\",\n\t\t\t\t\tacb->adapter_index, cdb_phyaddr_hi32);\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\t\ttimeout \\n\", acb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tuint32_t __iomem *rwbuffer;\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\twritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\n\t\t\tsizeof(struct InBound_SRB)), rwbuffer++);\n\t\twritel(0x100, rwbuffer);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\n\t\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)\n{\n\tuint32_t firmware_state = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tdo {\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tdo {\n\t\t\tfirmware_state = readl(reg->iop2drv_doorbell);\n\t\t} while ((firmware_state & ARCMSR_MESSAGE_FIRMWARE_OK) == 0);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tdo {\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tdo {\n\t\t\tfirmware_state = readl(reg->outbound_msgaddr1);\n\t\t} while ((firmware_state &\n\t\t\tARCMSR_ARC1214_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)){\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0) || ((acb->acb_flags & ACB_F_ABORT) != 0)) {\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) ||\n\t\t((acb->acb_flags & ACB_F_BUS_RESET) != 0) ||\n\t\t((acb->acb_flags & ACB_F_ABORT) != 0)) {\n\t\tmod_timer(&acb->eternal_timer,\n\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) ==\n\t\t\tatomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value,\n\t\t\tatomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG,\n\t\t\treg->inbound_msgaddr0);\n\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\tmsecs_to_jiffies(6 * HZ));\n\t}\n}\n\nstatic void arcmsr_request_device_map(unsigned long pacb)\n{\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;\n\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A: {\n\t\t\tarcmsr_hbaA_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_B: {\n\t\t\tarcmsr_hbaB_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C: {\n\t\t\tarcmsr_hbaC_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\t\tarcmsr_hbaD_request_device_map(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_hbaA_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\", acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\",acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &phbcmu->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &phbcmu->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\", pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *pmu = pACB->pmuD;\n\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, pmu->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'start adapter \"\n\t\t\t\"background rebulid' timeout\\n\", pACB->host->host_no);\n\t}\n}\n\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_start_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_clear_doorbell_queue_buffer(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_doorbell;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t/*clear doorbell interrupt */\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*clear interrupt and message state*/\n\t\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t/* let IOP know data has been read */\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\t&reg->outbound_doorbell_clear);\n\t\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK,\n\t\t\t\t\t&reg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, reg->outbound_doorbell);\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\treg->outbound_doorbell);\n\t\t\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\t\t\treg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_enable_eoi_mode(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\t{\n\t\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t\twritel(ARCMSR_MESSAGE_ACTIVE_EOI_MODE, reg->drv2iop_doorbell);\n\t\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"ARCMSR IOP enables EOI_MODE TIMEOUT\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn;\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb)\n{\n\tuint8_t value[64];\n\tint i, count = 0;\n\tstruct MessageUnit_A __iomem *pmuA = acb->pmuA;\n\tstruct MessageUnit_C __iomem *pmuC = acb->pmuC;\n\tstruct MessageUnit_D *pmuD = acb->pmuD;\n\n\t/* backup pci config data */\n\tprintk(KERN_NOTICE \"arcmsr%d: executing hw bus reset .....\\n\", acb->host->host_no);\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_read_config_byte(acb->pdev, i, &value[i]);\n\t}\n\t/* hardware reset signal */\n\tif ((acb->dev_id == 0x1680)) {\n\t\twritel(ARCMSR_ARC1680_BUS_RESET, &pmuA->reserved1[0]);\n\t} else if ((acb->dev_id == 0x1880)) {\n\t\tdo {\n\t\t\tcount++;\n\t\t\twritel(0xF, &pmuC->write_sequence);\n\t\t\twritel(0x4, &pmuC->write_sequence);\n\t\t\twritel(0xB, &pmuC->write_sequence);\n\t\t\twritel(0x2, &pmuC->write_sequence);\n\t\t\twritel(0x7, &pmuC->write_sequence);\n\t\t\twritel(0xD, &pmuC->write_sequence);\n\t\t} while (((readl(&pmuC->host_diagnostic) & ARCMSR_ARC1880_DiagWrite_ENABLE) == 0) && (count < 5));\n\t\twritel(ARCMSR_ARC1880_RESET_ADAPTER, &pmuC->host_diagnostic);\n\t} else if ((acb->dev_id == 0x1214)) {\n\t\twritel(0x20, pmuD->reset_request);\n\t} else {\n\t\tpci_write_config_byte(acb->pdev, 0x84, 0x20);\n\t}\n\tmsleep(2000);\n\t/* write back pci config data */\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_write_config_byte(acb->pdev, i, value[i]);\n\t}\n\tmsleep(1000);\n\treturn;\n}\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb)\n{\n\tuint32_t intmask_org;\n\t/* disable all outbound interrupt */\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_wait_firmware_ready(acb);\n\tarcmsr_iop_confirm(acb);\n\t/*start background rebuild*/\n\tarcmsr_start_adapter_bgrb(acb);\n\t/* empty doorbell Qbuffer if door bell ringed */\n\tarcmsr_clear_doorbell_queue_buffer(acb);\n\tarcmsr_enable_eoi_mode(acb);\n\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\tacb->acb_flags |= ACB_F_IOP_INITED;\n}\n\nstatic uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)\n{\n\tstruct CommandControlBlock *ccb;\n\tuint32_t intmask_org;\n\tuint8_t rtnval = 0x00;\n\tint i = 0;\n\tunsigned long flags;\n\n\tif (atomic_read(&acb->ccboutstandingcount) != 0) {\n\t\t/* disable all outbound interrupt */\n\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t/* talk to iop 331 outstanding command aborted */\n\t\trtnval = arcmsr_abort_allcmd(acb);\n\t\t/* clear all outbound posted Q */\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\t\tccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tscsi_dma_unmap(ccb->pcmd);\n\t\t\t\tccb->startdone = ARCMSR_CCB_DONE;\n\t\t\t\tccb->ccb_flags = 0;\n\t\t\t\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\t\t\t\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\t\t\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\t\t}\n\t\t}\n\t\tatomic_set(&acb->ccboutstandingcount, 0);\n\t\t/* enable all outbound interrupt */\n\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\treturn rtnval;\n\t}\n\treturn rtnval;\n}\n\nstatic int arcmsr_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb;\n\tuint32_t intmask_org, outbound_doorbell;\n\tint retry_count = 0;\n\tint rtn = FAILED;\n\tacb = (struct AdapterControlBlock *) cmd->device->host->hostdata;\n\tprintk(KERN_ERR \"arcmsr: executing bus reset eh.....num_resets = %d, num_aborts = %d \\n\", acb->num_resets, acb->num_aborts);\n\tacb->num_resets++;\n\n\tswitch(acb->adapter_type){\n\t\tcase ACB_ADAPTER_TYPE_A:{\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET){\n\t\t\t\tlong timeout;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: there is an  bus reset eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\n\t\t\t\tif (timeout) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_A __iomem *reg;\n\t\t\t\treg = acb->pmuA;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\nsleep_again:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(&reg->outbound_msgaddr1) & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0) {\n\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, retry=%d\\n\", acb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\\n\", acb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto sleep_again;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\t/* clear Qbuffer if door bell ringed */\n\t\t\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t\t\twritel(outbound_doorbell, &reg->outbound_doorbell); /*clear interrupt */\n   \t\t\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t\t\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: scsi  bus reset eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_B:{\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = FAILED;\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_C:{\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET) {\n\t\t\t\tlong timeout;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: there is an bus reset eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\n\t\t\t\tif (timeout) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_C __iomem *reg;\n\t\t\t\treg = acb->pmuC;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\nsleep:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(&reg->host_diagnostic) & 0x04) != 0) {\n\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, retry=%d\\n\", acb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\\n\", acb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto sleep;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\t/* clear Qbuffer if door bell ringed */\n\t\t\t\tarcmsr_clear_doorbell_queue_buffer(acb);\n\t\t\t\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: scsi bus reset eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_D: {\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET) {\n\t\t\t\tlong timeout;\n\t\t\t\tpr_notice(\"arcmsr: there is an bus reset\"\n\t\t\t\t\t\" eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags\n\t\t\t\t\t& ACB_F_BUS_RESET) == 0, 220 * HZ);\n\t\t\t\tif (timeout)\n\t\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_D *reg;\n\t\t\t\treg = acb->pmuD;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\t\t\tnap:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(reg->sample_at_reset) & 0x80) != 0) {\n\t\t\t\t\tpr_err(\"arcmsr%d: waiting for \"\n\t\t\t\t\t\t\"hw bus reset return, retry=%d\\n\",\n\t\t\t\t\t\tacb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tpr_err(\"arcmsr%d: waiting for hw bus\"\n\t\t\t\t\t\t\t\" reset return, \"\n\t\t\t\t\t\t\t\"RETRY TERMINATED!!\\n\",\n\t\t\t\t\t\t\tacb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto nap;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\tarcmsr_clear_doorbell_queue_buffer(acb);\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tpr_err(\"arcmsr: scsi bus reset \"\n\t\t\t\t\t\"eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *ccb)\n{\n\tint rtn;\n\trtn = arcmsr_polling_ccbdone(acb, ccb);\n\treturn rtn;\n}\n\nstatic int arcmsr_abort(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)cmd->device->host->hostdata;\n\tint i = 0;\n\tint rtn = FAILED;\n\tuint32_t intmask_org;\n\n\tprintk(KERN_NOTICE\n\t\t\"arcmsr%d: abort device command of scsi id = %d lun = %d\\n\",\n\t\tacb->host->host_no, cmd->device->id, (u32)cmd->device->lun);\n\tacb->acb_flags |= ACB_F_ABORT;\n\tacb->num_aborts++;\n\t/*\n\t************************************************\n\t** the all interrupt service routine is locked\n\t** we need to handle it as soon as possible and exit\n\t************************************************\n\t*/\n\tif (!atomic_read(&acb->ccboutstandingcount)) {\n\t\tacb->acb_flags &= ~ACB_F_ABORT;\n\t\treturn rtn;\n\t}\n\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\tif (ccb->startdone == ARCMSR_CCB_START && ccb->pcmd == cmd) {\n\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\trtn = arcmsr_abort_one_cmd(acb, ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n\tacb->acb_flags &= ~ACB_F_ABORT;\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\treturn rtn;\n}\n\nstatic const char *arcmsr_info(struct Scsi_Host *host)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tstatic char buf[256];\n\tchar *type;\n\tint raid6 = 1;\n\tswitch (acb->pdev->device) {\n\tcase PCI_DEVICE_ID_ARECA_1110:\n\tcase PCI_DEVICE_ID_ARECA_1200:\n\tcase PCI_DEVICE_ID_ARECA_1202:\n\tcase PCI_DEVICE_ID_ARECA_1210:\n\t\traid6 = 0;\n\t\t/*FALLTHRU*/\n\tcase PCI_DEVICE_ID_ARECA_1120:\n\tcase PCI_DEVICE_ID_ARECA_1130:\n\tcase PCI_DEVICE_ID_ARECA_1160:\n\tcase PCI_DEVICE_ID_ARECA_1170:\n\tcase PCI_DEVICE_ID_ARECA_1201:\n\tcase PCI_DEVICE_ID_ARECA_1203:\n\tcase PCI_DEVICE_ID_ARECA_1220:\n\tcase PCI_DEVICE_ID_ARECA_1230:\n\tcase PCI_DEVICE_ID_ARECA_1260:\n\tcase PCI_DEVICE_ID_ARECA_1270:\n\tcase PCI_DEVICE_ID_ARECA_1280:\n\t\ttype = \"SATA\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ARECA_1214:\n\tcase PCI_DEVICE_ID_ARECA_1380:\n\tcase PCI_DEVICE_ID_ARECA_1381:\n\tcase PCI_DEVICE_ID_ARECA_1680:\n\tcase PCI_DEVICE_ID_ARECA_1681:\n\tcase PCI_DEVICE_ID_ARECA_1880:\n\t\ttype = \"SAS/SATA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\traid6 =\t0;\n\t\tbreak;\n\t}\n\tsprintf(buf, \"Areca %s RAID Controller %s\\narcmsr version %s\\n\",\n\t\ttype, raid6 ? \"(RAID6 capable)\" : \"\", ARCMSR_DRIVER_VERSION);\n\treturn buf;\n}\n"], "fixing_code": ["/*\n*******************************************************************************\n**        O.S   : Linux\n**   FILE NAME  : arcmsr_hba.c\n**        BY    : Nick Cheng, C.L. Huang\n**   Description: SCSI RAID Device Driver for Areca RAID Controller\n*******************************************************************************\n** Copyright (C) 2002 - 2014, Areca Technology Corporation All rights reserved\n**\n**     Web site: www.areca.com.tw\n**       E-mail: support@areca.com.tw\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License version 2 as\n** published by the Free Software Foundation.\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n*******************************************************************************\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions\n** are met:\n** 1. Redistributions of source code must retain the above copyright\n**    notice, this list of conditions and the following disclaimer.\n** 2. Redistributions in binary form must reproduce the above copyright\n**    notice, this list of conditions and the following disclaimer in the\n**    documentation and/or other materials provided with the distribution.\n** 3. The name of the author may not be used to endorse or promote products\n**    derived from this software without specific prior written permission.\n**\n** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING,BUT\n** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF\n** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*******************************************************************************\n** For history of changes, see Documentation/scsi/ChangeLog.arcmsr\n**     Firmware Specification, see Documentation/scsi/arcmsr_spec.txt\n*******************************************************************************\n*/\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/pci_ids.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/circ_buf.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsicam.h>\n#include \"arcmsr.h\"\nMODULE_AUTHOR(\"Nick Cheng, C.L. Huang <support@areca.com.tw>\");\nMODULE_DESCRIPTION(\"Areca ARC11xx/12xx/16xx/188x SAS/SATA RAID Controller Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(ARCMSR_DRIVER_VERSION);\n\n#define\tARCMSR_SLEEPTIME\t10\n#define\tARCMSR_RETRYCOUNT\t12\n\nstatic wait_queue_head_t wait_q;\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct scsi_cmnd *cmd);\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb);\nstatic int arcmsr_abort(struct scsi_cmnd *);\nstatic int arcmsr_bus_reset(struct scsi_cmnd *);\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *info);\nstatic int arcmsr_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic int arcmsr_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id);\nstatic int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state);\nstatic int arcmsr_resume(struct pci_dev *pdev);\nstatic void arcmsr_remove(struct pci_dev *pdev);\nstatic void arcmsr_shutdown(struct pci_dev *pdev);\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb);\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb);\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\tu32 intmask_org);\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_request_device_map(unsigned long pacb);\nstatic void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb);\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work);\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb);\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *pACB);\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb);\nstatic const char *arcmsr_info(struct Scsi_Host *);\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_irq(struct pci_dev *, struct AdapterControlBlock *);\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb);\nstatic int arcmsr_adjust_disk_queue_depth(struct scsi_device *sdev, int queue_depth)\n{\n\tif (queue_depth > ARCMSR_MAX_CMD_PERLUN)\n\t\tqueue_depth = ARCMSR_MAX_CMD_PERLUN;\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\n\nstatic struct scsi_host_template arcmsr_scsi_host_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Areca SAS/SATA RAID driver\",\n\t.info\t\t\t= arcmsr_info,\n\t.queuecommand\t\t= arcmsr_queue_command,\n\t.eh_abort_handler\t\t= arcmsr_abort,\n\t.eh_bus_reset_handler\t= arcmsr_bus_reset,\n\t.bios_param\t\t= arcmsr_bios_param,\n\t.change_queue_depth\t= arcmsr_adjust_disk_queue_depth,\n\t.can_queue\t\t= ARCMSR_MAX_OUTSTANDING_CMD,\n\t.this_id\t\t\t= ARCMSR_SCSI_INITIATOR_ID,\n\t.sg_tablesize\t        \t= ARCMSR_DEFAULT_SG_ENTRIES, \n\t.max_sectors    \t    \t= ARCMSR_MAX_XFER_SECTORS_C, \n\t.cmd_per_lun\t\t= ARCMSR_MAX_CMD_PERLUN,\n\t.use_clustering\t\t= ENABLE_CLUSTERING,\n\t.shost_attrs\t\t= arcmsr_host_attrs,\n\t.no_write_same\t\t= 1,\n};\n\nstatic struct pci_device_id arcmsr_device_id_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1110),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1120),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1130),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1160),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1170),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1200),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1201),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1202),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1203),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1210),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1214),\n\t\t.driver_data = ACB_ADAPTER_TYPE_D},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1220),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1230),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1260),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1270),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1280),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1380),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1381),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1680),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1681),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1880),\n\t\t.driver_data = ACB_ADAPTER_TYPE_C},\n\t{0, 0}, /* Terminating entry */\n};\nMODULE_DEVICE_TABLE(pci, arcmsr_device_id_table);\n\nstatic struct pci_driver arcmsr_pci_driver = {\n\t.name\t\t\t= \"arcmsr\",\n\t.id_table\t\t\t= arcmsr_device_id_table,\n\t.probe\t\t\t= arcmsr_probe,\n\t.remove\t\t\t= arcmsr_remove,\n\t.suspend\t\t= arcmsr_suspend,\n\t.resume\t\t\t= arcmsr_resume,\n\t.shutdown\t\t= arcmsr_shutdown,\n};\n/*\n****************************************************************************\n****************************************************************************\n*/\n\nstatic void arcmsr_free_mu(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tdma_free_coherent(&acb->pdev->dev, acb->roundup_ccbsize,\n\t\t\tacb->dma_coherent2, acb->dma_coherent_handle2);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tswitch (acb->adapter_type){\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tacb->pmuA = ioremap(pci_resource_start(pdev,0), pci_resource_len(pdev,0));\n\t\tif (!acb->pmuA) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tvoid __iomem *mem_base0, *mem_base1;\n\t\tmem_base0 = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\n\t\tif (!mem_base0) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tmem_base1 = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));\n\t\tif (!mem_base1) {\n\t\t\tiounmap(mem_base0);\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tacb->mem_base1 = mem_base1;\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tacb->pmuC = ioremap_nocache(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\n\t\tif (!acb->pmuC) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tif (readl(&acb->pmuC->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &acb->pmuC->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tvoid __iomem *mem_base0;\n\t\tunsigned long addr, range, flags;\n\n\t\taddr = (unsigned long)pci_resource_start(pdev, 0);\n\t\trange = pci_resource_len(pdev, 0);\n\t\tflags = pci_resource_flags(pdev, 0);\n\t\tmem_base0 = ioremap(addr, range);\n\t\tif (!mem_base0) {\n\t\t\tpr_notice(\"arcmsr%d: memory mapping region fail\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void arcmsr_unmap_pciregion(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tiounmap(acb->pmuA);\n\t}\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tiounmap(acb->mem_base0);\n\t\tiounmap(acb->mem_base1);\n\t}\n\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tiounmap(acb->pmuC);\n\t}\n\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tiounmap(acb->mem_base0);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t arcmsr_do_interrupt(int irq, void *dev_id)\n{\n\tirqreturn_t handle_state;\n\tstruct AdapterControlBlock *acb = dev_id;\n\n\thandle_state = arcmsr_interrupt(acb);\n\treturn handle_state;\n}\n\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *geom)\n{\n\tint ret, heads, sectors, cylinders, total_capacity;\n\tunsigned char *buffer;/* return copy of block device's partition table */\n\n\tbuffer = scsi_bios_ptable(bdev);\n\tif (buffer) {\n\t\tret = scsi_partsize(buffer, capacity, &geom[2], &geom[0], &geom[1]);\n\t\tkfree(buffer);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n\ttotal_capacity = capacity;\n\theads = 64;\n\tsectors = 32;\n\tcylinders = total_capacity / (heads * sectors);\n\tif (cylinders > 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = total_capacity / (heads * sectors);\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\treturn 0;\n}\n\nstatic uint8_t arcmsr_hbaA_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&reg->outbound_intstatus) &\n\t\t\t\tARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\n\t\t\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT,\n\t\t\t\t&reg->outbound_intstatus);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaB_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->iop2drv_doorbell)\n\t\t\t& ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN,\n\t\t\t\t\treg->iop2drv_doorbell);\n\t\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT,\n\t\t\t\t\treg->drv2iop_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaC_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&phbcmu->outbound_doorbell)\n\t\t\t\t& ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR,\n\t\t\t\t&phbcmu->outbound_doorbell_clear); /*clear interrupt*/\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\n\treturn false;\n}\n\nstatic bool arcmsr_hbaD_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->outbound_doorbell)\n\t\t\t& ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\t\treg->outbound_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t} /* max 20 seconds */\n\treturn false;\n}\n\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint retry_count = 30;\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaA_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout, retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint retry_count = 30;\n\twritel(ARCMSR_MESSAGE_FLUSH_CACHE, reg->drv2iop_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaB_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaC_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tint retry_count = 30;/* enlarge wait flush adapter cache time: 10 minute */\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", pACB->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n\treturn;\n}\n\nstatic void arcmsr_hbaD_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tint retry_count = 15;\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\t\tbreak;\n\n\t\tretry_count--;\n\t\tpr_notice(\"arcmsr%d: wait 'flush adapter \"\n\t\t\t\"cache' timeout, retry count down = %d\\n\",\n\t\t\tpACB->host->host_no, retry_count);\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_flush_adapter_cache(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tarcmsr_hbaA_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tarcmsr_hbaB_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tarcmsr_hbaC_flush_cache(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_flush_cache(acb);\n\t\tbreak;\n\t}\n}\n\nstatic bool arcmsr_alloc_io_queue(struct AdapterControlBlock *acb)\n{\n\tbool rtn = true;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct pci_dev *pdev = acb->pdev;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg;\n\t\tacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_B), 32);\n\t\tdma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\treg = (struct MessageUnit_B *)dma_coherent;\n\t\tacb->pmuB = reg;\n\t\tif (acb->pdev->device == PCI_DEVICE_ID_ARECA_1203) {\n\t\t\treg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_1203);\n\t\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK_1203);\n\t\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_1203);\n\t\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK_1203);\n\t\t} else {\n\t\t\treg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL);\n\t\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK);\n\t\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL);\n\t\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK);\n\t\t}\n\t\treg->message_wbuffer = MEM_BASE1(ARCMSR_MESSAGE_WBUFFER);\n\t\treg->message_rbuffer = MEM_BASE1(ARCMSR_MESSAGE_RBUFFER);\n\t\treg->message_rwbuffer = MEM_BASE1(ARCMSR_MESSAGE_RWBUFFER);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg;\n\n\t\tacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_D), 32);\n\t\tdma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\treg = (struct MessageUnit_D *)dma_coherent;\n\t\tacb->pmuD = reg;\n\t\treg->chip_id = MEM_BASE0(ARCMSR_ARC1214_CHIP_ID);\n\t\treg->cpu_mem_config = MEM_BASE0(ARCMSR_ARC1214_CPU_MEMORY_CONFIGURATION);\n\t\treg->i2o_host_interrupt_mask = MEM_BASE0(ARCMSR_ARC1214_I2_HOST_INTERRUPT_MASK);\n\t\treg->sample_at_reset = MEM_BASE0(ARCMSR_ARC1214_SAMPLE_RESET);\n\t\treg->reset_request = MEM_BASE0(ARCMSR_ARC1214_RESET_REQUEST);\n\t\treg->host_int_status = MEM_BASE0(ARCMSR_ARC1214_MAIN_INTERRUPT_STATUS);\n\t\treg->pcief0_int_enable = MEM_BASE0(ARCMSR_ARC1214_PCIE_F0_INTERRUPT_ENABLE);\n\t\treg->inbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE0);\n\t\treg->inbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE1);\n\t\treg->outbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE0);\n\t\treg->outbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE1);\n\t\treg->inbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_INBOUND_DOORBELL);\n\t\treg->outbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL);\n\t\treg->outbound_doorbell_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL_ENABLE);\n\t\treg->inboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_LOW);\n\t\treg->inboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_HIGH);\n\t\treg->inboundlist_write_pointer = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_WRITE_POINTER);\n\t\treg->outboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_LOW);\n\t\treg->outboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_HIGH);\n\t\treg->outboundlist_copy_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_COPY_POINTER);\n\t\treg->outboundlist_read_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_READ_POINTER);\n\t\treg->outboundlist_interrupt_cause = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_CAUSE);\n\t\treg->outboundlist_interrupt_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_ENABLE);\n\t\treg->message_wbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_WBUFFER);\n\t\treg->message_rbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RBUFFER);\n\t\treg->msgcode_rwbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RWBUFFER);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct CommandControlBlock *ccb_tmp;\n\tint i = 0, j = 0;\n\tdma_addr_t cdb_phyaddr;\n\tunsigned long roundup_ccbsize;\n\tunsigned long max_xfer_len;\n\tunsigned long max_sg_entrys;\n\tuint32_t  firm_config_version;\n\n\tfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\n\t\tfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\n\t\t\tacb->devstate[i][j] = ARECA_RAID_GONE;\n\n\tmax_xfer_len = ARCMSR_MAX_XFER_LEN;\n\tmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\n\tfirm_config_version = acb->firm_cfg_version;\n\tif((firm_config_version & 0xFF) >= 3){\n\t\tmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;/* max 4M byte */\n\t\tmax_sg_entrys = (max_xfer_len/4096);\n\t}\n\tacb->host->max_sectors = max_xfer_len/512;\n\tacb->host->sg_tablesize = max_sg_entrys;\n\troundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\n\tacb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\n\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\n\tif(!dma_coherent){\n\t\tprintk(KERN_NOTICE \"arcmsr%d: dma_alloc_coherent got error\\n\", acb->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\tacb->dma_coherent = dma_coherent;\n\tacb->dma_coherent_handle = dma_coherent_handle;\n\tmemset(dma_coherent, 0, acb->uncache_size);\n\tccb_tmp = dma_coherent;\n\tacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\n\tfor(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\n\t\tcdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\n\t\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A:\n\t\tcase ACB_ADAPTER_TYPE_B:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\n\t\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C:\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr;\n\t\t\tbreak;\n\t\t}\n\t\tacb->pccb_pool[i] = ccb_tmp;\n\t\tccb_tmp->acb = acb;\n\t\tINIT_LIST_HEAD(&ccb_tmp->list);\n\t\tlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\n\t\tccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\n\t\tdma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\n\t}\n\treturn 0;\n}\n\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work) \n{\n\tstruct AdapterControlBlock *acb = container_of(work,\n\t\tstruct AdapterControlBlock, arcmsr_do_message_isr_bh);\n\tchar *acb_dev_map = (char *)acb->device_map;\n\tuint32_t __iomem *signature = NULL;\n\tchar __iomem *devicemap = NULL;\n\tint target, lun;\n\tstruct scsi_device *psdev;\n\tchar diff, temp;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\t}\n\tatomic_inc(&acb->rq_map_token);\n\tif (readl(signature) != ARCMSR_SIGNATURE_GET_CONFIG)\n\t\treturn;\n\tfor (target = 0; target < ARCMSR_MAX_TARGETID - 1;\n\t\ttarget++) {\n\t\ttemp = readb(devicemap);\n\t\tdiff = (*acb_dev_map) ^ temp;\n\t\tif (diff != 0) {\n\t\t\t*acb_dev_map = temp;\n\t\t\tfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN;\n\t\t\t\tlun++) {\n\t\t\t\tif ((diff & 0x01) == 1 &&\n\t\t\t\t\t(temp & 0x01) == 1) {\n\t\t\t\t\tscsi_add_device(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t} else if ((diff & 0x01) == 1\n\t\t\t\t\t&& (temp & 0x01) == 0) {\n\t\t\t\t\tpsdev = scsi_device_lookup(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t\tif (psdev != NULL) {\n\t\t\t\t\t\tscsi_remove_device(psdev);\n\t\t\t\t\t\tscsi_device_put(psdev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemp >>= 1;\n\t\t\t\tdiff >>= 1;\n\t\t\t}\n\t\t}\n\t\tdevicemap++;\n\t\tacb_dev_map++;\n\t}\n}\n\nstatic int\narcmsr_request_irq(struct pci_dev *pdev, struct AdapterControlBlock *acb)\n{\n\tint\ti, j, r;\n\tstruct msix_entry entries[ARCMST_NUM_MSIX_VECTORS];\n\n\tfor (i = 0; i < ARCMST_NUM_MSIX_VECTORS; i++)\n\t\tentries[i].entry = i;\n\tr = pci_enable_msix_range(pdev, entries, 1, ARCMST_NUM_MSIX_VECTORS);\n\tif (r < 0)\n\t\tgoto msi_int;\n\tacb->msix_vector_count = r;\n\tfor (i = 0; i < r; i++) {\n\t\tif (request_irq(entries[i].vector,\n\t\t\tarcmsr_do_interrupt, 0, \"arcmsr\", acb)) {\n\t\t\tpr_warn(\"arcmsr%d: request_irq =%d failed!\\n\",\n\t\t\t\tacb->host->host_no, entries[i].vector);\n\t\t\tfor (j = 0 ; j < i ; j++)\n\t\t\t\tfree_irq(entries[j].vector, acb);\n\t\t\tpci_disable_msix(pdev);\n\t\t\tgoto msi_int;\n\t\t}\n\t\tacb->entries[i] = entries[i];\n\t}\n\tacb->acb_flags |= ACB_F_MSIX_ENABLED;\n\tpr_info(\"arcmsr%d: msi-x enabled\\n\", acb->host->host_no);\n\treturn SUCCESS;\nmsi_int:\n\tif (pci_enable_msi_exact(pdev, 1) < 0)\n\t\tgoto legacy_int;\n\tif (request_irq(pdev->irq, arcmsr_do_interrupt,\n\t\tIRQF_SHARED, \"arcmsr\", acb)) {\n\t\tpr_warn(\"arcmsr%d: request_irq =%d failed!\\n\",\n\t\t\tacb->host->host_no, pdev->irq);\n\t\tpci_disable_msi(pdev);\n\t\tgoto legacy_int;\n\t}\n\tacb->acb_flags |= ACB_F_MSI_ENABLED;\n\tpr_info(\"arcmsr%d: msi enabled\\n\", acb->host->host_no);\n\treturn SUCCESS;\nlegacy_int:\n\tif (request_irq(pdev->irq, arcmsr_do_interrupt,\n\t\tIRQF_SHARED, \"arcmsr\", acb)) {\n\t\tpr_warn(\"arcmsr%d: request_irq = %d failed!\\n\",\n\t\t\tacb->host->host_no, pdev->irq);\n\t\treturn FAILED;\n\t}\n\treturn SUCCESS;\n}\n\nstatic int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct AdapterControlBlock *acb;\n\tuint8_t bus,dev_fun;\n\tint error;\n\terror = pci_enable_device(pdev);\n\tif(error){\n\t\treturn -ENODEV;\n\t}\n\thost = scsi_host_alloc(&arcmsr_scsi_host_template, sizeof(struct AdapterControlBlock));\n\tif(!host){\n    \t\tgoto pci_disable_dev;\n\t}\n\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\n\tif(error){\n\t\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif(error){\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"scsi%d: No suitable DMA mask available\\n\",\n\t\t\t       host->host_no);\n\t\t\tgoto scsi_host_release;\n\t\t}\n\t}\n\tinit_waitqueue_head(&wait_q);\n\tbus = pdev->bus->number;\n\tdev_fun = pdev->devfn;\n\tacb = (struct AdapterControlBlock *) host->hostdata;\n\tmemset(acb,0,sizeof(struct AdapterControlBlock));\n\tacb->pdev = pdev;\n\tacb->host = host;\n\thost->max_lun = ARCMSR_MAX_TARGETLUN;\n\thost->max_id = ARCMSR_MAX_TARGETID;\t\t/*16:8*/\n\thost->max_cmd_len = 16;\t \t\t\t/*this is issue of 64bit LBA ,over 2T byte*/\n\thost->can_queue = ARCMSR_MAX_OUTSTANDING_CMD;\n\thost->cmd_per_lun = ARCMSR_MAX_CMD_PERLUN;\t    \n\thost->this_id = ARCMSR_SCSI_INITIATOR_ID;\n\thost->unique_id = (bus << 8) | dev_fun;\n\tpci_set_drvdata(pdev, host);\n\tpci_set_master(pdev);\n\terror = pci_request_regions(pdev, \"arcmsr\");\n\tif(error){\n\t\tgoto scsi_host_release;\n\t}\n\tspin_lock_init(&acb->eh_lock);\n\tspin_lock_init(&acb->ccblist_lock);\n\tspin_lock_init(&acb->postq_lock);\n\tspin_lock_init(&acb->doneq_lock);\n\tspin_lock_init(&acb->rqbuffer_lock);\n\tspin_lock_init(&acb->wqbuffer_lock);\n\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_RQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\tacb->acb_flags &= ~ACB_F_SCSISTOPADAPTER;\n\tINIT_LIST_HEAD(&acb->ccb_free_list);\n\tacb->adapter_type = id->driver_data;\n\terror = arcmsr_remap_pciregion(acb);\n\tif(!error){\n\t\tgoto pci_release_regs;\n\t}\n\terror = arcmsr_alloc_io_queue(acb);\n\tif (!error)\n\t\tgoto unmap_pci_region;\n\terror = arcmsr_get_firmware_spec(acb);\n\tif(!error){\n\t\tgoto free_hbb_mu;\n\t}\n\terror = arcmsr_alloc_ccb_pool(acb);\n\tif(error){\n\t\tgoto free_hbb_mu;\n\t}\n\terror = scsi_add_host(host, &pdev->dev);\n\tif(error){\n\t\tgoto free_ccb_pool;\n\t}\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto scsi_host_remove;\n\tarcmsr_iop_init(acb);\n\tINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\n\tatomic_set(&acb->rq_map_token, 16);\n\tatomic_set(&acb->ante_token_value, 16);\n\tacb->fw_flag = FW_NORMAL;\n\tinit_timer(&acb->eternal_timer);\n\tacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\n\tacb->eternal_timer.data = (unsigned long) acb;\n\tacb->eternal_timer.function = &arcmsr_request_device_map;\n\tadd_timer(&acb->eternal_timer);\n\tif(arcmsr_alloc_sysfs_attr(acb))\n\t\tgoto out_free_sysfs;\n\tscsi_scan_host(host);\n\treturn 0;\nout_free_sysfs:\n\tdel_timer_sync(&acb->eternal_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\tarcmsr_free_irq(pdev, acb);\nscsi_host_remove:\n\tscsi_remove_host(host);\nfree_ccb_pool:\n\tarcmsr_free_ccb_pool(acb);\nfree_hbb_mu:\n\tarcmsr_free_mu(acb);\nunmap_pci_region:\n\tarcmsr_unmap_pciregion(acb);\npci_release_regs:\n\tpci_release_regions(pdev);\nscsi_host_release:\n\tscsi_host_put(host);\npci_disable_dev:\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic void arcmsr_free_irq(struct pci_dev *pdev,\n\t\tstruct AdapterControlBlock *acb)\n{\n\tint i;\n\n\tif (acb->acb_flags & ACB_F_MSI_ENABLED) {\n\t\tfree_irq(pdev->irq, acb);\n\t\tpci_disable_msi(pdev);\n\t} else if (acb->acb_flags & ACB_F_MSIX_ENABLED) {\n\t\tfor (i = 0; i < acb->msix_vector_count; i++)\n\t\t\tfree_irq(acb->entries[i].vector, acb);\n\t\tpci_disable_msix(pdev);\n\t} else\n\t\tfree_irq(pdev->irq, acb);\n}\n\nstatic int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tuint32_t intmask_org;\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tdel_timer_sync(&acb->eternal_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\tpci_set_drvdata(pdev, host);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\treturn 0;\n}\n\nstatic int arcmsr_resume(struct pci_dev *pdev)\n{\n\tint error;\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\tif (pci_enable_device(pdev)) {\n\t\tpr_warn(\"%s: pci_enable_device error\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\n\tif (error) {\n\t\terror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (error) {\n\t\t\tpr_warn(\"scsi%d: No suitable DMA mask available\\n\",\n\t\t\t       host->host_no);\n\t\t\tgoto controller_unregister;\n\t\t}\n\t}\n\tpci_set_master(pdev);\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto controller_stop;\n\tarcmsr_iop_init(acb);\n\tINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\n\tatomic_set(&acb->rq_map_token, 16);\n\tatomic_set(&acb->ante_token_value, 16);\n\tacb->fw_flag = FW_NORMAL;\n\tinit_timer(&acb->eternal_timer);\n\tacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\n\tacb->eternal_timer.data = (unsigned long) acb;\n\tacb->eternal_timer.function = &arcmsr_request_device_map;\n\tadd_timer(&acb->eternal_timer);\n\treturn 0;\ncontroller_stop:\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\ncontroller_unregister:\n\tscsi_remove_host(host);\n\tarcmsr_free_ccb_pool(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaB_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\n\twritel(ARCMSR_MESSAGE_ABORT_CMD, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic uint8_t arcmsr_hbaC_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaD_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'abort all outstanding \"\n\t\t\t\"command' timeout\\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tuint8_t rtnval = 0;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\trtnval = arcmsr_hbaA_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\trtnval = arcmsr_hbaB_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\trtnval = arcmsr_hbaC_abort_allcmd(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtnval = arcmsr_hbaD_abort_allcmd(acb);\n\t\tbreak;\n\t}\n\treturn rtnval;\n}\n\nstatic void arcmsr_pci_unmap_dma(struct CommandControlBlock *ccb)\n{\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\n\tscsi_dma_unmap(pcmd);\n}\n\nstatic void arcmsr_ccb_complete(struct CommandControlBlock *ccb)\n{\n\tstruct AdapterControlBlock *acb = ccb->acb;\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\tunsigned long flags;\n\tatomic_dec(&acb->ccboutstandingcount);\n\tarcmsr_pci_unmap_dma(ccb);\n\tccb->startdone = ARCMSR_CCB_DONE;\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\tpcmd->scsi_done(pcmd);\n}\n\nstatic void arcmsr_report_sense_info(struct CommandControlBlock *ccb)\n{\n\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\tstruct SENSE_DATA *sensebuffer = (struct SENSE_DATA *)pcmd->sense_buffer;\n\tpcmd->result = DID_OK << 16;\n\tif (sensebuffer) {\n\t\tint sense_data_length =\n\t\t\tsizeof(struct SENSE_DATA) < SCSI_SENSE_BUFFERSIZE\n\t\t\t? sizeof(struct SENSE_DATA) : SCSI_SENSE_BUFFERSIZE;\n\t\tmemset(sensebuffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tmemcpy(sensebuffer, ccb->arcmsr_cdb.SenseData, sense_data_length);\n\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\tsensebuffer->Valid = 1;\n\t}\n}\n\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb)\n{\n\tu32 orig_mask = 0;\n\tswitch (acb->adapter_type) {\t\n\tcase ACB_ADAPTER_TYPE_A : {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\torig_mask = readl(&reg->outbound_intmask);\n\t\twritel(orig_mask|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE, \\\n\t\t\t\t\t\t&reg->outbound_intmask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B : {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\torig_mask = readl(reg->iop2drv_doorbell_mask);\n\t\twritel(0, reg->iop2drv_doorbell_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t/* disable all outbound interrupt */\n\t\torig_mask = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\t\twritel(orig_mask|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\t/* disable all outbound interrupt */\n\t\twritel(ARCMSR_ARC1214_ALL_INT_DISABLE, reg->pcief0_int_enable);\n\t\t}\n\t\tbreak;\n\t}\n\treturn orig_mask;\n}\n\nstatic void arcmsr_report_ccb_state(struct AdapterControlBlock *acb, \n\t\t\tstruct CommandControlBlock *ccb, bool error)\n{\n\tuint8_t id, lun;\n\tid = ccb->pcmd->device->id;\n\tlun = ccb->pcmd->device->lun;\n\tif (!error) {\n\t\tif (acb->devstate[id][lun] == ARECA_RAID_GONE)\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\tccb->pcmd->result = DID_OK << 16;\n\t\tarcmsr_ccb_complete(ccb);\n\t}else{\n\t\tswitch (ccb->arcmsr_cdb.DeviceStatus) {\n\t\tcase ARCMSR_DEV_SELECT_TIMEOUT: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_ABORTED:\n\n\t\tcase ARCMSR_DEV_INIT_FAIL: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_BAD_TARGET << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_CHECK_CONDITION: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\t\tarcmsr_report_sense_info(ccb);\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"arcmsr%d: scsi id = %d lun = %d isr get command error done, \\\n\t\t\t\tbut got unknown DeviceStatus = 0x%x \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, id\n\t\t\t\t, lun\n\t\t\t\t, ccb->arcmsr_cdb.DeviceStatus);\n\t\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error)\n{\n\tint id, lun;\n\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\tstruct scsi_cmnd *abortcmd = pCCB->pcmd;\n\t\t\tif (abortcmd) {\n\t\t\t\tid = abortcmd->device->id;\n\t\t\t\tlun = abortcmd->device->lun;\t\t\t\t\n\t\t\t\tabortcmd->result |= DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: pCCB ='0x%p' isr got aborted command \\n\",\n\t\t\t\tacb->host->host_no, pCCB);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprintk(KERN_NOTICE \"arcmsr%d: isr get an illegal ccb command \\\n\t\t\t\tdone acb = '0x%p'\"\n\t\t\t\t\"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x\"\n\t\t\t\t\" ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, acb\n\t\t\t\t, pCCB\n\t\t\t\t, pCCB->acb\n\t\t\t\t, pCCB->startdone\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t  return;\n\t}\n\tarcmsr_report_ccb_state(acb, pCCB, error);\n}\n\nstatic void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)\n{\n\tint i = 0;\n\tuint32_t flag_ccb, ccb_cdb_phy;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_intstatus;\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\t\t\tacb->outbound_int_enable;\n\t\t/*clear and abort all outbound posted Q*/\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\t\twhile(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)\n\t\t\t\t&& (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\n\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*clear all outbound posted Q*/\n\t\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell); /* clear doorbell interrupt */\n\t\tfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\n\t\t\tflag_ccb = reg->done_qbuffer[i];\n\t\t\tif (flag_ccb != 0) {\n\t\t\t\treg->done_qbuffer[i] = 0;\n\t\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t}\n\t\t\treg->post_qbuffer[i] = 0;\n\t\t}\n\t\treg->doneq_index = 0;\n\t\treg->postq_index = 0;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\twhile ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\n\t\t\t/*need to do*/\n\t\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)(acb->vir2phy_offset+ccb_cdb_phy);/*frame must be 32 bytes aligned*/\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tuint32_t outbound_write_pointer;\n\t\tuint32_t doneq_index, index_stripped, addressLow, residual, toggle;\n\t\tunsigned long flags;\n\n\t\tresidual = atomic_read(&acb->ccboutstandingcount);\n\t\tfor (i = 0; i < residual; i++) {\n\t\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\t\toutbound_write_pointer =\n\t\t\t\tpmu->done_qbuffer[0].addressLow + 1;\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\tif ((doneq_index & 0xFFF) !=\n\t\t\t\t(outbound_write_pointer & 0xFFF)) {\n\t\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t\t0xFFF].addressLow;\n\t\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)\n\t\t\t\t\t(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\t\tpCCB = container_of(pARCMSR_CDB,\n\t\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (addressLow &\n\t\t\t\t\tARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ?\n\t\t\t\t\ttrue : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t\twritel(doneq_index,\n\t\t\t\t\tpmu->outboundlist_read_pointer);\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\tmdelay(10);\n\t\t\t}\n\t\t}\n\t\tpmu->postq_index = 0;\n\t\tpmu->doneq_index = 0x40FF;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tint poll_count = 0;\n\tarcmsr_free_sysfs_attr(acb);\n\tscsi_remove_host(host);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tdel_timer_sync(&acb->eternal_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\t\n\tacb->acb_flags |= ACB_F_SCSISTOPADAPTER;\n\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\n\tfor (poll_count = 0; poll_count < ARCMSR_MAX_OUTSTANDING_CMD; poll_count++){\n\t\tif (!atomic_read(&acb->ccboutstandingcount))\n\t\t\tbreak;\n\t\tarcmsr_interrupt(acb);/* FIXME: need spinlock */\n\t\tmsleep(25);\n\t}\n\n\tif (atomic_read(&acb->ccboutstandingcount)) {\n\t\tint i;\n\n\t\tarcmsr_abort_allcmd(acb);\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t}\n\t}\n\tarcmsr_free_irq(pdev, acb);\n\tarcmsr_free_ccb_pool(acb);\n\tarcmsr_free_mu(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}\n\nstatic void arcmsr_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\tdel_timer_sync(&acb->eternal_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n}\n\nstatic int arcmsr_module_init(void)\n{\n\tint error = 0;\n\terror = pci_register_driver(&arcmsr_pci_driver);\n\treturn error;\n}\n\nstatic void arcmsr_module_exit(void)\n{\n\tpci_unregister_driver(&arcmsr_pci_driver);\n}\nmodule_init(arcmsr_module_init);\nmodule_exit(arcmsr_module_exit);\n\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\t\t\t\t\t\tu32 intmask_org)\n{\n\tu32 mask;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tmask = intmask_org & ~(ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE |\n\t\t\t     ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE|\n\t\t\t     ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE);\n\t\twritel(mask, &reg->outbound_intmask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x000000ff;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tmask = intmask_org | (ARCMSR_IOP2DRV_DATA_WRITE_OK |\n\t\t\tARCMSR_IOP2DRV_DATA_READ_OK |\n\t\t\tARCMSR_IOP2DRV_CDB_DONE |\n\t\t\tARCMSR_IOP2DRV_MESSAGE_CMD_DONE);\n\t\twritel(mask, reg->iop2drv_doorbell_mask);\n\t\tacb->outbound_int_enable = (intmask_org | mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tmask = ~(ARCMSR_HBCMU_UTILITY_A_ISR_MASK | ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK);\n\t\twritel(intmask_org & mask, &reg->host_int_mask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\t\tmask = ARCMSR_ARC1214_ALL_INT_ENABLE;\n\t\twritel(intmask_org | mask, reg->pcief0_int_enable);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_build_ccb(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *ccb, struct scsi_cmnd *pcmd)\n{\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tint8_t *psge = (int8_t *)&arcmsr_cdb->u;\n\t__le32 address_lo, address_hi;\n\tint arccdbsize = 0x30;\n\t__le32 length = 0;\n\tint i;\n\tstruct scatterlist *sg;\n\tint nseg;\n\tccb->pcmd = pcmd;\n\tmemset(arcmsr_cdb, 0, sizeof(struct ARCMSR_CDB));\n\tarcmsr_cdb->TargetID = pcmd->device->id;\n\tarcmsr_cdb->LUN = pcmd->device->lun;\n\tarcmsr_cdb->Function = 1;\n\tarcmsr_cdb->msgContext = 0;\n\tmemcpy(arcmsr_cdb->Cdb, pcmd->cmnd, pcmd->cmd_len);\n\n\tnseg = scsi_dma_map(pcmd);\n\tif (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))\n\t\treturn FAILED;\n\tscsi_for_each_sg(pcmd, sg, nseg, i) {\n\t\t/* Get the physical address of the current data pointer */\n\t\tlength = cpu_to_le32(sg_dma_len(sg));\n\t\taddress_lo = cpu_to_le32(dma_addr_lo32(sg_dma_address(sg)));\n\t\taddress_hi = cpu_to_le32(dma_addr_hi32(sg_dma_address(sg)));\n\t\tif (address_hi == 0) {\n\t\t\tstruct SG32ENTRY *pdma_sg = (struct SG32ENTRY *)psge;\n\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length;\n\t\t\tpsge += sizeof (struct SG32ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG32ENTRY);\n\t\t} else {\n\t\t\tstruct SG64ENTRY *pdma_sg = (struct SG64ENTRY *)psge;\n\n\t\t\tpdma_sg->addresshigh = address_hi;\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length|cpu_to_le32(IS_SG64_ADDR);\n\t\t\tpsge += sizeof (struct SG64ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG64ENTRY);\n\t\t}\n\t}\n\tarcmsr_cdb->sgcount = (uint8_t)nseg;\n\tarcmsr_cdb->DataLength = scsi_bufflen(pcmd);\n\tarcmsr_cdb->msgPages = arccdbsize/0x100 + (arccdbsize % 0x100 ? 1 : 0);\n\tif ( arccdbsize > 256)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE;\n\tif (pcmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_WRITE;\n\tccb->arc_cdb_size = arccdbsize;\n\treturn SUCCESS;\n}\n\nstatic void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\n{\n\tuint32_t cdb_phyaddr = ccb->cdb_phyaddr;\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tatomic_inc(&acb->ccboutstandingcount);\n\tccb->startdone = ARCMSR_CCB_START;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\n\t\t\twritel(cdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\n\t\t\t&reg->inbound_queueport);\n\t\telse\n\t\t\twritel(cdb_phyaddr, &reg->inbound_queueport);\n\t\tbreak;\n\t}\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t ending_index, index = reg->postq_index;\n\n\t\tending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\n\t\treg->post_qbuffer[ending_index] = 0;\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\n\t\t\treg->post_qbuffer[index] =\n\t\t\t\tcdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE;\n\t\t} else {\n\t\t\treg->post_qbuffer[index] = cdb_phyaddr;\n\t\t}\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;/*if last index number set it to 0 */\n\t\treg->postq_index = index;\n\t\twritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tuint32_t ccb_post_stamp, arc_cdb_size;\n\n\t\tarc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\n\t\tccb_post_stamp = (cdb_phyaddr | ((arc_cdb_size - 1) >> 6) | 1);\n\t\tif (acb->cdb_phyaddr_hi32) {\n\t\t\twritel(acb->cdb_phyaddr_hi32, &phbcmu->inbound_queueport_high);\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t} else {\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tu16 index_stripped;\n\t\tu16 postq_index, toggle;\n\t\tunsigned long flags;\n\t\tstruct InBound_SRB *pinbound_srb;\n\n\t\tspin_lock_irqsave(&acb->postq_lock, flags);\n\t\tpostq_index = pmu->postq_index;\n\t\tpinbound_srb = (struct InBound_SRB *)&(pmu->post_qbuffer[postq_index & 0xFF]);\n\t\tpinbound_srb->addressHigh = dma_addr_hi32(cdb_phyaddr);\n\t\tpinbound_srb->addressLow = dma_addr_lo32(cdb_phyaddr);\n\t\tpinbound_srb->length = ccb->arc_cdb_size >> 2;\n\t\tarcmsr_cdb->msgContext = dma_addr_lo32(cdb_phyaddr);\n\t\ttoggle = postq_index & 0x4000;\n\t\tindex_stripped = postq_index + 1;\n\t\tindex_stripped &= (ARCMSR_MAX_ARC1214_POSTQUEUE - 1);\n\t\tpmu->postq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t(toggle ^ 0x4000);\n\t\twritel(postq_index, pmu->inboundlist_write_pointer);\n\t\tspin_unlock_irqrestore(&acb->postq_lock, flags);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaA_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_STOP_BGRB, reg->drv2iop_doorbell);\n\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebulid' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\tpr_notice(\"arcmsr%d: wait 'stop adapter background rebulid' \"\n\t\t\t\"timeout\\n\", pACB->host->host_no);\n}\n\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tarcmsr_hbaA_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tarcmsr_hbaB_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tarcmsr_hbaC_stop_bgrb(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_stop_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tdma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);\n}\n\nstatic void arcmsr_iop_message_read(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_DRV2IOP_DATA_WRITE_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstruct QBUFFER __iomem *arcmsr_get_iop_rqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *qbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tqbuffer = (struct QBUFFER __iomem *)&phbcmu->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\t}\n\treturn qbuffer;\n}\n\nstatic struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *pqbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tpqbuffer = (struct QBUFFER __iomem *) &reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B  *reg = acb->pmuB;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tpqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\t}\n\treturn pqbuffer;\n}\n\nstatic uint32_t\narcmsr_Read_iop_rqbuffer_in_DWORD(struct AdapterControlBlock *acb,\n\t\tstruct QBUFFER __iomem *prbuffer)\n{\n\tuint8_t *pQbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t iop_len, data_len, *buf2 = NULL;\n\n\tiop_data = (uint32_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\tif (iop_len > 0) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn 0;\n\t\tdata_len = iop_len;\n\t\twhile (data_len >= 4) {\n\t\t\t*buf2++ = readl(iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len)\n\t\t\t*buf2 = readl(iop_data);\n\t\tbuf2 = (uint32_t *)buf1;\n\t}\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = *buf1;\n\t\tacb->rqbuf_putIndex++;\n\t\t/* if last, index number set it to 0 */\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tbuf1++;\n\t\tiop_len--;\n\t}\n\tkfree(buf2);\n\t/* let IOP know data has been read */\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nuint32_t\narcmsr_Read_iop_rqbuffer_data(struct AdapterControlBlock *acb,\n\tstruct QBUFFER __iomem *prbuffer) {\n\n\tuint8_t *pQbuffer;\n\tuint8_t __iomem *iop_data;\n\tuint32_t iop_len;\n\n\tif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D))\n\t\treturn arcmsr_Read_iop_rqbuffer_in_DWORD(acb, prbuffer);\n\tiop_data = (uint8_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = readb(iop_data);\n\t\tacb->rqbuf_putIndex++;\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tiop_data++;\n\t\tiop_len--;\n\t}\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nstatic void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\tstruct QBUFFER __iomem  *prbuffer;\n\tint32_t buf_empty_len;\n\n\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\tbuf_empty_len = (acb->rqbuf_putIndex - acb->rqbuf_getIndex - 1) &\n\t\t(ARCMSR_MAX_QBUFFER - 1);\n\tif (buf_empty_len >= readl(&prbuffer->data_len)) {\n\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t} else\n\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n}\n\nstatic void arcmsr_write_ioctldata2iop_in_DWORD(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t allxfer_len = 0, data_len, *buf2 = NULL, data;\n\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn;\n\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint32_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\t*buf1 = *pQbuffer;\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tbuf1++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\tdata_len = allxfer_len;\n\t\tbuf1 = (uint8_t *)buf2;\n\t\twhile (data_len >= 4) {\n\t\t\tdata = *buf2++;\n\t\t\twritel(data, iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len) {\n\t\t\tdata = *buf2;\n\t\t\twritel(data, iop_data);\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tkfree(buf1);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nvoid\narcmsr_write_ioctldata2iop(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t __iomem *iop_data;\n\tint32_t allxfer_len = 0;\n\n\tif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D)) {\n\t\tarcmsr_write_ioctldata2iop_in_DWORD(acb);\n\t\treturn;\n\t}\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint8_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\twriteb(*pQbuffer, iop_data);\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tiop_data++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nstatic void arcmsr_iop2drv_data_read_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_READED;\n\tif (acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\tarcmsr_write_ioctldata2iop(acb);\n\tif (acb->wqbuf_getIndex == acb->wqbuf_putIndex)\n\t\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n}\n\nstatic void arcmsr_hbaA_doorbell_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK\n\t\t| ARCMSR_OUTBOUND_IOP331_DATA_READ_OK));\n}\nstatic void arcmsr_hbaC_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\t/*\n\t*******************************************************************\n\t**  Maybe here we need to check wrqbuffer_lock is lock or not\n\t**  DOORBELL: din! don!\n\t**  check if there are any mail need to pack from firmware\n\t*******************************************************************\n\t*/\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\treadl(&reg->outbound_doorbell_clear);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaC_message_isr(pACB);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaD_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, pmu->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaD_message_isr(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaA_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\twhile ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t}\n}\nstatic void arcmsr_hbaB_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t index;\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\tindex = reg->doneq_index;\n\twhile ((flag_ccb = reg->done_qbuffer[index]) != 0) {\n\t\treg->done_qbuffer[index] = 0;\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t}\n}\n\nstatic void arcmsr_hbaC_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *phbcmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, ccb_cdb_phy, throttling = 0;\n\tint error;\n\n\tphbcmu = acb->pmuC;\n\t/* areca cdb command done */\n\t/* Use correct offset and size for syncing */\n\n\twhile ((flag_ccb = readl(&phbcmu->outbound_queueport_low)) !=\n\t\t\t0xFFFFFFFF) {\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t+ ccb_cdb_phy);\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\t/* check if command done with no error */\n\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\tthrottling++;\n\t\tif (throttling == ARCMSR_HBC_ISR_THROTTLING_LEVEL) {\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING,\n\t\t\t\t&phbcmu->inbound_doorbell);\n\t\t\tthrottling = 0;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaD_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tu32 outbound_write_pointer, doneq_index, index_stripped, toggle;\n\tuint32_t addressLow, ccb_cdb_phy;\n\tint error;\n\tstruct MessageUnit_D  *pmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\tpmu = acb->pmuD;\n\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\tdoneq_index = pmu->doneq_index;\n\tif ((doneq_index & 0xFFF) != (outbound_write_pointer & 0xFFF)) {\n\t\tdo {\n\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t0xFFF].addressLow;\n\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t\t+ ccb_cdb_phy);\n\t\t\tccb = container_of(arcmsr_cdb,\n\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (addressLow & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t\t? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\t\twritel(doneq_index, pmu->outboundlist_read_pointer);\n\t\t} while ((doneq_index & 0xFFF) !=\n\t\t\t(outbound_write_pointer & 0xFFF));\n\t}\n\twritel(ARCMSR_ARC1214_OUTBOUND_LIST_INTERRUPT_CLEAR,\n\t\tpmu->outboundlist_interrupt_cause);\n\treadl(pmu->outboundlist_interrupt_cause);\n\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n}\n\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the current adapter config.  \n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaA_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT, &reg->outbound_intstatus);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\nstatic void arcmsr_hbaB_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the\n** current adapter config.\n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE, reg->outbound_doorbell);\n\treadl(reg->outbound_doorbell);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_intstatus;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\tacb->outbound_int_enable;\n\tif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\n\t\t\tarcmsr_hbaA_doorbell_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\n\t\t\tarcmsr_hbaA_postqueue_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\n\t\t\tarcmsr_hbaA_message_isr(acb);\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\n\t\t| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\n\t\t| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaB_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\t\tacb->outbound_int_enable;\n\tif (!outbound_doorbell)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(~outbound_doorbell, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_CDB_DONE)\n\t\t\tarcmsr_hbaB_postqueue_isr(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaB_message_isr(acb);\n\t\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_doorbell & (ARCMSR_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_IOP2DRV_CDB_DONE\n\t\t| ARCMSR_IOP2DRV_MESSAGE_CMD_DONE));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaC_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t host_interrupt_status;\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\t/*\n\t*********************************************\n\t**   check outbound intstatus\n\t*********************************************\n\t*/\n\thost_interrupt_status = readl(&phbcmu->host_int_status) &\n\t\t(ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaC_doorbell_isr(pACB);\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaC_postqueue_isr(pACB);\n\t\thost_interrupt_status = readl(&phbcmu->host_int_status);\n\t} while (host_interrupt_status & (ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_hbaD_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tu32 host_interrupt_status;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\thost_interrupt_status = readl(pmu->host_int_status) &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaD_postqueue_isr(pACB);\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaD_doorbell_isr(pACB);\n\t\thost_interrupt_status = readl(pmu->host_int_status);\n\t} while (host_interrupt_status &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn arcmsr_hbaA_handle_isr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\treturn arcmsr_hbaB_handle_isr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn arcmsr_hbaC_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_D:\n\t\treturn arcmsr_hbaD_handle_isr(acb);\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic void arcmsr_iop_parking(struct AdapterControlBlock *acb)\n{\n\tif (acb) {\n\t\t/* stop adapter background rebuild */\n\t\tif (acb->acb_flags & ACB_F_MSG_START_BGRB) {\n\t\t\tuint32_t intmask_org;\n\t\t\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\tarcmsr_stop_adapter_bgrb(acb);\n\t\t\tarcmsr_flush_adapter_cache(acb);\n\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t}\n\t}\n}\n\n\nvoid arcmsr_clear_iop2drv_rqueue_buffer(struct AdapterControlBlock *acb)\n{\n\tuint32_t\ti;\n\n\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\tfor (i = 0; i < 15; i++) {\n\t\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tarcmsr_iop_message_read(acb);\n\t\t\t\tmdelay(30);\n\t\t\t} else if (acb->rqbuf_getIndex !=\n\t\t\t\t   acb->rqbuf_putIndex) {\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tmdelay(30);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint32_t user_len;\n\t\tint32_t cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tkfree(ver_addr);\n\t\t\tgoto message_out;\n\t\t}\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}\n\nstatic struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb)\n{\n\tstruct list_head *head = &acb->ccb_free_list;\n\tstruct CommandControlBlock *ccb = NULL;\n\tunsigned long flags;\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\tif (!list_empty(head)) {\n\t\tccb = list_entry(head->next, struct CommandControlBlock, list);\n\t\tlist_del_init(&ccb->list);\n\t}else{\n\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\treturn ccb;\n}\n\nstatic void arcmsr_handle_virtual_command(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tswitch (cmd->cmnd[0]) {\n\tcase INQUIRY: {\n\t\tunsigned char inqdata[36];\n\t\tchar *buffer;\n\t\tstruct scatterlist *sg;\n\n\t\tif (cmd->device->lun) {\n\t\t\tcmd->result = (DID_TIME_OUT << 16);\n\t\t\tcmd->scsi_done(cmd);\n\t\t\treturn;\n\t\t}\n\t\tinqdata[0] = TYPE_PROCESSOR;\n\t\t/* Periph Qualifier & Periph Dev Type */\n\t\tinqdata[1] = 0;\n\t\t/* rem media bit & Dev Type Modifier */\n\t\tinqdata[2] = 0;\n\t\t/* ISO, ECMA, & ANSI versions */\n\t\tinqdata[4] = 31;\n\t\t/* length of additional data */\n\t\tstrncpy(&inqdata[8], \"Areca   \", 8);\n\t\t/* Vendor Identification */\n\t\tstrncpy(&inqdata[16], \"RAID controller \", 16);\n\t\t/* Product Identification */\n\t\tstrncpy(&inqdata[32], \"R001\", 4); /* Product Revision */\n\n\t\tsg = scsi_sglist(cmd);\n\t\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\n\t\tmemcpy(buffer, inqdata, sizeof(inqdata));\n\t\tsg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\n\t\tcmd->scsi_done(cmd);\n\t}\n\tbreak;\n\tcase WRITE_BUFFER:\n\tcase READ_BUFFER: {\n\t\tif (arcmsr_iop_message_xfer(acb, cmd))\n\t\t\tcmd->result = (DID_ERROR << 16);\n\t\tcmd->scsi_done(cmd);\n\t}\n\tbreak;\n\tdefault:\n\t\tcmd->scsi_done(cmd);\n\t}\n}\n\nstatic int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,\n\tvoid (* done)(struct scsi_cmnd *))\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tstruct CommandControlBlock *ccb;\n\tint target = cmd->device->id;\n\tint lun = cmd->device->lun;\n\tuint8_t scsicmd = cmd->cmnd[0];\n\tcmd->scsi_done = done;\n\tcmd->host_scribble = NULL;\n\tcmd->result = 0;\n\tif ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){\n\t\tif(acb->devstate[target][lun] == ARECA_RAID_GONE) {\n    \t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t}\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\tif (target == 16) {\n\t\t/* virtual device for iop message transfer */\n\t\tarcmsr_handle_virtual_command(acb, cmd);\n\t\treturn 0;\n\t}\n\tccb = arcmsr_get_freeccb(acb);\n\tif (!ccb)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif (arcmsr_build_ccb( acb, ccb, cmd ) == FAILED) {\n\t\tcmd->result = (DID_ERROR << 16) | (RESERVATION_CONFLICT << 1);\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\tarcmsr_post_ccb(acb, ccb);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(arcmsr_queue_command)\n\nstatic bool arcmsr_hbaA_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\n\tchar __iomem *iop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\n\tint count;\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count){\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\n\tcount = 16;\n\twhile (count){\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\n\tcount=16;\n\twhile(count){\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\tacb->signature = readl(&reg->message_rwbuffer[0]);\n\tacb->firm_request_len = readl(&reg->message_rwbuffer[1]);\n\tacb->firm_numbers_queue = readl(&reg->message_rwbuffer[2]);\n\tacb->firm_sdram_size = readl(&reg->message_rwbuffer[3]);\n\tacb->firm_hd_channels = readl(&reg->message_rwbuffer[4]);\n\tacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\treturn true;\n}\nstatic bool arcmsr_hbaB_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model;\n\t/*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version;\n\t/*firm_version,17,68-83*/\n\tchar __iomem *iop_device_map;\n\t/*firm_version,21,84-99*/\n\tint count;\n\n\tiop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\t/*firm_model,15,60-67*/\n\tiop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\t/*firm_version,17,68-83*/\n\tiop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\t/*firm_version,21,84-99*/\n\n\tarcmsr_wait_firmware_ready(acb);\n\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_ERR \"arcmsr%d: can't set driver mode.\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count){\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count){\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\n\tcount = 16;\n\twhile(count){\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\t\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\n\tacb->signature = readl(&reg->message_rwbuffer[0]);\n\t/*firm_signature,1,00-03*/\n\tacb->firm_request_len = readl(&reg->message_rwbuffer[1]);\n\t/*firm_request_len,1,04-07*/\n\tacb->firm_numbers_queue = readl(&reg->message_rwbuffer[2]);\n\t/*firm_numbers_queue,2,08-11*/\n\tacb->firm_sdram_size = readl(&reg->message_rwbuffer[3]);\n\t/*firm_sdram_size,3,12-15*/\n\tacb->firm_hd_channels = readl(&reg->message_rwbuffer[4]);\n\t/*firm_ide_channels,4,16-19*/\n\tacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*firm_ide_channels,4,16-19*/\n\treturn true;\n}\n\nstatic bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\n{\n\tuint32_t intmask_org, Index, firmware_state = 0;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tchar *acb_firm_model = pACB->firm_model;\n\tchar *acb_firm_version = pACB->firm_version;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);    /*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);  /*firm_version,17,68-83*/\n\tint count;\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tdo {\n\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t/* wait message ready */\n\tfor (Index = 0; Index < 2000; Index++) {\n\t\tif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t} /*max 1 seconds*/\n\tif (Index >= 2000) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tpACB->host->host_no,\n\t\tpACB->firm_model,\n\t\tpACB->firm_version);\n\tpACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);   /*firm_request_len,1,04-07*/\n\tpACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]); /*firm_numbers_queue,2,08-11*/\n\tpACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);    /*firm_sdram_size,3,12-15*/\n\tpACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);  /*firm_ide_channels,4,16-19*/\n\tpACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*all interrupt service will be enable at arcmsr_iop_init*/\n\treturn true;\n}\n\nstatic bool arcmsr_hbaD_get_config(struct AdapterControlBlock *acb)\n{\n\tchar *acb_firm_model = acb->firm_model;\n\tchar *acb_firm_version = acb->firm_version;\n\tchar *acb_device_map = acb->device_map;\n\tchar __iomem *iop_firm_model;\n\tchar __iomem *iop_firm_version;\n\tchar __iomem *iop_device_map;\n\tu32 count;\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\tiop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);\n\tiop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);\n\tiop_device_map = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\tif (readl(acb->pmuD->outbound_doorbell) &\n\t\tARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\tacb->pmuD->outbound_doorbell);/*clear interrupt*/\n\t}\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, reg->inbound_msgaddr0);\n\t/* wait message ready */\n\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\tpr_notice(\"arcmsr%d: wait get adapter firmware \"\n\t\t\t\"miscellaneous data timeout\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_device_map = readb(iop_device_map);\n\t\tacb_device_map++;\n\t\tiop_device_map++;\n\t\tcount--;\n\t}\n\tacb->signature = readl(&reg->msgcode_rwbuffer[0]);\n\t/*firm_signature,1,00-03*/\n\tacb->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);\n\t/*firm_request_len,1,04-07*/\n\tacb->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]);\n\t/*firm_numbers_queue,2,08-11*/\n\tacb->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);\n\t/*firm_sdram_size,3,12-15*/\n\tacb->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);\n\t/*firm_hd_channels,4,16-19*/\n\tacb->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tacb->host->host_no,\n\t\tacb->firm_model,\n\t\tacb->firm_version);\n\treturn true;\n}\n\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb)\n{\n\tbool rtn = false;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\trtn = arcmsr_hbaA_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\trtn = arcmsr_hbaB_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\trtn = arcmsr_hbaC_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_get_config(acb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (acb->firm_numbers_queue > ARCMSR_MAX_OUTSTANDING_CMD)\n\t\tacb->maxOutstanding = ARCMSR_MAX_OUTSTANDING_CMD;\n\telse\n\t\tacb->maxOutstanding = acb->firm_numbers_queue - 1;\n\tacb->host->can_queue = acb->maxOutstanding;\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaA_polling_ccbdone(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct CommandControlBlock *ccb;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tuint32_t flag_ccb, outbound_intstatus, poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\n\tbool error;\n\tpolling_hba_ccb_retry:\n\tpoll_count++;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) & acb->outbound_int_enable;\n\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\twhile (1) {\n\t\tif ((flag_ccb = readl(&reg->outbound_queueport)) == 0xFFFFFFFF) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hba_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, ccb->pcmd->device->id\n\t\t\t\t\t, (u32)ccb->pcmd->device->lun\n\t\t\t\t\t, ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaB_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, poll_ccb_done = 0, poll_count = 0;\n\tint index, rtn;\n\tbool error;\n\tpolling_hbb_ccb_retry:\n\n\tpoll_count++;\n\t/* clear doorbell interrupt */\n\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\twhile(1){\n\t\tindex = reg->doneq_index;\n\t\tflag_ccb = reg->done_qbuffer[index];\n\t\tif (flag_ccb == 0) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbb_ccb_retry;\n\t\t\t}\n\t\t}\n\t\treg->done_qbuffer[index] = 0;\n\t\tindex++;\n\t\t/*if last index number set it to 0 */\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t\t/* check if command done with no error*/\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t,acb->host->host_no\n\t\t\t\t\t,ccb->pcmd->device->id\n\t\t\t\t\t,(u32)ccb->pcmd->device->lun\n\t\t\t\t\t,ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t} \n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaC_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\tuint32_t flag_ccb, ccb_cdb_phy;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tuint32_t poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\npolling_hbc_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tif ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) == 0) {\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbc_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);/*frame must be 32 bytes aligned*/\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\t/* check ifcommand done with no error*/\n\t\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaD_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tbool error;\n\tuint32_t poll_ccb_done = 0, poll_count = 0, flag_ccb, ccb_cdb_phy;\n\tint rtn, doneq_index, index_stripped, outbound_write_pointer, toggle;\n\tunsigned long flags;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *pCCB;\n\tstruct MessageUnit_D *pmu = acb->pmuD;\n\npolling_hbaD_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\t\tdoneq_index = pmu->doneq_index;\n\t\tif ((outbound_write_pointer & 0xFFF) == (doneq_index & 0xFFF)) {\n\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 40) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbaD_ccb_retry;\n\t\t\t}\n\t\t}\n\t\ttoggle = doneq_index & 0x4000;\n\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\tdoneq_index = pmu->doneq_index;\n\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\tflag_ccb = pmu->done_qbuffer[doneq_index & 0xFFF].addressLow;\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset +\n\t\t\tccb_cdb_phy);\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\tif ((pCCB->acb != acb) ||\n\t\t\t(pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tpr_notice(\"arcmsr%d: scsi id = %d \"\n\t\t\t\t\t\"lun = %d ccb = '0x%p' poll command \"\n\t\t\t\t\t\"abort successfully\\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_notice(\"arcmsr%d: polling an illegal \"\n\t\t\t\t\"ccb command done ccb = '0x%p' \"\n\t\t\t\t\"ccboutstandingcount = %d\\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tint rtn = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\trtn = arcmsr_hbaA_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\trtn = arcmsr_hbaB_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\trtn = arcmsr_hbaC_polling_ccbdone(acb, poll_ccb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\n{\n\tuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\n\tdma_addr_t dma_coherent_handle;\n\n\t/*\n\t********************************************************************\n\t** here we need to tell iop 331 our freeccb.HighPart\n\t** if freeccb.HighPart is not zero\n\t********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tdma_coherent_handle = acb->dma_coherent_handle2;\n\t\tbreak;\n\tdefault:\n\t\tdma_coherent_handle = acb->dma_coherent_handle;\n\t\tbreak;\n\t}\n\tcdb_phyaddr = lower_32_bits(dma_coherent_handle);\n\tcdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\n\tacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\n\t/*\n\t***********************************************************************\n\t**    if adapter type B, set window of \"post command Q\"\n\t***********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, \\\n\t\t\t\t\t\t&reg->message_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\\n\t\t\t\t\t\t\t&reg->inbound_msgaddr0);\n\t\t\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: \"\"set ccb high \\\n\t\t\t\tpart physical address timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tuint32_t __iomem *rwbuffer;\n\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\twritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cannot set driver mode\\n\", \\\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\trwbuffer = reg->message_rwbuffer;\n\t\t/* driver \"set config\" signature */\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\t/* normal should be zero */\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\t/* postQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\t/* doneQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr + 1056, rwbuffer++);\n\t\t/* ccb maxQ size must be --> [(256 + 8)*4]*/\n\t\twritel(1056, rwbuffer);\n\n\t\twritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\ttimeout \\n\",acb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tpr_err(\"arcmsr%d: can't set driver mode.\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cdb_phyaddr_hi32=0x%x\\n\",\n\t\t\t\t\tacb->adapter_index, cdb_phyaddr_hi32);\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\t\ttimeout \\n\", acb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tuint32_t __iomem *rwbuffer;\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\twritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\n\t\t\tsizeof(struct InBound_SRB)), rwbuffer++);\n\t\twritel(0x100, rwbuffer);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\n\t\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)\n{\n\tuint32_t firmware_state = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tdo {\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tdo {\n\t\t\tfirmware_state = readl(reg->iop2drv_doorbell);\n\t\t} while ((firmware_state & ARCMSR_MESSAGE_FIRMWARE_OK) == 0);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tdo {\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tdo {\n\t\t\tfirmware_state = readl(reg->outbound_msgaddr1);\n\t\t} while ((firmware_state &\n\t\t\tARCMSR_ARC1214_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)){\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0) || ((acb->acb_flags & ACB_F_ABORT) != 0)) {\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\treturn;\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_request_device_map(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\tif (unlikely(atomic_read(&acb->rq_map_token) == 0) ||\n\t\t((acb->acb_flags & ACB_F_BUS_RESET) != 0) ||\n\t\t((acb->acb_flags & ACB_F_ABORT) != 0)) {\n\t\tmod_timer(&acb->eternal_timer,\n\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tif (atomic_read(&acb->ante_token_value) ==\n\t\t\tatomic_read(&acb->rq_map_token)) {\n\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t}\n\t\tatomic_set(&acb->ante_token_value,\n\t\t\tatomic_read(&acb->rq_map_token));\n\t\tif (atomic_dec_and_test(&acb->rq_map_token)) {\n\t\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(6 * HZ));\n\t\t\treturn;\n\t\t}\n\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG,\n\t\t\treg->inbound_msgaddr0);\n\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\tmsecs_to_jiffies(6 * HZ));\n\t}\n}\n\nstatic void arcmsr_request_device_map(unsigned long pacb)\n{\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;\n\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A: {\n\t\t\tarcmsr_hbaA_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_B: {\n\t\t\tarcmsr_hbaB_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C: {\n\t\t\tarcmsr_hbaC_request_device_map(acb);\n\t\t}\n\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\t\tarcmsr_hbaD_request_device_map(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_hbaA_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\", acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\",acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &phbcmu->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &phbcmu->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\", pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *pmu = pACB->pmuD;\n\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, pmu->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'start adapter \"\n\t\t\t\"background rebulid' timeout\\n\", pACB->host->host_no);\n\t}\n}\n\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_start_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_clear_doorbell_queue_buffer(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_doorbell;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t/*clear doorbell interrupt */\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*clear interrupt and message state*/\n\t\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t/* let IOP know data has been read */\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\t&reg->outbound_doorbell_clear);\n\t\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK,\n\t\t\t\t\t&reg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, reg->outbound_doorbell);\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\treg->outbound_doorbell);\n\t\t\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\t\t\treg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_enable_eoi_mode(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\t{\n\t\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t\twritel(ARCMSR_MESSAGE_ACTIVE_EOI_MODE, reg->drv2iop_doorbell);\n\t\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"ARCMSR IOP enables EOI_MODE TIMEOUT\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn;\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb)\n{\n\tuint8_t value[64];\n\tint i, count = 0;\n\tstruct MessageUnit_A __iomem *pmuA = acb->pmuA;\n\tstruct MessageUnit_C __iomem *pmuC = acb->pmuC;\n\tstruct MessageUnit_D *pmuD = acb->pmuD;\n\n\t/* backup pci config data */\n\tprintk(KERN_NOTICE \"arcmsr%d: executing hw bus reset .....\\n\", acb->host->host_no);\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_read_config_byte(acb->pdev, i, &value[i]);\n\t}\n\t/* hardware reset signal */\n\tif ((acb->dev_id == 0x1680)) {\n\t\twritel(ARCMSR_ARC1680_BUS_RESET, &pmuA->reserved1[0]);\n\t} else if ((acb->dev_id == 0x1880)) {\n\t\tdo {\n\t\t\tcount++;\n\t\t\twritel(0xF, &pmuC->write_sequence);\n\t\t\twritel(0x4, &pmuC->write_sequence);\n\t\t\twritel(0xB, &pmuC->write_sequence);\n\t\t\twritel(0x2, &pmuC->write_sequence);\n\t\t\twritel(0x7, &pmuC->write_sequence);\n\t\t\twritel(0xD, &pmuC->write_sequence);\n\t\t} while (((readl(&pmuC->host_diagnostic) & ARCMSR_ARC1880_DiagWrite_ENABLE) == 0) && (count < 5));\n\t\twritel(ARCMSR_ARC1880_RESET_ADAPTER, &pmuC->host_diagnostic);\n\t} else if ((acb->dev_id == 0x1214)) {\n\t\twritel(0x20, pmuD->reset_request);\n\t} else {\n\t\tpci_write_config_byte(acb->pdev, 0x84, 0x20);\n\t}\n\tmsleep(2000);\n\t/* write back pci config data */\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_write_config_byte(acb->pdev, i, value[i]);\n\t}\n\tmsleep(1000);\n\treturn;\n}\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb)\n{\n\tuint32_t intmask_org;\n\t/* disable all outbound interrupt */\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_wait_firmware_ready(acb);\n\tarcmsr_iop_confirm(acb);\n\t/*start background rebuild*/\n\tarcmsr_start_adapter_bgrb(acb);\n\t/* empty doorbell Qbuffer if door bell ringed */\n\tarcmsr_clear_doorbell_queue_buffer(acb);\n\tarcmsr_enable_eoi_mode(acb);\n\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\tacb->acb_flags |= ACB_F_IOP_INITED;\n}\n\nstatic uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)\n{\n\tstruct CommandControlBlock *ccb;\n\tuint32_t intmask_org;\n\tuint8_t rtnval = 0x00;\n\tint i = 0;\n\tunsigned long flags;\n\n\tif (atomic_read(&acb->ccboutstandingcount) != 0) {\n\t\t/* disable all outbound interrupt */\n\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t/* talk to iop 331 outstanding command aborted */\n\t\trtnval = arcmsr_abort_allcmd(acb);\n\t\t/* clear all outbound posted Q */\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\t\tccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tscsi_dma_unmap(ccb->pcmd);\n\t\t\t\tccb->startdone = ARCMSR_CCB_DONE;\n\t\t\t\tccb->ccb_flags = 0;\n\t\t\t\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\t\t\t\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\t\t\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\t\t}\n\t\t}\n\t\tatomic_set(&acb->ccboutstandingcount, 0);\n\t\t/* enable all outbound interrupt */\n\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\treturn rtnval;\n\t}\n\treturn rtnval;\n}\n\nstatic int arcmsr_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb;\n\tuint32_t intmask_org, outbound_doorbell;\n\tint retry_count = 0;\n\tint rtn = FAILED;\n\tacb = (struct AdapterControlBlock *) cmd->device->host->hostdata;\n\tprintk(KERN_ERR \"arcmsr: executing bus reset eh.....num_resets = %d, num_aborts = %d \\n\", acb->num_resets, acb->num_aborts);\n\tacb->num_resets++;\n\n\tswitch(acb->adapter_type){\n\t\tcase ACB_ADAPTER_TYPE_A:{\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET){\n\t\t\t\tlong timeout;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: there is an  bus reset eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\n\t\t\t\tif (timeout) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_A __iomem *reg;\n\t\t\t\treg = acb->pmuA;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\nsleep_again:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(&reg->outbound_msgaddr1) & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0) {\n\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, retry=%d\\n\", acb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\\n\", acb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto sleep_again;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\t/* clear Qbuffer if door bell ringed */\n\t\t\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t\t\twritel(outbound_doorbell, &reg->outbound_doorbell); /*clear interrupt */\n   \t\t\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t\t\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: scsi  bus reset eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_B:{\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = FAILED;\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_C:{\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET) {\n\t\t\t\tlong timeout;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: there is an bus reset eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\n\t\t\t\tif (timeout) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_C __iomem *reg;\n\t\t\t\treg = acb->pmuC;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\nsleep:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(&reg->host_diagnostic) & 0x04) != 0) {\n\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, retry=%d\\n\", acb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tprintk(KERN_ERR \"arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\\n\", acb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto sleep;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\t/* clear Qbuffer if door bell ringed */\n\t\t\t\tarcmsr_clear_doorbell_queue_buffer(acb);\n\t\t\t\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tprintk(KERN_ERR \"arcmsr: scsi bus reset eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_D: {\n\t\t\tif (acb->acb_flags & ACB_F_BUS_RESET) {\n\t\t\t\tlong timeout;\n\t\t\t\tpr_notice(\"arcmsr: there is an bus reset\"\n\t\t\t\t\t\" eh proceeding.......\\n\");\n\t\t\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags\n\t\t\t\t\t& ACB_F_BUS_RESET) == 0, 220 * HZ);\n\t\t\t\tif (timeout)\n\t\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tacb->acb_flags |= ACB_F_BUS_RESET;\n\t\t\tif (!arcmsr_iop_reset(acb)) {\n\t\t\t\tstruct MessageUnit_D *reg;\n\t\t\t\treg = acb->pmuD;\n\t\t\t\tarcmsr_hardware_reset(acb);\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\t\t\tnap:\n\t\t\t\tssleep(ARCMSR_SLEEPTIME);\n\t\t\t\tif ((readl(reg->sample_at_reset) & 0x80) != 0) {\n\t\t\t\t\tpr_err(\"arcmsr%d: waiting for \"\n\t\t\t\t\t\t\"hw bus reset return, retry=%d\\n\",\n\t\t\t\t\t\tacb->host->host_no, retry_count);\n\t\t\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\t\t\tpr_err(\"arcmsr%d: waiting for hw bus\"\n\t\t\t\t\t\t\t\" reset return, \"\n\t\t\t\t\t\t\t\"RETRY TERMINATED!!\\n\",\n\t\t\t\t\t\t\tacb->host->host_no);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto nap;\n\t\t\t\t}\n\t\t\t\tacb->acb_flags |= ACB_F_IOP_INITED;\n\t\t\t\t/* disable all outbound interrupt */\n\t\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\t\tarcmsr_get_firmware_spec(acb);\n\t\t\t\tarcmsr_start_adapter_bgrb(acb);\n\t\t\t\tarcmsr_clear_doorbell_queue_buffer(acb);\n\t\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tpr_err(\"arcmsr: scsi bus reset \"\n\t\t\t\t\t\"eh returns with success\\n\");\n\t\t\t} else {\n\t\t\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\t\t\tatomic_set(&acb->rq_map_token, 16);\n\t\t\t\tatomic_set(&acb->ante_token_value, 16);\n\t\t\t\tacb->fw_flag = FW_NORMAL;\n\t\t\t\tmod_timer(&acb->eternal_timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(6 * HZ));\n\t\t\t\trtn = SUCCESS;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *ccb)\n{\n\tint rtn;\n\trtn = arcmsr_polling_ccbdone(acb, ccb);\n\treturn rtn;\n}\n\nstatic int arcmsr_abort(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)cmd->device->host->hostdata;\n\tint i = 0;\n\tint rtn = FAILED;\n\tuint32_t intmask_org;\n\n\tprintk(KERN_NOTICE\n\t\t\"arcmsr%d: abort device command of scsi id = %d lun = %d\\n\",\n\t\tacb->host->host_no, cmd->device->id, (u32)cmd->device->lun);\n\tacb->acb_flags |= ACB_F_ABORT;\n\tacb->num_aborts++;\n\t/*\n\t************************************************\n\t** the all interrupt service routine is locked\n\t** we need to handle it as soon as possible and exit\n\t************************************************\n\t*/\n\tif (!atomic_read(&acb->ccboutstandingcount)) {\n\t\tacb->acb_flags &= ~ACB_F_ABORT;\n\t\treturn rtn;\n\t}\n\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\n\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\tif (ccb->startdone == ARCMSR_CCB_START && ccb->pcmd == cmd) {\n\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\trtn = arcmsr_abort_one_cmd(acb, ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n\tacb->acb_flags &= ~ACB_F_ABORT;\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\treturn rtn;\n}\n\nstatic const char *arcmsr_info(struct Scsi_Host *host)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tstatic char buf[256];\n\tchar *type;\n\tint raid6 = 1;\n\tswitch (acb->pdev->device) {\n\tcase PCI_DEVICE_ID_ARECA_1110:\n\tcase PCI_DEVICE_ID_ARECA_1200:\n\tcase PCI_DEVICE_ID_ARECA_1202:\n\tcase PCI_DEVICE_ID_ARECA_1210:\n\t\traid6 = 0;\n\t\t/*FALLTHRU*/\n\tcase PCI_DEVICE_ID_ARECA_1120:\n\tcase PCI_DEVICE_ID_ARECA_1130:\n\tcase PCI_DEVICE_ID_ARECA_1160:\n\tcase PCI_DEVICE_ID_ARECA_1170:\n\tcase PCI_DEVICE_ID_ARECA_1201:\n\tcase PCI_DEVICE_ID_ARECA_1203:\n\tcase PCI_DEVICE_ID_ARECA_1220:\n\tcase PCI_DEVICE_ID_ARECA_1230:\n\tcase PCI_DEVICE_ID_ARECA_1260:\n\tcase PCI_DEVICE_ID_ARECA_1270:\n\tcase PCI_DEVICE_ID_ARECA_1280:\n\t\ttype = \"SATA\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ARECA_1214:\n\tcase PCI_DEVICE_ID_ARECA_1380:\n\tcase PCI_DEVICE_ID_ARECA_1381:\n\tcase PCI_DEVICE_ID_ARECA_1680:\n\tcase PCI_DEVICE_ID_ARECA_1681:\n\tcase PCI_DEVICE_ID_ARECA_1880:\n\t\ttype = \"SAS/SATA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\traid6 =\t0;\n\t\tbreak;\n\t}\n\tsprintf(buf, \"Areca %s RAID Controller %s\\narcmsr version %s\\n\",\n\t\ttype, raid6 ? \"(RAID6 capable)\" : \"\", ARCMSR_DRIVER_VERSION);\n\treturn buf;\n}\n"], "filenames": ["drivers/scsi/arcmsr/arcmsr_hba.c"], "buggy_code_start_loc": [2391], "buggy_code_end_loc": [2399], "fixing_code_start_loc": [2391], "fixing_code_end_loc": [2406], "type": "CWE-119", "message": "The arcmsr_iop_message_xfer function in drivers/scsi/arcmsr/arcmsr_hba.c in the Linux kernel through 4.8.2 does not restrict a certain length field, which allows local users to gain privileges or cause a denial of service (heap-based buffer overflow) via an ARCMSR_MESSAGE_WRITE_WQBUFFER control code.", "other": {"cve": {"id": "CVE-2016-7425", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-16T21:59:12.163", "lastModified": "2023-01-17T21:15:16.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The arcmsr_iop_message_xfer function in drivers/scsi/arcmsr/arcmsr_hba.c in the Linux kernel through 4.8.2 does not restrict a certain length field, which allows local users to gain privileges or cause a denial of service (heap-based buffer overflow) via an ARCMSR_MESSAGE_WRITE_WQBUFFER control code."}, {"lang": "es", "value": "La funci\u00f3n arcmsr_iop_message_xfer en drivers/scsi/arcmsr/arcmsr_hba.c en el kernel de Linux hasta la versi\u00f3n 4.8.2 no restringe una cierta longitud de campo, lo que permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica) a trav\u00e9s de un c\u00f3digo de control ARCMSR_MESSAGE_WRITE_WQBUFFER."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2", "versionEndExcluding": "3.2.84", "matchCriteriaId": "D3FA2AA8-48CD-4ED5-8F85-E292A0ADFF6E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.105", "matchCriteriaId": "2B846CBB-1438-4151-B9FC-816C9548110E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.67", "matchCriteriaId": "2C527DD8-9CB0-40F0-9455-7C5755792DE7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.39", "matchCriteriaId": "0E2B3352-CCBA-4E78-9FC1-BBDF9A3A87B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.46", "matchCriteriaId": "B4BEDC6F-3F06-444D-AF78-96C7C02DCF30"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.37", "matchCriteriaId": "0DE2C8A2-D80A-4FAE-915A-94E58094F78A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.27", "matchCriteriaId": "6AE1A1F2-7BD1-4B3C-AA5E-A556FB9FFFD6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.7.10", "matchCriteriaId": "C6C1817C-C779-47B1-B9F7-A77838991F27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.8", "versionEndExcluding": "4.8.4", "matchCriteriaId": "A19EA449-377D-4E08-8752-39CDAB81FE7D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.10:*:*:*:*:*:*:*", "matchCriteriaId": "1AFB20FA-CB00-4729-AB3A-816454C6D096"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7bc2b55a5c030685b399bb65b6baa9ccc3d1f167", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://marc.info/?l=linux-scsi&m=147394713328707&w=2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://marc.info/?l=linux-scsi&m=147394796228991&w=2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/17/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93037", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3144-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3144-2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3145-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3145-2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3146-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3146-2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3147-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1377330", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7bc2b55a5c030685b399bb65b6baa9ccc3d1f167", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-7425", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7bc2b55a5c030685b399bb65b6baa9ccc3d1f167"}}