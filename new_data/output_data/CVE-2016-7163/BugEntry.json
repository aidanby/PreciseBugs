{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final ( opj_cp_t *p_cp,\n                                                 OPJ_UINT32 p_tileno,\n                                                 OPJ_INT32 p_tx0,\n                                                 OPJ_INT32 p_tx1,\n                                                 OPJ_INT32 p_ty0,\n                                                 OPJ_INT32 p_ty1,\n                                                 OPJ_UINT32 p_max_prec,\n                                                 OPJ_UINT32 p_max_res,\n                                                 OPJ_UINT32 p_dx_min,\n                                                 OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_num_comps\t\tthe number of components\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc (  opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_num_comps,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * \n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\t\tpointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\t\tpointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res );\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tpointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tpointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n * @param\tp_resolutions\tpointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno,\n                                            OPJ_INT32 * p_tx0,\n                                            OPJ_INT32 * p_tx1,\n                                            OPJ_INT32 * p_ty0,\n                                            OPJ_INT32 * p_ty1,\n                                            OPJ_UINT32 * p_dx_min,\n                                            OPJ_UINT32 * p_dy_min,\n                                            OPJ_UINT32 * p_max_prec,\n                                            OPJ_UINT32 * p_max_res,\n                                            OPJ_UINT32 ** p_resolutions );\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n * \n * @param\tp_image\t\tthe image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param\tp_cp\t\tthe coding parameters.\n * @param\ttileno\tthe index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno );\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                          opj_tcp_t * p_tcp,\n                                          OPJ_UINT32 p_max_precision,\n                                          OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc (  opj_pi_iterator_t * p_pi,\n                                        opj_tcp_t * p_tcp,\n                                        OPJ_UINT32 p_max_precision,\n                                        OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nstatic OPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\t\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n\t\tpi->resno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif (!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\nif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32  trx1, try1;\n\t\t\t\t\tOPJ_UINT32  rpx, rpy;\n\t\t\t\t\tOPJ_INT32  prci, prcj;\n\t\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\n\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\t\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\tOPJ_UINT32 resno;\n\t\tcomp = &pi->comps[pi->compno];\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\tOPJ_UINT32 dx, dy;\n\t\t\tres = &comp->resolutions[resno];\n\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t}\n\t\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic void opj_get_encoding_parameters(\tconst opj_image_t *p_image,\n                                    const opj_cp_t *p_cp,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 * p_tx0,\n                                    OPJ_INT32  * p_tx1,\n                                    OPJ_INT32  * p_ty0,\n                                    OPJ_INT32  * p_ty1,\n                                    OPJ_UINT32 * p_dx_min,\n                                    OPJ_UINT32 * p_dy_min,\n                                    OPJ_UINT32 * p_max_prec,\n                                    OPJ_UINT32 * p_max_res )\n{\n\t/* loop */\n\tOPJ_UINT32  compno, resno;\n\t/* pointers */\n\tconst opj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* position in x and y of tile */\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps [p_tileno];\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n\tp = p_tileno % p_cp->tw;\n\tq = p_tileno / p_cp->tw;\n\n\t/* find extent of tile */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision is 0 (can only grow) */\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min */\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min  = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* arithmetic variables to calculate */\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_pdx, l_pdy;\n\t\tOPJ_UINT32 l_pw, l_ph;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts */\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n\t\t\t/* take the minimum size for dx for each comp and resolution */\n\t\t\t*p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n\t\t\t*p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n\t\t\t/* various calculations of extents */\n\t\t\tl_level_no = l_tccp->numresolutions - 1 - resno;\n\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n\t\t\tl_product = l_pw * l_ph;\n\n\t\t\t/* update precision */\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\t\t}\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n}\n\n\nstatic void opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* non-corrected (in regard to image offset) tile offset */\n\tOPJ_UINT32 l_tx0, l_ty0;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\tl_tx0 = p_cp->tx0 + p * p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n\tl_ty0 = p_cp->ty0 + q * p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t--l_level_no;\n\t\t\t\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *image,\n                                    const opj_cp_t *cp,\n                                    OPJ_UINT32 tileno )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino, compno;\n\t/* number of poc in the p_pi*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* pointers to tile coding parameters and components.*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *tcp = 00;\n\tconst opj_tccp_t *tccp = 00;\n\n\t/* current packet iterator being allocated*/\n\topj_pi_iterator_t *l_current_pi = 00;\n\n\t/* preconditions in debug*/\n\tassert(cp != 00);\n\tassert(image != 00);\n\tassert(tileno < cp->tw * cp->th);\n\n\t/* initializations*/\n\ttcp = &cp->tcps[tileno];\n\tl_poc_bound = tcp->numpocs+1;\n\n\t/* memory allocations*/\n\tl_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound), sizeof(opj_pi_iterator_t));\n\tif (!l_pi) {\n\t\treturn NULL;\n\t}\n\n\tl_current_pi = l_pi;\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\n\t\tl_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));\n\t\tif (! l_current_pi->comps) {\n\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl_current_pi->numcomps = image->numcomps;\n\n\t\tfor (compno = 0; compno < image->numcomps; ++compno) {\n\t\t\topj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n\t\t\ttccp = &tcp->tccps[compno];\n\n\t\t\tcomp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions, sizeof(opj_pi_resolution_t));\n\t\t\tif (!comp->resolutions) {\n\t\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\t\treturn 00;\n\t\t\t}\n\n\t\t\tcomp->numresolutions = tccp->numresolutions;\n\t\t}\n\t\t++l_current_pi;\n\t}\n\treturn l_pi;\n}\n\nstatic void opj_pi_update_encode_poc_and_final (   opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tl_current_poc->compS = l_current_poc->compno0;\n\tl_current_poc->compE = l_current_poc->compno1;\n\tl_current_poc->resS = l_current_poc->resno0;\n\tl_current_poc->resE = l_current_poc->resno1;\n\tl_current_poc->layE = l_current_poc->layno1;\n\n\t/* special treatment for the first element*/\n\tl_current_poc->layS = 0;\n\tl_current_poc->prg  = l_current_poc->prg1;\n\tl_current_poc->prcS = 0;\n\n\tl_current_poc->prcE = p_max_prec;\n\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\tl_current_poc->dx = p_dx_min;\n\tl_current_poc->dy = p_dy_min;\n\n\t++ l_current_poc;\n\tfor (pino = 1;pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = l_current_poc->compno0;\n\t\tl_current_poc->compE= l_current_poc->compno1;\n\t\tl_current_poc->resS = l_current_poc->resno0;\n\t\tl_current_poc->resE = l_current_poc->resno1;\n\t\tl_current_poc->layE = l_current_poc->layno1;\n\t\tl_current_poc->prg  = l_current_poc->prg1;\n\t\tl_current_poc->prcS = 0;\n\t\t/* special treatment here different from the first element*/\n\t\tl_current_poc->layS = (l_current_poc->layE > (l_current_poc-1)->layE) ? l_current_poc->layE : 0;\n\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_encode_not_poc (\topj_cp_t *p_cp,\n                                    OPJ_UINT32 p_num_comps,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 p_tx0,\n                                    OPJ_INT32 p_tx1,\n                                    OPJ_INT32 p_ty0,\n                                    OPJ_INT32 p_ty1,\n                                    OPJ_UINT32 p_max_prec,\n                                    OPJ_UINT32 p_max_res,\n                                    OPJ_UINT32 p_dx_min,\n                                    OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = 0;\n\t\tl_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n\t\tl_current_poc->resS = 0;\n\t\tl_current_poc->resE = p_max_res;\n\t\tl_current_poc->layS = 0;\n\t\tl_current_poc->layE = l_tcp->numlayers;\n\t\tl_current_poc->prg  = l_tcp->prg;\n\t\tl_current_poc->prcS = 0;\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,\n                               opj_tcp_t * p_tcp,\n                               OPJ_UINT32 p_max_precision,\n                               OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\topj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_pi != 00);\n\tassert(p_tcp != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\tl_current_poc = p_tcp->pocs;\n\n\tfor\t(pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n\t\tl_current_pi->first = 1;\n\n\t\tl_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n\t\tl_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n\t\tl_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */\n\t\tl_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t\t++l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                   opj_tcp_t * p_tcp,\n                                   OPJ_UINT32 p_max_precision,\n                                   OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\t/* preconditions in debug*/\n\tassert(p_tcp != 00);\n\tassert(p_pi != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\n\tfor (pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = p_tcp->prg;\n\t\tl_current_pi->first = 1;\n\t\tl_current_pi->poc.resno0 = 0;\n\t\tl_current_pi->poc.compno0 = 0;\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = p_max_res;\n\t\tl_current_pi->poc.compno1 = l_current_pi->numcomps;\n\t\tl_current_pi->poc.layno1 = p_tcp->numlayers;\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t}\n}\n\n\n\nstatic OPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog)\n{\n\tOPJ_INT32 i;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp = &tcps->pocs[pino];\n\n\tif(pos>=0){\n\t\tfor(i=pos;pos>=0;i--){\n\t\t\tswitch(prog[i]){\n\t\t    case 'R':\n\t\t\t    if(tcp->res_t==tcp->resE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'C':\n\t\t\t    if(tcp->comp_t==tcp->compE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'L':\n\t\t\t    if(tcp->lay_t==tcp->layE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'P':\n\t\t\t    switch(tcp->prg){\n                    case OPJ_LRCP: /* fall through */\n                    case OPJ_RLCP:\n\t\t\t\t\t    if(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }\n\t\t\t\t\t    break;\n\t\t\t    default:\n\t\t\t\t    if(tcp->tx0_t == tcp->txE){\n\t\t\t\t\t    /*TY*/\n\t\t\t\t\t    if(tcp->ty0_t == tcp->tyE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }/*TY*/\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }\n\t\t\t\t    break;\n\t\t\t    }/*end case P*/\n\t\t    }/*end switch*/\n\t\t}/*end for*/\n\t}/*end if*/\n\treturn OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n                                            opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tile_no,\n                                            J2K_T2_MODE p_t2_mode )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions*/\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif (! l_tmp_data) {\n\t\treturn 00;\n\t}\n\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif (! l_tmp_ptr) {\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi*/\n\tl_pi = opj_pi_create(p_image,p_cp,p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array*/\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\n\t/* get encoding parameters*/\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations*/\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator*/\n\tl_pi->tp_on = (OPJ_BYTE)p_cp->m_specific_param.m_enc.m_tp_on;\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include*/\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l, sizeof(OPJ_INT16));\n\tif (!l_current_pi->include) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator*/\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\tl_current_pi->dx = l_dx_min;\n\tl_current_pi->dy = l_dy_min;\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\n\t\t/* resolutions have already been initialized */\n\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino ) {\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\tl_current_pi->dx = l_dx_min;\n\t\tl_current_pi->dy = l_dy_min;\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\n\treturn l_pi;\n}\n\nvoid opj_pi_create_encode( \topj_pi_iterator_t *pi,\n\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\tOPJ_UINT32 tpnum,\n\t\t\t\t\t\t\tOPJ_INT32 tppos,\n\t\t\t\t\t\t\tJ2K_T2_MODE t2_mode)\n{\n\tconst OPJ_CHAR *prog;\n\tOPJ_INT32 i;\n\tOPJ_UINT32 incr_top=1,resetX=0;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp= &tcps->pocs[pino];\n\n\tprog = opj_j2k_convert_progression_order(tcp->prg);\n\n\tpi[pino].first = 1;\n\tpi[pino].poc.prg = tcp->prg;\n\n    if(!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) && (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))){\n\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t}else {\n\t\tfor(i=tppos+1;i<4;i++){\n\t\t\tswitch(prog[i]){\n\t\t\tcase 'R':\n\t\t\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\t\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\t\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\t\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tswitch(tcp->prg){\n\t\t\t\tcase OPJ_LRCP:\n\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\t\t\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(tpnum==0){\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tincr_top=1;\n\t\t}else{\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t-1;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t-1;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t-1;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t-1;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(incr_top==1){\n\t\t\t\t\tswitch(prog[i]){\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tif(tcp->res_t==tcp->resE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tif(tcp->comp_t ==tcp->compE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tif(tcp->lay_t == tcp->layE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\t\tif(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(tcp->tx0_t >= tcp->txE){\n\t\t\t\t\t\t\t\tif(tcp->ty0_t >= tcp->tyE){\n\t\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\t\tincr_top=1;resetX=1;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tincr_top=0;resetX=0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\tincr_top=0;resetX=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(resetX==1){\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n\tOPJ_UINT32 compno, pino;\n\topj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n\t\tif (p_pi->include) {\n\t\t\topj_free(p_pi->include);\n\t\t\tp_pi->include = 00;\n\t\t}\n\t\tfor (pino = 0; pino < p_nb_elements; ++pino){\n\t\t\tif(l_current_pi->comps) {\n\t\t\t\topj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++){\n                    if(l_current_component->resolutions) {\n\t\t\t\t\t\topj_free(l_current_component->resolutions);\n\t\t\t\t\t\tl_current_component->resolutions = 00;\n\t\t\t\t\t}\n\n\t\t\t\t\t++l_current_component;\n\t\t\t\t}\n\t\t\t\topj_free(l_current_pi->comps);\n\t\t\t\tl_current_pi->comps = 0;\n\t\t\t}\n\t\t\t++l_current_pi;\n\t\t}\n\t\topj_free(p_pi);\n\t}\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(\tconst opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no )\n{\n\t/* encoding parameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\n\t/* pointers */\n\topj_tcp_t *l_tcp = 00;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\tl_tcp = &(p_cp->tcps[p_tile_no]);\n\n\t/* get encoding parameters */\n\topj_get_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res);\n\n\tif (l_tcp->POC) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi) {\n\tswitch (pi->poc.prg) {\n\t\tcase OPJ_LRCP:\n\t\t\treturn opj_pi_next_lrcp(pi);\n\t\tcase OPJ_RLCP:\n\t\t\treturn opj_pi_next_rlcp(pi);\n\t\tcase OPJ_RPCL:\n\t\t\treturn opj_pi_next_rpcl(pi);\n\t\tcase OPJ_PCRL:\n\t\t\treturn opj_pi_next_pcrl(pi);\n\t\tcase OPJ_CPRL:\n\t\t\treturn opj_pi_next_cprl(pi);\n\t\tcase OPJ_PROG_UNKNOWN:\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final ( opj_cp_t *p_cp,\n                                                 OPJ_UINT32 p_tileno,\n                                                 OPJ_INT32 p_tx0,\n                                                 OPJ_INT32 p_tx1,\n                                                 OPJ_INT32 p_ty0,\n                                                 OPJ_INT32 p_ty1,\n                                                 OPJ_UINT32 p_max_prec,\n                                                 OPJ_UINT32 p_max_res,\n                                                 OPJ_UINT32 p_dx_min,\n                                                 OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_num_comps\t\tthe number of components\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc (  opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_num_comps,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * \n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\t\tpointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\t\tpointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res );\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tpointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tpointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n * @param\tp_resolutions\tpointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno,\n                                            OPJ_INT32 * p_tx0,\n                                            OPJ_INT32 * p_tx1,\n                                            OPJ_INT32 * p_ty0,\n                                            OPJ_INT32 * p_ty1,\n                                            OPJ_UINT32 * p_dx_min,\n                                            OPJ_UINT32 * p_dy_min,\n                                            OPJ_UINT32 * p_max_prec,\n                                            OPJ_UINT32 * p_max_res,\n                                            OPJ_UINT32 ** p_resolutions );\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n * \n * @param\tp_image\t\tthe image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param\tp_cp\t\tthe coding parameters.\n * @param\ttileno\tthe index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno );\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                          opj_tcp_t * p_tcp,\n                                          OPJ_UINT32 p_max_precision,\n                                          OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc (  opj_pi_iterator_t * p_pi,\n                                        opj_tcp_t * p_tcp,\n                                        OPJ_UINT32 p_max_precision,\n                                        OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nstatic OPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\t\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n\t\tpi->resno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif (!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\nif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32  trx1, try1;\n\t\t\t\t\tOPJ_UINT32  rpx, rpy;\n\t\t\t\t\tOPJ_INT32  prci, prcj;\n\t\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\n\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\t\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\tOPJ_UINT32 resno;\n\t\tcomp = &pi->comps[pi->compno];\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\tOPJ_UINT32 dx, dy;\n\t\t\tres = &comp->resolutions[resno];\n\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t}\n\t\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nstatic void opj_get_encoding_parameters(\tconst opj_image_t *p_image,\n                                    const opj_cp_t *p_cp,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 * p_tx0,\n                                    OPJ_INT32  * p_tx1,\n                                    OPJ_INT32  * p_ty0,\n                                    OPJ_INT32  * p_ty1,\n                                    OPJ_UINT32 * p_dx_min,\n                                    OPJ_UINT32 * p_dy_min,\n                                    OPJ_UINT32 * p_max_prec,\n                                    OPJ_UINT32 * p_max_res )\n{\n\t/* loop */\n\tOPJ_UINT32  compno, resno;\n\t/* pointers */\n\tconst opj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* position in x and y of tile */\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps [p_tileno];\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n\tp = p_tileno % p_cp->tw;\n\tq = p_tileno / p_cp->tw;\n\n\t/* find extent of tile */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision is 0 (can only grow) */\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min */\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min  = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* arithmetic variables to calculate */\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_pdx, l_pdy;\n\t\tOPJ_UINT32 l_pw, l_ph;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts */\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n\t\t\t/* take the minimum size for dx for each comp and resolution */\n\t\t\t*p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n\t\t\t*p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n\t\t\t/* various calculations of extents */\n\t\t\tl_level_no = l_tccp->numresolutions - 1 - resno;\n\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n\t\t\tl_product = l_pw * l_ph;\n\n\t\t\t/* update precision */\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\t\t}\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n}\n\n\nstatic void opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* non-corrected (in regard to image offset) tile offset */\n\tOPJ_UINT32 l_tx0, l_ty0;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\tl_tx0 = p_cp->tx0 + p * p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n\tl_ty0 = p_cp->ty0 + q * p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t--l_level_no;\n\t\t\t\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *image,\n                                    const opj_cp_t *cp,\n                                    OPJ_UINT32 tileno )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino, compno;\n\t/* number of poc in the p_pi*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* pointers to tile coding parameters and components.*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *tcp = 00;\n\tconst opj_tccp_t *tccp = 00;\n\n\t/* current packet iterator being allocated*/\n\topj_pi_iterator_t *l_current_pi = 00;\n\n\t/* preconditions in debug*/\n\tassert(cp != 00);\n\tassert(image != 00);\n\tassert(tileno < cp->tw * cp->th);\n\n\t/* initializations*/\n\ttcp = &cp->tcps[tileno];\n\tl_poc_bound = tcp->numpocs+1;\n\n\t/* memory allocations*/\n\tl_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound), sizeof(opj_pi_iterator_t));\n\tif (!l_pi) {\n\t\treturn NULL;\n\t}\n\n\tl_current_pi = l_pi;\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\n\t\tl_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));\n\t\tif (! l_current_pi->comps) {\n\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl_current_pi->numcomps = image->numcomps;\n\n\t\tfor (compno = 0; compno < image->numcomps; ++compno) {\n\t\t\topj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n\t\t\ttccp = &tcp->tccps[compno];\n\n\t\t\tcomp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions, sizeof(opj_pi_resolution_t));\n\t\t\tif (!comp->resolutions) {\n\t\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\t\treturn 00;\n\t\t\t}\n\n\t\t\tcomp->numresolutions = tccp->numresolutions;\n\t\t}\n\t\t++l_current_pi;\n\t}\n\treturn l_pi;\n}\n\nstatic void opj_pi_update_encode_poc_and_final (   opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tl_current_poc->compS = l_current_poc->compno0;\n\tl_current_poc->compE = l_current_poc->compno1;\n\tl_current_poc->resS = l_current_poc->resno0;\n\tl_current_poc->resE = l_current_poc->resno1;\n\tl_current_poc->layE = l_current_poc->layno1;\n\n\t/* special treatment for the first element*/\n\tl_current_poc->layS = 0;\n\tl_current_poc->prg  = l_current_poc->prg1;\n\tl_current_poc->prcS = 0;\n\n\tl_current_poc->prcE = p_max_prec;\n\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\tl_current_poc->dx = p_dx_min;\n\tl_current_poc->dy = p_dy_min;\n\n\t++ l_current_poc;\n\tfor (pino = 1;pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = l_current_poc->compno0;\n\t\tl_current_poc->compE= l_current_poc->compno1;\n\t\tl_current_poc->resS = l_current_poc->resno0;\n\t\tl_current_poc->resE = l_current_poc->resno1;\n\t\tl_current_poc->layE = l_current_poc->layno1;\n\t\tl_current_poc->prg  = l_current_poc->prg1;\n\t\tl_current_poc->prcS = 0;\n\t\t/* special treatment here different from the first element*/\n\t\tl_current_poc->layS = (l_current_poc->layE > (l_current_poc-1)->layE) ? l_current_poc->layE : 0;\n\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_encode_not_poc (\topj_cp_t *p_cp,\n                                    OPJ_UINT32 p_num_comps,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 p_tx0,\n                                    OPJ_INT32 p_tx1,\n                                    OPJ_INT32 p_ty0,\n                                    OPJ_INT32 p_ty1,\n                                    OPJ_UINT32 p_max_prec,\n                                    OPJ_UINT32 p_max_res,\n                                    OPJ_UINT32 p_dx_min,\n                                    OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = 0;\n\t\tl_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n\t\tl_current_poc->resS = 0;\n\t\tl_current_poc->resE = p_max_res;\n\t\tl_current_poc->layS = 0;\n\t\tl_current_poc->layE = l_tcp->numlayers;\n\t\tl_current_poc->prg  = l_tcp->prg;\n\t\tl_current_poc->prcS = 0;\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,\n                               opj_tcp_t * p_tcp,\n                               OPJ_UINT32 p_max_precision,\n                               OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\topj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_pi != 00);\n\tassert(p_tcp != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\tl_current_poc = p_tcp->pocs;\n\n\tfor\t(pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n\t\tl_current_pi->first = 1;\n\n\t\tl_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n\t\tl_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n\t\tl_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */\n\t\tl_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t\t++l_current_poc;\n\t}\n}\n\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                   opj_tcp_t * p_tcp,\n                                   OPJ_UINT32 p_max_precision,\n                                   OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\t/* preconditions in debug*/\n\tassert(p_tcp != 00);\n\tassert(p_pi != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\n\tfor (pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = p_tcp->prg;\n\t\tl_current_pi->first = 1;\n\t\tl_current_pi->poc.resno0 = 0;\n\t\tl_current_pi->poc.compno0 = 0;\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = p_max_res;\n\t\tl_current_pi->poc.compno1 = l_current_pi->numcomps;\n\t\tl_current_pi->poc.layno1 = p_tcp->numlayers;\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t}\n}\n\n\n\nstatic OPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog)\n{\n\tOPJ_INT32 i;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp = &tcps->pocs[pino];\n\n\tif(pos>=0){\n\t\tfor(i=pos;pos>=0;i--){\n\t\t\tswitch(prog[i]){\n\t\t    case 'R':\n\t\t\t    if(tcp->res_t==tcp->resE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'C':\n\t\t\t    if(tcp->comp_t==tcp->compE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'L':\n\t\t\t    if(tcp->lay_t==tcp->layE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'P':\n\t\t\t    switch(tcp->prg){\n                    case OPJ_LRCP: /* fall through */\n                    case OPJ_RLCP:\n\t\t\t\t\t    if(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }\n\t\t\t\t\t    break;\n\t\t\t    default:\n\t\t\t\t    if(tcp->tx0_t == tcp->txE){\n\t\t\t\t\t    /*TY*/\n\t\t\t\t\t    if(tcp->ty0_t == tcp->tyE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }/*TY*/\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }\n\t\t\t\t    break;\n\t\t\t    }/*end case P*/\n\t\t    }/*end switch*/\n\t\t}/*end for*/\n\t}/*end if*/\n\treturn OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\t/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n                                            opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tile_no,\n                                            J2K_T2_MODE p_t2_mode )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions*/\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif (! l_tmp_data) {\n\t\treturn 00;\n\t}\n\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif (! l_tmp_ptr) {\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi*/\n\tl_pi = opj_pi_create(p_image,p_cp,p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array*/\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\n\t/* get encoding parameters*/\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations*/\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator*/\n\tl_pi->tp_on = (OPJ_BYTE)p_cp->m_specific_param.m_enc.m_tp_on;\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include*/\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l, sizeof(OPJ_INT16));\n\tif (!l_current_pi->include) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator*/\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\tl_current_pi->dx = l_dx_min;\n\tl_current_pi->dy = l_dy_min;\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\n\t\t/* resolutions have already been initialized */\n\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino ) {\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\tl_current_pi->dx = l_dx_min;\n\t\tl_current_pi->dy = l_dy_min;\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\n\treturn l_pi;\n}\n\nvoid opj_pi_create_encode( \topj_pi_iterator_t *pi,\n\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\tOPJ_UINT32 tpnum,\n\t\t\t\t\t\t\tOPJ_INT32 tppos,\n\t\t\t\t\t\t\tJ2K_T2_MODE t2_mode)\n{\n\tconst OPJ_CHAR *prog;\n\tOPJ_INT32 i;\n\tOPJ_UINT32 incr_top=1,resetX=0;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp= &tcps->pocs[pino];\n\n\tprog = opj_j2k_convert_progression_order(tcp->prg);\n\n\tpi[pino].first = 1;\n\tpi[pino].poc.prg = tcp->prg;\n\n    if(!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) && (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))){\n\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t}else {\n\t\tfor(i=tppos+1;i<4;i++){\n\t\t\tswitch(prog[i]){\n\t\t\tcase 'R':\n\t\t\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\t\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\t\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\t\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tswitch(tcp->prg){\n\t\t\t\tcase OPJ_LRCP:\n\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\t\t\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(tpnum==0){\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tincr_top=1;\n\t\t}else{\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t-1;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t-1;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t-1;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t-1;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(incr_top==1){\n\t\t\t\t\tswitch(prog[i]){\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tif(tcp->res_t==tcp->resE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tif(tcp->comp_t ==tcp->compE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tif(tcp->lay_t == tcp->layE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\t\tif(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(tcp->tx0_t >= tcp->txE){\n\t\t\t\t\t\t\t\tif(tcp->ty0_t >= tcp->tyE){\n\t\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\t\tincr_top=1;resetX=1;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tincr_top=0;resetX=0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\tincr_top=0;resetX=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(resetX==1){\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n\tOPJ_UINT32 compno, pino;\n\topj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n\t\tif (p_pi->include) {\n\t\t\topj_free(p_pi->include);\n\t\t\tp_pi->include = 00;\n\t\t}\n\t\tfor (pino = 0; pino < p_nb_elements; ++pino){\n\t\t\tif(l_current_pi->comps) {\n\t\t\t\topj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++){\n                    if(l_current_component->resolutions) {\n\t\t\t\t\t\topj_free(l_current_component->resolutions);\n\t\t\t\t\t\tl_current_component->resolutions = 00;\n\t\t\t\t\t}\n\n\t\t\t\t\t++l_current_component;\n\t\t\t\t}\n\t\t\t\topj_free(l_current_pi->comps);\n\t\t\t\tl_current_pi->comps = 0;\n\t\t\t}\n\t\t\t++l_current_pi;\n\t\t}\n\t\topj_free(p_pi);\n\t}\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(\tconst opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no )\n{\n\t/* encoding parameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\n\t/* pointers */\n\topj_tcp_t *l_tcp = 00;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\tl_tcp = &(p_cp->tcps[p_tile_no]);\n\n\t/* get encoding parameters */\n\topj_get_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res);\n\n\tif (l_tcp->POC) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi) {\n\tswitch (pi->poc.prg) {\n\t\tcase OPJ_LRCP:\n\t\t\treturn opj_pi_next_lrcp(pi);\n\t\tcase OPJ_RLCP:\n\t\t\treturn opj_pi_next_rlcp(pi);\n\t\tcase OPJ_RPCL:\n\t\t\treturn opj_pi_next_rpcl(pi);\n\t\tcase OPJ_PCRL:\n\t\t\treturn opj_pi_next_pcrl(pi);\n\t\tcase OPJ_CPRL:\n\t\t\treturn opj_pi_next_cprl(pi);\n\t\tcase OPJ_PROG_UNKNOWN:\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n"], "filenames": ["src/lib/openjp2/pi.c"], "buggy_code_start_loc": [1240], "buggy_code_end_loc": [1241], "fixing_code_start_loc": [1240], "fixing_code_end_loc": [1247], "type": "CWE-190", "message": "Integer overflow in the opj_pi_create_decode function in pi.c in OpenJPEG allows remote attackers to execute arbitrary code via a crafted JP2 file, which triggers an out-of-bounds read or write.", "other": {"cve": {"id": "CVE-2016-7163", "sourceIdentifier": "cve@mitre.org", "published": "2016-09-21T14:25:28.550", "lastModified": "2022-04-07T15:39:38.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the opj_pi_create_decode function in pi.c in OpenJPEG allows remote attackers to execute arbitrary code via a crafted JP2 file, which triggers an out-of-bounds read or write."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n opj_pi_create_decode en pi.c en OpenJPEG permite a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de un archivo JP2 manipulado, lo que desencadena una lectura o escritura fuera de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "296C5E2F-04D1-4F8A-8FA4-E05DA7766025"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2017-0559.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0838.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3665", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/08/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/08/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92897", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/ef01f18dfc6780b776d0674ed3e7415c6ef54d24", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/826", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/pull/809", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2T6IQAMS4W65MGP7UW5FPE22PXELTK5D/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/66BWMMMWXH32J5AOGLAJGZA3GH5LZHXH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AQ2IIIQSJ3J4MONBOGCG6XHLKKJX2HKM/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/H4IRSGYMBSHCBZP23CUDIRJ3LBKH6ZJ7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JYLOX7PZS3ZUHQ6RGI3M6H27B7I5ZZ26/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGKSEWWWED77Q5ZHK4OA2EKSJXLRU3MK/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4"}}