{"buggy_code": ["package auth\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt\"\n\t\"github.com/sipcapture/homer-app/model\"\n\t\"github.com/sipcapture/homer-app/utils/logger\"\n)\n\n// jwt token claims which contains info regarding user\ntype JwtUserClaim struct {\n\tUserName        string `json:\"username\"`\n\tUserAdmin       bool   `json:\"useradmin\"`\n\tUserGroup       string `json:\"usergroup\"`\n\tExternalAuth    bool   `json:\"externalauth\"`\n\tExternalProfile string `json:\"externaltype\"`\n\tDisplayName     string `json:\"displayname\"`\n\tAvatar          string `json:\"avatar\"`\n\tjwt.StandardClaims\n}\n\nfunc Token(user model.TableUser) (string, error) {\n\n\ttNow := time.Now()\n\ttUTC := tNow\n\n\tnewTUTC := tUTC.Add(time.Duration(TokenExpiryTime) * time.Minute)\n\n\t// Set custom claims\n\tclaims := &JwtUserClaim{\n\t\tuser.UserName,\n\t\tuser.IsAdmin,\n\t\tuser.UserGroup,\n\t\tuser.ExternalAuth,\n\t\tuser.ExternalProfile,\n\t\tuser.FirstName + \" \" + user.LastName,\n\t\tuser.Avatar,\n\t\tjwt.StandardClaims{\n\t\t\tExpiresAt: newTUTC.Unix(),\n\t\t},\n\t}\n\n\tlogger.Debug(\"Current time : \", tNow)\n\tlogger.Debug(\"Local time : \", tUTC)\n\tlogger.Debug(\"Expire Local time : \", newTUTC)\n\n\t// Create token with claims\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\n\t// Generate encoded token and send it as response.\n\tt, err := token.SignedString([]byte(JwtSecret))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn t, nil\n}\n", "package auth\n\nconst JwtSecret = \"167f0db2-f83e-4baa-9736-d56064a5b415\"\n\n/* our expire time */\nvar TokenExpiryTime = 1200\n\n// token header\nconst TokenHeader = \"Auth-Token\"\n", "package config\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/sipcapture/homer-app/model\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar Setting HomerSettingServer\n\nvar OAuth2TokenMap map[string]model.OAuth2MapToken\n\ntype HomerSettingServer struct {\n\tMAIN_SETTINGS struct {\n\t\tIsolateQuery        string `default:\"\"`\n\t\tIsolateGroup        string `default:\"\"`\n\t\tUseCaptureIDInAlias bool   `default:\"false\"`\n\t\tDefaultAuth         string `default:\"internal\"`\n\t\tEnableGravatar      bool   `default:\"false\"`\n\t\tGravatarUrl         string `default:\"https://www.gravatar.com/avatar/%s.jpg\"`\n\t\tOAuth2Config        oauth2.Config\n\t\tGlobalToken         *oauth2.Token\n\t\tUserGroups          []string `default:\"[admin,user,support]\"`\n\t\tSubscribeHttpClient *http.Client\n\t\tTimeoutHttpClient   uint32 `default:\"10\"`\n\t}\n\n\tGRAFANA_SETTINGS struct {\n\t\tURL      string `default:\"http://grafana/\"`\n\t\tAuthKey  string `default:\"\"`\n\t\tUser     string `default:\"\"`\n\t\tPassword string `default:\"\"`\n\t\tPath     string `default:\"/grafana\"`\n\t\tEnable   bool   `default:\"false\"`\n\t}\n\n\tTRANSACTION_SETTINGS struct {\n\t\tDedupModel        string `default:\"message-ip-pair\"`\n\t\tGlobalDeduplicate bool   `default:\"false\"`\n\t}\n\n\tDASHBOARD_SETTINGS struct {\n\t\tExternalHomeDashboard string `default:\"\"`\n\t}\n\n\tOAUTH2_SETTINGS struct {\n\t\tEnable               bool     `default:\"false\"`\n\t\tClientID             string   `default:\"1234565\"`\n\t\tClientSecret         string   `default:\"FAKE\"`\n\t\tProjectID            string   `default:\"Homer Oauth2\"`\n\t\tAuthUri              string   `default:\"https://accounts.google.com/o/oauth2/auth\"`\n\t\tTokenUri             string   `default:\"https://oauth2.googleapis.com/token\"`\n\t\tAuthProviderCert     string   `default:\"https://www.googleapis.com/oauth2/v1/certs\"`\n\t\tRedirectUri          string   `default:\"http://localhost:80/api/v3/oauth2/auth\"`\n\t\tProfileURL           string   `default:\"https://www.googleapis.com/oauth2/v1/userinfo\"`\n\t\tMethod               string   `default:\"GET\"`\n\t\tUserToken            string   `default:\"checkRandom\"`\n\t\tServiceProviderName  string   `default:\"google\"`\n\t\tServiceProviderImage string   `default:\"\"`\n\t\tStateValue           string   `default:\"jkwh027yasj\"`\n\t\tUrlToServiceRedirect string   `default:\"/api/v3/oauth2/redirect\"`\n\t\tScope                []string `default:\"[email,openid,profile]\"`\n\t\tEnableGravatar       bool     `default:\"false\"`\n\t\tAuthStyle            int      `default:\"0\"`\n\t\tGravatarUrl          string   `default:\"https://www.gravatar.com/avatar/%s.jpg\"`\n\t\tExpireSSOToken       uint32   `default:\"5\"`\n\t}\n\n\tLOG_SETTINGS struct {\n\t\tEnable        bool   `default:\"true\"`\n\t\tMaxAgeDays    uint32 `default:\"7\"`\n\t\tRotationHours uint32 `default:\"24\"`\n\t\tPath          string `default:\"/usr/local/homer/log\"`\n\t\tLevel         string `default:\"error\"`\n\t\tName          string `default:\"homer-app.log\"`\n\t\tStdout        bool   `default:\"false\"`\n\t\tJson          bool   `default:\"true\"`\n\t\tSysLogLevel   string `default:\"LOG_INFO\"`\n\t\tSysLog        bool   `default:\"false\"`\n\t\tSyslogUri     string `default:\"\"`\n\t}\n\n\tSWAGGER struct {\n\t\tEnable  bool   `default:\"true\"`\n\t\tApiJson string `default:\"/usr/local/homer/etc/swagger.json\"`\n\t\tApiHost string `default:\"127.0.0.1:9080\"`\n\t}\n\n\tDECODER_SHARK struct {\n\t\tBin        string   `default:\"/usr/local/bin/tshark\"`\n\t\tParam      string   `default:\"\"`\n\t\tProtocols  []string `default:\"\"`\n\t\tUID        uint32   `default:\"0\"`\n\t\tGID        uint32   `default:\"0\"`\n\t\tImportNode string   `default:\"\"`\n\t\tEnable     bool     `default:\"false\"`\n\t}\n}\n", "{\n  \"database_data\": {\n    \"LocalNode\": {\n      \"help\": \"Settings for PGSQL Database (data)\",\n      \"node\": \"LocalNode\",\n      \"user\": \"homer_user\",\n      \"pass\": \"homer_password\",\n      \"name\": \"homer_data\",\n      \"keepalive\": true,\n      \"host\": \"127.0.0.1\"\n    }\n  },\n  \"hep_relay\": {\n    \"help\": \"UDP socket to send HEP data on\",\n    \"host\": \"127.0.0.1\",\n    \"port\": 9060\n  },\n  \"database_config\": {\n    \"help\": \"Settings for PGSQL Database (settings)\",\n    \"node\": \"LocalConfig\",\n    \"user\": \"homer_user\",\n    \"pass\": \"homer_password\",\n    \"name\": \"homer_config\",\n    \"keepalive\": true,\n    \"host\": \"localhost\"\n  },\n  \"influxdb_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for InfluxDB Database (optional)\",\n    \"user\": \"influx_user\",\n    \"pass\": \"influx_password\",\n    \"name\": \"homer_config\",\n    \"host\": \"http://127.0.0.1:8086\",\n    \"database\": \"homer\",\n    \"policy\": \"autogen\"\n  },\n  \"prometheus_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for Prometheus Database (optional)\",\n    \"user\": \"admin\",\n    \"pass\": \"admin\",\n    \"host\": \"http://127.0.0.1:9090\",\n    \"api\": \"api/v1\"\n  },\n  \"swagger\": {\n    \"enable\": true,\n    \"api_json\": \"/usr/local/homer/etc/swagger.json\",\n    \"api_host\": \"127.0.0.1:9080\"\n  },\n  \"loki_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for LOKI Database (optional)\",\n    \"user\": \"admin\",\n    \"pass\": \"admin\",\n    \"host\": \"http://127.0.0.1:3100\",\n    \"api\": \"loki/api/v1\",\n    \"param_query\": \"query_range\"\n  },\n  \"grafana_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for Grafana\",\n    \"host\": \"http://127.0.0.1:3000\",\n    \"path\": \"/grafana\",\n    \"token\": \"\"\n  },\n  \"http_settings\": {\n    \"help\": \"Settings for the HOMER Webapp Server. If you have gzip_static = false, please be sure that your dist directory has uncompressed .js files\",\n    \"host\": \"0.0.0.0\",\n    \"port\": 9080,\n    \"root\": \"/usr/local/homer/dist\",\n    \"gzip\": true,\n    \"gzip_static\": true,\n    \"debug\": false\n  },\n  \"transaction_settings\": {\n    \"deduplicate\": {\n        \"global\": false\n    }\n  },\n  \"api_settings\": {\n    \"add_captid_to_resolve\": false\n  },\n  \"https_settings\": {\n    \"help\": \"SSL settings for homer-app\",\n    \"enable\": false,\n    \"host\": \"0.0.0.0\",\n    \"port\": 443,\n    \"cert\": \"/usr/local/homer/tls/cert.pem\",\n    \"key\": \"/usr/local/homer/tls/key.pem\"\n  },\n  \"system_settings\": {\n    \"help\": \"Settings for HOMER logs\",\n    \"logpath\": \"/usr/local/homer/log\",\n    \"logname\": \"homer-app.log\",\n    \"_loglevels\": \"can be: fatal, error, warn, info, debug, trace\",\n    \"loglevel\": \"error\",\n    \"logstdout\": false\n  },\n  \"dashboard_settings\": {\n    \"_comment\": \"Here you can define a customs dashboards home\",\n    \"dashboard_home\": \"/usr/local/homer/etc/dashboard_home.json\"\n  },\n  \"auth_settings\": {\n    \"_comment\": \"The type param can be internal, ldap, http_auth\",\n    \"type\": \"internal\",\n    \"gravatar\": false,\n    \"gravatar_url\": \"https://www.gravatar.com/avatar/%s.jpg\",\n    \"token_expire\": 1200,\n    \"user_groups\": [\"admin\", \"user\", \"support\"]\n  },\n  \"ldap_config\": {\n    \"base\": \"dc=example,dc=com\",\n    \"host\": \"ldap.example.com\",\n    \"port\": 389,\n    \"usessl\": false,\n    \"skiptls\": true,\n    \"binddn\": \"uid=readonlysuer,ou=People,dc=example,dc=com\",\n    \"bindpassword\": \"readonlypassword\",\n    \"userfilter\": \"(uid=%s)\",\n    \"groupfilter\": \"(memberUid=%s)\",\n    \"group_attributes\": [\n      \"cn\",\n      \"memberOf\",\n      \"GroupAttribute\",\n      \"distinguishedName\",\n      \"dn\",\n      \"member\"\n    ],\n    \"admingroup\": \"admin\",\n    \"adminmode\": true,\n    \"usergroup\": \"HOMER_user\",\n    \"usermode\": true,\n    \"attributes\": [\"dn\", \"givenName\", \"sn\", \"mail\", \"uid\"],\n    \"skipverify\": true,\n    \"anonymous\": false,\n    \"userdn\": \"uid=%s,ou=People,dc=example,dc=com\"\n  },\n  \"http_auth\": {\n    \"url\": \"http://localhost:1323\",\n    \"skipverify\": true\n  },\n  \"oauth2\": {\n    \"enable\": false,\n    \"client_id\": \"1234565\",\n    \"client_secret\": \"FAKE\",\n    \"project_id\": \"Homer OAuth\",\n    \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n    \"token_uri\": \"https://oauth2.googleapis.com/token\",\n    \"auth_provider_x509_cert_url\":  \"https://www.googleapis.com/oauth2/v1/certs\",\n    \"redirect_uri\": \"http://localhost:80/api/v3/oauth2/auth\",\n    \"service_redirect\": \"/api/v3/oauth2/redirect\",\n    \"profile_url\": \"https://www.googleapis.com/oauth2/v1/userinfo\",\n    \"provider_name\": \"google\",\n    \"scope\": [\"email\", \"openid\", \"profile\"],\n    \"gravatar\": false,\n    \"gravatar_url\": \"https://www.gravatar.com/avatar/%s.jpg\",\n    \"provider_image\": \"\"\n  },\n  \"decoder_shark\": {\n    \"_comment\": \"Here you can do packet decoding using tshark application. Please define uid, gid if you run the app under root\",\n    \"active\": false,\n    \"bin\": \"/usr/bin/tshark\",\n    \"protocols\": [\"1_call\", \"1_registration\", \"1_default\"]\n  }\n}\n", "// Homer-App\n//\n// Homer-App User interface for WEB AI\n//\n//     Schemes: http, https\n//     Host: localhost:9080\n//     BasePath: /api/v3\n//     Version: 1.1.2\n//     License: AGPL https://www.gnu.org/licenses/agpl-3.0.en.html\n//\t   Copyright: QXIP B.V. 2019-2020\n//\n//     Consumes:\n//     - application/json\n//\n//     Produces:\n//     - application/json\n//     Security:\n//     - bearer:\n//\n//     SecurityDefinitions:\n//     bearer:\n//          type: apiKey\n//          name: Authorization\n//          in: header\n//\n// swagger:meta\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/davecgh/go-spew/spew\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/oauth2\"\n\n\t_ \"github.com/influxdata/influxdb1-client\" // this is important because of the bug in go mod\n\tclient \"github.com/influxdata/influxdb1-client/v2\"\n\t\"github.com/jinzhu/gorm\"\n\t_ \"github.com/jinzhu/gorm/dialects/postgres\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/mcuadros/go-defaults\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/sipcapture/homer-app/auth\"\n\t\"github.com/sipcapture/homer-app/config\"\n\t\"github.com/sipcapture/homer-app/data/service\"\n\t\"github.com/sipcapture/homer-app/migration\"\n\t\"github.com/sipcapture/homer-app/migration/jsonschema\"\n\t\"github.com/sipcapture/homer-app/model\"\n\thttpresponse \"github.com/sipcapture/homer-app/network/response\"\n\tapirouterv1 \"github.com/sipcapture/homer-app/router/v1\"\n\t\"github.com/sipcapture/homer-app/system/webmessages\"\n\t\"github.com/sipcapture/homer-app/utils/heputils\"\n\t\"github.com/sipcapture/homer-app/utils/httpauth\"\n\t\"github.com/sipcapture/homer-app/utils/ldap\"\n\t\"github.com/sipcapture/homer-app/utils/logger\"\n\t\"github.com/spf13/viper\"\n\t\"gopkg.in/go-playground/validator.v9\"\n)\n\n//CustomValidator function\ntype CustomValidator struct {\n\tvalidator *validator.Validate\n}\n\n// validate function\nfunc (cv *CustomValidator) Validate(i interface{}) error {\n\treturn cv.validator.Struct(i)\n}\n\nvar appFlags CommandLineFlags\nvar ldapClient ldap.LDAPClient\nvar httpAuth httpauth.Client\n\ntype arrayFlags []string\n\nfunc (i *arrayFlags) String() string {\n\treturn \"my string representation\"\n}\n\nfunc (i *arrayFlags) Set(value string) error {\n\t*i = append(*i, value)\n\treturn nil\n}\n\n//params for Flags\ntype CommandLineFlags struct {\n\tInitializeDB              *bool      `json:\"initialize_db\"`\n\tCreateConfigDB            *bool      `json:\"create_config_db\"`\n\tCreateDataDB              *bool      `json:\"create_data_db\"`\n\tCreateTableConfigDB       *bool      `json:\"create_table_config\"`\n\tUpgradeTableConfigDB      *bool      `json:\"upgrade_table_config\"`\n\tPopulateTableConfigDB     *bool      `json:\"populate_table_config\"`\n\tCreateHomerUser           *bool      `json:\"create_homer_user\"`\n\tDeleteHomerUser           *bool      `json:\"delete_homer_user\"`\n\tShowVersion               *bool      `json:\"version\"`\n\tForcePopulate             *bool      `json:\"force_insert\"`\n\tForcePasswordDB           *string    `json:\"force_password\"`\n\tUpdateUIUser              *string    `json:\"update_ui_user\"`\n\tUpdateUIPassword          *string    `json:\"update_ui_password\"`\n\tTablesPopulate            arrayFlags `json:\"force_tables\"`\n\tRevokeHomerRole           *bool      `json:\"revoke_homer_role\"`\n\tCreateHomerRole           *bool      `json:\"create_homer_role\"`\n\tSaveHomerDbConfigToConfig *bool      `json:\"save_db_config_to_config\"`\n\tSaveHomerDbDataToConfig   *bool      `json:\"save_db_data_to_config\"`\n\tShowDbUsers               *bool      `json:\"show_db_users\"`\n\tShowHelpMessage           *bool      `json:\"help\"`\n\tDatabaseRootUser          *string    `json:\"root_user\"`\n\tDatabaseRootPassword      *string    `json:\"root_password\"`\n\tDatabaseHost              *string    `json:\"root_host\"`\n\tDatabasePort              *int       `json:\"root_port\"`\n\tDatabaseRootDB            *string    `json:\"root_db\"`\n\tDatabaseSSLMode           *string    `json:\"sslmode_db\"`\n\tDatabaseHomerNode         *string    `json:\"homer_node\"`\n\tDatabaseHomerUser         *string    `json:\"homer_user\"`\n\tDatabaseHomerPassword     *string    `json:\"homer_password\"`\n\tDatabaseHomerConfig       *string    `json:\"db_homer_config\"`\n\tDatabaseHomerData         *string    `json:\"db_homer_data\"`\n\tPathWebAppConfig          *string    `json:\"path_webapp\"`\n\tLogPathWebApp             *string    `json:\"path_log_webapp\"`\n\tLogName                   *string    `json:\"log_name_webapp\"`\n\tAPIPrefix                 *string    `json:\"api_prefix\"`\n\tWatchConfig               *bool      `json:\"watch_config\"`\n\tShowCurrentConfig         *bool      `json:\"show_current_config\"`\n}\n\n//params for  Services\ntype ServicesObject struct {\n\tconfigDBSession   *gorm.DB\n\tdataDBSession     map[string]*gorm.DB\n\tdatabaseNodeMap   []model.DatabasesMap\n\tinfluxDBSession   service.ServiceInfluxDB\n\tservicePrometheus service.ServicePrometheus\n\tserviceLoki       service.ServiceLoki\n\tserviceGrafana    service.ServiceGrafana\n\texternalDecoder   service.ExternalDecoder\n}\n\nvar servicesObject ServicesObject\n\n/* init flags */\nfunc initFlags() {\n\tappFlags.InitializeDB = flag.Bool(\"initialize_db\", false, \"initialize the database and create all tables\")\n\tappFlags.CreateConfigDB = flag.Bool(\"create-config-db\", false, \"create config db\")\n\tappFlags.CreateDataDB = flag.Bool(\"create-data-db\", false, \"create data db\")\n\tappFlags.CreateTableConfigDB = flag.Bool(\"create-table-db-config\", false, \"create table in db config\")\n\tappFlags.UpgradeTableConfigDB = flag.Bool(\"upgrade-table-db-config\", false, \"upgrade table in db config\")\n\n\tappFlags.PopulateTableConfigDB = flag.Bool(\"populate-table-db-config\", false, \"populate table in db config\")\n\n\tappFlags.CreateHomerUser = flag.Bool(\"create-homer-user\", false, \"create homer user\")\n\tappFlags.DeleteHomerUser = flag.Bool(\"delete-homer-user\", false, \"delete homer user\")\n\tappFlags.ShowDbUsers = flag.Bool(\"show-db-users\", false, \"show db users\")\n\n\tappFlags.ForcePopulate = flag.Bool(\"force-populate\", false, \"force populate all records to config\")\n\tappFlags.ForcePasswordDB = flag.String(\"force-password\", \"\", \"force password for AWS setups\")\n\n\tappFlags.UpdateUIUser = flag.String(\"update-ui-user\", \"\", \"update user ui\")\n\tappFlags.UpdateUIPassword = flag.String(\"update-ui-password\", \"\", \"update password for user\")\n\n\tflag.Var(&appFlags.TablesPopulate, \"populate-table\", \"force to populate only current tables\")\n\n\tappFlags.ShowVersion = flag.Bool(\"version\", false, \"show version\")\n\n\tappFlags.CreateHomerRole = flag.Bool(\"create-homer-role\", false, \"create homer role\")\n\tappFlags.RevokeHomerRole = flag.Bool(\"revoke-homer-role\", false, \"revoke homer user\")\n\n\tappFlags.SaveHomerDbConfigToConfig = flag.Bool(\"save-homer-db-config-settings\", false, \"save homer db-config to configs\")\n\tappFlags.SaveHomerDbDataToConfig = flag.Bool(\"save-homer-db-data-settings\", false, \"save homer db-data settings to configs\")\n\n\tappFlags.ShowHelpMessage = flag.Bool(\"help\", false, \"show help\")\n\tappFlags.DatabaseRootUser = flag.String(\"database-root-user\", \"postgres\", \"database-root-user\")\n\tappFlags.DatabaseRootPassword = flag.String(\"database-root-password\", \"\", \"database-root-password\")\n\tappFlags.DatabaseHost = flag.String(\"database-host\", \"localhost\", \"database-host\")\n\tappFlags.DatabasePort = flag.Int(\"database-port\", 5432, \"database-port\")\n\tappFlags.DatabaseSSLMode = flag.String(\"database-ssl-mode\", \"disable\", \"database-ssl-mode\")\n\tappFlags.DatabaseRootDB = flag.String(\"database-root-db\", \"postgres\", \"database-root-db\")\n\tappFlags.DatabaseHomerNode = flag.String(\"database-homer-node\", \"localnode\", \"database-homer-node\")\n\tappFlags.DatabaseHomerUser = flag.String(\"database-homer-user\", \"homer_user\", \"database-homer-user\")\n\tappFlags.DatabaseHomerPassword = flag.String(\"database-homer-password\", \"homer_password\", \"database-homer-password\")\n\tappFlags.DatabaseHomerConfig = flag.String(\"database-homer-config\", \"homer_config\", \"database-homer-config\")\n\tappFlags.DatabaseHomerData = flag.String(\"database-homer-data\", \"homer_data\", \"database-homer-data\")\n\tappFlags.PathWebAppConfig = flag.String(\"webapp-config-path\", \"/usr/local/homer/etc\", \"the path to the webapp config file\")\n\tappFlags.LogName = flag.String(\"webapp-log-name\", \"\", \"the name prefix of the log file.\")\n\tappFlags.LogPathWebApp = flag.String(\"webapp-log-path\", \"\", \"the path for the log file.\")\n\tappFlags.APIPrefix = flag.String(\"webapp-api-prefix\", \"\", \"API prefix.\")\n\tappFlags.WatchConfig = flag.Bool(\"watch-config\", false, \"Watch the configuration for changes\")\n\tappFlags.ShowCurrentConfig = flag.Bool(\"show-current-config\", false, \"print out the current config and exit\")\n\n\tflag.Parse()\n}\n\nfunc main() {\n\n\t//init flags\n\tinitFlags()\n\n\t/* first check admin flags */\n\tcheckHelpVersionFlags()\n\n\tcfg := new(config.HomerSettingServer)\n\tdefaults.SetDefaults(cfg) //<-- This set the defaults values\n\tconfig.Setting = *cfg\n\n\t// read system configurations and expose through viper\n\treadConfig()\n\n\tconfigureLogging()\n\n\t/* first check admin flags */\n\tcheckAdminFlags()\n\n\t/* now check if we do write to config */\n\tif *appFlags.SaveHomerDbConfigToConfig {\n\t\tapplyDBConfigParamToConfig(appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword,\n\t\t\tappFlags.DatabaseHomerConfig, appFlags.DatabaseHost, appFlags.DatabaseSSLMode)\n\t\tos.Exit(0)\n\t} else if *appFlags.SaveHomerDbDataToConfig {\n\t\tapplyDBDataParamToConfig(appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword, appFlags.DatabaseHomerData,\n\t\t\tappFlags.DatabaseHost, appFlags.DatabaseHomerNode, appFlags.DatabaseSSLMode)\n\t\tos.Exit(0)\n\t}\n\n\tservicesObject.configDBSession = getConfigDBSession()\n\tdefer servicesObject.configDBSession.Close()\n\tnameHomerConfig := viper.GetString(\"database_config.name\")\n\n\tif *appFlags.CreateTableConfigDB || *appFlags.UpgradeTableConfigDB {\n\t\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpgradeTableConfigDB, true)\n\t\tos.Exit(0)\n\t} else if *appFlags.PopulateTableConfigDB {\n\t\tmigration.PopulateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.ForcePopulate, appFlags.TablesPopulate,\n\t\t\t*appFlags.ForcePasswordDB)\n\t\tos.Exit(0)\n\t}\n\n\tif *appFlags.UpdateUIUser != \"\" && *appFlags.UpdateUIPassword != \"\" {\n\t\tlogger.Info(fmt.Sprintf(\"Updating password for user: [%s]\\n\", *appFlags.UpdateUIUser))\n\t\tmigration.UpdateHomerUser(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpdateUIUser, *appFlags.UpdateUIPassword)\n\n\t\tos.Exit(0)\n\t}\n\n\t//http client\n\tinitHttpClient()\n\n\tconfigureServiceObjects()\n\n\t/* force to upgrade */\n\tif nameHomerConfig := viper.GetString(\"database_config.name\"); nameHomerConfig != \"\" {\n\t\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, true, false)\n\t}\n\n\t// update version\n\tupdateVersionApplication(servicesObject.configDBSession)\n\n\tif *appFlags.ShowCurrentConfig {\n\t\tShowCurrentConfigToConsole()\n\t\tos.Exit(0)\n\t}\n\n\t// configure to serve WebServices\n\tconfigureAsHTTPServer()\n\n}\n\nfunc configureLogging() {\n\n\t/* OLD LOG */\n\tif viper.IsSet(\"system_settings.logpath\") {\n\t\tconfig.Setting.LOG_SETTINGS.Path = viper.GetString(\"system_settings.logpath\")\n\t}\n\tif viper.IsSet(\"system_settings.logname\") {\n\t\tconfig.Setting.LOG_SETTINGS.Name = viper.GetString(\"system_settings.logname\")\n\t}\n\tif viper.IsSet(\"system_settings.loglevel\") {\n\t\tconfig.Setting.LOG_SETTINGS.Level = viper.GetString(\"system_settings.loglevel\")\n\t}\n\tif viper.IsSet(\"system_settings.logstdout\") {\n\t\tconfig.Setting.LOG_SETTINGS.Stdout = viper.GetBool(\"system_settings.logstdout\")\n\t}\n\tif viper.IsSet(\"system_settings.logjson\") {\n\t\tconfig.Setting.LOG_SETTINGS.Json = viper.GetBool(\"system_settings.logjson\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog\") {\n\t\tconfig.Setting.LOG_SETTINGS.SysLog = viper.GetBool(\"system_settings.syslog\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog_level\") {\n\t\tconfig.Setting.LOG_SETTINGS.SysLogLevel = viper.GetString(\"system_settings.syslog_level\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog_uri\") {\n\t\tconfig.Setting.LOG_SETTINGS.SyslogUri = viper.GetString(\"system_settings.syslog_uri\")\n\t}\n\n\tif *appFlags.LogPathWebApp != \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Path = *appFlags.LogPathWebApp\n\t} else if config.Setting.LOG_SETTINGS.Path == \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Path = \"log\"\n\t}\n\n\tif *appFlags.LogName != \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Name = *appFlags.LogName\n\t} else if config.Setting.LOG_SETTINGS.Name == \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Name = \"webapp.log\"\n\t}\n\t// initialize logger\n\tlogger.InitLogger()\n}\n\nfunc configureServiceObjects() {\n\t// configure new db session\n\tservicesObject.dataDBSession, servicesObject.databaseNodeMap = getDataDBSession()\n\t/* for val := range servicesObject.dataDBSession {\n\t\tdefer servicesObject.dataDBSession[val].Close()\n\t}\n\t*/\n\n\t// configure new influx db session\n\tservicesObject.influxDBSession = getInfluxDBSession()\n\t/*if servicesObject.influxDBSession.Active {\n\t\tdefer servicesObject.influxDBSession.InfluxClient.Close()\n\t}\n\t*/\n\n\t// configure new influx db session\n\tservicesObject.servicePrometheus = getPrometheusDBSession()\n\t//defer prometheusService.Close()\n\n\tservicesObject.serviceLoki = getRemoteDBSession()\n\t//defer httpClient.CloseIdleConnections()\n\n\tservicesObject.serviceGrafana = getGrafanaSession()\n\n\t/***********************************/\n\tconfig.Setting.MAIN_SETTINGS.IsolateQuery = viper.GetString(\"group_settings.isolate_query\")\n\tconfig.Setting.MAIN_SETTINGS.IsolateGroup = viper.GetString(\"group_settings.isolate_group\")\n\n\t/***********************************/\n\tif viper.IsSet(\"transaction_settings.deduplicate\") {\n\n\t\tif viper.IsSet(\"transaction_settings.deduplicate.model\") {\n\t\t\tconfig.Setting.TRANSACTION_SETTINGS.DedupModel = viper.GetString(\"transaction_settings.deduplicate.model\")\n\t\t}\n\n\t\tif viper.IsSet(\"transaction_settings.deduplicate.global\") {\n\t\t\tconfig.Setting.TRANSACTION_SETTINGS.GlobalDeduplicate = viper.GetBool(\"transaction_settings.deduplicate.global\")\n\t\t}\n\t}\n\n\t/* CaptID alias */\n\tif viper.IsSet(\"api_settings.add_captid_to_resolve\") {\n\t\tconfig.Setting.MAIN_SETTINGS.UseCaptureIDInAlias = viper.GetBool(\"api_settings.add_captid_to_resolve\")\n\t}\n\n\t/* init map */\n\tconfig.OAuth2TokenMap = make(map[string]model.OAuth2MapToken)\n\n\t/* oauth2 */\n\tif viper.IsSet(\"oauth2.enable\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Enable = viper.GetBool(\"oauth2.enable\")\n\t}\n\tif viper.IsSet(\"oauth2.client_id\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ClientID = viper.GetString(\"oauth2.client_id\")\n\t}\n\tif viper.IsSet(\"oauth2.client_secret\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ClientSecret = viper.GetString(\"oauth2.client_secret\")\n\t}\n\tif viper.IsSet(\"oauth2.project_id\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ProjectID = viper.GetString(\"oauth2.project_id\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthUri = viper.GetString(\"oauth2.auth_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.token_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.TokenUri = viper.GetString(\"oauth2.token_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_provider_x509_cert_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthProviderCert = viper.GetString(\"oauth2.auth_provider_x509_cert_url\")\n\t}\n\tif viper.IsSet(\"oauth2.redirect_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.RedirectUri = viper.GetString(\"oauth2.redirect_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.provider_name\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ServiceProviderName = viper.GetString(\"oauth2.provider_name\")\n\t}\n\tif viper.IsSet(\"oauth2.provider_image\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ServiceProviderImage = viper.GetString(\"oauth2.provider_image\")\n\t}\n\tif viper.IsSet(\"oauth2.service_redirect\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.UrlToServiceRedirect = viper.GetString(\"oauth2.service_redirect\")\n\t}\n\tif viper.IsSet(\"oauth2.scope\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Scope = viper.GetStringSlice(\"oauth2.scope\")\n\t}\n\tif viper.IsSet(\"oauth2.state_value\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.StateValue = viper.GetString(\"oauth2.state_value\")\n\t}\n\tif viper.IsSet(\"oauth2.expire_sso\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ExpireSSOToken = viper.GetUint32(\"oauth2.expire_sso\")\n\t}\n\tif viper.IsSet(\"oauth2.profile_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ProfileURL = viper.GetString(\"oauth2.profile_url\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_style\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthStyle = viper.GetInt(\"oauth2.auth_style\")\n\t}\n\n\tif viper.IsSet(\"oauth2.method\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Method = viper.GetString(\"oauth2.method\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"oauth2.gravatar\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.EnableGravatar = viper.GetBool(\"oauth2.gravatar\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"oauth2.gravatar_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.GravatarUrl = viper.GetString(\"oauth2.gravatar_url\")\n\t}\n\t/*********** DASHBOARD *******************/\n\tif viper.IsSet(\"dashboard_settings.dashboard_home\") {\n\t\tconfig.Setting.DASHBOARD_SETTINGS.ExternalHomeDashboard = viper.GetString(\"dashboard_settings.dashboard_home\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.type\") {\n\t\tconfig.Setting.MAIN_SETTINGS.DefaultAuth = viper.GetString(\"auth_settings.type\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.gravatar\") {\n\t\tconfig.Setting.MAIN_SETTINGS.EnableGravatar = viper.GetBool(\"auth_settings.gravatar\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.gravatar_url\") {\n\t\tconfig.Setting.MAIN_SETTINGS.GravatarUrl = viper.GetString(\"auth_settings.gravatar_url\")\n\t}\n\n\t/* auth settings */\n\tif viper.IsSet(\"auth_settings.user_groups\") {\n\t\tconfig.Setting.MAIN_SETTINGS.UserGroups = viper.GetStringSlice(\"auth_settings.user_groups\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"http_client.connection_timeout\") {\n\t\tconfig.Setting.MAIN_SETTINGS.TimeoutHttpClient = viper.GetUint32(\"http_client.connection_timeout\")\n\t}\n\n\t/* check the auth type */\n\tif config.Setting.MAIN_SETTINGS.DefaultAuth == \"\" {\n\t\tconfig.Setting.MAIN_SETTINGS.DefaultAuth = \"internal\"\n\t}\n\n\tif config.Setting.OAUTH2_SETTINGS.Enable {\n\t\tconfig.Setting.MAIN_SETTINGS.OAuth2Config = oauth2.Config{\n\t\t\tClientID:     config.Setting.OAUTH2_SETTINGS.ClientID,\n\t\t\tClientSecret: config.Setting.OAUTH2_SETTINGS.ClientSecret,\n\t\t\tScopes:       config.Setting.OAUTH2_SETTINGS.Scope,\n\t\t\tRedirectURL:  config.Setting.OAUTH2_SETTINGS.RedirectUri + \"/\" + config.Setting.OAUTH2_SETTINGS.ServiceProviderName,\n\t\t\tEndpoint: oauth2.Endpoint{\n\t\t\t\tAuthURL:   config.Setting.OAUTH2_SETTINGS.AuthUri,\n\t\t\t\tTokenURL:  config.Setting.OAUTH2_SETTINGS.TokenUri,\n\t\t\t\tAuthStyle: oauth2.AuthStyle(config.Setting.OAUTH2_SETTINGS.AuthStyle),\n\t\t\t},\n\t\t}\n\t}\n\n\t/* Check LDAP here */\n\tswitch config.Setting.MAIN_SETTINGS.DefaultAuth {\n\tcase \"ldap\":\n\n\t\tdefaults.SetDefaults(&ldapClient) //<-- This set the defaults values\n\n\t\tif viper.IsSet(\"ldap_config.base\") {\n\t\t\tldapClient.Base = viper.GetString(\"ldap_config.base\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.host\") {\n\t\t\tldapClient.Host = viper.GetString(\"ldap_config.host\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.port\") {\n\t\t\tldapClient.Port = viper.GetInt(\"ldap_config.port\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.servername\") {\n\t\t\tldapClient.ServerName = viper.GetString(\"ldap_config.servername\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.userdn\") {\n\t\t\tldapClient.UserDN = viper.GetString(\"ldap_config.userdn\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.usessl\") {\n\t\t\tldapClient.UseSSL = viper.GetBool(\"ldap_config.usessl\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.deref\") {\n\t\t\tldapClient.DerefName = viper.GetString(\"ldap_config.deref\")\n\t\t\t/* lets fix it */\n\t\t\tif ldapClient.DerefName != \"\" {\n\t\t\t\tfor index, x := range ldap.DerefMap {\n\t\t\t\t\tif x == ldapClient.DerefName {\n\t\t\t\t\t\tldapClient.DerefValue = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.scope\") {\n\t\t\tldapClient.ScopeName = viper.GetString(\"ldap_config.scope\")\n\t\t\t/* lets fix it */\n\t\t\tif ldapClient.ScopeName != \"\" {\n\t\t\t\tfor index, x := range ldap.ScopeMap {\n\t\t\t\t\tif x == ldapClient.ScopeName {\n\t\t\t\t\t\tldapClient.ScopeValue = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.anonymous\") {\n\t\t\tldapClient.Anonymous = viper.GetBool(\"ldap_config.anonymous\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.binddn\") {\n\t\t\tldapClient.BindDN = viper.GetString(\"ldap_config.binddn\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.bindpassword\") {\n\t\t\tldapClient.BindPassword = viper.GetString(\"ldap_config.bindpassword\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.userfilter\") {\n\t\t\tldapClient.UserFilter = viper.GetString(\"ldap_config.userfilter\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.groupfilter\") {\n\t\t\tldapClient.GroupFilter = viper.GetString(\"ldap_config.groupfilter\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.attributes\") {\n\t\t\tldapClient.Attributes = viper.GetStringSlice(\"ldap_config.attributes\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.group_attributes\") {\n\t\t\tldapClient.GroupAttribute = viper.GetStringSlice(\"ldap_config.group_attributes\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.admingroup\") {\n\t\t\tldapClient.AdminGroup = viper.GetString(\"ldap_config.admingroup\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.usergroup\") {\n\t\t\tldapClient.UserGroup = viper.GetString(\"ldap_config.usergroup\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.usermode\") {\n\t\t\tldapClient.UserMode = viper.GetBool(\"ldap_config.usermode\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.adminmode\") {\n\t\t\tldapClient.AdminMode = viper.GetBool(\"ldap_config.adminmode\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.searchlimit\") {\n\t\t\tldapClient.SearchLimit = viper.GetInt(\"ldap_config.searchlimit\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.grouplimit\") {\n\t\t\tldapClient.GroupLimit = viper.GetInt(\"ldap_config.grouplimit\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.skiptls\") {\n\t\t\tldapClient.SkipTLS = viper.GetBool(\"ldap_config.skiptls\")\n\t\t} else {\n\t\t\tif !ldapClient.UseSSL {\n\t\t\t\tldapClient.SkipTLS = true\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.skipverify\") {\n\t\t\tldapClient.InsecureSkipVerify = viper.GetBool(\"ldap_config.skipverify\")\n\t\t} else {\n\t\t\tldapClient.InsecureSkipVerify = true\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.short_group\") {\n\t\t\tldapClient.ShortGroup = viper.GetBool(\"ldap_config.short_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.short_dn_group\") {\n\t\t\tldapClient.ShortDNForGroup = viper.GetBool(\"ldap_config.short_dn_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.nested_group\") {\n\t\t\tldapClient.NestedGroup = viper.GetBool(\"ldap_config.nested_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.UseDNForGroupSearch\") {\n\t\t\tldapClient.UseDNForGroupSearch = viper.GetBool(\"ldap_config.UseDNForGroupSearch\")\n\t\t} else {\n\t\t\tldapClient.UseDNForGroupSearch = true\n\t\t}\n\n\t\tdefer ldapClient.Close()\n\n\tcase \"http_auth\":\n\t\thttpAuth.URL = viper.GetString(\"http_auth.url\")\n\t\thttpAuth.InsecureSkipVerify = viper.GetBool(\"skipverify\")\n\t}\n\n\t/* apply token expire - default 1200 */\n\tauthTokenExpire := viper.GetInt(\"auth_settings.token_expire\")\n\tif authTokenExpire > 0 {\n\t\tauth.TokenExpiryTime = authTokenExpire\n\t}\n\n\tif versionPg, err := migration.CheckVersion(servicesObject.configDBSession); err != nil {\n\t\theputils.Colorize(heputils.ColorRed, \"\\r\\nVersion of DB couldn't be retrieved\\r\\n\")\n\t} else if (versionPg / 10000) < jsonschema.MinimumPgSQL {\n\t\theputils.Colorize(heputils.ColorRed, fmt.Sprintf(\"\\r\\nYou don't have required version of PostgreSQL. Please install minimum: %d\\r\\n\", jsonschema.MinimumPgSQL))\n\t} else {\n\t\theputils.Colorize(heputils.ColorBlue, fmt.Sprintf(\"\\r\\nPostgreSQL version: %d.%d\\r\\n\", versionPg/10000, versionPg%10000))\n\t}\n\n}\n\nfunc configureAsHTTPServer() {\n\n\te := echo.New()\n\t// add validation\n\te.Validator = &CustomValidator{validator: validator.New()}\n\t// Middleware\n\tif httpDebugEnable := viper.GetBool(\"http_settings.debug\"); httpDebugEnable {\n\t\te.Use(middleware.Logger())\n\t\te.Use(middleware.Recover())\n\t\te.Use(middleware.BodyDumpWithConfig(middleware.BodyDumpConfig{Skipper: skipper, Handler: bodyDumpHandler}))\n\t}\n\n\t//CORS\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"*\"},\n\t\tAllowMethods: []string{echo.GET, echo.PUT, echo.PATCH, echo.POST, echo.DELETE},\n\t}))\n\n\t/* hide banner */\n\te.HideBanner = true\n\n\tif viper.IsSet(\"grafana_config.host\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.URL = viper.GetString(\"grafana_config.host\")\n\t}\n\n\tif viper.IsSet(\"grafana_config.path\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.Path = viper.GetString(\"grafana_config.path\")\n\t}\n\n\tif viper.IsSet(\"grafana_config.token\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.AuthKey = viper.GetString(\"grafana_config.token\")\n\t}\n\n\t// Reverse Proxy\n\turl1, err := url.Parse(config.Setting.GRAFANA_SETTINGS.URL)\n\tif err != nil {\n\t\te.Logger.Fatal(err)\n\t}\n\n\t/* target grafana */\n\te.Use(GrafanaHeader)\n\n\ttargets := []*middleware.ProxyTarget{\n\t\t{\n\t\t\tURL: url1,\n\t\t},\n\t}\n\n\te.Group(config.Setting.GRAFANA_SETTINGS.Path, middleware.ProxyWithConfig(middleware.ProxyConfig{\n\t\tBalancer: middleware.NewRoundRobinBalancer(targets),\n\t\tRewrite: map[string]string{\n\t\t\tconfig.Setting.GRAFANA_SETTINGS.Path + \"/*\": \"/$1\",\n\t\t},\n\t}))\n\n\tif config.Setting.SWAGGER.Enable {\n\t\t//e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\te.GET(\"/doc/api/json\", func(c echo.Context) error {\n\n\t\t\tlogger.Debug(\"Middle swagger ware: \", c.Request().RequestURI)\n\t\t\tdataJson, err := ioutil.ReadFile(config.Setting.SWAGGER.ApiJson)\n\t\t\tif err != nil {\n\t\t\t\treturn httpresponse.CreateBadResponse(&c, http.StatusBadRequest, webmessages.SwaggerFileNotExistsError)\n\t\t\t}\n\n\t\t\tnewJson := strings.ReplaceAll(string(dataJson), \"localhost:9080\", config.Setting.SWAGGER.ApiHost)\n\n\t\t\treturn httpresponse.CreateSuccessResponseWithJson(&c, http.StatusOK, []byte(newJson))\n\t\t})\n\t}\n\n\t/* static */\n\trootPath := viper.GetString(\"http_settings.root\")\n\tif rootPath == \"\" {\n\t\trootPath = \"/usr/local/homer/dist\"\n\t}\n\t/* static */\n\te.Use(middleware.Static(rootPath))\n\n\t/* enable guzip*/\n\tif gzipEnable := viper.GetBool(\"http_settings.gzip\"); gzipEnable {\n\t\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\t\tSkipper: func(c echo.Context) bool {\n\t\t\t\tif strings.HasPrefix(c.Request().RequestURI, \"/swagger\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tLevel: 5,\n\t\t}))\n\t}\n\n\tgzipStaticEnable := true\n\n\tif viper.IsSet(\"http_settings.gzip_static\") {\n\t\tgzipStaticEnable = viper.GetBool(\"http_settings.gzip_static\")\n\t}\n\n\tif gzipStaticEnable {\n\n\t\te.Pre(middleware.RewriteWithConfig(middleware.RewriteConfig{\n\t\t\tSkipper: func(c echo.Context) bool {\n\n\t\t\t\tif strings.HasSuffix(c.Request().RequestURI, \".js\") {\n\t\t\t\t\tif heputils.FileExists(rootPath + c.Request().RequestURI + \".gz\") {\n\t\t\t\t\t\tc.Response().Header().Set(echo.HeaderContentEncoding, \"gzip\")\n\t\t\t\t\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJavaScript)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tRules: map[string]string{\n\t\t\t\t\"*.js\": \"$1.js.gz\",\n\t\t\t},\n\t\t}))\n\t}\n\n\tregisterGetRedirect(e, rootPath)\n\n\t/* decoder */\n\tservicesObject.externalDecoder.Active = false\n\n\t/* old */\n\tbinShark := viper.GetString(\"decoder_shark.bin\")\n\tif binShark != \"\" {\n\t\tservicesObject.externalDecoder.Binary = binShark\n\t\tservicesObject.externalDecoder.Param = viper.GetString(\"decoder_shark.param\")\n\t\tservicesObject.externalDecoder.Protocols = viper.GetStringSlice(\"decoder_shark.protocols\")\n\t\tservicesObject.externalDecoder.UID = uint32(viper.GetInt(\"decoder_shark.uid\"))\n\t\tservicesObject.externalDecoder.GID = uint32(viper.GetInt(\"decoder_shark.gid\"))\n\t\tservicesObject.externalDecoder.Active = viper.GetBool(\"decoder_shark.active\")\n\t}\n\n\t//  DECODER - SHARK\n\tif viper.IsSet(\"decoder_shark.bin\") {\n\t\tconfig.Setting.DECODER_SHARK.Bin = viper.GetString(\"decoder_shark.bin\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.param\") {\n\t\tconfig.Setting.DECODER_SHARK.Param = viper.GetString(\"decoder_shark.param\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.import_node\") {\n\t\tconfig.Setting.DECODER_SHARK.ImportNode = viper.GetString(\"decoder_shark.import_node\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.protocols\") {\n\t\tconfig.Setting.DECODER_SHARK.Protocols = viper.GetStringSlice(\"decoder_shark.protocols\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.uid\") {\n\t\tconfig.Setting.DECODER_SHARK.UID = uint32(viper.GetInt(\"decoder_shark.uid\"))\n\t}\n\n\tif viper.IsSet(\"decoder_shark.gid\") {\n\t\tconfig.Setting.DECODER_SHARK.GID = uint32(viper.GetInt(\"decoder_shark.gid\"))\n\t}\n\tif viper.IsSet(\"decoder_shark.active\") {\n\t\tconfig.Setting.DECODER_SHARK.Enable = viper.GetBool(\"decoder_shark.active\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.enable\") {\n\t\tconfig.Setting.DECODER_SHARK.Enable = viper.GetBool(\"decoder_shark.enable\")\n\t}\n\n\tif viper.IsSet(\"swagger.enable\") {\n\t\tconfig.Setting.SWAGGER.Enable = viper.GetBool(\"swagger.enable\")\n\t}\n\n\tif viper.IsSet(\"swagger.api_json\") {\n\t\tconfig.Setting.SWAGGER.ApiJson = viper.GetString(\"swagger.api_json\")\n\t}\n\n\tif viper.IsSet(\"swagger.api_host\") {\n\t\tconfig.Setting.SWAGGER.ApiHost = viper.GetString(\"swagger.api_host\")\n\t}\n\n\t// perform routing for v1 version of web apis\n\tperformV1APIRouting(e)\n\tif viper.GetBool(\"https_settings.enable\") {\n\t\thttpsHost := viper.GetString(\"https_settings.host\")\n\t\thttpsPort := viper.GetString(\"https_settings.port\")\n\t\thttpsURL := fmt.Sprintf(\"%s:%s\", httpsHost, httpsPort)\n\n\t\thttpsCert := viper.GetString(\"https_settings.cert\")\n\t\thttpsKey := viper.GetString(\"https_settings.key\")\n\t\theputils.Colorize(heputils.ColorRed, heputils.HomerLogo)\n\t\theputils.Colorize(heputils.ColorGreen, fmt.Sprintf(\"Version: %s %s\", getName(), getVersion()))\n\n\t\t//Doc Swagger for future. For now - external\n\t\t/* e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\t */\n\t\te.Logger.Fatal(e.StartTLS(httpsURL, httpsCert, httpsKey))\n\t} else {\n\t\thttpHost := viper.GetString(\"http_settings.host\")\n\t\thttpPort := viper.GetString(\"http_settings.port\")\n\t\thttpURL := fmt.Sprintf(\"%s:%s\", httpHost, httpPort)\n\n\t\theputils.Colorize(heputils.ColorRed, heputils.HomerLogo)\n\t\theputils.Colorize(heputils.ColorGreen, fmt.Sprintf(\"Version: %s %s\", getName(), getVersion()))\n\n\t\t//Doc Swagger for future. For now - external\n\t\t/* e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\t */\n\t\te.Logger.Fatal(e.Start(httpURL))\n\t}\n\n}\n\nfunc performV1APIRouting(e *echo.Echo) {\n\n\tprefix := *appFlags.APIPrefix\n\n\tif viper.IsSet(\"http_settings.api_prefix\") {\n\t\tprefix = viper.GetString(\"http_settings.api_prefix\")\n\t}\n\n\t// accessible web services will fall in this group\n\tacc := e.Group(prefix + \"/api/v3\")\n\n\tswitch config.Setting.MAIN_SETTINGS.DefaultAuth {\n\tcase \"ldap\":\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, &ldapClient, nil)\n\tcase \"http_auth\":\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, nil, &httpAuth)\n\tdefault:\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, nil, nil)\n\t}\n\n\t//subscribe access with authKey\n\tapirouterv1.RouteAgentsubAuthKeyApis(acc, servicesObject.configDBSession)\n\n\t// route hep_reply apis\n\taddr := fmt.Sprintf(\"%s:%d\", viper.Get(\"hep_relay.host\"), viper.GetInt(\"hep_relay.port\"))\n\tapirouterv1.RouteWebSocketApis(acc, addr)\n\n\t// restricted web services will fall in this group\n\tres := e.Group(prefix + \"/api/v3\")\n\t// Configure middleware with the custom claims type\n\tconfig := middleware.JWTConfig{\n\t\tClaims:     &auth.JwtUserClaim{},\n\t\tSigningKey: []byte(auth.JwtSecret),\n\t}\n\n\tres.Use(middleware.JWTWithConfig(config))\n\tres.Use(auth.MiddlewareRes)\n\n\tlogger.Debug(auth.JwtUserClaim{})\n\n\t/*************** admin access ONLY ***************/\n\t// route mapping apis\n\tapirouterv1.RouteMappingdApis(res, servicesObject.configDBSession)\n\t// route alias apis\n\tapirouterv1.RouteAliasApis(res, servicesObject.configDBSession)\n\t// route advanced apis\n\tapirouterv1.RouteAdvancedApis(res, servicesObject.configDBSession)\n\t// route hepsub apis\n\tapirouterv1.RouteHepsubApis(res, servicesObject.configDBSession)\n\t// route make auth token\n\tapirouterv1.RouteAuthTokenApis(res, servicesObject.configDBSession)\n\n\t/*************** PARTLY admin access ONLY ***************/\n\t// route user apis\n\tapirouterv1.RouteUserDetailsApis(res, servicesObject.configDBSession)\n\t// route userSettings apis\n\tapirouterv1.RouteUserSettingsApis(res, servicesObject.configDBSession)\n\t// route agent sub apis\n\tapirouterv1.RouteAgentsubApis(res, servicesObject.configDBSession)\n\n\t// route hep sub search apis\n\tapirouterv1.RouteHepSubSearch(res, servicesObject.configDBSession)\n\n\t// route search apis\n\tapirouterv1.RouteSearchApis(res, servicesObject.dataDBSession, servicesObject.configDBSession, servicesObject.externalDecoder)\n\t// route dashboards apis\n\tapirouterv1.RouteDashboardApis(res, servicesObject.configDBSession)\n\n\t// route profile apis\n\tapirouterv1.RouteProfileApis(res, servicesObject.configDBSession, servicesObject.databaseNodeMap)\n\t// route RouteStatisticApis apis\n\tapirouterv1.RouteStatisticApis(res, servicesObject.influxDBSession)\n\t// route RouteStatisticApis apis\n\tapirouterv1.RoutePrometheusApis(res, servicesObject.servicePrometheus)\n\t// route RouteLokiApis apis\n\tapirouterv1.RouteLokiApis(res, servicesObject.serviceLoki)\n\t// route RouteLokiApis apis\n\tapirouterv1.RouteGrafanaApis(res, servicesObject.configDBSession, servicesObject.serviceGrafana)\n\n}\n\n/* retries */\nfunc RetryHandler(n int, f func() (bool, error)) error {\n\tok, er := f()\n\tif ok && er == nil {\n\t\treturn nil\n\t}\n\tif n-1 > 0 {\n\t\treturn RetryHandler(n-1, f)\n\t}\n\treturn er\n}\n\n// getSession creates a new mongo session and panics if connection error occurs\nfunc getDataDBSession() (map[string]*gorm.DB, []model.DatabasesMap) {\n\n\tdataConfig := viper.GetStringMapStringSlice(\"database_data\")\n\tdbMap := make(map[string]*gorm.DB)\n\tvar dbNodeMap []model.DatabasesMap\n\n\tif _, ok := dataConfig[\"user\"]; !ok {\n\t\tfor val := range dataConfig {\n\n\t\t\tkeyData := \"database_data.\" + val\n\n\t\t\tuser := viper.GetString(keyData + \".user\")\n\t\t\tpassword := viper.GetString(keyData + \".pass\")\n\t\t\tname := viper.GetString(keyData + \".name\")\n\t\t\thost := viper.GetString(keyData + \".host\")\n\t\t\tnode := viper.GetString(keyData + \".node\")\n\t\t\tport := viper.GetInt(keyData + \".port\")\n\n\t\t\t/* keep alive is on by default */\n\t\t\tkeepAlive := true\n\t\t\tif viper.IsSet(keyData + \".keepalive\") {\n\t\t\t\tkeepAlive = viper.GetBool(keyData + \".keepalive\")\n\t\t\t}\n\n\t\t\tsslMode := \"disable\"\n\t\t\tif viper.IsSet(keyData + \".sslmode\") {\n\t\t\t\tsslMode = viper.GetString(keyData + \".sslmode\")\n\t\t\t} else if viper.IsSet(keyData+\".usessl\") && viper.GetBool(keyData+\".usessl\") {\n\t\t\t\tsslMode = \"require\"\n\t\t\t}\n\n\t\t\tlogger.Info(fmt.Sprintf(\"Connecting to [%s, %s, %s, %s, %d, ssl: %s]\\n\", host, user, name, node, port, sslMode))\n\n\t\t\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\t\t\tif port != 0 {\n\t\t\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t\t\t}\n\n\t\t\tdbA, err := gorm.Open(\"postgres\", connectString)\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make connection to [Host: %s, Node: %s, Port: %d]: \\n\", host, node, port), err)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tdbA.DB().SetMaxIdleConns(5)\n\t\t\t\tdbA.DB().SetMaxOpenConns(10)\n\t\t\t\tdbA.DB().SetConnMaxLifetime(5 * time.Minute)\n\t\t\t\t/* activate logging */\n\t\t\t\tdbA.SetLogger(&logger.GormLogger{})\n\t\t\t\tdbMap[val] = dbA\n\n\t\t\t\tdbNodeMap = append(dbNodeMap, model.DatabasesMap{Name: node, Value: val})\n\n\t\t\t\tif keepAlive {\n\n\t\t\t\t\tgo makePingKeepAlive(dbA, host, \"data\", node)\n\n\t\t\t\t\t// auto-connect\uff0cping per 60s, re-connect on fail or error with intervels 3s, 3s, 15s, 30s, 60s, 60s ...\n\t\t\t\t\t/* go func(dbConfig string, db *gorm.DB) {\n\t\t\t\t\t\tvar intervals = []time.Duration{3 * time.Second, 3 * time.Second, 15 * time.Second, 30 * time.Second, 60 * time.Second}\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\ttime.Sleep(60 * time.Second)\n\t\t\t\t\t\t\tif e := db.DB().Ping(); e != nil {\n\t\t\t\t\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make ping to [Connect: %s]  Error: [%v]\", dbConfig, e))\n\t\t\t\t\t\t\tL:\n\t\t\t\t\t\t\t\tfor i := 0; i < len(intervals); i++ {\n\t\t\t\t\t\t\t\t\te2 := RetryHandler(3, func() (bool, error) {\n\t\t\t\t\t\t\t\t\t\tvar e error\n\t\t\t\t\t\t\t\t\t\tdb, e = gorm.Open(\"postgres\", dbConfig)\n\t\t\t\t\t\t\t\t\t\tif e != nil {\n\t\t\t\t\t\t\t\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make connect to [Connect: %s]  Error: [%v]\", dbConfig, e))\n\t\t\t\t\t\t\t\t\t\t\treturn false, e\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tif e2 != nil {\n\t\t\t\t\t\t\t\t\t\tfmt.Println(e.Error())\n\t\t\t\t\t\t\t\t\t\ttime.Sleep(intervals[i])\n\t\t\t\t\t\t\t\t\t\tif i == len(intervals)-1 {\n\t\t\t\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak L\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}(connectString, dbA)\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlogger.Info(\"----------------------------------- \")\n\t\t\tlogger.Info(\"*** Database Data Session created *** \")\n\t\t\tlogger.Info(\"----------------------------------- \")\n\t\t}\n\t} else {\n\t\t//single node\n\t\tuser := viper.GetString(\"database_data.user\")\n\t\tpassword := viper.GetString(\"database_data.pass\")\n\t\tname := viper.GetString(\"database_data.name\")\n\t\thost := viper.GetString(\"database_data.host\")\n\t\tport := viper.GetInt(\"database_data.port\")\n\n\t\t/* keep alive is on by default */\n\t\tkeepAlive := true\n\t\tif viper.IsSet(\"database_data.keepalive\") {\n\t\t\tkeepAlive = viper.GetBool(\"database_data.keepalive\")\n\t\t}\n\n\t\tlogger.Info(fmt.Sprintf(\"Connecting to the old way: [%s, %s, %s, %d]\\n\", host, user, name, port))\n\n\t\tsslMode := \"disable\"\n\t\tif viper.IsSet(\"database_data.sslmode\") {\n\t\t\tsslMode = viper.GetString(\"database_data.sslmode\")\n\t\t} else if viper.IsSet(\"database_data.usessl\") && viper.GetBool(\"database_data.usessl\") {\n\t\t\tsslMode = \"require\"\n\t\t}\n\n\t\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\t\tif port != 0 {\n\t\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t\t}\n\n\t\tdb, err := gorm.Open(\"postgres\", connectString)\n\n\t\tdb.DB().SetMaxIdleConns(5)\n\t\tdb.DB().SetMaxOpenConns(10)\n\t\tdb.DB().SetConnMaxLifetime(5 * time.Minute)\n\t\t/* activate logging */\n\t\tdb.SetLogger(&logger.GormLogger{})\n\n\t\tdbMap[\"localnode\"] = db\n\n\t\tif err != nil {\n\t\t\tlogger.Error(err)\n\t\t\tpanic(\"failed to connect database\")\n\t\t}\n\n\t\tdbNodeMap = append(dbNodeMap, model.DatabasesMap{Value: \"localnode\", Name: \"LocalNode\"})\n\n\t\tif keepAlive {\n\t\t\tgo makePingKeepAlive(db, host, \"data\", \"localnode\")\n\t\t}\n\n\t\tlogger.Info(\"----------------------------------- \")\n\t\tlogger.Info(\"*** Database Data Session created *** \")\n\t\tlogger.Info(\"----------------------------------- \")\n\t}\n\n\treturn dbMap, dbNodeMap\n}\n\n// getSession creates a new postgres session and panics if connection error occurs\nfunc getConfigDBSession() *gorm.DB {\n\tuser := viper.GetString(\"database_config.user\")\n\tpassword := viper.GetString(\"database_config.pass\")\n\tname := viper.GetString(\"database_config.name\")\n\thost := viper.GetString(\"database_config.host\")\n\tport := viper.GetInt(\"database_config.port\")\n\n\t/* keep alive is on by default */\n\tkeepAlive := true\n\tif viper.IsSet(\"database_config.keepalive\") {\n\t\tkeepAlive = viper.GetBool(\"database_config.keepalive\")\n\t}\n\n\tsslMode := \"disable\"\n\tif viper.IsSet(\"database_config.sslmode\") {\n\t\tsslMode = viper.GetString(\"database_config.sslmode\")\n\t} else if viper.IsSet(\"database_config.usessl\") && viper.GetBool(\"database_config.usessl\") {\n\t\tsslMode = \"require\"\n\t}\n\n\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\tif port != 0 {\n\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"Connecting to the config: [%s, %s, %s, %d]\\n\", host, user, name, port))\n\n\tdb, err := gorm.Open(\"postgres\", connectString)\n\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to connect database\")\n\t}\n\n\tdb.DB().SetMaxIdleConns(5)\n\tdb.DB().SetMaxOpenConns(10)\n\tdb.DB().SetConnMaxLifetime(5 * time.Minute)\n\tdb.SetLogger(&logger.GormLogger{})\n\n\tlogger.Info(\"----------------------------------- \")\n\tlogger.Info(\"*** Database Config Session created *** \")\n\tlogger.Info(\"----------------------------------- \")\n\n\tif keepAlive {\n\t\tgo makePingKeepAlive(db, host, \"config\", \"localnode\")\n\t}\n\n\treturn db\n}\n\n// getSession creates a new mongo session and panics if connection error occurs\nfunc updateVersionApplication(configDBSession *gorm.DB) bool {\n\n\tvar err error\n\tvar saveConfig = false\n\trecordApp := model.TableApplications{}\n\trecordApp.VersionApplication = getVersion()\n\trecordApp.NameApplication = getName()\n\n\trecordApp.HostApplication = viper.GetString(\"system_settings.hostname\")\n\tif recordApp.HostApplication == \"\" {\n\t\trecordApp.HostApplication, err = os.Hostname()\n\t\tif err != nil {\n\t\t\trecordApp.HostApplication = \"unknown\"\n\t\t}\n\t\tviper.Set(\"system_settings.hostname\", recordApp.HostApplication)\n\t\tsaveConfig = true\n\n\t}\n\n\trecordApp.GUID = viper.GetString(\"system_settings.uuid\")\n\tif recordApp.GUID == \"\" {\n\t\trecordApp.GUID = uuid.NewV4().String()\n\t\tviper.Set(\"system_settings.uuid\", recordApp.GUID)\n\t\tsaveConfig = true\n\t}\n\n\tif saveConfig {\n\t\terr := viper.WriteConfig()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif err := configDBSession.Debug().Set(\n\t\t\"gorm:insert_option\",\n\t\tfmt.Sprintf(\"ON CONFLICT (name,host) DO UPDATE SET version = EXCLUDED.version, guid = EXCLUDED.guid\"),\n\t).Table(\"applications\").Create(&recordApp).Error; err != nil {\n\t\tlogger.Error(\"Error by updating application table\", err)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getInfluxDBSession() service.ServiceInfluxDB {\n\n\tuser := viper.GetString(\"influxdb_config.user\")\n\tpassword := viper.GetString(\"influxdb_config.pass\")\n\thost := viper.GetString(\"influxdb_config.host\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"InfluxDB functions disabled\")\n\t\treturn service.ServiceInfluxDB{Active: false}\n\t}\n\n\turlInflux, err := url.Parse(host)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to parse influx host\")\n\t}\n\n\tconf := client.HTTPConfig{\n\t\tAddr:     urlInflux.String(),\n\t\tUsername: user,\n\t\tPassword: password,\n\t}\n\n\tinfluxClient, err := client.NewHTTPClient(conf)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to connect influx database\")\n\t}\n\n\tserviceInfluxDB := service.ServiceInfluxDB{\n\t\tInfluxClient: influxClient,\n\t\tActive:       true,\n\t}\n\n\tlogger.Info(\"----------------------------------- \")\n\tlogger.Info(\"*** Influx Database Session created *** \")\n\tlogger.Info(\"----------------------------------- \")\n\treturn serviceInfluxDB\n}\n\n// getPrometheusDBSession creates a new influxdb session and panics if connection error occurs\nfunc getPrometheusDBSession() service.ServicePrometheus {\n\n\thost := viper.GetString(\"prometheus_config.host\")\n\tuser := viper.GetString(\"prometheus_config.user\")\n\tpassword := viper.GetString(\"prometheus_config.pass\")\n\tapi := viper.GetString(\"prometheus_config.api\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"Prometheus functions disabled\")\n\t\treturn service.ServicePrometheus{Active: false}\n\t}\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tservicePrometheus := service.ServicePrometheus{\n\t\tHttpClient: httpClient,\n\t\tUser:       user,\n\t\tPassword:   password,\n\t\tHost:       host,\n\t\tApi:        api,\n\t\tActive:     true,\n\t}\n\n\tlogger.Info(\"------------------------------------ \")\n\tlogger.Info(\"**** Prometheus Session created **** \")\n\tlogger.Info(\"------------------------------------ \")\n\treturn servicePrometheus\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getRemoteDBSession() service.ServiceLoki {\n\n\tuser := viper.GetString(\"loki_config.user\")\n\tpassword := viper.GetString(\"loki_config.pass\")\n\tif viper.IsSet(\"loki_config.password\") {\n\t\tpassword = viper.GetString(\"loki_config.password\")\n\t}\n\n\thost := viper.GetString(\"loki_config.host\")\n\tapi := viper.GetString(\"loki_config.api\")\n\tparamQuery := viper.GetString(\"loki_config.param_query\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"Loki functions disabled\")\n\t\treturn service.ServiceLoki{Active: false}\n\t}\n\n\t/* if the param_query has been not defined - we use the new schema */\n\tif paramQuery == \"\" {\n\t\tparamQuery = \"query_range\"\n\t}\n\t/* force to new api*/\n\tif api == \"\" || api == \"api/prom\" {\n\t\tapi = \"loki/api/v1\"\n\t}\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tServiceLoki := service.ServiceLoki{\n\t\tHttpClient: httpClient,\n\t\tUser:       user,\n\t\tPassword:   password,\n\t\tHost:       host,\n\t\tApi:        api,\n\t\tParamQuery: paramQuery,\n\t\tActive:     true,\n\t}\n\n\tlogger.Info(\"------------------------------------ \")\n\tlogger.Info(\"**** Loki Session created **** \")\n\tlogger.Info(\"------------------------------------ \")\n\treturn ServiceLoki\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getGrafanaSession() service.ServiceGrafana {\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tServiceGrafana := service.ServiceGrafana{\n\t\tHttpClient: httpClient,\n\t\tUser:       \"admin\",\n\t\tPassword:   \"\",\n\t\tToken:      \"\",\n\t\tHost:       \"http://127.0.0.1:3000\",\n\t\tApi:        \"\",\n\t\tActive:     true,\n\t}\n\n\treturn ServiceGrafana\n}\n\nfunc readConfig() {\n\t// Getting constant values\n\tif configEnv := os.Getenv(\"WEBAPPENV\"); configEnv != \"\" {\n\t\tviper.SetConfigName(\"webapp_config_\" + configEnv)\n\t} else {\n\t\tviper.SetConfigName(\"webapp_config\")\n\t}\n\tviper.SetConfigType(\"json\")\n\n\tif configPath := os.Getenv(\"WEBAPPPATH\"); configPath != \"\" {\n\t\tviper.AddConfigPath(configPath)\n\t} else {\n\t\tviper.AddConfigPath(*appFlags.PathWebAppConfig)\n\t}\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n\tif *appFlags.WatchConfig {\n\t\tviper.OnConfigChange(func(in fsnotify.Event) {\n\t\t\tconfigureLogging()\n\t\t\tconfigureServiceObjects()\n\n\t\t})\n\t\tviper.WatchConfig()\n\t}\n}\n\nfunc applyDBDataParamToConfig(user *string, password *string, dbname *string, host *string, node *string, sslmode *string) {\n\n\tcreateString := fmt.Sprintf(\"\\r\\nHOMER - writing data to config [user=%s password=%s, dbname=%s, host=%s, node=%s, sslmode=%s]\", *user, *password, *dbname, *host, *node, *sslmode)\n\n\theputils.Colorize(heputils.ColorRed, createString)\n\n\tviper.Set(\"database_data.\"+*node+\".user\", *user)\n\tviper.Set(\"database_data.\"+*node+\".pass\", *password)\n\tviper.Set(\"database_data.\"+*node+\".name\", *dbname)\n\tviper.Set(\"database_data.\"+*node+\".host\", *host)\n\tviper.Set(\"database_data.\"+*node+\".node\", *node)\n\tviper.Set(\"database_data.\"+*node+\".sslmode\", *sslmode)\n\n\terr := viper.WriteConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n}\n\nfunc applyDBConfigParamToConfig(user *string, password *string, dbname *string, host *string, sslmode *string) {\n\n\tcreateString := fmt.Sprintf(\"\\r\\nHOMER - writing data to config [user=%s password=%s, dbname=%s, host=%s, sslmode=%s]\", *user, *password, *dbname, *host, *sslmode)\n\n\theputils.Colorize(heputils.ColorRed, createString)\n\n\tviper.Set(\"database_config.user\", *user)\n\tviper.Set(\"database_config.pass\", *password)\n\tviper.Set(\"database_config.name\", *dbname)\n\tviper.Set(\"database_config.host\", *host)\n\tviper.Set(\"database_config.sslmode\", *sslmode)\n\n\terr := viper.WriteConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n}\n\nfunc registerGetRedirect(e *echo.Echo, path string) {\n\n\tprefix := *appFlags.APIPrefix\n\n\tif viper.IsSet(\"http_settings.api_prefix\") {\n\t\tprefix = viper.GetString(\"http_settings.api_prefix\")\n\t}\n\n\te.GET(prefix+\"/dashboard/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/call/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/call/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/search/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/search/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/registration/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/registration/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"(system:login)\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/preference/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/transaction/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/search/result/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/search/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n}\n\n// middle ware handler\nfunc bodyDumpHandler(c echo.Context, reqBody, resBody []byte) {\n\n\tlogger.Debug(\"================================\")\n\n\tlogger.Debug(\"--------request body-------\")\n\tprintBody(reqBody)\n\tlogger.Info(\"---------------------------\")\n\n\tlogger.Debug(\"-------- response body --------\")\n\tprintBody(resBody)\n\tlogger.Debug(\"-------------------------------\")\n\tlogger.Debug(\"=================================\")\n}\n\n// body dump skipper\nfunc skipper(c echo.Context) bool {\n\n\tif c.Request().Method == \"POST\" {\n\t\tlogger.Debug(c.Request().URL.Path)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// private method\nfunc printBody(obj []byte) {\n\n\tlogger.Logger.WithFields(logrus.Fields{\n\t\t\"json\": string(obj),\n\t}).Info(\"Payload\")\n}\n\nfunc checkHelpVersionFlags() {\n\tif *appFlags.ShowHelpMessage {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tif *appFlags.ShowVersion {\n\t\tfmt.Printf(\"VERSION: %s\\r\\n\", getVersion())\n\t\tos.Exit(0)\n\t}\n}\n\nfunc checkAdminFlags() {\n\tif *appFlags.InitializeDB {\n\t\tinitDB()\n\t}\n\n\t/* start creating pgsql user */\n\tif *appFlags.CreateHomerUser {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.CreateNewUser(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start drop pgsql user */\n\t} else if *appFlags.DeleteHomerUser {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.DeleteNewUser(rootDb, appFlags.DatabaseHomerUser)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start creating pgsql user */\n\t} else if *appFlags.CreateConfigDB || *appFlags.CreateDataDB {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\t\tif *appFlags.CreateDataDB {\n\t\t\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerData, appFlags.DatabaseHomerUser)\n\t\t} else {\n\t\t\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerUser)\n\t\t}\n\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start creating pgsql user */\n\t} else if *appFlags.CreateHomerRole {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tdataDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseHomerData,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection to data. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer dataDb.Close()\n\n\t\tmigration.CreateHomerRole(rootDb, dataDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t} else if *appFlags.RevokeHomerRole {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.RevokeHomerRole(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start drop pgsql user */\n\t\t/* start drop pgsql user */\n\t} else if *appFlags.ShowDbUsers {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t}\n}\n\nfunc initDB() {\n\trootDb, err := migration.GetDataRootDBSession(\n\t\tappFlags.DatabaseRootUser,\n\t\tappFlags.DatabaseRootPassword,\n\t\tappFlags.DatabaseRootDB,\n\t\tappFlags.DatabaseHost,\n\t\tappFlags.DatabasePort,\n\t\tappFlags.DatabaseSSLMode)\n\n\tif err != nil {\n\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\tpanic(err)\n\t}\n\n\tdefer rootDb.Close()\n\n\tmigration.CreateNewUser(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword)\n\tmigration.ShowUsers(rootDb)\n\n\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerData, appFlags.DatabaseHomerUser)\n\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerUser)\n\n\tdatabaseDb, err := migration.GetDataRootDBSession(\n\t\tappFlags.DatabaseRootUser,\n\t\tappFlags.DatabaseRootPassword,\n\t\tappFlags.DatabaseHomerData,\n\t\tappFlags.DatabaseHost,\n\t\tappFlags.DatabasePort,\n\t\tappFlags.DatabaseSSLMode)\n\n\tif err != nil {\n\t\tlogger.Error(\"Couldn't establish connection to databaseDb. Please be sure you can have correct password\", err)\n\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\tpanic(err)\n\t}\n\n\tdefer databaseDb.Close()\n\n\tmigration.CreateHomerRole(rootDb, databaseDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\n\tservicesObject.configDBSession = getConfigDBSession()\n\tdefer servicesObject.configDBSession.Close()\n\tnameHomerConfig := viper.GetString(\"database_config.name\")\n\n\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpgradeTableConfigDB, true)\n\tmigration.PopulateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.ForcePopulate, appFlags.TablesPopulate, *appFlags.ForcePasswordDB)\n\n\tos.Exit(0)\n}\n\n// ServerHeader middleware adds a `Server` header to the response.\nfunc GrafanaHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tif strings.HasPrefix(c.Request().RequestURI, config.Setting.GRAFANA_SETTINGS.Path) {\n\t\t\tc.Request().Header.Add(\"Authorization\", \"Bearer \"+config.Setting.GRAFANA_SETTINGS.AuthKey)\n\t\t}\n\t\treturn next(c)\n\t}\n}\n\n// make a ping keep alive\nfunc makePingKeepAlive(db *gorm.DB, host string, typeData string, node string) {\n\n\tfor {\n\n\t\tpingErr := db.DB().Ping()\n\t\tif pingErr != nil {\n\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make ping to [Host: %s], Type: [%s], Node: [%s]  Error: [%v]\",\n\t\t\t\thost, typeData, node, pingErr))\n\t\t} else {\n\t\t\tlogger.Debug(fmt.Printf(\"Successful ping: %s, Type: %s, Node: %s\", host, typeData, node))\n\t\t}\n\n\t\ttime.Sleep(time.Duration(60) * time.Second)\n\t}\n}\n\nfunc ShowCurrentConfigToConsole() {\n\n\theputils.Colorize(heputils.ColorRed, \"\\r\\nMAIN_SETTINGS:\\r\\n\")\n\n\tspew.Dump(config.Setting)\n\n\theputils.Colorize(heputils.ColorRed, \"\\r\\nLDAP:\\r\\n\")\n\n\tspew.Dump(ldapClient)\n\n}\n\nfunc initHttpClient() {\n\n\tconfig.Setting.MAIN_SETTINGS.SubscribeHttpClient = &http.Client{Timeout: time.Duration(config.Setting.MAIN_SETTINGS.TimeoutHttpClient) * time.Second}\n}\n", "package main\n\n//VERSION\nvar VERSION_APPLICATION = \"1.4.27\"\n\n//NAME\nvar NAME_APPLICATION = \"homer-app\"\n\nfunc getVersion() string {\n\treturn VERSION_APPLICATION\n}\n\nfunc getName() string {\n\treturn NAME_APPLICATION\n}\n"], "fixing_code": ["package auth\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt\"\n\t\"github.com/sipcapture/homer-app/config\"\n\t\"github.com/sipcapture/homer-app/model\"\n\t\"github.com/sipcapture/homer-app/utils/logger\"\n)\n\n// jwt token claims which contains info regarding user\ntype JwtUserClaim struct {\n\tUserName        string `json:\"username\"`\n\tUserAdmin       bool   `json:\"useradmin\"`\n\tUserGroup       string `json:\"usergroup\"`\n\tExternalAuth    bool   `json:\"externalauth\"`\n\tExternalProfile string `json:\"externaltype\"`\n\tDisplayName     string `json:\"displayname\"`\n\tAvatar          string `json:\"avatar\"`\n\tjwt.StandardClaims\n}\n\nfunc Token(user model.TableUser) (string, error) {\n\n\ttNow := time.Now()\n\ttUTC := tNow\n\n\tnewTUTC := tUTC.Add(time.Duration(TokenExpiryTime) * time.Minute)\n\n\t// Set custom claims\n\tclaims := &JwtUserClaim{\n\t\tuser.UserName,\n\t\tuser.IsAdmin,\n\t\tuser.UserGroup,\n\t\tuser.ExternalAuth,\n\t\tuser.ExternalProfile,\n\t\tuser.FirstName + \" \" + user.LastName,\n\t\tuser.Avatar,\n\t\tjwt.StandardClaims{\n\t\t\tExpiresAt: newTUTC.Unix(),\n\t\t},\n\t}\n\n\tlogger.Debug(\"Current time : \", tNow)\n\tlogger.Debug(\"Local time : \", tUTC)\n\tlogger.Debug(\"Expire Local time : \", newTUTC)\n\n\t// Create token with claims\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\n\t// Generate encoded token and send it as response.\n\tt, err := token.SignedString([]byte(config.Setting.AUTH_SETTINGS.JwtSecret))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn t, nil\n}\n", "package auth\n\n/* our expire time */\nvar TokenExpiryTime = 1200\n\n// token header\nconst TokenHeader = \"Auth-Token\"\n", "package config\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/sipcapture/homer-app/model\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar Setting HomerSettingServer\n\nvar OAuth2TokenMap map[string]model.OAuth2MapToken\n\ntype HomerSettingServer struct {\n\tMAIN_SETTINGS struct {\n\t\tIsolateQuery        string `default:\"\"`\n\t\tIsolateGroup        string `default:\"\"`\n\t\tUseCaptureIDInAlias bool   `default:\"false\"`\n\t\tDefaultAuth         string `default:\"internal\"`\n\t\tEnableGravatar      bool   `default:\"false\"`\n\t\tGravatarUrl         string `default:\"https://www.gravatar.com/avatar/%s.jpg\"`\n\t\tOAuth2Config        oauth2.Config\n\t\tGlobalToken         *oauth2.Token\n\t\tUserGroups          []string `default:\"[admin,user,support]\"`\n\t\tSubscribeHttpClient *http.Client\n\t\tTimeoutHttpClient   uint32 `default:\"10\"`\n\t}\n\n\tGRAFANA_SETTINGS struct {\n\t\tURL      string `default:\"http://grafana/\"`\n\t\tAuthKey  string `default:\"\"`\n\t\tUser     string `default:\"\"`\n\t\tPassword string `default:\"\"`\n\t\tPath     string `default:\"/grafana\"`\n\t\tEnable   bool   `default:\"false\"`\n\t}\n\n\tTRANSACTION_SETTINGS struct {\n\t\tDedupModel        string `default:\"message-ip-pair\"`\n\t\tGlobalDeduplicate bool   `default:\"false\"`\n\t}\n\n\tDASHBOARD_SETTINGS struct {\n\t\tExternalHomeDashboard string `default:\"\"`\n\t}\n\n\tAUTH_SETTINGS struct {\n\t\tJwtSecret string `default:\"\"`\n\t}\n\n\tOAUTH2_SETTINGS struct {\n\t\tEnable               bool     `default:\"false\"`\n\t\tClientID             string   `default:\"1234565\"`\n\t\tClientSecret         string   `default:\"FAKE\"`\n\t\tProjectID            string   `default:\"Homer Oauth2\"`\n\t\tAuthUri              string   `default:\"https://accounts.google.com/o/oauth2/auth\"`\n\t\tTokenUri             string   `default:\"https://oauth2.googleapis.com/token\"`\n\t\tAuthProviderCert     string   `default:\"https://www.googleapis.com/oauth2/v1/certs\"`\n\t\tRedirectUri          string   `default:\"http://localhost:80/api/v3/oauth2/auth\"`\n\t\tProfileURL           string   `default:\"https://www.googleapis.com/oauth2/v1/userinfo\"`\n\t\tMethod               string   `default:\"GET\"`\n\t\tUserToken            string   `default:\"checkRandom\"`\n\t\tServiceProviderName  string   `default:\"google\"`\n\t\tServiceProviderImage string   `default:\"\"`\n\t\tStateValue           string   `default:\"jkwh027yasj\"`\n\t\tUrlToServiceRedirect string   `default:\"/api/v3/oauth2/redirect\"`\n\t\tScope                []string `default:\"[email,openid,profile]\"`\n\t\tEnableGravatar       bool     `default:\"false\"`\n\t\tAuthStyle            int      `default:\"0\"`\n\t\tGravatarUrl          string   `default:\"https://www.gravatar.com/avatar/%s.jpg\"`\n\t\tExpireSSOToken       uint32   `default:\"5\"`\n\t}\n\n\tLOG_SETTINGS struct {\n\t\tEnable        bool   `default:\"true\"`\n\t\tMaxAgeDays    uint32 `default:\"7\"`\n\t\tRotationHours uint32 `default:\"24\"`\n\t\tPath          string `default:\"/usr/local/homer/log\"`\n\t\tLevel         string `default:\"error\"`\n\t\tName          string `default:\"homer-app.log\"`\n\t\tStdout        bool   `default:\"false\"`\n\t\tJson          bool   `default:\"true\"`\n\t\tSysLogLevel   string `default:\"LOG_INFO\"`\n\t\tSysLog        bool   `default:\"false\"`\n\t\tSyslogUri     string `default:\"\"`\n\t}\n\n\tSWAGGER struct {\n\t\tEnable  bool   `default:\"true\"`\n\t\tApiJson string `default:\"/usr/local/homer/etc/swagger.json\"`\n\t\tApiHost string `default:\"127.0.0.1:9080\"`\n\t}\n\n\tDECODER_SHARK struct {\n\t\tBin        string   `default:\"/usr/local/bin/tshark\"`\n\t\tParam      string   `default:\"\"`\n\t\tProtocols  []string `default:\"\"`\n\t\tUID        uint32   `default:\"0\"`\n\t\tGID        uint32   `default:\"0\"`\n\t\tImportNode string   `default:\"\"`\n\t\tEnable     bool     `default:\"false\"`\n\t}\n}\n", "{\n  \"database_data\": {\n    \"LocalNode\": {\n      \"help\": \"Settings for PGSQL Database (data)\",\n      \"node\": \"LocalNode\",\n      \"user\": \"homer_user\",\n      \"pass\": \"homer_password\",\n      \"name\": \"homer_data\",\n      \"keepalive\": true,\n      \"host\": \"127.0.0.1\"\n    }\n  },\n  \"hep_relay\": {\n    \"help\": \"UDP socket to send HEP data on\",\n    \"host\": \"127.0.0.1\",\n    \"port\": 9060\n  },\n  \"database_config\": {\n    \"help\": \"Settings for PGSQL Database (settings)\",\n    \"node\": \"LocalConfig\",\n    \"user\": \"homer_user\",\n    \"pass\": \"homer_password\",\n    \"name\": \"homer_config\",\n    \"keepalive\": true,\n    \"host\": \"localhost\"\n  },\n  \"influxdb_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for InfluxDB Database (optional)\",\n    \"user\": \"influx_user\",\n    \"pass\": \"influx_password\",\n    \"name\": \"homer_config\",\n    \"host\": \"http://127.0.0.1:8086\",\n    \"database\": \"homer\",\n    \"policy\": \"autogen\"\n  },\n  \"prometheus_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for Prometheus Database (optional)\",\n    \"user\": \"admin\",\n    \"pass\": \"admin\",\n    \"host\": \"http://127.0.0.1:9090\",\n    \"api\": \"api/v1\"\n  },\n  \"swagger\": {\n    \"enable\": true,\n    \"api_json\": \"/usr/local/homer/etc/swagger.json\",\n    \"api_host\": \"127.0.0.1:9080\"\n  },\n  \"loki_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for LOKI Database (optional)\",\n    \"user\": \"admin\",\n    \"pass\": \"admin\",\n    \"host\": \"http://127.0.0.1:3100\",\n    \"api\": \"loki/api/v1\",\n    \"param_query\": \"query_range\"\n  },\n  \"grafana_config\": {\n    \"enable\": true,\n    \"help\": \"Settings for Grafana\",\n    \"host\": \"http://127.0.0.1:3000\",\n    \"path\": \"/grafana\",\n    \"token\": \"\"\n  },\n  \"http_settings\": {\n    \"help\": \"Settings for the HOMER Webapp Server. If you have gzip_static = false, please be sure that your dist directory has uncompressed .js files\",\n    \"host\": \"0.0.0.0\",\n    \"port\": 9080,\n    \"root\": \"/usr/local/homer/dist\",\n    \"gzip\": true,\n    \"gzip_static\": true,\n    \"debug\": false\n  },\n  \"transaction_settings\": {\n    \"deduplicate\": {\n        \"global\": false\n    }\n  },\n  \"api_settings\": {\n    \"add_captid_to_resolve\": false\n  },\n  \"https_settings\": {\n    \"help\": \"SSL settings for homer-app\",\n    \"enable\": false,\n    \"host\": \"0.0.0.0\",\n    \"port\": 443,\n    \"cert\": \"/usr/local/homer/tls/cert.pem\",\n    \"key\": \"/usr/local/homer/tls/key.pem\"\n  },\n  \"system_settings\": {\n    \"help\": \"Settings for HOMER logs\",\n    \"logpath\": \"/usr/local/homer/log\",\n    \"logname\": \"homer-app.log\",\n    \"_loglevels\": \"can be: fatal, error, warn, info, debug, trace\",\n    \"loglevel\": \"error\",\n    \"logstdout\": false\n  },\n  \"dashboard_settings\": {\n    \"_comment\": \"Here you can define a customs dashboards home\",\n    \"dashboard_home\": \"/usr/local/homer/etc/dashboard_home.json\"\n  },\n  \"auth_settings\": {\n    \"_comment\": \"The type param can be internal, ldap, http_auth\",\n    \"type\": \"internal\",\n    \"jwt_secret\": \"167f0db2-f83e-4baa-9736-d56064a5b415\",\n    \"gravatar\": false,\n    \"gravatar_url\": \"https://www.gravatar.com/avatar/%s.jpg\",\n    \"token_expire\": 1200,\n    \"user_groups\": [\"admin\", \"user\", \"support\"]\n  },\n  \"ldap_config\": {\n    \"base\": \"dc=example,dc=com\",\n    \"host\": \"ldap.example.com\",\n    \"port\": 389,\n    \"usessl\": false,\n    \"skiptls\": true,\n    \"binddn\": \"uid=readonlysuer,ou=People,dc=example,dc=com\",\n    \"bindpassword\": \"readonlypassword\",\n    \"userfilter\": \"(uid=%s)\",\n    \"groupfilter\": \"(memberUid=%s)\",\n    \"group_attributes\": [\n      \"cn\",\n      \"memberOf\",\n      \"GroupAttribute\",\n      \"distinguishedName\",\n      \"dn\",\n      \"member\"\n    ],\n    \"admingroup\": \"admin\",\n    \"adminmode\": true,\n    \"usergroup\": \"HOMER_user\",\n    \"usermode\": true,\n    \"attributes\": [\"dn\", \"givenName\", \"sn\", \"mail\", \"uid\"],\n    \"skipverify\": true,\n    \"anonymous\": false,\n    \"userdn\": \"uid=%s,ou=People,dc=example,dc=com\"\n  },\n  \"http_auth\": {\n    \"url\": \"http://localhost:1323\",\n    \"skipverify\": true\n  },\n  \"oauth2\": {\n    \"enable\": false,\n    \"client_id\": \"1234565\",\n    \"client_secret\": \"FAKE\",\n    \"project_id\": \"Homer OAuth\",\n    \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n    \"token_uri\": \"https://oauth2.googleapis.com/token\",\n    \"auth_provider_x509_cert_url\":  \"https://www.googleapis.com/oauth2/v1/certs\",\n    \"redirect_uri\": \"http://localhost:80/api/v3/oauth2/auth\",\n    \"service_redirect\": \"/api/v3/oauth2/redirect\",\n    \"profile_url\": \"https://www.googleapis.com/oauth2/v1/userinfo\",\n    \"provider_name\": \"google\",\n    \"scope\": [\"email\", \"openid\", \"profile\"],\n    \"gravatar\": false,\n    \"gravatar_url\": \"https://www.gravatar.com/avatar/%s.jpg\",\n    \"provider_image\": \"\"\n  },\n  \"decoder_shark\": {\n    \"_comment\": \"Here you can do packet decoding using tshark application. Please define uid, gid if you run the app under root\",\n    \"active\": false,\n    \"bin\": \"/usr/bin/tshark\",\n    \"protocols\": [\"1_call\", \"1_registration\", \"1_default\"]\n  }\n}\n", "// Homer-App\n//\n// Homer-App User interface for WEB AI\n//\n//     Schemes: http, https\n//     Host: localhost:9080\n//     BasePath: /api/v3\n//     Version: 1.1.2\n//     License: AGPL https://www.gnu.org/licenses/agpl-3.0.en.html\n//\t   Copyright: QXIP B.V. 2019-2020\n//\n//     Consumes:\n//     - application/json\n//\n//     Produces:\n//     - application/json\n//     Security:\n//     - bearer:\n//\n//     SecurityDefinitions:\n//     bearer:\n//          type: apiKey\n//          name: Authorization\n//          in: header\n//\n// swagger:meta\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/davecgh/go-spew/spew\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/oauth2\"\n\n\t_ \"github.com/influxdata/influxdb1-client\" // this is important because of the bug in go mod\n\tclient \"github.com/influxdata/influxdb1-client/v2\"\n\t\"github.com/jinzhu/gorm\"\n\t_ \"github.com/jinzhu/gorm/dialects/postgres\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/mcuadros/go-defaults\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/sipcapture/homer-app/auth\"\n\t\"github.com/sipcapture/homer-app/config\"\n\t\"github.com/sipcapture/homer-app/data/service\"\n\t\"github.com/sipcapture/homer-app/migration\"\n\t\"github.com/sipcapture/homer-app/migration/jsonschema\"\n\t\"github.com/sipcapture/homer-app/model\"\n\thttpresponse \"github.com/sipcapture/homer-app/network/response\"\n\tapirouterv1 \"github.com/sipcapture/homer-app/router/v1\"\n\t\"github.com/sipcapture/homer-app/system/webmessages\"\n\t\"github.com/sipcapture/homer-app/utils/heputils\"\n\t\"github.com/sipcapture/homer-app/utils/httpauth\"\n\t\"github.com/sipcapture/homer-app/utils/ldap\"\n\t\"github.com/sipcapture/homer-app/utils/logger\"\n\t\"github.com/spf13/viper\"\n\t\"gopkg.in/go-playground/validator.v9\"\n)\n\n//CustomValidator function\ntype CustomValidator struct {\n\tvalidator *validator.Validate\n}\n\n// validate function\nfunc (cv *CustomValidator) Validate(i interface{}) error {\n\treturn cv.validator.Struct(i)\n}\n\nvar appFlags CommandLineFlags\nvar ldapClient ldap.LDAPClient\nvar httpAuth httpauth.Client\n\ntype arrayFlags []string\n\nfunc (i *arrayFlags) String() string {\n\treturn \"my string representation\"\n}\n\nfunc (i *arrayFlags) Set(value string) error {\n\t*i = append(*i, value)\n\treturn nil\n}\n\n//params for Flags\ntype CommandLineFlags struct {\n\tInitializeDB              *bool      `json:\"initialize_db\"`\n\tCreateConfigDB            *bool      `json:\"create_config_db\"`\n\tCreateDataDB              *bool      `json:\"create_data_db\"`\n\tCreateTableConfigDB       *bool      `json:\"create_table_config\"`\n\tUpgradeTableConfigDB      *bool      `json:\"upgrade_table_config\"`\n\tPopulateTableConfigDB     *bool      `json:\"populate_table_config\"`\n\tCreateHomerUser           *bool      `json:\"create_homer_user\"`\n\tDeleteHomerUser           *bool      `json:\"delete_homer_user\"`\n\tShowVersion               *bool      `json:\"version\"`\n\tForcePopulate             *bool      `json:\"force_insert\"`\n\tForcePasswordDB           *string    `json:\"force_password\"`\n\tUpdateUIUser              *string    `json:\"update_ui_user\"`\n\tUpdateUIPassword          *string    `json:\"update_ui_password\"`\n\tTablesPopulate            arrayFlags `json:\"force_tables\"`\n\tRevokeHomerRole           *bool      `json:\"revoke_homer_role\"`\n\tCreateHomerRole           *bool      `json:\"create_homer_role\"`\n\tSaveHomerDbConfigToConfig *bool      `json:\"save_db_config_to_config\"`\n\tSaveHomerDbDataToConfig   *bool      `json:\"save_db_data_to_config\"`\n\tShowDbUsers               *bool      `json:\"show_db_users\"`\n\tShowHelpMessage           *bool      `json:\"help\"`\n\tDatabaseRootUser          *string    `json:\"root_user\"`\n\tDatabaseRootPassword      *string    `json:\"root_password\"`\n\tDatabaseHost              *string    `json:\"root_host\"`\n\tDatabasePort              *int       `json:\"root_port\"`\n\tDatabaseRootDB            *string    `json:\"root_db\"`\n\tDatabaseSSLMode           *string    `json:\"sslmode_db\"`\n\tDatabaseHomerNode         *string    `json:\"homer_node\"`\n\tDatabaseHomerUser         *string    `json:\"homer_user\"`\n\tDatabaseHomerPassword     *string    `json:\"homer_password\"`\n\tDatabaseHomerConfig       *string    `json:\"db_homer_config\"`\n\tDatabaseHomerData         *string    `json:\"db_homer_data\"`\n\tPathWebAppConfig          *string    `json:\"path_webapp\"`\n\tLogPathWebApp             *string    `json:\"path_log_webapp\"`\n\tLogName                   *string    `json:\"log_name_webapp\"`\n\tAPIPrefix                 *string    `json:\"api_prefix\"`\n\tWatchConfig               *bool      `json:\"watch_config\"`\n\tShowCurrentConfig         *bool      `json:\"show_current_config\"`\n\tGenerateJwtSecret         *bool      `json:\"generate_jwt_secret\"`\n}\n\n//params for  Services\ntype ServicesObject struct {\n\tconfigDBSession   *gorm.DB\n\tdataDBSession     map[string]*gorm.DB\n\tdatabaseNodeMap   []model.DatabasesMap\n\tinfluxDBSession   service.ServiceInfluxDB\n\tservicePrometheus service.ServicePrometheus\n\tserviceLoki       service.ServiceLoki\n\tserviceGrafana    service.ServiceGrafana\n\texternalDecoder   service.ExternalDecoder\n}\n\nvar servicesObject ServicesObject\n\n/* init flags */\nfunc initFlags() {\n\tappFlags.InitializeDB = flag.Bool(\"initialize_db\", false, \"initialize the database and create all tables\")\n\tappFlags.CreateConfigDB = flag.Bool(\"create-config-db\", false, \"create config db\")\n\tappFlags.CreateDataDB = flag.Bool(\"create-data-db\", false, \"create data db\")\n\tappFlags.CreateTableConfigDB = flag.Bool(\"create-table-db-config\", false, \"create table in db config\")\n\tappFlags.UpgradeTableConfigDB = flag.Bool(\"upgrade-table-db-config\", false, \"upgrade table in db config\")\n\n\tappFlags.PopulateTableConfigDB = flag.Bool(\"populate-table-db-config\", false, \"populate table in db config\")\n\n\tappFlags.CreateHomerUser = flag.Bool(\"create-homer-user\", false, \"create homer user\")\n\tappFlags.DeleteHomerUser = flag.Bool(\"delete-homer-user\", false, \"delete homer user\")\n\tappFlags.ShowDbUsers = flag.Bool(\"show-db-users\", false, \"show db users\")\n\n\tappFlags.ForcePopulate = flag.Bool(\"force-populate\", false, \"force populate all records to config\")\n\tappFlags.ForcePasswordDB = flag.String(\"force-password\", \"\", \"force password for AWS setups\")\n\n\tappFlags.UpdateUIUser = flag.String(\"update-ui-user\", \"\", \"update user ui\")\n\tappFlags.UpdateUIPassword = flag.String(\"update-ui-password\", \"\", \"update password for user\")\n\n\tflag.Var(&appFlags.TablesPopulate, \"populate-table\", \"force to populate only current tables\")\n\n\tappFlags.ShowVersion = flag.Bool(\"version\", false, \"show version\")\n\n\tappFlags.CreateHomerRole = flag.Bool(\"create-homer-role\", false, \"create homer role\")\n\tappFlags.RevokeHomerRole = flag.Bool(\"revoke-homer-role\", false, \"revoke homer user\")\n\n\tappFlags.SaveHomerDbConfigToConfig = flag.Bool(\"save-homer-db-config-settings\", false, \"save homer db-config to configs\")\n\tappFlags.SaveHomerDbDataToConfig = flag.Bool(\"save-homer-db-data-settings\", false, \"save homer db-data settings to configs\")\n\n\tappFlags.ShowHelpMessage = flag.Bool(\"help\", false, \"show help\")\n\tappFlags.DatabaseRootUser = flag.String(\"database-root-user\", \"postgres\", \"database-root-user\")\n\tappFlags.DatabaseRootPassword = flag.String(\"database-root-password\", \"\", \"database-root-password\")\n\tappFlags.DatabaseHost = flag.String(\"database-host\", \"localhost\", \"database-host\")\n\tappFlags.DatabasePort = flag.Int(\"database-port\", 5432, \"database-port\")\n\tappFlags.DatabaseSSLMode = flag.String(\"database-ssl-mode\", \"disable\", \"database-ssl-mode\")\n\tappFlags.DatabaseRootDB = flag.String(\"database-root-db\", \"postgres\", \"database-root-db\")\n\tappFlags.DatabaseHomerNode = flag.String(\"database-homer-node\", \"localnode\", \"database-homer-node\")\n\tappFlags.DatabaseHomerUser = flag.String(\"database-homer-user\", \"homer_user\", \"database-homer-user\")\n\tappFlags.DatabaseHomerPassword = flag.String(\"database-homer-password\", \"homer_password\", \"database-homer-password\")\n\tappFlags.DatabaseHomerConfig = flag.String(\"database-homer-config\", \"homer_config\", \"database-homer-config\")\n\tappFlags.DatabaseHomerData = flag.String(\"database-homer-data\", \"homer_data\", \"database-homer-data\")\n\tappFlags.PathWebAppConfig = flag.String(\"webapp-config-path\", \"/usr/local/homer/etc\", \"the path to the webapp config file\")\n\tappFlags.LogName = flag.String(\"webapp-log-name\", \"\", \"the name prefix of the log file.\")\n\tappFlags.LogPathWebApp = flag.String(\"webapp-log-path\", \"\", \"the path for the log file.\")\n\tappFlags.APIPrefix = flag.String(\"webapp-api-prefix\", \"\", \"API prefix.\")\n\tappFlags.WatchConfig = flag.Bool(\"watch-config\", false, \"Watch the configuration for changes\")\n\tappFlags.ShowCurrentConfig = flag.Bool(\"show-current-config\", false, \"print out the current config and exit\")\n\n\t//Jwt\n\tappFlags.GenerateJwtSecret = flag.Bool(\"generate-jwt-secret\", false, \"generate jwt secret\")\n\n\tflag.Parse()\n}\n\nfunc main() {\n\n\t//init flags\n\tinitFlags()\n\n\t/* first check admin flags */\n\tcheckHelpVersionFlags()\n\n\tcfg := new(config.HomerSettingServer)\n\tdefaults.SetDefaults(cfg) //<-- This set the defaults values\n\tconfig.Setting = *cfg\n\n\t// read system configurations and expose through viper\n\treadConfig()\n\n\tconfigureLogging()\n\n\t/* first check admin flags */\n\tcheckAdminFlags()\n\n\t/* now check if we do write to config */\n\tif *appFlags.SaveHomerDbConfigToConfig {\n\t\tapplyDBConfigParamToConfig(appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword,\n\t\t\tappFlags.DatabaseHomerConfig, appFlags.DatabaseHost, appFlags.DatabaseSSLMode)\n\t\tos.Exit(0)\n\t} else if *appFlags.SaveHomerDbDataToConfig {\n\t\tapplyDBDataParamToConfig(appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword, appFlags.DatabaseHomerData,\n\t\t\tappFlags.DatabaseHost, appFlags.DatabaseHomerNode, appFlags.DatabaseSSLMode)\n\t\tos.Exit(0)\n\t}\n\n\tservicesObject.configDBSession = getConfigDBSession()\n\tdefer servicesObject.configDBSession.Close()\n\tnameHomerConfig := viper.GetString(\"database_config.name\")\n\n\tif *appFlags.CreateTableConfigDB || *appFlags.UpgradeTableConfigDB {\n\t\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpgradeTableConfigDB, true)\n\t\tos.Exit(0)\n\t} else if *appFlags.PopulateTableConfigDB {\n\t\tmigration.PopulateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.ForcePopulate, appFlags.TablesPopulate,\n\t\t\t*appFlags.ForcePasswordDB)\n\t\tos.Exit(0)\n\t}\n\n\tif *appFlags.UpdateUIUser != \"\" && *appFlags.UpdateUIPassword != \"\" {\n\t\tlogger.Info(fmt.Sprintf(\"Updating password for user: [%s]\\n\", *appFlags.UpdateUIUser))\n\t\tmigration.UpdateHomerUser(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpdateUIUser, *appFlags.UpdateUIPassword)\n\n\t\tos.Exit(0)\n\t}\n\n\tif *appFlags.GenerateJwtSecret {\n\t\tlogger.Info(\"Generating jwt secret...\")\n\t\tconfig.Setting.AUTH_SETTINGS.JwtSecret = uuid.NewV4().String()\n\t\tviper.Set(\"auth_settings.jwt_secret\", config.Setting.AUTH_SETTINGS.JwtSecret)\n\t\terr := viper.WriteConfig()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\t}\n\n\t\tos.Exit(0)\n\t}\n\n\t//http client\n\tinitHttpClient()\n\n\tconfigureServiceObjects()\n\n\t/* force to upgrade */\n\tif nameHomerConfig := viper.GetString(\"database_config.name\"); nameHomerConfig != \"\" {\n\t\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, true, false)\n\t}\n\n\t// update version\n\tupdateVersionApplication(servicesObject.configDBSession)\n\n\tif *appFlags.ShowCurrentConfig {\n\t\tShowCurrentConfigToConsole()\n\t\tos.Exit(0)\n\t}\n\n\t// configure to serve WebServices\n\tconfigureAsHTTPServer()\n\n}\n\nfunc configureLogging() {\n\n\t/* OLD LOG */\n\tif viper.IsSet(\"system_settings.logpath\") {\n\t\tconfig.Setting.LOG_SETTINGS.Path = viper.GetString(\"system_settings.logpath\")\n\t}\n\tif viper.IsSet(\"system_settings.logname\") {\n\t\tconfig.Setting.LOG_SETTINGS.Name = viper.GetString(\"system_settings.logname\")\n\t}\n\tif viper.IsSet(\"system_settings.loglevel\") {\n\t\tconfig.Setting.LOG_SETTINGS.Level = viper.GetString(\"system_settings.loglevel\")\n\t}\n\tif viper.IsSet(\"system_settings.logstdout\") {\n\t\tconfig.Setting.LOG_SETTINGS.Stdout = viper.GetBool(\"system_settings.logstdout\")\n\t}\n\tif viper.IsSet(\"system_settings.logjson\") {\n\t\tconfig.Setting.LOG_SETTINGS.Json = viper.GetBool(\"system_settings.logjson\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog\") {\n\t\tconfig.Setting.LOG_SETTINGS.SysLog = viper.GetBool(\"system_settings.syslog\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog_level\") {\n\t\tconfig.Setting.LOG_SETTINGS.SysLogLevel = viper.GetString(\"system_settings.syslog_level\")\n\t}\n\tif viper.IsSet(\"system_settings.syslog_uri\") {\n\t\tconfig.Setting.LOG_SETTINGS.SyslogUri = viper.GetString(\"system_settings.syslog_uri\")\n\t}\n\n\tif *appFlags.LogPathWebApp != \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Path = *appFlags.LogPathWebApp\n\t} else if config.Setting.LOG_SETTINGS.Path == \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Path = \"log\"\n\t}\n\n\tif *appFlags.LogName != \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Name = *appFlags.LogName\n\t} else if config.Setting.LOG_SETTINGS.Name == \"\" {\n\t\tconfig.Setting.LOG_SETTINGS.Name = \"webapp.log\"\n\t}\n\t// initialize logger\n\tlogger.InitLogger()\n}\n\nfunc configureServiceObjects() {\n\t// configure new db session\n\tservicesObject.dataDBSession, servicesObject.databaseNodeMap = getDataDBSession()\n\t/* for val := range servicesObject.dataDBSession {\n\t\tdefer servicesObject.dataDBSession[val].Close()\n\t}\n\t*/\n\n\t// configure new influx db session\n\tservicesObject.influxDBSession = getInfluxDBSession()\n\t/*if servicesObject.influxDBSession.Active {\n\t\tdefer servicesObject.influxDBSession.InfluxClient.Close()\n\t}\n\t*/\n\n\t// configure new influx db session\n\tservicesObject.servicePrometheus = getPrometheusDBSession()\n\t//defer prometheusService.Close()\n\n\tservicesObject.serviceLoki = getRemoteDBSession()\n\t//defer httpClient.CloseIdleConnections()\n\n\tservicesObject.serviceGrafana = getGrafanaSession()\n\n\t/***********************************/\n\tconfig.Setting.MAIN_SETTINGS.IsolateQuery = viper.GetString(\"group_settings.isolate_query\")\n\tconfig.Setting.MAIN_SETTINGS.IsolateGroup = viper.GetString(\"group_settings.isolate_group\")\n\n\t/***********************************/\n\tif viper.IsSet(\"transaction_settings.deduplicate\") {\n\n\t\tif viper.IsSet(\"transaction_settings.deduplicate.model\") {\n\t\t\tconfig.Setting.TRANSACTION_SETTINGS.DedupModel = viper.GetString(\"transaction_settings.deduplicate.model\")\n\t\t}\n\n\t\tif viper.IsSet(\"transaction_settings.deduplicate.global\") {\n\t\t\tconfig.Setting.TRANSACTION_SETTINGS.GlobalDeduplicate = viper.GetBool(\"transaction_settings.deduplicate.global\")\n\t\t}\n\t}\n\n\t/* CaptID alias */\n\tif viper.IsSet(\"api_settings.add_captid_to_resolve\") {\n\t\tconfig.Setting.MAIN_SETTINGS.UseCaptureIDInAlias = viper.GetBool(\"api_settings.add_captid_to_resolve\")\n\t}\n\n\t/* init map */\n\tconfig.OAuth2TokenMap = make(map[string]model.OAuth2MapToken)\n\n\t/* oauth2 */\n\tif viper.IsSet(\"oauth2.enable\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Enable = viper.GetBool(\"oauth2.enable\")\n\t}\n\tif viper.IsSet(\"oauth2.client_id\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ClientID = viper.GetString(\"oauth2.client_id\")\n\t}\n\tif viper.IsSet(\"oauth2.client_secret\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ClientSecret = viper.GetString(\"oauth2.client_secret\")\n\t}\n\tif viper.IsSet(\"oauth2.project_id\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ProjectID = viper.GetString(\"oauth2.project_id\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthUri = viper.GetString(\"oauth2.auth_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.token_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.TokenUri = viper.GetString(\"oauth2.token_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_provider_x509_cert_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthProviderCert = viper.GetString(\"oauth2.auth_provider_x509_cert_url\")\n\t}\n\tif viper.IsSet(\"oauth2.redirect_uri\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.RedirectUri = viper.GetString(\"oauth2.redirect_uri\")\n\t}\n\tif viper.IsSet(\"oauth2.provider_name\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ServiceProviderName = viper.GetString(\"oauth2.provider_name\")\n\t}\n\tif viper.IsSet(\"oauth2.provider_image\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ServiceProviderImage = viper.GetString(\"oauth2.provider_image\")\n\t}\n\tif viper.IsSet(\"oauth2.service_redirect\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.UrlToServiceRedirect = viper.GetString(\"oauth2.service_redirect\")\n\t}\n\tif viper.IsSet(\"oauth2.scope\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Scope = viper.GetStringSlice(\"oauth2.scope\")\n\t}\n\tif viper.IsSet(\"oauth2.state_value\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.StateValue = viper.GetString(\"oauth2.state_value\")\n\t}\n\tif viper.IsSet(\"oauth2.expire_sso\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ExpireSSOToken = viper.GetUint32(\"oauth2.expire_sso\")\n\t}\n\tif viper.IsSet(\"oauth2.profile_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.ProfileURL = viper.GetString(\"oauth2.profile_url\")\n\t}\n\tif viper.IsSet(\"oauth2.auth_style\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.AuthStyle = viper.GetInt(\"oauth2.auth_style\")\n\t}\n\n\tif viper.IsSet(\"oauth2.method\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.Method = viper.GetString(\"oauth2.method\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"oauth2.gravatar\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.EnableGravatar = viper.GetBool(\"oauth2.gravatar\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"oauth2.gravatar_url\") {\n\t\tconfig.Setting.OAUTH2_SETTINGS.GravatarUrl = viper.GetString(\"oauth2.gravatar_url\")\n\t}\n\t/*********** DASHBOARD *******************/\n\tif viper.IsSet(\"dashboard_settings.dashboard_home\") {\n\t\tconfig.Setting.DASHBOARD_SETTINGS.ExternalHomeDashboard = viper.GetString(\"dashboard_settings.dashboard_home\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.type\") {\n\t\tconfig.Setting.MAIN_SETTINGS.DefaultAuth = viper.GetString(\"auth_settings.type\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.gravatar\") {\n\t\tconfig.Setting.MAIN_SETTINGS.EnableGravatar = viper.GetBool(\"auth_settings.gravatar\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"auth_settings.gravatar_url\") {\n\t\tconfig.Setting.MAIN_SETTINGS.GravatarUrl = viper.GetString(\"auth_settings.gravatar_url\")\n\t}\n\n\t/* auth settings */\n\tif viper.IsSet(\"auth_settings.user_groups\") {\n\t\tconfig.Setting.MAIN_SETTINGS.UserGroups = viper.GetStringSlice(\"auth_settings.user_groups\")\n\t}\n\n\t/***********************************/\n\tif viper.IsSet(\"http_client.connection_timeout\") {\n\t\tconfig.Setting.MAIN_SETTINGS.TimeoutHttpClient = viper.GetUint32(\"http_client.connection_timeout\")\n\t}\n\n\t/* check the auth type */\n\tif config.Setting.MAIN_SETTINGS.DefaultAuth == \"\" {\n\t\tconfig.Setting.MAIN_SETTINGS.DefaultAuth = \"internal\"\n\t}\n\n\tif config.Setting.OAUTH2_SETTINGS.Enable {\n\t\tconfig.Setting.MAIN_SETTINGS.OAuth2Config = oauth2.Config{\n\t\t\tClientID:     config.Setting.OAUTH2_SETTINGS.ClientID,\n\t\t\tClientSecret: config.Setting.OAUTH2_SETTINGS.ClientSecret,\n\t\t\tScopes:       config.Setting.OAUTH2_SETTINGS.Scope,\n\t\t\tRedirectURL:  config.Setting.OAUTH2_SETTINGS.RedirectUri + \"/\" + config.Setting.OAUTH2_SETTINGS.ServiceProviderName,\n\t\t\tEndpoint: oauth2.Endpoint{\n\t\t\t\tAuthURL:   config.Setting.OAUTH2_SETTINGS.AuthUri,\n\t\t\t\tTokenURL:  config.Setting.OAUTH2_SETTINGS.TokenUri,\n\t\t\t\tAuthStyle: oauth2.AuthStyle(config.Setting.OAUTH2_SETTINGS.AuthStyle),\n\t\t\t},\n\t\t}\n\t}\n\n\t/* Check LDAP here */\n\tswitch config.Setting.MAIN_SETTINGS.DefaultAuth {\n\tcase \"ldap\":\n\n\t\tdefaults.SetDefaults(&ldapClient) //<-- This set the defaults values\n\n\t\tif viper.IsSet(\"ldap_config.base\") {\n\t\t\tldapClient.Base = viper.GetString(\"ldap_config.base\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.host\") {\n\t\t\tldapClient.Host = viper.GetString(\"ldap_config.host\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.port\") {\n\t\t\tldapClient.Port = viper.GetInt(\"ldap_config.port\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.servername\") {\n\t\t\tldapClient.ServerName = viper.GetString(\"ldap_config.servername\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.userdn\") {\n\t\t\tldapClient.UserDN = viper.GetString(\"ldap_config.userdn\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.usessl\") {\n\t\t\tldapClient.UseSSL = viper.GetBool(\"ldap_config.usessl\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.deref\") {\n\t\t\tldapClient.DerefName = viper.GetString(\"ldap_config.deref\")\n\t\t\t/* lets fix it */\n\t\t\tif ldapClient.DerefName != \"\" {\n\t\t\t\tfor index, x := range ldap.DerefMap {\n\t\t\t\t\tif x == ldapClient.DerefName {\n\t\t\t\t\t\tldapClient.DerefValue = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.scope\") {\n\t\t\tldapClient.ScopeName = viper.GetString(\"ldap_config.scope\")\n\t\t\t/* lets fix it */\n\t\t\tif ldapClient.ScopeName != \"\" {\n\t\t\t\tfor index, x := range ldap.ScopeMap {\n\t\t\t\t\tif x == ldapClient.ScopeName {\n\t\t\t\t\t\tldapClient.ScopeValue = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.anonymous\") {\n\t\t\tldapClient.Anonymous = viper.GetBool(\"ldap_config.anonymous\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.binddn\") {\n\t\t\tldapClient.BindDN = viper.GetString(\"ldap_config.binddn\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.bindpassword\") {\n\t\t\tldapClient.BindPassword = viper.GetString(\"ldap_config.bindpassword\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.userfilter\") {\n\t\t\tldapClient.UserFilter = viper.GetString(\"ldap_config.userfilter\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.groupfilter\") {\n\t\t\tldapClient.GroupFilter = viper.GetString(\"ldap_config.groupfilter\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.attributes\") {\n\t\t\tldapClient.Attributes = viper.GetStringSlice(\"ldap_config.attributes\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.group_attributes\") {\n\t\t\tldapClient.GroupAttribute = viper.GetStringSlice(\"ldap_config.group_attributes\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.admingroup\") {\n\t\t\tldapClient.AdminGroup = viper.GetString(\"ldap_config.admingroup\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.usergroup\") {\n\t\t\tldapClient.UserGroup = viper.GetString(\"ldap_config.usergroup\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.usermode\") {\n\t\t\tldapClient.UserMode = viper.GetBool(\"ldap_config.usermode\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.adminmode\") {\n\t\t\tldapClient.AdminMode = viper.GetBool(\"ldap_config.adminmode\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.searchlimit\") {\n\t\t\tldapClient.SearchLimit = viper.GetInt(\"ldap_config.searchlimit\")\n\t\t}\n\t\tif viper.IsSet(\"ldap_config.grouplimit\") {\n\t\t\tldapClient.GroupLimit = viper.GetInt(\"ldap_config.grouplimit\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.skiptls\") {\n\t\t\tldapClient.SkipTLS = viper.GetBool(\"ldap_config.skiptls\")\n\t\t} else {\n\t\t\tif !ldapClient.UseSSL {\n\t\t\t\tldapClient.SkipTLS = true\n\t\t\t}\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.skipverify\") {\n\t\t\tldapClient.InsecureSkipVerify = viper.GetBool(\"ldap_config.skipverify\")\n\t\t} else {\n\t\t\tldapClient.InsecureSkipVerify = true\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.short_group\") {\n\t\t\tldapClient.ShortGroup = viper.GetBool(\"ldap_config.short_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.short_dn_group\") {\n\t\t\tldapClient.ShortDNForGroup = viper.GetBool(\"ldap_config.short_dn_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.nested_group\") {\n\t\t\tldapClient.NestedGroup = viper.GetBool(\"ldap_config.nested_group\")\n\t\t}\n\n\t\tif viper.IsSet(\"ldap_config.UseDNForGroupSearch\") {\n\t\t\tldapClient.UseDNForGroupSearch = viper.GetBool(\"ldap_config.UseDNForGroupSearch\")\n\t\t} else {\n\t\t\tldapClient.UseDNForGroupSearch = true\n\t\t}\n\n\t\tdefer ldapClient.Close()\n\n\tcase \"http_auth\":\n\t\thttpAuth.URL = viper.GetString(\"http_auth.url\")\n\t\thttpAuth.InsecureSkipVerify = viper.GetBool(\"skipverify\")\n\t}\n\n\t/* apply token expire - default 1200 */\n\tauthTokenExpire := viper.GetInt(\"auth_settings.token_expire\")\n\tif authTokenExpire > 0 {\n\t\tauth.TokenExpiryTime = authTokenExpire\n\t}\n\n\tif versionPg, err := migration.CheckVersion(servicesObject.configDBSession); err != nil {\n\t\theputils.Colorize(heputils.ColorRed, \"\\r\\nVersion of DB couldn't be retrieved\\r\\n\")\n\t} else if (versionPg / 10000) < jsonschema.MinimumPgSQL {\n\t\theputils.Colorize(heputils.ColorRed, fmt.Sprintf(\"\\r\\nYou don't have required version of PostgreSQL. Please install minimum: %d\\r\\n\", jsonschema.MinimumPgSQL))\n\t} else {\n\t\theputils.Colorize(heputils.ColorBlue, fmt.Sprintf(\"\\r\\nPostgreSQL version: %d.%d\\r\\n\", versionPg/10000, versionPg%10000))\n\t}\n\n}\n\nfunc configureAsHTTPServer() {\n\n\te := echo.New()\n\t// add validation\n\te.Validator = &CustomValidator{validator: validator.New()}\n\t// Middleware\n\tif httpDebugEnable := viper.GetBool(\"http_settings.debug\"); httpDebugEnable {\n\t\te.Use(middleware.Logger())\n\t\te.Use(middleware.Recover())\n\t\te.Use(middleware.BodyDumpWithConfig(middleware.BodyDumpConfig{Skipper: skipper, Handler: bodyDumpHandler}))\n\t}\n\n\t//CORS\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"*\"},\n\t\tAllowMethods: []string{echo.GET, echo.PUT, echo.PATCH, echo.POST, echo.DELETE},\n\t}))\n\n\t/* hide banner */\n\te.HideBanner = true\n\n\tif viper.IsSet(\"grafana_config.host\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.URL = viper.GetString(\"grafana_config.host\")\n\t}\n\n\tif viper.IsSet(\"grafana_config.path\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.Path = viper.GetString(\"grafana_config.path\")\n\t}\n\n\tif viper.IsSet(\"grafana_config.token\") {\n\t\tconfig.Setting.GRAFANA_SETTINGS.AuthKey = viper.GetString(\"grafana_config.token\")\n\t}\n\n\t// Reverse Proxy\n\turl1, err := url.Parse(config.Setting.GRAFANA_SETTINGS.URL)\n\tif err != nil {\n\t\te.Logger.Fatal(err)\n\t}\n\n\t/* target grafana */\n\te.Use(GrafanaHeader)\n\n\ttargets := []*middleware.ProxyTarget{\n\t\t{\n\t\t\tURL: url1,\n\t\t},\n\t}\n\n\te.Group(config.Setting.GRAFANA_SETTINGS.Path, middleware.ProxyWithConfig(middleware.ProxyConfig{\n\t\tBalancer: middleware.NewRoundRobinBalancer(targets),\n\t\tRewrite: map[string]string{\n\t\t\tconfig.Setting.GRAFANA_SETTINGS.Path + \"/*\": \"/$1\",\n\t\t},\n\t}))\n\n\tif config.Setting.SWAGGER.Enable {\n\t\t//e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\te.GET(\"/doc/api/json\", func(c echo.Context) error {\n\n\t\t\tlogger.Debug(\"Middle swagger ware: \", c.Request().RequestURI)\n\t\t\tdataJson, err := ioutil.ReadFile(config.Setting.SWAGGER.ApiJson)\n\t\t\tif err != nil {\n\t\t\t\treturn httpresponse.CreateBadResponse(&c, http.StatusBadRequest, webmessages.SwaggerFileNotExistsError)\n\t\t\t}\n\n\t\t\tnewJson := strings.ReplaceAll(string(dataJson), \"localhost:9080\", config.Setting.SWAGGER.ApiHost)\n\n\t\t\treturn httpresponse.CreateSuccessResponseWithJson(&c, http.StatusOK, []byte(newJson))\n\t\t})\n\t}\n\n\t/* static */\n\trootPath := viper.GetString(\"http_settings.root\")\n\tif rootPath == \"\" {\n\t\trootPath = \"/usr/local/homer/dist\"\n\t}\n\t/* static */\n\te.Use(middleware.Static(rootPath))\n\n\t/* enable guzip*/\n\tif gzipEnable := viper.GetBool(\"http_settings.gzip\"); gzipEnable {\n\t\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\t\tSkipper: func(c echo.Context) bool {\n\t\t\t\tif strings.HasPrefix(c.Request().RequestURI, \"/swagger\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tLevel: 5,\n\t\t}))\n\t}\n\n\tgzipStaticEnable := true\n\n\tif viper.IsSet(\"http_settings.gzip_static\") {\n\t\tgzipStaticEnable = viper.GetBool(\"http_settings.gzip_static\")\n\t}\n\n\tif gzipStaticEnable {\n\n\t\te.Pre(middleware.RewriteWithConfig(middleware.RewriteConfig{\n\t\t\tSkipper: func(c echo.Context) bool {\n\n\t\t\t\tif strings.HasSuffix(c.Request().RequestURI, \".js\") {\n\t\t\t\t\tif heputils.FileExists(rootPath + c.Request().RequestURI + \".gz\") {\n\t\t\t\t\t\tc.Response().Header().Set(echo.HeaderContentEncoding, \"gzip\")\n\t\t\t\t\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJavaScript)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tRules: map[string]string{\n\t\t\t\t\"*.js\": \"$1.js.gz\",\n\t\t\t},\n\t\t}))\n\t}\n\n\tregisterGetRedirect(e, rootPath)\n\n\t/* decoder */\n\tservicesObject.externalDecoder.Active = false\n\n\t/* old */\n\tbinShark := viper.GetString(\"decoder_shark.bin\")\n\tif binShark != \"\" {\n\t\tservicesObject.externalDecoder.Binary = binShark\n\t\tservicesObject.externalDecoder.Param = viper.GetString(\"decoder_shark.param\")\n\t\tservicesObject.externalDecoder.Protocols = viper.GetStringSlice(\"decoder_shark.protocols\")\n\t\tservicesObject.externalDecoder.UID = uint32(viper.GetInt(\"decoder_shark.uid\"))\n\t\tservicesObject.externalDecoder.GID = uint32(viper.GetInt(\"decoder_shark.gid\"))\n\t\tservicesObject.externalDecoder.Active = viper.GetBool(\"decoder_shark.active\")\n\t}\n\n\t//  DECODER - SHARK\n\tif viper.IsSet(\"decoder_shark.bin\") {\n\t\tconfig.Setting.DECODER_SHARK.Bin = viper.GetString(\"decoder_shark.bin\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.param\") {\n\t\tconfig.Setting.DECODER_SHARK.Param = viper.GetString(\"decoder_shark.param\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.import_node\") {\n\t\tconfig.Setting.DECODER_SHARK.ImportNode = viper.GetString(\"decoder_shark.import_node\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.protocols\") {\n\t\tconfig.Setting.DECODER_SHARK.Protocols = viper.GetStringSlice(\"decoder_shark.protocols\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.uid\") {\n\t\tconfig.Setting.DECODER_SHARK.UID = uint32(viper.GetInt(\"decoder_shark.uid\"))\n\t}\n\n\tif viper.IsSet(\"decoder_shark.gid\") {\n\t\tconfig.Setting.DECODER_SHARK.GID = uint32(viper.GetInt(\"decoder_shark.gid\"))\n\t}\n\tif viper.IsSet(\"decoder_shark.active\") {\n\t\tconfig.Setting.DECODER_SHARK.Enable = viper.GetBool(\"decoder_shark.active\")\n\t}\n\n\tif viper.IsSet(\"decoder_shark.enable\") {\n\t\tconfig.Setting.DECODER_SHARK.Enable = viper.GetBool(\"decoder_shark.enable\")\n\t}\n\n\tif viper.IsSet(\"swagger.enable\") {\n\t\tconfig.Setting.SWAGGER.Enable = viper.GetBool(\"swagger.enable\")\n\t}\n\n\tif viper.IsSet(\"swagger.api_json\") {\n\t\tconfig.Setting.SWAGGER.ApiJson = viper.GetString(\"swagger.api_json\")\n\t}\n\n\tif viper.IsSet(\"swagger.api_host\") {\n\t\tconfig.Setting.SWAGGER.ApiHost = viper.GetString(\"swagger.api_host\")\n\t}\n\n\t// perform routing for v1 version of web apis\n\tperformV1APIRouting(e)\n\tif viper.GetBool(\"https_settings.enable\") {\n\t\thttpsHost := viper.GetString(\"https_settings.host\")\n\t\thttpsPort := viper.GetString(\"https_settings.port\")\n\t\thttpsURL := fmt.Sprintf(\"%s:%s\", httpsHost, httpsPort)\n\n\t\thttpsCert := viper.GetString(\"https_settings.cert\")\n\t\thttpsKey := viper.GetString(\"https_settings.key\")\n\t\theputils.Colorize(heputils.ColorRed, heputils.HomerLogo)\n\t\theputils.Colorize(heputils.ColorGreen, fmt.Sprintf(\"Version: %s %s\", getName(), getVersion()))\n\n\t\t//Doc Swagger for future. For now - external\n\t\t/* e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\t */\n\t\te.Logger.Fatal(e.StartTLS(httpsURL, httpsCert, httpsKey))\n\t} else {\n\t\thttpHost := viper.GetString(\"http_settings.host\")\n\t\thttpPort := viper.GetString(\"http_settings.port\")\n\t\thttpURL := fmt.Sprintf(\"%s:%s\", httpHost, httpPort)\n\n\t\theputils.Colorize(heputils.ColorRed, heputils.HomerLogo)\n\t\theputils.Colorize(heputils.ColorGreen, fmt.Sprintf(\"Version: %s %s\", getName(), getVersion()))\n\n\t\t//Doc Swagger for future. For now - external\n\t\t/* e.GET(\"/swagger/*\", echoSwagger.WrapHandler)\n\t\t */\n\t\te.Logger.Fatal(e.Start(httpURL))\n\t}\n\n}\n\nfunc performV1APIRouting(e *echo.Echo) {\n\n\tprefix := *appFlags.APIPrefix\n\n\tif viper.IsSet(\"http_settings.api_prefix\") {\n\t\tprefix = viper.GetString(\"http_settings.api_prefix\")\n\t}\n\n\t// accessible web services will fall in this group\n\tacc := e.Group(prefix + \"/api/v3\")\n\n\tswitch config.Setting.MAIN_SETTINGS.DefaultAuth {\n\tcase \"ldap\":\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, &ldapClient, nil)\n\tcase \"http_auth\":\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, nil, &httpAuth)\n\tdefault:\n\t\tapirouterv1.RouteUserApis(acc, servicesObject.configDBSession, nil, nil)\n\t}\n\n\t//subscribe access with authKey\n\tapirouterv1.RouteAgentsubAuthKeyApis(acc, servicesObject.configDBSession)\n\n\t// route hep_reply apis\n\taddr := fmt.Sprintf(\"%s:%d\", viper.Get(\"hep_relay.host\"), viper.GetInt(\"hep_relay.port\"))\n\tapirouterv1.RouteWebSocketApis(acc, addr)\n\n\t// restricted web services will fall in this group\n\tres := e.Group(prefix + \"/api/v3\")\n\t// Configure middleware with the custom claims type\n\tconfig := middleware.JWTConfig{\n\t\tClaims:     &auth.JwtUserClaim{},\n\t\tSigningKey: []byte(config.Setting.AUTH_SETTINGS.JwtSecret),\n\t}\n\n\tres.Use(middleware.JWTWithConfig(config))\n\tres.Use(auth.MiddlewareRes)\n\n\tlogger.Debug(auth.JwtUserClaim{})\n\n\t/*************** admin access ONLY ***************/\n\t// route mapping apis\n\tapirouterv1.RouteMappingdApis(res, servicesObject.configDBSession)\n\t// route alias apis\n\tapirouterv1.RouteAliasApis(res, servicesObject.configDBSession)\n\t// route advanced apis\n\tapirouterv1.RouteAdvancedApis(res, servicesObject.configDBSession)\n\t// route hepsub apis\n\tapirouterv1.RouteHepsubApis(res, servicesObject.configDBSession)\n\t// route make auth token\n\tapirouterv1.RouteAuthTokenApis(res, servicesObject.configDBSession)\n\n\t/*************** PARTLY admin access ONLY ***************/\n\t// route user apis\n\tapirouterv1.RouteUserDetailsApis(res, servicesObject.configDBSession)\n\t// route userSettings apis\n\tapirouterv1.RouteUserSettingsApis(res, servicesObject.configDBSession)\n\t// route agent sub apis\n\tapirouterv1.RouteAgentsubApis(res, servicesObject.configDBSession)\n\n\t// route hep sub search apis\n\tapirouterv1.RouteHepSubSearch(res, servicesObject.configDBSession)\n\n\t// route search apis\n\tapirouterv1.RouteSearchApis(res, servicesObject.dataDBSession, servicesObject.configDBSession, servicesObject.externalDecoder)\n\t// route dashboards apis\n\tapirouterv1.RouteDashboardApis(res, servicesObject.configDBSession)\n\n\t// route profile apis\n\tapirouterv1.RouteProfileApis(res, servicesObject.configDBSession, servicesObject.databaseNodeMap)\n\t// route RouteStatisticApis apis\n\tapirouterv1.RouteStatisticApis(res, servicesObject.influxDBSession)\n\t// route RouteStatisticApis apis\n\tapirouterv1.RoutePrometheusApis(res, servicesObject.servicePrometheus)\n\t// route RouteLokiApis apis\n\tapirouterv1.RouteLokiApis(res, servicesObject.serviceLoki)\n\t// route RouteLokiApis apis\n\tapirouterv1.RouteGrafanaApis(res, servicesObject.configDBSession, servicesObject.serviceGrafana)\n\n}\n\n/* retries */\nfunc RetryHandler(n int, f func() (bool, error)) error {\n\tok, er := f()\n\tif ok && er == nil {\n\t\treturn nil\n\t}\n\tif n-1 > 0 {\n\t\treturn RetryHandler(n-1, f)\n\t}\n\treturn er\n}\n\n// getSession creates a new mongo session and panics if connection error occurs\nfunc getDataDBSession() (map[string]*gorm.DB, []model.DatabasesMap) {\n\n\tdataConfig := viper.GetStringMapStringSlice(\"database_data\")\n\tdbMap := make(map[string]*gorm.DB)\n\tvar dbNodeMap []model.DatabasesMap\n\n\tif _, ok := dataConfig[\"user\"]; !ok {\n\t\tfor val := range dataConfig {\n\n\t\t\tkeyData := \"database_data.\" + val\n\n\t\t\tuser := viper.GetString(keyData + \".user\")\n\t\t\tpassword := viper.GetString(keyData + \".pass\")\n\t\t\tname := viper.GetString(keyData + \".name\")\n\t\t\thost := viper.GetString(keyData + \".host\")\n\t\t\tnode := viper.GetString(keyData + \".node\")\n\t\t\tport := viper.GetInt(keyData + \".port\")\n\n\t\t\t/* keep alive is on by default */\n\t\t\tkeepAlive := true\n\t\t\tif viper.IsSet(keyData + \".keepalive\") {\n\t\t\t\tkeepAlive = viper.GetBool(keyData + \".keepalive\")\n\t\t\t}\n\n\t\t\tsslMode := \"disable\"\n\t\t\tif viper.IsSet(keyData + \".sslmode\") {\n\t\t\t\tsslMode = viper.GetString(keyData + \".sslmode\")\n\t\t\t} else if viper.IsSet(keyData+\".usessl\") && viper.GetBool(keyData+\".usessl\") {\n\t\t\t\tsslMode = \"require\"\n\t\t\t}\n\n\t\t\tlogger.Info(fmt.Sprintf(\"Connecting to [%s, %s, %s, %s, %d, ssl: %s]\\n\", host, user, name, node, port, sslMode))\n\n\t\t\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\t\t\tif port != 0 {\n\t\t\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t\t\t}\n\n\t\t\tdbA, err := gorm.Open(\"postgres\", connectString)\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make connection to [Host: %s, Node: %s, Port: %d]: \\n\", host, node, port), err)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tdbA.DB().SetMaxIdleConns(5)\n\t\t\t\tdbA.DB().SetMaxOpenConns(10)\n\t\t\t\tdbA.DB().SetConnMaxLifetime(5 * time.Minute)\n\t\t\t\t/* activate logging */\n\t\t\t\tdbA.SetLogger(&logger.GormLogger{})\n\t\t\t\tdbMap[val] = dbA\n\n\t\t\t\tdbNodeMap = append(dbNodeMap, model.DatabasesMap{Name: node, Value: val})\n\n\t\t\t\tif keepAlive {\n\n\t\t\t\t\tgo makePingKeepAlive(dbA, host, \"data\", node)\n\n\t\t\t\t\t// auto-connect\uff0cping per 60s, re-connect on fail or error with intervels 3s, 3s, 15s, 30s, 60s, 60s ...\n\t\t\t\t\t/* go func(dbConfig string, db *gorm.DB) {\n\t\t\t\t\t\tvar intervals = []time.Duration{3 * time.Second, 3 * time.Second, 15 * time.Second, 30 * time.Second, 60 * time.Second}\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\ttime.Sleep(60 * time.Second)\n\t\t\t\t\t\t\tif e := db.DB().Ping(); e != nil {\n\t\t\t\t\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make ping to [Connect: %s]  Error: [%v]\", dbConfig, e))\n\t\t\t\t\t\t\tL:\n\t\t\t\t\t\t\t\tfor i := 0; i < len(intervals); i++ {\n\t\t\t\t\t\t\t\t\te2 := RetryHandler(3, func() (bool, error) {\n\t\t\t\t\t\t\t\t\t\tvar e error\n\t\t\t\t\t\t\t\t\t\tdb, e = gorm.Open(\"postgres\", dbConfig)\n\t\t\t\t\t\t\t\t\t\tif e != nil {\n\t\t\t\t\t\t\t\t\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make connect to [Connect: %s]  Error: [%v]\", dbConfig, e))\n\t\t\t\t\t\t\t\t\t\t\treturn false, e\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tif e2 != nil {\n\t\t\t\t\t\t\t\t\t\tfmt.Println(e.Error())\n\t\t\t\t\t\t\t\t\t\ttime.Sleep(intervals[i])\n\t\t\t\t\t\t\t\t\t\tif i == len(intervals)-1 {\n\t\t\t\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak L\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}(connectString, dbA)\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlogger.Info(\"----------------------------------- \")\n\t\t\tlogger.Info(\"*** Database Data Session created *** \")\n\t\t\tlogger.Info(\"----------------------------------- \")\n\t\t}\n\t} else {\n\t\t//single node\n\t\tuser := viper.GetString(\"database_data.user\")\n\t\tpassword := viper.GetString(\"database_data.pass\")\n\t\tname := viper.GetString(\"database_data.name\")\n\t\thost := viper.GetString(\"database_data.host\")\n\t\tport := viper.GetInt(\"database_data.port\")\n\n\t\t/* keep alive is on by default */\n\t\tkeepAlive := true\n\t\tif viper.IsSet(\"database_data.keepalive\") {\n\t\t\tkeepAlive = viper.GetBool(\"database_data.keepalive\")\n\t\t}\n\n\t\tlogger.Info(fmt.Sprintf(\"Connecting to the old way: [%s, %s, %s, %d]\\n\", host, user, name, port))\n\n\t\tsslMode := \"disable\"\n\t\tif viper.IsSet(\"database_data.sslmode\") {\n\t\t\tsslMode = viper.GetString(\"database_data.sslmode\")\n\t\t} else if viper.IsSet(\"database_data.usessl\") && viper.GetBool(\"database_data.usessl\") {\n\t\t\tsslMode = \"require\"\n\t\t}\n\n\t\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\t\tif port != 0 {\n\t\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t\t}\n\n\t\tdb, err := gorm.Open(\"postgres\", connectString)\n\n\t\tdb.DB().SetMaxIdleConns(5)\n\t\tdb.DB().SetMaxOpenConns(10)\n\t\tdb.DB().SetConnMaxLifetime(5 * time.Minute)\n\t\t/* activate logging */\n\t\tdb.SetLogger(&logger.GormLogger{})\n\n\t\tdbMap[\"localnode\"] = db\n\n\t\tif err != nil {\n\t\t\tlogger.Error(err)\n\t\t\tpanic(\"failed to connect database\")\n\t\t}\n\n\t\tdbNodeMap = append(dbNodeMap, model.DatabasesMap{Value: \"localnode\", Name: \"LocalNode\"})\n\n\t\tif keepAlive {\n\t\t\tgo makePingKeepAlive(db, host, \"data\", \"localnode\")\n\t\t}\n\n\t\tlogger.Info(\"----------------------------------- \")\n\t\tlogger.Info(\"*** Database Data Session created *** \")\n\t\tlogger.Info(\"----------------------------------- \")\n\t}\n\n\treturn dbMap, dbNodeMap\n}\n\n// getSession creates a new postgres session and panics if connection error occurs\nfunc getConfigDBSession() *gorm.DB {\n\tuser := viper.GetString(\"database_config.user\")\n\tpassword := viper.GetString(\"database_config.pass\")\n\tname := viper.GetString(\"database_config.name\")\n\thost := viper.GetString(\"database_config.host\")\n\tport := viper.GetInt(\"database_config.port\")\n\n\t/* keep alive is on by default */\n\tkeepAlive := true\n\tif viper.IsSet(\"database_config.keepalive\") {\n\t\tkeepAlive = viper.GetBool(\"database_config.keepalive\")\n\t}\n\n\tsslMode := \"disable\"\n\tif viper.IsSet(\"database_config.sslmode\") {\n\t\tsslMode = viper.GetString(\"database_config.sslmode\")\n\t} else if viper.IsSet(\"database_config.usessl\") && viper.GetBool(\"database_config.usessl\") {\n\t\tsslMode = \"require\"\n\t}\n\n\tconnectString := fmt.Sprintf(\"host=%s user=%s dbname=%s sslmode=%s password=%s\", host, user, name, sslMode, password)\n\n\tif port != 0 {\n\t\tconnectString += fmt.Sprintf(\" port=%d\", port)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"Connecting to the config: [%s, %s, %s, %d]\\n\", host, user, name, port))\n\n\tdb, err := gorm.Open(\"postgres\", connectString)\n\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to connect database\")\n\t}\n\n\tdb.DB().SetMaxIdleConns(5)\n\tdb.DB().SetMaxOpenConns(10)\n\tdb.DB().SetConnMaxLifetime(5 * time.Minute)\n\tdb.SetLogger(&logger.GormLogger{})\n\n\tlogger.Info(\"----------------------------------- \")\n\tlogger.Info(\"*** Database Config Session created *** \")\n\tlogger.Info(\"----------------------------------- \")\n\n\tif keepAlive {\n\t\tgo makePingKeepAlive(db, host, \"config\", \"localnode\")\n\t}\n\n\treturn db\n}\n\n// getSession creates a new mongo session and panics if connection error occurs\nfunc updateVersionApplication(configDBSession *gorm.DB) bool {\n\n\tvar err error\n\tvar saveConfig = false\n\trecordApp := model.TableApplications{}\n\trecordApp.VersionApplication = getVersion()\n\trecordApp.NameApplication = getName()\n\n\trecordApp.HostApplication = viper.GetString(\"system_settings.hostname\")\n\tif recordApp.HostApplication == \"\" {\n\t\trecordApp.HostApplication, err = os.Hostname()\n\t\tif err != nil {\n\t\t\trecordApp.HostApplication = \"unknown\"\n\t\t}\n\t\tviper.Set(\"system_settings.hostname\", recordApp.HostApplication)\n\t\tsaveConfig = true\n\n\t}\n\n\trecordApp.GUID = viper.GetString(\"system_settings.uuid\")\n\tif recordApp.GUID == \"\" {\n\t\trecordApp.GUID = uuid.NewV4().String()\n\t\tviper.Set(\"system_settings.uuid\", recordApp.GUID)\n\t\tsaveConfig = true\n\t}\n\n\t//generate JWT\n\tconfig.Setting.AUTH_SETTINGS.JwtSecret = viper.GetString(\"auth_settings.jwt_secret\")\n\tif config.Setting.AUTH_SETTINGS.JwtSecret == \"\" {\n\t\tconfig.Setting.AUTH_SETTINGS.JwtSecret = uuid.NewV4().String()\n\t\tviper.Set(\"auth_settings.jwt_secret\", config.Setting.AUTH_SETTINGS.JwtSecret)\n\t\tsaveConfig = true\n\t}\n\n\tif saveConfig {\n\t\terr := viper.WriteConfig()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif err := configDBSession.Debug().Set(\n\t\t\"gorm:insert_option\",\n\t\tfmt.Sprintf(\"ON CONFLICT (name,host) DO UPDATE SET version = EXCLUDED.version, guid = EXCLUDED.guid\"),\n\t).Table(\"applications\").Create(&recordApp).Error; err != nil {\n\t\tlogger.Error(\"Error by updating application table\", err)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getInfluxDBSession() service.ServiceInfluxDB {\n\n\tuser := viper.GetString(\"influxdb_config.user\")\n\tpassword := viper.GetString(\"influxdb_config.pass\")\n\thost := viper.GetString(\"influxdb_config.host\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"InfluxDB functions disabled\")\n\t\treturn service.ServiceInfluxDB{Active: false}\n\t}\n\n\turlInflux, err := url.Parse(host)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to parse influx host\")\n\t}\n\n\tconf := client.HTTPConfig{\n\t\tAddr:     urlInflux.String(),\n\t\tUsername: user,\n\t\tPassword: password,\n\t}\n\n\tinfluxClient, err := client.NewHTTPClient(conf)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\tpanic(\"failed to connect influx database\")\n\t}\n\n\tserviceInfluxDB := service.ServiceInfluxDB{\n\t\tInfluxClient: influxClient,\n\t\tActive:       true,\n\t}\n\n\tlogger.Info(\"----------------------------------- \")\n\tlogger.Info(\"*** Influx Database Session created *** \")\n\tlogger.Info(\"----------------------------------- \")\n\treturn serviceInfluxDB\n}\n\n// getPrometheusDBSession creates a new influxdb session and panics if connection error occurs\nfunc getPrometheusDBSession() service.ServicePrometheus {\n\n\thost := viper.GetString(\"prometheus_config.host\")\n\tuser := viper.GetString(\"prometheus_config.user\")\n\tpassword := viper.GetString(\"prometheus_config.pass\")\n\tapi := viper.GetString(\"prometheus_config.api\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"Prometheus functions disabled\")\n\t\treturn service.ServicePrometheus{Active: false}\n\t}\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tservicePrometheus := service.ServicePrometheus{\n\t\tHttpClient: httpClient,\n\t\tUser:       user,\n\t\tPassword:   password,\n\t\tHost:       host,\n\t\tApi:        api,\n\t\tActive:     true,\n\t}\n\n\tlogger.Info(\"------------------------------------ \")\n\tlogger.Info(\"**** Prometheus Session created **** \")\n\tlogger.Info(\"------------------------------------ \")\n\treturn servicePrometheus\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getRemoteDBSession() service.ServiceLoki {\n\n\tuser := viper.GetString(\"loki_config.user\")\n\tpassword := viper.GetString(\"loki_config.pass\")\n\tif viper.IsSet(\"loki_config.password\") {\n\t\tpassword = viper.GetString(\"loki_config.password\")\n\t}\n\n\thost := viper.GetString(\"loki_config.host\")\n\tapi := viper.GetString(\"loki_config.api\")\n\tparamQuery := viper.GetString(\"loki_config.param_query\")\n\n\tif host == \"\" {\n\t\tlogger.Info(\"Loki functions disabled\")\n\t\treturn service.ServiceLoki{Active: false}\n\t}\n\n\t/* if the param_query has been not defined - we use the new schema */\n\tif paramQuery == \"\" {\n\t\tparamQuery = \"query_range\"\n\t}\n\t/* force to new api*/\n\tif api == \"\" || api == \"api/prom\" {\n\t\tapi = \"loki/api/v1\"\n\t}\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tServiceLoki := service.ServiceLoki{\n\t\tHttpClient: httpClient,\n\t\tUser:       user,\n\t\tPassword:   password,\n\t\tHost:       host,\n\t\tApi:        api,\n\t\tParamQuery: paramQuery,\n\t\tActive:     true,\n\t}\n\n\tlogger.Info(\"------------------------------------ \")\n\tlogger.Info(\"**** Loki Session created **** \")\n\tlogger.Info(\"------------------------------------ \")\n\treturn ServiceLoki\n}\n\n// getInfluxDBSession creates a new influxdb session and panics if connection error occurs\nfunc getGrafanaSession() service.ServiceGrafana {\n\n\thttpClient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\tServiceGrafana := service.ServiceGrafana{\n\t\tHttpClient: httpClient,\n\t\tUser:       \"admin\",\n\t\tPassword:   \"\",\n\t\tToken:      \"\",\n\t\tHost:       \"http://127.0.0.1:3000\",\n\t\tApi:        \"\",\n\t\tActive:     true,\n\t}\n\n\treturn ServiceGrafana\n}\n\nfunc readConfig() {\n\t// Getting constant values\n\tif configEnv := os.Getenv(\"WEBAPPENV\"); configEnv != \"\" {\n\t\tviper.SetConfigName(\"webapp_config_\" + configEnv)\n\t} else {\n\t\tviper.SetConfigName(\"webapp_config\")\n\t}\n\tviper.SetConfigType(\"json\")\n\n\tif configPath := os.Getenv(\"WEBAPPPATH\"); configPath != \"\" {\n\t\tviper.AddConfigPath(configPath)\n\t} else {\n\t\tviper.AddConfigPath(*appFlags.PathWebAppConfig)\n\t}\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n\tif *appFlags.WatchConfig {\n\t\tviper.OnConfigChange(func(in fsnotify.Event) {\n\t\t\tconfigureLogging()\n\t\t\tconfigureServiceObjects()\n\n\t\t})\n\t\tviper.WatchConfig()\n\t}\n}\n\nfunc applyDBDataParamToConfig(user *string, password *string, dbname *string, host *string, node *string, sslmode *string) {\n\n\tcreateString := fmt.Sprintf(\"\\r\\nHOMER - writing data to config [user=%s password=%s, dbname=%s, host=%s, node=%s, sslmode=%s]\", *user, *password, *dbname, *host, *node, *sslmode)\n\n\theputils.Colorize(heputils.ColorRed, createString)\n\n\tviper.Set(\"database_data.\"+*node+\".user\", *user)\n\tviper.Set(\"database_data.\"+*node+\".pass\", *password)\n\tviper.Set(\"database_data.\"+*node+\".name\", *dbname)\n\tviper.Set(\"database_data.\"+*node+\".host\", *host)\n\tviper.Set(\"database_data.\"+*node+\".node\", *node)\n\tviper.Set(\"database_data.\"+*node+\".sslmode\", *sslmode)\n\n\terr := viper.WriteConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n}\n\nfunc applyDBConfigParamToConfig(user *string, password *string, dbname *string, host *string, sslmode *string) {\n\n\tcreateString := fmt.Sprintf(\"\\r\\nHOMER - writing data to config [user=%s password=%s, dbname=%s, host=%s, sslmode=%s]\", *user, *password, *dbname, *host, *sslmode)\n\n\theputils.Colorize(heputils.ColorRed, createString)\n\n\tviper.Set(\"database_config.user\", *user)\n\tviper.Set(\"database_config.pass\", *password)\n\tviper.Set(\"database_config.name\", *dbname)\n\tviper.Set(\"database_config.host\", *host)\n\tviper.Set(\"database_config.sslmode\", *sslmode)\n\n\terr := viper.WriteConfig()\n\tif err != nil {\n\t\tfmt.Println(\"No configuration file loaded: \", err)\n\t\tlogger.Error(\"No configuration file loaded - using defaults\")\n\t\tpanic(\"DB configuration file not found: \")\n\t}\n}\n\nfunc registerGetRedirect(e *echo.Echo, path string) {\n\n\tprefix := *appFlags.APIPrefix\n\n\tif viper.IsSet(\"http_settings.api_prefix\") {\n\t\tprefix = viper.GetString(\"http_settings.api_prefix\")\n\t}\n\n\te.GET(prefix+\"/dashboard/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/call/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/call/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/search/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/search/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/registration/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/registration/:name/\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"(system:login)\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(prefix+\"/preference/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/transaction/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/search/result/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n\te.GET(\"/search/:name\", func(c echo.Context) (err error) {\n\t\treturn c.File(path + \"/index.html\")\n\t})\n\n}\n\n// middle ware handler\nfunc bodyDumpHandler(c echo.Context, reqBody, resBody []byte) {\n\n\tlogger.Debug(\"================================\")\n\n\tlogger.Debug(\"--------request body-------\")\n\tprintBody(reqBody)\n\tlogger.Info(\"---------------------------\")\n\n\tlogger.Debug(\"-------- response body --------\")\n\tprintBody(resBody)\n\tlogger.Debug(\"-------------------------------\")\n\tlogger.Debug(\"=================================\")\n}\n\n// body dump skipper\nfunc skipper(c echo.Context) bool {\n\n\tif c.Request().Method == \"POST\" {\n\t\tlogger.Debug(c.Request().URL.Path)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// private method\nfunc printBody(obj []byte) {\n\n\tlogger.Logger.WithFields(logrus.Fields{\n\t\t\"json\": string(obj),\n\t}).Info(\"Payload\")\n}\n\nfunc checkHelpVersionFlags() {\n\tif *appFlags.ShowHelpMessage {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tif *appFlags.ShowVersion {\n\t\tfmt.Printf(\"VERSION: %s\\r\\n\", getVersion())\n\t\tos.Exit(0)\n\t}\n}\n\nfunc checkAdminFlags() {\n\tif *appFlags.InitializeDB {\n\t\tinitDB()\n\t}\n\n\t/* start creating pgsql user */\n\tif *appFlags.CreateHomerUser {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.CreateNewUser(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start drop pgsql user */\n\t} else if *appFlags.DeleteHomerUser {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.DeleteNewUser(rootDb, appFlags.DatabaseHomerUser)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start creating pgsql user */\n\t} else if *appFlags.CreateConfigDB || *appFlags.CreateDataDB {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\t\tif *appFlags.CreateDataDB {\n\t\t\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerData, appFlags.DatabaseHomerUser)\n\t\t} else {\n\t\t\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerUser)\n\t\t}\n\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start creating pgsql user */\n\t} else if *appFlags.CreateHomerRole {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tdataDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseHomerData,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection to data. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer dataDb.Close()\n\n\t\tmigration.CreateHomerRole(rootDb, dataDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t} else if *appFlags.RevokeHomerRole {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.RevokeHomerRole(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t\t/* start drop pgsql user */\n\t\t/* start drop pgsql user */\n\t} else if *appFlags.ShowDbUsers {\n\n\t\trootDb, err := migration.GetDataRootDBSession(appFlags.DatabaseRootUser,\n\t\t\tappFlags.DatabaseRootPassword,\n\t\t\tappFlags.DatabaseRootDB,\n\t\t\tappFlags.DatabaseHost,\n\t\t\tappFlags.DatabasePort,\n\t\t\tappFlags.DatabaseSSLMode)\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer rootDb.Close()\n\n\t\tmigration.ShowUsers(rootDb)\n\n\t\tos.Exit(0)\n\t}\n}\n\nfunc initDB() {\n\trootDb, err := migration.GetDataRootDBSession(\n\t\tappFlags.DatabaseRootUser,\n\t\tappFlags.DatabaseRootPassword,\n\t\tappFlags.DatabaseRootDB,\n\t\tappFlags.DatabaseHost,\n\t\tappFlags.DatabasePort,\n\t\tappFlags.DatabaseSSLMode)\n\n\tif err != nil {\n\t\tlogger.Error(\"Couldn't establish connection. Please be sure you can have correct password\", err)\n\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\tpanic(err)\n\t}\n\n\tdefer rootDb.Close()\n\n\tmigration.CreateNewUser(rootDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerPassword)\n\tmigration.ShowUsers(rootDb)\n\n\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerData, appFlags.DatabaseHomerUser)\n\tmigration.CreateHomerDB(rootDb, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerUser)\n\n\tdatabaseDb, err := migration.GetDataRootDBSession(\n\t\tappFlags.DatabaseRootUser,\n\t\tappFlags.DatabaseRootPassword,\n\t\tappFlags.DatabaseHomerData,\n\t\tappFlags.DatabaseHost,\n\t\tappFlags.DatabasePort,\n\t\tappFlags.DatabaseSSLMode)\n\n\tif err != nil {\n\t\tlogger.Error(\"Couldn't establish connection to databaseDb. Please be sure you can have correct password\", err)\n\t\tlogger.Error(\"Try run: sudo -u postgres psql -c \\\"ALTER USER postgres PASSWORD 'postgres';\\\"\")\n\t\tpanic(err)\n\t}\n\n\tdefer databaseDb.Close()\n\n\tmigration.CreateHomerRole(rootDb, databaseDb, appFlags.DatabaseHomerUser, appFlags.DatabaseHomerConfig, appFlags.DatabaseHomerData)\n\n\tservicesObject.configDBSession = getConfigDBSession()\n\tdefer servicesObject.configDBSession.Close()\n\tnameHomerConfig := viper.GetString(\"database_config.name\")\n\n\tmigration.CreateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.UpgradeTableConfigDB, true)\n\tmigration.PopulateHomerConfigTables(servicesObject.configDBSession, nameHomerConfig, *appFlags.ForcePopulate, appFlags.TablesPopulate, *appFlags.ForcePasswordDB)\n\n\tos.Exit(0)\n}\n\n// ServerHeader middleware adds a `Server` header to the response.\nfunc GrafanaHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tif strings.HasPrefix(c.Request().RequestURI, config.Setting.GRAFANA_SETTINGS.Path) {\n\t\t\tc.Request().Header.Add(\"Authorization\", \"Bearer \"+config.Setting.GRAFANA_SETTINGS.AuthKey)\n\t\t}\n\t\treturn next(c)\n\t}\n}\n\n// make a ping keep alive\nfunc makePingKeepAlive(db *gorm.DB, host string, typeData string, node string) {\n\n\tfor {\n\n\t\tpingErr := db.DB().Ping()\n\t\tif pingErr != nil {\n\t\t\tlogger.Error(fmt.Sprintf(\"couldn't make ping to [Host: %s], Type: [%s], Node: [%s]  Error: [%v]\",\n\t\t\t\thost, typeData, node, pingErr))\n\t\t} else {\n\t\t\tlogger.Debug(fmt.Printf(\"Successful ping: %s, Type: %s, Node: %s\", host, typeData, node))\n\t\t}\n\n\t\ttime.Sleep(time.Duration(60) * time.Second)\n\t}\n}\n\nfunc ShowCurrentConfigToConsole() {\n\n\theputils.Colorize(heputils.ColorRed, \"\\r\\nMAIN_SETTINGS:\\r\\n\")\n\n\tspew.Dump(config.Setting)\n\n\theputils.Colorize(heputils.ColorRed, \"\\r\\nLDAP:\\r\\n\")\n\n\tspew.Dump(ldapClient)\n\n}\n\nfunc initHttpClient() {\n\n\tconfig.Setting.MAIN_SETTINGS.SubscribeHttpClient = &http.Client{Timeout: time.Duration(config.Setting.MAIN_SETTINGS.TimeoutHttpClient) * time.Second}\n}\n", "package main\n\n//VERSION\nvar VERSION_APPLICATION = \"1.4.28\"\n\n//NAME\nvar NAME_APPLICATION = \"homer-app\"\n\nfunc getVersion() string {\n\treturn VERSION_APPLICATION\n}\n\nfunc getName() string {\n\treturn NAME_APPLICATION\n}\n"], "filenames": ["auth/claims.go", "auth/constants.go", "config/config.go", "etc/webapp_config.json", "main.go", "version.go"], "buggy_code_start_loc": [6, 2, 44, 105, 132, 4], "buggy_code_end_loc": [53, 4, 44, 105, 1167, 5], "fixing_code_start_loc": [7, 1, 45, 106, 133, 4], "fixing_code_end_loc": [54, 1, 49, 107, 1193, 5], "type": "CWE-798", "message": "QXIP SIPCAPTURE homer-app before 1.4.28 for HOMER 7.x has the same 167f0db2-f83e-4baa-9736-d56064a5b415 JWT secret key across different customers' installations.", "other": {"cve": {"id": "CVE-2022-22845", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-10T14:12:58.567", "lastModified": "2022-01-18T17:41:36.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "QXIP SIPCAPTURE homer-app before 1.4.28 for HOMER 7.x has the same 167f0db2-f83e-4baa-9736-d56064a5b415 JWT secret key across different customers' installations."}, {"lang": "es", "value": "QXIP SIPCAPTURE homer-app versiones anteriores a 1.4.28 para HOMER versi\u00f3n 7.x, presenta la misma 167f0db2-f83e-4baa-9736-d56064a5b415 clave secreta JWT en las instalaciones de diferentes clientes"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qxip:homer_webapp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.28", "matchCriteriaId": "D7C13F26-B7C0-41BA-B1C5-172D495CDE0D"}]}]}], "references": [{"url": "http://sipcapture.org", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/sipcapture/homer", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sipcapture/homer-app/commit/7f92f3afc8b0380c14af3d0fc1c365318a2d1591", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sipcapture/homer-app/compare/1.4.27...1.4.28", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sipcapture/homer-app/commit/7f92f3afc8b0380c14af3d0fc1c365318a2d1591"}}