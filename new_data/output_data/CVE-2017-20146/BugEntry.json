{"buggy_code": ["package handlers\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CORSOption represents a functional option for configuring the CORS middleware.\ntype CORSOption func(*cors) error\n\ntype cors struct {\n\th                      http.Handler\n\tallowedHeaders         []string\n\tallowedMethods         []string\n\tallowedOrigins         []string\n\tallowedOriginValidator OriginValidator\n\texposedHeaders         []string\n\tmaxAge                 int\n\tignoreOptions          bool\n\tallowCredentials       bool\n}\n\n// OriginValidator takes an origin string and returns whether or not that origin is allowed.\ntype OriginValidator func(string) bool\n\nvar (\n\tdefaultCorsMethods = []string{\"GET\", \"HEAD\", \"POST\"}\n\tdefaultCorsHeaders = []string{\"Accept\", \"Accept-Language\", \"Content-Language\", \"Origin\"}\n\t// (WebKit/Safari v9 sends the Origin header by default in AJAX requests)\n)\n\nconst (\n\tcorsOptionMethod           string = \"OPTIONS\"\n\tcorsAllowOriginHeader      string = \"Access-Control-Allow-Origin\"\n\tcorsExposeHeadersHeader    string = \"Access-Control-Expose-Headers\"\n\tcorsMaxAgeHeader           string = \"Access-Control-Max-Age\"\n\tcorsAllowMethodsHeader     string = \"Access-Control-Allow-Methods\"\n\tcorsAllowHeadersHeader     string = \"Access-Control-Allow-Headers\"\n\tcorsAllowCredentialsHeader string = \"Access-Control-Allow-Credentials\"\n\tcorsRequestMethodHeader    string = \"Access-Control-Request-Method\"\n\tcorsRequestHeadersHeader   string = \"Access-Control-Request-Headers\"\n\tcorsOriginHeader           string = \"Origin\"\n\tcorsVaryHeader             string = \"Vary\"\n\tcorsOriginMatchAll         string = \"*\"\n)\n\nfunc (ch *cors) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\torigin := r.Header.Get(corsOriginHeader)\n\tif !ch.isOriginAllowed(origin) {\n\t\tch.h.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\tif r.Method == corsOptionMethod {\n\t\tif ch.ignoreOptions {\n\t\t\tch.h.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := r.Header[corsRequestMethodHeader]; !ok {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tmethod := r.Header.Get(corsRequestMethodHeader)\n\t\tif !ch.isMatch(method, ch.allowedMethods) {\n\t\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\trequestHeaders := strings.Split(r.Header.Get(corsRequestHeadersHeader), \",\")\n\t\tallowedHeaders := []string{}\n\t\tfor _, v := range requestHeaders {\n\t\t\tcanonicalHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif canonicalHeader == \"\" || ch.isMatch(canonicalHeader, defaultCorsHeaders) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(canonicalHeader, ch.allowedHeaders) {\n\t\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tallowedHeaders = append(allowedHeaders, canonicalHeader)\n\t\t}\n\n\t\tif len(allowedHeaders) > 0 {\n\t\t\tw.Header().Set(corsAllowHeadersHeader, strings.Join(allowedHeaders, \",\"))\n\t\t}\n\n\t\tif ch.maxAge > 0 {\n\t\t\tw.Header().Set(corsMaxAgeHeader, strconv.Itoa(ch.maxAge))\n\t\t}\n\n\t\tif !ch.isMatch(method, defaultCorsMethods) {\n\t\t\tw.Header().Set(corsAllowMethodsHeader, method)\n\t\t}\n\t} else {\n\t\tif len(ch.exposedHeaders) > 0 {\n\t\t\tw.Header().Set(corsExposeHeadersHeader, strings.Join(ch.exposedHeaders, \",\"))\n\t\t}\n\t}\n\n\tif ch.allowCredentials {\n\t\tw.Header().Set(corsAllowCredentialsHeader, \"true\")\n\t}\n\n\tif len(ch.allowedOrigins) > 1 {\n\t\tw.Header().Set(corsVaryHeader, corsOriginHeader)\n\t}\n\n\tw.Header().Set(corsAllowOriginHeader, origin)\n\n\tif r.Method == corsOptionMethod {\n\t\treturn\n\t}\n\tch.h.ServeHTTP(w, r)\n}\n\n// CORS provides Cross-Origin Resource Sharing middleware.\n// Example:\n//\n//  import (\n//      \"net/http\"\n//\n//      \"github.com/gorilla/handlers\"\n//      \"github.com/gorilla/mux\"\n//  )\n//\n//  func main() {\n//      r := mux.NewRouter()\n//      r.HandleFunc(\"/users\", UserEndpoint)\n//      r.HandleFunc(\"/projects\", ProjectEndpoint)\n//\n//      // Apply the CORS middleware to our top-level router, with the defaults.\n//      http.ListenAndServe(\":8000\", handlers.CORS()(r))\n//  }\n//\nfunc CORS(opts ...CORSOption) func(http.Handler) http.Handler {\n\treturn func(h http.Handler) http.Handler {\n\t\tch := parseCORSOptions(opts...)\n\t\tch.h = h\n\t\treturn ch\n\t}\n}\n\nfunc parseCORSOptions(opts ...CORSOption) *cors {\n\tch := &cors{\n\t\tallowedMethods: defaultCorsMethods,\n\t\tallowedHeaders: defaultCorsHeaders,\n\t\tallowedOrigins: []string{corsOriginMatchAll},\n\t}\n\n\tfor _, option := range opts {\n\t\toption(ch)\n\t}\n\n\treturn ch\n}\n\n//\n// Functional options for configuring CORS.\n//\n\n// AllowedHeaders adds the provided headers to the list of allowed headers in a\n// CORS request.\n// This is an append operation so the headers Accept, Accept-Language,\n// and Content-Language are always allowed.\n// Content-Type must be explicitly declared if accepting Content-Types other than\n// application/x-www-form-urlencoded, multipart/form-data, or text/plain.\nfunc AllowedHeaders(headers []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tfor _, v := range headers {\n\t\t\tnormalizedHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif normalizedHeader == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedHeader, ch.allowedHeaders) {\n\t\t\t\tch.allowedHeaders = append(ch.allowedHeaders, normalizedHeader)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// AllowedMethods can be used to explicitly allow methods in the\n// Access-Control-Allow-Methods header.\n// This is a replacement operation so you must also\n// pass GET, HEAD, and POST if you wish to support those methods.\nfunc AllowedMethods(methods []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowedMethods = []string{}\n\t\tfor _, v := range methods {\n\t\t\tnormalizedMethod := strings.ToUpper(strings.TrimSpace(v))\n\t\t\tif normalizedMethod == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedMethod, ch.allowedMethods) {\n\t\t\t\tch.allowedMethods = append(ch.allowedMethods, normalizedMethod)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// AllowedOrigins sets the allowed origins for CORS requests, as used in the\n// 'Allow-Access-Control-Origin' HTTP header.\n// Note: Passing in a []string{\"*\"} will allow any domain.\nfunc AllowedOrigins(origins []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tfor _, v := range origins {\n\t\t\tif v == corsOriginMatchAll {\n\t\t\t\tch.allowedOrigins = []string{corsOriginMatchAll}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tch.allowedOrigins = origins\n\t\treturn nil\n\t}\n}\n\n// AllowedOriginValidator sets a function for evaluating allowed origins in CORS requests, represented by the\n// 'Allow-Access-Control-Origin' HTTP header.\nfunc AllowedOriginValidator(fn OriginValidator) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowedOriginValidator = fn\n\t\treturn nil\n\t}\n}\n\n// ExposeHeaders can be used to specify headers that are available\n// and will not be stripped out by the user-agent.\nfunc ExposedHeaders(headers []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.exposedHeaders = []string{}\n\t\tfor _, v := range headers {\n\t\t\tnormalizedHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif normalizedHeader == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedHeader, ch.exposedHeaders) {\n\t\t\t\tch.exposedHeaders = append(ch.exposedHeaders, normalizedHeader)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// MaxAge determines the maximum age (in seconds) between preflight requests. A\n// maximum of 10 minutes is allowed. An age above this value will default to 10\n// minutes.\nfunc MaxAge(age int) CORSOption {\n\treturn func(ch *cors) error {\n\t\t// Maximum of 10 minutes.\n\t\tif age > 600 {\n\t\t\tage = 600\n\t\t}\n\n\t\tch.maxAge = age\n\t\treturn nil\n\t}\n}\n\n// IgnoreOptions causes the CORS middleware to ignore OPTIONS requests, instead\n// passing them through to the next handler. This is useful when your application\n// or framework has a pre-existing mechanism for responding to OPTIONS requests.\nfunc IgnoreOptions() CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.ignoreOptions = true\n\t\treturn nil\n\t}\n}\n\n// AllowCredentials can be used to specify that the user agent may pass\n// authentication details along with the request.\nfunc AllowCredentials() CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowCredentials = true\n\t\treturn nil\n\t}\n}\n\nfunc (ch *cors) isOriginAllowed(origin string) bool {\n\tif origin == \"\" {\n\t\treturn false\n\t}\n\n\tif ch.allowedOriginValidator != nil {\n\t\treturn ch.allowedOriginValidator(origin)\n\t}\n\n\tfor _, allowedOrigin := range ch.allowedOrigins {\n\t\tif allowedOrigin == origin || allowedOrigin == corsOriginMatchAll {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (ch *cors) isMatch(needle string, haystack []string) bool {\n\tfor _, v := range haystack {\n\t\tif v == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n", "package handlers\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestDefaultCORSHandlerReturnsOk(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusFound)\n\t}\n}\n\nfunc TestDefaultCORSHandlerReturnsOkWithOrigin(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusFound)\n\t}\n}\n\nfunc TestCORSHandlerIgnoreOptionsFallsThrough(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\tCORS(IgnoreOptions())(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusTeapot {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusTeapot)\n\t}\n}\n\nfunc TestCORSHandlerSetsExposedHeaders(t *testing.T) {\n\t// Test default configuration.\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(ExposedHeaders([]string{\"X-CORS-TEST\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsExposeHeadersHeader)\n\tif header != \"X-Cors-Test\" {\n\t\tt.Fatal(\"bad header: expected X-Cors-Test header, got empty header for method.\")\n\t}\n}\n\nfunc TestCORSHandlerUnsetRequestMethodForPreflightBadRequest(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedMethods([]string{\"DELETE\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusBadRequest {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusBadRequest)\n\t}\n}\n\nfunc TestCORSHandlerInvalidRequestMethodForPreflightMethodNotAllowed(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"DELETE\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusMethodNotAllowed {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc TestCORSHandlerOptionsRequestMustNotBePassedToNextHandler(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"GET\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Fatal(\"Options request must not be passed to next handler\")\n\t})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n}\n\nfunc TestCORSHandlerAllowedMethodForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"DELETE\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedMethods([]string{\"DELETE\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowMethodsHeader)\n\tif header != \"DELETE\" {\n\t\tt.Fatalf(\"bad header: expected DELETE method header, got empty header.\")\n\t}\n}\n\nfunc TestCORSHandlerAllowMethodsNotSetForSimpleRequestPreflight(t *testing.T) {\n\tfor _, method := range defaultCorsMethods {\n\t\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\t\tr.Header.Set(\"Origin\", r.URL.String())\n\t\tr.Header.Set(corsRequestMethodHeader, method)\n\n\t\trr := httptest.NewRecorder()\n\n\t\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\t\tif status := rr.Code; status != http.StatusOK {\n\t\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t\t}\n\n\t\theader := rr.HeaderMap.Get(corsAllowMethodsHeader)\n\t\tif header != \"\" {\n\t\t\tt.Fatalf(\"bad header: expected empty method header, got %s.\", header)\n\t\t}\n\t}\n}\n\nfunc TestCORSHandlerAllowedHeaderNotSetForSimpleRequestPreflight(t *testing.T) {\n\tfor _, simpleHeader := range defaultCorsHeaders {\n\t\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\t\tr.Header.Set(\"Origin\", r.URL.String())\n\t\tr.Header.Set(corsRequestMethodHeader, \"GET\")\n\t\tr.Header.Set(corsRequestHeadersHeader, simpleHeader)\n\n\t\trr := httptest.NewRecorder()\n\n\t\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\t\tif status := rr.Code; status != http.StatusOK {\n\t\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t\t}\n\n\t\theader := rr.HeaderMap.Get(corsAllowHeadersHeader)\n\t\tif header != \"\" {\n\t\t\tt.Fatalf(\"bad header: expected empty header, got %s.\", header)\n\t\t}\n\t}\n}\n\nfunc TestCORSHandlerAllowedHeaderForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\tr.Header.Set(corsRequestHeadersHeader, \"Content-Type\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedHeaders([]string{\"Content-Type\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowHeadersHeader)\n\tif header != \"Content-Type\" {\n\t\tt.Fatalf(\"bad header: expected Content-Type header, got empty header.\")\n\t}\n}\n\nfunc TestCORSHandlerInvalidHeaderForPreflightForbidden(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\tr.Header.Set(corsRequestHeadersHeader, \"Content-Type\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusForbidden {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusForbidden)\n\t}\n}\n\nfunc TestCORSHandlerMaxAgeForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(MaxAge(3500))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsMaxAgeHeader)\n\tif header != \"600\" {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsMaxAgeHeader, \"600\", header)\n\t}\n}\n\nfunc TestCORSHandlerAllowedCredentials(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowCredentials())(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowCredentialsHeader)\n\tif header != \"true\" {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsAllowCredentialsHeader, \"true\", header)\n\t}\n}\n\nfunc TestCORSHandlerMultipleAllowOriginsSetsVaryHeader(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedOrigins([]string{r.URL.String(), \"http://google.com\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsVaryHeader)\n\tif header != corsOriginHeader {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsVaryHeader, corsOriginHeader, header)\n\t}\n}\n\nfunc TestCORSWithMultipleHandlers(t *testing.T) {\n\tvar lastHandledBy string\n\tcorsMiddleware := CORS()\n\n\ttestHandler1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlastHandledBy = \"testHandler1\"\n\t})\n\ttestHandler2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlastHandledBy = \"testHandler2\"\n\t})\n\n\tr1 := newRequest(\"GET\", \"http://www.example.com/\")\n\trr1 := httptest.NewRecorder()\n\thandler1 := corsMiddleware(testHandler1)\n\n\tcorsMiddleware(testHandler2)\n\n\thandler1.ServeHTTP(rr1, r1)\n\tif lastHandledBy != \"testHandler1\" {\n\t\tt.Fatalf(\"bad CORS() registration: Handler served should be Handler registered\")\n\t}\n}\n\nfunc TestCORSHandlerWithCustomValidator(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://a.example.com\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\toriginValidator := func(origin string) bool {\n\t\tif strings.HasSuffix(origin, \".example.com\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tCORS(AllowedOriginValidator(originValidator))(testHandler).ServeHTTP(rr, r)\n\theader := rr.HeaderMap.Get(corsAllowOriginHeader)\n\tif header != r.URL.String() {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsAllowOriginHeader, r.URL.String(), header)\n\t}\n\n}\n"], "fixing_code": ["package handlers\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CORSOption represents a functional option for configuring the CORS middleware.\ntype CORSOption func(*cors) error\n\ntype cors struct {\n\th                      http.Handler\n\tallowedHeaders         []string\n\tallowedMethods         []string\n\tallowedOrigins         []string\n\tallowedOriginValidator OriginValidator\n\texposedHeaders         []string\n\tmaxAge                 int\n\tignoreOptions          bool\n\tallowCredentials       bool\n}\n\n// OriginValidator takes an origin string and returns whether or not that origin is allowed.\ntype OriginValidator func(string) bool\n\nvar (\n\tdefaultCorsMethods = []string{\"GET\", \"HEAD\", \"POST\"}\n\tdefaultCorsHeaders = []string{\"Accept\", \"Accept-Language\", \"Content-Language\", \"Origin\"}\n\t// (WebKit/Safari v9 sends the Origin header by default in AJAX requests)\n)\n\nconst (\n\tcorsOptionMethod           string = \"OPTIONS\"\n\tcorsAllowOriginHeader      string = \"Access-Control-Allow-Origin\"\n\tcorsExposeHeadersHeader    string = \"Access-Control-Expose-Headers\"\n\tcorsMaxAgeHeader           string = \"Access-Control-Max-Age\"\n\tcorsAllowMethodsHeader     string = \"Access-Control-Allow-Methods\"\n\tcorsAllowHeadersHeader     string = \"Access-Control-Allow-Headers\"\n\tcorsAllowCredentialsHeader string = \"Access-Control-Allow-Credentials\"\n\tcorsRequestMethodHeader    string = \"Access-Control-Request-Method\"\n\tcorsRequestHeadersHeader   string = \"Access-Control-Request-Headers\"\n\tcorsOriginHeader           string = \"Origin\"\n\tcorsVaryHeader             string = \"Vary\"\n\tcorsOriginMatchAll         string = \"*\"\n)\n\nfunc (ch *cors) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\torigin := r.Header.Get(corsOriginHeader)\n\tif !ch.isOriginAllowed(origin) {\n\t\tch.h.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\tif r.Method == corsOptionMethod {\n\t\tif ch.ignoreOptions {\n\t\t\tch.h.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := r.Header[corsRequestMethodHeader]; !ok {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tmethod := r.Header.Get(corsRequestMethodHeader)\n\t\tif !ch.isMatch(method, ch.allowedMethods) {\n\t\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\trequestHeaders := strings.Split(r.Header.Get(corsRequestHeadersHeader), \",\")\n\t\tallowedHeaders := []string{}\n\t\tfor _, v := range requestHeaders {\n\t\t\tcanonicalHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif canonicalHeader == \"\" || ch.isMatch(canonicalHeader, defaultCorsHeaders) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(canonicalHeader, ch.allowedHeaders) {\n\t\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tallowedHeaders = append(allowedHeaders, canonicalHeader)\n\t\t}\n\n\t\tif len(allowedHeaders) > 0 {\n\t\t\tw.Header().Set(corsAllowHeadersHeader, strings.Join(allowedHeaders, \",\"))\n\t\t}\n\n\t\tif ch.maxAge > 0 {\n\t\t\tw.Header().Set(corsMaxAgeHeader, strconv.Itoa(ch.maxAge))\n\t\t}\n\n\t\tif !ch.isMatch(method, defaultCorsMethods) {\n\t\t\tw.Header().Set(corsAllowMethodsHeader, method)\n\t\t}\n\t} else {\n\t\tif len(ch.exposedHeaders) > 0 {\n\t\t\tw.Header().Set(corsExposeHeadersHeader, strings.Join(ch.exposedHeaders, \",\"))\n\t\t}\n\t}\n\n\tif ch.allowCredentials {\n\t\tw.Header().Set(corsAllowCredentialsHeader, \"true\")\n\t}\n\n\tif len(ch.allowedOrigins) > 1 {\n\t\tw.Header().Set(corsVaryHeader, corsOriginHeader)\n\t}\n\n\treturnOrigin := origin\n\tfor _, o := range ch.allowedOrigins {\n\t\t// A configuration of * is different than explicitly setting an allowed\n\t\t// origin. Returning arbitrary origin headers an an access control allow\n\t\t// origin header is unsafe and is not required by any use case.\n\t\tif o == corsOriginMatchAll {\n\t\t\treturnOrigin = \"*\"\n\t\t\tbreak\n\t\t}\n\t}\n\tw.Header().Set(corsAllowOriginHeader, returnOrigin)\n\n\tif r.Method == corsOptionMethod {\n\t\treturn\n\t}\n\tch.h.ServeHTTP(w, r)\n}\n\n// CORS provides Cross-Origin Resource Sharing middleware.\n// Example:\n//\n//  import (\n//      \"net/http\"\n//\n//      \"github.com/gorilla/handlers\"\n//      \"github.com/gorilla/mux\"\n//  )\n//\n//  func main() {\n//      r := mux.NewRouter()\n//      r.HandleFunc(\"/users\", UserEndpoint)\n//      r.HandleFunc(\"/projects\", ProjectEndpoint)\n//\n//      // Apply the CORS middleware to our top-level router, with the defaults.\n//      http.ListenAndServe(\":8000\", handlers.CORS()(r))\n//  }\n//\nfunc CORS(opts ...CORSOption) func(http.Handler) http.Handler {\n\treturn func(h http.Handler) http.Handler {\n\t\tch := parseCORSOptions(opts...)\n\t\tch.h = h\n\t\treturn ch\n\t}\n}\n\nfunc parseCORSOptions(opts ...CORSOption) *cors {\n\tch := &cors{\n\t\tallowedMethods: defaultCorsMethods,\n\t\tallowedHeaders: defaultCorsHeaders,\n\t\tallowedOrigins: []string{corsOriginMatchAll},\n\t}\n\n\tfor _, option := range opts {\n\t\toption(ch)\n\t}\n\n\treturn ch\n}\n\n//\n// Functional options for configuring CORS.\n//\n\n// AllowedHeaders adds the provided headers to the list of allowed headers in a\n// CORS request.\n// This is an append operation so the headers Accept, Accept-Language,\n// and Content-Language are always allowed.\n// Content-Type must be explicitly declared if accepting Content-Types other than\n// application/x-www-form-urlencoded, multipart/form-data, or text/plain.\nfunc AllowedHeaders(headers []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tfor _, v := range headers {\n\t\t\tnormalizedHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif normalizedHeader == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedHeader, ch.allowedHeaders) {\n\t\t\t\tch.allowedHeaders = append(ch.allowedHeaders, normalizedHeader)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// AllowedMethods can be used to explicitly allow methods in the\n// Access-Control-Allow-Methods header.\n// This is a replacement operation so you must also\n// pass GET, HEAD, and POST if you wish to support those methods.\nfunc AllowedMethods(methods []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowedMethods = []string{}\n\t\tfor _, v := range methods {\n\t\t\tnormalizedMethod := strings.ToUpper(strings.TrimSpace(v))\n\t\t\tif normalizedMethod == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedMethod, ch.allowedMethods) {\n\t\t\t\tch.allowedMethods = append(ch.allowedMethods, normalizedMethod)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// AllowedOrigins sets the allowed origins for CORS requests, as used in the\n// 'Allow-Access-Control-Origin' HTTP header.\n// Note: Passing in a []string{\"*\"} will allow any domain.\nfunc AllowedOrigins(origins []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tfor _, v := range origins {\n\t\t\tif v == corsOriginMatchAll {\n\t\t\t\tch.allowedOrigins = []string{corsOriginMatchAll}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tch.allowedOrigins = origins\n\t\treturn nil\n\t}\n}\n\n// AllowedOriginValidator sets a function for evaluating allowed origins in CORS requests, represented by the\n// 'Allow-Access-Control-Origin' HTTP header.\nfunc AllowedOriginValidator(fn OriginValidator) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowedOriginValidator = fn\n\t\treturn nil\n\t}\n}\n\n// ExposeHeaders can be used to specify headers that are available\n// and will not be stripped out by the user-agent.\nfunc ExposedHeaders(headers []string) CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.exposedHeaders = []string{}\n\t\tfor _, v := range headers {\n\t\t\tnormalizedHeader := http.CanonicalHeaderKey(strings.TrimSpace(v))\n\t\t\tif normalizedHeader == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !ch.isMatch(normalizedHeader, ch.exposedHeaders) {\n\t\t\t\tch.exposedHeaders = append(ch.exposedHeaders, normalizedHeader)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// MaxAge determines the maximum age (in seconds) between preflight requests. A\n// maximum of 10 minutes is allowed. An age above this value will default to 10\n// minutes.\nfunc MaxAge(age int) CORSOption {\n\treturn func(ch *cors) error {\n\t\t// Maximum of 10 minutes.\n\t\tif age > 600 {\n\t\t\tage = 600\n\t\t}\n\n\t\tch.maxAge = age\n\t\treturn nil\n\t}\n}\n\n// IgnoreOptions causes the CORS middleware to ignore OPTIONS requests, instead\n// passing them through to the next handler. This is useful when your application\n// or framework has a pre-existing mechanism for responding to OPTIONS requests.\nfunc IgnoreOptions() CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.ignoreOptions = true\n\t\treturn nil\n\t}\n}\n\n// AllowCredentials can be used to specify that the user agent may pass\n// authentication details along with the request.\nfunc AllowCredentials() CORSOption {\n\treturn func(ch *cors) error {\n\t\tch.allowCredentials = true\n\t\treturn nil\n\t}\n}\n\nfunc (ch *cors) isOriginAllowed(origin string) bool {\n\tif origin == \"\" {\n\t\treturn false\n\t}\n\n\tif ch.allowedOriginValidator != nil {\n\t\treturn ch.allowedOriginValidator(origin)\n\t}\n\n\tfor _, allowedOrigin := range ch.allowedOrigins {\n\t\tif allowedOrigin == origin || allowedOrigin == corsOriginMatchAll {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (ch *cors) isMatch(needle string, haystack []string) bool {\n\tfor _, v := range haystack {\n\t\tif v == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n", "package handlers\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestDefaultCORSHandlerReturnsOk(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusFound)\n\t}\n}\n\nfunc TestDefaultCORSHandlerReturnsOkWithOrigin(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusFound)\n\t}\n}\n\nfunc TestCORSHandlerIgnoreOptionsFallsThrough(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\tCORS(IgnoreOptions())(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusTeapot {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusTeapot)\n\t}\n}\n\nfunc TestCORSHandlerSetsExposedHeaders(t *testing.T) {\n\t// Test default configuration.\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(ExposedHeaders([]string{\"X-CORS-TEST\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsExposeHeadersHeader)\n\tif header != \"X-Cors-Test\" {\n\t\tt.Fatal(\"bad header: expected X-Cors-Test header, got empty header for method.\")\n\t}\n}\n\nfunc TestCORSHandlerUnsetRequestMethodForPreflightBadRequest(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedMethods([]string{\"DELETE\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusBadRequest {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusBadRequest)\n\t}\n}\n\nfunc TestCORSHandlerInvalidRequestMethodForPreflightMethodNotAllowed(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"DELETE\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusMethodNotAllowed {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc TestCORSHandlerOptionsRequestMustNotBePassedToNextHandler(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"GET\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Fatal(\"Options request must not be passed to next handler\")\n\t})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n}\n\nfunc TestCORSHandlerAllowedMethodForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"DELETE\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedMethods([]string{\"DELETE\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowMethodsHeader)\n\tif header != \"DELETE\" {\n\t\tt.Fatalf(\"bad header: expected DELETE method header, got empty header.\")\n\t}\n}\n\nfunc TestCORSHandlerAllowMethodsNotSetForSimpleRequestPreflight(t *testing.T) {\n\tfor _, method := range defaultCorsMethods {\n\t\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\t\tr.Header.Set(\"Origin\", r.URL.String())\n\t\tr.Header.Set(corsRequestMethodHeader, method)\n\n\t\trr := httptest.NewRecorder()\n\n\t\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\t\tif status := rr.Code; status != http.StatusOK {\n\t\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t\t}\n\n\t\theader := rr.HeaderMap.Get(corsAllowMethodsHeader)\n\t\tif header != \"\" {\n\t\t\tt.Fatalf(\"bad header: expected empty method header, got %s.\", header)\n\t\t}\n\t}\n}\n\nfunc TestCORSHandlerAllowedHeaderNotSetForSimpleRequestPreflight(t *testing.T) {\n\tfor _, simpleHeader := range defaultCorsHeaders {\n\t\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\t\tr.Header.Set(\"Origin\", r.URL.String())\n\t\tr.Header.Set(corsRequestMethodHeader, \"GET\")\n\t\tr.Header.Set(corsRequestHeadersHeader, simpleHeader)\n\n\t\trr := httptest.NewRecorder()\n\n\t\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\t\tif status := rr.Code; status != http.StatusOK {\n\t\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t\t}\n\n\t\theader := rr.HeaderMap.Get(corsAllowHeadersHeader)\n\t\tif header != \"\" {\n\t\t\tt.Fatalf(\"bad header: expected empty header, got %s.\", header)\n\t\t}\n\t}\n}\n\nfunc TestCORSHandlerAllowedHeaderForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\tr.Header.Set(corsRequestHeadersHeader, \"Content-Type\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedHeaders([]string{\"Content-Type\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowHeadersHeader)\n\tif header != \"Content-Type\" {\n\t\tt.Fatalf(\"bad header: expected Content-Type header, got empty header.\")\n\t}\n}\n\nfunc TestCORSHandlerInvalidHeaderForPreflightForbidden(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\tr.Header.Set(corsRequestHeadersHeader, \"Content-Type\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS()(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusForbidden {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusForbidden)\n\t}\n}\n\nfunc TestCORSHandlerMaxAgeForPreflight(t *testing.T) {\n\tr := newRequest(\"OPTIONS\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\tr.Header.Set(corsRequestMethodHeader, \"POST\")\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(MaxAge(3500))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsMaxAgeHeader)\n\tif header != \"600\" {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsMaxAgeHeader, \"600\", header)\n\t}\n}\n\nfunc TestCORSHandlerAllowedCredentials(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowCredentials())(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsAllowCredentialsHeader)\n\tif header != \"true\" {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsAllowCredentialsHeader, \"true\", header)\n\t}\n}\n\nfunc TestCORSHandlerMultipleAllowOriginsSetsVaryHeader(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://www.example.com/\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tCORS(AllowedOrigins([]string{r.URL.String(), \"http://google.com\"}))(testHandler).ServeHTTP(rr, r)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Fatalf(\"bad status: got %v want %v\", status, http.StatusOK)\n\t}\n\n\theader := rr.HeaderMap.Get(corsVaryHeader)\n\tif header != corsOriginHeader {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsVaryHeader, corsOriginHeader, header)\n\t}\n}\n\nfunc TestCORSWithMultipleHandlers(t *testing.T) {\n\tvar lastHandledBy string\n\tcorsMiddleware := CORS()\n\n\ttestHandler1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlastHandledBy = \"testHandler1\"\n\t})\n\ttestHandler2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlastHandledBy = \"testHandler2\"\n\t})\n\n\tr1 := newRequest(\"GET\", \"http://www.example.com/\")\n\trr1 := httptest.NewRecorder()\n\thandler1 := corsMiddleware(testHandler1)\n\n\tcorsMiddleware(testHandler2)\n\n\thandler1.ServeHTTP(rr1, r1)\n\tif lastHandledBy != \"testHandler1\" {\n\t\tt.Fatalf(\"bad CORS() registration: Handler served should be Handler registered\")\n\t}\n}\n\nfunc TestCORSHandlerWithCustomValidator(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://a.example.com\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\toriginValidator := func(origin string) bool {\n\t\tif strings.HasSuffix(origin, \".example.com\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t// Specially craft a CORS object.\n\thandleFunc := func(h http.Handler) http.Handler {\n\t\tc := &cors{\n\t\t\tallowedMethods: defaultCorsMethods,\n\t\t\tallowedHeaders: defaultCorsHeaders,\n\t\t\tallowedOrigins: []string{\"http://a.example.com\"},\n\t\t\th:              h,\n\t\t}\n\t\tAllowedOriginValidator(originValidator)(c)\n\t\treturn c\n\t}\n\n\thandleFunc(testHandler).ServeHTTP(rr, r)\n\theader := rr.HeaderMap.Get(corsAllowOriginHeader)\n\tif header != r.URL.String() {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsAllowOriginHeader, r.URL.String(), header)\n\t}\n\n}\n\nfunc TestCORSAllowStar(t *testing.T) {\n\tr := newRequest(\"GET\", \"http://a.example.com\")\n\tr.Header.Set(\"Origin\", r.URL.String())\n\trr := httptest.NewRecorder()\n\n\ttestHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\toriginValidator := func(origin string) bool {\n\t\tif strings.HasSuffix(origin, \".example.com\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tCORS(AllowedOriginValidator(originValidator))(testHandler).ServeHTTP(rr, r)\n\theader := rr.HeaderMap.Get(corsAllowOriginHeader)\n\t// Because * is the default CORS policy (which is safe), we should be\n\t// expect a * returned here as the Access Control Allow Origin header\n\tif header != \"*\" {\n\t\tt.Fatalf(\"bad header: expected %s to be %s, got %s.\", corsAllowOriginHeader, r.URL.String(), header)\n\t}\n\n}\n"], "filenames": ["cors.go", "cors_test.go"], "buggy_code_start_loc": [113, 330], "buggy_code_end_loc": [114, 336], "fixing_code_start_loc": [113, 330], "fixing_code_end_loc": [124, 372], "type": "CWE-346", "message": "Usage of the CORS handler may apply improper CORS headers, allowing the requester to explicitly control the value of the Access-Control-Allow-Origin header, which bypasses the expected behavior of the Same Origin Policy.", "other": {"cve": {"id": "CVE-2017-20146", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.070", "lastModified": "2023-01-06T16:26:16.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Usage of the CORS handler may apply improper CORS headers, allowing the requester to explicitly control the value of the Access-Control-Allow-Origin header, which bypasses the expected behavior of the Same Origin Policy."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gorillatoolkit:handlers:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "0731243E-DC58-4998-8161-885D9E0ADF6C"}]}]}], "references": [{"url": "https://github.com/gorilla/handlers/commit/90663712d74cb411cbef281bc1e08c19d1a76145", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gorilla/handlers/pull/116", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0020", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gorilla/handlers/commit/90663712d74cb411cbef281bc1e08c19d1a76145"}}