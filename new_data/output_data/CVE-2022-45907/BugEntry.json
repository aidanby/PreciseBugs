{"buggy_code": ["# -*- coding: utf-8 -*-\n# Owner(s): [\"oncall: jit\"]\n\nimport torch\n\n# This is how we include tests located in test/jit/...\n# They are included here so that they are invoked when you call `test_jit.py`,\n# do not run these test files directly.\nfrom jit.test_tracer import TestTracer, TestMixTracingScripting  # noqa: F401\nfrom jit.test_recursive_script import TestRecursiveScript  # noqa: F401\nfrom jit.test_type_sharing import TestTypeSharing  # noqa: F401\nfrom jit.test_logging import TestLogging  # noqa: F401\nfrom jit.test_backends import TestBackends, TestBackendsWithCompiler  # noqa: F401\nfrom jit.test_backend_nnapi import TestNnapiBackend  # noqa: F401\nfrom jit.test_list_dict import TestList, TestDict, TestNamedTuple, TestScriptDict, TestScriptList  # noqa: F401\nfrom jit.test_async import TestAsync  # noqa: F401\nfrom jit.test_data_parallel import TestDataParallel  # noqa: F401\nfrom jit.test_models import TestModels  # noqa: F401\nfrom jit.test_modules import TestModules  # noqa: F401\nfrom jit.test_autodiff import TestAutodiffJit  # noqa: F401\nfrom jit.test_autodiff_subgraph_slicing import TestAutodiffSubgraphSlicing  # noqa: F401\nfrom jit.test_custom_operators import TestCustomOperators  # noqa: F401\nfrom jit.test_graph_rewrite_passes import TestGraphRewritePasses  # noqa: F401\nfrom jit.test_class_type import TestClassType  # noqa: F401\nfrom jit.test_builtins import TestBuiltins, TestTensorBuiltins  # noqa: F401\nfrom jit.test_ignore_context_manager import TestIgnoreContextManager  # noqa: F401\nfrom jit.test_symbolic_shape_analysis import TestSymbolicShapeAnalysis  # noqa: F401\nfrom jit.test_op_decompositions import TestOpDecompositions  # noqa: F401\nfrom jit.test_unsupported_ops import TestUnsupportedOps  # noqa: F401\nfrom jit.test_freezing import TestFreezing, TestFrozenOptimizations, TestMKLDNNReinplacing  # noqa: F401\nfrom jit.test_peephole import TestPeephole  # noqa: F401\nfrom jit.test_alias_analysis import TestAliasAnalysis  # noqa: F401\nfrom jit.test_save_load import TestSaveLoad, TestSaveLoadFlatbuffer  # noqa: F401\nfrom jit.test_save_load_for_op_version import TestSaveLoadForOpVersion  # noqa: F401\nfrom jit.test_module_containers import TestModuleContainers  # noqa: F401\nfrom jit.test_python_bindings import TestPythonBindings  # noqa: F401\nfrom jit.test_python_ir import TestPythonIr  # noqa: F401\nfrom jit.test_functional_blocks import TestFunctionalBlocks  # noqa: F401\nfrom jit.test_remove_mutation import TestRemoveMutation  # noqa: F401\nfrom jit.test_torchbind import TestTorchbind  # noqa: F401\nfrom jit.test_module_interface import TestModuleInterface  # noqa: F401  # noqa: F401\nfrom jit.test_with import TestWith  # noqa: F401\nfrom jit.test_enum import TestEnum  # noqa: F401\nfrom jit.test_string_formatting import TestStringFormatting  # noqa: F401\nfrom jit.test_profiler import TestProfiler  # noqa: F401\nfrom jit.test_slice import TestSlice  # noqa: F401\nfrom jit.test_ignorable_args import TestIgnorableArgs  # noqa: F401\nfrom jit.test_hooks import TestHooks  # noqa: F401\nfrom jit.test_warn import TestWarn  # noqa: F401\nfrom jit.test_isinstance import TestIsinstance  # noqa: F401\nfrom jit.test_cuda import TestCUDA  # noqa: F401\nfrom jit.test_python_builtins import TestPythonBuiltinOP  # noqa: F401\nfrom jit.test_typing import TestTyping  # noqa: F401\nfrom jit.test_hash import TestHash  # noqa: F401\nfrom jit.test_complex import TestComplex  # noqa: F401\nfrom jit.test_jit_utils import TestJitUtils  # noqa: F401\nfrom jit.test_scriptmod_ann import TestScriptModuleInstanceAttributeTypeAnnotation  # noqa: F401\nfrom jit.test_types import TestTypesAndAnnotation  # noqa: F401\nfrom jit.test_misc import TestMisc  # noqa: F401\nfrom jit.test_upgraders import TestUpgraders  # noqa: F401\nfrom jit.test_pdt import TestPDT  # noqa: F401\nfrom jit.test_tensor_creation_ops import TestTensorCreationOps  # noqa: F401\nfrom jit.test_module_apis import TestModuleAPIs  # noqa: F401\nfrom jit.test_script_profile import TestScriptProfile  # noqa: F401\nfrom jit.test_convert_activation import TestFunctionalToInplaceActivation, TestInplaceToFunctionalActivation  # noqa: F401\nfrom jit.test_parametrization import TestParametrization  # noqa: F401\nfrom jit.test_attr import TestGetDefaultAttr  # noqa: F401\nfrom jit.test_aten_pow import TestAtenPow  # noqa: F401\nfrom jit.test_optimize_for_mobile_preserve_debug_info import TestOptimizeForMobilePreserveDebugInfo  # noqa: F401\nfrom jit.test_union import TestUnion  # noqa: F401\nfrom jit.test_batch_mm import TestBatchMM  # noqa: F401\nfrom jit.test_dtype_analysis import TestDtypeAnalysis, TestDtypeCustomRulesCPU  # noqa: F401\nfrom jit.test_device_analysis import TestDeviceAnalysis  # noqa: F401\nfrom jit.test_dce import TestDCE  # noqa: F401\nfrom jit.test_sparse import TestSparse  # noqa: F401\nfrom jit.test_tensor_methods import TestTensorMethods  # noqa: F401\nfrom jit.test_dataclasses import TestDataclasses  # noqa: F401\n\n# Torch\nfrom torch import Tensor\nfrom torch._C import TensorType, BoolType, parse_ir, _propagate_shapes\nfrom torch.autograd import Variable\nfrom torch.jit.annotations import BroadcastingList2, BroadcastingList3, Any  # noqa: F401\nfrom torch.nn.utils.rnn import PackedSequence\nfrom torch.testing import FileCheck, make_tensor\nimport torch.autograd.profiler\nimport torch.cuda\nimport torch.jit\nimport torch.jit._logging\nimport torch.jit.frontend\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# Testing utils\nfrom torch.testing._internal import jit_utils\nfrom torch.testing._internal.common_jit import check_against_reference\nfrom torch.testing._internal.common_utils import run_tests, IS_WINDOWS, TEST_WITH_UBSAN, \\\n    suppress_warnings, BUILD_WITH_CAFFE2, IS_SANDCASTLE, GRAPH_EXECUTOR, ProfilingMode, TestCase, \\\n    freeze_rng_state, slowTest, TemporaryFileName, \\\n    enable_profiling_mode_for_profiling_tests, TEST_MKL, set_default_dtype, num_profiled_runs, \\\n    skipIfCrossRef, IS_MACOS, skipIfTorchDynamo\nfrom torch.testing._internal.jit_utils import JitTestCase, enable_cpu_fuser, disable_autodiff_subgraph_inlining, \\\n    _trace, do_input_map, get_execution_plan, make_global, \\\n    execWrapper, _inline_everything, _tmp_donotuse_dont_inline_everything, \\\n    RUN_CUDA\nfrom torch.testing._internal.jit_metaprogramming_utils import (\n    get_script_args,\n    create_input, unpack_variables,\n    additional_module_tests, EXCLUDE_SCRIPT_MODULES,\n    get_nn_module_name_from_kwargs, get_nn_mod_test_name, script_method_template)\n\nfrom torch.testing._internal.common_nn import module_tests, new_module_tests, criterion_tests\n\n# For testing truediv in python 2\nfrom torch.testing._internal.test_module.future_div import div_int_future, div_float_future\nfrom torch.testing._internal.test_module.no_future_div import div_int_nofuture, div_float_nofuture\n\n# Standard library\nfrom collections import defaultdict, namedtuple, OrderedDict\nfrom copy import deepcopy\nfrom itertools import product\nfrom textwrap import dedent\nfrom typing import List, Dict, NamedTuple, Optional, Tuple, Union\nimport copy\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport numpy as np\nimport os\nimport pickle\nimport pickletools\nimport random\nimport re\nimport shutil\nimport string\nimport sys\nimport tempfile\nimport types\nimport typing\nimport unittest\nimport warnings\nimport zipfile\n\n\ndef canonical(graph):\n    return torch._C._jit_pass_canonicalize(graph).str(False)\n\ndef LSTMCellF(input, hx, cx, *params):\n    return LSTMCell(input, (hx, cx), *params)\n\ndef doAutodiffCheck(testname):\n    # TODO: setting false on test itself is not working\n    if \"test_t_\" in testname or testname == \"test_t\":\n        return False\n\n    if GRAPH_EXECUTOR == ProfilingMode.SIMPLE:\n        return False\n\n    if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n        return True\n\n\n    # these tests are disabled because BailOut nodes\n    # inserted by ProfilingExecutor interfere with\n    # subgraph slicing of Differentiable Graphs\n    test_exceptions = [\n        # functional\n        'test_nn_dropout',\n        'test_nn_log_softmax',\n        'test_nn_relu',\n        'test_nn_softmax',\n        'test_nn_threshold',\n        'test_nn_lp_pool2d',\n        'test_nn_lp_pool1d',\n        'test_nn_gumbel_softmax_hard',\n        'test_nn_gumbel_softmax',\n        'test_nn_multilabel_soft_margin_loss',\n        'test_nn_batch_norm',\n        'test_nn_max_pool2d_with_indices',\n        # AutogradJitGenerated\n        'test___rdiv___constant',\n        'test___rdiv___scalar_constant',\n        'test_split',\n        'test_split_dim',\n        'test_split_dim_neg0',\n        'test_split_size_list',\n        'test_split_size_list_dim',\n        'test_split_size_list_dim_neg0',\n        'test_split_with_sizes',\n        'test_split_with_sizes_dim',\n        'test_split_with_sizes_dim_neg0',\n        'test_split_with_sizes_size_0',\n        'test_nn_max_pool2d_with_indices',\n    ]\n\n    if testname in test_exceptions:\n        return False\n    return True\n\n\n# TODO: enable TE in PE when all tests are fixed\ntorch._C._jit_set_texpr_fuser_enabled(GRAPH_EXECUTOR == ProfilingMode.PROFILING)\ntorch._C._jit_set_profiling_executor(GRAPH_EXECUTOR != ProfilingMode.LEGACY)\n\ndef LSTMCell(input, hidden, w_ih, w_hh, b_ih=None, b_hh=None):\n    hx, cx = hidden\n    gates = F.linear(input, w_ih, b_ih) + F.linear(hx, w_hh, b_hh)\n\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = torch.sigmoid(ingate)\n    forgetgate = torch.sigmoid(forgetgate)\n    cellgate = torch.tanh(cellgate)\n    outgate = torch.sigmoid(outgate)\n\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * torch.tanh(cy)\n    return hy, cy\n\n\ndef LSTMCellC(*args, **kwargs):\n    hy, cy = LSTMCellF(*args, **kwargs)\n    return torch.cat((hy, cy))\n\n\ndef LSTMCellS(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n    gates = x.mm(w_ih.t()) + hx.mm(w_hh.t()) + b_ih + b_hh\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = torch.sigmoid(ingate)\n    forgetgate = torch.sigmoid(forgetgate)\n    cellgate = torch.tanh(cellgate)\n    outgate = torch.sigmoid(outgate)\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * torch.tanh(cy)\n    return hy, cy\n\n\n# Code reference: https://github.com/pytorch/translate/blob/master/pytorch_translate/rnn_cell.py#L27:44\ndef MiLSTMCell(x, hx, cx, w_ih, w_hh, alpha, beta_i, beta_h, bias):\n    Wx = x.mm(w_ih.t())\n    Uz = hx.mm(w_hh.t())\n    # Section 2.1 in https://arxiv.org/pdf/1606.06630.pdf\n    gates = alpha * Wx * Uz + beta_i * Wx + beta_h * Uz + bias\n    # Same as LSTMCell after this point\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = ingate.sigmoid()\n    forgetgate = forgetgate.sigmoid()\n    cellgate = cellgate.tanh()\n    outgate = outgate.sigmoid()\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * cy.tanh()\n    return hy, cy\n\n\n\ndef get_lstm_inputs(device, training=False, seq_length=None):\n    input_shape = (3, 10) if seq_length is None else (seq_length, 3, 10)\n    input = torch.randn(*input_shape, dtype=torch.float, device=device, requires_grad=training)\n    hx = torch.randn(3, 20, dtype=torch.float, device=device, requires_grad=training)\n    cx = torch.randn(3, 20, dtype=torch.float, device=device, requires_grad=training)\n    module = nn.LSTMCell(10, 20).to(device, torch.float)  # Just to allocate weights with correct sizes\n    if training:\n        params = tuple(module.parameters())\n    else:\n        params = tuple(p.requires_grad_(False) for p in module.parameters())\n    return (input, hx, cx) + params\n\n\ndef get_milstm_inputs(device, training=False):\n    minibatch = 3\n    input_size = 10\n    hidden_size = 20\n    x = torch.randn(minibatch, input_size, device=device, dtype=torch.float)\n    hx = torch.randn(minibatch, hidden_size, device=device, dtype=torch.float)\n    cx = torch.randn(minibatch, hidden_size, device=device, dtype=torch.float)\n\n    ih = torch.randn(4 * hidden_size, input_size, device=device, dtype=torch.float, requires_grad=training)\n    hh = torch.randn(4 * hidden_size, hidden_size, device=device, dtype=torch.float, requires_grad=training)\n    alpha = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    ibeta = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    hbeta = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    bias = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    return x, hx, cx, ih, hh, alpha, ibeta, hbeta, bias\n\n\ndef get_fn(file_name, script_path):\n    import importlib.util\n    spec = importlib.util.spec_from_file_location(file_name, script_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    fn = module.fn\n    return fn\n\ndef get_grad_executor(plan_state, diff_graph_idx=None, skip_check=False):\n    if diff_graph_idx is None:\n        nodes = list(plan_state.graph.nodes())\n\n        if not skip_check:\n            nodes = list(filter(lambda n : n.kind() != \"prim::BailOut\" and n.kind() != \"prim::BailoutTemplate\", nodes))\n            if len(nodes) == 1 or (len(nodes) == 2 and nodes[1].kind() == \"prim::TupleConstruct\"):\n                pass\n            elif len(nodes) == 2 and nodes[0].kind() == \"prim::RequiresGradCheck\" and nodes[1].kind() == \"prim::If\":\n                pass\n            else:\n                raise RuntimeError(\"Can't get a grad_executor for a non-differentiable graph\")\n    grad_executors = list(plan_state.code.grad_executor_states())\n    return grad_executors[diff_graph_idx or 0]\n\n\ndef all_backward_graphs(script_module, diff_graph_idx=None):\n    # Note: for Python 2 the order seems to be unstable\n    ge_state = script_module.get_debug_state()\n    fwd_plan = get_execution_plan(ge_state)\n    grad_executor_state = get_grad_executor(fwd_plan, diff_graph_idx=diff_graph_idx)\n    bwd_plans = list(grad_executor_state.execution_plans.values())\n    return [p.graph.copy() for p in bwd_plans]\n\n\ndef backward_graph(script_module, diff_graph_idx=None, skip_check=False):\n    ge_state = script_module.get_debug_state()\n    fwd_plan = get_execution_plan(ge_state)\n    grad_executor_state = get_grad_executor(fwd_plan, diff_graph_idx=diff_graph_idx, skip_check=skip_check)\n    bwd_plan = get_execution_plan(grad_executor_state)\n    # Running JIT passes requires that we own the graph (with a shared_ptr).\n    # The debug state struct does not own its graph so we make a copy of it.\n    return bwd_plan.graph.copy()\n\n\n# helper function to get sum of List[Tensor]\ndef _sum_of_list(tensorlist):\n    s = 0\n    for t in tensorlist:\n        s += t.sum()\n    return s\n\n\n# has to be at top level or Pickle complains\nclass FooToPickle(torch.nn.Module):\n    def __init__(self):\n        super(FooToPickle, self).__init__()\n        self.bar = torch.jit.ScriptModule()\n\nclass TestJit(JitTestCase):\n    @unittest.skip(\"Requires a lot of RAM\")\n    def test_big(self):\n        m = torch.jit.ScriptModule()\n        gig = int(1024 * 1024 * 1024 / 4)\n        # a small tensor in the first 4GB\n        m.v0 = nn.Parameter(torch.full((2,), 1, dtype=torch.float))\n        # a large tensor in the first 4GB that ends outside of it\n        m.v1 = nn.Parameter(torch.full((5, gig), 2, dtype=torch.float))\n        # a small tensor in >4GB space\n        m.v2 = nn.Parameter(torch.full((2,), 3, dtype=torch.float))\n        # s large tensor in the > 4GB space\n        m.v3 = nn.Parameter(torch.full((5, gig), 4, dtype=torch.float))\n\n        m2 = self.getExportImportCopy(m)\n\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n\n    def test_inferred_as_tensor(self):\n        with self.assertRaisesRegex(RuntimeError, \"Inferred the value for argument 'dim' to be of type 'Tensor' \"\n                                                  \"because it was not annotated with an explicit type\"):\n            @torch.jit.script\n            def dot(points, query, dim):\n                return (points * query).sum(dim)\n\n    def test_constants_pkl(self):\n        # This test asserts that the serialization archive includes a `constants.pkl`\n        # file. This file is used by `torch.load` to determine whether a zip file\n        # is a normal eager-mode serialization zip or a jit serialization zip. If\n        # you are deleting `constants.pkl`, make sure to update `torch.serialization.load`\n        # so it is still able to figure out which is which.\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        buf = io.BytesIO()\n        torch.jit.save(fn, buf)\n        buf.seek(0)\n\n        files = zipfile.ZipFile(buf).filelist\n        self.assertTrue(any(['archive/constants.pkl' == f.filename for f in files]))\n\n    def test_script_fn_pkl(self):\n        with self.assertRaisesRegex(pickle.PickleError, \"ScriptFunction cannot be pickled\"):\n\n            @torch.jit.script\n            def fn(x: torch.Tensor) -> torch.Tensor:\n                return x\n\n            pkl_fn = pickle.dumps(fn, protocol=0)\n\n    def test_restore_device(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, cpu_device_str):\n                super(M, self).__init__()\n                self.p0 = nn.Parameter(torch.tensor([0.3], dtype=torch.float,\n                                                    device=cpu_device_str))\n                self.b0 = torch.tensor([0.9], dtype=torch.float,\n                                       device=cpu_device_str)\n\n        # main purpose is checking map_location works\n        m = M(\"cpu\")\n        m2 = self.getExportImportCopy(m)\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertFalse(m2.p0.is_cuda)\n        self.assertFalse(m2.b0.is_cuda)\n\n    @unittest.skipIf(not RUN_CUDA, \"restore device requires CUDA\")\n    def test_restore_device_cuda(self):\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.register_buffer('b0', torch.randn(1, 3))\n                self.p0 = nn.Parameter(torch.randn(2, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.b0 + self.p0\n\n        m = MyModule()\n        m.cuda(torch.cuda.device_count() - 1)\n        cuda_device_str = 'cuda:' + str(torch.cuda.device_count() - 1)\n\n        self.assertTrue(m.p0.is_cuda)\n        self.assertTrue(m.b0.is_cuda)\n\n        # restore to the saved devices\n        m2 = self.getExportImportCopy(m)\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertEqual(str(m2.p0.device), cuda_device_str)\n        self.assertEqual(str(m2.b0.device), cuda_device_str)\n\n        # restore all to cpu using string\n        cpu_device_str = 'cpu'\n        m3 = self.getExportImportCopy(m, map_location=cpu_device_str)\n        self.assertEqual(str(m3.p0.device), cpu_device_str)\n        self.assertEqual(str(m3.b0.device), cpu_device_str)\n\n        # restore all to first gpu using device\n        m4 = self.getExportImportCopy(\n            m3, map_location=torch.device('cuda:0'))\n        self.assertEqual(str(m4.p0.device), 'cuda:0')\n        self.assertEqual(str(m4.b0.device), 'cuda:0')\n\n        # compute and compare the results\n        input = torch.rand(2, 3).cuda(torch.cuda.device_count() - 1)\n        origin_result = m(input)\n        self.assertEqual(origin_result, m2(input))\n        self.assertEqual(origin_result, m3(input.cpu()))\n        self.assertEqual(origin_result, m4(input.cuda(0)))\n\n    def test_trace_retains_train(self):\n        class M(torch.nn.Module):\n            def forward(self, x):\n                return x\n        m = M()\n        m.eval()\n        tm = torch.jit.trace(m, (torch.rand(3)))\n        self.assertEqual(tm.training, m.training)\n\n    @unittest.skipIf(not RUN_CUDA, \"restore device requires CUDA\")\n    def test_restore_shared_storage_on_cuda(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                whole_tensor = torch.randn(4, 5, dtype=torch.float, device='cpu')\n                self.p0 = nn.Parameter(whole_tensor.narrow(0, 0, 1))\n                self.register_buffer('b0', whole_tensor.narrow(0, 3, 1))\n\n        m = Foo()\n        m2 = self.getExportImportCopy(m, map_location=torch.device('cuda:0'))\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertTrue(m2.p0.is_cuda)\n        self.assertTrue(m2.b0.is_cuda)\n        self.assertTrue(m2.p0.is_shared())\n        self.assertTrue(m2.b0.is_shared())\n        self.assertEqual(m2.b0.storage().data_ptr(), m2.p0.storage().data_ptr())\n\n    def test_add_relu_fusion(self):\n        class M(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(M, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b, c):\n                tmp = torch.add(a, b)\n                x = self.relu_op(tmp)\n                d = torch.add(a, c)\n                return x + d\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        c = torch.rand((7, 11))\n        m = torch.jit.script(M(torch.relu))\n        orig_res = m(a, b, c)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a, b, c)\n        FileCheck().check_not(\"aten::relu(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n\n        # add, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        c = torch.rand((7, 11))\n        m = torch.jit.script(M(torch.relu_))\n        orig_res = m(a, b, c)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a, b, c)\n        FileCheck().check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n\n        class Madd_(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(Madd_, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b):\n                x = a.add_(b)\n                x = self.relu_op(x)\n                return x\n\n        # add_, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        # Because in place add_ will overwrite a\n        a_copy = a.clone()\n        m = torch.jit.script(Madd_(torch.relu_))\n        orig_res = m(a, b)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a_copy, b)\n        FileCheck().check_not(\"aten::add_(\") \\\n            .check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu_(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n        # Since _add_relu_ does inplace mutation ensure\n        # a_copy is modified\n        torch.testing.assert_close(orig_res, a_copy)\n\n        class Madd_out(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(Madd_out, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b):\n                x = torch.add(a, b, out=a)\n                x = self.relu_op(x)\n                return x\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n\n        # add_out, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        # Because in place add_ will overwrite a\n        a_copy = a.clone()\n        m = torch.jit.script(Madd_out(torch.relu_))\n        orig_res = m(a, b)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a_copy, b)\n        FileCheck().check_not(\"aten::add(\") \\\n            .check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n        # Since _add_relu_ with out=a does inplace mutation ensure\n        # a_copy is modified\n        torch.testing.assert_close(orig_res, a_copy)\n\n    def test_repeat_interleave_script(self):\n        def fn(input: torch.Tensor, repeats: torch.Tensor) -> torch.Tensor:\n            output = input.repeat_interleave(repeats)\n            return output\n        fn_scripted = torch.jit.script(fn)\n\n        input = torch.tensor([5, 7], dtype=torch.int64)\n        repeats = torch.tensor([3, 6], dtype=torch.int64)\n\n        output = fn(input, repeats)\n        output_scripted = fn_scripted(input, repeats)\n        self.assertEqual(output_scripted, output)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"Simple executor doesn't have shape information\")\n    def test_peephole_optimize_shape_ops(self):\n        def test_input(func, input, result):\n            # if result == 2 we will trigger a bailout and\n            # the unprofiled graph should return the correct result\n            self.assertEqual(func(input, profile_and_replay=True), result)\n            gre = func.graph_for(input)\n            FileCheck().check_not(\"prim::If\").run(gre)\n\n        def test_dim():\n            @torch.jit.script\n            def func(x):\n                if x.dim() == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor([0.5]), 1)\n            test_input(func, torch.tensor([[0.5]]), 2)\n        test_dim()\n\n        def test_size_index():\n            @torch.jit.script\n            def func(x):\n                if x.size(0) == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.rand([1, 2]), 1)\n            test_input(func, torch.rand([1, 3]), 1)\n\n            @torch.jit.script\n            def neg_index(x):\n                if x.size(-2) == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(neg_index, torch.rand([1, 2]), 1)\n            test_input(neg_index, torch.rand([1, 3]), 1)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            test_size_index()\n\n        def test_dtype():\n            @torch.jit.script\n            def func(x):\n                if x.dtype == torch.float32:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor(0.5, dtype=torch.float32), 1)\n            test_input(func, torch.tensor(0.5, dtype=torch.int64), 2)\n        test_dtype()\n\n        def test_is_floating_poiint():\n            @torch.jit.script\n            def func(x):\n                if x.is_floating_point():\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor(0.5, dtype=torch.float32), 1)\n            test_input(func, torch.tensor(0.5, dtype=torch.int64), 2)\n        test_is_floating_poiint()\n\n        def test_device():\n            @torch.jit.script\n            def func_1(x):\n                if x.device == torch.device('cuda:0'):\n                    a = 0\n                else:\n                    a = 1\n                return a\n\n            @torch.jit.script\n            def func_2(x):\n                if x.is_cuda:\n                    a = 0\n                else:\n                    a = 1\n                return a\n\n            test_input(func_1, torch.tensor(0.5), 1)\n            test_input(func_2, torch.tensor(0.5), 1)\n\n            if RUN_CUDA:\n                test_input(func_1, torch.tensor(0.5, device=\"cuda:0\"), 0)\n                test_input(func_2, torch.tensor(0.5, device=\"cuda:0\"), 0)\n\n        test_device()\n\n    def test_attrs(self):\n        def foo(x):\n            return (\n                # x.dtype, TODO: dtype long -> instance conversion\n                x.device,\n                x.shape,\n                x.is_cuda,\n                x.is_mkldnn,\n                x.is_quantized,\n                x.requires_grad,\n                x.T,\n                x.mT,\n                x.H,\n                x.mH\n                # x.layout TODO: layout long -> instance conversion\n            )\n\n        scripted = torch.jit.script(foo)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted(x), foo(x))\n\n    def test_layout(self):\n        @torch.jit.script\n        def check(x, y):\n            return x.layout == y.layout\n\n        x = torch.rand(3, 4)\n        y = torch.rand(3, 4)\n\n        self.assertTrue(check(x, y))\n\n    def test_matrix_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.mT, x.transpose(-2, -1))\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n    def test_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.T, x.t())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n    def test_matrix_conj_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.mH, x.transpose(-2, -1).conj())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n        x = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n        self.assertTrue(check(x))\n\n    def test_conj_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.H, x.t().conj())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n        x = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n        self.assertTrue(check(x))\n\n    def test_T_mT_H_mH(self):\n        def T(x):\n            return x.mT\n\n        def mT(x):\n            return x.mT\n\n        def H(x):\n            return x.H\n\n        def mH(x):\n            return x.mH\n\n        x = torch.rand(3, 4)\n        y = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n\n        self.checkScript(T, (x, ))\n        self.checkScript(mT, (x, ))\n        self.checkScript(H, (x, ))\n        self.checkScript(mH, (x, ))\n        self.checkScript(T, (y, ))\n        self.checkScript(mT, (y, ))\n        self.checkScript(H, (y, ))\n        self.checkScript(mH, (y, ))\n\n    def test_nn_conv(self):\n        class Mod(nn.Module):\n            def __init__(self, conv):\n                super().__init__()\n                self.conv = conv\n\n            def forward(self, input):\n                return self.conv(input)\n\n        inputs = [\n            # Conv\n            (Mod(nn.Conv1d(16, 33, 3, stride=2)), torch.randn(20, 16, 5)),\n            (Mod(nn.Conv2d(16, 33, 3, stride=2)), torch.randn(20, 16, 5, 10)),\n            (Mod(nn.Conv3d(16, 33, 3, stride=2)), torch.randn(20, 16, 3, 5, 4)),\n            # ConvTransposed\n            (Mod(nn.ConvTranspose1d(16, 33, 3, stride=2)), torch.randn(20, 16, 5)),\n            (Mod(nn.ConvTranspose2d(16, 33, 3, stride=2)), torch.randn(20, 16, 5, 10)),\n            (Mod(nn.ConvTranspose3d(16, 33, 3, stride=2)), torch.randn(20, 16, 3, 5, 4)),\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, 'Not implemented for Simple or Legacy')\n    def test_debug_flush_compilation_cache(self):\n        def foo(x):\n            return x + 2\n\n        class Mod(nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n\n            def forward(self, t):\n                return t + 2\n\n        m = torch.jit.script(Mod())\n        x = torch.rand(1, 10)\n\n        with enable_profiling_mode_for_profiling_tests():\n            jitted = self.checkScript(foo, (x,))\n            # shouldn't throw\n            states = jitted.get_debug_state()\n\n            # after flushing there shouldn't be\n            # no opt plan\n            jitted._debug_flush_compilation_cache()\n            with self.assertRaisesRegex(RuntimeError, \"INTERNAL ASSERT FAILED\"):\n                states = jitted.get_debug_state()\n\n            NUM_RUNS = 1\n            with num_profiled_runs(NUM_RUNS):\n                m(x)\n                m(x)\n                fwd = m._c._get_method(\"forward\")\n                states = m.get_debug_state()\n\n                # after flushing there shouldn't be\n                # no opt plan\n                fwd._debug_flush_compilation_cache()\n                with self.assertRaisesRegex(RuntimeError, \"INTERNAL ASSERT FAILED\"):\n                    states = m.get_debug_state()\n\n    def test_numel(self):\n        @torch.jit.script\n        def get_numel_script(x):\n            return x.numel()\n\n        x = torch.rand(3, 4)\n        numel = get_numel_script(x)\n        self.assertEqual(numel, x.numel())\n\n    def test_element_size(self):\n        @torch.jit.script\n        def get_element_size_script(x):\n            return x.element_size()\n\n        x = torch.rand(3, 4)\n        element_size = get_element_size_script(x)\n        self.assertEqual(element_size, x.element_size())\n\n    def test_Sequential(self):\n        class Seq(nn.Module):\n            def __init__(self):\n                super(Seq, self).__init__()\n                self.seq = nn.Sequential(nn.Linear(10, 20), nn.Linear(20, 30))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for l in self.seq:\n                    x = l(x)\n                return x\n\n        m = torch.jit.script(Seq())\n        assert m.graph  # ensure jit was able to compile\n\n    def test_ModuleList(self):\n        class Mod(nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.model = nn.ModuleList([nn.Linear(10, 10) for _ in range(10)])\n                self.model += (nn.Linear(10, 20),)\n                self.model.append(nn.Linear(20, 30))\n                self.model.extend([nn.Linear(30, 40), nn.Linear(40, 50)])\n\n            def forward(self, v):\n                for m in self.model:\n                    v = m(v)\n                return v\n\n        m = torch.jit.script(Mod())\n        assert m.graph  # ensure jit was able to compile\n\n    def test_disabled(self):\n        torch.jit._state.disable()\n        try:\n            def f(x, y):\n                return x + y\n\n            self.assertIs(torch.jit.trace(f, (torch.randn(2, 2), torch.randn(2, 2))), f)\n            self.assertIs(torch.jit.script(f), f)\n\n            class MyModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def method(self, x):\n                    return x\n\n            # XXX: Unfortunately ScriptModule won't simply become Module now,\n            # because that requires disabling the JIT at startup time, which\n            # we can't do in here.\n            # We need to or those two conditions to make it work with all versions of Python\n            self.assertTrue(inspect.ismethod(MyModule.method) or inspect.isfunction(MyModule.method))\n        finally:\n            torch.jit._state.enable()\n\n    def test_train_eval(self):\n        class Sub(nn.Module):\n            def forward(self, input):\n                if self.training:\n                    return input\n                else:\n                    return -input\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, module):\n                super(MyModule, self).__init__()\n                self.module = module\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.module(input) + 1\n\n        m = MyModule(Sub())\n        input = torch.rand(3, 4)\n        self.assertEqual(input + 1, m(input))\n        m.eval()\n        self.assertEqual(-input + 1, m(input))\n\n        # test batchnorm and dropout train/eval\n        input = torch.randn(6, 10)\n        batchnorm = nn.BatchNorm1d(10)\n        dropout = nn.Dropout(p=0.2)\n\n        m_batchnorm = MyModule(batchnorm)\n        self.assertEqual(batchnorm(input) + 1, m_batchnorm(input))\n        batchnorm.eval()\n        m_batchnorm.eval()\n        self.assertEqual(batchnorm(input) + 1, m_batchnorm(input))\n\n        m_dropout = MyModule(dropout)\n        dropout.eval()\n        m_dropout.eval()\n        self.assertEqual(dropout(input) + 1, m_dropout(input))\n\n    def test_nn_lp_pool2d(self):\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.l = torch.nn.LPPool2d(2, 3)\n                self.n = torch.nn.LPPool2d(2, (7, 1))\n\n            def forward(self, x):\n                return (self.l(x),\n                        self.n(x),\n                        torch.nn.functional.lp_pool2d(x, float(2), 3),\n                        torch.nn.functional.lp_pool2d(x, 2, 3),\n                        torch.nn.functional.lp_pool2d(x, float(2), (7, 1)))\n\n        self.checkModule(Mod(), (torch.rand(1, 3, 7, 7),))\n\n    def test_nn_lp_pool1d(self):\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.l = torch.nn.LPPool1d(2, 3)\n                self.n = torch.nn.LPPool1d(2, 7)\n\n            def forward(self, x):\n                return (self.l(x),\n                        self.n(x),\n                        torch.nn.functional.lp_pool1d(x, float(2), 3),\n                        torch.nn.functional.lp_pool1d(x, 2, 3),\n                        torch.nn.functional.lp_pool1d(x, float(2), 7))\n\n        self.checkModule(Mod(), (torch.rand(1, 3, 7),))\n\n    def test_nn_padding_functional(self):\n        class Mod(nn.Module):\n            def __init__(self, *pad):\n                super().__init__()\n                self.pad = pad\n\n            def forward(self, x):\n                return F.pad(x, self.pad, mode='constant', value=3.5)\n\n        inputs = [\n            (Mod(1, 2), torch.randn(1, 3, 4)),  # 1D\n            (Mod(1, 2, 3, 4), torch.randn(1, 3, 4)),  # 2D\n            (Mod(1, 2, 3, 4, 5, 6), torch.randn(1, 3, 4)),  # 3D\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    def test_nn_padding(self):\n        class Mod(nn.Module):\n            def __init__(self, padding):\n                super().__init__()\n                self.padding = padding\n\n            def forward(self, input):\n                return self.padding(input)\n\n        inputs = [\n            (Mod(nn.ConstantPad1d(2, 3.5)), torch.randn(1, 2, 4)),\n            (Mod(nn.ConstantPad2d(2, 3.5)), torch.randn(1, 2, 2)),\n            (Mod(nn.ConstantPad3d(3, 3.5)), torch.randn(16, 3, 10, 20, 30)),\n            (Mod(nn.ReflectionPad1d(2)), torch.arange(8, dtype=torch.float).reshape(1, 2, 4)),\n            (Mod(nn.ReflectionPad2d(2)), torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)),\n            (Mod(nn.ReflectionPad3d(3)), torch.randn(16, 3, 8, 32, 48)),\n            (Mod(nn.ReplicationPad1d(2)), torch.arange(8, dtype=torch.float).reshape(1, 2, 4)),\n            (Mod(nn.ReplicationPad2d(2)), torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)),\n            (Mod(nn.ReplicationPad3d(3)), torch.randn(16, 3, 8, 32, 48)),\n            (Mod(nn.ZeroPad2d(2)), torch.randn(1, 1, 3, 3))\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    def test_script_autograd_grad(self):\n        def test_simple_grad(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = x + 2 * y + x * y\n            return torch.autograd.grad((z.sum(), ), (x, y))\n\n        def test_simple_grad_with_grad_outputs(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = x + 2 * y + x * y\n            grad_outputs = torch.jit.annotate(List[Optional[torch.Tensor]], [torch.ones((2, 2)), ])\n            return torch.autograd.grad((z, ), (x, y), grad_outputs)\n\n        def test_one_output_not_requires_grad(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = 2 * y + y\n            return torch.autograd.grad((z.sum(),), (x, y), allow_unused=True)\n\n        def test_retain_graph(x, y):\n            # type: (Tensor, Tensor) -> None\n            z = x + 2 * y + x * y\n            torch.autograd.grad((z.sum(), ), (x, y), retain_graph=True)\n            torch.autograd.grad((z.sum(), ), (x, y))\n\n        x = torch.randn(2, 2, requires_grad=True)\n        y = torch.randn(2, 2, requires_grad=True)\n        self.checkScript(test_simple_grad, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_simple_grad_with_grad_outputs, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_one_output_not_requires_grad, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_retain_graph, (x, y), inputs_requires_grad=True)\n\n    def test_script_backward(self):\n        def checkBackwardScript(fn, inputs):\n            scripted_fn = torch.jit.script(fn)\n            FileCheck().check(\"torch.autograd.backward\").run(scripted_fn.code)\n            recording_inputs = do_input_map(lambda t: t.detach().requires_grad_(), inputs)\n\n            fn(*inputs)\n            scripted_fn(*recording_inputs)\n\n            for inp1, inp2 in zip(inputs, recording_inputs):\n                self.assertEqual(inp1.grad, inp2.grad)\n\n        def test_tensor_backward(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            sum_out = output.sum()\n            sum_out.backward()\n\n        def test_torch_autograd_backward(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            torch.autograd.backward(output.sum())\n\n        def test_torch_autograd_backward_with_grad_tensors(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            grad_outputs = torch.jit.annotate(List[Optional[torch.Tensor]], [torch.ones((2, 2)), ])\n            torch.autograd.backward((output,), grad_outputs)\n\n        inp = torch.randn(2, 2, requires_grad=True)\n        checkBackwardScript(test_tensor_backward, (inp,))\n        checkBackwardScript(test_torch_autograd_backward, (inp,))\n        checkBackwardScript(test_torch_autograd_backward_with_grad_tensors, (inp,))\n\n    def test_script_backward_twice(self):\n        def checkBackwardTwiceScript(fn, inputs, retain_graph_=False):\n            torch._C._jit_set_profiling_executor(False)\n\n            with torch.jit.optimized_execution(True):\n                scripted_fn = torch.jit.script(fn, inputs)\n                FileCheck().check(\"prim::DifferentiableGraph\").run(scripted_fn.graph_for(*inputs))\n\n                result = scripted_fn(*inputs)\n                result.sum().backward(retain_graph=retain_graph_)\n                if not retain_graph_:\n                    self.assertRaisesRegex(RuntimeError, 'Specify retain_graph=True',\n                                           lambda: result.sum().backward())\n                else:\n                    result.sum().backward()\n\n        def test_script_backward_twice_with_saved_values(input1, input2):\n            # type: (Tensor, Tensor) -> Tensor\n            tmp1 = torch.mul(input1, input2)\n            tmp2 = torch.abs(tmp1)\n            if torch.equal(input1, input2):\n                tmp2 = torch.acos(tmp2)\n            else:\n                tmp2 = torch.atan(tmp2)\n            result = torch.add(tmp2, input2)\n            return result\n\n        inp1 = torch.randn(2, 2, requires_grad=True)\n        inp2 = torch.randn(2, 2, requires_grad=True)\n        checkBackwardTwiceScript(test_script_backward_twice_with_saved_values, (inp1, inp2), False)\n        checkBackwardTwiceScript(test_script_backward_twice_with_saved_values, (inp1, inp2), True)\n\n    def test_diff_subgraph_clones_constants(self):\n        @torch.jit.script\n        def f(x, y):\n            return x + x + y + x + y + x + y + x + y + x\n\n        def count_constants(graph):\n            return sum(node.kind() == 'prim::Constant' for node in graph.nodes())\n\n        graph = f.graph.copy()\n        self.run_pass('cse', graph)\n        self.run_pass('create_autodiff_subgraphs', graph)\n        nodes = list(graph.nodes())\n        self.assertEqual(count_constants(graph), 1)\n        self.assertEqual(count_constants(nodes[1].g('Subgraph')), 1)\n\n    # TODO: adapt this test to check that GraphExecutor treats them differently\n    @unittest.skip(\"Need to be adjusted to Graph Executor\")\n    def test_arg_configurations(self):\n        \"\"\"Different arg configurations should trigger different traces\"\"\"\n        x = Variable(torch.FloatTensor(4, 4).uniform_())\n        x_double = Variable(x.data.double())\n        x_grad = Variable(x.data.clone(), requires_grad=True)\n        y = Variable(torch.randn(4))\n\n        configurations = [\n            (x,),\n            (x_double,),\n            (x_grad,),\n            (y,),\n            ([x, x],),\n            ([x, y],),\n        ]\n        if torch.cuda.is_available():\n            x_cuda = Variable(x.data.cuda())\n            configurations += [\n                (x_cuda,),\n                ([x, x_cuda],),\n                ([x_cuda, x],),\n                ([[x_cuda, x]],),\n            ]\n            if torch.cuda.device_count() > 1:\n                x_cuda_1 = Variable(x.data.cuda(1))\n                configurations += [\n                    (x_cuda_1,),\n                    ([x_cuda, x_cuda_1],),\n                ]\n\n        @torch.jit.compile(nderivs=0)\n        def fn(*args):\n            in_vars, _ = torch._C._jit_flatten(args)\n            return in_vars[0] + 1\n\n        for i, config in enumerate(configurations):\n            self.assertFalse(fn.has_trace_for(*config))\n            fn(*config)\n            self.assertTrue(fn.has_trace_for(*config))\n            for unk_config in configurations[i + 1:]:\n                self.assertFalse(fn.has_trace_for(*unk_config))\n        self.assertEqual(fn.hits, 0)\n\n    def test_torch_sum(self):\n        def fn(x):\n            return torch.sum(x)\n\n        def fn1(x, dim: int):\n            return torch.sum(x, dim)\n\n        x = torch.randn(3, 4)\n        self.checkScript(fn, (x, ))\n        self.checkScript(fn1, (x, 1, ))\n        self.checkScript(fn1, (x, 0, ))\n\n    def test_cse(self):\n        x = torch.tensor([0.4, 0.3], requires_grad=True)\n        y = torch.tensor([0.7, 0.5], requires_grad=True)\n\n        def fn(x, y):\n            w = (x + y) * (x + y) * (x + y)\n            t = torch.tanh(w) + torch.tanh(w)\n            z = (x + y) * (x + y) * (x + y) + t\n            return z\n\n        g, _ = torch.jit._get_trace_graph(fn, (x, y))\n        self.run_pass('cse', g)\n        do_exactly = True\n        FileCheck().check_count(\"add\", 1).check_count(\"mul\", 2, do_exactly) \\\n            .check_count(\"tanh\", 1, do_exactly).check_count(\"add\", 2, do_exactly).check_next(\"return\")  \\\n            .run(str(g))\n\n        self.assertExportImport(g, (x, y))\n\n    def test_cse_not_introduce_aliasing(self):\n        @torch.jit.script\n        def tensor_alias_outputs(x):\n            return x + x, x + x\n\n        self.run_pass('cse', tensor_alias_outputs.graph)\n        FileCheck().check_count(\"aten::add\", 2).run(tensor_alias_outputs.graph)\n\n        @torch.jit.script\n        def ints_alias_outputs(x):\n            # type: (int) -> Tuple[int, int]\n            return x + x, x + x\n\n        # non-aliasing types can be CSEd\n        self.run_pass('cse', ints_alias_outputs.graph)\n        FileCheck().check_count(\"aten::add\", 1, exactly=True).run(ints_alias_outputs.graph)\n\n    def test_recursive_cse(self):\n        input_str = \"\"\"\ngraph(%x : Tensor,\n      %y : Tensor,\n      %20 : int):\n  %2 : int = prim::Constant[value=1]()\n  %3 : Tensor = aten::add(%x, %y, %2)\n  %4 : int = aten::add(%2, %20)\n  %5 : bool = aten::Bool(%4)\n  %z : int = prim::If(%5)\n    # CHECK: block\n    block0():\n      # CHECK-NOT: aten::add\n      %z.1 : int = aten::add(%2, %20)\n      -> (%z.1)\n    block1():\n      -> (%2)\n  return (%z)\n\"\"\"\n        graph = parse_ir(input_str)\n        self.run_pass('cse', graph)\n        FileCheck().run(input_str, graph)\n\n    def test_pattern_based_rewrite(self):\n        # mul(mul(mul(mul(x,y),z),x),y) --> mul(mul(mulmul(x,y,z), x), y) -->\n        # --> mulmul(mulmul(x,y,z), x, y)\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK: my::fused_mulmul\n    %t = aten::mul(%x, %y)\n    %p = aten::mul(%t, %z)\n    # CHECK: my::fused_mulmul\n    %u = aten::mul(%p, %x)\n    %o = aten::mul(%u, %y)\n    return (%o)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c):\n  %q = aten::mul(%a, %b)\n  %r = aten::mul(%q, %c)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c):\n  %r = my::fused_mulmul(%a, %b, %c)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check that overlapping matches are handled correctly\n        # mul(mul(mul(x,y),z),x) --> mul(mulmul(x,y,z), x)\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK: my::fused_mulmul\n    %t = aten::mul(%x, %y)\n    %p = aten::mul(%t, %z)\n    # CHECK-NEXT: aten::mul\n    %u = aten::mul(%p, %x)\n    return (%u)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c):\n  %q = aten::mul(%a, %b)\n  %r = aten::mul(%q, %c)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c):\n  %r = my::fused_mulmul(%a, %b, %c)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check add(mul(x,y),z) --> muladd(x,y,z) replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK-NOT: aten::add\n    %c = prim::Const[value=1]()\n    %t = aten::mul(%x, %y)\n    %p = aten::add(%t, %z, %c)\n    # CHECK: my::muladd\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::mul(%a, %b)\n  %r = aten::add(%q, %c, %d)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c, %d):\n  %r = my::muladd(%a, %b, %c, %d)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check add(mul(x,y),z) --> sub(add(x,y),z) replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    %c = prim::Const[value=1]()\n    # CHECK: aten::add\n    %t = aten::mul(%x, %y)\n    # CHECK-NEXT: aten::sub\n    %p = aten::add(%t, %z, %c)\n    # CHECK-NOT: aten::add\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::mul(%a, %b)\n  %r = aten::add(%q, %c, %d)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::add(%a, %b, %d)\n  %r = aten::sub(%q, %c, %d)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check mul(x,y) --> x replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    %c = prim::Const[value=1]()\n    # CHECK-NOT: aten::mul\n    %t = aten::mul(%x, %y)\n    # CHECK: aten::add(%x, %z\n    %p = aten::add(%t, %z, %c)\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%Pa, %Pb):\n  %Pq = aten::mul(%Pa, %Pb)\n  return (%Pq)\"\"\", \"\"\"\ngraph(%Ra, %Rb):\n  return (%Ra)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_pattern_based_module_rewrite(self):\n        # Check match::module behavior\n        class Test(torch.nn.Module):\n            def __init__(self):\n                super(Test, self).__init__()\n                self.conv = torch.nn.Conv2d(1, 20, 5, 1)\n                self.bn = torch.nn.BatchNorm2d(num_features=20)\n\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return x\n        m = torch.jit.script(Test())\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\n        graph(%self, %x):\n                %conv = match::module[name=\"Conv2d\"](%self)\n                %y = prim::CallMethod[name=\"forward\"](%conv, %x)\n                %bn = match::module[name=\"BatchNorm2d\"](%self)\n                %z = prim::CallMethod[name=\"forward\"](%bn, %y)\n                return (%z)\"\"\", \"\"\"\n        graph(%self, %x):\n          %z = my::matched_conv_bn(%self, %x)\n          return (%z)\"\"\", m._c._get_method(\"forward\").graph)\n\n        FileCheck().check(\"my::matched_conv_bn\").run(m._c._get_method(\"forward\").graph)\n\n    def test_pattern_based_rewrite_with_source_range_preserved(self):\n        class TestModule1(torch.nn.Module):\n            def __init__(self):\n                super(TestModule1, self).__init__()\n\n            def forward(self, x, y, z, w):\n                x = x + y\n                x = x * z\n                return w - x\n\n        input_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %t = aten::add(%x, %y, %const)\n            %o = aten::mul(%t, %z)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %o = my::add_mul(%x, %y, %z, %const)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule1())\n        graph = scripted_model.graph\n        value_mappings = [(\"o\", \"t\")]\n        for node in graph.nodes():\n            if node.kind() == \"aten::add\":\n                source_range_1 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, scripted_model.graph, value_name_pairs=value_mappings)\n        graph = scripted_model.graph\n        for node in graph.nodes():\n            if node.kind() == \"my::add_mul\":\n                source_range_2 = node.sourceRange()\n        self.assertTrue(source_range_1 == source_range_2)\n\n        class TestModule2(torch.nn.Module):\n            def __init__(self):\n                super(TestModule2, self).__init__()\n\n            def forward(self, x, y, z, w):\n                x = x + y\n                x = x + z\n                x = x * z\n                x = x * w\n                return x - 2\n\n        # Check source range preservation for two node transforms add -> my_add\n        input_pattern = \"\"\"\n        graph(%x, %y, %const):\n            %o = aten::add(%x, %y, %const)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %const):\n            %o = my::add(%x, %y, %const)\n            return (%o)\"\"\"\n        scripted_model = copy.deepcopy(torch.jit.script(TestModule2()))\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"o\", \"o\")]\n        source_range_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_add_1 is None and node.kind() == \"aten::add\":\n                source_range_add_1 = node.sourceRange()\n            if source_range_add_1 is not None and node.kind() == \"aten::add\":\n                source_range_add_2 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        source_range_my_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_my_add_1 is None and node.kind() == \"my::add\":\n                source_range_my_add_1 = node.sourceRange()\n            if source_range_my_add_1 is not None and node.kind() == \"my::add\":\n                source_range_my_add_2 = node.sourceRange()\n        self.assertTrue(source_range_add_1 == source_range_my_add_1)\n        self.assertTrue(source_range_add_2 == source_range_my_add_2)\n\n        # Check source range preservation for add-add -> double_add transform\n        # fuse nodes\n        input_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %t = aten::add(%x, %y, %const)\n            %o = aten::add(%t, %z, %const)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %o = my::double_add(%x, %y, %z, %const)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"o\", \"t\")]\n        source_range_1 = None\n        source_range_2 = None\n        for node in graph_copy.nodes():\n            if node.kind() == \"aten::add\":\n                source_range_1 = node.sourceRange()\n                break\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        for node in graph_copy.nodes():\n            if node.kind() == \"my::double_add\":\n                source_range_2 = node.sourceRange()\n        self.assertTrue(source_range_1 == source_range_2)\n\n        # Check source range preservation for mul -> add + add transform\n        # split node\n        input_pattern = \"\"\"\n        graph(%x, %y):\n            %t = aten::mul(%x, %y)\n            return (%t)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y):\n            %t = my::add(%x, %y)\n            %o = my::add(%t, %y)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"t\", \"t\"), (\"o\", \"t\")]\n        source_range_mul_1 = None\n        for node in graph_copy.nodes():\n            if source_range_mul_1 is None and node.kind() == \"aten::mul\":\n                source_range_mul_1 = node.sourceRange()\n            if source_range_mul_1 is not None and node.kind() == \"aten::mul\":\n                source_range_mul_2 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        source_range_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_add_1 is None and node.kind() == \"my::add\":\n                source_range_add_1 = node.sourceRange()\n            if source_range_add_1 is not None and node.kind() == \"my::add\":\n                source_range_add_2 = node.sourceRange()\n        self.assertTrue(source_range_mul_1 == source_range_add_1)\n        self.assertTrue(source_range_mul_2 == source_range_add_2)\n\n        # Check lack of source range preservation for mul-mul-> double_mul transform\n        input_pattern = \"\"\"\n        graph(%x, %y, %z):\n            %t = aten::mul(%x, %y)\n            %o = aten::mul(%t, %z)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z):\n            %o = my::double_mul(%x, %y, %z)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        for node in graph_copy.nodes():\n            if node.kind() == \"aten::mul\":\n                source_range_1 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(input_pattern, replacement_pattern, graph_copy)\n        for node in graph_copy.nodes():\n            if node.kind() == \"my::double_mul\":\n                source_range_2 = node.sourceRange()\n        self.assertFalse(source_range_1 == source_range_2)\n\n    def test_expand_quantlint(self):\n        pass\n\n    def test_expand_fold_quant_inputs(self):\n        pass\n\n    def test_shape_analysis_broadcast(self):\n        def broadcast(a, b):\n            return a + b\n\n        x = torch.randn(3, 1, 5, requires_grad=True)\n        y = torch.randn(4, 1, 8, 5, requires_grad=True)\n\n        graph = torch.jit.script(broadcast).graph\n        torch._C._jit_pass_complete_shape_analysis(graph, (x, y), False)\n        FileCheck().check(\"Double(4, 3, 8, 5, strides=[120, 40, 5, 1], device=cpu)\").run(str(graph))\n\n    def test_shape_analysis_unsqueeze_in_loop(self):\n        input_str = \"\"\"graph(%x.1 : Tensor):\n          %4 : bool = prim::Constant[value=1]()\n          %1 : int = prim::Constant[value=2]()\n          %7 : int = prim::Constant[value=0]()\n          # CHECK: FloatTensor(requires_grad=0, device=cpu) = prim::Loop\n          %x : Tensor = prim::Loop(%1, %4, %x.1)\n            # CHECK: : FloatTensor(requires_grad=0, device=cpu)):\n            block0(%i : int, %x.6 : Tensor):\n              # CHECK: FloatTensor(requires_grad=0, device=cpu) = aten::unsqueeze\n              %x.3 : Tensor = aten::unsqueeze(%x.6, %7)\n              -> (%4, %x.3)\n          return (%x)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_complete_shape_analysis(graph, (torch.zeros(2, 2, dtype=torch.float32),), False)\n        FileCheck().run(input_str, graph)\n\n    def test_script_tensor_type(self):\n        def foo(x, t: torch.dtype):\n            return x.type(t)\n        scr = torch.jit.script(foo)\n        x = torch.rand(3, 4)\n        for t in [torch.int8, torch.float64, torch.float32,\n                  torch.bfloat16, torch.complex64, torch.complex128, torch.bool]:\n            self.assertEqual(scr(x, t), foo(x, t))\n\n    def test_shape_analysis_masked_select(self):\n        input_str = \"\"\"graph(%0 : Float(),\n          %1 : Bool()):\n          # CHECK: Float(*, requires_grad=0, device=cpu) = aten::masked_select\n          %2 : Tensor = aten::masked_select(%0, %1) # test/test_jit.py:15261:0\n          return (%2)\"\"\"\n        graph = parse_ir(input_str)\n        x = torch.ones(1, dtype=torch.float32)[0]\n        mask = x.ge(0.5)\n        torch._C._jit_pass_complete_shape_analysis(graph, (x, mask), False)\n        FileCheck().run(input_str, graph)\n\n    # TODO: update verify to work with GraphExecutors\n    @unittest.skip(\"verify needs to be updated to work with GraphExecutors\")\n    def test_verify(self):\n        x = torch.tensor([0.4], requires_grad=True)\n        y = torch.tensor([0.7], requires_grad=True)\n\n        @torch.jit.compile\n        def f(x, y):\n            z = torch.sigmoid(x * (x + y))\n            w = torch.abs(x * x * x + y) + Variable(torch.ones(1))\n            return z, w\n\n        torch.jit.verify(f, (x, y), loss_fn=lambda z, w: z * w, devices=[])\n\n    # TODO: adapt to a GraphExecutor test\n    @unittest.skip(\"Need to instrument GraphExecutors a bit more\")\n    def test_flags(self):\n        x, y = torch.randn(2, 2)\n        y = Variable(torch.randn(2, 2))\n\n        @torch.jit.compile\n        def fn(x, y):\n            return (x * x + y * y + x * y).sum()\n\n        grads = {}\n        for rx, ry in product((True, False), repeat=2):\n            x.requires_grad = rx\n            y.requires_grad = ry\n\n            self.assertFalse(fn.has_trace_for(x, y))\n            out = fn(x, y)\n\n            self.assertFalse(fn.has_trace_for(x, y))\n            for v, name, compute in [(x, 'x', rx), (y, 'y', ry)]:\n                if not compute:\n                    continue\n                grad_v, = torch.autograd.grad(out, v, retain_graph=True)\n                expected_grad = grads.setdefault(name, grad_v)\n                self.assertEqual(grad_v, expected_grad)\n            self.assertEqual(fn.has_trace_for(x, y), rx or ry)\n\n    def test_python_ir(self):\n        x = torch.tensor([0.4], requires_grad=True)\n        y = torch.tensor([0.7], requires_grad=True)\n\n        def doit(x, y):\n            return torch.sigmoid(torch.tanh(x * (x + y)))\n\n        g, _ = torch.jit._get_trace_graph(doit, (x, y))\n        self.run_pass('dce', g)\n        self.run_pass('canonicalize', g)\n        g2 = torch._C.Graph()\n        g_to_g2 = {}\n        for node in g.inputs():\n            g_to_g2[node] = g2.addInput()\n        for node in g.nodes():\n            n_ = g2.createClone(node, lambda x: g_to_g2[x])\n            g2.appendNode(n_)\n            for o, no in zip(node.outputs(), n_.outputs()):\n                g_to_g2[o] = no\n\n        for node in g.outputs():\n            g2.registerOutput(g_to_g2[node])\n\n        t_node = g2.create(\"prim::TensorTest\").t_(\"a\", torch.ones([2, 2]))\n        self.assertEqual(t_node.attributeNames(), [\"a\"])\n        g2.appendNode(t_node)\n        self.assertTrue(torch.equal(torch.ones(2, 2), t_node.t(\"a\")))\n        for node in g.nodes():\n            self.assertTrue(g2.findNode(node.kind()) is not None)\n\n    def test_permute_inputs_binding(self):\n        @torch.jit.script\n        def foo(i, j, k):\n            pass\n\n        g = foo.graph\n\n        idxs = []\n        for i, inp in enumerate(g.inputs()):\n            inp.setDebugName(f\"inp{i}\")\n            idxs.append(i)\n\n        permuted_idxs = list(np.random.permutation(idxs))\n        g.permuteInputs(permuted_idxs)\n        for i, inp in enumerate(g.inputs()):\n            self.assertEqual(f\"inp{permuted_idxs[i]}\", inp.debugName())\n\n    @unittest.skipIf(IS_MACOS, \"Failing on MacOS only\")\n    def test_python_ir_utils(self):\n        @torch.jit.script\n        def foo(inp):\n            x = inp + 1\n            y = x / 2\n            z = y * y\n            return z\n\n        add_node = foo.graph.findNode(\"aten::add\")\n        div_node = foo.graph.findNode(\"aten::div\")\n\n        with foo.graph.insert_point_guard(add_node):\n            with foo.graph.insert_point_guard(div_node):\n                foo.graph.insertConstant(\"goodbye\")\n            foo.graph.insertConstant(\"hello\")\n        with foo.graph.insert_point_guard(foo.graph.findNode(\"aten::mul\")):\n            foo.graph.insertConstant(\"hello\")\n        FileCheck().check(\"hello\").check(\"goodbye\").check(\"hello\").run(foo.graph)\n\n        self.assertTrue(add_node.matches(add_node.schema()))\n        self.assertFalse(add_node.matches(div_node.schema()))\n\n    def test_python_ir_utils_graph(self):\n        @torch.jit.script\n        def unrolled_mul(x: torch.Tensor, y: int):\n            out = x\n            for _ in range(y - 1):\n                out = out + x\n            return out\n\n        @torch.jit.script\n        def foo(x):\n            return x * 4\n\n        g = foo.graph\n        muls = g.findAllNodes(\"aten::mul\")\n        scalar_muls = filter(lambda x: x.matches(\"aten::mul(Tensor self, Scalar other) -> Tensor\"), muls)\n        mul_constant_int = filter(lambda x: isinstance(list(x.inputs())[1].toIValue(), int), scalar_muls)\n        for mul in mul_constant_int:\n            with g.insert_point_guard(mul):\n                outputs = g.insertGraph(unrolled_mul.graph, list(mul.inputs()))\n                assert len(outputs) == len(list(mul.outputs()))\n                for new_out, old_out in zip(outputs, g.outputs()):\n                    old_out.replaceAllUsesWith(new_out)\n                mul.destroy()\n\n        FileCheck().check_not(\"aten::mul\").check(\"aten::add\").run(foo.graph)\n        self.assertEqual(foo(torch.ones([2, 2])), torch.ones([2, 2]) * 4)\n\n    @unittest.skipIf(IS_SANDCASTLE, \"gtest runs these in sandcastle\")\n    @unittest.skipIf(RUN_CUDA, \"covered by test_cpp_cuda\")\n    @unittest.skipIf(not torch._C._jit_has_cpp_tests(), \"Tests were not built, use BUILD_TEST=1\")\n    def test_cpp(self):\n        from cpp.jit import tests_setup\n        tests_setup.setup()\n        torch._C._jit_run_cpp_tests()\n        tests_setup.shutdown()\n\n    def test_batchnorm(self):\n        x = torch.ones(2, 2, 2, 2)\n        g, outputs, inputs = torch.jit._get_trace_graph(nn.BatchNorm2d(2), x,\n                                                        _force_outplace=True, return_inputs=True)\n        m = self.createFunctionFromGraph(g)\n        self.assertEqual(outputs, m(*inputs))\n\n    def test_dropout(self):\n        x = torch.ones(2, 2)\n        with torch.random.fork_rng(devices=[]):\n            g, outputs, inputs = torch.jit._get_trace_graph(nn.Dropout(0.6), x, return_inputs=True)\n        with torch.random.fork_rng(devices=[]):\n            m = self.createFunctionFromGraph(g)\n            self.assertEqual(outputs, m(*inputs))\n\n    @unittest.skipIf(not RUN_CUDA, \"test requires CUDA\")\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_native_dropout_corner_case(self):\n        with disable_autodiff_subgraph_inlining():\n            def t(x, p: float, t: bool):\n                o = torch.dropout(x, p, t)\n                return o\n\n            jit_t = torch.jit.script(t)\n            x = torch.randn(5).requires_grad_()\n            FileCheck().check(\"prim::DifferentiableGraph\").run(jit_t.graph_for(x, 1.0, True, profile_and_replay=True))\n\n            for train in [True, False]:\n                for p in [0.0, 1.0]:\n                    for device in [\"cuda\", \"cpu\"]:\n                        x = torch.randn(5).to(device=device).requires_grad_()\n                        x_ref = x.detach().requires_grad_()\n                        o = jit_t(x, p, train)\n                        o_ref = t(x_ref, p, train)\n                        o.sum().backward()\n                        o_ref.sum().backward()\n                        assert(o.equal(o_ref))\n                        assert(x.grad.equal(x_ref.grad))\n\n    @slowTest\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, 'Testing differentiable graph')\n    def test_dropout_module_requires_grad(self):\n        with enable_profiling_mode_for_profiling_tests():\n            class MyModule(torch.nn.Module):\n                def __init__(self, M):\n                    super(MyModule, self).__init__()\n                    self.dropout = torch.nn.Dropout(0.5)\n                    self.linear = torch.nn.Linear(M, M)\n\n                def forward(self, input):\n                    input = self.dropout(input)\n                    output = self.linear(input)\n                    return output\n\n            def profile(func, X):\n                with torch.autograd.profiler.profile() as prof:\n                    func(X)\n                return [e.name for e in prof.function_events]\n\n            M = 1000\n            scripted = torch.jit.script(MyModule(M))\n            # To reduce confusion about expected behaviors:\n            #   requires_grad controls whether dropout is symbolically differentiated.\n            #   training controls whether bernoulli_ is called inside symbolic differentiation of dropout.\n            # * When requires_grad == training, the expected behaviors are obvious.\n            # * When requires_grad=True and training=False, bernoulli_ might still show up in the graph.\n            #   But it's in a branch that's not called. That's why we have separate checks for autograd\n            #   profiler to make sure it's not run.\n            # * When requires_grad=False and training=True, bernoulli_ must be run since it's the expected\n            #   behavior for the dropout layer in training mode. It's independent of whether graph requires\n            #   gradient. In fact bernoulli_ comes from autograd instead of autodiff in this case.\n            for training in (True, False):\n                if training:\n                    scripted.train()\n                else:\n                    scripted.eval()\n                for requires_grad in (True, False):\n                    X = torch.randn(M, M, requires_grad=requires_grad)\n                    if requires_grad:\n                        FileCheck().check(\"aten::native_dropout\").run(scripted.graph_for(X, profile_and_replay=True))\n                    self.assertEqual(training, 'aten::bernoulli_' in profile(scripted, X))\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.SIMPLE, 'Testing differentiable graph')\n    @skipIfTorchDynamo(\"Torchdynamo cannot correctly handle profiler.profile calls\")\n    def test_dropout_func_requires_grad(self):\n        def dropout_training(input):\n            return F.dropout(input, 0.5, training=True)\n\n        def dropout_eval(input):\n            return F.dropout(input, 0.5, training=False)\n\n        def profile(func, X):\n            with torch.autograd.profiler.profile() as prof:\n                func(X)\n            return [e.name for e in prof.function_events]\n\n        M = 1000\n        scripted_training = torch.jit.script(dropout_training)\n        scripted_eval = torch.jit.script(dropout_eval)\n        # See comments in test_dropout_module_requires_grad.\n        with disable_autodiff_subgraph_inlining():\n            for requires_grad in (True, False):\n                X = torch.randn(M, M, requires_grad=requires_grad)\n                if requires_grad:\n                    FileCheck().check(\"aten::native_dropout\").run(scripted_training.graph_for(X, profile_and_replay=True))\n                self.assertIn('aten::bernoulli_', profile(scripted_training, X))\n                self.assertNotIn('aten::bernoulli_', profile(scripted_eval, X))\n\n    @unittest.skipIf(not RUN_CUDA, \"test_dropout_cuda require CUDA\")\n    def test_dropout_cuda(self):\n        # Dropout AD is dispatched to _fused_dropout in CUDA case,\n        # which is not included in TestJitGeneratedFunctional\n        def _zero_rate(t):\n            return torch.true_divide((t == 0).sum(), t.numel())\n\n        x = torch.ones(1000, 1000).cuda().requires_grad_()\n\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.nn.functional.dropout(x)\n\n            with freeze_rng_state():\n                out_ref = torch.nn.functional.dropout(x)\n                grad_ref = torch.autograd.grad(out_ref.sum(), x)\n\n            with freeze_rng_state():\n                out = func(x)\n                grad = torch.autograd.grad(out.sum(), x)\n\n            # TODO(#40882): previously we assert exact matches between eager and JIT result:\n            #  self.assertEqual(out, out_ref)\n            #  self.assertEqual(grad, grad_ref)\n            # This test was disabled during legacy -> profiling executor transition.\n            # Currently JIT fused results doesn't match eager result exactly due to some changes merged in between.\n            # We temporarily only check statstical difference but it should be reverted once the issue is fixed.\n            self.assertEqual(_zero_rate(out), _zero_rate(out_ref), rtol=1e-3, atol=1e-4)\n            self.assertEqual(_zero_rate(grad[0]), _zero_rate(grad_ref[0]), rtol=1e-3, atol=1e-4)\n\n    def test_torch_ops_overloaded(self):\n        with self.assertRaisesRegex(RuntimeError, \"failed to many any schema\"):\n            torch.ops.aten.add(\"a\", 1)\n        self.assertEqual(\"ab\", torch.ops.aten.add(\"a\", \"b\"))\n        a, b = torch.rand(3, 4), torch.rand(3, 4)\n        self.assertEqual(a + b, torch.ops.aten.add(a, b))\n        self.assertEqual(a + 1, torch.ops.aten.add(a, 1))\n\n    def test_torch_ops_kwonly(self):\n        a, b = torch.rand(3, 4), torch.rand(3, 4)\n        with self.assertRaisesRegex(RuntimeError, \"positional argument\"):\n            torch.ops.aten.add(a, b, 2)\n        # h/t Chillee for this ambiguous case\n        self.assertEqual(a.prod(1), torch.ops.aten.prod(a, 1))\n\n    def test_torch_complex(self):\n        def fn(real, img):\n            return torch.complex(real, img)\n\n        def fn_out(real, img, out):\n            return torch.complex(real, img, out=out)\n        self.checkScript(fn, (torch.rand(3, 4), torch.rand(3, 4), ))\n        self.checkScript(fn, (torch.ones(5, 1, 4), torch.ones(5, 1, 4), ))\n        self.checkScript(fn, (torch.zeros(1, 6), torch.ones(6, 1), ))\n        self.checkScript(fn, (torch.zeros(1, 6), torch.zeros(6, 1), ))\n        self.checkScript(fn, (torch.empty(3, 4), torch.empty(3, 4), ))\n\n        real = torch.tensor([1, 2], dtype=torch.float32)\n        img = torch.tensor([3, 4], dtype=torch.float32)\n        out = torch.empty([3, 4], dtype=torch.complex64)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.tensor([5, 2], dtype=torch.float64)\n        img = torch.tensor([3, 4], dtype=torch.float64)\n        out = torch.empty([5, 2], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([1, 2])\n        img = torch.ones([1, 2])\n        out = torch.empty([1, 2], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([3, 8, 7])\n        img = torch.ones([3, 8, 7])\n        out = torch.empty([3, 8, 7], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.empty([3, 2, 6])\n        img = torch.empty([3, 2, 6])\n        out = torch.empty([3, 2, 6], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.zeros([1, 3])\n        img = torch.empty([3, 1])\n        out = torch.empty([3, 3], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([2, 5])\n        img = torch.empty([2, 1])\n        out = torch.empty([2, 5], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([2, 5])\n        img = torch.zeros([2, 1])\n        out = torch.empty([2, 5], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n    def test_einsum(self):\n        def check(fn, jitted, *args):\n            self.assertGraphContains(jitted.graph, kind='aten::einsum')\n            self.assertEqual(fn(*args), jitted(*args))\n\n        def equation_format(x, y):\n            return torch.einsum('i,j->ij', (x, y))\n\n        def equation_format_varargs(x, y):\n            return torch.einsum('i,j->ij', x, y)\n\n        def sublist_format(x, y):\n            return torch.einsum(x, [0], y, [1], [0, 1])\n\n        x = make_tensor((5,), dtype=torch.float32, device=\"cpu\")\n        y = make_tensor((10,), dtype=torch.float32, device=\"cpu\")\n\n        for fn in [equation_format, equation_format_varargs, sublist_format]:\n            check(fn, torch.jit.script(fn), x, y)\n            check(fn, torch.jit.trace(fn, (x, y)), x, y)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_python_ivalue(self):\n        # Test if pure python object can be hold as IValue and conversion\n        # between IValue and PyObject are correct\n        # test for numpy object\n        py_array = np.arange(15)\n        ret_py_obj = torch._C._ivalue_debug_python_object(py_array)\n        self.assertEqual(py_array, ret_py_obj)\n\n        # test for function object\n        ret_py_obj = torch._C._ivalue_debug_python_object(F.relu)\n        self.assertEqual(F.relu, ret_py_obj)\n\n        # test for memory management\n        # we need to ensure IValue correctly call incref/decref to avoid\n        # dangling behavior and potential memory leaks during conversions\n        def test_func_scope_helper(inp):\n            # create a scope and do the conversion -> ivalue -> pyobject\n            # this func return a new pyobject that refcount + 1\n            inp_refcount = sys.getrefcount(inp)\n            ivalue_holder = torch._C._ivalue_debug_python_object(inp)\n            self.assertEqual(inp_refcount + 1, sys.getrefcount(ivalue_holder))\n            return ivalue_holder + 1\n\n        test_input = 2200\n        before_count = sys.getrefcount(test_input)\n        test_func_scope_helper(test_input)\n        after_count = sys.getrefcount(test_input)\n\n        # after the test_func_scope_helper_call, the refcount of\n        # test_input should be equal to the original refcount\n        # otherwise we get either dangling pointer or memory leak!\n        self.assertEqual(before_count, after_count)\n\n    def test_decompose_addmm(self):\n        def does_decompose():\n            @torch.jit.script\n            def addmm(mat, mat1, mat2):\n                a = mat.addmm(mat1, mat2)\n                b = mat.addmm(mat1, mat2, alpha=1.0, beta=1.0)\n                return a + b\n\n            mat = torch.randn(2, 2)\n            mat1 = torch.randn(2, 4)\n            mat2 = torch.randn(4, 2)\n\n            out_ref = addmm(mat, mat1, mat2)\n            self.run_pass('decompose_ops', addmm.graph)\n            out_test = addmm(mat, mat1, mat2)\n            self.assertEqual(out_ref, out_test)\n            FileCheck().check_not(\"addmm\").run(str(addmm.graph))\n\n        def doesnt_decompose():\n            @torch.jit.script\n            def addmm(mat, mat1, mat2, alpha, beta):\n                a = mat.addmm(mat1, mat2, alpha=4.20, beta=2.0)\n                b = mat.addmm(mat1, mat2, alpha=int(alpha), beta=int(beta))\n\n                return a + b\n\n            orig = str(addmm.graph)\n            self.run_pass('decompose_ops', addmm.graph)\n            self.assertTrue(orig == str(addmm.graph))\n\n        does_decompose()\n        doesnt_decompose()\n\n    @suppress_warnings\n    def test_sparse_tensors(self):\n        @torch.jit.ignore\n        def get_sparse():\n            return torch.sparse.FloatTensor(2, 3)\n\n        @torch.jit.script\n        def test_is_sparse(input):\n            # type: (Tensor) -> bool\n            return input.is_sparse\n\n        script_out_is_sparse = test_is_sparse(get_sparse())\n        script_out_is_dense = test_is_sparse(torch.randn(2, 3))\n        self.assertEqual(script_out_is_sparse, True)\n        self.assertEqual(script_out_is_dense, False)\n\n        def test_basic_sparse(input):\n            output = get_sparse()\n            return output, input\n\n        self.checkScript(test_basic_sparse, (get_sparse(),))\n        self.checkScript(test_basic_sparse, (torch.tensor([1]),))\n\n        def test_sparse_sum(input):\n            return torch.sparse.sum(input)\n\n        self.checkScript(test_sparse_sum, (get_sparse(),))\n\n        def test_sparse_mm(input1, input2):\n            return torch.sparse.mm(input1, input2)\n\n        self.checkScript(test_sparse_mm, (get_sparse(), torch.randn(3, 4)))\n\n        def test_sparse_addmm(input, input1, input2):\n            return torch.sparse.addmm(input, input1, input2)\n\n        def test_sparse_addmm_alpha_beta(input, input1, input2):\n            return torch.sparse.addmm(input, input1, input2, alpha=1.3, beta=1.5)\n\n        self.checkScript(test_sparse_addmm, (torch.randn(2, 4), get_sparse(), torch.randn(3, 4)))\n        self.checkScript(test_sparse_addmm_alpha_beta, (torch.randn(2, 4), get_sparse(), torch.randn(3, 4)))\n\n    @suppress_warnings\n    def test_sparse_csr_tensors(self):\n        @torch.jit.ignore\n        def get_sparse_csr():\n            return torch.randn(3, 3).to_sparse_csr()\n\n        @torch.jit.script\n        def test_is_sparse_csr(input):\n            # type: (Tensor) -> bool\n            return input.is_sparse_csr\n\n        script_out_is_sparse_csr = test_is_sparse_csr(get_sparse_csr())\n        script_out_is_dense_csr = test_is_sparse_csr(torch.randn(3, 3))\n\n        self.assertEqual(script_out_is_sparse_csr, True)\n        self.assertEqual(script_out_is_dense_csr, False)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_device_not_equal(self):\n\n        def compare_device(x: torch.device):\n            return x != torch.device(\"cuda:0\")\n\n        def compare_two_device(x: torch.device, y: torch.device):\n            return x != y\n\n        self.checkScript(compare_device, (torch.device(\"cuda:0\"),))\n        self.checkScript(compare_two_device, (torch.device(\"cuda:0\"), torch.device(\"cuda:1\"), ))\n\n    def test_constant_prop_simple(self):\n        @torch.jit.script\n        def constant_prop(input_int):\n            # type: (int) -> int\n            a = 2 * 3\n            b = a + 2\n            return b - input_int\n\n        out_ref = constant_prop(2)\n        self.run_pass('constant_propagation', constant_prop.graph)\n        out_test = constant_prop(2)\n        self.assertEqual(out_ref, out_test)\n        graph_str = str(constant_prop.graph)\n        self.assertTrue(\"aten::add\" not in graph_str and \"aten::mul\" not in graph_str)\n        const = constant_prop.graph.findNode(\"prim::Constant\").output().toIValue()\n        self.assertEqual(const, 8)\n\n    def test_constant_prop_nested(self):\n        @torch.jit.script\n        def constant_prop(a):\n            b = 2 + 1\n            if bool(a < 2):\n                c = b + 2\n            else:\n                c = b - 2\n            return c\n        out_ref = constant_prop(torch.tensor(2))\n        self.run_pass('constant_propagation', constant_prop.graph)\n        out_test = constant_prop(torch.tensor(2))\n        self.assertEqual(out_ref, out_test)\n        if_node = constant_prop.graph.findNode(\"prim::If\")\n        for block in if_node.blocks():\n            for node in block.nodes():\n                self.assertTrue(node.kind() == \"prim::Constant\")\n\n    def test_constant_prop_print(self):\n        @torch.jit.script\n        def constant_prop(input_tensor):\n            a = 2 * 3\n            print(a)\n            b = a + 2\n            return b + input_tensor\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        graph = constant_prop.graph\n        print_node = graph.findNode(\"prim::Print\")\n        self.assertTrue(print_node.input().toIValue() == 6)\n\n    def test_constant_prop_rand(self):\n        @torch.jit.script\n        def constant_prop():\n            a = torch.randn([3])\n            b = a + 2\n            return b\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        self.assertTrue(\"aten::randn\" in str(constant_prop.graph))\n\n    def test_constant_prop_none(self):\n        @torch.jit.script\n        def typed_none():\n            # type: () -> Optional[int]\n            return None\n\n        @torch.jit.script\n        def constant_prop():\n            a = typed_none()\n            b = typed_none()\n            if (a is None and b is None):\n                a = 2\n            else:\n                a = 1\n            return a\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        FileCheck().check(\"prim::Constant\").run(constant_prop.graph)\n\n    def test_constant_prop_if_inline(self):\n        @torch.jit.script\n        def constant_prop():\n            cond = True\n            a = 1\n            if cond:\n                a = 1 * 2\n            else:\n                a = 1 // 0\n            return a\n\n        # testing that 1 // 0 error is not thrownn\n        self.run_pass('constant_propagation', constant_prop.graph)\n\n    def test_constant_prop_exception(self):\n        # checking y = a[4] does not error in constant propagation\n        def bad_index(x):\n            # type: (bool)\n            y = 0\n            if x:\n                a = [1, 2, 3]\n                y = a[4]\n            return y\n\n        self.checkScript(bad_index, (False,))\n\n    def test_constant_prop_aliasing_type(self):\n        @torch.jit.script\n        def foo():\n            return len([1]), len(torch.tensor([2]))\n\n        FileCheck().check_dag(\"aten::tensor\").check_dag(\"aten::len\").run(foo.graph)\n\n        @torch.jit.script\n        def fn():\n            if 1 == 1:\n                return 1\n            else:\n                return 2\n\n        FileCheck().check_not(\"prim::If\").run(fn.graph)\n\n    def test_unchecked_cast(self):\n        def test(cond):\n            # type: (bool)\n            a = torch.tensor([10])\n            if cond:\n                b = None\n            else:\n                b = a\n            if b is not None:\n                b[0] = 5\n            return a.int()\n\n        self.checkScript(test, (True,))\n        self.checkScript(test, (False,))\n\n    def test_constant_prop_if_constant(self):\n        @torch.jit.script\n        def constant_prop(a, b):\n            c0 = 1\n            c1 = 1\n            c2 = 1\n            if bool(a):  # -> c0, c1\n                if bool(b):  # -> c0\n                    if 1 == 1:  # -> c0\n                        c0 = c0 + 1\n                        if 1 == 2:\n                            c1 = c1 + 1\n                            c2 = c2 + 1\n            else:  # -> c0, c1\n                c1 = c1 + 1\n\n            if 1 == 1:  # inlined\n                c0 = c0 + 1  # dynamic\n                c2 = c2 + 4  # set to 5\n            return a + c0 + c1 + c2\n\n        graph = constant_prop.graph\n        self.run_pass('constant_propagation', graph)\n        ifs = graph.findAllNodes(\"prim::If\", recurse=False)\n        snd_if_inlined = len(ifs) == 1\n        self.assertTrue(snd_if_inlined)\n        first_if = ifs[0]\n        self.assertTrue(first_if.outputsSize() == 2)\n        second_if = first_if.findNode(\"prim::If\", recurse=False)\n        self.assertTrue(second_if.outputsSize() == 1)\n        self.assertTrue(second_if.findNode(\"prim::If\") is None)\n\n    def test_constant_prop_loop_constant(self):\n        @torch.jit.script\n        def constant_prop(cond, iter):\n            # type: (bool, int) -> int\n            b = 0\n            while True:\n                print(\"stays\")\n            for _ in range(2):\n                print(\"stays\")\n            for _ in range(iter):\n                print(\"stays\")\n            while cond:\n                print(\"stays\")\n            while False:\n                print(\"removed\")\n            for _i in range(0):\n                print(\"removed\")\n            for _i in range(-4):\n                print(\"removed\")\n            return b\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        graph = canonical(constant_prop.graph)\n        self.assertTrue(graph.count(\"removed\") == 0)\n        self.assertTrue(graph.count(\"stays\") == 1)  # constant gets pooled\n        self.assertTrue(graph.count(\"prim::Print\") == 4)\n\n    def test_constant_prop_remove_output(self):\n        @torch.jit.script\n        def constant_prop(iter):\n            # type: (int) -> None\n            a = 1\n            b = 1\n            c = 1\n            for i in range(iter):\n                if 1 == 2:\n                    a = 10\n                if i == 5:\n                    b = 2\n                    c = 3\n            print(a, b, c)\n\n        graph = constant_prop.graph\n        self.run_pass('constant_propagation', graph)\n        self.assertTrue(graph.findNode(\"prim::Loop\").outputsSize() == 2)\n\n    # TODO(gmagogsfm): Refactor this test to reduce complexity.\n    def test_constant_insertion(self):\n        funcs_template = dedent('''\n        def func():\n            return {constant_constructor}\n        ''')\n\n        # constants: primitives: int, double, bool, str, lists of primitives,\n        # and tuples\n        def check_constant(constant_constructor):\n            scope = {}\n            funcs_str = funcs_template.format(constant_constructor=constant_constructor)\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            self.run_pass('constant_propagation', f_script.graph)\n            FileCheck().check_count(\"prim::Constant\", 1, exactly=True).run(f_script.graph)\n            self.assertEqual(scope['func'](), f_script())\n            imported = self.getExportImportCopy(f_script)\n            self.assertEqual(imported(), f_script())\n\n        constants = [\"None\", \"-.5\", \"0\", \"1\", \"True\", \"False\", \"''\", \"'a'\", \"'b'\", \"torch.tensor(1)\",\n                     \"[True, False]\", \"[0., .5]\", \"[torch.tensor(4), torch.tensor(2)]\", \"[0, 1]\", \"['0', '1']\",\n                     \"[True, None]\", \"[.5, None, .2]\"]\n\n        for type in [\"Tensor\", \"str\", \"int\", \"float\", \"bool\"]:\n            constants.append(\"torch.jit.annotate(List[ \" + type + \"], [])\")\n\n        for constant in constants:\n            check_constant(constant)\n\n        for key_type in [\"str\", \"int\", \"float\"]:\n            for value_type in [\"Tensor\", \"bool\", \"str\", \"int\", \"float\"]:\n                check_constant(\"torch.jit.annotate(Dict[ \" + key_type + \", \" + value_type + \"], {})\")\n                check_constant(\"torch.jit.annotate(Dict[ \" + key_type + \", Optional[\" + value_type + \"]], {})\")\n\n        for i in range(len(constants)):\n            for j in range(i + 1, len(constants)):\n                tup_constant = constants[i] + \", \" + constants[j]\n                check_constant(tup_constant)\n\n        dict_constants = []\n        for i in range(len(constants)):\n            # check_constant constructs the second dict with another Tensor\n            # which fails the comparison\n            if not isinstance(eval(constants[i]), (str, int, float)):\n                continue\n            for j in range(len(constants)):\n                dict_constant = \"{ \" + constants[i] + \": \" + constants[j] + \"}\"\n                check_constant(dict_constant)\n                dict_constants.append(dict_constant)\n        constants = constants + dict_constants\n\n        # testing node hashing\n        funcs_template = dedent('''\n        def func():\n            print({constant_constructor})\n        ''')\n        single_elem_tuples = (\"(\" + x + \",)\" for x in constants)\n        input_arg = \", \".join(single_elem_tuples)\n        scope = {}\n        funcs_str = funcs_template.format(constant_constructor=input_arg)\n        execWrapper(funcs_str, globals(), scope)\n        cu = torch.jit.CompilationUnit(funcs_str)\n        f_script = cu.func\n        self.run_pass('constant_propagation', f_script.graph)\n        # prim::None return adds one constant\n        self.assertEqual(len(constants) + 1, str(f_script.graph).count(\"prim::Constant\"))\n        self.run_pass('cse', f_script.graph)\n        # node hashing correctly working, no CSE occurs\n        self.assertEqual(len(constants) + 1, str(f_script.graph).count(\"prim::Constant\"))\n\n        funcs_template = dedent('''\n        def func():\n            a = {constant_constructor}\n            print(a)\n            b = {constant_constructor}\n            print(b)\n        ''')\n\n        # generate dicts with built-in types (excluding torch.Tensor)\n        xprod = itertools.product(constants, constants)\n\n        # test that equal tuples and dicts correctly work with node hashing\n        for tup in (\"(\" + x + \",)\" for x in constants):\n            funcs_str = funcs_template.format(constant_constructor=tup)\n            scope = {}\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            self.run_pass('constant_propagation_immutable_types', f_script.graph)\n            num_constants = str(f_script.graph).count(\"prim::Constant\")\n            self.run_pass('cse', f_script.graph)\n            FileCheck().check_count(\"prim::Constant\", num_constants, exactly=True).run(f_script.graph)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_cuda_export_restore(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(3, 4))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mod = Sub()\n\n            @torch.jit.script_method\n            def forward(self, v):\n                return self.mod(v)\n        m = M()\n        m.cuda()\n        m2 = self.getExportImportCopy(m)\n        m2.cuda()\n        input = torch.rand(3, 4).cuda()\n        self.assertEqual(m(input), m2(input))\n\n    @slowTest\n    def test_export_batchnorm(self):\n        for mode in ['eval', 'train']:\n            for clazz in [\n                    torch.nn.BatchNorm1d(100),\n                    torch.nn.BatchNorm1d(100, affine=False),\n                    torch.nn.BatchNorm2d(100),\n                    torch.nn.BatchNorm2d(100, affine=False)]:\n                getattr(clazz, mode)()\n                input = torch.randn(20, 100) if isinstance(clazz, torch.nn.BatchNorm1d) else \\\n                    torch.randn(20, 100, 35, 45)\n                traced = torch.jit.trace(clazz, (input,))\n                imported = self.getExportImportCopy(traced)\n                x = torch.randn(20, 100) if isinstance(clazz, torch.nn.BatchNorm1d) else \\\n                    torch.randn(20, 100, 35, 45)\n                self.assertEqual(traced(x), imported(x))\n\n    def test_export_rnn(self):\n        for clazz in [nn.RNN(10, 20, 2), nn.GRU(10, 20, 2)]:\n            class RNNTest(torch.nn.Module):\n                def __init__(self):\n                    super(RNNTest, self).__init__()\n                    self.rnn = clazz\n\n                def forward(self, x, lengths, h0):\n                    packed = torch.nn.utils.rnn.pack_padded_sequence(x, lengths)\n                    out, h = self.rnn(packed, h0)\n                    padded_outs, _ = torch.nn.utils.rnn.pad_packed_sequence(out)\n                    return padded_outs\n\n            test = RNNTest()\n\n            traced = torch.jit.trace(test, (torch.randn(5, 3, 10), torch.LongTensor([3, 2, 1]), torch.randn(2, 3, 20)))\n            imported = self.getExportImportCopy(traced)\n            # NB: We make sure to pass in a batch with a different max sequence\n            # length to ensure that the argument stashing for pad_packed works\n            # properly.\n            x, lengths, h0 = torch.randn(7, 4, 10), torch.LongTensor([7, 3, 2, 1]), torch.randn(2, 4, 20)\n            self.assertEqual(traced(x, lengths, h0), imported(x, lengths, h0))\n\n    def test_export_lstm(self):\n        class LSTMTest(torch.nn.Module):\n            def __init__(self):\n                super(LSTMTest, self).__init__()\n                self.rnn = nn.LSTM(10, 20, 2)\n\n            def forward(self, x, lengths, hiddens):\n                h0, c0 = hiddens\n                packed = torch.nn.utils.rnn.pack_padded_sequence(x, lengths)\n                out, (h, c) = self.rnn(packed, (h0, c0))\n                padded_outs, _ = torch.nn.utils.rnn.pad_packed_sequence(out)\n                return padded_outs\n\n        test = LSTMTest()\n\n        traced = torch.jit.trace(test, (torch.randn(5, 3, 10),\n                                        torch.LongTensor([3, 2, 1]),\n                                        (torch.randn(2, 3, 20), torch.randn(2, 3, 20))))\n        imported = self.getExportImportCopy(traced)\n        x, lengths, h0, c0 = \\\n            torch.randn(7, 3, 10), torch.LongTensor([7, 5, 2]), torch.randn(2, 3, 20), torch.randn(2, 3, 20)\n        self.assertEqual(traced(x, lengths, (h0, c0)), imported(x, lengths, (h0, c0)))\n\n    def test_unique_state_dict(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                shared_param = torch.nn.Parameter(torch.ones(1))\n                self.register_parameter('w1', shared_param)\n                self.register_parameter('w2', shared_param)\n\n            def forward(self, input):\n                return input + self.w1 + self.w2\n\n        model = MyModule()\n        unittest.TestCase.assertEqual(\n            self, len(torch.jit._unique_state_dict(model, keep_vars=False)), 1)\n        unittest.TestCase.assertEqual(\n            self, len(torch.jit._unique_state_dict(model, keep_vars=True)), 1)\n\n    def test_export_dropout(self):\n        test = torch.nn.Dropout()\n        test.eval()\n\n        traced = torch.jit.trace(test, (torch.rand(3, 4),), check_trace=False)\n        imported = self.getExportImportCopy(traced)\n        x = torch.randn(3, 4)\n        self.assertEqual(traced(x), imported(x))\n\n    def test_pretty_printer(self):\n        @torch.jit.script\n        def if_test(a, b):\n            # FIXME: use 0 instead of a.\n            # c = 0\n            c = a\n            if bool(a < b):\n                c = b\n            else:\n                c = a\n            return c\n\n        @torch.jit.script\n        def if_one(a, b):\n            c = b\n            if bool(a < b):\n                c = a\n            return c\n\n        @torch.jit.script\n        def while_test(a, i):\n            while bool(i < 3):\n                a *= a\n                i += 1\n            return a\n\n        @torch.jit.script\n        def while_if_test(a, b):\n            c = 0\n            while bool(a < 10):\n                a = a + 1\n                b = b + 1\n                if bool(a > b):\n                    c = 2\n                else:\n                    c = 3\n            return a + 1 + c\n\n        @torch.jit.script\n        def loop_use_test(y):\n            x = y + 1\n            z = x + 5\n            while bool(y < 8):\n                y += 1\n                z = x\n            return x, z\n\n        @torch.jit.ignore\n        def python_fn(x):\n            return x + 10\n\n        @torch.jit.script\n        def python_op_name_test(y):\n            return python_fn(y)\n\n        @torch.jit.script\n        def empty_int_list_test(y):\n            x = torch.jit.annotate(List[int], [])\n            return x[0]\n\n        @torch.jit.script\n        def empty_float_list_test(y):\n            return [1.0, 2.0, 3.0]\n\n        @torch.jit.script\n        def print_weird_test(y):\n            print(\"hi\\016\")\n\n        self.assertExpected(if_test.code, \"if_test\")\n        self.assertExpected(if_one.code, \"if_one\")\n        self.assertExpected(while_test.code, \"while_test\")\n        self.assertExpected(while_if_test.code, \"while_if_test\")\n        self.assertExpected(loop_use_test.code, \"loop_use_test\")\n        self.assertExpected(python_op_name_test.code, \"python_op_name_test\")\n        self.assertExpected(empty_int_list_test.code, \"empty_int_list_test\")\n        self.assertExpected(empty_float_list_test.code, \"empty_float_list_test\")\n        self.assertExpected(print_weird_test.code, \"print_weird_test\")\n\n    def test_cu_escaped_number(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                print(\"hi\\016\")\n        ''')\n        self.assertExpected(cu.foo.code)\n\n    def test_import_method(self):\n        with torch._jit_internal._disable_emit_hooks():\n            class Foo(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(Foo, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self, x, y):\n                    return 2 * x + y\n\n            foo = Foo()\n            buffer = io.BytesIO()\n            torch.jit.save(foo, buffer)\n\n            buffer.seek(0)\n            foo_loaded = torch.jit.load(buffer)\n            self.assertExpected(foo_loaded.forward.code)\n\n    @unittest.skip(\"temporarily disable the test for fwd compatibility\")\n    def test_non_ascii_string(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.a = \"Over \\u0e55\\u0e57 57\"\n\n            @torch.jit.script_method\n            def forward(self, x, y):\n                return self.a + \"hi\\xA1\"\n\n        foo = Foo()\n        buffer = io.BytesIO()\n        torch.jit.save(foo, buffer)\n\n        buffer.seek(0)\n        foo_loaded = torch.jit.load(buffer)\n        self.assertExpected(foo_loaded.forward.code)\n\n    def test_function_default_values(self):\n        outer_var = torch.tensor(20)\n        outer_var2 = torch.tensor(30)\n        a = torch.tensor(0.5)\n        b = torch.tensor(10)\n\n        @torch.jit.script\n        def simple_fn(x, a=a, b=b, c=outer_var + outer_var2):\n            return x + a + b + c\n\n        self.assertEqual(\n            simple_fn(torch.ones(1)),\n            torch.ones(1) + 0.5 + 10 + (20 + 30))\n        self.assertEqual(\n            simple_fn(torch.ones(1), torch.tensor(1), torch.tensor(3), torch.tensor(4)),\n            torch.ones(1) + 1 + 3 + 4)\n\n        outer_c = torch.tensor(9)\n        outer_flag = torch.tensor(False)\n\n        @torch.jit.script\n        def bool_fn(x, a=outer_c, flag=outer_flag):\n            if bool(flag):\n                result = x\n            else:\n                result = x + a\n            return result\n\n        self.assertEqual(bool_fn(torch.ones(1)), torch.ones(1) + 9)\n        self.assertEqual(\n            bool_fn(torch.ones(1), torch.tensor(1), torch.tensor(True)),\n            torch.ones(1))\n\n        @torch.jit.script\n        def none_fn(x=None):\n            # type: (Optional[int]) -> Optional[int]\n            return x\n\n        self.assertEqual(none_fn(), None)\n        self.assertEqual(none_fn(1), 1)\n\n        @torch.jit.script\n        def hints(x, a=0.5, b=10):\n            # type: (Tensor, float, int) -> Tensor\n            return x + a + b\n\n        self.assertEqual(hints(torch.ones(1)), torch.ones(1) + 0.5 + 10)\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected a default value\"):\n\n            @torch.jit.script\n            def hints_bad_types(x, a=10, b=0.5):  # noqa: T484\n                # type: (Tensor, float, int) -> Tensor\n                return x + a + b\n        with self.assertRaisesRegex(RuntimeError, \"Expected a default value\"):\n            @torch.jit.script\n            def bad_no_optional(x=None):\n                # type: (Dict[str, int]) -> Dict[str, int]\n                return x\n\n\n    def test_module_default_values(self):\n        four = torch.tensor(4)\n\n        class Test(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Test, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, input, other=four):\n                return input + other\n\n        t = Test()\n        self.assertEqual(t(torch.ones(1)), torch.ones(1) + 4)\n\n    def test_mutable_default_values(self):\n        with self.assertRaisesRegex(Exception, \"Mutable default parameters\"):\n            @torch.jit.script\n            def foo(x=(1, [])):\n                # type: (Tuple[int, List[Tensor]])\n                return x\n\n        class Test(torch.nn.Module):\n            def forward(self, input=[]):  # noqa: B006\n                return input\n\n        with self.assertRaisesRegex(Exception, \"Mutable default parameters\"):\n            torch.jit.script(Test())\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_warnings(self):\n        import warnings\n\n        def fn(x):\n            if bool(x < 2):\n                warnings.warn(\"x is less than 2\")\n            return x\n\n        class M(torch.nn.Module):\n            def forward(self, x):\n                if bool(x < 2):\n                    warnings.warn(\"x is less than 2\")\n                return x\n\n\n        scripted_mod = torch.jit.script(M())\n        scripted_fn = torch.jit.script(fn)\n\n        with warnings.catch_warnings(record=True) as warns:\n            fn(torch.ones(1))\n\n        with warnings.catch_warnings(record=True) as script_warns:\n            scripted_fn(torch.ones(1))\n\n        with warnings.catch_warnings(record=True) as script_mod_warns:\n            scripted_mod(torch.ones(1))\n\n        self.assertEqual(str(warns[0]), str(script_warns[0]))\n        self.assertEqual(len(script_mod_warns), 1)\n        self.assertEqual(str(warns[0].message), str(script_mod_warns[0].message))\n\n    def test_no_erroneous_warnings(self):\n        import warnings\n\n        def fn(x):\n            if bool(x > 0):\n                warnings.warn('This should NOT be printed')\n                x += 1\n            return x\n\n        with warnings.catch_warnings(record=True) as warns:\n            fn_script = torch.jit.script(fn)\n            fn_script(torch.tensor(0))\n        warns = [str(w.message) for w in warns]\n        self.assertEqual(len(warns), 0)\n\n    @unittest.skipIf(True, \"TODO: re-enable with https://github.com/pytorch/pytorch/pull/29339\")\n    def test_torch_load_error(self):\n        class J(torch.jit.ScriptModule):\n            def __init__(self):\n                super(J, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return input + 100\n\n        j = J()\n        with TemporaryFileName() as fname:\n            j.save(fname)\n            with self.assertRaisesRegex(RuntimeError, \"is a zip\"):\n                torch.load(fname)\n\n    def test_torch_load_zipfile_check(self):\n        @torch.jit.script\n        def fn(x):\n            return x + 10\n\n        with TemporaryFileName() as fname:\n            fn.save(fname)\n            with io.open(fname, 'rb') as f:\n                self.assertTrue(torch.serialization._is_zipfile(f))\n\n    def test_python_bindings(self):\n        lstm_cell = torch.jit.script(LSTMCellS)\n\n        def lstm(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n            for i in range(x.size(0)):\n                hx, cx = lstm_cell(x[i], hx, cx, w_ih, w_hh, b_ih, b_hh)\n            return hx\n\n        slstm = torch.jit.script(lstm)\n\n        inputs = get_lstm_inputs('cpu', training=True, seq_length=10)\n        slstm(*inputs).sum().backward()\n        global fw_graph\n        fw_graph = slstm.graph_for(*inputs)\n        nodes = list(fw_graph.nodes())\n        tested_blocks = False\n        for node in nodes:\n            for output in node.outputs():\n                self.assertTrue(hasattr(output, 'type'))\n                self.assertTrue(output.type() is not None)\n            for input in node.inputs():\n                self.assertTrue(hasattr(input, 'type'))\n                self.assertTrue(input.type() is not None)\n            for block in node.blocks():\n                tested_blocks = True\n                self.assertTrue(hasattr(block, 'inputs'))\n                self.assertTrue(hasattr(block, 'outputs'))\n                for output in block.outputs():\n                    self.assertTrue(hasattr(output, 'type'))\n                    self.assertTrue(output.type() is not None)\n                for input in block.inputs():\n                    self.assertTrue(hasattr(input, 'type'))\n                    self.assertTrue(input.type() is not None)\n                self.assertTrue(hasattr(block, 'returnNode'))\n                self.assertTrue(type(block.returnNode()) == torch._C.Node)\n                self.assertTrue(hasattr(block, 'paramNode'))\n                self.assertTrue(type(block.paramNode()) == torch._C.Node)\n        self.assertTrue(tested_blocks)\n\n    def test_export_opnames(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n\n            def one(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                return x + y\n\n            def two(self, x):\n                # type: (Tensor) -> Tensor\n                return 2 * x\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                return self.one(self.two(x), x)\n\n        class Bar(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Bar, self).__init__()\n                self.sub = Foo()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                return self.sub.forward(x)\n\n        bar = Bar()\n        ops = torch.jit.export_opnames(bar)\n        expected = ['aten::add.Tensor', 'aten::mul.Scalar']\n        self.assertTrue(set(expected).issubset(set(ops)))\n\n    def test_pytorch_jit_env_off(self):\n        import subprocess\n        env = os.environ.copy()\n        env['PYTORCH_JIT'] = '0'\n        try:\n            subprocess.check_output([sys.executable, '-c', 'import torch'], env=env)\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(\"Could not 'import torch' with PYTORCH_JIT=0\") from e\n\n    def test_print_op_module(self):\n        # Issue #19351: python2 and python3 go through different paths.\n        # python2 returns '<module 'torch.ops' (built-in)>'\n        # python3 uses __file__ and return\n        # '<module 'torch.ops' from '/scratch/ailzhang/pytorch/torch/_ops.py'>'\n        s = str(torch.ops)\n        self.assertRegex(s, r'ops')\n\n    def test_print_classes_module(self):\n        s = str(torch.classes)\n        self.assertRegex(s, r'classes')\n\n    def test_print_torch_ops_modules(self):\n        s = str(torch._ops.ops.quantized)\n        self.assertRegex(s, r'torch.ops')\n        s = str(torch._ops.ops.atan)\n        self.assertRegex(s, r'torch.ops')\n\n    @unittest.skipIf(IS_WINDOWS, 'TODO: fix occasional windows failure')\n    def test_profiler(self):\n        prev_opt = torch._C._get_graph_executor_optimize()\n        torch._C._set_graph_executor_optimize(False)\n\n        def other_fn(x):\n            return x * 2\n\n        x = torch.rand(3, 4)\n        traced_other_fn = torch.jit.trace(other_fn, x)\n\n        def fn(x):\n            y = traced_other_fn(x)\n            fut = torch.jit._fork(traced_other_fn, x)\n            y = torch.jit._wait(fut)\n            return y\n\n        traced_fn = torch.jit.trace(fn, x)\n        with torch.autograd.profiler.profile() as prof:\n            traced_fn(x)\n\n        # expecting to see other_fn TS function call\n        # with cpu time >= mul cpu time and\n        # a forked other_fn\n\n        mul_events = defaultdict(int)\n        other_fn_events = defaultdict(int)\n        for e in prof.function_events:\n            if e.name == \"aten::mul\":\n                self.assertTrue(e.thread not in mul_events)\n                mul_events[e.thread] = e.time_range.elapsed_us()\n            elif e.name == \"other_fn\":\n                self.assertTrue(e.thread not in other_fn_events)\n                other_fn_events[e.thread] = e.time_range.elapsed_us()\n\n        self.assertTrue(len(mul_events) == 2)\n        self.assertTrue(len(other_fn_events) == 2)\n\n        for thread, mul_time in mul_events.items():\n            self.assertTrue(thread in other_fn_events)\n            self.assertTrue(other_fn_events[thread] >= mul_time)\n\n        torch._C._set_graph_executor_optimize(prev_opt)\n\n    def test_hide_source_ranges_context_manager(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.add(x, x)\n\n        graph = foo.graph\n        source_range_regex = \"# .*\\\\.py\"\n        self.assertRegex(graph.__repr__(), source_range_regex)\n        with torch.jit._hide_source_ranges():\n            self.assertNotRegex(graph.__repr__(), source_range_regex)\n            self.assertRegex(graph.str(print_source_ranges=True), source_range_regex)\n        self.assertRegex(graph.__repr__(), source_range_regex)\n\n\nclass TestFrontend(JitTestCase):\n\n    def test_instancing_error(self):\n        @torch.jit.ignore\n        class MyScriptClass(object):\n            def unscriptable(self):\n                return \"a\" + 200\n\n\n        class TestModule(torch.nn.Module):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n            def forward(self, x):\n                return MyScriptClass()\n\n        with self.assertRaises(torch.jit.frontend.FrontendError) as cm:\n            torch.jit.script(TestModule())\n\n        checker = FileCheck()\n        checker.check(\"Cannot instantiate class\")\n        checker.check(\"def forward\")\n        checker.run(str(cm.exception))\n\n    def test_dictionary_as_example_inputs_for_jit_trace(self):\n        class TestModule_v1(torch.nn.Module):\n            def __init__(self):\n                super(TestModule_v1, self).__init__()\n\n            def forward(self, key2=None, key3=None, key4=None, key5=None, key1=None, key6=None):\n                return key1 + key2 + key3\n\n        class TestModule_v2(torch.nn.Module):\n            def __init__(self):\n                super(TestModule_v2, self).__init__()\n\n            def forward(self, x, y):\n                return x + y\n\n        def test_func(x, y):\n            return x + y\n        model_1 = TestModule_v1()\n        model_2 = TestModule_v2()\n        value1 = torch.ones(1)\n        value2 = torch.ones(1)\n        value3 = torch.ones(1)\n        example_input_dict = {'key1': value1, 'key2': value2, 'key3': value3}\n        example_input_dict_func = {'x': value1, 'y': value2}\n        traced_model_1 = torch.jit.trace(model_1, example_kwarg_inputs=example_input_dict, strict=False)\n        traced_model_1_m = torch.jit.trace_module(\n            model_1, {'forward': example_input_dict}, example_inputs_is_kwarg=True, strict=False)\n        traced_model_2 = torch.jit.trace(model_2, example_kwarg_inputs={'x': torch.rand([2]), 'y': torch.rand([2])})\n        traced_func = torch.jit.trace(test_func, example_kwarg_inputs=example_input_dict_func, strict=False)\n        res_1 = traced_model_1(**example_input_dict)\n        res_1_m = traced_model_1_m(**example_input_dict)\n        self.assertEqual(res_1, 3 * torch.ones(1))\n        self.assertEqual(res_1_m, 3 * torch.ones(1))\n        res_func = traced_func(**example_input_dict_func)\n        self.assertEqual(res_func, 2 * torch.ones(1))\n        with self.assertRaisesRegex(RuntimeError, r\"forward\\(\\) is missing value for argument 'x'.\"):\n            res_2 = traced_model_2(**{'z': torch.rand([2]), 'y': torch.rand([2])})\n        with self.assertRaisesRegex(RuntimeError, r\"forward\\(\\) is missing value for argument 'y'.\"):\n            res_2 = traced_model_2(**{'x': torch.rand([2]), 'z': torch.rand([2])})\n\n\nclass TestScript(JitTestCase):\n\n    # Tests that calling torch.jit.script repeated on function is allowed.\n    def test_repeated_script_on_function(self):\n        @torch.jit.script\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        torch.jit.script(torch.jit.script(fn))\n\n    def test_pretty_print_function(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.nn.functional.interpolate(x)\n\n        FileCheck().check(\"interpolate\").run(foo.code)\n\n    def test_inlined_graph(self):\n        \"\"\"\n        Check that the `inlined_graph` property correctly returns an inlined\n        graph, both through function calls and method calls.\n        \"\"\"\n        @torch.jit.script\n        def foo(x):\n            return torch.add(x, x)\n\n        class MyNestedMod(torch.nn.Module):\n            def __init__(self):\n                super(MyNestedMod, self).__init__()\n\n            def forward(self, x):\n                return torch.sub(x, x)\n\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.nested = MyNestedMod()\n\n            def forward(self, x):\n                x = self.nested(x)  # sub\n                x = foo(x)  # add\n                return torch.mul(x, x)\n\n        m = torch.jit.script(MyMod())\n        FileCheck().check(\"aten::sub\") \\\n            .check(\"aten::add\") \\\n            .check(\"aten::mul\") \\\n            .run(m.inlined_graph)\n\n    def test_static_method_on_module(self):\n        \"\"\"\n        Check that the `@staticmethod` annotation on a function on a module works.\n        \"\"\"\n        class MyCell(torch.nn.Module):\n            def __init__(self):\n                super(MyCell, self).__init__()\n\n            @staticmethod\n            def do_it(x, h):\n                new_h = torch.tanh(x + h)\n                return new_h, new_h\n\n            def forward(self, x, h):\n                return self.do_it(x, h)\n\n        my_cell = torch.jit.script(MyCell())\n        x = torch.rand(3, 4)\n        h = torch.rand(3, 4)\n        jitted_cell = my_cell(x, h)\n        non_jitted_cell = MyCell().do_it(x, h)\n\n        self.assertEqual(jitted_cell, non_jitted_cell)\n\n    def test_code_with_constants(self):\n        \"\"\"\n        Check that the `code_with_constants` property correctly returns graph CONSTANTS in the\n        CONSTANTS.cN format used in the output of the `code` property.\n        \"\"\"\n        @torch.jit.script\n        def foo(x=torch.ones(1)):\n            return x\n\n        class Moddy(torch.nn.Module):\n            def __init__(self):\n                super(Moddy, self).__init__()\n\n            def forward(self, x):\n                return foo()\n\n        m = torch.jit.script(Moddy())\n        src, CONSTANTS = m.code_with_constants\n\n        self.assertEqual(CONSTANTS.c0, torch.ones(1))\n        self.assertEqual(src, m.code)\n\n    def test_code_with_constants_restore(self):\n        \"\"\"\n        Check that the `code_with_constants` property correctly works on restoration after save() + load()\n        \"\"\"\n        @torch.jit.script\n        def foo(x=torch.ones(1)):\n            return x\n\n        class Moddy(torch.nn.Module):\n            def __init__(self):\n                super(Moddy, self).__init__()\n\n            def forward(self, x):\n                return foo()\n\n        m = torch.jit.script(Moddy())\n        src, CONSTANTS = m.code_with_constants\n        eic = self.getExportImportCopy(m)\n\n        src_eic, CONSTANTS_eic = eic.code_with_constants\n\n        self.assertEqual(src, src_eic)\n        self.assertEqual(CONSTANTS.c0, CONSTANTS_eic.c0)\n\n\n    def test_oneline_func(self):\n        def fn(x): return x  # noqa: E704\n\n        self.checkScript(fn, (torch.ones(2, 2), ))\n\n    def test_request_bailout(self):\n        with enable_profiling_mode_for_profiling_tests():\n\n            def fct_loop(x):\n                for i in range(3):\n                    x = torch.cat((x, x), 0)\n                return x\n\n            x = torch.ones(2, 3, 4, dtype=torch.float32)\n            expected = fct_loop(x)\n            jitted = torch.jit.script(fct_loop)\n            # profile\n            jitted(x)\n            # optimize\n            jitted(x)\n            dstate = jitted.get_debug_state()\n            eplan = get_execution_plan(dstate)\n            num_bailouts = eplan.code.num_bailouts()\n\n            for i in range(0, num_bailouts):\n                eplan.code.request_bailout(i)\n                self.assertEqual(jitted(x), expected)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_dominated_bailout(self):\n        with enable_profiling_mode_for_profiling_tests():\n            # functional dominated guard\n            @torch.jit.script\n            def foo(x):\n                dim = x.dim()\n                if dim == 0:\n                    y = int(x)\n                else:\n                    y = x.size()[dim - 1]\n                return y\n\n            x = torch.zeros(2)\n            self.assertEqual(foo(x), 2)\n            self.assertEqual(foo(x), 2)\n            g = torch.jit.last_executed_optimized_graph()\n            g_s = str(g)\n            g_s = g_s[0:g_s.find(\"return\")]\n            FileCheck().check_count(\"prim::BailOut[\", 1, exactly=True).run(g_s)\n\n            # dominated guard of non-functional value\n            @torch.jit.script\n            def foo(x):\n                dim = x.dim()\n                x.add_(3)\n                if dim == 0:\n                    return 0\n                else:\n                    return x.size()[dim - 1]\n\n            x = torch.zeros(2)\n            self.assertEqual(foo(x), 2)\n            self.assertEqual(foo(x), 2)\n            g = torch.jit.last_executed_optimized_graph()\n            FileCheck().check(\"prim::BailOut[\").check(\"aten::add_\").check_next(\"prim::BailOut[\").check(\"return\").run(g)\n\n            with torch.enable_grad():\n                @torch.jit.ignore\n                def disable_grad():\n                    torch.set_grad_enabled(False)\n\n                @torch.jit.ignore\n                def enable_grad():\n                    torch.set_grad_enabled(True)\n\n                @torch.jit.script\n                def foo(x):\n                    x = x + 1\n                    dim = x.dim()\n                    disable_grad()\n                    if dim == 0:\n                        y = int(x)\n                    else:\n                        y = x.size()[dim - 1]\n                    enable_grad()\n                    return y\n\n                x = torch.zeros(2, requires_grad=True)\n                self.assertEqual(foo(x), 2)\n                self.assertEqual(foo(x), 2)\n                g = torch.jit.last_executed_optimized_graph()\n                # there should still be a Bailout after disable_grad call\n                FileCheck().check(\"disable_grad\").check(\"BailOut[\").check(\"BailoutTemplate\").run(g)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_profiling_merge(self):\n        @torch.jit.script\n        def test_not_const(x):\n            if x.size(0) == 1:\n                return 1\n            else:\n                return 2\n\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(2):\n                test_not_const(torch.rand([1, 2]))\n                test_not_const(torch.rand([2, 2]))\n\n                graph_str = torch.jit.last_executed_optimized_graph()\n                FileCheck().check(\"profiled_type=Double(*, 2, strides=[2, 1], requires_grad=0, device=cpu\").run(graph_str)\n                FileCheck().check_not(\"profiled_type=Double(1, 2, strides=[2, 1], requires_grad=0, device=cpu\").run(graph_str)\n\n\n    def test_nested_bailouts(self):\n        @torch.jit.script\n        def fct_loop(x):\n            for i in range(3):\n                x = torch.cat((x, x), 0)\n            return x\n\n        x = torch.ones(2, 3, 4, dtype=torch.float32)\n        out = fct_loop(x)\n        jit_trace = torch.jit.trace(fct_loop, x)\n        out_trace = jit_trace(x)\n\n    def test_no_self_arg_ignore_function(self):\n        class MyModule(nn.Module):\n            @torch.jit.ignore  # noqa: B902\n            def call_np():  # noqa: B902\n                # type: () -> int\n                return np.random.choice(2, p=[.95, .05])\n\n            def forward(self):\n                return self.call_np()\n\n        with self.assertRaisesRegex(Exception, \"does not have a self argument\"):\n            torch.jit.script(MyModule())\n\n    def test_loop_liveness(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def f(i):\n                # type: (int) -> Tensor\n                l = []\n                for n in [2, 1]:\n                    l.append(torch.zeros(n, i))\n\n                return l[0]\n\n            f(2)\n            f(1)\n\n    def test_bailout_loop_carried_deps_name_clash(self):\n        with enable_profiling_mode_for_profiling_tests():\n            NUM_ITERATIONS = 10\n\n            @torch.jit.script\n            def fct_loop(z, size):\n                # type: (int, int) -> Tuple[Tensor, List[int]]\n                counters = torch.jit.annotate(List[int], [])\n                j = 0\n                y = torch.ones(2)\n                for i in range(size):\n                    counters.append(i + j)\n                    y = torch.cat((y, torch.ones(z)), 0)\n                    j = j + 1\n                return y, counters\n\n            inputs = [1, 2, 3, 4]\n            expected = [x * 2 for x in range(NUM_ITERATIONS)]\n            for inp in inputs:\n                results = fct_loop(inp, NUM_ITERATIONS)\n                self.assertEqual(results[1], expected)\n\n    def test_bailout_loop_counter_transition(self):\n        with enable_profiling_mode_for_profiling_tests():\n            NUM_ITERATIONS = 10\n\n            @torch.jit.script\n            def fct_loop(z, size):\n                # type: (int, int) -> Tuple[Tensor, List[int]]\n                counters = torch.jit.annotate(List[int], [])\n                y = torch.ones(2)\n                for i in range(size):\n                    counters.append(i)\n                    y = torch.cat((y, torch.ones(z)), 0)\n                return y, counters\n\n            inputs = [1, 2, 3, 4]\n            expected = list(range(NUM_ITERATIONS))\n            for inp in inputs:\n                results = fct_loop(inp, NUM_ITERATIONS)\n                self.assertEqual(results[1], expected)\n\n    def test_ignored_method_binding(self):\n        class Bar(torch.nn.Module):\n            def __init__(self):\n                super(Bar, self).__init__()\n                self.x : int = 0\n\n            @torch.jit.export\n            def setx(self, x : int):\n                self.x = x\n\n            @torch.jit.export\n            def getx(self):\n                return self.x\n\n            @torch.jit.ignore\n            def ignored_getx(self):\n                return self.x\n\n        b = Bar()\n        b.setx(123)\n        sb = torch.jit.script(b)\n        self.assertEqual(sb.getx(), 123)\n        self.assertEqual(sb.ignored_getx(), 123)\n\n        sb.setx(456)\n        self.assertEqual(sb.getx(), 456)\n        self.assertEqual(sb.ignored_getx(), 456)\n\n    def test_set_attribute_through_optional(self):\n        class A(torch.nn.Module):\n            __annotations__ = {\"x\": Optional[torch.Tensor]}\n\n            def __init__(self):\n                super(A, self).__init__()\n                self.x = None\n\n            @torch.jit.ignore\n            def foo(self):\n                if self.x is None:\n                    self.x = torch.tensor([3])\n                return self.x\n\n            def forward(self, x):\n                a = self.foo()\n                return x + 1\n\n        m = torch.jit.script(A())\n        self.assertEqual(m.x, None)\n        m(torch.rand(1))\n        self.assertEqual(m.x, torch.tensor([3]))\n\n    def test_mutate_constant(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = [\"foo\"]\n\n            def __init__(self, foo):\n                super(M, self).__init__()\n                self.foo = foo\n\n        m = M(5)\n        # m has a constant attribute, but we can't\n        # assign to it\n        with self.assertRaises(RuntimeError):\n            m.foo = 6\n\n    def test_class_attribute(self):\n        class M(torch.jit.ScriptModule):\n            FOO = 0\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.foo = self.FOO\n        m = M()\n        self.assertEqual(m.foo, M.FOO)\n\n    def test_class_attribute_in_script(self):\n        class M(torch.jit.ScriptModule):\n            FOO = 0\n\n            def __init__(self):\n                super(M, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.FOO\n        with self.assertRaises(RuntimeError):\n            M()\n\n    def test_not_initialized_err(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                self.foo = torch.rand(2, 3)\n        with self.assertRaises(RuntimeError):\n            M()\n\n    def test_attribute_in_init(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.foo = torch.jit.Attribute(0.1, float)\n                # we should be able to use self.foo as a float here\n                assert 0.0 < self.foo\n        M()\n\n    def test_scriptable_fn_as_attr(self):\n        class M(torch.nn.Module):\n            def __init__(self, fn):\n                super(M, self).__init__()\n                self.fn = fn\n\n            def forward(self, x):\n                return self.fn(x)\n\n        m = M(torch.sigmoid)\n        inp = torch.rand(2, 3)\n        self.checkModule(m, (inp, ))\n\n    def test_sequence_parsing(self):\n        tests = [\n            (\"return [x, x,]\", True),\n            (\"return [x x]\", \"expected ]\"),\n            (\"return x, x,\", True),\n            (\"return bar(x, x,)\", True),\n            (\"return bar()\", \"Argument x not provided\"),\n            (\"for a, b, in x, x,:\\n        pass\", \"List of iterables\"),\n            (\"a, b, = x, x,\\n    return a + b\", True)\n        ]\n        for exp, result in tests:\n            cu = torch.jit.CompilationUnit()\n            full = \"\"\"\ndef bar(x, y):\n    return x + y\ndef foo(x):\n    {}\n            \"\"\".format(exp)\n            if isinstance(result, str):\n                with self.assertRaisesRegex(RuntimeError, result):\n                    cu.define(full)\n            else:\n                cu.define(full)\n\n    def test_namedtuple_python(self):\n        global MyTuple, MyMod  # see [local resolution in python]\n        MyTuple = namedtuple('MyTuple', ['a'])\n\n        @torch.jit.unused\n        def fn():\n            # type: () -> MyTuple\n            return MyTuple(1)\n\n        # Only check compilation\n        @torch.jit.script\n        def fn2():\n            # type: () -> MyTuple\n            return fn()\n\n        FileCheck().check(\"NamedTuple\").run(fn2.graph)\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n\n            @torch.jit.unused\n            def fn(self):\n                # type: () -> MyTuple\n                return MyTuple(1)\n\n            def forward(self, x):\n                if 1 == 1:\n                    return MyTuple(torch.rand(2, 3))\n                else:\n                    return self.fn()\n\n        # shouldn't throw a type error\n        torch.jit.script(MyMod())\n\n    def test_unused_decorator(self):\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n\n            @torch.jit.unused\n            @torch.no_grad()\n            def fn(self, x):\n                # type: (Tensor) -> int\n                return next(x)  # invalid, but should be ignored\n\n            def forward(self, x):\n                return self.fn(x)\n\n        torch.jit.script(MyMod())\n\n    @_inline_everything\n    def test_lazy_script(self):\n        def untraceable(x):\n            if x.ndim > 2:\n                print(\"hello\")\n            else:\n                print(\"goodbye\")\n            return x + 2\n\n        # Non-working example\n        def fn(x):\n            return untraceable(x)\n\n        with self.capture_stdout():\n            traced_bad = torch.jit.trace(fn, [torch.ones(2, 2)])\n\n        FileCheck().check_not(\"goodbye\").check_not(\"hello\").run(traced_bad.graph)\n\n        # Working example\n        untraceable = torch.jit.script_if_tracing(untraceable)\n\n        def fn2(x):\n            return untraceable(x)\n\n        with self.capture_stdout():\n            traced = torch.jit.trace(fn, [torch.ones(2, 2)])\n\n        FileCheck().check(\"goodbye\").run(traced.graph)\n\n        def foo(x: int):\n            return x + 1\n\n        @torch.jit.script_if_tracing\n        def fee(x: int = 2):\n            return foo(1) + x\n\n        # test directly compiling function\n        fee_compiled = torch.jit.script(fee)\n        self.assertEqual(fee_compiled(), fee())\n\n        # test compiling it within another function\n        @torch.jit.script\n        def hum():\n            return fee(x=3)\n\n        self.assertEqual(hum(), 5)\n\n    def test_big_int_literals(self):\n        def ok():\n            # signed 64 bit max\n            a = 9223372036854775807\n            return a\n\n        def toobig():\n            a = 9223372036854775808\n            return a\n\n        def waytoobig():\n            a = 99999999999999999999\n            return a\n\n        self.checkScript(ok, [])\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(toobig)\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(waytoobig)\n\n    def test_hex_literals(self):\n        def test1():\n            return 0xaaaaaa\n\n        def test2():\n            return 0xaaaaaa\n\n        def test3():\n            return -0xaaaaaa\n\n        self.checkScript(test1, [])\n        self.checkScript(test2, [])\n        self.checkScript(test3, [])\n\n        def ok():\n            a = 0x7FFFFFFFFFFFFFFF\n            return a\n\n        def toobig():\n            a = 0xFFFFFFFFFFFFFFFF\n            return a\n\n        def waytoobig():\n            a = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            return a\n\n        self.checkScript(ok, [])\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(toobig)\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(waytoobig)\n\n    def test_big_float_literals(self):\n        def ok():\n            # Python interprets this as inf\n            a = 1.2E400\n            return a\n\n        def check(fn):\n            self.assertTrue(fn() == ok())\n\n        # checkScript doesn't work since assertEqual doesn't consider\n        # `inf` == `inf`\n        check(torch.jit.script(ok))\n\n        cu = torch.jit.CompilationUnit()\n        cu.define(dedent(inspect.getsource(ok)))\n        check(cu.ok)\n\n    def _test_device_type(self, dest):\n        def fn(x):\n            # type: (Device) -> Tuple[str, Optional[int]]\n            return x.type, x.index\n\n        device = torch.ones(2).to(dest).device\n        self.checkScript(fn, [device])\n\n    def test_device_type(self):\n        self._test_device_type('cpu')\n\n    @unittest.skipIf(not RUN_CUDA, \"Requires CUDA\")\n    def test_device_type_cuda(self):\n        self._test_device_type('cuda')\n\n    def test_string_device_implicit_conversion(self):\n        @torch.jit.script\n        def fn(x: torch.device):\n            return x\n\n        self.assertEqual(fn(\"cpu\"), torch.device(\"cpu\"))\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected one of\"):\n            fn(\"invalid_device\")\n\n    def test_eval_python(self):\n        def _test(m):\n            self.assertTrue(m(torch.ones(2, 2)))\n            self.assertTrue(m.training)\n            self.assertTrue(m._c.getattr('training'))\n\n            m.eval()\n\n            self.assertFalse(m.training)\n            self.assertFalse(m._c.getattr('training'))\n            self.assertFalse(m(torch.ones(2, 2)))\n\n            buffer = io.BytesIO()\n            torch.jit.save(m, buffer)\n            buffer.seek(0)\n\n            loaded = torch.jit.load(buffer)\n\n            self.assertFalse(loaded.training)\n            self.assertFalse(loaded._c.getattr('training'))\n\n        class M(nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, x):\n                return self.training\n\n        class OldM(torch.jit.ScriptModule):\n            def __init__(self):\n                super(OldM, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.training\n\n        _test(torch.jit.script(M()))\n        _test(OldM())\n\n    def test_inherit_method(self):\n        class A(torch.jit.ScriptModule):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.bar(x)\n\n        class B(A):\n            def __init__(self):\n                super(B, self).__init__()\n\n            @torch.jit.script_method\n            def bar(self, x):\n                return x * x\n\n        with self.assertRaisesRegex(RuntimeError, 'attribute'):\n            A()  # cannot use because bar is not defined\n\n        v = torch.rand(3, 4)\n        b = B()\n        self.assertEqual(b(v), v + v * v)\n\n        class C(torch.jit.ScriptModule):\n            def __init__(self):\n                super(C, self).__init__()\n\n            @torch.jit.script_method\n            def bar(self, x):\n                return x\n\n        class D(C, B):\n            def __init__(self):\n                super(D, self).__init__()\n\n        self.assertEqual(D()(v), v + v)\n\n    def test_tensor_subclasses(self):\n        def check_subclass(x, tensor):\n            template = dedent(\"\"\"\n                def func(input: {}) -> {}:\n                    return torch.zeros((input.shape[0], 1), dtype=input.dtype)\n                \"\"\")\n\n            self._check_code(template.format(x, x), \"func\", [tensor])\n\n        check_subclass(\"torch.LongTensor\", torch.LongTensor([[1, 2], [3, 4]]))\n        check_subclass(\"torch.DoubleTensor\", torch.DoubleTensor([[1.2, 2.3], [3.4, 4.5]]))\n        check_subclass(\"torch.IntTensor\", torch.IntTensor([[1, 2], [3, 4]]))\n        check_subclass(\"torch.BoolTensor\", torch.BoolTensor([[False, True], [True, False]]))\n\n        def check_subclass_warn(input: torch.LongTensor) -> torch.LongTensor:\n            return torch.zeros((input.shape[0], 1), dtype=input.dtype)\n\n        with warnings.catch_warnings(record=True) as warns:\n            scripted = torch.jit.script(check_subclass_warn)\n        FileCheck().check(\"TorchScript will treat type annotations of Tensor\").run(str(warns[0]))\n\n    def test_first_class_module(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.foo = nn.Parameter(torch.rand(3, 4))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                self.foo = input\n                return self.foo\n        foo = Foo()\n        input = torch.rand(3, 4)\n        foo.forward(input)\n        self.assertEqual(input, foo.foo)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_first_class_calls(self):\n        @torch.jit.script\n        class Foo(object):\n            def __init__(self, x):\n                self.bar = x\n\n            def stuff(self, x):\n                return self.bar + x\n\n        @torch.jit.script\n        def foo(x):\n            return x * x + Foo(x).stuff(2 * x)\n\n        @torch.jit.script\n        def bar(x):\n            return foo(x) * foo(x)\n\n        x = torch.rand(3, 4)\n        self.assertEqual(bar(x), (x * x + 3 * x) * (x * x + 3 * x))\n\n    def test_static_methods(self):\n        class M(nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            @staticmethod\n            def my_method(x):\n                return x + 100\n\n            def forward(self, x):\n                return x + M.my_method(x)\n\n        class N(nn.Module):\n            def __init__(self):\n                super(N, self).__init__()\n\n            @staticmethod\n            def my_method(x):\n                return x * 100\n\n            def forward(self, x):\n                return x - M.my_method(x) + N.my_method(x)\n\n        self.checkModule(M(), (torch.ones(2, 2),))\n\n        self.checkModule(N(), (torch.ones(2, 2),))\n\n    def test_invalid_prefix_annotation(self):\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation1(a):\n                    #type: (Int) -> Int # noqa: E265\n                    return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation2(a):\n                    #type   : (Int) -> Int # noqa: E265\n                    return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation3(a):\n                    #     type: (Int) -> Int\n                    return a + 2\n\n    def test_builtin_function_attributes(self):\n        class Add(nn.Module):\n            def __init__(self):\n                super(Add, self).__init__()\n                self.add = torch.add\n\n            def forward(self, input):\n                return self.add(input, input)\n\n        self.checkModule(Add(), [torch.randn(2, 2)])\n\n    def test_pybind_type_comparisons(self):\n        @torch.jit.script\n        def f():\n            return None\n\n        node = list(f.graph.nodes())[0]\n        t = node.outputsAt(0).type()\n        self.assertIsNotNone(t)\n\n    @unittest.skipIf(IS_WINDOWS and sys.version_info >= (3, 8), 'TODO: need to fix the test case')\n    def test_unmatched_type_annotation(self):\n        message1 = re.escape(\"Number of type annotations (2) did not match the number of function parameters (1):\")\n        message2 = 'def invalid2\\\\(a\\\\):\\n\\\\s*~+\\\\.*\\\\s+<--- HERE\\n\\\\s+# type: \\\\(Int, Int\\\\) -> Int\\n\\\\s+return a \\\\+ 2'\n        message3 = 'def invalid4\\\\(a\\\\):\\n\\\\s*~+\\\\.*\\\\s+<--- HERE\\n\\\\s+# type: \\\\(Int, Int\\\\) -> Int\\n\\\\s+return a \\\\+ 2'\n        with self.assertRaisesRegex(RuntimeError, message1):\n            @torch.jit.script\n            def invalid1(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, message2):\n            @torch.jit.script\n            def invalid2(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, message1):\n            def invalid3(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n            torch.jit.script(invalid3)\n\n        with self.assertRaisesRegex(RuntimeError, message3):\n            def invalid4(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n            torch.jit.script(invalid4)\n\n    def test_is_optional(self):\n        ann = Union[List[int], List[float]]\n        torch._jit_internal.is_optional(ann)\n\n    def test_interpreter_fuzz(self):\n        import builtins\n        # This test generates random tree-like programs to fuzz test\n        # that the interpreter does not have a bug in its stack manipulation\n        # code. An assert in that code ensures individual operators are\n        # not reordered.\n        templates = [\n            \"torch.rand(3, 4)\",\n            \"({} + {})\",\n            \"-{}\",\n            \"({} * {})\",\n            \"torch.tanh({})\",\n            \"VAR {}\",\n        ]\n\n        def gen_code():\n            src_lines = ['def f():']\n            exprs = []\n            n_variables = 0\n\n            def get_expr(idx):\n                elem = exprs[idx]\n                exprs[idx] = exprs[-1]\n                exprs.pop()\n                return elem\n\n            def select_expr_or_var():\n                idx = random.randrange(0, len(exprs) + n_variables)\n                if idx < len(exprs):\n                    return get_expr(idx)\n                else:\n                    return 'v{}'.format(idx - len(exprs))\n\n            for i in range(50):\n                n = None\n                while n is None or n > len(exprs) + n_variables:\n                    template = random.choice(templates)\n                    n = template.count('{}')\n\n                if 'VAR' in template:\n                    src_lines.append('  v{} = {}'.format(n_variables, select_expr_or_var()))\n                    n_variables += 1\n                else:\n                    exprs.append(template.format(*(select_expr_or_var() for _ in range(n))))\n\n            src_lines.append('  return ({})\\n'.format(''.join('v{},'.format(i) for i in range(n_variables))))\n            return '\\n'.join(src_lines)\n\n        for i in range(100):\n            g = {'torch': torch}\n            code = gen_code()\n            builtins.exec(code, g, None)\n            cu = torch.jit.CompilationUnit(code)\n            with freeze_rng_state():\n                o1 = g['f']()\n            with freeze_rng_state():\n                o2 = cu.f()\n            self.assertEqual(o1, o2)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_cpp_module_iterator(self):\n        a = nn.Module()\n        a.name = 'a'\n        a.p = nn.Parameter(torch.rand(3, 4))\n        a.foo = nn.Module()\n        a.foo.name = 'foo'\n        a.foo.register_buffer('b', torch.rand(1, 1))\n        a.foo.bar = nn.Module()\n        a.foo.bar.name = 'bar'\n        a.foo.bar.an_int = 4\n        a.another = nn.Module()\n        a.another.name = 'another'\n        sa = torch.jit.script(a)\n        result = torch._C._jit_debug_module_iterators(sa._c)\n\n        def replace(e):\n            if e is a.p:\n                return 'P'\n            elif e is a.foo.b:\n                return 'B'\n            elif isinstance(e, torch._C.ScriptModule):\n                return e.getattr('name')\n\n            return e\n        for k, v in result.items():\n            for i in range(len(v)):\n                if isinstance(v[i], tuple):\n                    n, v2 = v[i]\n                    v[i] = (n, replace(v2))\n                else:\n                    v[i] = replace(v[i])\n            # module type creation is not deterministic, so we have to sort\n            # the result\n            v.sort()\n        expected = {'buffers': [],\n                    'buffers_r': ['B'],\n                    'children': ['another', 'foo'],\n                    'modules': ['a', 'another', 'bar', 'foo'],\n                    'named_attributes': [('_is_full_backward_hook', None),\n                                         ('another', 'another'),\n                                         ('foo', 'foo'),\n                                         ('name', 'a'),\n                                         ('p', 'P'),\n                                         ('training', True)],\n                    'named_attributes_r': [('_is_full_backward_hook', None),\n                                           ('another', 'another'),\n                                           ('another._is_full_backward_hook', None),\n                                           ('another.name', 'another'),\n                                           ('another.training', True),\n                                           ('foo', 'foo'),\n                                           ('foo._is_full_backward_hook', None),\n                                           ('foo.b', 'B'),\n                                           ('foo.bar', 'bar'),\n                                           ('foo.bar._is_full_backward_hook', None),\n                                           ('foo.bar.an_int', 4),\n                                           ('foo.bar.name', 'bar'),\n                                           ('foo.bar.training', True),\n                                           ('foo.name', 'foo'),\n                                           ('foo.training', True),\n                                           ('name', 'a'),\n                                           ('p', 'P'),\n                                           ('training', True)],\n                    'named_buffers': [],\n                    'named_buffers_r': [('foo.b', 'B')],\n                    'named_children': [('another', 'another'), ('foo', 'foo')],\n                    'named_modules': [('', 'a'),\n                                      ('another', 'another'),\n                                      ('foo', 'foo'),\n                                      ('foo.bar', 'bar')],\n                    'named_parameters': [('p', 'P')],\n                    'named_parameters_r': [('p', 'P')],\n                    'parameters': ['P'],\n                    'parameters_r': ['P']}\n        self.assertEqual(expected, result)\n\n    def test_parameter_order(self):\n        m = nn.Module()\n        for i, name in enumerate(string.ascii_letters):\n            setattr(m, name, nn.Parameter(torch.tensor([float(i)])))\n        ms = torch.jit.script(m)\n        print(torch.cat(list(m.parameters())))\n        print(torch.cat(list(ms.parameters())))\n        self.assertEqual(list(m.parameters()), list(ms.parameters()))\n\n    def test_python_op_builtins(self):\n        @torch.jit.unused\n        def fn(x):\n            # type: (List[int]) -> int\n            return sum(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            # type: (List[int]) -> int\n            return fn(x)\n\n    def test_submodule_twice(self):\n        @torch.jit.script\n        def foo(x):\n            return x * x\n\n        class What(torch.jit.ScriptModule):\n            def __init__(self, x):\n                super(What, self).__init__()\n                self.foo = x\n        a = What(foo)\n        c = What(foo)\n\n    def test_training_param(self):\n        class What(torch.jit.ScriptModule):\n            def __init__(self):\n                super(What, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (int) -> int\n                if self.training:\n                    r = x\n                else:\n                    r = x + 4\n                # check double use of training\n                if self.training:\n                    r = r + 1\n                return r\n\n        w = What()\n        self.assertEqual(4, w(3))\n        w.train(False)\n        self.assertEqual(7, w(3))\n        self.assertFalse(\"training\" in w.state_dict())\n\n    def test_class_as_attribute(self):\n        @torch.jit.script\n        class Foo321(object):\n            def __init__(self):\n                self.x = 3\n\n        class FooBar1234(torch.nn.Module):\n            def __init__(self):\n                super(FooBar1234, self).__init__()\n                self.f = Foo321()\n\n            def forward(self, x):\n                return x + self.f.x\n\n        scripted = torch.jit.script(FooBar1234())\n        eic = self.getExportImportCopy(scripted)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted(x), eic(x))\n\n    def test_module_str(self):\n        class Foo(torch.nn.Module):\n            def forward(self, x):\n                return torch.relu(x)\n\n        f = torch.jit.script(Foo())\n        self.assertEqual('ScriptObject', str(f._c))\n\n    def test_jitter_bug(self):\n        @torch.jit.script\n        def fn2(input, kernel_size):\n            # type: (Tensor, List[int]) -> Tensor\n            if kernel_size[0] > 1:\n                _stride = [2]\n            else:\n                _stride = kernel_size\n            print(_stride, kernel_size)\n            return input\n\n        @torch.jit.script\n        def fn(input):\n            # type: (Tensor) -> Tensor\n            return fn2(input, [1])\n\n    def test_parser_kwargonly(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x, *, y) -> Tuple[Tensor, Tensor]:\n                return x, x\n            def bar(x):\n                return foo(x, y=x)\n        ''')\n        self.assertTrue('*' in str(cu.foo.schema))\n        with self.assertRaisesRegex(RuntimeError, \"not provided\"):\n            torch.jit.CompilationUnit('''\n                def foo(x, *, y) -> Tuple[Tensor, Tensor]:\n                    return x, x\n                def bar(x):\n                    return foo(x, x)\n            ''')\n\n    def test_annoying_doubles(self):\n        mod = types.ModuleType(\"temp\")\n        mod.inf = float(\"inf\")\n        mod.ninf = float(\"-inf\")\n        mod.nan = float(\"nan\")\n\n        with torch._jit_internal._disable_emit_hooks():\n            class Foo(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(Foo, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self):\n                    return math.pi, 0.1, mod.inf, mod.ninf, 2.225073858507201e-308, mod.nan\n\n            foo = Foo()\n            buffer = io.BytesIO()\n            torch.jit.save(foo, buffer)\n\n            buffer.seek(0)\n            foo_loaded = torch.jit.load(buffer)\n\n            r = foo()\n            r2 = foo_loaded()\n            # use precise assert, we are checking floating point details\n            self.assertTrue(r[:-1] == r2[:-1])\n            self.assertTrue(math.isnan(r[-1]) and math.isnan(r2[-1]))\n\n    def test_type_annotate(self):\n\n        def foo(a):\n            return torch.jit.annotate(torch.Tensor, a)\n\n        self.checkScript(foo, (torch.rand(3),))\n\n        def bar():\n            a = torch.jit.annotate(List[int], [])\n            for _ in range(10):\n                a.append(4)\n            return a\n\n        self.checkScript(bar, ())\n\n        def baz(a):\n            return torch.jit.annotate(float, a)\n        self.checkScript(baz, (torch.rand(()),))\n\n        # test annotate none types\n        def annotate_none():\n            return torch.jit.annotate(Optional[torch.Tensor], None)\n\n        self.checkScript(annotate_none, ())\n\n\n    def test_robust_op_resolution(self):\n        neg = torch.add  # misleading name to make sure we resolve by function\n\n        def stuff(x):\n            return neg(x, x)\n\n        a = (torch.rand(3),)\n        self.checkScript(stuff, a)\n\n    def test_nested_aug_assign(self):\n        @torch.jit.script\n        class SomeClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __iadd__(self, x):\n                # type: (int)\n                self.num += x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        @torch.jit.script\n        class SomeOutOfPlaceClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __add__(self, x):\n                # type: (int)\n                self.num = x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        class Child(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.x = 2\n                self.o = SomeClass()\n                self.oop = SomeOutOfPlaceClass()\n                self.list = [1, 2, 3]\n\n        class A(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.child = Child()\n\n            def forward(self):\n                self.child.x += 1\n                self.child.o += 5\n                self.child.oop += 5\n                some_list = [1, 2]\n                self.child.list += some_list\n                self.child.list *= 2\n                return self.child.x, self.child.o, self.child.list, self.child.oop\n\n        a = A()\n        sa = torch.jit.script(A())\n        eager_result = a()\n        script_result = sa()\n        self.assertEqual(eager_result, script_result)\n        self.assertEqual(a.child.x, sa.child.x)\n        self.assertEqual(a.child.o, sa.child.o)\n        self.assertEqual(a.child.list, sa.child.list)\n\n        @torch.jit.script\n        class SomeNonAddableClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        # with self.assertRaisesRegex(RuntimeError, \"\")\n        class A(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.x = SomeNonAddableClass()\n\n            def forward(self):\n                self.x += SomeNonAddableClass()\n                return self.x\n\n        with self.assertRaisesRegex(RuntimeError, \"Cannot emit inplace op\"):\n            torch.jit.script(A())\n\n    def test_var_aug_assign(self):\n        @torch.jit.script\n        class SomeNonAddableClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __eq__(self, other):\n                # type: (SomeNonAddableClass) -> bool\n                return self.num == other.num\n\n        with self.assertRaisesRegex(RuntimeError, \"Cannot emit inplace op\"):\n            @torch.jit.script\n            def fn():\n                a = SomeNonAddableClass()\n                a += SomeNonAddableClass()\n                return a\n\n        @torch.jit.script\n        class SomeClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __iadd__(self, x):\n                # type: (int)\n                self.num += x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        @torch.jit.script\n        class SomeOutOfPlaceClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __add__(self, x):\n                # type: (int)\n                self.num = x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        def fn2():\n            a = SomeClass()\n            a_copy = a\n            a += 20\n            assert a is a_copy\n            b = SomeOutOfPlaceClass()\n            b_copy = b\n            b += 99\n            assert b is b_copy\n            c = [1, 2, 3]\n            c_copy = c\n            c *= 2\n            assert c is c_copy\n            c += [4, 5, 6]\n            d = torch.ones(2, 2)\n            d_copy = d\n            d += torch.ones(2, 2)\n            assert d is d_copy\n            return a, b, c, d\n\n        self.checkScript(fn2, [])\n\n    def test_nested_list_construct(self):\n        def foo():\n            return [[4]] + [[4, 5]]\n        self.checkScript(foo, ())\n\n    def test_file_line_error(self):\n        def foobar(xyz):\n            return torch.blargh(xyz)\n\n        _, lineno = inspect.getsourcelines(foobar)\n        with self.assertRaisesRegex(RuntimeError, \"test_jit.py\\\", line {}\".format(lineno + 1)):\n            scripted = torch.jit.script(foobar)\n\n    def test_file_line_error_class_defn(self):\n        class FooBar(object):\n            def baz(self, xyz):\n                return torch.blargh(xyz)\n\n        _, lineno = inspect.getsourcelines(FooBar)\n        with self.assertRaisesRegex(RuntimeError, \"test_jit.py\\\", line {}\".format(lineno + 2)):\n            torch.jit.script(FooBar)\n\n    def test_file_line_graph(self):\n        def foobar(xyz):\n            return torch.neg(xyz)\n\n        scripted = torch.jit.script(foobar)\n\n        _, lineno = inspect.getsourcelines(foobar)\n        fc = FileCheck().check('test_jit.py:{}:19'.format(lineno + 1))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_file_line_save_load(self):\n        class Scripted(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, xyz):\n                return torch.neg(xyz)\n\n        scripted = Scripted()\n\n        # NB: not using getExportImportCopy because that takes a different\n        # code path that calls CompilationUnit._import rather than\n        # going through the full save/load pathway\n        buffer = scripted.save_to_buffer()\n        bytesio = io.BytesIO(buffer)\n        scripted = torch.jit.load(bytesio)\n\n        _, lineno = inspect.getsourcelines(Scripted)\n        fc = FileCheck().check(':{}'.format(lineno + 3))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_file_line_string(self):\n        scripted = torch.jit.CompilationUnit('''\ndef foo(xyz):\n    return torch.neg(xyz)\n        ''')\n\n        fc = FileCheck().check('<string>:3:11')\n        fc.run(scripted.foo.graph)\n        fc.run(str(scripted.foo.graph))\n\n    @skipIfCrossRef\n    def test_file_line_trace(self):\n        def foobar(xyz):\n            return torch.neg(xyz)\n\n        scripted = torch.jit.trace(foobar, (torch.rand(3, 4)))\n\n        _, lineno = inspect.getsourcelines(foobar)\n        fc = FileCheck().check('test_jit.py:{}:0'.format(lineno + 1))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_serialized_source_ranges(self):\n\n        class FooTest(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, w):\n                return torch.mm(x, w.t())\n\n        ft = FooTest()\n        loaded = self.getExportImportCopy(ft)\n        _, lineno = inspect.getsourcelines(FooTest)\n\n        with self.assertRaisesRegex(RuntimeError, 'test_jit.py\\\", line {}'.format(lineno + 3)):\n            loaded(torch.rand(3, 4), torch.rand(30, 40))\n\n    def test_serialized_source_ranges_graph(self):\n\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, w):\n                return torch.mm(x, w.t())\n\n        ft = FooTest3()\n        loaded = self.getExportImportCopy(ft)\n        _, lineno = inspect.getsourcelines(FooTest3)\n\n        fc = FileCheck().check('test_jit.py:{}'.format(lineno + 3))\n        fc.run(loaded.graph)\n\n    def test_serialized_source_ranges2(self):\n\n        class FooTest2(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self):\n                raise RuntimeError('foo')\n\n        _, lineno = inspect.getsourcelines(FooTest2)\n\n        with self.assertRaisesRegex(torch.jit.Error, 'test_jit.py\\\", line {}'.format(lineno + 3)):\n            ft = FooTest2()\n            loaded = self.getExportImportCopy(ft)\n            loaded()\n\n    def test_serialized_source_ranges_dont_jitter(self):\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, lim):\n                first = 1\n                second = 1\n                i = 1\n                somenum = 5\n                dontmutateme = 3\n                third = 0\n                while bool(i < lim):\n                    third = first + second\n                    first = second\n                    second = third\n                    j = 0\n                    while j < 10:\n                        somenum = somenum * 2\n                        j = j + 1\n                    i = i + j\n                    i = i + dontmutateme\n\n                st = second + third\n                fs = first + second\n                return third, st, fs\n\n        ft3 = FooTest3()\n\n        def debug_records_from_mod(self, mod):\n            buffer = io.BytesIO()\n            torch.jit.save(ft3, buffer)\n            buffer.seek(0)\n            archive = zipfile.ZipFile(buffer)\n            files = filter(lambda x: x.startswith('archive/code/'), archive.namelist())\n            debug_files = list(filter(lambda f: f.endswith('.debug_pkl'), files))\n            self.assertEqual(len(debug_files), 1)\n            debug_file = archive.open(debug_files[0])\n            return pickle.load(debug_file), buffer\n\n        records1, buffer = debug_records_from_mod(self, ft3)\n\n        buffer.seek(0)\n        loaded = torch.jit.load(buffer)\n        records2, buffer = debug_records_from_mod(self, loaded)\n\n        buffer.seek(0)\n        loaded2 = torch.jit.load(buffer)\n        records3, _ = debug_records_from_mod(self, loaded2)\n\n        self.assertEqual(records1, records2)\n        self.assertEqual(records2, records3)\n\n    def test_serialized_source_ranges_no_dups(self):\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, lim):\n                first = 1\n                second = 1\n                i = 1\n                somenum = 5\n                dontmutateme = 3\n                third = 0\n                while bool(i < lim):\n                    third = first + second\n                    first = second\n                    second = third\n                    j = 0\n                    while j < 10:\n                        somenum = somenum * 2\n                        j = j + 1\n                    i = i + j\n                    i = i + dontmutateme\n\n                st = second + third\n                fs = first + second\n                return third, st, fs\n\n        ft3 = FooTest3()\n\n        def debug_records_from_mod(mod):\n            buffer = io.BytesIO()\n            torch.jit.save(ft3, buffer)\n            buffer.seek(0)\n            archive = zipfile.ZipFile(buffer)\n            files = list(filter(lambda x: x.startswith('archive/code/'), archive.namelist()))\n            debug_files = filter(lambda f: f.endswith('.debug_pkl'), files)\n            debug_files = (archive.open(f) for f in debug_files)\n            debug_files = (pickle.load(f) for f in debug_files)\n            debug_files = (f[2] for f in debug_files)\n            return list(debug_files)\n\n        debug_files = debug_records_from_mod(ft3)\n        for debug_file in debug_files:\n            for i in range(len(debug_file) - 1):\n                offset, source_range_tag, source_range = debug_file[i]\n                offset2, source_range_tag2, source_range2 = debug_file[i + 1]\n                self.assertNotEqual(source_range, source_range2)\n\n    def test_circular_dependency(self):\n        \"\"\"\n        https://github.com/pytorch/pytorch/issues/25871\n        \"\"\"\n        class A(torch.jit.ScriptModule):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x\n\n        class B(torch.jit.ScriptModule):\n            def __init__(self):\n                super(B, self).__init__()\n                self.foo = torch.nn.ModuleList([A()])\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for f in self.foo:\n                    x = f(x)\n                return x\n\n        class C(torch.jit.ScriptModule):\n            def __init__(self):\n                super(C, self).__init__()\n                self.foo = torch.nn.Sequential(B())\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for f in self.foo:\n                    x = f(x)\n                return x\n        self.getExportImportCopy(C())\n\n    def test_serialize_long_lines(self):\n        class OrderModuleLong(torch.nn.Module):\n            def forward(self, long_arg_name: List[torch.Tensor]):\n                return [(long_arg_name[1],), (long_arg_name[0].argmax(),)]\n        src = str(torch.jit.script(OrderModuleLong()).code)\n        # make long_arg_name[1] does not get reordered after the argmax\n        FileCheck().check(\"long_arg_name[1]\").check(\"argmax\").run(src)\n\n    def test_tensor_shape(self):\n        x = torch.empty(34, 56, 78)\n\n        def f(x):\n            return x.shape\n\n        self.checkScript(f, (x,))\n\n\n    def test_block_input_grad_in_loop(self):\n\n        x = torch.randn(3, 3, requires_grad=False)\n        y = torch.randn(3, 3, requires_grad=True)\n\n        def grad_in_loop(x, y):\n            for i in range(100):\n                x = y @ x\n            return x\n\n        scripted = torch.jit.script(grad_in_loop)\n        outer = scripted.graph_for(x, y)\n        loop = outer.findNode(\"prim::Loop\")\n        loop_block = next(loop.blocks())\n        param_node = loop_block.paramNode()\n        x_value = list(param_node.outputs())[1]\n        self.assertTrue(x_value.requires_grad())\n\n    def test_tensor_grad(self):\n        x = torch.randn(3, 4, requires_grad=True)\n        y = torch.randn(3, 4, requires_grad=False)\n\n        def f_requires_grad(x):\n            return x.requires_grad\n\n        self.checkScript(f_requires_grad, (x,))\n        self.checkScript(f_requires_grad, (y,))\n\n        def f_grad(x):\n            return x.grad\n\n        x.sum().backward()\n        self.checkScript(f_grad, (x,))\n        self.checkScript(f_grad, (y,))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"shape analysis is only enabled in Legacy\")\n    def test_prim_grad_undefined(self):\n\n        x = torch.ones(2)\n\n        def f_grad(x):\n            return x.grad\n\n        scripted = self.checkScript(f_grad, (x,))\n        g = scripted.graph_for(x)\n\n        prim_grad_node = g.findNode(\"prim::grad\")\n        self.assertTrue(next(prim_grad_node.outputs()).type().undefined() is None)\n\n    def test_tensor_data(self):\n        x = torch.randn(3, 4, requires_grad=True)\n        y = torch.randn(4, 5)\n\n        def f_data(x):\n            return x.data\n\n        scripted_f_data = torch.jit.script(f_data)\n\n        scripted_x = scripted_f_data(x)\n        self.assertEqual(scripted_x, f_data(x))\n        self.assertEqual(scripted_x.requires_grad, False)\n\n        scripted_y = scripted_f_data(y)\n        self.assertEqual(scripted_y, f_data(y))\n        self.assertEqual(scripted_x.requires_grad, False)\n\n    def test_tensor_dtype(self):\n        x_byte = torch.empty(34, 56, 78, dtype=torch.uint8)\n        x_long = torch.empty(34, 56, 78, dtype=torch.long)\n        x_float32 = torch.empty(34, 56, 78, dtype=torch.float32)\n\n        @torch.jit.script\n        def byte(x):\n            return x.dtype == torch.uint8\n\n        @torch.jit.script\n        def long(x):\n            return x.dtype == torch.long\n\n        @torch.jit.script\n        def float32(x):\n            return x.dtype == torch.float32\n\n        self.assertTrue(byte(x_byte))\n        self.assertFalse(byte(x_long))\n        self.assertFalse(byte(x_float32))\n        self.assertFalse(long(x_byte))\n        self.assertTrue(long(x_long))\n        self.assertFalse(long(x_float32))\n        self.assertFalse(float32(x_byte))\n        self.assertFalse(float32(x_long))\n        self.assertTrue(float32(x_float32))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_device(self):\n        cpu = torch.empty(34, 56, 78, device='cpu')\n        gpu = torch.empty(34, 56, 78, device='cuda')\n\n        @torch.jit.script\n        def same_device(x, y):\n            return x.device == y.device\n\n        self.assertTrue(same_device(cpu, cpu))\n        self.assertTrue(same_device(gpu, gpu))\n        self.assertFalse(same_device(cpu, gpu))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_to_device(self):\n        def to_device(x):\n            return x.to(device=\"cuda\").to(device=torch.device(\"cpu\"))\n\n        self.checkScript(to_device, (torch.ones(3, 4),))\n\n    def test_tensor_to_cpu(self):\n        def to_cpu(x):\n            return x.cpu()\n\n        x = torch.ones(3, 4)\n        script_fn = torch.jit.script(to_cpu)\n        self.assertEqual(to_cpu(x).device, script_fn(x).device)\n        self.checkScript(to_cpu, (x,))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_to_cuda(self):\n        def to_cuda(x):\n            return x.cuda()\n\n        x = torch.ones(3, 4)\n        script_fn = torch.jit.script(to_cuda)\n        self.assertEqual(to_cuda(x).device, script_fn(x).device)\n        self.checkScript(to_cuda, (x,))\n\n    def test_generic_list_errors(self):\n        with self.assertRaisesRegex(RuntimeError, \"previously matched to type\"):\n            @torch.jit.script\n            def foo(x):\n                return [[x]] + [[1]]\n\n    def test_script_cu(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                b = a\n                return b\n        ''')\n        a = Variable(torch.rand(1))\n        self.assertEqual(a, cu.foo(a))\n\n    # because the compilation unit ingests python strings\n    # to use an escape sequence escape the backslash (\\\\n = \\n)\n    def test_string_cu(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                print(a, \"\"\"a\\\\n\\tb\\\\n\"\"\", 2, \"a\\\na\")\n                return a\n        ''')\n        FileCheck().check(\"aa\").check(\"a\\\\n\\\\tb\\\\n\").run(str(cu.foo.graph))\n\n    def test_function_compilation_caching(self):\n        def fun():\n            return 1 + 2\n\n        fun_compiled = torch.jit.script(fun)\n        # python wrapper around the script function is a different pointer,\n        # but the underlying script function graph is the same\n        self.assertIs(fun_compiled.graph, torch.jit.script(fun).graph)\n\n        def fun():\n            return 3 + 4\n\n        num_ref_counts = sys.getrefcount(fun)\n\n        # caching doesn't get tripped up by same qualname\n        fun_compiled_2 = torch.jit.script(fun)\n        self.assertIsNot(fun_compiled, fun_compiled_2)\n        self.assertEqual(fun_compiled_2(), 7)\n\n        # caching doesnt increase refcounts to function (holds weak reference)\n        self.assertTrue(sys.getrefcount(fun), num_ref_counts)\n\n    def test_string_ops(self):\n        def foo():\n            a = \"a\" + \"b\"\n            return a + a, \"ab\" == \"b\", \"ab\" != \"b\", \"ab\" == \"ab\", \"ab\" != \"ab\"\n\n        self.checkScript(foo, ())\n\n    def test_string_sorted(self):\n        def foo(strs: List[str]):\n            return sorted(strs)\n\n        FileCheck() \\\n            .check(\"graph\") \\\n            .check_next(\"str[] = aten::sorted\") \\\n            .check_next(\"return\") \\\n            .run(str(torch.jit.script(foo).graph))\n\n        inputs = [\"str3\", \"str2\", \"str1\"]\n        self.checkScript(foo, (inputs,))\n\n    def test_string_sort(self):\n        def foo(strs: List[str]):\n            strs.sort()\n            return strs\n\n        inputs = [\"str3\", \"str2\", \"str1\"]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sorted(self):\n        def foo(tups: List[Tuple[int, int]]):\n            return sorted(tups)\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sort(self):\n        def foo(tups: List[Tuple[int, int]]):\n            tups.sort()\n            return tups\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sort_reverse(self):\n        def foo(tups: List[Tuple[int, int]]):\n            tups.sort(reverse=True)\n            return tups\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_unsortable_element_type(self):\n        @torch.jit.script\n        def foo():\n            tups = [({1: 2}, {2: 3})]\n            tups.sort()\n            return tups\n\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"are not sortable\", \"tups.sort\"):\n            foo()\n\n    def test_tuple_unsortable_diff_type(self):\n        @torch.jit.script\n        def foo(inputs: List[Any]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, 2), (\"foo\", \"bar\")]\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Only values of same type can be compared\", \"inputs.sort\"):\n            foo(inputs)\n\n    def test_tuple_nested_sort(self):\n        def foo(inputs: List[Tuple[int, Tuple[int, str]]]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, (2, \"foo\")), (1, (2, \"bar\")), (1, (0, \"bar\"))]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_unsortable_nested_diff_type(self):\n        @torch.jit.script\n        def foo(inputs: List[Any]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, (2, 3)), (2, (\"foo\", \"bar\"))]\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Only values of same type can be compared\", \"inputs.sort\"):\n            foo(inputs)\n\n    def test_string_new_line(self):\n        with self.assertRaisesRegex(RuntimeError, \"expected a valid token*\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a):\n                print(\"\n                    a\")\n                return a\n            ''')\n\n    def test_string_single_escape(self):\n        with self.assertRaisesRegex(RuntimeError, \"expected a valid token*\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a):\n                print(\"\\\\\")\n                return a\n            ''')\n\n    def test_script_annotation(self):\n        @torch.jit.script\n        def foo(a):\n            return a + a + a\n        s = Variable(torch.rand(2))\n        self.assertEqual(s + s + s, foo(s))\n\n    def test_torch_pow(self):\n        def func(a, b):\n            return pow(a, b)\n\n        def func2(a, b, c, d):\n            return pow(pow(c + a, b), d)\n\n        def func3(a : int, b : float):\n            # type: (int, float) -> float\n            return pow(a, b)\n\n        def func4():\n            # type: () -> float\n            return pow(2, -2)\n\n        def func5(x, y):\n            return pow(x.item(), y.item())\n\n        def func6(a : int, b : int):\n            # type: (int, int) -> float\n            return pow(a, b)\n\n        a = torch.rand(1)\n        b = torch.rand(1)\n        c = torch.rand(1)\n        d = torch.rand(1)\n        self.checkScript(func, (a, b))\n        self.checkScript(func2, (a, b, c, d))\n        self.checkScript(func3, (4, -0.5))\n        self.checkScript(func4, ())\n        self.checkScript(func6, (2, 4))\n\n        inputs = [torch.tensor(2), torch.tensor(-2), torch.tensor(.5), torch.tensor(.2)]\n        for x in inputs:\n            for y in inputs:\n                if x < 0:\n                    continue\n                else:\n                    self.checkScript(func5, (x, y))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_pow_scalar_backward_cuda(self):\n        # see that scalar exponent works with cuda base (#19253)\n        with enable_profiling_mode_for_profiling_tests():\n            for dtype in [torch.float, torch.double]:\n                @torch.jit.script\n                def func(a, b):\n                    # type: (Tensor, float) -> Tensor\n                    return (a * 2) ** b\n\n                a = torch.rand(1, requires_grad=True, device='cuda', dtype=dtype)\n                func(a, 1, profile_and_replay=True).backward()\n\n                @torch.jit.script\n                def func(a, b):\n                    # type: (float, Tensor) -> Tensor\n                    return a ** (b * 2 + 1)\n\n                a = torch.rand(1, requires_grad=True, device='cuda', dtype=dtype)\n                func(2, a, profile_and_replay=True).backward()\n\n    def _check_code(self, code_str, fn_name, inputs):\n        scope = {}\n        exec(code_str, globals(), scope)\n        cu = torch.jit.CompilationUnit(code_str)\n        self.assertEqual(cu.func(*inputs), scope[fn_name](*inputs))\n\n    @unittest.skipIf(not RUN_CUDA, 'no CUDA')\n    def test_scriptmodule_releases_tensors_cuda(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def fn(x, y):\n                return x.sigmoid() * y.tanh()\n\n            def test(backward=False):\n                x = torch.randn(3, 3, dtype=torch.double, device='cuda', requires_grad=True)\n                y = torch.randn(3, 3, dtype=torch.double, device='cuda', requires_grad=True)\n                out = fn(x, y, profile_and_replay=True)\n                if backward:\n                    out.sum().backward()\n\n            with self.assertLeaksNoCudaTensors():\n                test()\n                test()\n                test()\n\n            if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                with self.assertLeaksNoCudaTensors():\n                    test(backward=True)\n                    test(backward=True)\n                    test(backward=True)\n\n    def test_index(self):\n        def consec(size, start=0):\n            numel = torch.tensor(size).prod().item()\n            return torch.arange(numel).view(size)\n\n        def consec_list(size):\n            return list(range(size))\n\n        def random_string(size):\n            letters = string.ascii_lowercase\n            return \"\".join(random.choice(letters) for i in range(size))\n\n        def check_indexing(indexing, tensor):\n            template = dedent(\"\"\"\n            def func(x):\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [tensor])\n\n        def check_dynamic_indexing(indexing, tensor, value1, value2):\n            value1 = torch.tensor(value1)\n            value2 = torch.tensor(value2)\n\n            template = dedent(\"\"\"\n            def func(x, value1, value2):\n                i = int(value1)\n                j = int(value2)\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [tensor, value1, value2])\n\n        # Torchscript assumes type Tensor by default, so we need this explicit\n        # declaration.\n        def check_indexing_list_int(indexing, list):\n            template = dedent(\"\"\"\n            def func(x):\n                # type: (List[int]) -> Any\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [list])\n\n        def check_indexing_str(indexing, str):\n            template = dedent(\"\"\"\n            def func(x):\n                # type: (str) -> Any\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [str])\n\n        # basic slices\n        check_indexing('[0]', consec((3, 3)))\n        check_indexing('[1]', consec((3, 3), 10))\n        check_indexing('[2]', consec((3, 3), 19))\n        check_indexing('[2]', consec((3,)))\n        check_indexing('[-1]', consec((3, 3), 19))\n        check_indexing('[0:2]', consec((3, 3, 3)))\n        check_indexing('[1:-1]', consec((3, 3, 3)))\n        check_indexing('[-3:-1]', consec((6, 3)))\n        check_indexing('[1:]', consec((3, 3)))\n        check_indexing('[:1]', consec((3, 3)))\n        check_indexing('[:]', consec((3, 2)))\n\n        # multi-dim: indexes\n        check_indexing('[0, 1]', consec((3, 3)))\n        check_indexing('[0, 1]', consec((3, 3, 2)))\n        check_indexing('[1, 0, 2]', consec((3, 3, 3)))\n        check_indexing('[2, -1]', consec((3, 3)))\n\n        # multi-dim: mixed slicing and indexing\n        check_indexing('[0, 1:2]', consec((3, 3)))\n        check_indexing('[0, :1]', consec((3, 3, 2)))\n        check_indexing('[1, 2:]', consec((3, 3, 3)))\n        check_indexing('[-1, 1:, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[1:, -1, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, 2:, 1:2]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, 1:, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, :, 0, 2]', consec((3, 3, 3, 3)))\n\n        # zero-sized slices\n        check_indexing('[0:0]', consec((2, 2)))\n        check_indexing('[0:0, 1]', consec((3, 3)))\n\n        # trivial expression usage\n        check_indexing('[1+1]', consec((3, 3)))\n        check_indexing('[1:(0 + 2)]', consec((3, 3, 3)))\n\n        # None for new dimensions\n        check_indexing('[None, 0]', consec((3, 3)))\n        check_indexing('[1, None]', consec((3, 3), 10))\n        check_indexing('[None, None, 2]', consec((3, 3), 19))\n        check_indexing('[None, 2, None]', consec((3,)))\n        check_indexing('[0:2, None]', consec((3, 3, 3)))\n        check_indexing('[None, 1:-1]', consec((3, 3, 3)))\n        check_indexing('[None, -3:-1, None]', consec((6, 3)))\n        check_indexing('[-1, None, 2:, None, 1:2]', consec((3, 3, 3, 3)))\n        check_indexing('[None, -1, None, 2:, None, 1:2, None]', consec((3, 3, 3, 3)))\n\n        # dynamic expression usage\n        check_dynamic_indexing(\"[i + j]\", consec((3, 3)), 0, 1)\n        check_dynamic_indexing(\"[i:j, i]\", consec((3, 3, 2)), 0, 2)\n\n        # positive striding\n        check_indexing_list_int('[0]', consec_list(6))\n        check_indexing_list_int('[1]', consec_list(7))\n        check_indexing_list_int('[2]', consec_list(8))\n        check_indexing_list_int('[2]', consec_list(9))\n        check_indexing_list_int('[-1]', consec_list(10))\n        check_indexing_list_int('[0:2]', consec_list(11))\n        check_indexing_list_int('[1:-1]', consec_list(12))\n        check_indexing_list_int('[-3:-1]', consec_list(13))\n        check_indexing_list_int('[1:]', consec_list(15))\n        check_indexing_list_int('[:1]', consec_list(16))\n        check_indexing_list_int('[:]', consec_list(17))\n        check_indexing_list_int('[::]', consec_list(0))\n        check_indexing_list_int('[1000::]', consec_list(0))\n        check_indexing_list_int('[:1000:]', consec_list(0))\n\n        # negative striding\n        check_indexing_list_int('[::-1]', consec_list(7))\n        check_indexing_list_int('[:3:-1]', consec_list(7))\n        check_indexing_list_int('[3::-1]', consec_list(7))\n        check_indexing_list_int('[1000::-1]', consec_list(7))\n        check_indexing_list_int('[3:0:-1]', consec_list(7))\n        check_indexing_list_int('[3:-1000:-1]', consec_list(7))\n        check_indexing_list_int('[0:0:-1]', consec_list(7))\n        check_indexing_list_int('[0:-1000:-1]', consec_list(7))\n\n        # only step is specified\n        check_indexing_list_int('[::-1]', consec_list(0))\n        check_indexing_list_int('[::-1]', consec_list(7))\n        check_indexing_list_int('[::-2]', consec_list(7))\n        check_indexing_list_int('[::2]', consec_list(7))\n        check_indexing_list_int('[::42]', consec_list(7))\n        check_indexing_list_int('[::-42]', consec_list(7))\n        check_indexing_list_int('[::42]', consec_list(0))\n        check_indexing_list_int('[::-42]', consec_list(0))\n        check_indexing_list_int('[::9223372036854775807]', consec_list(42))\n        check_indexing_list_int('[::-9223372036854775807]', consec_list(42))\n        with self.assertRaisesRegex(RuntimeError, \"out of bounds\"):\n            check_indexing_list_int('[::-9223372036854775808]', consec_list(42))\n        with self.assertRaisesRegex(RuntimeError, \"should have non-zero step\"):\n            check_indexing_list_int('[::0]', consec_list(42))\n\n        # striding strings\n        check_indexing_str('[0]', random_string(6))\n        check_indexing_str('[1]', random_string(7))\n        check_indexing_str('[2]', random_string(8))\n        check_indexing_str('[2]', random_string(9))\n        check_indexing_str('[-1]', random_string(10))\n        check_indexing_str('[0:2]', random_string(11))\n        check_indexing_str('[1:-1]', random_string(12))\n        check_indexing_str('[-3:-1]', random_string(13))\n        check_indexing_str('[1:]', random_string(15))\n        check_indexing_str('[:1]', random_string(16))\n        check_indexing_str('[:]', random_string(17))\n        check_indexing_str('[::]', random_string(0))\n        check_indexing_str('[1000::]', random_string(0))\n        check_indexing_str('[:1000:]', random_string(0))\n\n        check_indexing_str('[::-1]', random_string(7))\n        check_indexing_str('[:3:-1]', random_string(7))\n        check_indexing_str('[3::-1]', random_string(7))\n        check_indexing_str('[1000::-1]', random_string(7))\n        check_indexing_str('[3:0:-1]', random_string(7))\n        check_indexing_str('[3:-1000:-1]', random_string(7))\n        check_indexing_str('[0:0:-1]', random_string(7))\n        check_indexing_str('[0:-1000:-1]', random_string(7))\n\n        check_indexing_str('[::-1]', random_string(0))\n        check_indexing_str('[::-1]', random_string(7))\n        check_indexing_str('[::-2]', random_string(7))\n        check_indexing_str('[::2]', random_string(7))\n        check_indexing_str('[::42]', random_string(7))\n        check_indexing_str('[::-42]', random_string(7))\n        check_indexing_str('[::42]', random_string(0))\n        check_indexing_str('[::-42]', random_string(0))\n        check_indexing_str('[::9223372036854775807]', random_string(42))\n        check_indexing_str('[::-9223372036854775807]', random_string(42))\n        with self.assertRaisesRegex(RuntimeError, \"out of bounds\"):\n            check_indexing_str('[::-9223372036854775808]', random_string(42))\n        with self.assertRaisesRegex(RuntimeError, \"should have non-zero step\"):\n            check_indexing_str('[::0]', random_string(42))\n\n    def test_module_copy_with_attributes(self):\n        class Vocabulary(torch.jit.ScriptModule):\n            def __init__(self, vocab_list):\n                super(Vocabulary, self).__init__()\n                self._vocab = torch.jit.Attribute(vocab_list, List[str])\n                self.some_idx = torch.jit.Attribute(2, int)\n                self.idx = torch.jit.Attribute(\n                    {word: i for i, word in enumerate(vocab_list)}, Dict[str, int]\n                )\n\n            @torch.jit.script_method\n            def lookup_indices_1d(self, values):\n                # type: (List[str]) -> List[int]\n                result = torch.jit.annotate(List[int], [])\n                # Direct list iteration not supported\n                for i in range(len(values)):\n                    value = values[i]\n                    result.append(self.idx.get(value, self.some_idx))\n                return result\n\n            @torch.jit.script_method\n            def forward(self, values):\n                # type: (List[List[str]]) -> List[List[int]]\n                result = torch.jit.annotate(List[List[int]], [])\n                # Direct list iteration not supported\n                for i in range(len(values)):\n                    result.append(self.lookup_indices_1d(values[i]))\n                return result\n\n        v = Vocabulary(list('uabcdefg'))\n        v.__copy__()\n\n    def test_tuple_to_opt_list(self):\n        @torch.jit.script\n        def foo(x):\n            # type: (Optional[List[int]]) -> int\n            return 1\n\n        @torch.jit.script\n        def tuple_call():\n            return foo((1, 2))\n\n    def test_keyword(self):\n        @torch.jit.script\n        def func(x):\n            return torch.sum(x, dim=0)\n\n        x = torch.rand(10, dtype=torch.float, requires_grad=True)\n        y = func(x)\n        y2 = torch.sum(x, dim=0)\n        self.assertEqual(y, y2)\n\n    def test_constant_pooling_none(self):\n        @torch.jit.script\n        def typed_nones(a=None, b=None, c=None):\n            # type: (Optional[int], Optional[bool], Optional[Tensor]) -> Tuple[Optional[int], Optional[bool], Optional[Tensor]]\n            return a, b, c\n\n        @torch.jit.script\n        def test(a):\n            # type: (bool) -> None\n            if a:\n                print(typed_nones())\n            else:\n                print(typed_nones())\n\n        graph_str = str(test.graph)\n        self.assertTrue(graph_str.count(\"NoneType = prim::Constant\") == 1)\n\n    def test_constant_pooling_same_identity(self):\n        def foo():\n            a = torch.tensor([4])\n            b = (a,)\n            index = len(a) - 1\n            c = b[index]\n            d = b[index]\n            return c, d\n\n        foo_script = torch.jit.script(foo)\n        self.run_pass('constant_propagation', foo_script.graph)\n        self.run_pass('constant_pooling', foo_script.graph)\n        # even though the c & d escape scope, we are still able\n        # pool them into one constant because they are the same object\n        FileCheck().check_count(\"prim::Constant\", 1, exactly=True).run(foo_script.graph)\n        self.assertEqual(foo(), foo_script())\n\n    def test_constant_pooling_introduce_aliasing(self):\n        @torch.jit.script\n        def foo():\n            a = torch.tensor(1)\n            b = torch.tensor(1)\n            return a, b\n\n        self.run_pass('constant_propagation', foo.graph)\n        self.run_pass('constant_pooling', foo.graph)\n        # dont pool constants bc it would introduce observable alias relationship changing\n        a, b = foo()\n        self.assertIsNot(a, b)\n\n    def test_literal(self):\n        def func1(a, b):\n            c = a, b\n            d, e = c\n            return d + e\n\n        def func2(a, b):\n            c = a, (a, b)\n            d, e = c\n            f, g = e\n            return d + f + g\n\n        def func3(a, b):\n            # type: (float, float) -> float\n            c = 0., (0., 0.)\n            x = True\n            while x:\n                x = False\n                c = a, (a, b)\n            d, e = c\n            f, g = e\n            return d + f + g\n\n        a = torch.rand(1, requires_grad=True)\n        b = torch.rand(1, requires_grad=True)\n        self.checkScript(func1, (a, b), optimize=True)\n        self.checkScript(func2, (a, b), optimize=True)\n        self.checkScript(func3, (a.item(), b.item()), optimize=True)\n\n    def test_expand(self):\n        @torch.jit.script\n        def func(x, y):\n            return x + y\n\n        x = torch.rand(2, 3, dtype=torch.float, requires_grad=True)\n        y = torch.rand(3, dtype=torch.float, requires_grad=True)\n        out = func(x, y)\n        self.assertEqual(func(x, y), x + y)\n\n        grad = torch.randn(2, 3, dtype=torch.float)\n        out.backward(grad)\n        self.assertEqual(x.grad, grad)\n        self.assertEqual(y.grad, grad.sum(dim=0))\n\n    def test_sum(self):\n        @torch.jit.script\n        def func(x):\n            return x.sum(dim=[4])\n\n        @torch.jit.script\n        def func2(x):\n            return x.sum(dim=4)\n\n        # test that shape analysis is written correctly for sum with OptionalIntArrayRef[1] dim argument\n        self.run_pass('constant_propagation', func.graph)\n        self.run_pass('constant_propagation', func2.graph)\n        g = _propagate_shapes(func.graph, (torch.zeros(1, 1, 1, 1, 4),), False)\n        g2 = _propagate_shapes(func2.graph, (torch.zeros(1, 1, 1, 1, 4),), False)\n\n    def test_cat(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.cat((x, x), dim=0)\n\n            x = torch.rand(10, dtype=torch.float, requires_grad=True)\n            self.assertEqual(func(x, profile_and_replay=True), torch.cat((x, x), dim=0))\n\n            @torch.jit.script\n            def func2(x, y):\n                return torch.cat((x, x), y)\n\n            with disable_autodiff_subgraph_inlining():\n                for sizes in ((2, 2), (0, 2)):\n                    x = torch.rand(sizes).requires_grad_()\n                    y = torch.tensor(1)\n\n                    output = func2(x, y, profile_and_replay=True)\n                    output_ref = torch.cat((x, x), y)\n                    self.assertEqual(output, output_ref)\n\n                    if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                        self.assertAutodiffNode(func2.graph_for(x, y), True, ['aten::cat'], [])\n\n                        grad = torch.autograd.grad(output.sum(), x)\n                        grad_ref = torch.autograd.grad(output_ref.sum(), x)\n                        self.assertEqual(grad, grad_ref)\n\n    def test_cat_lifts(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.cat([x, x], dim=1)\n\n        @torch.jit.script\n        def foo2(x):\n            return torch.cat([], dim=1)\n\n        @torch.jit.script\n        def foo3(x):\n            return torch.cat([x], dim=1)\n\n        for g in [foo.graph, foo2.graph, foo3.graph]:\n            FileCheck().check(\"int =\").check(\"ListConstruct\").check(\"aten::cat\").run(str(g))\n\n    def test_stack(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.stack((x, x), dim=1)\n            x = torch.rand(10, 10)\n            self.assertEqual(func(x, profile_and_replay=True), torch.stack((x, x), dim=1))\n\n            @torch.jit.script\n            def func2(x, y):\n                return torch.stack((x, y), dim=0)\n\n            with disable_autodiff_subgraph_inlining():\n                x = torch.randn([2, 2]).requires_grad_()\n                y = torch.randn([2, 2]).requires_grad_()\n\n                output = func2(x, y, profile_and_replay=True)\n                output_ref = torch.stack((x, y), 0)\n                self.assertEqual(output, output_ref)\n                if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                    self.assertAutodiffNode(func2.graph_for(x, y), True, ['aten::stack'], [])\n\n                    grads = torch.autograd.grad(output.sum(), (x, y))\n                    grads_ref = torch.autograd.grad(output_ref.sum(), (x, y))\n                    self.assertEqual(grads, grads_ref)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY,\n                     \"Profiling executor will be using different heuristics for constructing differentiable graphs\")\n    def test_unbind(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x, y):\n                # type: (Tensor, int) -> List[Tensor]\n                return torch.unbind(x, y)\n\n            with disable_autodiff_subgraph_inlining():\n                x = torch.rand([2, 2]).requires_grad_()\n                y = 0\n                outputs = func(x, y, profile_and_replay=True)\n                outputs_ref = torch.unbind(x, dim=y)\n                self.assertEqual(outputs, outputs_ref)\n                self.assertAutodiffNode(func.graph_for(x, y), True, [], [])\n\n                grad = torch.autograd.grad(_sum_of_list(outputs), x)\n                grad_ref = torch.autograd.grad(_sum_of_list(outputs_ref), x)\n                self.assertEqual(grad, grad_ref)\n\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.PROFILING,\n                     \"Profiling executor fails to recognize that tensors in a list require gradients\")\n    def test_meshgrid(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(a):\n                # type: (List[Tensor]) -> List[Tensor]\n                return torch.meshgrid(a)\n            with disable_autodiff_subgraph_inlining():\n                a = torch.tensor([1.0, 2, 3]).requires_grad_()\n                b = torch.tensor([1.0, 2, 3, 4]).requires_grad_()\n                inputs = [a, b]\n\n                outputs_ref = torch.meshgrid(inputs)\n                outputs = func(inputs, profile_and_replay=True)\n                self.assertEqual(outputs, outputs_ref)\n\n                if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                    self.assertAutodiffNode(func.graph_for(inputs), True, [], [])\n\n                    grads = torch.autograd.grad(_sum_of_list(outputs), inputs)\n                    grads_ref = torch.autograd.grad(_sum_of_list(outputs_ref), inputs)\n                    self.assertEqual(grads, grads_ref)\n\n    def test_tensor_len(self):\n        def func(x):\n            return len(x)\n\n        self.checkScript(func, [torch.ones(4, 5, 6)])\n\n    def test_func_call(self):\n        def add(a, b):\n            return a + b\n\n        def mul(a, x):\n            return a * x\n\n        def func(alpha, beta, x, y):\n            return add(mul(alpha, x), mul(beta, y))\n\n        alpha = torch.rand(1, dtype=torch.float, requires_grad=True)\n        beta = torch.rand(1, dtype=torch.float, requires_grad=True)\n        x = torch.rand(3, dtype=torch.float, requires_grad=True)\n        y = torch.rand(3, dtype=torch.float, requires_grad=True)\n\n        # NOTE: cannot optimize yet because broadcasts are not inserted before the fuser runs\n        self.checkScript(func, [alpha, beta, x, y], optimize=False)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_profiling_graph_executor(self):\n        @torch.jit.script\n        def def_in_one_branch(x, z):\n            # type: (Tensor, bool) -> float\n            y = x\n            if z is False:\n                y = x + 1\n\n            return y.sum()\n\n        a = torch.rand(2, 3)\n\n        with enable_profiling_mode_for_profiling_tests():\n            # check prim::profile are inserted\n            profiled_graph_str = str(def_in_one_branch.graph_for(a, True))\n            FileCheck().check_count(\"prim::profile\", 4).run(profiled_graph_str)\n            # this call is optimized for\n            # the given shape of (2, 3)\n            def_in_one_branch(a, False)\n            # change shape to (3)\n            # so we go down a bailout path\n            a = torch.ones(3)\n            # check prim::BailOuts are inserted\n            bailout_graph_str = str(def_in_one_branch.graph_for(a, True))\n            FileCheck().check_count(\"prim::BailOut\", 3).run(bailout_graph_str)\n            # this triggers all 3 bailouts\n            self.assertEqual(def_in_one_branch(a, False), 6.0)\n            # this triggers 2 bailouts\n            self.assertEqual(def_in_one_branch(a, True), 3.0)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_maxpool_guard_elimination(self):\n        @torch.jit.script\n        def my_maxpool(x):\n            return F.max_pool1d(x, kernel_size=[1]) + torch.ones([32, 32, 32])\n\n        a = torch.rand(32, 32, 32)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_maxpool(a)\n            bailout_graph_str = str(my_maxpool.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 1).run(bailout_graph_str)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_slice_guard_elimination(self):\n        @torch.jit.script\n        def my_slice(x):\n            return x[0:16:2] + x[0:16:2]\n\n        a = torch.rand(32, 4)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_slice(a)\n            bailout_graph_str = str(my_slice.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 1).run(bailout_graph_str)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_unsqueeze_guard_elimination(self):\n        @torch.jit.script\n        def my_unsqueeze(x):\n            return torch.unsqueeze(x, 0) + torch.unsqueeze(x, 0)\n\n        a = torch.rand(32, 4)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_unsqueeze(a)\n            bailout_graph_str = str(my_unsqueeze.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 2).run(bailout_graph_str)\n\n    def test_resize_input_ops(self):\n        # resize_ and resize_as resize the input tensor. because our shape analysis\n        # is flow invariant, we set any Tensor that can alias a resized Tensor\n        # to the base Tensor Type, without size information.\n\n        # testing that value which is an input of a graph gets handled\n        def out_op_graph_input():\n            @torch.jit.script\n            def test(x, y, z):\n                torch.mul(x, y, out=z)\n                return z\n\n            graph = _propagate_shapes(test.graph,\n                                      (torch.zeros(2, 1), torch.zeros(1, 2), torch.zeros(1, 1, 1)), False)\n            self.assertTrue(next(graph.outputs()).type() == TensorType.get())\n        out_op_graph_input()\n\n        def test_resize():\n            @torch.jit.script\n            def test(x):\n                after_resize_alias = torch.zeros([2])\n                for _i in range(5):\n                    b = x + 1\n                    f = [1]\n                    before_resize_alias = b.sub_(1)\n                    # for i in range(10):\n                    f.append(1)\n                    b.resize_(f)\n                    after_resize_alias = b.add_(1)\n                return after_resize_alias\n\n            self.run_pass('constant_propagation', test.graph)\n            g = _propagate_shapes(test.graph, (torch.zeros(1, 1),), False)\n            resize_node = g.findNode(\"aten::resize_\")\n            # first input and output of b.resize_ is b\n            self.assertTrue(next(resize_node.inputs()).type() == TensorType.get())\n            self.assertTrue(next(resize_node.outputs()).type() == TensorType.get())\n\n            # correctly propagates to b alias set\n            before_resize = g.findNode(\"aten::sub_\")\n            self.assertTrue(next(before_resize.outputs()).type() == TensorType.get())\n\n            after_resize = g.findNode(\"aten::add_\")\n            self.assertTrue(next(after_resize.outputs()).type() == TensorType.get())\n\n        test_resize()\n\n        def test_resize_as():\n            @torch.jit.script\n            def test(x):\n                b = torch.zeros([2, 2])\n                b.resize_as_(x)\n                return b\n\n            g = test.graph\n            self.run_pass('constant_propagation', g)\n            g = _propagate_shapes(test.graph, (torch.zeros(1, 1),), False)\n\n            # x doesn't alias a resized op so it shouldn't be set to base Tensor type\n            self.assertTrue(next(g.inputs()).type() != TensorType.get())\n            # return is resized\n            self.assertTrue(next(g.outputs()).type() == TensorType.get())\n\n        test_resize_as()\n\n    def test_uninitialized(self):\n        graph_str = \"\"\"graph():\n          %1 : int = prim::Uninitialized()\n          %2 : int = prim::Constant[value=1]()\n          %3 : int = aten::add(%1, %2)\n          return (%3)\n        \"\"\"\n        g = parse_ir(graph_str)\n        m = self.createFunctionFromGraph(g)\n        self.getExportImportCopy(m)\n        with self.assertRaisesRegex(RuntimeError, \"isInt\"):\n            m()\n\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.SIMPLE, \"Simple Executor doesn't use requires_grad information\")\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.PROFILING, \"Peeling is now disabled\")\n    def test_requires_grad_loop(self):\n        @torch.jit.script\n        def test(x, y, z):\n            # type: (Tensor, Tensor, int) -> Tensor\n            for _ in range(z):\n                x = y\n            return x\n\n        # x requires grad, y does not\n        # testing that requires grad analysis correctly exits, with its input\n        # to the loop (x) requiring grad and its output to the loop not requiring grad\n        # and the output of the node conservatively setting grad to true\n\n        inps = (torch.tensor(1.0, requires_grad=True), torch.tensor(1), 10)\n        test(*inps, profile_and_replay=True)\n\n        graph = test.graph_for(*inps)\n        loop = graph.findNode(\"prim::Loop\")\n        loop_body = next(loop.blocks())\n        loop_inputs = list(loop_body.inputs())\n        loop_outputs = list(loop_body.outputs())\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            # TODO: simplify this test as it's very sensitive\n            # the optimized graph will have 3 loops\n            # the original loop is peeled\n            # peeled loop also gets unrolled\n            index_of_x_in_peeled_unrolled_loop = -2\n            self.assertTrue(loop_inputs[index_of_x_in_peeled_unrolled_loop].requires_grad())\n            bailouts_in_outer_block = graph.findAllNodes(\"prim::BailOut\", False)\n            last_bailout_index_on_loops_output = -1\n            self.assertFalse(bailouts_in_outer_block[last_bailout_index_on_loops_output].output().requires_grad())\n        else:\n            self.assertTrue(loop_inputs[1].requires_grad())\n            self.assertTrue(loop.output().requires_grad())\n            self.assertFalse(loop_outputs[1].requires_grad())\n\n    def test_view_shape_prop(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_view_shape_prop(a):\n            return a.view(size=[-1])\n        ''')\n        inputs = [torch.zeros(10, 10)]\n        outputs = torch.zeros(100)\n\n        real_outs = cu.test_view_shape_prop(*inputs)\n        self.assertEqual(real_outs, outputs)\n\n    def test_view_listconstruct_shape_prop(self):\n        def fn(x):\n            B = x.size(0)\n            C = x.size(1)\n            T = x.size(2)\n            return x.view(T, B, C)\n\n        x = torch.randn(3, 1, 5, requires_grad=True)\n        fn = torch.jit.script(fn)\n        graph = _propagate_shapes(fn.graph, (x,), False)\n        self.assertTrue(next(graph.outputs()).type().scalarType() == 'Double')\n\n    def test_shape_prop_promotion(self):\n        @torch.jit.script\n        def fn(x, y):\n            return x + y\n\n        x, y = torch.rand(3, 4, dtype=torch.float), torch.rand(3, 4, dtype=torch.double)\n        graph = _propagate_shapes(fn.graph, (x, y), False)\n        FileCheck().check('Double(*, *, device=cpu) = aten::add').run(graph)\n\n    def test_shape_prop_promote_scalar_arg(self):\n        @torch.jit.script\n        def fn(x):\n            return math.pi + x\n\n        x = torch.zeros(3, 4, dtype=torch.long)\n        graph = _propagate_shapes(fn.graph, (x,), False)\n        default = torch.get_default_dtype()\n        if(default == torch.float):\n            FileCheck().check('Float(*, *, requires_grad=0, device=cpu) = aten::add').run(graph)\n        else:\n            FileCheck().check('Double(*, *, requires_grad=0, device=cpu) = aten::add').run(graph)\n\n    def test_integral_shape_inference(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_integral_shape_inference(a):\n            return a * a\n        ''')\n        inputs = [torch.ones(10, 10, dtype=torch.long)]\n        outputs = torch.ones(10, 10, dtype=torch.long)\n\n        self.assertEqual(cu.test_integral_shape_inference(*inputs), outputs)\n\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_batchnorm_fuser_cpu(self):\n        code = '''\n            graph(%3 : Tensor,\n                  %7 : Tensor,\n                  %12 : Float(*, *),\n                  %13 : Tensor,\n                  %25 : Tensor):\n                %23 : int = prim::Constant[value=1]()\n                %22 : float = prim::Constant[value=1e-05]()\n                %26 : Tensor = aten::sqrt(%25)\n                %24 : Tensor = aten::add(%26, %22, %23)\n                %20 : Tensor = aten::reciprocal(%24)\n                %norm_invstd : Tensor = aten::mul(%20, %23)\n                %15 : Tensor = aten::sub(%12, %13, %23)\n                %11 : Tensor = aten::mul(%15, %norm_invstd)\n                %8 : Tensor = aten::mul(%11, %7)\n                %5 : Tensor = aten::add(%8, %3, %23)\n                %1 : Float(*, *) = aten::relu(%5)\n                return (%1)\n        '''\n\n        graph = parse_ir(code)\n        inputs = 5 * [torch.rand(26, 2048, dtype=torch.float)]\n        code = torch._C._jit_fuser_get_fused_kernel_code(graph, inputs)\n        FileCheck().check('sqrtf').run(code)\n\n    @slowTest\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_fuser_double_float_codegen(self):\n        fns = ['log', 'log10', 'log1p', 'log2', 'lgamma', 'exp', 'expm1', 'erf',\n               'erfc', 'cos', 'acos', 'cosh', 'sin', 'asin', 'sinh', 'tan',\n               'atan', 'tanh', 'sqrt', 'ceil', 'floor', 'round', 'trunc',\n               'frac']\n\n        def lookup_c_equivalent_fn(aten_fn):\n            return aten_fn\n\n        def test_dispatch(op, expects, dtype, binary=False):\n            if dtype == torch.double:\n                dtype_str = 'Double'\n            elif dtype == torch.float:\n                dtype_str = 'Float'\n            else:\n                raise RuntimeError('Unknown dtype')\n\n            if binary:\n                code = '''\n                    graph(%3 : Tensor, %4 : Tensor):\n                        %2 : {dtype}(*, *) = aten::{op}(%3, %4)\n                        %1 : {dtype}(*, *) = aten::relu(%2)\n                        return (%1)\n                '''.format(op=op, dtype=dtype_str)\n            else:\n                code = '''\n                    graph(%3 : Tensor):\n                        %2 : {dtype}(*, *) = aten::{op}(%3)\n                        %1 : {dtype}(*, *) = aten::relu(%2)\n                        return (%1)\n                '''.format(op=op, dtype=dtype_str)\n\n            graph = parse_ir(code)\n            inputs = (2 if binary else 1) * [torch.rand(26, 2048, dtype=dtype)]\n            code = torch._C._jit_fuser_get_fused_kernel_code(graph, inputs)\n            FileCheck().check(expects).run(code)\n\n        for fn in fns:\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + '(', torch.double)\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + 'f(', torch.float)\n\n        # 'min', 'max' were previously tested but are now replaced with ternary expressions\n        # instead of fmin() and fmax()\n        binary_fns = ['pow']\n        for fn in binary_fns:\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + '(', torch.double, binary=True)\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + 'f(', torch.float, binary=True)\n\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_fuser_double_literal_precision(self):\n        code = '''\n        graph(%2 : Float(*, *)):\n            %4 : int = prim::Constant[value=1]()\n            %3 : float = prim::Constant[value=1.282549830161864]()\n            %5 : Float(*, *) = aten::add(%2, %3, %4)\n            %1 : Float(*, *) = aten::relu(%5)\n            return (%1)\n        '''\n\n        graph = parse_ir(code)\n        code = torch._C._jit_fuser_get_fused_kernel_code(graph, [torch.rand(3, 4)])\n        FileCheck().check('1.282549830161864').run(code)\n\n    def test_fuser_multiple_blocks(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_fuser_multiple_blocks(this, that, theother, meme):\n            i = 0\n            while i < 20:\n                this = torch.cat([this, meme], dim=0)\n                that = torch.cat([that, meme], dim=0)\n                theother = torch.cat([theother, meme], dim=0)\n                i = i + 1\n            return this, that, theother\n        ''')\n\n        inputs = [torch.ones(0, 10, 10)] * 3\n        inputs += [torch.ones(1, 10, 10)]\n        outputs = [torch.ones(20, 10, 10)] * 3\n\n        self.assertEqual(cu.test_fuser_multiple_blocks(*inputs), outputs)\n\n    @unittest.skip(\"RuntimeError: VariableType::ID() not implemented\")\n    def test_cast(self):\n        script = '''\n        def to_int(x):\n            return int(x)\n        '''\n        x = Variable(torch.FloatTensor([1.1, 2.3]), requires_grad=True)\n        out = Variable(torch.IntTensor([1, 2]), requires_grad=True)\n        self.checkScript(script, [x], optimize=True, outputs=[out], func='to_int')\n\n    def test_str_cast(self):\n        @torch.jit.script\n        def to_str(x):\n            # type: (int) -> str\n            return str((x, x))\n\n        self.assertEqual(\"(1, 1)\", to_str(1))\n\n    def test_int_cast(self):\n        @torch.jit.script\n        def to_int(x):\n            # type: (str) -> int\n            return int(x)\n\n        self.assertEqual(5, to_int('5'))\n        self.assertEqual(-5, to_int('-5'))\n        self.assertEqual(2147483647, to_int('2147483647'))\n        self.assertEqual(-2147483648, to_int('-2147483648'))\n\n        with self.assertRaisesRegex(RuntimeError, \"invalid literal for int()\"):\n            to_int('0x20')\n\n        with self.assertRaisesRegex(RuntimeError, \"invalid literal for int()\"):\n            to_int('0b0001')\n\n    def test_python_frontend(self):\n        def fn(x, y, z):\n            q = None\n            q = x + y - z.sigmoid()\n            print(q)\n            w = -z\n            if not x and not y and z:\n                m = x if not z else y\n            while x < y > z:\n                q = x\n            assert 1 == 1, \"hello\"\n            return x\n\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        self.assertExpected(str(ast))\n\n    def test_python_frontend_source_range(self):\n        def fn():\n            raise Exception(\"hello\")\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        FileCheck().check(\"SourceRange at:\") \\\n                   .check(\"def fn():\") \\\n                   .check(\"~~~~~~~~~\") \\\n                   .check('raise Exception(\"hello\")') \\\n                   .check('~~~~~~~~~~~~~~~~~ <--- HERE') \\\n                   .run(str(ast.range()))\n\n    def test_python_frontend_py3(self):\n        def fn():\n            raise Exception(\"hello\")\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        self.assertExpected(str(ast))\n\n    def _make_scalar_vars(self, arr, dtype):\n        return [torch.tensor(val, dtype=dtype) for val in arr]\n\n\n    def test_string_print(self):\n        def func(a):\n            print(a, \"a\" 'b' '''c''' \"\"\"d\"\"\", 2, 1.5)\n            return a\n\n        inputs = self._make_scalar_vars([1], torch.int64)\n        self.checkScript(func, inputs, capture_output=True)\n\n    def test_while(self):\n        def func(a, b, max):\n            while bool(a < max):\n                a = a + 1\n                b = b + 1\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([1, 1, 10], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_fibb(self):\n        def func(lim):\n            first = 1\n            second = 1\n            i = 1\n            somenum = 5\n            dontmutateme = 3\n            third = 0\n            while bool(i < lim):\n                third = first + second\n                first = second\n                second = third\n                j = 0\n                while j < 10:\n                    somenum = somenum * 2\n                    j = j + 1\n                i = i + j\n                i = i + dontmutateme\n\n            st = second + third\n            fs = first + second\n            return third, st, fs\n\n        inputs = self._make_scalar_vars([10], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_fibb_totally_better(self):\n        def fib(x):\n            # type: (int) -> int\n            prev = 1\n            v = 1\n            for i in range(0, x):\n                save = v\n                v = v + prev\n                prev = save\n            return v\n\n        self.checkScript(fib, (10,))\n\n    def test_if(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            d = 3\n            if bool(a > 10):\n                a = 3 + d\n            else:\n                b = 3 + d\n                d = 4\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([1, -1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_for_in_range(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            d = 3\n            for _ in range(20):\n                if bool(a > 10):\n                    a = 3 + d\n                else:\n                    b = 3 + d\n                    d = 4\n                c = a + b\n            return d\n        inputs = self._make_scalar_vars([1, -1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_noelse(self):\n        def func(a, b):\n            if bool(a > 10):\n                a = 3 + b\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([-1, 1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_is_none_dispatch(self):\n\n        @torch.jit.script\n        def test_lhs_none_rhs_none():\n            # LHS, RHS both alwaysNone, dispatch always_none_branch\n            # only emit one prim::Constant\n            if None is None:\n                return 1\n            elif None is not None:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_none_rhs_none.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_lhs_opt_rhs_none(lhs=None):\n            # type: (Optional[Tensor]) -> int\n            # LHS maybeNone: emit normal if stmt that contains 3 constants\n            if lhs is not None:\n                return 2\n            elif lhs is None:\n                return 1\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_opt_rhs_none.graph).count(': int = prim::Constant') == 3)\n\n        @torch.jit.script\n        def test_lhs_none_rhs_opt(rhs=None):\n            # type: (Optional[Tensor]) -> int\n            # RHS maybeNone, emit normal if stmt that contains 3 constants\n            if None is rhs:\n                return 1\n            elif None is not rhs:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_opt_rhs_none.graph).count(': int = prim::Constant') == 3)\n\n        @torch.jit.script\n        def test_lhs_never_rhs_none(lhs):\n            # LHS neverNone, RHS alwaysNone dispatch never_none_branch\n            # only emit one prim::Constant\n            if lhs is None:\n                return 1\n            elif lhs is not None:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_never_rhs_none.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_lhs_none_rhs_never(rhs):\n            # LHS alwaysNone, RHS neverNone dispatch never_none_branch\n            # only emit one prim::Constant\n            if None is rhs:\n                return 1\n            elif None is not rhs:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_none_rhs_never.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_bool_arith_and(lhs):\n            if lhs is None and lhs is not None:\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_and(torch.zeros(3)), 2)\n        self.assertTrue(str(test_bool_arith_and.graph).count('if') == 0)\n\n        @torch.jit.script\n        def test_bool_arith_or(lhs):\n            if lhs is None or lhs is not None:\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_or(torch.zeros(3)), 1)\n        self.assertTrue(str(test_bool_arith_or.graph).count('if') == 0)\n\n\n        @torch.jit.script\n        def test_bool_arith_not(lhs):\n            if not (lhs is None):\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_not(torch.zeros(3)), 1)\n        self.assertTrue(str(test_bool_arith_not.graph).count('if') == 0)\n\n    def test_conditional_casting(self):\n        def test_bool_cast_tensor(x):\n            if x:\n                return 1\n            else:\n                return 0\n\n        for make_one_dim in [True, False]:\n            for inp_val in [0.1, 0.0, -0.0, -0.1, -1, 0, 1]:\n                inp_val = [inp_val] if make_one_dim else inp_val\n                self.checkScript(test_bool_cast_tensor, (torch.tensor(inp_val),))\n\n        self.checkScriptRaisesRegex(test_bool_cast_tensor, (torch.tensor([1, 1]),), Exception,\n                                    \"Boolean value of Tensor with more than one value\")\n\n        def test_not_cast(x):\n            if not x:\n                return 1\n            else:\n                return 0\n\n        self.checkScript(test_not_cast, (torch.tensor(1),))\n        self.checkScript(test_not_cast, (torch.tensor(0),))\n\n        with self.assertRaisesRegex(RuntimeError, r\"Could not cast value of type Tuple\\[Tensor, Tensor\\]\"):  # noqa: W605\n            @torch.jit.script\n            def test_mult(x, y):\n                return not(x, y)\n\n        def test_cast_int(x):\n            # type: (int) -> int\n            if x:\n                return 1\n            else:\n                return 0\n        self.checkScript(test_cast_int, (1,))\n        self.checkScript(test_cast_int, (0,))\n        self.checkScript(test_cast_int, (-1,))\n\n        def test_cast_float(x):\n            # type: (float) -> int\n            if x:\n                return 1\n            else:\n                return 0\n        self.checkScript(test_cast_float, (1.,))\n        self.checkScript(test_cast_float, (0.,))\n        self.checkScript(test_cast_float, (-1.,))\n\n        with self.assertRaisesRegex(RuntimeError, r\"Could not cast value of type Tuple\\[int, int\\] to bool\"):  # noqa: W605\n\n            @torch.jit.script\n            def test_bad_conditional(x):\n                if (1, 2):  # noqa: F634\n                    return\n                else:\n                    return 0\n\n    def test_while_nonexistent_value(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value x\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a, b):\n                while bool(a < 10):\n                    a = a + x\n                    b = b + 1\n                return a + b\n            ''')\n\n    def test_while_nonexistent_cond_value(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value x\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a, b):\n                while a < x:\n                    a = a + 1\n                    b = b + 1\n                return a + b\n            ''')\n\n        @torch.jit.script\n        def test_ternary(x):\n            # type: (Optional[int]) -> int\n            x = x if x is not None else 2\n            return x\n\n        @torch.jit.script\n        def test_not_none(x):\n            # type: (Optional[int]) -> None\n            if x is not None:\n                print(x + 1)\n\n        @torch.jit.script\n        def test_and(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if x is not None and y is not None:\n                print(x + y)\n\n        @torch.jit.script\n        def test_not(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if not (x is not None and y is not None):\n                pass\n            else:\n                print(x + y)\n\n        @torch.jit.script\n        def test_bool_expression(x):\n            # type: (Optional[int]) -> None\n            if x is not None and x < 2:\n                print(x + 1)\n\n        @torch.jit.script\n        def test_nested_bool_expression(x, y):\n            # type: (Optional[int], Optional[int]) -> int\n            if x is not None and x < 2 and y is not None:\n                x = x + y\n            else:\n                x = 5\n            return x + 2\n\n        @torch.jit.script\n        def test_or(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if y is None or x is None:\n                pass\n            else:\n                print(x + y)\n\n        # backwards compatibility\n        @torch.jit.script\n        def test_manual_unwrap_opt(x):\n            # type: (Optional[int]) -> int\n            if x is None:\n                x = 1\n            else:\n                x = torch.jit._unwrap_optional(x)\n            return x  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def or_error(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                if x is None or y is None:\n                    print(x + y)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def and_error(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                if x is None and y is None:\n                    pass\n                else:\n                    print(x + y)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def named_var(x):\n                # type: (Optional[int]) -> None\n                x_none = x is not None\n                if x_none:\n                    print(x + 1)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def named_var_and(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                x_none = x is not None\n                if y is not None and x_none:\n                    print(x + y)  # noqa: T484\n\n    def test_assertion_optional_refinement(self):\n        @torch.jit.script\n        def test(x, y):\n            # type: (Optional[int], Optional[int]) -> int\n            assert x is not None and y is not None\n            return x + y\n\n        self.assertEqual(test(2, 2), 4)\n        with self.assertRaisesRegex(Exception, \"\"):\n            test(1, None)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the current version of Profiler doesn't profile/specialize Optionals\")\n    def test_optional_tensor(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Optional[Tensor], int) -> int\n            if x is None:\n                return y\n            else:\n                return 0\n\n        res = fn(None, 1)\n        self.assertEqual(res, 1)\n        g = torch.jit.last_executed_optimized_graph()\n        first_input = next(g.inputs())\n        # check if input is disconnected\n        self.assertEqual(first_input.type().kind(), 'OptionalType')\n        self.assertEqual(first_input.uses(), [])\n        t = torch.ones(1)\n        res = fn(t, 1)\n        self.assertEqual(res, 0)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.inputs()).type().kind(), 'TensorType')\n\n        @torch.jit.script\n        def fn(x, y, b):\n            # type: (Optional[Tensor], Tensor, bool) -> Tensor\n            if b:\n                res = y\n            else:\n                res = torch.jit._unwrap_optional(x)\n            return res\n\n        t2 = torch.zeros(1)\n        res = fn(t, t2, True)\n        self.assertEqual(res, t2)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            res = fn(None, t2, False)\n        res = fn(None, t2, True)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertIn(next(g.outputs()).type().str(), (\"Tensor\", \"Tensor(requires_grad=1)\"))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the current version of Profiler doesn't profile/specialize Optionals\")\n    def test_optional_list(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Optional[List[int]], int) -> int\n            if x is None:\n                return y\n            else:\n                res = 0\n                for d in x:\n                    res += d\n                return res\n\n        res = fn(None, 1)\n        self.assertEqual(res, 1)\n        g = torch.jit.last_executed_optimized_graph()\n        first_input = next(g.inputs())\n        # check if input is disconnected\n        self.assertEqual(first_input.type().kind(), 'OptionalType')\n        self.assertEqual(first_input.uses(), [])\n        l = [2, 3]\n        res = fn(l, 1)\n        self.assertEqual(res, 5)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.inputs()).type().kind(), 'ListType')\n\n        @torch.jit.script\n        def fn(x, y, b):\n            # type: (Optional[List[int]], List[int], bool) -> List[int]\n            if b:\n                l = torch.jit._unwrap_optional(x)\n            else:\n                l = y\n            return l\n\n        l2 = [0, 1]\n        res = fn(l, l2, True)\n        self.assertEqual(res, l)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            res = fn(None, l2, True)\n        res = fn(None, l2, False)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.outputs()).type().str(), \"int[]\")\n\n    def test_alias_covariant_type_containers(self):\n        @torch.jit.script\n        def foo(x):\n            # type: (bool)\n            if x:\n                a = (None,)\n            else:\n                a = ([],)\n            return a\n\n        @torch.jit.script\n        def foo2(x, li):\n            # type: (bool, Tuple[Optional[List[Tensor]]])\n            if x:\n                li = (None,)\n            return li\n\n    def test_while_write_outer_then_read(self):\n        def func(a, b):\n            while bool(a < 10):\n                a = a + 1\n                b = a + 1\n            return a + b\n\n        inputs = self._make_scalar_vars([42, 1337], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_while_nest_if(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            c = 0\n            while a < 10:\n                a = a + 1\n                b = b + 1\n                if a > b:\n                    c = -a\n                else:\n                    c = -b\n            return c + 1\n\n        inputs = self._make_scalar_vars([-1234, 4321], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_divmod(self):\n        def func_int(a, b):\n            # type: (int, int) -> Tuple[int, int]\n            return divmod(a, b)\n\n        def func_float(a, b):\n            # type: (float, float) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def func_int_float(a, b):\n            # type: (int, float) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def func_float_int(a, b):\n            # type: (float, int) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def divmod_test_iterator(func, num, den):\n            for i in num:\n                for j in den:\n                    self.checkScript(func, (i, j), frames_up=2)\n\n        num_int = [1024, -1024]\n        den_int = [10, -10]\n        num_float = [5.3, -5.3]\n        den_float = [2.0, -2.0]\n        divmod_test_iterator(func_int, num_int, den_int)\n        divmod_test_iterator(func_float, num_float, den_float)\n        divmod_test_iterator(func_int_float, num_int, den_float)\n        divmod_test_iterator(func_float_int, num_float, den_int)\n\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: integer division or modulo by zero\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_int)))\n            cu.func_int(1024, 0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_float)))\n            cu.func_float(5.3, 0.0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_int_float)))\n            cu.func_int_float(1024, 0.0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_float_int)))\n            cu.func_float_int(5.3, 0)\n\n    def test_math_ops(self):\n        def checkMathWrap(func_name, num_args=1, is_float=True, **args):\n            if is_float:\n                checkMath(func_name, num_args, True, **args)\n                checkMath(func_name, num_args, False, **args)\n            else:\n                checkMath(func_name, num_args, is_float, **args)\n\n        inf = float(\"inf\")\n        NaN = float(\"nan\")\n        mx_int = 2**31 - 1\n        mn_int = -2**31\n        float_vals = ([inf, NaN, 0.0, 1.0, 2.2, -1.0, -0.0, -2.2, -inf, 1, 0, 2] +\n                      [10.0 ** i for i in range(5)] + [-(10.0 ** i) for i in range(5)])\n        int_vals = list(range(-5, 5, 1)) + [mx_int + 5, mx_int * 2, mn_int - 5, mn_int * 2]\n\n        def checkMath(func_name, num_args, is_float=True, ret_type=\"float\", debug=False, vals=None, args_type=None):\n            funcs_template = dedent('''\n            def func(a, b):\n                # type: {args_type} -> {ret_type}\n                return math.{func}({args})\n            ''')\n            if num_args == 1:\n                args = \"a\"\n            elif num_args == 2:\n                args = \"a, b\"\n            else:\n                raise RuntimeError(\"Test doesn't support more than 2 arguments\")\n            if args_type is None:\n                args_type = \"(float, float)\" if is_float else \"(int, int)\"\n            funcs_str = funcs_template.format(func=func_name, args=args, args_type=args_type, ret_type=ret_type)\n            scope = {}\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            f = scope['func']\n\n            if vals is None:\n                vals = float_vals if is_float else int_vals\n                vals = [(i, j) for i in vals for j in vals]\n\n            for a, b in vals:\n                res_python = None\n                res_script = None\n                try:\n                    res_python = f(a, b)\n                except Exception as e:\n                    res_python = e\n                try:\n                    res_script = f_script(a, b)\n                except Exception as e:\n                    res_script = e\n                if debug:\n                    print(\"in: \", a, b)\n                    print(\"out: \", res_python, res_script)\n                # We can't use assertEqual because of a couple of differences:\n                # 1. nan == nan should return true\n                # 2. When python functions throw an exception, we usually want to silently ignore them.\n                # (ie: We want to return `nan` for math.sqrt(-5))\n                if res_python != res_script:\n                    if isinstance(res_python, Exception):\n                        continue\n\n                    if type(res_python) == type(res_script):\n                        if isinstance(res_python, tuple) and (math.isnan(res_python[0]) == math.isnan(res_script[0])):\n                            continue\n                        if isinstance(res_python, float) and math.isnan(res_python) and math.isnan(res_script):\n                            continue\n                    msg = (\"Failed on {func_name} with inputs {a} {b}. Python: {res_python}, Script: {res_script}\"\n                           .format(func_name=func_name, a=a, b=b, res_python=res_python, res_script=res_script))\n                    self.assertEqual(res_python, res_script, msg=msg, atol=(1e-4) * max(abs(res_python), res_script), rtol=0)\n\n        unary_float_ops = [\"log\", \"log1p\", \"log10\", \"exp\", \"sqrt\", \"gamma\", \"lgamma\", \"erf\",\n                           \"erfc\", \"expm1\", \"fabs\", \"acos\", \"asin\", \"atan\", \"cos\", \"sin\", \"tan\",\n                           \"asinh\", \"atanh\", \"acosh\", \"sinh\", \"cosh\", \"tanh\", \"degrees\", \"radians\"]\n        binary_float_ops = [\"atan2\", \"fmod\", \"copysign\"]\n        for op in unary_float_ops:\n            checkMathWrap(op, 1)\n        for op in binary_float_ops:\n            checkMathWrap(op, 2)\n\n        checkMath(\"modf\", 1, ret_type=\"Tuple[float, float]\")\n        checkMath(\"frexp\", 1, ret_type=\"Tuple[float, int]\")\n        checkMath(\"isnan\", 1, ret_type=\"bool\")\n        checkMath(\"isinf\", 1, ret_type=\"bool\")\n        checkMath(\"ldexp\", 2, is_float=False, ret_type=\"float\", args_type=\"(float, int)\",\n                  vals=[(i, j) for i in float_vals for j in range(-10, 10)])\n        checkMath(\"pow\", 2, is_float=False, ret_type=\"float\")\n        checkMath(\"pow\", 2, is_float=True, ret_type=\"float\")\n        checkMathWrap(\"floor\", ret_type=\"int\")\n        checkMathWrap(\"ceil\", ret_type=\"int\")\n        checkMathWrap(\"gcd\", 2, is_float=False, ret_type=\"int\")\n        checkMath(\"isfinite\", 1, ret_type=\"bool\")\n        checkMathWrap(\"remainder\", 2)\n        checkMathWrap(\"factorial\", 1, is_float=False, ret_type=\"int\", vals=[(i, 0) for i in range(-2, 10)])\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_if_nest_while(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            c = 0\n            if a > b:\n                while a > b:\n                    b = b + 1\n                    c = -b\n            return c\n\n        inputs = self._make_scalar_vars([4321, 1234], torch.int64)\n        self.checkScript(func, inputs)\n\n    def test_script_optional_none(self):\n        def none_stmt(x):\n            output = None\n            output = x\n            return output\n\n        def none_args(x):\n            # type: (Optional[Tensor]) -> Optional[Tensor]\n            return None\n\n        self.checkScript(none_stmt, [torch.arange(0, 2)], optimize=True)\n        self.checkScript(none_args, [None], optimize=True)\n\n        # test undefined tensor None as default param\n        def test_script_optional_tensor_none(x=None):\n            # type: (Optional[Tensor]) -> Tensor\n            res = torch.zeros(1, dtype=torch.int8)\n            if x is None:\n                res = res + 1\n            else:\n                res = x\n            return res\n\n        fn = test_script_optional_tensor_none\n        scripted_fn = torch.jit.script(fn)\n        self.assertEqual(fn(), scripted_fn())\n        self.assertEqual(fn(torch.zeros(1)), scripted_fn(torch.zeros(1)))\n\n        # test typical None as default param\n        def test_script_optional_other_none(x=None):\n            # type: (Optional[float]) -> float\n            res = 2.0\n            if x is None:\n                res = res + 1.0\n            else:\n                res = x\n            return res\n\n        fn = test_script_optional_other_none\n        scripted_fn = torch.jit.script(fn)\n        self.assertEqual(fn(), scripted_fn())\n        self.assertEqual(fn(1.0), scripted_fn(1.0))\n\n    def test_script_clamp_none(self):\n        def test_script_clamp_max_none(x):\n            return torch.clamp(x, min=2, max=None)\n\n        def test_script_clamp_max(x):\n            return torch.clamp(x, max=2)\n\n        def test_script_clamp_min_none(x):\n            return torch.clamp(x, min=None, max=2)\n\n        def test_script_clamp_min(x):\n            return torch.clamp(x, min=2)\n\n        input = [torch.arange(0, 3)]\n        self.checkScript(test_script_clamp_max_none, input, optimize=True)\n        self.checkScript(test_script_clamp_max, input, optimize=True)\n        self.checkScript(test_script_clamp_min_none, input, optimize=True)\n        self.checkScript(test_script_clamp_min, input, optimize=True)\n\n    def test_script_bool_constant(self):\n        def test_script_bool_constant():\n            a = True\n            return a\n        self.checkScript(test_script_bool_constant, [])\n\n    def test_ternary(self):\n        def func(a, b):\n            c = 3\n            c = a + b if bool(a > 3) else b\n            return c\n\n        inputs_true = self._make_scalar_vars([5, 2], torch.int64)\n        inputs_false = self._make_scalar_vars([1, 0], torch.int64)\n        self.checkScript(func, inputs_true, optimize=True)\n        self.checkScript(func, inputs_false, optimize=True)\n\n    def test_ternary_module_type_hint(self):\n        class M1(torch.nn.Module):\n            def forward(self) -> Any:\n                return 'out' if self.training else {}\n\n        class M2(torch.nn.Module):\n            def forward(self) -> Any:\n                out: Any = 'out' if self.training else {}\n                return out\n\n        class M3(torch.nn.Module):\n            def forward(self) -> Optional[int]:\n                return None if self.training else 1\n\n        for module in [M1, M2, M3]:\n            self.checkModule(module().train(), ())\n            self.checkModule(module().eval(), ())\n\n    def test_ternary_static_if(self):\n        # Test for True branch when condition variable\n        # is annotated as Final\n        class M1(torch.nn.Module):\n            flag: torch.jit.Final[bool]\n\n            def __init__(self):\n                super().__init__()\n                self.flag = True\n\n            def forward(self) -> torch.Tensor:\n                return torch.ones(3) if self.flag else {}\n\n        # Test for True branch when condition variable\n        # is annotated as Final\n        class M2(torch.nn.Module):\n            flag: torch.jit.Final[bool]\n\n            def __init__(self):\n                super().__init__()\n                self.flag = False\n\n            def forward(self) -> torch.Tensor:\n                return {} if self.flag else torch.ones(3)\n\n        model1 = M1()\n        model2 = M2()\n        script_model_1 = torch.jit.script(model1)\n        script_model_2 = torch.jit.script(model2)\n        self.assertEqual(model1.forward(), script_model_1.forward())\n        self.assertEqual(model2.forward(), script_model_2.forward())\n\n    def test_ternary_right_associative(self):\n        def plus_123(x: int):\n            return x + 1 if x == 1 else x + 2 if x == 2 else x + 3\n        self.checkScript(plus_123, (1,))\n        self.checkScript(plus_123, (2,))\n        self.checkScript(plus_123, (3,))\n\n    def test_print(self):\n        def func(x, y):\n            q = (x + y).sigmoid()\n            print(q, 1, 2, [1, 2], [1.0, 2.0])\n            w = -q\n            return w * w\n\n        x = torch.arange(4., requires_grad=True)\n        y = torch.arange(0., 8, 2, requires_grad=True)\n        self.checkScript(func, [x, y], optimize=True, capture_output=True)\n\n    def test_format(self):\n        def func(x):\n            print(\"{}, I'm a {}\".format(\"Hello\", \"test\"))\n            print(\"format blank\".format())\n            print(\"stuff before {}\".format(\"hi\"))\n            print(\"{} stuff after\".format(\"hi\"))\n            return x + 1\n\n        x = torch.arange(4., requires_grad=True)\n        self.checkScript(func, [x], optimize=True, capture_output=True)\n\n    def test_logical_short_circuit(self):\n        @torch.jit.script\n        def testNoThrows(t):\n            c1 = 1\n            if (False and bool(t[1])) or (True or bool(t[1])):\n                c1 = 0\n            return c1\n\n        FileCheck().check_not(\"prim::If\").run(testNoThrows.graph)\n        self.assertEqual(0, testNoThrows(torch.randn(0)))\n        self.assertEqual(0, testNoThrows(torch.randn([2, 3])))\n\n        @torch.jit.script\n        def throwsOr(t):\n            c0 = False or bool(t[1])\n            print(c0)\n\n        @torch.jit.script\n        def throwsAnd(t):\n            c0 = True and bool(t[1])\n            print(c0)\n\n        t = torch.randn(0)\n        with self.assertRaisesRegex(RuntimeError, \"index 1 out of range for tensor of size\"):\n            throwsOr(t)\n        with self.assertRaisesRegex(RuntimeError, \"index 1 out of range for tensor of size\"):\n            throwsAnd(t)\n\n    def test_type_cast(self):\n        template = dedent('''\n        def func(v):\n            # type: ({from_type}) -> {to_type}\n            return {to_type}(v)\n        ''')\n\n        def check_cast(from_type, to_type, value, raises=False):\n            code = template.format(from_type=from_type, to_type=to_type)\n            self.checkScript(code, (value,))\n\n        check_cast('int', 'float', 1)\n        check_cast('int', 'bool', 1)\n        check_cast('int', 'bool', 0)\n\n        check_cast('float', 'int', 1.)\n        check_cast('float', 'bool', 1.)\n        check_cast('float', 'bool', 0.)\n\n        check_cast('bool', 'int', True)\n        check_cast('bool', 'float', True)\n\n    def test_multiple_assignment(self):\n        def outer_func(x):\n            return x * 2, x + 2\n\n        @torch.jit.script\n        def func(x):\n            y, z = outer_func(x)\n            return y + z\n\n        x = torch.arange(4)\n        self.assertEqual(func(x), x * 2 + x + 2)\n\n    def test_literals(self):\n        def func(a):\n            return a.view(size=[1, 2, 3])\n\n        a = torch.randn(6)\n        self.checkScript(func, [a], optimize=True)\n\n    def test_return(self):\n        def no_return(a):\n            a + 1\n\n        def void_return(a):\n            return\n\n        def one_return(a):\n            return a + 1.\n\n        def multiple_returns(a):\n            return a * 1., a * 2., a * 3.\n\n        a = torch.randn(1, dtype=torch.float)\n        self.checkScript(no_return, [a], optimize=True)\n        self.checkScript(void_return, [a], optimize=True)\n        self.checkScript(one_return, [a], optimize=True)\n        self.checkScript(multiple_returns, [a], optimize=True)\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all paths\"):\n            torch.jit.CompilationUnit('''\n            def no_return_bad_annotation(a):\n                # type: (Tensor) -> Tensor\n                a + 1\n            ''')\n\n    def test_error(self):\n        @torch.jit.script\n        def foo(a):\n            return a.t()\n        s = Variable(torch.rand(5, 5, 5))\n        # XXX: this should stay quiet in stay propagation and only fail in the interpreter\n        with self.assertRaisesRegex(RuntimeError, \"failed in the TorchScript interpreter\"):\n            foo(s)\n\n        @torch.jit.script\n        def bar(c, b):\n            return c + b\n\n        with self.assertRaisesRegex(RuntimeError, \"failed in the TorchScript interpreter\"):\n            bar(Variable(torch.rand(10), requires_grad=True), Variable(torch.rand(9), requires_grad=True))\n\n    def test_error_stacktrace(self):\n        @torch.jit.script\n        def baz(c, b):\n            return c + b\n\n        @torch.jit.script\n        def foo(c, b):\n            return baz(c, b)\n\n        @torch.jit.script\n        def bar(c, b):\n            return foo(c, b)\n\n        with self.assertRaises(RuntimeError) as cm:\n            bar(torch.rand(10), torch.rand(9))\n        FileCheck().check(\"The following operation failed in the TorchScript interpreter\") \\\n                   .check(\"Traceback\") \\\n                   .check(\"in foo\").check(\"in baz\").run(str(cm.exception))\n\n    def test_error_stacktrace_interface(self):\n        @torch.jit.script\n        def baz(c, b):\n            return c + b\n\n        @torch.jit.script\n        def foo(c, b):\n            return baz(c, b)\n\n        @torch.jit.script\n        def bar(c, b):\n            return foo(c, b)\n\n        @torch.jit.script\n        class Bar(object):\n            def one(self, x, y):\n                return bar(x, y)\n\n        @torch.jit.interface\n        class IFace(object):\n            def one(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                pass\n\n        make_global(IFace)\n\n        @torch.jit.script\n        def as_interface(x):\n            # type: (IFace) -> IFace\n            return x\n\n        f = as_interface(Bar())\n\n        with self.assertRaises(RuntimeError) as cm:\n            x = f.one(torch.rand(10), torch.rand(9))\n            bar(torch.rand(10), torch.rand(9))\n        FileCheck().check(\"The following operation failed in the TorchScript interpreter\") \\\n                   .check(\"Traceback\") \\\n                   .check(\"in foo\").check(\"in baz\").run(str(cm.exception))\n\n    def test_operator_precedence(self):\n        def double(x):\n            # type: (int) -> int\n            return 2 * x\n\n        def complicated_arithmetic_operation():\n            # TODO we need to test exponent operator '**' and bitwise not\n            # operator '~' once they are properly supported.\n            list = [0, 1, 2, 3]\n            result = list[1:3][0] + double(4) + (-3 + 8) * 6 // 2 % 4 << 2 + 1 >> 1 | 23 & 16 + 3 ^ 4\n            return result\n\n        self.checkScript(complicated_arithmetic_operation, ())\n\n    def test_in_operator_with_two_strings(self):\n        def fn() -> bool:\n            return \"a\" in \"abcd\"\n        self.checkScript(fn, ())\n\n    def test_bitwise_ops(self):\n\n        def int_test():\n            return 2 & 3, 2 ^ 3, 2 | 3, 2 << 3, 2 >> 3\n\n        self.checkScript(int_test, ())\n\n        def bool_test(x, y):\n            # type: (bool, bool) -> Tuple[bool, bool, bool]\n            return x & y, x ^ y, x | y\n\n        self.checkScript(bool_test, (True, False))\n        self.checkScript(bool_test, (True, True))\n\n        def tensor_test(x, y):\n            return x & y, x ^ y, x | y\n\n        def tensor_with_int_test(x, y):\n            # type: (Tensor, int) -> Tuple[Tensor, Tensor]\n            return x << y, x >> y\n\n        x = torch.tensor(2)\n        y = torch.tensor(3)\n\n        self.checkScript(tensor_test, (x, y))\n        self.checkScript(tensor_with_int_test, (x, 2))\n\n        def not_test(x):\n            return ~x\n\n        self.checkScript(not_test, (torch.tensor([2, 4]), ))\n\n    def test_all(self):\n        @torch.jit.script\n        def test_all_tensor(x):\n            return all(x)\n        self.assertFalse(test_all_tensor(torch.tensor([1, 0, 3], dtype=torch.uint8)))\n        self.assertTrue(test_all_tensor(torch.tensor([3.14, 3, 99], dtype=torch.uint8)))\n        self.assertTrue(test_all_tensor(torch.tensor([True, True], dtype=torch.uint8)))\n        self.assertFalse(test_all_tensor(torch.tensor([True, False], dtype=torch.uint8)))\n\n        @torch.jit.script\n        def test_all_bool_list(x):\n            # type: (List[bool]) -> bool\n            return all(x)\n        self.assertTrue(test_all_bool_list([True, True]))\n        self.assertTrue(test_all_bool_list([True, 1]))\n        self.assertFalse(test_all_bool_list([True, False]))\n        self.assertFalse(test_all_bool_list([True, 0]))\n        self.assertFalse(test_all_bool_list([False, 0]))\n        self.assertTrue(test_all_bool_list([]))\n\n        @torch.jit.script\n        def test_all_int_list(x):\n            # type: (List[int]) -> bool\n            return all(x)\n        self.assertTrue(test_all_int_list([3, 6]))\n        self.assertFalse(test_all_int_list([2, 0]))\n\n        @torch.jit.script\n        def test_all_float_list(x):\n            # type: (List[float]) -> bool\n            return all(x)\n        self.assertTrue(test_all_float_list([3.14, 8.1]))\n        self.assertFalse(test_all_float_list([3.14, 0, 8.9]))\n\n\n    def test_number_math(self):\n        ops_template = dedent('''\n        def func():\n            return {scalar1} {op} {scalar2}\n        ''')\n        ops = ['+', '-', '*', '%', '<', '<=', '>', '>=', '==', '!=', '//']\n        funcs_template = dedent('''\n        def func():\n            return {func}({scalar1}, {scalar2})\n        ''')\n        funcs = ['min', 'max']\n        scalars = ['7', '2', '3', '-3', '3.14', '0.125', '-0.5', '2.0', '-2.0']\n        scalar_pairs = [(scalar1, scalar2) for scalar1 in scalars for scalar2 in scalars]\n\n        def run_test(code):\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n\n            self.assertEqual(cu.func(), scope['func']())\n\n        for scalar1, scalar2 in scalar_pairs:\n            for op in ops:\n                code = ops_template.format(op=op, scalar1=scalar1, scalar2=scalar2)\n                run_test(code)\n            for func in funcs:\n                code = funcs_template.format(func=func, scalar1=scalar1, scalar2=scalar2)\n                run_test(code)\n\n        # test Scalar overloads\n        for scalar1, scalar2 in scalar_pairs:\n            item1 = 'torch.tensor(' + scalar1 + ').item()'\n            item2 = 'torch.tensor(' + scalar2 + ').item()'\n            for op in ops:\n                code = ops_template.format(op=op, scalar1=item1, scalar2=scalar2)\n                run_test(code)\n                code = ops_template.format(op=op, scalar1=scalar1, scalar2=item2)\n                run_test(code)\n                code = ops_template.format(op=op, scalar1=item1, scalar2=item2)\n                run_test(code)\n            for func in funcs:\n                code = funcs_template.format(func=func, scalar1=item1, scalar2=scalar2)\n                run_test(code)\n                code = funcs_template.format(func=func, scalar1=scalar1, scalar2=item2)\n                run_test(code)\n                code = funcs_template.format(func=func, scalar1=item1, scalar2=item2)\n                run_test(code)\n\n    def test_number_abs(self):\n        def func1(x):\n            # type: (float) -> float\n            return abs(x)\n\n        def func2(x):\n            # type: (int) -> int\n            return abs(x)\n\n        def func3(x):\n            return abs(x)\n\n        self.checkScript(func1, (-3.14,))\n        self.checkScript(func1, (3.14,))\n        self.checkScript(func2, (-10,))\n        self.checkScript(func2, (10,))\n        self.checkScript(func3, (torch.tensor([-5, -10, -20]),))\n        self.checkScript(func3, (torch.tensor([5, 10, 20]),))\n        self.checkScript(func3, (torch.tensor([-5, 10, -20]),))\n\n    def test_number_div(self):\n        self.assertEqual(div_int_future(), torch.jit.script(div_int_future)())\n        self.checkScript(div_float_future, ())\n\n        self.checkScript(div_int_nofuture, ())\n        self.checkScript(div_float_nofuture, ())\n\n    # Testing bitwise shorthand aug assignment\n    def test_bool_augassign_bitwise_or(self):\n        def func(a: bool, b: bool) -> bool:\n            a |= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_bool_augassign_bitwise_and(self):\n        def func(a: bool, b: bool) -> bool:\n            a &= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_bool_augassign_bitwise_xor(self):\n        def func(a: bool, b: bool) -> bool:\n            a ^= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_number_augassign_bitwise_lshift(self):\n        def func() -> int:\n            z = 8\n            z <<= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign_bitwise_rshift(self):\n        def func() -> int:\n            z = 8\n            z >>= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign_bitwise_pow(self):\n        def func() -> float:\n            z = 8\n            z **= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign(self):\n        def func():\n            z = 1\n            z += 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_nested_select_assign(self):\n        class SubSubModule(torch.nn.Module):\n            def __init__(self):\n                super(SubSubModule, self).__init__()\n                self.abc = 11\n\n            def forward(self, x):\n                return self.abc\n\n        class SubModule(torch.nn.Module):\n            def __init__(self):\n                super(SubModule, self).__init__()\n                self.a = 11\n                self.nested = SubSubModule()\n\n            def forward(self, x):\n                return self.a\n\n        class TestModule(torch.nn.Module):\n            def __init__(self):\n                super(TestModule, self).__init__()\n                self.sub = SubModule()\n                self.hi = 1\n\n            def forward(self):\n                self.hi = 5\n                self.sub.a = 1\n                self.sub.nested.abc = 5\n                return self.sub.a * 20 + self.sub.nested.abc * 3 + self.hi\n\n        self.checkModule(TestModule(), ())\n\n    def test_number_neg(self):\n        # int -> int\n        def func1():\n            return -8\n\n        # float -> float\n        def func2():\n            return -3.14\n\n        self.checkScript(func1, (), optimize=True)\n        self.checkScript(func2, (), optimize=True)\n\n    def test_compare_two_bool_inputs(self):\n        def compare_eq(a: bool, b: bool):\n            return a == b\n\n        def compare_ne(a: bool, b: bool):\n            return a != b\n\n        scripted_fn_eq = torch.jit.script(compare_eq)\n        scripted_fn_ne = torch.jit.script(compare_ne)\n        self.assertEqual(scripted_fn_eq(True, False), compare_eq(True, False))\n        self.assertEqual(scripted_fn_eq(False, True), compare_eq(False, True))\n        self.assertEqual(scripted_fn_eq(True, True), compare_eq(True, True))\n        self.assertEqual(scripted_fn_eq(False, False), compare_eq(False, False))\n\n        self.assertEqual(scripted_fn_ne(True, False), compare_ne(True, False))\n        self.assertEqual(scripted_fn_ne(False, True), compare_ne(False, True))\n        self.assertEqual(scripted_fn_ne(True, True), compare_ne(True, True))\n        self.assertEqual(scripted_fn_ne(False, False), compare_ne(False, False))\n\n\n    def _test_tensor_number_math(self, device='cpu'):\n        template = dedent('''\n        def func(t):\n            return {lhs} {op} {rhs}\n        ''')\n\n        def test(op, tensor, const, swap_args, template=template):\n            args = ('t', const)\n            if swap_args:\n                args = (const, 't')\n\n            code = template.format(lhs=args[0], rhs=args[1], op=op)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            message = 'with code `{} {} {}` and t={}'.format(args[0], op, args[1], tensor)\n            res1 = cu.func(tensor)\n            res2 = scope['func'](tensor)\n            self.assertEqual(res1, res2, msg=message + \"\\nres1=\" + str(res1) + \"\\nres2=\" + str(res2))\n            self.assertEqual(res1.dtype, res2.dtype, msg=message + \"\\nres1=\" + str(res1) + \"\\nres2=\" + str(res2))\n\n        var_int = [2, -2]\n        var_float = [1.4321, -1.2]\n\n        ops = ['+', '-', '*', '%', '<', '<=', '>', '>=', '==', '!=', '/']\n\n        float_tensor = torch.randn(5, 5, device=device)\n        double_tensor = torch.randn(5, 5, dtype=torch.double, device=device)\n        long_tensor = torch.randint(-5, 5, (5, 5), dtype=torch.long, device=device)\n        long_tensor[long_tensor == 0] = 2\n\n        tensors = [float_tensor, double_tensor, long_tensor]\n        consts = var_int + var_float\n\n        for op, tensor, const, swap_args in product(ops, tensors, consts, [True, False]):\n            # FIXME: things like 2 / long_tensor are not implemented correctly\n            # Look in torch/_tensor.py to see how pytorch implements it.\n            if op == '/' and tensor.data_ptr() == long_tensor.data_ptr():\n                continue\n\n            # % operator does not take: const % tensor\n            if op == '%' and swap_args is True:\n                continue\n\n            test(op, tensor, const, swap_args)\n\n    def test_tensor_number_math(self):\n        self._test_tensor_number_math()\n\n    def test_torch_tensor_bad_input(self):\n        with self.assertRaisesRegex(RuntimeError, \"must be of ints, floats, \"\n                                    \"or bools, got None\"):\n            @torch.jit.script\n            def test():\n                return torch.tensor([None])\n            test()\n\n        with self.assertRaisesRegex(RuntimeError, r\"Empty lists default to List\\[Tensor\\]\"):\n            @torch.jit.script\n            def tmp():\n                return torch.tensor([])\n            tmp()\n\n        @torch.jit.script\n        def foo():\n            return torch.tensor([[2, 2], [1]])\n        with self.assertRaisesRegex(RuntimeError, \"Expected sequence of length\"):\n            foo()\n\n    @suppress_warnings\n    def test_torch_tensor_as_tensor_empty_list(self):\n        tensor_template = dedent('''\n        def func():\n            empty_list = torch.jit.annotate(List[int], [])\n            ten1 = torch.{tensor_op}({input})\n            return ten1\n        ''')\n        ops = ['tensor', 'as_tensor']\n        inputs = ['empty_list', '[empty_list, empty_list]', '[[[empty_list]]]']\n\n        for op in ops:\n            for inp in inputs:\n                code = tensor_template.format(tensor_op=op, input=inp)\n                scope = {}\n                exec(code, globals(), scope)\n                cu = torch.jit.CompilationUnit(code)\n                t1 = cu.func()\n                t2 = scope['func']()\n                if inp == 'empty_list':\n                    # torchscript returns int tensor, python returns float tensor\n                    self.assertNotEqual(t1.dtype, t2.dtype)\n                self.assertEqual(t1, t2, exact_dtype=False)\n                self.assertEqual(t1.device, t2.device)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"Simple Executor doesn't have any shapes to propagate\")\n    def test_tensor_as_tensor_shape_prop(self):\n        tensor_template = dedent('''\n        def func():\n            return torch.{tensor_op}({input})\n        ''')\n        ops = ['tensor', 'as_tensor']\n        inputs = ['[1]', '[False]', '[2.5]', '0.5', '1', 'False', '[[1]]', 'torch.jit.annotate(List[List[int]], [])']\n        expected_shape = [\"Long(*, device=cpu)\", \"Bool(*, device=cpu)\",\n                          \"Double(*, device=cpu)\", \"Double(device=cpu)\",\n                          \"Long(device=cpu)\", \"Bool(device=cpu)\", \"Long(*, *, device=cpu)\"]\n\n        for op in ops:\n            for inp, expect in zip(inputs, expected_shape):\n                code = tensor_template.format(tensor_op=op, input=inp)\n                scope = {}\n                exec(code, globals(), scope)\n                cu = torch.jit.CompilationUnit(code)\n                torch._C._jit_pass_complete_shape_analysis(cu.func.graph, (), False)\n                FileCheck().check(expect).check(\"aten::{tensor_op}\".format(tensor_op=op)).run(cu.func.graph)\n\n        @torch.jit.script\n        def test_dtype(inp_dtype: torch.dtype):\n            a = torch.tensor(1.0, dtype=torch.float, requires_grad=True)\n            return a, torch.tensor(1.0, dtype=inp_dtype)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            g = test_dtype.graph_for(5, profile_and_replay=True)\n            # both should have completed shapes\n            FileCheck().check(\"Tensor = aten::tensor\").check(\"Float(device=cpu) = prim::BailOut\") \\\n                       .check(\"Tensor = aten::tensor\").check(\"Half(device=cpu) = prim::BailOut\").run(g)\n        else:\n            g = test_dtype.graph_for(5)\n            # first should have type set second should not\n            FileCheck().check(\"Float(requires_grad=1, device=cpu) = aten::tensor\") \\\n                       .check(\"Tensor(requires_grad=0) = aten::tensor\").run(g)\n\n        @torch.jit.script\n        def test_as_tensor_tensor_input(input):\n            a = torch.as_tensor(input, dtype=input.dtype)\n            return a, torch.as_tensor(input, dtype=torch.float)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            g = test_as_tensor_tensor_input.graph_for(torch.ones(3, 4), profile_and_replay=True)\n            FileCheck().check(\"Tensor = aten::as_tensor\").check(\"Float(3, 4) = prim::BailOut\") \\\n                       .check(\"Tensor = aten::as_tensor\").check(\"Float(3, 4) = prim::BailOut\").run(g)\n        else:\n            g = test_as_tensor_tensor_input.graph_for(torch.ones(3, 4))\n            FileCheck().check(\"Tensor = aten::as_tensor\").check(\"Float(*, *, requires_grad=0, device=cpu) = aten::as_tensor\").run(g)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"testing legacy behavior\")\n    def test_tensor_requires_grad(self):\n        @torch.jit.script\n        def test(b):\n            # type: (bool) -> Tuple[Tensor, Tensor, Tensor]\n            a = torch.tensor(1., requires_grad=b)\n            b = torch.tensor(1., requires_grad=True)\n            c = torch.tensor(1., requires_grad=False)\n            return a, b, c\n\n        g = test.graph_for(True)\n        out = next(g.outputs())\n        out_inp = list(out.node().inputs())\n\n        self.assertTrue(out_inp[0].requires_grad())\n        self.assertTrue(out_inp[1].requires_grad())\n        self.assertFalse(out_inp[2].requires_grad())\n\n    def test_grad_from_script(self):\n        def test():\n            a = torch.tensor(2.5, requires_grad=True)\n            b = a * 2\n            return a, b\n\n        a, b = test()\n        b.backward()\n\n        a_script, b_script = torch.jit.script(test)()\n        b_script.backward()\n        self.assertEqual(a.grad, a_script.grad)\n\n    def test_torch_tensor_as_tensor(self):\n        tensor_template = dedent('''\n        def func():\n            li = {list_create}\n            ten1 = torch.{tensor_op}(li {options})\n            return ten1\n        ''')\n\n        lists = [\"2.5\", \"4\", \"True\", \"False\", \"[2]\", \"[-.5]\", \"[False, True, False]\", \"[2, 2]\", \"(1, 1)\",\n                 \"torch.jit.annotate(List[List[int]], [])\",\n                 \"torch.jit.annotate(List[int], [])\", \"[2.5, 2.5]\", \"[[2], [2]]\", \"[[-.5], [2.2]]\", \"[[False], [True]]\"]\n\n        dtypes = [\"\", \", dtype=torch.float\", \", dtype=torch.double\", \", dtype=torch.half\",\n                  \", dtype=torch.uint8\", \", dtype=torch.int8\", \", dtype=torch.short\",\n                  \", dtype=torch.int\", \", dtype=torch.long\", \", dtype=torch.cfloat\",\n                  \", dtype=torch.cdouble\"]\n\n        ops = ['tensor', 'as_tensor']\n        devices = ['', \", device='cpu'\"]\n        if RUN_CUDA:\n            devices.append(\", device='cuda'\")\n\n        option_pairs = [dtype + device for dtype in dtypes for device in devices]\n        for op in ops:\n            for li in lists:\n                for option in option_pairs:\n                    # tensor from empty list is type float in python and annotated type in torchscript\n                    if \"annotate\" in li and \"dtype\" not in option:\n                        continue\n                    # Skip unsigned tensor initializaton for signed values on 3.10\n                    if sys.version_info[:2] >= (3, 10) and \"torch.uint8\" in option and \"-\" in li:\n                        continue\n                    code = tensor_template.format(list_create=li, tensor_op=op, options=option)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    cu = torch.jit.CompilationUnit(code)\n                    t1 = cu.func()\n                    t2 = scope['func']()\n                    if t1.dtype == torch.float16:  # equality NYI for half tensor\n                        self.assertTrue(str(t1) == str(t2))\n                    else:\n                        self.assertEqual(t1, t2)\n                    self.assertEqual(t1.dtype, t2.dtype)\n                    self.assertEqual(t1.device, t2.device)\n\n        def test_as_tensor_tensor_input(input):\n            # type: (Tensor) -> Tuple[Tensor, Tensor, Tensor]\n            return torch.as_tensor(input, dtype=torch.cfloat), torch.as_tensor(input, dtype=torch.float), \\\n                torch.as_tensor(input, dtype=torch.int32)\n\n        inp = torch.randn(3, 4, dtype=torch.cfloat)\n        self.checkScript(test_as_tensor_tensor_input, (inp,))\n\n    def test_torch_tensor_dtype(self):\n        def foo(s: float):\n            return torch.tensor(s), torch.tensor([s, s])\n\n        # need to clear function cache so we re run shape analysis\n        with set_default_dtype(torch.double):\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Double\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n        with set_default_dtype(torch.float):\n            del torch.jit._state._jit_caching_layer[foo]\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Float\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n        with set_default_dtype(torch.half):\n            del torch.jit._state._jit_caching_layer[foo]\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Half\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n\n    def test_shape_analysis_grad_property(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.sub(x, torch.tanh(x))\n\n        torch._C._jit_pass_complete_shape_analysis(foo.graph, (torch.tensor([0.39]),), False)\n\n        # requires_grad property shouldn't be accidentally set by shape analysis\n        self.assertTrue(foo.graph.findNode(\"aten::sub\").output().requiresGrad() is None)\n\n    def test_empty_like_memory_format_bc(self):\n        def f(x):\n            # type: (Tensor) -> Tensor\n            return torch.zeros_like(x, memory_format=None)\n\n        scripted_f = torch.jit.script(f)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted_f(x), f(x))\n\n    def test_multiline_string_dedents(self):\n        def foo() -> None:\n            multiline_string_dedent_1 = \"\"\"\nThis is a string dedent \"\"\"\n            multiline_string_dedent_2 = \"\"\" This is a\n  string dedent \"\"\"\n            multiline_string_dedent_3 = \"\"\"\n            This is a string\ndedent \"\"\"\n            multiline_string_dedent_4 = \"\"\" This is a string dedent \"\"\"\n\n        scripted_foo = torch.jit.script(foo)\n        self.assertEqual(scripted_foo(), foo())\n\n    def test_class_with_comment_at_lower_indentation(self):\n        class Foo(torch.nn.Module):\n            def forward(self, x):\n                x = torch.neg(x)\n        # This comment is at the wrong indent\n                return x\n\n        torch.jit.script(Foo())\n\n    # adapted from test in test_torch\n    def test_tensor_to(self):\n        template = dedent('''\n        def func(t):\n            cuda = \"{cuda}\"\n            device = \"{device}\"\n            non_blocking = {non_blocking}\n            return {to_str}\n        ''')\n\n        def s(t, to_str, non_blocking=None, device=None, cuda=None):\n            device = device if device is not None else str(t.device)\n            non_blocking = non_blocking if non_blocking is not None else False\n            cuda = \"cuda\" if cuda is None else cuda\n            code = template.format(to_str=to_str, device=device, non_blocking=non_blocking, cuda=cuda)\n            scope = {}\n            cu = torch.jit.CompilationUnit(code)\n            return cu.func(t, profile_and_replay=True)\n\n        def test_copy_behavior(t, non_blocking=False):\n            self.assertIs(t, s(t, 't.to(t, non_blocking=non_blocking)', non_blocking))\n            self.assertIs(t, s(t, 't.to(t.dtype, non_blocking=non_blocking)', non_blocking))\n            self.assertIs(t, s(t, 't.to(torch.empty_like(t), non_blocking=non_blocking)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(t, non_blocking=non_blocking, copy=True)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(t.dtype, non_blocking=non_blocking, copy=True)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(torch.empty_like(t), non_blocking=non_blocking, copy=True)', non_blocking))\n\n            devices = [t.device]\n            if t.device.type == 'cuda':\n                if t.device.index == -1:\n                    devices.append('cuda:{}'.format(torch.cuda.current_device()))\n                elif t.device.index == torch.cuda.current_device():\n                    devices.append('cuda')\n            for device in devices:\n                self.assertIs(t, s(t, 't.to(device, non_blocking=non_blocking)', non_blocking, device))\n                self.assertIs(t, s(t, 't.to(device, t.dtype, non_blocking=non_blocking)', non_blocking, device))\n                self.assertIsNot(t, s(t, 't.to(device, non_blocking=non_blocking, copy=True)', non_blocking, device))\n                self.assertIsNot(t, s(t, 't.to(device, t.dtype, non_blocking=non_blocking, copy=True)',\n                                      non_blocking, device))\n\n        t = torch.tensor(5)\n        test_copy_behavior(t)\n\n        self.assertEqual(t.device, s(t, \"t.to('cpu')\").device)\n        self.assertEqual(t.device, s(t, \"t.to('cpu', dtype=torch.float32)\").device)\n        self.assertIs(torch.float32, s(t, \"t.to('cpu', dtype=torch.float32)\").dtype)\n        self.assertEqual(t.device, s(t, \"t.to(torch.float32)\").device)\n        self.assertIs(torch.float32, s(t, \"t.to(dtype=torch.float32)\").dtype)\n        self.assertEqual(t.data_ptr(), s(t, \"t.to('cpu')\").data_ptr())\n        self.assertEqual(t.data_ptr(), s(t, \"t.to(dtype=t.dtype, device=t.device, copy=False)\").data_ptr())\n        self.assertEqual(t.data_ptr(), s(t, \"t.to('cpu', copy=False)\").data_ptr())\n        self.assertNotEqual(t.data_ptr(), s(t, \"t.to('cpu', copy=True)\").data_ptr())\n\n        a = torch.tensor(5)\n        if torch.cuda.is_available():\n            for non_blocking in [True, False]:\n                for cuda in ['cuda', 'cuda:0' if torch.cuda.device_count() == 1 else 'cuda:1']:\n                    b = torch.tensor(5., device=cuda)\n                    test_copy_behavior(b, non_blocking)\n                    self.assertEqual(b.device, s(b, \"t.to(cuda, non_blocking=non_blocking).device\", cuda=cuda))\n                    self.assertEqual(a.device, s(b, \"t.to('cpu', non_blocking=non_blocking).device\"))\n                    self.assertEqual(b.device, s(b, \"t.to(cuda, non_blocking=non_blocking).device\", cuda=cuda))\n                    self.assertIs(torch.int32, s(b, \"t.to('cpu', dtype=torch.int32, non_blocking=non_blocking)\").dtype)\n                    self.assertEqual(a.device, s(b, \"t.to('cpu', dtype=torch.int32, non_blocking=non_blocking)\").device)\n                    self.assertIs(torch.int32, s(b, \"t.to(dtype=torch.int32)\").dtype)\n                    self.assertEqual(b.device, s(b, \"t.to(dtype=torch.int32)\").device)\n\n        # Test AD: aten::to(Tensor self, int dtype, bool non_blocking, bool copy) -> Tensor\n        t = torch.tensor(5).float().requires_grad_()\n        out_ref = t.to(torch.float32)\n        out = s(t, \"t.to(torch.float32)\")\n        self.assertEqual(out_ref, out)\n\n        grad_ref = torch.autograd.grad(out_ref.sum(), t)\n        grad = torch.autograd.grad(out.sum(), t)\n        self.assertEqual(grad_ref, grad)\n\n        # Test AD: aten::to(Tensor self, Device? device, int? dtype, bool non_blocking, bool copy) -> Tensor\n        out_ref = t.to('cpu')\n        out = s(t, \"t.to('cpu')\")\n        self.assertEqual(out_ref, out)\n\n        grad_ref = torch.autograd.grad(out_ref.sum(), t)\n        grad = torch.autograd.grad(out.sum(), t)\n        self.assertEqual(grad_ref, grad)\n\n        # Test AD: aten::to(Tensor self, Tensor other, bool non_blocking, bool copy) -> Tensor\n        @torch.jit.script\n        def func2(t, t_ref):\n            return t.to(t_ref)\n\n        with disable_autodiff_subgraph_inlining():\n            t_ref = torch.tensor(4).double()\n            out_ref = t.to(t_ref)\n            out = func2(t, t_ref)\n            grad_ref = torch.autograd.grad(out_ref.sum(), t)\n            grad = torch.autograd.grad(out.sum(), t)\n            self.assertEqual(grad_ref, grad)\n\n    @unittest.skipIf(not RUN_CUDA, \"No CUDA\")\n    def test_tensor_number_math_cuda(self):\n        self._test_tensor_number_math(device='cuda')\n\n    def test_not(self):\n        # test not operator in python\n        # TODO: add more tests when bool conversions ready\n        def test_not_op(a):\n            return not bool(a > 1)\n\n        self.checkScript(test_not_op, (torch.tensor(2), ), optimize=True)\n\n    def test_is_isnot(self):\n        # test is and is not operator in python\n        template = dedent('''\n        def func():\n            # type: () -> bool\n            return {lhs} {op} {rhs}\n        ''')\n\n        def test(op, args):\n            code = template.format(lhs=args[0], rhs=args[1], op=op)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            self.assertEqual(\n                cu.func(),\n                scope['func'](),\n                msg=\"Failed with op: {}, lhs: {}, rhs: {}\"\n                .format(op, args[0], args[1])\n            )\n\n        ops = ['is', 'is not']\n        type_literals = [True, False, None, [1, 1], 1, 2, .5, 1.5]\n\n        # do literals product to try any types combinations\n        for op, lhs, rhs in product(ops, type_literals, type_literals):\n            test(op, [lhs, rhs])\n\n    def test_isinstance_refinement(self):\n        @torch.jit.script\n        def foo(a):\n            # type: (Optional[int]) -> int\n            if isinstance(a, int):\n                return a + 3\n            else:\n                return 4\n        self.assertEqual(foo(4), 7)\n        self.assertEqual(foo(None), 4)\n\n        @torch.jit.script\n        def foo2(a, b):\n            # type: (Optional[int], Optional[int]) -> int\n            if not isinstance(a, int) or not isinstance(b, int):\n                return 0\n            else:\n                return a + b\n        self.assertEqual(foo2(3, 4), 7)\n        self.assertEqual(foo2(None, 4), 0)\n        self.assertEqual(foo2(4, None), 0)\n\n        @torch.jit.script\n        def any_refinement(a, b):\n            # type: (Any, Any) -> int\n            if isinstance(a, int) and isinstance(b, int):\n                return a + b\n            return 0\n\n        self.assertEqual(any_refinement(3, 4), 7)\n        self.assertEqual(any_refinement(3, \"hi\"), 0)\n\n        @torch.jit.script\n        def any_refinement2(a):\n            # type: (Any) -> Tensor\n            if isinstance(a, Tensor):\n                return a\n            return torch.tensor(3)\n\n        self.assertEqual(any_refinement2(3), torch.tensor(3))\n        self.assertEqual(any_refinement2(torch.tensor(5)), torch.tensor(5))\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.LEGACY, \"bug persists in deprecated executor\")\n    def test_unspecialized_any_binding(self):\n        # any binding will infer the type, if it infers\n        # a specialized tensor type `x` Dict type will fail isinstance check\n\n        @torch.jit.script\n        def foo(x: Any):\n            assert isinstance(x, Dict[str, torch.Tensor])\n\n        foo({\"1\": torch.tensor(3)})\n        with self.assertRaises(Exception):\n            foo(2)\n\n    def test_isinstance(self):\n        # test isinstance operator for static type checking\n        template = dedent('''\n        def func(x):\n            # type: ({type_hint}) -> bool\n            return isinstance(x, {typ})\n        ''')\n\n        def test(inp, typ, type_hint):\n            code = template.format(typ=typ, type_hint=type_hint)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            self.assertEqual(\n                cu.func(inp),\n                scope['func'](inp),\n                msg=\"Failed with typ: {}\"\n                .format(typ)\n            )\n\n        inputs = [True, 1, 1.0, torch.tensor(1), [1, 2], (1.0,), [1, 2], 1]\n        type_literals = ['bool', 'int', 'float', 'torch.Tensor', 'list', 'tuple',\n                         '(list, tuple)', '(int, float, bool)']\n        type_annotations = ['bool', 'int', 'float', 'Tensor', 'List[int]', 'Tuple[float]',\n                            'List[int]', 'int']\n\n        # do zipping to try different types\n        for inp, typ, type_hint in zip(inputs, type_literals, type_annotations):\n            test(inp, typ, type_hint)\n\n        # test optional isinstance check\n        @torch.jit.script\n        def opt_func(x):\n            # type: (Optional[int]) -> bool\n            return isinstance(x, int)\n        self.assertTrue(opt_func(3))\n        self.assertFalse(opt_func(None))\n\n    def test_dropout_eval(self):\n        class ScriptedConv2d(torch.jit.ScriptModule):\n            def __init__(self, in_channels, out_channels, **kwargs):\n                super(ScriptedConv2d, self).__init__()\n                self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\n                self.bn = nn.BatchNorm2d(out_channels, eps=0.001)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return F.relu(x, inplace=True)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.Conv2d_1a_3x3 = ScriptedConv2d(3, 32, kernel_size=3, stride=2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                x = self.Conv2d_1a_3x3(x)\n                return F.dropout(x, training=self.training)\n\n        class EagerConv2d(torch.nn.Module):\n            def __init__(self, in_channels, out_channels, **kwargs):\n                super(EagerConv2d, self).__init__()\n                self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\n                self.bn = nn.BatchNorm2d(out_channels, eps=0.001)\n\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return F.relu(x, inplace=True)\n\n        class EagerMod(torch.nn.Module):\n            def __init__(self):\n                super(EagerMod, self).__init__()\n                self.Conv2d_1a_3x3 = EagerConv2d(3, 32, kernel_size=3, stride=2)\n\n            def forward(self, x):\n                x = self.Conv2d_1a_3x3(x)\n                return F.dropout(x, training=self.training)\n\n        script_input = torch.rand(4, 3, 299, 299)\n        eager_input = script_input.clone()\n\n        with freeze_rng_state():\n            script_mod = ScriptMod()\n            script_mod.eval()\n            script_output = script_mod(script_input)\n\n        with freeze_rng_state():\n            eager_mod = EagerMod()\n            eager_mod.eval()\n            eager_output = eager_mod(eager_input)\n\n        self.assertEqual(script_output, eager_output)\n\n        with freeze_rng_state():\n            script_mod = ScriptMod()\n            script_mod.train()\n            script_output = script_mod(script_input)\n\n        with freeze_rng_state():\n            eager_mod = EagerMod()\n            eager_mod.train()\n            eager_output = eager_mod(eager_input)\n\n        self.assertEqual(script_output, eager_output)\n\n    def test_nested_breaks(self):\n        def no_bool_loop_outputs(g):\n            # testing that the \"did exit\" transform values are not loop block\n            # outputs (and thus not affecting one loop from another)\n            loops = g.findAllNodes(\"prim::Loop\")\n            for loop in loops:\n                for out in loop.outputs():\n                    self.assertTrue(out.type() != BoolType.get())\n\n        def test(y):\n            # type: (int)\n            ret = 0\n            tensor = torch.tensor(0)\n            while int(tensor.add_(1)) < 4:\n                if y == 1:\n                    continue\n                for i in range(y):\n                    continue\n                    ret += 1\n                ret += 1\n            return ret, int(tensor)\n\n        self.assertEqual(torch.jit.script(test)(1), test(1))\n        self.assertEqual(torch.jit.script(test)(2), test(2))\n        no_bool_loop_outputs(torch.jit.script(test).graph)\n\n        def foo():\n            y = torch.tensor(0)\n            z = 0\n            while int(y.add_(1)) < 20:\n                if int(y) < 10:\n                    for i in range(6):\n                        if i == 3:\n                            continue\n                        else:\n                            if i > 3:\n                                break\n                        z += 2\n                if int(y) == 18:\n                    break\n                if int(y) == 15:\n                    continue\n                z += 1\n            return int(y), z\n\n        no_bool_loop_outputs(torch.jit.script(foo).graph)\n        self.checkScript(foo, ())\n\n        def test_nested_two():\n            i = 0\n            k = 0\n            while i < 5:\n                for j in range(5):\n                    k += 1\n                    if j == 3:\n                        continue\n                i += 1\n                k += 1\n                if i == 4:\n                    break\n            return i, k\n\n        self.checkScript(test_nested_two, ())\n        no_bool_loop_outputs(torch.jit.script(test_nested_two).graph)\n\n    def test_breaks_continues(self):\n        def foo_continue(cond):\n            # type: (int)\n            j = 1\n            for i in range(5):\n                if i == cond:\n                    continue\n                j += 1\n            return j\n\n        def foo_break(cond):\n            # type: (int)\n            j = 1\n            for i in range(5):\n                if i == cond:\n                    break\n                j += 1\n            return j\n\n        for i in range(1, 4):\n            self.checkScript(foo_continue, (i,))\n            self.checkScript(foo_break, (i,))\n\n        def test_refine_outside_loop():\n            if 1 == 1:\n                x = None\n            else:\n                x = 1\n            i = 0\n            j = 0\n            while (x is None or torch.jit._unwrap_optional(x) > 3):\n                if i < 3:\n                    if i < 3:\n                        x = torch.jit.annotate(Optional[int], None)\n                        i += 1\n                        continue\n                    x = 1\n                else:\n                    x = 1 if x is None else x\n                x = x + 1\n                j = x + x\n\n            return x, j\n\n        self.checkScript(test_refine_outside_loop, ())\n\n        def assign_after_break(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                x = y * 2 + i\n                break\n                x = 4\n            return x\n\n        self.checkScript(assign_after_break, (1,))\n        self.checkScript(assign_after_break, (2,))\n        self.checkScript(assign_after_break, (3,))\n\n        def assign_after_break_nested(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                if y == 1:\n                    x = 5\n                    break\n                    assert 1 == 2\n                else:\n                    x = x + 1\n                    break\n                    assert 1 == 2\n                x = -30\n                assert 1 == 2\n            return x\n\n        self.checkScript(assign_after_break_nested, (1,))\n        self.checkScript(assign_after_break_nested, (2,))\n        self.checkScript(assign_after_break_nested, (3,))\n\n        def may_break(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                if y == 1:\n                    x = 5\n                else:\n                    x = x + 1\n                    break\n                x = -30\n            return x\n\n        self.checkScript(may_break, (1,))\n        self.checkScript(may_break, (2,))\n        self.checkScript(may_break, (3,))\n\n        def test(x, y):\n            # type: (int, int)\n            a = 1\n            while (x > 0):\n                if y == 3:\n                    for i in range(y):\n                        a += (1 % (i + 1))\n                        x -= 1\n                if x == 3:\n                    a = x * 3\n                    break\n                if x < 3:\n                    if x == 1:\n                        a -= 2\n                        x -= 1\n                        break\n                a -= 1\n                x -= 3\n            return a, x\n\n        self.checkScript(test, (10, 3))\n        self.checkScript(test, (10, 2))\n        self.checkScript(test, (3, 2))\n        self.checkScript(test, (5, 3))\n        self.checkScript(test, (2, 3))\n\n        def test_delete_after_break(x):\n            # type: (int)\n            a = 1\n            b = 1\n            for i in range(x):\n                a = i * 3\n                break\n                b = i * 5\n            return a, b\n\n        self.checkScript(test_delete_after_break, (0,))\n        self.checkScript(test_delete_after_break, (1,))\n\n        def test_will_break_after_guard(x):\n            # type: (int)\n            a = 1\n            for i in range(x):\n                if i == 4:\n                    a = 3\n                    break\n                a -= 1\n                break\n                assert 1 == 2\n                a -= -100\n            return a\n\n        self.checkScript(test_will_break_after_guard, (0,))\n        self.checkScript(test_will_break_after_guard, (2,))\n        self.checkScript(test_will_break_after_guard, (4,))\n\n        def test_varexit(cond):\n            # type: (int)\n            m = 0\n            for i in range(3):\n                if cond == 2:\n                    if cond == 2:\n                        m = 2\n                        break\n                    k = 1\n                else:\n                    k = 2\n                m += k\n            return m\n\n        # use of k tests the pathway where we have to insert unitialized\n        self.checkScript(test_varexit, (3,))\n        self.checkScript(test_varexit, (2,))\n\n        def test_break_true():\n            i = 0\n            while True:\n                i += 1\n                if i == 3:\n                    break\n            while False:\n                i += 1\n            return i\n\n        self.checkScript(test_break_true, ())\n\n    def test_break_continue_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"Syntax\"):\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                break\n                ''')\n\n        with self.assertRaisesRegex(RuntimeError, \"Syntax\"):\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                for i in range(5):\n                    def foo():\n                        break\n                ''')\n\n        with self.assertRaisesRegex(RuntimeError, \"do not support break or continue inside\"):\n            @torch.jit.script\n            def foo(x):\n                i = 0\n                for a in (1, \"2\", 1.5):\n                    b = a\n                    if x:\n                        break\n                return b\n\n    def test_python_call(self):\n        def pyfunc(a):\n            return a * 3.0\n\n        cu = torch.jit.CompilationUnit('''\n        def other_func(a):\n            return a + a\n\n        def test_call_python(a):\n            b = pyfunc(a)\n            b = other_func(b)\n            i = 0\n            step = 1\n            while i < 10:\n                b = pyfunc(b)\n                if bool(b > 3.0):\n                    b = pyfunc(b)\n                i = 11\n            return b\n        ''')\n        inputs = self._make_scalar_vars([1], torch.float)\n        outputs = self._make_scalar_vars([54], torch.float)\n\n        self.assertEqual(cu.test_call_python(*inputs), outputs[0])\n\n    def test_python_call_failure(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value pyfunc2\"):\n            def pyfunc(a):\n                return a * 3.0\n\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                return a + a\n\n            def test_call_python(a):\n                b = pyfunc(a)\n                b = other_func(b)\n                i = 0\n                step = 1\n                while i < 10:\n                    b = pyfunc2(b)\n                    if b > 3.0:\n                        b = pyfunc(b)\n                    i = 11\n                return b\n            ''')\n            inputs = self._make_scalar_vars([1], torch.float)\n            outputs = self._make_scalar_vars([54], torch.float)\n\n            self.assertEqual(cu.test_call_python(*inputs), outputs)\n\n    def test_type_call_in_script(self):\n        @torch.jit.script\n        def fn(x):\n            return type(x)\n\n        with self.assertRaisesRegex(RuntimeError, \"value of type _TensorMeta\"):\n            fn(torch.tensor(.5))\n\n    def test_python_call_annotation(self):\n        def pyfunc(a):\n            return a * 3.0\n\n        @torch.jit.script\n        def foo(a):\n            return pyfunc(a) + pyfunc(a)\n\n        inputs = self._make_scalar_vars([1], torch.float)\n        outputs = self._make_scalar_vars([6], torch.float)\n        self.assertEqual(foo(*inputs), outputs[0])\n\n    def test_python_call_annoytation_failure(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value pyfunc2\"):\n            def pyfunc(a):\n                return a * 3.0\n\n            @torch.jit.script\n            def foo(a):\n                return pyfunc2(a) + pyfunc(a)\n\n            inputs = self._make_scalar_vars([1], torch.float)\n            outputs = self._make_scalar_vars([6], torch.float)\n\n            self.assertEqual(foo(*inputs), outputs[0])\n\n    def test_desugar_module(self):\n        import torch.nn.functional as F\n\n        def fn(x, slope):\n            a = torch.abs(x)\n            b = torch.nn.functional.prelu(x, slope)\n            c = F.prelu(x, slope)\n            return a, b, c\n\n        x = torch.arange(-3., 4)\n        slope = torch.tensor([0.5])\n        self.checkScript(fn, [x, slope], optimize=True)\n\n    def test_script_docstring(self):\n        @torch.jit.script\n        def with_docstring(x):\n            \"\"\"test str\"\"\"\n            y = x\n            \"\"\"y is the same as x\"\"\"\n            return y\n        self.assertEqual(with_docstring.__doc__, 'test str')\n\n    def test_script_method_docstring(self):\n        class A(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def with_docstring(self, x):\n                \"\"\"test str\"\"\"\n                y = x\n                \"\"\"y is the same as x\"\"\"\n                return y\n        a = A()\n        self.assertEqual(a.with_docstring.__doc__, 'test str')\n\n    def test_script_module(self):\n        class M1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M1, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class PModule(nn.Module):\n            def __init__(self):\n                super(PModule, self).__init__()\n                self.a = nn.Parameter(torch.randn(2, 3))\n\n            def forward(self, a):\n                return self.a.mm(a)\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                # test submodule\n                self.sub = M1()\n                self.sub2 = PModule()\n                # test parameters\n                self.weight = nn.Parameter(torch.randn(2, 3))\n                self.bias = nn.Parameter(torch.randn(2))\n                # test defining a method from a string\n                self.define(\"\"\"\n                    def hi(self, a):\n                        return self.weight.mm(a)\n                \"\"\")\n            # test script methods\n\n            @torch.jit.script_method\n            def doit(self, input):\n                # test use of parameter\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit2(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                a = self.doit(input)\n                b = self.doit2(input)\n                c = self.hi(input)\n                d = self.sub2(input)\n                return a + b + self.bias + self.sub(a) + c + d\n        with torch.jit.optimized_execution(False):\n            m2 = M2()\n            input = torch.randn(3, 2)\n            a = m2.weight.mm(input)\n            b = m2.weight.mm(input)\n            c = m2.weight.mm(input)\n            d = m2.sub2.a.mm(input)\n            ref = a + b + m2.bias + m2.sub.weight + a + c + d\n            self.assertEqual(ref, m2.forward(input))\n            m2.weight = nn.Parameter(torch.zeros_like(m2.weight))\n            m2.bias = nn.Parameter(torch.zeros_like(m2.bias))\n            m2.sub.weight = nn.Parameter(torch.zeros_like(m2.sub.weight))\n            m2.sub2.a.data.zero_()\n            self.assertEqual(torch.zeros(2, 2), m2.forward(torch.randn(3, 2)))\n\n    def test_irparser(self):\n        graph_str = \"\"\"graph(%0 : Double(5, 5)):\n          # CHECK: aten::relu\n          %1 : Double(5, 5) = aten::relu(%0)\n          return (%1)\n        \"\"\"\n        FileCheck().run(graph_str, parse_ir(graph_str))\n\n    def test_parse_tensor_constants(self):\n        def foo():\n            return torch.zeros([4, 4])\n\n        foo_s = torch.jit.script(foo)\n        torch._C._jit_pass_constant_propagation(foo_s.graph)\n\n        g = str(foo_s.graph)\n        g_parsed = parse_ir(g, parse_tensor_constants=True)\n        self.assertEqual(str(canonical(g_parsed)), str(canonical(foo_s.graph)))\n        func = torch._C._create_function_from_graph(\"forward\", g_parsed)\n\n        out_parsed = func()\n        out_func = foo()\n        # not checking data, just dtype, size etc\n        out_parsed[:] = 0\n        out_func[:] = 0\n        self.assertEqual(out_func, out_parsed)\n\n        with self.assertRaises(RuntimeError):\n            parse_ir(g, parse_tensor_constants=False)\n\n    def test_parse_nested_names(self):\n        g_str = \"\"\"\n    graph(%x.1 : Tensor):\n        %3 : int = prim::Constant[value=1]()\n        %2 : int = prim::Constant[value=2]()\n        %hi.submod.value.5 : Tensor = aten::add(%x.1, %2, %3)\n        return (%hi.submod.value.5)\n        \"\"\"\n        g = parse_ir(g_str)\n        round_trip_g = parse_ir(str(g))\n        self.assertEqual(canonical(g), canonical(round_trip_g))\n\n        func1 = torch._C._create_function_from_graph(\"forward\", g)\n        func2 = torch._C._create_function_from_graph(\"forward\", round_trip_g)\n        self.assertEqual(func1(torch.ones([2])), func2(torch.ones([2])))\n\n    def test_is_after_use(self):\n        def sorted_input_use(g):\n            uses = list(next(g.inputs()).uses())\n            return sorted(uses, key=functools.cmp_to_key(type(uses[0]).isAfter))\n\n        @torch.jit.script\n        def foo(x):\n            a = x + 1\n            return (x, x, a)\n\n        uses_sorted = sorted_input_use(foo.graph)\n        # sorts last use to the end\n        self.assertFalse(uses_sorted[0].isAfter(uses_sorted[1]))\n        self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n        self.assertEqual(uses_sorted[1].offset, 0)\n\n        @torch.jit.script\n        def foo(x, cond: bool):\n            if cond:\n                return x + 3\n            else:\n                return x - 3\n\n        uses_sorted = sorted_input_use(foo.graph)\n        self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n        self.assertTrue(uses_sorted[1].user.kind() == \"aten::sub\")\n\n        @torch.jit.script\n        def foo(x, cond: bool, cond2: bool):\n            if cond:\n                return x + 3\n            elif cond2 :\n                return x - 3\n\n            return x / 3\n\n        graph1 = foo.graph\n\n        @torch.jit.script\n        def foo(x, cond: bool, cond2: bool):\n            if cond:\n                return x + 3\n            else:\n                if cond2 :\n                    return x - 3\n                return x / 3\n\n        graph2 = foo.graph\n\n        for graph in [graph1, graph2]:\n            uses_sorted = sorted_input_use(graph)\n            self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n            self.assertTrue(uses_sorted[1].user.kind() == \"aten::sub\")\n            self.assertTrue(uses_sorted[2].user.kind() == \"aten::div\")\n\n    def test_canonicalize_control_outputs(self):\n        def test_all_outputs(g):\n            ifs = g.findAllNodes(\"prim::If\")\n            loops = g.findAllNodes(\"prim::Loop\")\n\n            def contained_blocks(node):\n                return len(node.findAllNodes(\"prim::If\")) * 2 + len(node.findAllNodes(\"prim::Loop\"))\n            for node in ifs + loops:\n                outs = list(node.outputs())\n                out_name = [x.debugName() for x in outs]\n                if len(out_name) == 0:\n                    continue\n                fc = FileCheck()\n                # find the last output, then all subsequent uses\n                fc.check(out_name[-1] + \" : \")\n                # skip past node body\n                for i in range(contained_blocks(node)):\n                    fc.check(\"->\")\n                if (node.kind() == \"prim::If\"):\n                    fc.check(\"->\").check(\"->\").check(\"\\n\")\n                else:\n                    fc.check(\"->\").check(\"\\n\")\n                # the canonical order is the same order as the first use\n                # appears in text\n                for name in out_name:\n                    fc.check(name)\n                fc.run(g)\n\n        @torch.jit.script\n        def test(x):\n            # type: (bool) -> Tuple[int, int]\n            b = 2\n            a = 1\n            if x:\n                a = 1\n                b = 2\n                x = False\n            if x:\n                b = a\n            else:\n                a = b\n\n            return a, b\n        test_all_outputs(test.graph)\n\n        @torch.jit.script\n        def test2(x):\n            # type: (bool) -> Tuple[int, int]\n            b = 2\n            a = 1\n            if x:\n                a = 1\n                b = 2\n                x = False\n            if x:\n                print(a)\n            else:\n                if x:\n                    print(b)\n\n            return a, b\n        test_all_outputs(test2.graph)\n\n        @torch.jit.script\n        def test_loop(x, iter):\n            # type: (bool, int) -> (None)\n            a = 1\n            b = 2\n            c = 3\n            for i in range(iter):\n                a = 4\n                b = 5\n                c = 6\n                x = True\n            print(c)\n            if x:\n                print(a, b)\n        test_all_outputs(test_loop.graph)\n\n        @torch.jit.script\n        def loop_unused(iter):\n            # type: (int) -> (None)\n            a = 1\n            b = 2\n            c = 3\n            for i in range(iter):\n                c = c + 1\n                b = b + 1\n                a = a + 1\n                print(a, b)\n            print(c)\n\n        # c is used, then unused should be ordered by alphabetical\n        FileCheck().check(r\"%c : int, %a : int, %b : int\").run(loop_unused.graph)\n\n    def test_filecheck(self):\n        def test_check():\n            file = \"232\"\n            FileCheck().check(\"2\").check(\"3\").check(\"2\").run(file)\n            FileCheck().check(\"232\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().check(\"22\").run(file)\n            with self.assertRaisesRegex(RuntimeError, \"CHECK: 3\"):\n                FileCheck().check(\"3\").check(\"3\").run(file)\n\n        test_check()\n\n        def test_check_count():\n            file = \"22222\"\n            FileCheck().check_count(\"2\", 5).run(file)\n            FileCheck().check_count(\"22\", 2).run(file)\n            FileCheck().check_count(\"222\", 1).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find'):\n                FileCheck().check_count(\"2\", 4, exactly=True).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().check_count(\"22\", 3).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"CHECK-COUNT-6: 2\"):\n                FileCheck().check_count(\"2\", 6).run(file)\n\n        test_check_count()\n\n        def test_check_same():\n            file = \"22\\n33\"\n            FileCheck().check_same(\"22\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().check_same(\"33\").run(file)\n\n            file = \"22  1  3\"\n\n            FileCheck().check(\"2\").check_same(\"3\").run(file)\n            FileCheck().check_count(\"2\", 2).check_same(\"3\").run(file)\n\n        test_check_same()\n\n        def test_check_next():\n            file = \"\\n1\\n2\\n3\"\n            FileCheck().check(\"1\").check_next(\"2\").check_next(\"3\").run(file)\n            FileCheck().check_next(\"1\").check_next(\"2\").check_next(\"3\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to find\"):\n                FileCheck().check(\"1\").check_next(\"2\").run(\"12\")\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().check(\"1\").check_next(\"2\").run(\"1\\n\\n2\")\n\n        test_check_next()\n\n        def test_check_dag():\n            fc = FileCheck().check_dag(\"1\").check_dag(\"2\").check_not(\"2\")\n            fc.run(\"12\")\n            fc.run(\"21\")\n\n            fc = FileCheck()\n            fc.check_not(\"3\").check_dag(\"1\").check_dag(\"2\").check_not(\"3\")\n            fc.run(\"1 3 2\")\n            fc.run(\"2 3 1\")\n\n            fc = FileCheck().check_dag(\"1\").check_dag(\"2\").check(\"3\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"3\" but did not find it'):\n                fc.run(\"1 3 2\")\n\n        test_check_dag()\n\n        def test_check_not():\n            FileCheck().check_not(\"2\").check(\"1\").run(\"12\")\n            FileCheck().check(\"2\").check_not(\"2\").run(\"12\")\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"2\"'):\n                FileCheck().check_not(\"2\").check(\"1\").run(\"21\")\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"1\"'):\n                FileCheck().check(\"2\").check_not(\"1\").run(\"21\")\n\n            # checks with distinct range matchings\n            fb = FileCheck().check_count(\"2\", 2).check_count(\"2\", 2).check_not(\"2\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"2\"'):\n                fb.run(\"22 2 22\")\n\n            fb = FileCheck().check_count(\"2\", 2).check_not(\"1\").check_count(\"2\", 2)\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"1\"'):\n                fb.run(\"22 1 22\")\n\n    def _dtype_to_jit_name(self, dtype):\n        if(dtype == torch.float32):\n            return \"Float\"\n        if(dtype == torch.float64):\n            return \"Double\"\n        if(dtype == torch.int64):\n            return \"Long\"\n        if(dtype == torch.int32):\n            return \"Int\"\n        if(dtype == torch.bool):\n            return \"Bool\"\n        raise RuntimeError('dtype not handled')\n\n    def _dtype_to_expect(self, dtype, dim=0):\n        param = ', '.join(['*'] * dim + ['device=cpu'])\n        param = '(' + param + ')'\n        jit_type = self._dtype_to_jit_name(dtype)\n        if dim >= 0:\n            return jit_type + param\n        # special case representing wrapped number\n        else:\n            return jit_type.lower()\n\n\n    def _test_dtype_op_shape(self, ops, args, input_dims=1):\n        if input_dims < 1:\n            raise RuntimeError(\"input dims must be at least 1\")\n        dtypes = [torch.float32, torch.float64, torch.int64, torch.int32]\n        str_args = ', '.join([str(arg) for arg in args]) + (', ' if len(args) else '')\n        tensor_data = ('[' * input_dims) + '1, 2, 3' + (input_dims * ']')\n        template = dedent('''\n        def func():\n            return {return_line}\n        ''')\n\n        for op in ops:\n            for dtype in (dtypes + [None]):\n                for tensor_type in dtypes:\n                    # a couple of ops aren't implemented for non-floating types\n                    if(not tensor_type.is_floating_point or (dtype is not None and not dtype.is_floating_point)):\n                        if op in ['mean', 'softmax', 'log_softmax']:\n                            continue\n                    return_line = \"torch.tensor({}, dtype={}).{}({}dtype={})\".format(tensor_data, tensor_type, op, str_args, dtype)\n                    # uncomment for debugging a failed test:\n                    # print(\"testing {}\".format(return_line))\n                    code = template.format(return_line=return_line)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    cu = torch.jit.CompilationUnit(code)\n                    graph = cu.func.graph\n                    torch._C._jit_pass_complete_shape_analysis(graph, (), False)\n                    input_array = [1, 2, 3]\n                    for _ in range(1, input_dims):\n                        input_array = [input_array]\n                    t = torch.tensor(input_array, dtype=tensor_type)\n                    attr = getattr(t, op)\n                    kwargs = {'dtype': dtype}\n                    result = attr(*args, **kwargs)\n                    expect = self._dtype_to_expect(result.dtype, result.dim())\n                    FileCheck().check(\"aten::tensor\").check(expect).run(graph)\n\n    def test_dtype_op_shape(self):\n        ops = ['prod']\n        self._test_dtype_op_shape(ops, args=[])\n        self._test_dtype_op_shape(ops, args=[0, False])\n        self._test_dtype_op_shape(ops, args=[0, False])\n        self._test_dtype_op_shape(ops, args=[0, True])\n\n    def test_dtype_op_shape2(self):\n        ops = ['cumprod', 'cumsum', 'softmax', 'log_softmax']\n        self._test_dtype_op_shape(ops, args=[0])\n\n        self._test_dtype_op_shape(ops, args=[1], input_dims=4)\n\n\n    def _test_binary_op_shape(self, ops, input_dims=1):\n\n        dtypes = [torch.float32, torch.float64, torch.int64, torch.int32, torch.bool]\n\n        if input_dims == 0:\n            shape = '1'\n        else:\n            shape = '[' + ('1,' * 4) + ']'\n            for _ in range(1, input_dims):\n                shape = '[' + \",\".join([shape] * 4) + ']'\n\n        template = dedent('''\n        def func():\n            arg1 = {}\n            arg2 = {}\n            return torch.{}(arg1, arg2)\n        ''')\n\n        args = []\n        for dtype in dtypes:\n            args = args + [\"torch.tensor({}, dtype={})\".format(shape, dtype)]\n        args = args + [1, 1.5]\n\n        def isBool(arg):\n            return type(arg) == bool or (type(arg) == str and \"torch.bool\" in arg)\n\n        for op in ops:\n            for first_arg in args:\n                for second_arg in args:\n                    # subtract not supported for bool\n                    if (op == 'sub' or op == 'div') and (isBool(first_arg) or isBool(second_arg)):\n                        continue\n                    # div is not implemented correctly for mixed-type or int params\n                    if (op == 'div' and (type(first_arg) != type(second_arg) or\n                       isinstance(first_arg, int) or\n                       (isinstance(first_arg, str) and 'int' in first_arg))):\n                        continue\n                    return_line = \"torch.{}({}, {})\".format(op, first_arg, second_arg)\n                    # uncomment for debugging a failed test:\n                    # print(\"testing {}\".format(return_line))\n                    code = template.format(first_arg, second_arg, op)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    non_jit_result = scope['func']()\n\n                    cu = torch.jit.CompilationUnit(code)\n                    graph = cu.func.graph\n                    torch._C._jit_pass_complete_shape_analysis(graph, (), False)\n                    # use dim=-1 to represent a python/jit scalar.\n                    dim = -1 if type(first_arg) != str and type(second_arg) != str else non_jit_result.dim()\n                    dtype = non_jit_result.dtype\n                    # jit only supports int/float scalars.\n                    if dim < 0:\n                        if dtype == torch.int64:\n                            dtype = torch.int32\n                        if dtype == torch.float64:\n                            dtype = torch.float32\n                    expect = self._dtype_to_expect(dtype, dim)\n                    jit_output = next(graph.outputs())\n\n                    check = FileCheck()\n                    check.check(expect).run(str(jit_output))\n\n    def test_binary_op_shape(self):\n        self._test_binary_op_shape(['mul', 'div', 'add', 'sub'], 0)\n        self._test_binary_op_shape(['mul', 'div', 'add', 'sub'], 3)\n\n    def test_no_dtype_shape(self):\n\n        @torch.jit.script\n        def foo(x):\n            scalar_number = x.item()\n            return x.add(scalar_number)\n\n        @torch.jit.script\n        def foo2(x):\n            scalar_number = x.item()\n            return torch.tensor(1).add(scalar_number)\n\n        t = torch.tensor(5)\n        g = foo.graph_for(t)\n        type = next(g.outputs())\n        self.assertTrue(type.type() == torch._C.TensorType.get())\n        g2 = foo2.graph_for(t)\n        type = next(g.outputs())\n        self.assertTrue(type.type() == torch._C.TensorType.get())\n\n\n    def test_filecheck_parse(self):\n        def test_check():\n            file = \"\"\"\n                # CHECK: 2\n                # CHECK: 3\n                # CHECK: 2\n                232\n                \"\"\"\n            FileCheck().run(checks_file=file, test_file=file)\n            file = \"\"\"\n                # CHECK: 232\n                232\n                \"\"\"\n            FileCheck().run(file, \"232\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"232\"'):\n                FileCheck().run(file, \"22\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().run(\"# CHECK: 22\", \"23\")\n        test_check()\n\n        def test_check_count():\n            file = \"22222\"\n            FileCheck().run(\"# CHECK-COUNT-5: 2\", file)\n            FileCheck().run(\"# CHECK-COUNT-EXACTLY-5: 2\", file)\n            FileCheck().run(\"# CHECK-COUNT-2: 22\", file)\n            FileCheck().run(\"# CHECK-COUNT-1: 222\", file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find'):\n                FileCheck().run(\"# CHECK-COUNT-EXACTLY-2: 2\", file)\n        test_check_count()\n\n        def test_check_same():\n            file = \"22\\n33\"\n            FileCheck().run(\"# CHECK-SAME: 22\", file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().run(\"# CHECK-SAME: 33\", file)\n\n            file = \"22  1  3\"\n\n            FileCheck().run(\"# CHECK: 2\\n # CHECK-SAME: 3\", file)\n            FileCheck().run(\"# CHECK-COUNT-2: 2\\n # CHECK-SAME: 3\", file)\n        test_check_same()\n\n        def test_bad_input():\n            with self.assertRaisesRegex(RuntimeError, \"Check for bad input\"):\n                FileCheck().run(\"\", \"1\")\n\n            with self.assertRaisesRegex(RuntimeError, \"Could not parse check\"):\n                FileCheck().run(\"# CHECK1\", \"\")\n\n        test_bad_input()\n\n    def test_script_module_call_noscript(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.value = 1\n\n            @torch.jit.ignore\n            def foo(self):\n                return torch.ones(2, 2) + self.value\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return input + self.foo()\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            input = torch.randn(2, 2)\n            o = m(input)\n            self.assertEqual(o, input + torch.ones(2, 2) + 1)\n            # check that we can change python attributes\n            # and that those changes are picked up in script methods\n            m.value = 2\n            o = m(input)\n            self.assertEqual(o, input + torch.ones(2, 2) + 2)\n\n    def test_script_module_nochange_submodule(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.sub = nn.Linear(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.sub(input)\n        with torch.jit.optimized_execution(False):\n            m = M()\n            input = torch.randn(1, 5, 5)\n            o = m(input)\n            self.assertEqual(o, m.sub(input))\n            with self.assertRaisesRegex(RuntimeError, \"Cannot re-assign\"):\n                m.sub = nn.Linear(5, 5)\n\n    def test_module_apis(self):\n        class Sub(torch.nn.Module):\n            def __init__(self):\n                super(Sub, self).__init__()\n\n            def forward(self, thing):\n                return thing - 2\n\n        class Double(torch.nn.Module):\n            def __init__(self):\n                super(Double, self).__init__()\n\n            def forward(self, thing):\n                return thing * 2\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.mod = (Sub())\n                self.mod2 = (Sub())\n                self.mod3 = nn.Sequential(nn.Sequential(Sub()))\n                self.mod4 = nn.Sequential(Sub(), Double())\n\n            @torch.jit.export\n            def method(self, x, x1, y, y1):\n                mod_names = \"\"\n                for name, mod in self.named_modules():\n                    mod_names = mod_names + \" \" + name\n                    x = mod(x)\n\n                children_names = \"\"\n                for name, mod in self.named_children():\n                    children_names = children_names + \" \" + name\n                    x1 = mod(x1)\n\n                for mod in self.modules():\n                    y = mod(y)\n\n                for mod in self.children():\n                    y1 = mod(y1)\n\n                return mod_names, children_names, x, x1, y, y1\n\n            def forward(self, x):\n                return x + 2\n\n        mod = torch.jit.script(MyMod())\n        inps = tuple([torch.tensor(i) for i in range(1, 5)])\n        self.assertEqual(mod.method(*inps), MyMod().method(*inps))\n\n    def test_script_module_const(self):\n        class M(torch.jit.ScriptModule):\n\n            __constants__ = ['b', 'i', 'c', 's']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.b = False\n                self.i = 1\n                self.c = 3.5\n                self.s = [\"hello\"]\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.b, self.i, self.c\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            o0, o1, o2 = m()\n        self.assertEqual(o0, 0)\n        self.assertEqual(o1, 1)\n        self.assertEqual(o2, 3.5)\n\n    def test_script_module_fail_exist(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.whatisgoingon\n        with self.assertRaisesRegex(RuntimeError, \"Module 'M' has no attribute\"):\n            M()\n\n    @unittest.skip(\"[module dedupe] currently NoneType refinement on optional attributes doesn't work.\")\n    def test_script_module_none_exist_fail(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, my_optional):\n                super(M, self).__init__()\n                self.my_optional = my_optional\n\n            @torch.jit.script_method\n            def forward(self, x):\n                if self.my_optional is not None:\n                    return torch.neg(x) + self.my_optional\n                return torch.neg(x)\n        with self.assertRaisesRegex(RuntimeError, \"has no attribute 'my_optional'\"):\n            x = torch.rand(3, 4)\n            fb = M(None)\n            fb(x)\n\n    def test_script_module_invalid_consts(self):\n        class Foo(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.invalid = [nn.Linear(3, 4)]\n\n        with self.assertRaisesRegex(\n                TypeError,\n                \"Linear' object in attribute 'Foo.invalid' is not a valid constant\"):\n            Foo()\n\n        class Foo2(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo2, self).__init__()\n                self.invalid = type(1)\n\n        with self.assertRaisesRegex(TypeError, \"not a valid constant\"):\n            Foo2()\n\n        class Foo3(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo3, self).__init__()\n                self.invalid = (3, 4, {})\n\n        with self.assertRaisesRegex(TypeError, \"not a valid constant\"):\n            Foo3()\n\n        class Foo4(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo4, self).__init__()\n                self.invalid = np.int64(5)\n\n        # verify that we capture human understandable class name\n        with self.assertRaisesRegex(TypeError, \"numpy.int64\"):\n            Foo4()\n\n    def test_script_module_param_buffer_mutation(self):\n        # TODO: add param mutation test case after JIT support it\n        class ModuleBufferMutate(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ModuleBufferMutate, self).__init__()\n                self.register_buffer('running_var', torch.tensor(0, dtype=torch.long))\n\n            @torch.jit.script_method\n            def forward(self):\n                if self.training:\n                    self.running_var += 1\n                return self.running_var\n\n        with torch.jit.optimized_execution(False):\n            m = ModuleBufferMutate()\n            self.assertEqual(m(), 1)\n            m.eval()\n            self.assertEqual(m(), 1)\n\n    def test_script_module_for(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['b']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.b = [1, 2, 3, 4]\n\n            @torch.jit.script_method\n            def forward(self):\n                sum = 0\n                for i in self.b:\n                    sum += i\n                return sum\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            self.assertEqual(m(), 10)\n\n    def test_override_magic(self):\n        class OverrideMagic(nn.Module):\n            def __init__(self):\n                super(OverrideMagic, self).__init__()\n\n            @torch.jit.export\n            def __len__(self):\n                return 10\n\n        mod = OverrideMagic()\n        self.assertEqual(len(mod), len(torch.jit.script(mod)))\n\n        class OverrideMagicSeq(nn.Sequential):\n            def __init__(self):\n                super(OverrideMagicSeq, self).__init__()\n\n            @torch.jit.export\n            def __len__(self):\n                return 10\n\n        mod = OverrideMagicSeq()\n        self.assertEqual(len(mod), len(torch.jit.script(mod)))\n        self.assertTrue(torch.jit.script(mod))\n\n    def test_script_module_for2(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([Sub() for i in range(10)])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    v = m(v)\n                return v\n\n        with torch.jit.optimized_execution(False):\n            i = torch.empty(2)\n            m = M()\n            o = m(i)\n            v = i\n            for sub in m.mods:\n                v = sub(v)\n            self.assertEqual(o, v)\n            with self.assertRaisesRegex(Exception, \"object is not iterable\"):\n                print(list(m))\n\n    def test_attr_qscheme_script(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.qscheme = torch.per_tensor_affine\n\n            def forward(self):\n                if self.qscheme == torch.per_tensor_symmetric:\n                    return 3\n                else:\n                    return 4\n\n        f = Foo()\n        scripted = torch.jit.script(f)\n        self.assertEqual(f(), scripted())\n\n    def test_script_module_const_submodule_fail(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = [Sub() for _ in range(10)]\n\n            @torch.jit.script_method\n            def forward(self):\n                for _ in self.mods:\n                    print(1)\n                return 4\n\n        with self.assertRaisesRegex(RuntimeError, \"has no attribute 'mods'\"):\n            M()\n\n    class DerivedStateModule(torch.jit.ScriptModule):\n        def __init__(self):\n            super(TestScript.DerivedStateModule, self).__init__()\n            self.param = torch.nn.Parameter(torch.ones(3, 4, dtype=torch.float))\n            self.register_buffer('derived', torch.neg(self.param).detach().clone())\n\n            # This is a flag so we can test that the pack method was called\n            self.register_buffer('pack_called', torch.zeros(1, dtype=torch.long))\n            # This is a flag so we can test that the unpack method was called\n            self.register_buffer('unpack_called', torch.zeros(1, dtype=torch.long))\n\n        @torch.jit.script_method\n        def _pack(self):\n            self.pack_called.set_(torch.ones(1, dtype=torch.long))\n            self.derived.set_(torch.rand(1, dtype=torch.float).detach())\n\n        @torch.jit.script_method\n        def _unpack(self):\n            self.unpack_called.set_(torch.ones(1, dtype=torch.long))\n            self.derived.set_(torch.neg(self.param).detach())\n\n        @torch.jit.script_method\n        def forward(self, x):\n            return x + self.derived\n\n    def test_pack_unpack_state(self):\n        sm = TestScript.DerivedStateModule()\n        x = torch.rand(3, 4, dtype=torch.float)\n        torch.testing.assert_close(sm(x), x + torch.neg(torch.ones(3, 4, dtype=torch.float)))\n\n        # Test save path\n        self.assertFalse(sm.pack_called.item())\n        self.assertFalse(sm.unpack_called.item())\n        imported = self.getExportImportCopyWithPacking(sm)\n        # ensure pack was called before serialization\n        self.assertTrue(sm.pack_called.item())\n        # ensure unpack was called after serialization so as to leave the module in an initialized state\n        self.assertTrue(sm.unpack_called.item())\n\n        torch.testing.assert_close(sm.derived, torch.neg(sm.param))\n\n        # Test load paths\n        self.assertTrue(imported.unpack_called.item())\n        torch.testing.assert_close(imported(x), x + torch.neg(torch.ones(3, 4, dtype=torch.float)))\n\n    @unittest.skipIf(not TEST_MKL, \"PyTorch is built without MKL support\")\n    @unittest.skipIf(True, \"Skipping while landing PR stack\")\n    def test_torch_functional(self):\n        def stft(input, n_fft):\n            # type: (Tensor, int) -> Tensor\n            return torch.stft(input, n_fft, return_complex=True)\n\n        inps = (torch.randn(10), 7)\n        self.assertEqual(stft(*inps), torch.jit.script(stft)(*inps))\n\n        def istft(input, n_fft):\n            # type: (Tensor, int) -> Tensor\n            return torch.istft(input, n_fft)\n\n        inps2 = (stft(*inps), inps[1])\n        self.assertEqual(istft(*inps2), torch.jit.script(istft)(*inps2))\n\n        def lu_unpack(x):\n            A_LU, pivots = torch.linalg.lu_factor(x)\n            return torch.lu_unpack(A_LU, pivots)\n\n        for shape in ((3, 3), (5, 3, 3), (7, 3, 5, 5), (7, 5, 3, 3, 3)):\n            a = torch.randn(*shape)\n            self.checkScript(lu_unpack, (a,))\n\n        def cdist_fn():\n            a = torch.tensor([[0.9041, 0.0196], [-0.3108, -2.4423], [-0.4821, 1.059]])\n            b = torch.tensor([[-2.1763, -0.4713], [-0.6986, 1.3702]])\n            return torch.cdist(a, b, compute_mode=\"use_mm_for_euclid_dist\")\n\n        self.checkScript(cdist_fn, ())\n\n        def norm():\n            c = torch.tensor([[1, 2, 3], [-1, 1, 4]], dtype=torch.float)\n            return torch.norm(c, p=\"fro\"), torch.norm(c, p=\"nuc\"), torch.norm(c), torch.norm(c, p=.5)\n\n        self.checkScript(norm, ())\n\n        def torch_unique(dim: Optional[int]):\n            ten = torch.unique(torch.tensor([[1, 3], [2, 3]], dtype=torch.long))\n            a = torch.unique(ten, dim=dim)\n            b = torch.unique(ten, return_counts=True, dim=dim)\n            c = torch.unique(ten, return_inverse=True, dim=dim)\n            d = torch.unique(ten, return_counts=True, return_inverse=True, dim=dim)\n            return a, b, c, d\n\n        self.checkScript(torch_unique, (None,))\n        self.checkScript(torch_unique, (0,))\n\n        def torch_unique_consecutive(dim: Optional[int]):\n            ten = torch.unique(torch.tensor([[1, 3], [3, 2], [3, 2], [2, 3]], dtype=torch.long))\n            a = torch.unique_consecutive(ten, dim=dim)\n            b = torch.unique_consecutive(ten, return_counts=True, dim=dim)\n            c = torch.unique_consecutive(ten, return_inverse=True, dim=dim)\n            d = torch.unique_consecutive(ten, return_counts=True, return_inverse=True, dim=dim)\n            return a, b, c, d\n\n        self.checkScript(torch_unique_consecutive, (None,))\n        self.checkScript(torch_unique_consecutive, (0,))\n\n    def test_torch_functional_tensordot_int(self):\n        def tensordot_dims_int(a: torch.Tensor, b: torch.Tensor, dims: int):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(120.).reshape(2, 3, 4, 5)\n        b = torch.arange(840.).reshape(4, 5, 6, 7)\n        dims = 2\n        self.checkScript(tensordot_dims_int, (a, b, dims))\n\n    def test_torch_functional_tensordot_tensor(self):\n        def tensordot_dims_tensor(a: torch.Tensor, b: torch.Tensor, dims: torch.Tensor):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(120.).reshape(2, 3, 4, 5)\n        b = torch.arange(840.).reshape(4, 5, 6, 7)\n        dims = torch.tensor([2])\n        self.checkScript(tensordot_dims_tensor, (a, b, dims))\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = torch.tensor([[1, 0], [0, 1]], dtype=torch.long)\n        self.checkScript(tensordot_dims_tensor, (a, b, dims))\n\n    def test_torch_functional_tensordot_list(self):\n        def tensordot_dims_list(a: torch.Tensor, b: torch.Tensor, dims: List[List[int]]):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = [[1, 0], [0, 1]]\n        self.checkScript(tensordot_dims_list, (a, b, dims))\n\n    def test_torch_functional_tensordot_tuple(self):\n        def tensordot_dims_tuple(a: torch.Tensor, b: torch.Tensor, dims: Tuple[List[int], List[int]]):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = ([1, 0], [0, 1])\n        self.checkScript(tensordot_dims_tuple, (a, b, dims))\n\n    def test_missing_getstate(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.x = 1\n\n            def forward(self, x):\n                return x * self.x\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.x = state[0]\n                self.training = state[1]\n\n        with self.assertRaisesRegex(RuntimeError, \"getstate\"):\n            scripted = torch.jit.script(Foo())\n\n    def test_inlining_cleanup(self):\n        def foo(x):\n            return F.linear(x, x)\n\n        @torch.jit.script\n        def fee(x):\n            return foo(x)\n\n        # inlining optimizations should have cleaned up linear if statement\n        self.run_pass(\"inline\", fee.graph)\n        FileCheck().check_not(\"prim::If\").run(fee.graph)\n\n    def test_pack_unpack_nested(self):\n        class SubSubMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SubSubMod, self).__init__()\n                self.register_buffer('buf', torch.ones(3, 4) * 3)\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double) * 3)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.buf\n\n        class SubMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SubMod, self).__init__()\n                self.register_buffer('buf', torch.ones(3, 4) * 2)\n                self.ssm = SubSubMod()\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double) * 2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.ssm(x + self.buf)\n\n        class Mod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.submod = SubMod()\n                self.register_buffer('buf', torch.ones(3, 4) * 1)\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.submod(x + self.buf)\n\n        m = Mod()\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.ones(3, 4) * 6)\n        m.apply(lambda s: s._pack())\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.zeros(3, 4))\n        m.apply(lambda s: s._unpack())\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.ones(3, 4) * 6)\n\n    def test_torch_any(self):\n        def fn(x):\n            return torch.any(x)\n\n        def fn1(x, dim: int):\n            return torch.any(x, dim)\n\n        self.checkScript(fn, (torch.randn(3, 4), ))\n        self.checkScript(fn, (torch.empty(3), ))\n        self.checkScript(fn, (torch.empty(1), ))\n        self.checkScript(fn, (torch.ones(3, 4),))\n        self.checkScript(fn, (torch.zeros(5, 7, 1),))\n        self.checkScript(fn1, (torch.empty(3, 4), -2))\n        self.checkScript(fn1, (torch.randn(3, 8), 1))\n        self.checkScript(fn1, (torch.zeros(3, 6, 9), -3))\n        self.checkScript(fn1, (torch.empty(5), 0))\n\n    def test_any(self):\n        def fn(x: List[int]):\n            return any(x)\n\n        def fn1(x: List[float]):\n            return any(x)\n\n        def fn2(x: List[bool]):\n            return any(x)\n\n        def fn3(x: List[str]):\n            return any(x)\n\n        self.checkScript(fn, ([0, 0, 0, 0], ))\n        self.checkScript(fn, ([0, 3, 0], ))\n        self.checkScript(fn, ([], ))\n        self.checkScript(fn1, ([1.0, 2.0, 3.0], ))\n        self.checkScript(fn1, ([0.0, 0.0, 0.0], ))\n        self.checkScript(fn1, ([0, 0, 0], ))\n        self.checkScript(fn1, ([], ))\n        self.checkScript(fn2, ([True, False, False], ))\n        self.checkScript(fn2, ([False, False, False], ))\n        self.checkScript(fn2, ([True, True, True, True], ))\n        self.checkScript(fn2, ([], ))\n        self.checkScript(fn3, ([\"\", \"\", \"\"], ))\n        self.checkScript(fn3, ([\"\", \"\", \"\", \"-1\"], ))\n        self.checkScript(fn3, ([], ))\n\n    def test_script_module_not_tuple(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['mods']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = 1\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    print(m)\n                return v\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not iterable\"):\n            M()\n\n    def test_attr_module_constants(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self, mod_list):\n                super(M2, self).__init__()\n                self.mods = mod_list\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.mods.forward(x)\n\n        with torch.jit.optimized_execution(False):\n            m = M2(nn.Sequential(nn.ReLU()))\n            self.assertExportImportModule(m, (torch.randn(2, 2),))\n\n    def test_script_sequential_for(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.Sequential(Sub(), Sub(), Sub())\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    v = m(v)\n                return v\n\n            @torch.jit.script_method\n            def forward2(self, v):\n                return self.mods(v)\n\n        with torch.jit.optimized_execution(False):\n            i = torch.empty(2)\n            m = M()\n            o = m(i)\n            v = i\n            for sub in m.mods._modules.values():\n                v = sub(v)\n            self.assertEqual(o, v)\n\n            o2 = m.forward2(i)\n            self.assertEqual(o2, v)\n\n    def test_script_sequential_sliced_iteration(self):\n        class seq_mod(nn.Module):\n            def __init__(self):\n                super(seq_mod, self).__init__()\n                self.layers = [nn.ReLU(), nn.ReLU(), nn.ReLU()]\n                self.layers = nn.Sequential(*self.layers)\n\n            def forward(self, input):\n                x = self.layers[0].forward(input)\n                for layer in self.layers[1:3]:\n                    x = layer.forward(x)\n                for layer in self.layers[2:]:\n                    x = layer.forward(x)\n                return x\n\n        seq = seq_mod()\n        self.checkModule(seq, [torch.tensor([-2, 1, -1, 2])])\n\n    def test_script_sequential_orderdict(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.Sequential(OrderedDict([\n                    (\"conv\", nn.Conv2d(1, 20, 5)),\n                    (\"relu\", nn.ReLU())\n                ]))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.mods(input)\n\n        m = M()\n        self.assertTrue('mods.conv.weight' in m.state_dict().keys())\n\n    def test_script_sequential_multi_output_fail(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class ReturnMulti(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ReturnMulti, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x, x, x\n\n        class HaveSequential(torch.jit.ScriptModule):\n            def __init__(self):\n                super(HaveSequential, self).__init__()\n                self.someseq = nn.Sequential(\n                    Sub(),\n                    ReturnMulti(),\n                    Sub()\n                )\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.someseq(x)\n\n        with self.assertRaisesRegex(RuntimeError, \"(Tensor, Tensor, Tensor)\"):\n            with torch.jit.optimized_execution(False):\n                hs = HaveSequential()\n                i = torch.empty(2)\n                hs(i)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_script_sequential_in_mod_list(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([Sub(), nn.Sequential(Sub(), nn.Sequential(Sub(), Sub()), Sub())])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for mod in self.mods:\n                    v = mod(v)\n                return v\n\n        m = M()\n        graph = str(m.graph)\n        self.assertTrue(graph.count(\"prim::CallMethod\") == 2)\n        self.assertTrue(\"python\" not in graph)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_script_nested_mod_list(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([nn.ModuleList([Sub()]), nn.Sequential(Sub()), nn.ModuleList([Sub(), Sub()])])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for mod in self.mods:\n                    for m in mod:\n                        v = m(v)\n                return v\n\n        m = M()\n        graph = str(m.graph)\n        self.assertTrue(graph.count(\"prim::CallMethod\") == 4)\n        self.assertTrue(\"python\" not in graph)\n\n    def test_constant_as_attr(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['dim']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.dim = 1\n\n            @torch.jit.script_method\n            def forward(self, v):\n                return torch.cat([v, v, v], dim=self.dim)\n        v = torch.zeros(1, 1)\n        with torch.jit.optimized_execution(False):\n            self.assertEqual(torch.cat([v, v, v], dim=1), M()(v))\n\n    class StarTestSumStarred(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestSumStarred, self).__init__()\n\n        def forward(self, *inputs):\n            output = inputs[0]\n            for i in range(1, len(inputs)):\n                output += inputs[i]\n            return output\n\n    class StarTestReturnThree(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestReturnThree, self).__init__()\n\n        def forward(self, rep):\n            return rep, rep, rep\n\n    def test_script_star_expr(self):\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.m = torch.jit.trace(TestScript.StarTestSumStarred(),\n                                         (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)))\n                self.g = torch.jit.trace(TestScript.StarTestReturnThree(), torch.ones(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, rep):\n                tup = self.g(rep)\n                return self.m(*tup)\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    def test_script_star_expr_string(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.m = torch.jit.trace(TestScript.StarTestSumStarred(),\n                                         (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)))\n                self.g = torch.jit.trace(TestScript.StarTestReturnThree(), torch.ones(4, 3))\n\n                self.define('''\n            def forward(self, rep):\n                tup = self.g(rep)\n                return self.m(*tup)\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    class StarTestSumAndReturnThree(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestSumAndReturnThree, self).__init__()\n\n        def forward(self, *inputs):\n            output = inputs[0]\n            for i in range(1, len(inputs)):\n                output += inputs[i]\n            return output, output, output\n\n    def test_script_star_assign(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(TestScript.StarTestSumAndReturnThree(), torch.ones(4, 3))\n                self.define('''\n            def forward(self, rep):\n                head, *tail = self.g(rep)\n                return head\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    def test_script_module_star_assign2(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(\n                    TestScript.StarTestSumAndReturnThree(),\n                    (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)),\n                    _force_outplace=True)\n                self.define('''\n            def forward(self, rep):\n                *head, tail = self.g(rep, rep, rep)\n                return tail\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.ones(4, 3)), 3 * torch.ones(4, 3))\n\n    def test_script_module_star_assign2_inplace(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(\n                    TestScript.StarTestSumAndReturnThree(),\n                    (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)),\n                    _force_outplace=False)\n                self.define('''\n            def forward(self, rep):\n                *head, tail = self.g(rep, rep, rep)\n                return tail\n                ''')\n\n        m = M2()\n        # since forward() makes three aliases to the input `rep` before passing\n        # it to StarTestSumAndReturnThree(), in-place behavior will be different\n        # than the above out of place.\n        self.assertEqual(m(torch.ones(4, 3)), 4 * torch.ones(4, 3))\n\n    def test_script_module_star_assign_fail_pythonop(self):\n\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            class M2(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M2, self).__init__()\n\n                    @torch.jit.ignore\n                    def myfunc():\n                        return torch.zeros(1, 2, 3), torch.zeros(1, 2, 3)\n\n                    self.define('''\n                def forward(self, rep):\n                    a, *b = myfunc()\n                    return a\n                    ''')\n\n            m = M2()\n            m(torch.zeros(4, 3))\n\n    def test_script_module_star_assign_fail_builtin(self):\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            class M2(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M2, self).__init__()\n\n                    self.define('''\n                def forward(self, rep):\n                    a, *b = torch.neg(rep)\n                    return a\n                    ''')\n\n            m = M2()\n            m(torch.zeros(4, 3))\n\n    def test_script_pack_padded_sequence(self):\n        from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence\n\n        def pack_padded_pad_packed_script(x, seq_lens):\n            x = pack_padded_sequence(x, seq_lens)\n            x, lengths = pad_packed_sequence(x)\n            return x, lengths\n\n        T, B, C = 3, 5, 7\n        x = torch.ones((T, B, C))\n        seq_lens = torch.tensor([3, 3, 2, 2, 1])\n        # set padding value so we can test equivalence\n        for b in range(B):\n            if seq_lens[b] < T:\n                x[seq_lens[b]:, b, :] = 0\n\n        eager_seq, eager_lengths = pack_padded_pad_packed_script(x, seq_lens)\n        with torch._jit_internal._disable_emit_hooks():\n            scripted_pack_padded_seq = torch.jit.script(pack_padded_pad_packed_script)\n        script_seq, script_lengths = scripted_pack_padded_seq(x, seq_lens)\n        self.assertEqual(eager_seq, script_seq)\n        self.assertEqual(eager_lengths, script_lengths)\n\n        class ExperimentalLSTM(torch.nn.Module):\n            def __init__(self, input_dim, hidden_dim):\n                super().__init__()\n\n            def forward(self, input):\n                # type: (Tensor)\n                packed = pack_padded_sequence(\n                    input=input, lengths=torch.tensor([1, 2]), enforce_sorted=False\n                )\n                output, lengths = pad_packed_sequence(\n                    sequence=packed, total_length=2\n                )\n                # lengths is flipped, so is output\n                return output[0]\n\n        lstm = ExperimentalLSTM(input_dim=2, hidden_dim=2)\n\n        with torch._jit_internal._disable_emit_hooks():\n            self.checkModule(lstm, [torch.ones(2, 2)])\n\n    def test_script_pad_sequence_pack_sequence(self):\n        from torch.nn.utils.rnn import pad_sequence, pack_sequence, pad_packed_sequence\n\n        def pad_sequence_func(tensor_list, batch_first=False, padding_value=0.0):\n            # type: (List[Tensor], bool, float) -> Tensor\n            return pad_sequence(tensor_list, batch_first, padding_value)\n\n        def pack_sequence_func(tensor_list, enforce_sorted=True):\n            # type: (List[Tensor], bool) -> Tensor\n            return pad_packed_sequence(pack_sequence(tensor_list, enforce_sorted))[0]\n\n        ones3 = torch.ones(3, 5)\n        ones4 = torch.ones(4, 5)\n        ones5 = torch.ones(5, 5)\n        tensor1 = torch.tensor([1, 2, 3])\n        tensor2 = torch.tensor([4, 5])\n        tensor3 = torch.tensor([6])\n        with torch._jit_internal._disable_emit_hooks():\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5],))\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5], True))\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5], True, 2.5))\n            self.checkScript(pack_sequence_func,\n                             ([tensor1, tensor2, tensor3],))\n            self.checkScript(pack_sequence_func,\n                             ([tensor1, tensor2, tensor3], False))\n\n    def test_script_get_tracing_state(self):\n        def test_if_tracing(x):\n            if torch._C._get_tracing_state():\n                return x + 1\n            else:\n                return x - 1\n\n        inp = torch.randn(3, 3)\n        self.checkScript(test_if_tracing, (inp,))\n\n    def test_script_is_tracing(self):\n        def test_is_tracing(x):\n            if torch.jit.is_tracing():\n                return x + 1\n            else:\n                return x - 1\n\n        inp = torch.randn(3, 3)\n        self.checkScript(test_is_tracing, (inp,))\n\n    def test_is_scripting(self):\n        def foo():\n            return torch.jit.is_scripting()\n\n        self.assertFalse(foo())\n        scripted = torch.jit.script(foo)\n        self.assertTrue(scripted())\n\n    def test_comment_ignore_indent(self):\n        class Model(torch.nn.Module):\n            def __init__(self):\n    # useless comment that is not indented correctly  # noqa: E115\n                super().__init__()\n\n            def forward(self):\n                return 5\n\n        # should compile without an error\n        self.checkModule(Model(), ())\n\n    def test_script_outputs(self):\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            @torch.jit.script\n            def foo(a):\n                c, d = a + a\n                return c + d\n\n        @torch.jit.script\n        def return3():\n            return 1, 2, 3\n\n        with self.assertRaisesRegex(RuntimeError, \"too many values to unpack\"):\n            @torch.jit.script\n            def bind2():\n                a, b = return3()\n                print(a)\n                print(b)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_script_get_device_cuda(self):\n        @torch.jit.script\n        def foo(a):\n            return a.get_device()\n\n        v = torch.randn(1, device='cuda')\n        self.assertEqual(foo(v), 0)\n\n    def test_script_chunk(self):\n        @torch.jit.script\n        def foo(a):\n            b, c = torch.chunk(a, dim=0, chunks=2)\n            return b\n        v = torch.rand(10, 3)\n        self.assertEqual(torch.chunk(v, dim=0, chunks=2)[0], foo(v))\n\n    def test_script_copy(self):\n        class M(torch.nn.Module):\n            __annotations__ = {\n                \"val\": Optional[torch.Tensor]\n            }\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.val = None\n\n            def some_method(self):\n                return 3\n\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                self.val = x + self.some_method()\n                return x\n\n        m = torch.jit.script(M())\n        # test copy\n        copy.copy(m)\n        copy.deepcopy(m)\n\n    def test_script_forward_method_replacement(self):\n        # We want to support the use case of attaching a different `forward` method\n        class LowLevelModule(torch.nn.Module):\n            def __init__(self):\n                super(LowLevelModule, self).__init__()\n\n            def forward(self, input: torch.Tensor):\n                # Generic forward dispatch\n                return self.forward_pytorch(input) * 2\n\n        class TestModule(LowLevelModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n                # Replace the forward method\n                self.forward = types.MethodType(LowLevelModule.forward, self)\n\n            def forward_pytorch(self, input: torch.Tensor):\n                return torch.tensor(123)\n\n            def forward(self, input: torch.Tensor):\n                # Should not use this forward method\n                raise AssertionError(\"This method should not be used\")\n                return self.forward_pytorch(input)\n\n        m = TestModule()\n        self.assertEqual(m(torch.tensor(1)), torch.tensor(246))\n\n        m_scripted = torch.jit.script(m)\n        self.assertEqual(m_scripted(torch.tensor(1)), torch.tensor(246))\n\n    def test_python_call_non_tensor(self):\n        def foo(a, b, c):\n            # type: (Tensor, int, Tuple[Tensor, int]) -> Tuple[int, Tensor]\n            d, e = c\n            return b + e, a + d\n\n        @torch.jit.script\n        def bar():\n            x = torch.ones(3, 4)\n            a, b = foo(x, 3, (x, 3))\n            return a, b\n\n        self.assertEqual((6, torch.ones(3, 4) + 1), bar())\n\n    def test_python_call_non_tensor_wrong(self):\n        with self.assertRaisesRegex(RuntimeError, r\"but instead got value of type tuple\"):\n            @torch.jit.ignore\n            def foo():\n                # type: () -> Tensor\n                return ((3, 4),)  # noqa: T484\n\n            @torch.jit.script\n            def bar():\n                return foo()\n\n            bar()\n\n    def test_if_different_type(self):\n        with self.assertRaisesRegex(RuntimeError, \"c0 is set to type \"\n                                    \"int in the true branch and type \"\n                                    \"float in the false branch\"):\n            @torch.jit.script\n            def diff_type_used():\n                if 1 == 2:\n                    c0 = 1\n                else:\n                    c0 = 1.0\n                return c0\n\n        with self.assertRaisesRegex(RuntimeError, \"Variable 'c0' previously had type float\"):\n            @torch.jit.script\n            def diff_existing_type(x):\n                c0 = 1.0\n                if 1 == 2:\n                    c0 = 1\n                    print(x)\n                return x\n\n        @torch.jit.script\n        def diff_type_unused():\n            if 1 == 1:\n                c0 = 1\n                print(c0)\n            else:\n                c0 = 1.0\n                print(c0)\n            return 1\n\n    def test_if_not_defined_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"c0 is not defined in the false branch\"):\n            @torch.jit.script\n            def test():\n                if 1 == 1:\n                    c0 = 1\n                return c0\n        with self.assertRaisesRegex(RuntimeError, \"c0 is not defined in the true branch\"):\n            @torch.jit.script\n            def test2():\n                if 1 == 1:\n                    pass\n                else:\n                    c0 = 1\n                return c0\n\n    def test_if_list_cat(self):\n        # testing that different length lists don't throw error on cat in shape prop\n        @torch.jit.script\n        def test_list(x):\n            if bool(x.sum() < 1):\n                c = [x, x]\n            else:\n                c = [x, x, x]\n            return torch.cat(c)\n\n        b = torch.zeros(2, 4)\n        _propagate_shapes(test_list.graph, (b,), False)\n\n    def test_if_supertype(self):\n        @torch.jit.script\n        def tensor_unifying(x, y, z):\n            # testing dynamic is appropriately set for y and z\n            if bool(x):\n                x, y, z = x + 1, y, z\n            else:\n                x, y, z = x + 1, x, y\n\n            return x, y, z\n\n        a = torch.zeros(2, 2, dtype=torch.float)\n        b = torch.zeros(2, 4, dtype=torch.long)\n        c = torch.zeros(2, 4, dtype=torch.float)\n\n        graph = _propagate_shapes(tensor_unifying.graph, (a, b, c), False)\n        if_outputs = list(graph.findNode(\"prim::If\").outputs())\n        self.assertTrue(if_outputs[0].type().str() == \"Float(*, *, requires_grad=0, device=cpu)\")\n        self.assertTrue(if_outputs[1].type().str() == \"Tensor(*, *, requires_grad=0, device=cpu)\")\n        self.assertTrue(if_outputs[2].type().str() == \"Tensor(*, *, requires_grad=0, device=cpu)\")\n\n    def test_list_unify(self):\n        # allowing a unififed int?[] would cause a runtime error b/c\n        # the index operation expects int?[] to be a generic list,\n        # but in the true branch the IValue will be a int list\n        with self.assertRaisesRegex(RuntimeError, \"int[] in the true branch and type None[]\"):\n            @torch.jit.script\n            def list_optional_fails(x):\n                # type: (bool) -> Optional[int]\n                if x:\n                    y = [1]\n                else:\n                    y = [None]  # noqa: T484\n                return y[0]\n\n        @torch.jit.script\n        def list_tensors(x):\n            # type: (bool) -> Tuple[Tensor, List[Tensor]]\n            if x:\n                a = torch.zeros([1, 1])\n                y = [a]\n            else:\n                a = torch.zeros([1, 2])\n                y = [a]\n            return a, y\n\n        self.run_pass('constant_propagation', list_tensors.graph)\n        m = self.createFunctionFromGraph(list_tensors.graph)\n        # testing that tensor type of lists is unified\n        self.getExportImportCopy(m)\n\n    @_inline_everything\n    def test_import_constants_not_specialized(self):\n        class Mod(torch.nn.Module):\n            def forward(self, x):\n                return torch.cat(2 * [x], dim=0)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self, mod):\n                super(ScriptMod, self).__init__()\n                x = torch.zeros(1, 3)\n                mod_fn = lambda : mod(x)  # noqa: E731\n                self.mod = torch.jit.trace(mod_fn, tuple())\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.mod()\n\n        cm = ScriptMod(Mod())\n        # specialized tensor in graph\n        FileCheck().check(\"Double(1, 3, strides=[3, 1], requires_grad=0, device=cpu)\").run(cm.forward.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(cm, buffer)\n        buffer.seek(0)\n        # when tensor is loaded as constant it isnt specialized\n        cm_load = torch.jit.load(buffer)\n        FileCheck().check_not(\"Double(1, 3)\").run(cm_load.forward.graph)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_type_annotations_repeated_list(self):\n        @torch.jit.script\n        def float_fn(x, y):\n            # type: (float, BroadcastingList3[float]) -> List[float]\n            return y\n        self.assertEqual(float_fn(2.0, 1.0), float_fn(2.0, [1.0, 1.0, 1.0]))\n        self.assertEqual(float_fn(2.0, 1.0), float_fn(2.0, (1.0, 1.0, 1.0)))\n\n        @torch.jit.script\n        def float_fn_call():\n            print(float_fn(1.0, 1.0))\n            print(float_fn(1.0, (1.0, 1.0, 1.0)))\n\n        @torch.jit.script\n        def int_fn(x):\n            # type: (BroadcastingList3[int]) -> List[int]\n            return x\n        self.assertEqual(int_fn(1), int_fn([1, 1, 1]))\n        self.assertEqual(int_fn(1), int_fn((1, 1, 1)))\n\n        @torch.jit.script\n        def int_fn_call():\n            print(int_fn(1))\n            print(int_fn((1, 1, 1)))\n\n        with self.assertRaisesRegex(RuntimeError, \"must be a positive integer:\"):\n            @torch.jit.script  # noqa: T484\n            def fn(x):\n                # type: (BroadcastingListx[int]) -> List[int]  # noqa: T484\n                return x\n\n        # using CU so that flake8 error on int[2] is not raised (noqa not working)\n        with self.assertRaisesRegex(RuntimeError, \"Unknown type constructor\"):\n            cu = torch.jit.CompilationUnit('''\n                def nested(x, y):\n                    # type: (int, Tuple[int, int[2]]) -> List[int]\n                    return x  # noqa: T484\n            ''')\n\n        @torch.jit.script\n        def f(x: BroadcastingList2[int]):\n            return x\n\n        out = f(1)\n        self.assertTrue(isinstance(out[0], int))\n        self.assertEqual(out, [1, 1])\n\n    def test_ntuple_builtins(self):\n        from torch.nn.modules.utils import _single, _pair, _triple, _quadruple\n\n        def test_ints():\n            return _single(1), _pair(2), _triple(3), _quadruple(4)\n\n        def test_floats():\n            return _single(1), _pair(2.1), _triple(3.1), _quadruple(4.1)\n\n        self.checkScript(test_ints, ())\n        self.checkScript(test_floats, ())\n\n    def test_embedding_renorm_grad_error(self):\n        # Testing that the builtin call to embedding_renorm_ correctly throws\n        # Error when .backward() is called on its input\n\n        def embedding_norm(input, embedding_matrix, max_norm):\n            F.embedding(input, embedding_matrix, max_norm=0.01)\n\n        @torch.jit.script\n        def embedding_norm_script(input, embedding_matrix, max_norm):\n            # type: (Tensor, Tensor, float) -> None\n            F.embedding(input, embedding_matrix, max_norm=0.01)\n\n        for _ in [embedding_norm, embedding_norm_script]:\n            input = torch.tensor([[1, 2, 4, 5], [4, 3, 2, 9]])\n            embedding_matrix = torch.randn(10, 3)\n\n            var1 = torch.randn(10, 3, requires_grad=True)\n            var2 = var1.detach().requires_grad_()\n            output1 = var1 * embedding_matrix\n            output2 = var2 * embedding_matrix\n\n            output1.sum().backward()\n\n            ignore = F.embedding(input, embedding_matrix, max_norm=0.01)\n            with self.assertRaisesRegex(RuntimeError, \"modified\"):\n                output2.sum().backward()\n\n    def test_type_annotations(self):\n        def fn(x, y):\n            # type: (Tensor, Tensor) -> Tuple[Tensor, Tensor, Tensor]\n            return x, x * 2, x * 3\n\n        with self.assertRaisesRegex(RuntimeError, r\"need 4 values .* found only 3\"):\n            @torch.jit.script\n            def script_fn(x):\n                x, y, z, w = fn(x, x)\n\n        with self.assertRaisesRegex(RuntimeError, r\"too many values .* need 2 but found 3\"):\n            @torch.jit.script\n            def script_fn2(x):\n                x, y = fn(x, x)\n\n        def fn_unpack(x):\n            y, z, w = fn(x, x)\n            return y\n\n        def fn_index(x):\n            q = fn(x, x)\n            return x\n\n        def fn_string(str, strpair):\n            # type: (str, Tuple[str, str]) -> Tuple[str, int, str, str]\n            str1, str2 = strpair\n            return str, 2, str1, str2\n\n        x = torch.ones(2, 2)\n        self.checkScript(fn_unpack, (x,), optimize=True)\n        self.checkScript(fn_index, (x,), optimize=True)\n        self.checkScript(fn_string, (\"1\", (\"3\", \"4\")), optimize=True)\n\n    def test_type_annotations_varargs(self):\n        @torch.jit.ignore\n        def fn_varargs(x, *args):\n            return args[0] if args else x\n\n        def fn1(x, y, z):\n            return fn_varargs(x)\n\n        def fn2(x, y, z):\n            return fn_varargs(x, y)\n\n        def fn3(x, y, z):\n            return fn_varargs(x, y, z)\n\n        x, y, z = [torch.randn(2, 2) for _ in range(3)]\n        self.checkScript(fn1, (x, y, z), optimize=True)\n        self.checkScript(fn2, (x, y, z), optimize=True)\n        self.checkScript(fn3, (x, y, z), optimize=True)\n\n    def test_type_annotation_py3(self):\n        code = dedent(\"\"\"\n        import torch\n        from torch import Tensor\n        from typing import Tuple\n\n        def fn(x : torch.Tensor, y : Tensor, z) -> Tuple[Tensor, Tensor, Tensor]:\n            return (x, y + z, z)\n        \"\"\")\n\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            script_path = os.path.join(tmp_dir, 'script.py')\n            with open(script_path, 'w') as f:\n                f.write(code)\n            fn = get_fn('test_type_annotation_py3', script_path)\n            fn = torch.jit.ignore(fn)\n\n            with self.assertRaisesRegex(RuntimeError, r\"Expected a value of type 'Tensor' for argument\"\n                                                      r\" 'x' but instead found type 'Tuple\\[Tensor,\"):\n                @torch.jit.script\n                def bad_fn(x):\n                    x, y = fn((x, x), x, x)\n                    return y\n\n            with self.assertRaisesRegex(RuntimeError, r\"too many values .* need 2 but found 3\"):\n                @torch.jit.script\n                def bad_fn2(x):\n                    x, y = fn(x, x, x)\n                    return y\n\n            with self.assertRaisesRegex(RuntimeError, r\"need 4 values .* found only 3\"):\n                @torch.jit.script\n                def bad_fn3(x):\n                    x, y, z, w = fn(x, x, x)\n                    return y\n\n            def good_fn(x):\n                y, z, w = fn(x, x, x)\n                return y, z, w\n\n            self.checkScript(good_fn, (torch.ones(2, 2),), optimize=True)\n\n    def test_type_annotation_module(self):\n        class BaseModule(torch.jit.ScriptModule):\n            @torch.jit.ignore\n            def foo(self, x):\n                # type: (Tensor) -> Tensor\n                return x + 1\n\n            @torch.jit.ignore\n            def bar(self, x, y):\n                # type: (Tensor, Tensor) -> Tuple[Tensor, Tensor]\n                return x + y, y\n\n            @torch.jit.ignore\n            def baz(self, x, y):\n                return x\n\n        class ModuleTooMany(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                return self.foo(x, x)\n\n        class ModuleTooFew(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                return self.bar(x)\n\n        class ModuleTooManyAssign(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                y, z, w = self.bar(x, x)\n                return x\n\n        class ModuleDefault(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                y = self.baz(x)\n                return x\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected at most 2 arguments but found 3\"):\n            ModuleTooMany()\n        with self.assertRaisesRegex(RuntimeError, \"Argument y not provided\"):\n            ModuleTooFew()\n        with self.assertRaisesRegex(RuntimeError, \"need 3 values .* found only 2\"):\n            ModuleTooManyAssign()\n        with self.assertRaisesRegex(RuntimeError, \"Argument y not provided.\"):\n            ModuleDefault()\n\n    def test_type_inferred_from_empty_annotation(self):\n        \"\"\"\n        Test that the type inferred from an empty or missing annotation is Torch.Tensor wtih `inferred=true`\n        \"\"\"\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        graph = fn.graph\n        n = next(graph.inputs())\n        self.assertTrue(n.type() == torch._C.TensorType.getInferred())\n\n        with self.assertRaisesRegex(RuntimeError, \"Inferred \\'x\\' to be of type \\'Tensor\"):\n            fn(\"1\")\n\n    def test_script_define_order(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input)\n\n            @torch.jit.script_method\n            def foo(self, input):\n                return input + 1\n        m = M()\n        self.assertEqual(2, m.call_foo(torch.ones((), dtype=torch.int64)))\n\n    def test_script_define_order_recursive_fail(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input)\n\n            @torch.jit.script_method\n            def foo(self, input):\n                self.call_foo(input)\n\n        with self.assertRaisesRegex(RuntimeError, 'called recursively'):\n            M()\n\n    def test_script_kwargs_fn_call(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input=input, bar=1)\n\n            @torch.jit.script_method\n            def foo(self, bar, input):\n                # type: (int, Tensor) -> Tensor\n                return input + bar\n        m = M()\n        self.assertEqual(2, m.call_foo(torch.ones((), dtype=torch.int64)))\n\n    def test_if_define(self):\n        @torch.jit.script\n        def foo(a):\n            if bool(a == 0):\n                b = 1\n            else:\n                b = 0\n            return b + 1\n\n        @torch.jit.script\n        def foo2(a):\n            b = 0\n            if bool(a == 0):\n                b = 1\n            return b + 1\n\n        @torch.jit.script\n        def foo3(a):\n            b = 1\n            if bool(a == 0):\n                c = 4\n            else:\n                b = 0\n            return b + 1\n\n        a = torch.ones(1, dtype=torch.long)\n        b = torch.zeros(1, dtype=torch.long)\n        self.assertEqual(1, foo(a))\n        self.assertEqual(2, foo(b))\n        self.assertEqual(1, foo2(a))\n        self.assertEqual(2, foo2(b))\n        self.assertEqual(1, foo3(a))\n        self.assertEqual(2, foo3(b))\n\n    def test_script_module_export_submodule(self):\n        class M1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M1, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                # test submodule\n                self.sub = M1()\n                self.weight = nn.Parameter(torch.randn(2, 3))\n                self.bias = nn.Parameter(torch.randn(2))\n                self.define(\"\"\"\n                    def hi(self, a):\n                        return self.weight.mm(a)\n                \"\"\")\n\n            @torch.jit.script_method\n            def doit(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit2(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit3(self, input):\n                return input + torch.ones([1], dtype=torch.double)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                a = self.doit(input)\n                b = self.doit2(input)\n                c = self.hi(input)\n                return a + b + self.bias + c\n\n        with torch.jit.optimized_execution(False):\n            m_orig = M2()\n            m_import = self.getExportImportCopy(m_orig)\n\n            input = torch.randn(3, 2)\n            self.assertEqual(m_orig.doit(input), m_import.doit(input))\n            self.assertEqual(m_orig.hi(input), m_import.hi(input))\n            self.assertEqual(m_orig.doit3(input), m_import.doit3(input))\n            self.assertEqual(m_orig.forward(input), m_import.forward(input))\n\n    @slowTest\n    def test_compile_module_with_constant(self):\n        class Double(nn.Module):\n            def __init__(self, downsample=None):\n                super(Double, self).__init__()\n\n            def forward(self, input):\n                return input * 2\n\n        class Mod(nn.Module):\n            __constants__ = ['downsample']\n\n            def __init__(self, downsample=None):\n                super(Mod, self).__init__()\n                self.downsample = downsample\n\n            def forward(self, input):\n                if self.downsample is not None:\n                    return self.downsample(input)\n                return input\n\n        none_mod = torch.jit.script(Mod(None))\n        double_mod = torch.jit.script(Mod(Double()))\n        self.assertEqual(none_mod(torch.tensor(1)), torch.tensor(1))\n        self.assertEqual(double_mod(torch.tensor(1)), torch.tensor(1) * 2)\n\n    def test_device_kwarg(self):\n        from torch import device\n\n        def f():\n            return device(type='cuda'), torch.device(type='cpu')\n        self.checkScript(f, ())\n\n    def test_script_module_export_tensor_type(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, type):\n                super(M, self).__init__()\n                self.param = torch.nn.Parameter(torch.zeros((5, 5), dtype=type).random_())\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param\n\n        with torch.jit.optimized_execution(False):\n            for type in [torch.float, torch.double]:\n                m_orig = M(type)\n                m_import = self.getExportImportCopy(m_orig)\n                # check to make sure the storage wasn't resized\n                self.assertTrue(m_orig.param.storage().size() == 25)\n                self.assertEqual(m_orig.foo(), m_import.foo())\n                self.assertTrue(m_orig.foo().dtype == m_import.foo().dtype)\n\n    @unittest.skipIf(not RUN_CUDA, \"testing cuda tensors require CUDA\")\n    def test_script_module_export_tensor_cuda(self):\n        class M(torch.jit.ScriptModule):\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.param = torch.nn.Parameter(torch.zeros((5, 5), device='cuda:0').random_())\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param\n\n        m_orig = M()\n        m_import = self.getExportImportCopy(m_orig)\n        # check to make sure the storage wasn't resized\n        self.assertTrue(m_orig.param.storage().size() == 25)\n        self.assertTrue(m_import.foo().device == torch.device('cuda:0'))\n        self.assertEqual(m_orig.foo(), m_import.foo())\n        self.assertTrue(m_orig.foo().dtype == m_import.foo().dtype)\n\n    def test_script_module_export_blocks(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, n, m):\n                super(M, self).__init__()\n                self.weight = torch.nn.Parameter(torch.rand(n, m))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                if bool(input.sum() > 0):\n                    output = self.weight.mv(input)\n                else:\n                    output = self.weight + input\n                return output\n\n        m_orig = M(200, 200)\n        m_import = self.getExportImportCopy(m_orig)\n\n        t = torch.rand(200)\n        self.assertEqual(m_orig(t), m_import(t))\n\n    def test_script_module_export_shared_storage(self):\n        class M(torch.jit.ScriptModule):\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.param1 = torch.nn.Parameter(torch.rand(5, 5))\n                self.param2 = torch.nn.Parameter(self.param1[3])\n                self.param3 = torch.nn.Parameter(torch.rand(5, 5))\n                self.param4 = torch.nn.Parameter(torch.rand(11, 5)[1:6])\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param1 + self.param2 + self.param3 + self.param4\n\n        with torch.jit.optimized_execution(False):\n            m_orig = M()\n            m_import = self.getExportImportCopy(m_orig)\n\n            self.assertEqual(m_orig.foo(), m_import.foo())\n\n            self.assertTrue(m_import.param1.storage().data_ptr() == m_import.param2.storage().data_ptr())\n            self.assertTrue(m_import.param1.storage().data_ptr() != m_import.param3.storage().data_ptr())\n\n    def test_sequential_intermediary_types(self):\n        class A(torch.nn.Module):\n            def __init__(self):\n                super(A, self).__init__()\n\n            def forward(self, x):\n                return x + 3\n\n        class B(torch.nn.Module):\n            def __init__(self):\n                super(B, self).__init__()\n\n            def forward(self, x):\n                return {\"1\": x}\n\n        class C(torch.nn.Module):\n            def __init__(self):\n                super(C, self).__init__()\n                self.foo = torch.nn.Sequential(A(), B())\n\n            def forward(self, x):\n                return self.foo(x)\n\n        self.checkModule(C(), (torch.tensor(1),))\n\n    def test_ellipsis_const_mid(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, Ellipsis, 0:4, 4:8].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_mid_select(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, Ellipsis, 4, 4, 4:8, 2].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_start(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[Ellipsis, 0:4, 4:8].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_end(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[0:4, 2, Ellipsis].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_mid(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, ..., 0:4, 4:8].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_mid_select(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, ..., 4, 4, 4:8, 2].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_start(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[..., 0:4, 4:8].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_end(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[0:4, 2, ...].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_torch_manual_seed(self):\n        with freeze_rng_state():\n            def test():\n                torch.manual_seed(2)\n                return torch.rand(1)\n\n            script = torch.jit.script(test)\n            self.assertEqual(test(), script())\n            graph = script.graph_for()\n            FileCheck().check(\"aten::manual_seed\").run(graph)\n\n    def test_index_select_shape_prop(self):\n\n        @torch.jit.script\n        def foo(x, y):\n            return torch.index_select(x, index=y, dim=1)\n\n        a = torch.zeros(2, 2)\n        b = torch.zeros(4, dtype=torch.long)\n        torch._C._jit_pass_complete_shape_analysis(foo.graph, (a, b), False)\n        FileCheck().check(\"Double(2, 4, strides=[4, 1], requires_grad=0, device=cpu)\").run(str(foo.graph))\n\n    def test_shape_analysis_loop(self):\n        def foo(a, b, x):\n            c = a\n            # on the first iteration of the loop it appears that\n            # c should have a expand to the size of b\n            # but on the second+ iterations, there is no broadcast and the\n            # sizes are different.\n            # previously this would cause the compiler to (1) enter an infinite\n            # loop trying to compute the shape, and (2) insert invalid\n            # broadcasts.\n            # this test ensure we don't regress on these issues\n            for _ in range(2):\n                a = c + b\n                c = x\n                b = x\n            return a\n\n        self.checkScript(foo, (torch.zeros(1), torch.zeros(4), torch.zeros(5)), optimize=False)\n\n    def test_intlist_args(self):\n        def func_1(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, 1)\n\n        def func_2(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, output_size=1)\n\n        def func_3(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, output_size=[1])\n\n        x = torch.randn(8, 8, 8)\n        self.checkScript(func_1, [x], optimize=True)\n        self.checkScript(func_2, [x], optimize=True)\n        self.checkScript(func_3, [x], optimize=True)\n\n    def test_wrong_implicit_expand(self):\n\n        @_trace(torch.zeros(3), torch.zeros(1))\n        def foo(a, b):\n            return a + b\n\n        a = torch.rand(4)\n        b = torch.rand(4)\n        self.assertEqual(a + b, foo(a, b))\n\n    def test_builtin_args_fails(self):\n\n        with self.assertRaisesRegex(RuntimeError, 'Argument self not provided'):\n            @torch.jit.script\n            def f1(a):\n                torch.sum(foo=4)\n\n        with self.assertRaisesRegex(RuntimeError, 'specified twice'):\n            @torch.jit.script\n            def f2(a):\n                torch.sum(a, self=a)\n\n        with self.assertRaisesRegex(RuntimeError, 'not provided'):\n            @torch.jit.script\n            def f3(a):\n                torch.sum(dim=4)\n\n        with self.assertRaisesRegex(RuntimeError, 'for argument \\'tensors\\' but instead found type \\'Tensor'):\n            @torch.jit.script\n            def f4(a):\n                torch.cat(a)\n\n        with self.assertRaisesRegex(RuntimeError, r'argument \\'tensors\\' but instead found type \\'List\\[int\\]'):\n            @torch.jit.script\n            def f5(a):\n                torch.cat([3])\n\n        with self.assertRaisesRegex(RuntimeError, r'Expected a value of'\n                                    r' type \\'List\\[int\\]\\' for argument'\n                                    r' \\'size\\' but instead found type '\n                                    r'\\'List\\[Union\\[List\\[int\\], int\\]\\]'):\n            @torch.jit.script\n            def f6(a):\n                a.expand(size=[3, [4]])\n\n    def test_builtin_args(self):\n\n        def t0(a):\n            # default arg dim\n            return torch.cat([a, a])\n\n        self.checkScript(t0, (torch.zeros(1, 1),))\n\n        def t1(a):\n            # keywords out of order\n            return torch.cat(dim=1, tensors=[a, a])\n\n        self.checkScript(t1, (torch.zeros(1, 1, 2),))\n\n        def t2(a):\n            # mix const/non-const attributes\n            if 1 == 1:\n                b = 1\n            else:\n                b = 0\n            return torch.sum(a, dim=b, keepdim=False)\n\n        self.checkScript(t2, (torch.zeros(1, 1, 2),))\n\n    def test_parser_type_annotations(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : Tensor, y : Tuple[Tuple[Tensor, Tensor], Tensor]) -> Tuple[Tensor, Tensor]:\n                return x, x\n        ''')\n\n        self.assertExpected(str(cu.foo.schema))\n\n    def test_parser_type_annotations_comment(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x, y):\n                # type: (Tensor, Tuple[Tuple[Tensor, Tensor], Tensor]) -> Tuple[Tensor, Tensor]\n                return x, x\n        ''')\n\n        self.assertExpected(str(cu.foo.schema))\n\n    def test_parser_type_annotations_unknown_type(self):\n        with self.assertRaisesRegex(RuntimeError, \"Unknown type name 'Foo'\"):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[Tuple[Foo, Tensor], Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_subscript_non_ident(self):\n        with self.assertRaisesRegex(RuntimeError, r'Subscripted type must be a type identifier'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[Tensor, Tensor][Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_subscript_tensor(self):\n        with self.assertRaisesRegex(RuntimeError, r'Unknown type constructor Tensor'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tensor[Tensor, Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_incompatible_expression(self):\n        with self.assertRaisesRegex(RuntimeError, r'Expression of type \\+ cannot be used in a type expression'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[3 + 4, Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_gather_dynamic_index(self):\n        def t(x):\n            gather1 = x[0]\n            idx = 0 + 1\n            gather2 = x[idx]\n            return gather1 + gather2\n\n        self.checkScript(t, (torch.zeros(3, 2, 3),))\n\n    def test_torch_ignore_conversion_to_none(self):\n        class A(torch.nn.Module):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.ignore\n            def ignored(self, a: int) -> None:\n                l: int = len([2 for i in range(a) if i > 2])\n                return\n\n            def forward(self) -> int:\n                a: int = 4\n                b: int = 5\n                self.ignored(a)\n                return a + b\n\n        class B(torch.nn.Module):\n            def __init__(self):\n                super(B, self).__init__()\n\n            @torch.jit.ignore\n            def ignored(self, a: int):\n                l: int = len([2 for i in range(a) if i > 2])\n                return\n\n            def forward(self) -> int:\n                a: int = 4\n                b: int = 5\n                self.ignored(a)\n                return a + b\n\n        modelA = torch.jit.script(A())\n        self.assertEqual(modelA(), 9)\n\n        modelB = torch.jit.script(B())\n        self.assertEqual(modelB(), 9)\n\n    def test_addmm_grad(self):\n        \"\"\" This test checks several things:\n            1. An expand node was inserted before the addmm operating on the\n               bias term.\n            2. The fused form of addmm appears in the ultimate graph that's\n               executed.\n            3. A sum op was emitted for accumulating gradients along the 0th\n               (expanded) dimension of the bias term.\n            4. The correct symbolic representation for the backward pass of the\n               mm operator was emitted (x.t() -> mm)\n\n            TODO: we should actually check these conditions once we have a way\n            to dump the GraphExecutor state. Namely the processed forward graph\n            and the backward graph.\n        \"\"\"\n        @torch.jit.script\n        def addmm_grad_test(b, x, w):\n            return torch.addmm(b, x, w)\n\n        # Initialize param and input values\n        w_init = torch.rand(2, 5)\n        b_init = torch.rand(5)\n        x = torch.rand(3, 2)\n\n        # Clone trainable params\n        b = b_init.clone()\n        b.requires_grad_()\n        w = w_init.clone()\n        w.requires_grad_()\n\n        # Test symbolic differentiation\n        y = addmm_grad_test(b, x, w)\n        y.sum().backward()\n\n        # clone params for autograd reference\n        b_ref = b_init.clone()\n        b_ref.requires_grad_()\n        w_ref = w_init.clone()\n        w_ref.requires_grad_()\n        y_ref = torch.addmm(b_ref, x, w_ref)\n        y_ref.sum().backward()\n\n        self.assertEqual(w.grad, w_ref.grad)\n        self.assertEqual(b.grad, b_ref.grad)\n\n    @unittest.skipIf(not RUN_CUDA, \"running tests on cuda to verify cudnn fix\")\n    def test_batch_norm_inference_backward_cuda(self):\n        with enable_profiling_mode_for_profiling_tests():\n            class MyBatchNorm(torch.nn.Module):\n                def __init__(self, num_features, affine, track_running_stats):\n                    super(MyBatchNorm, self).__init__()\n                    self.bn = torch.nn.BatchNorm2d(\n                        num_features, 1e-5, affine=affine, track_running_stats=track_running_stats).float()\n\n                def forward(self, x: torch.Tensor):\n                    o = self.bn(x)\n                    o = torch.nn.functional.relu(o)\n                    return o\n\n            batch = 4\n            c = 2\n            hw = 3\n            # Initialize param and input values\n            x_init = torch.randn(batch, c, hw, hw, dtype=torch.float).cuda()\n            grad = torch.randn(batch, c, hw, hw, dtype=torch.float).cuda()\n\n            training = False\n            affine = True\n            track_running_stats = True\n\n            module = torch.jit.script(MyBatchNorm(c, affine, track_running_stats)).cuda()\n            ref_module = MyBatchNorm(c, affine, track_running_stats).cuda()\n            module.eval()\n            ref_module.eval()\n\n            jit_module = torch.jit.script(module)\n            ref_module.load_state_dict(module.state_dict())\n\n            x = x_init.detach().clone()\n            x.requires_grad_()\n            x_ref = x_init.detach().clone()\n            x_ref.requires_grad_()\n\n            # Test symbolic differentiation\n            # Run Forward and Backward thrice to trigger autodiff graph\n            for i in range(0, 3):\n                y = jit_module(x)\n                y.backward(grad)\n            x.grad.zero_()\n\n            module.bn.running_mean.zero_()\n            module.bn.running_var.fill_(1.0)\n            ref_module.bn.running_mean.zero_()\n            ref_module.bn.running_var.fill_(1.0)\n\n            # run jitted module\n            y = jit_module(x)\n            y.backward(grad)\n            # reference computation\n            y_ref = ref_module(x_ref)\n            y_ref.backward(grad)\n\n            self.assertEqual(y_ref, y)\n            self.assertEqual(x.grad, x_ref.grad)\n            self.assertEqual(module.bn.running_mean, ref_module.bn.running_mean)\n            self.assertEqual(module.bn.running_var, ref_module.bn.running_var)\n\n    def test_zeros(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['d']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.d = torch.device('cpu')\n\n            @torch.jit.script_method\n            def create(self):\n                return torch.zeros([1, 1, 2], dtype=torch.float, device=self.d, layout=torch.strided)\n\n        r = M().create()\n        self.assertEqual(r.dtype, torch.float)\n        self.assertEqual(torch.zeros([1, 1, 2], dtype=torch.float), r)\n\n        def fn():\n            return torch.zeros((1, 2, 3))\n\n        self.checkScript(fn, ())\n\n    def test_vararg_zeros(self):\n        def foo():\n            return torch.zeros(3, 4, 5, dtype=torch.int)\n\n        self.checkScript(foo, ())\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the original version of test_rand\")\n    def test_rand(self):\n        def test_rand():\n            a = torch.rand([3, 4])\n            return a + 1.0 - a\n\n        self.checkScript(test_rand, ())\n        fn = torch.jit.script(test_rand)\n        out = fn()\n        self.assertEqual(out.dtype, torch.double)\n        g = fn.graph_for()\n        # Testing shape analysis correctly setting type\n        if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n            FileCheck().check(\"Double(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Float(*, *, requires_grad=0, device=cpu)\").run(g)\n\n        @torch.jit.script\n        def randint():\n            return torch.randint(0, 5, [1, 2])\n        out = randint()\n        self.assertEqual(out.dtype, torch.int64)\n        if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n            FileCheck().check(\"Long(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Float(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Double(*, *, requires_grad=0, device=cpu)\") \\\n                       .run(randint.graph_for())\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_autodiff_complex(self):\n        def foo(x: torch.Tensor, y: torch.Tensor, W: torch.Tensor):\n            return torch.exp(torch.mm(torch.complex(x, y), W.cfloat()))\n\n        @torch.jit.script\n        def jitted_foo(x: torch.Tensor, y: torch.Tensor, W: torch.Tensor):\n            return torch.exp(torch.mm(torch.complex(x, y), W.cfloat()))\n\n        x = torch.randn(128, 16, dtype=torch.float32, device='cuda:0')\n        y = torch.randn(128, 16, dtype=torch.float32, device='cuda:0')\n        W = torch.randn(16, 1, dtype=torch.float32, device='cuda:0', requires_grad=True)\n        W.data /= 4\n\n        with enable_profiling_mode_for_profiling_tests():\n            for i in range(4):\n                self.assertTrue((foo(x, y, W).grad_fn is None) == (jitted_foo(x, y, W).grad_fn is None))\n\n\n    def test_linear_grad(self):\n        with enable_profiling_mode_for_profiling_tests():\n            def t(x: torch.Tensor, w: torch.Tensor, b: Optional[torch.Tensor]):\n                return torch.nn.functional.linear(x, w, b)\n\n            x_init = torch.randn(4, 2)\n            w_init = torch.randn(3, 2)\n            b_init = torch.randn(3)\n            grad = torch.randn(4, 3)\n\n            with disable_autodiff_subgraph_inlining():\n                # script module\n                jit_t = torch.jit.script(t)\n\n                x = x_init.detach().requires_grad_()\n                w = w_init.detach().requires_grad_()\n                b = b_init.detach().requires_grad_()\n                x_ref = x_init.detach().requires_grad_()\n                w_ref = w_init.detach().requires_grad_()\n                b_ref = b_init.detach().requires_grad_()\n\n                # profiling/optimization runs\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n\n                x.grad.zero_()\n                w.grad.zero_()\n                b.grad.zero_()\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n                o = t(x_ref, w_ref, b_ref)\n                o.backward(grad)\n\n                self.assertEqual(jit_o, o)\n                self.assertEqual(x.grad, x_ref.grad)\n                self.assertEqual(w.grad, w_ref.grad)\n                self.assertEqual(b.grad, b_ref.grad)\n\n                x.grad.zero_()\n                w.grad.zero_()\n                x_ref.grad.zero_()\n                w_ref.grad.zero_()\n                jit_o = jit_t(x, w, None)\n                jit_o.backward(grad)\n                o = t(x_ref, w_ref, None)\n                o.backward(grad)\n\n                self.assertEqual(jit_o, o)\n                self.assertEqual(x.grad, x_ref.grad)\n                self.assertEqual(w.grad, w_ref.grad)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"the profiling version of test_rand\")\n    def test_rand_profiling(self):\n        def test_rand():\n            a = torch.rand([3, 4])\n            return a + 1.0 - a\n\n        # Testing shape analysis correctly setting type\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(1):\n                fn = torch.jit.script(test_rand)\n                out = fn()\n                graph_str = torch.jit.last_executed_optimized_graph()\n                self.assertEqual(out.dtype, torch.double)\n                FileCheck().check(\"Double(3, 4, strides=[4, 1], requires_grad=0, device=cpu)\") \\\n                           .check_not(\"Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu)\").run(graph_str)\n\n            # fn = self.checkScript(test_rand, ())\n            # out = fn()\n            # self.assertEqual(out.dtype, torch.double)\n\n        @torch.jit.script\n        def randint():\n            return torch.randint(0, 5, [1, 2])\n\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(1):\n                out = randint()\n                graph_str = torch.jit.last_executed_optimized_graph()\n                self.assertEqual(out.dtype, torch.int64)\n                FileCheck().check(\"profiled_type=Long(1, 2, strides=[2, 1], requires_grad=0, device=cpu)\").run(graph_str)\n\n\n    def test_erase_number_types(self):\n        def func(a):\n            b = 7 + 1 + 3\n            c = a + b\n            c += b\n            return c\n\n        graph = torch.jit.script(func).graph\n        FileCheck().check(\"int = prim::Constant\").check(\"aten::add_\").run(str(graph))\n        self.run_pass(\"erase_number_types\", graph)\n        FileCheck().check_not(\"int = prim::Constant\").run(str(graph))\n\n    def test_refine_tuple_types(self):\n        # TupleConstruct output type is not correct here.\n        graph_str = \"\"\"\n        graph(%a : Float(123), %b : Float(4, 5, 6)):\n          %c : (Tensor, Tensor) = prim::TupleConstruct(%a, %b)\n          return (%c)\n        \"\"\"\n        graph = parse_ir(graph_str)\n        torch._C._jit_pass_refine_tuple_types(graph)\n\n        # After the pass, the output type should've been updated.\n        self.assertTrue('(Float(123), Float(4, 5, 6))' in str(graph.findNode('prim::TupleConstruct').output()))\n\n    # TODO(henrytu): Add test for RefineTypes for NamedTuple when it's supported by IR parser.\n\n    def test_remove_dropout(self):\n        weight_0_shape = (20, 5)\n        weight_1_shape = (20, 20)\n        input_shape = (10, 5)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n                self.weight_0 = torch.nn.Parameter(torch.rand(weight_0_shape))\n                self.weight_1 = torch.nn.Parameter(torch.rand(weight_1_shape))\n\n            def forward(self, x):\n                o = F.linear(x, self.weight_0)\n                o = F.dropout(o, training=self.training)\n                o = F.linear(o, self.weight_1)\n                return o\n\n        data = torch.rand(input_shape)\n        m = M()\n        m = torch.jit.script(m)\n        with self.assertRaisesRegex(RuntimeError, r'Dropout removal module in training mode is not yet supported'):\n            torch._C._jit_pass_remove_dropout(m._c)\n        m.eval()\n        ref_res = m(data)\n        # Need to inline otherwise we see instances of Function.\n        # We would have to use torch.linear/dropout to get around it otherwise.\n        from torch.jit._recursive import wrap_cpp_module\n        m = wrap_cpp_module(torch._C._freeze_module(m._c))\n        torch._C._jit_pass_remove_dropout(m._c)\n        res = m(data)\n        FileCheck().check_not(\"aten::dropout\").run(str(m.graph))\n        torch.testing.assert_close(ref_res, res, rtol=1e-2, atol=1e-3)\n\n    def test_unfold_zero_dim(self):\n        def fn(x):\n            return x.unfold(0, 1, 1)\n\n        graph = torch.jit.script(fn).graph\n        torch._C._jit_pass_complete_shape_analysis(graph, (torch.tensor(0.39),), False)\n        out_dims = fn(torch.tensor(0.3923)).ndim\n        self.assertEqual(graph.findNode(\"aten::unfold\").output().type().dim(), out_dims)\n\n    def test_mm_batching(self):\n\n        with enable_profiling_mode_for_profiling_tests():\n            lstm_cell = torch.jit.script(LSTMCellS)\n\n            def lstm(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n                for i in range(x.size(0)):\n                    hx, cx = lstm_cell(x[i], hx, cx, w_ih, w_hh, b_ih, b_hh)\n                return hx\n\n            slstm = torch.jit.script(lstm)\n\n            inputs = get_lstm_inputs('cpu', training=True, seq_length=10)\n            slstm(*inputs, profile_and_replay=True).sum().backward(retain_graph=True)\n            if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n                slstm(*inputs, profile_and_replay=True).sum().backward()\n\n            fw_graph = slstm.graph_for(*inputs)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                bw_graph = backward_graph(slstm, diff_graph_idx=0)\n                self.assertTrue('prim::MMBatchSide' in str(fw_graph))\n                self.assertTrue('prim::MMTreeReduce' in str(bw_graph))\n\n            sout = slstm(*inputs)\n            out = lstm(*inputs)\n            self.assertEqual(sout, out)\n            self.assertEqual(torch.autograd.grad(sout.sum(), inputs),\n                             torch.autograd.grad(out.sum(), inputs))\n\n    def test_loop_unrolling(self):\n        def fn(x):\n            y = 0\n            for i in range(int(x)):\n                y -= i\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        unroll_factor = 8\n        FileCheck().check(\"prim::Loop\").check_count(\"aten::sub\", unroll_factor) \\\n            .check(\"prim::Loop\").check(\"aten::sub\").run(str(graph))\n        self.checkScript(fn, (torch.tensor(10),))\n\n    def test_loop_unrolling_const(self):\n        def fn():\n            y = 0\n            for _ in range(10):\n                y -= 1\n            return y\n\n        def fn2():\n            y = 0\n            for i in range(10):\n                y -= i\n            return y\n\n        def check(fn, name):\n            graph = torch.jit.script(fn).graph\n            self.run_pass('loop_unrolling', graph)\n            # entirely unrolled\n            FileCheck().check_not(\"prim::Loop'\").run(str(graph))\n            self.checkScript(fn, ())\n\n        check(fn, 'add_const')\n        check(fn2, 'add_iter')\n\n    def test_loop_unrolling_nested(self):\n        def fn(x):\n            y = 0\n            for _ in range(10):\n                for j in range(int(x)):\n                    y -= j\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        # inner loop with 8 subs followed by loop epilogue\n        unroll_factor = 8\n        FileCheck().check(\"prim::Loop\").check(\"prim::Loop\").check_count('aten::sub', unroll_factor) \\\n            .check(\"prim::Loop\").check(\"aten::sub\").run(str(graph))\n        self.checkScript(fn, (torch.tensor(10),))\n\n    def test_loop_unroll_unused_counter(self):\n        def fn(x):\n            y = 0\n            for _ in range(int(x)):\n                y -= 1\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        FileCheck().check(\"prim::Loop\").check_not(\"aten::add\").check(\"return\") \\\n            .run(str(graph))\n\n    def test_loop_unroll_negative(self):\n        def fn(x):\n            y = 0\n            for _ in range(int(x)):\n                y += 1\n            return y\n\n        self.checkScript(fn, (torch.tensor(-20),))\n        self.checkScript(fn, (torch.tensor(-2),))\n        self.checkScript(fn, (torch.tensor(-1),))\n        self.checkScript(fn, (torch.tensor(0),))\n        self.checkScript(fn, (torch.tensor(1),))\n        self.checkScript(fn, (torch.tensor(2),))\n\n    def test_where(self):\n        def fn(x, y):\n            return torch.where(x > 0.0, x, y)\n\n        self.checkScript(fn, (torch.randn(3, 2, dtype=torch.float), torch.ones(3, 2, dtype=torch.float)))\n\n    def test_where_method(self):\n        def fn(x, y):\n            return x.where(x > 0.0, y)\n\n        self.checkScript(fn, (torch.randn(3, 2, dtype=torch.float), torch.ones(3, 2, dtype=torch.float)))\n\n    def test_union_to_number(self):\n        @torch.jit.script\n        def fn(x: Union[int, complex, float], y: Union[int, complex, float]):\n            return x + y\n        FileCheck().check(\": Scalar):\").run(fn.graph)\n\n    def test_reassign_module_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot re-assign \\'self\\''):\n            class ReassignSelfLHS(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _ in range(20):\n                        self = x\n                    return self\n\n            ReassignSelfLHS()\n\n    def test_reassign_module_rhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot re-assign \\'x\\' to a value of type module'):\n            class ReassignSelfRHS(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _ in range(20):\n                        x = self\n                    return self\n\n            ReassignSelfRHS()\n\n    def test_unknown_builtin(self):\n        with self.assertRaisesRegex(RuntimeError, 'object has no attribute or method'):\n            @torch.jit.script\n            def unknown_builtin(x):\n                return x.splork(3)\n\n    def test_return_tuple(self):\n        def return_tuple(x):\n            a = (x, x)\n            return a, x\n        self.checkScript(return_tuple, (torch.rand(4),))\n\n    def test_add_tuple_optional(self):\n        def foo(input: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]) -> Optional[torch.Tensor]:\n            changed_input = input[0] + 1\n            value: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]] = (changed_input,) + input[1:]\n            return value[2]\n        inp: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]] = (torch.rand(4), None, None)\n        self.checkScript(foo, (inp,))\n\n    def test_add_tuple_non_optional(self):\n        def foo(input: Tuple[torch.Tensor, torch.Tensor, torch.Tensor]) -> torch.Tensor:\n            changed_input = input[0] + 1\n            value: Tuple[torch.Tensor, torch.Tensor, torch.Tensor] = (changed_input,) + input[1:]\n            return torch.sum(value[2]) + 4\n        inp: Tuple[torch.Tensor, torch.Tensor, torch.Tensor] = (torch.rand(4), torch.rand(4), torch.rand(4))\n        self.checkScript(foo, (inp,))\n\n    def test_add_tuple_different_types(self):\n        def foo(a: Tuple[int, float], b: Tuple[int]) -> int:\n            c: Tuple[int, float, int] = a + b\n            d: Tuple[int, float, int, int] = c + b\n            return d[3] + 1\n        a = (1, 2.0)\n        b = (3,)\n        self.checkScript(foo, (a, b))\n\n    def test_add_tuple_same_types(self):\n        def foo(a: Tuple[int, int], b: Tuple[int, int, int]) -> int:\n            c: Tuple[int, int, int, int, int] = a + b\n            d: Tuple[int, int, int, int, int, int, int, int] = c + b\n            return d[6] - 2\n        a = (1, 2)\n        b = (3, 4, 5)\n        self.checkScript(foo, (a, b))\n\n    def test_method_no_self(self):\n        with self.assertRaisesRegex(RuntimeError, 'methods must have a self argument'):\n            class MethodNoSelf(torch.jit.ScriptModule):\n                @torch.jit.script_method  # noqa: B902\n                def forward():  # noqa: B902\n                    return torch.zeros(3, 4)\n\n            MethodNoSelf()\n\n    def test_return_stmt_not_at_end(self):\n        def return_stmt(x):\n            if bool(x > 3):\n                return x + 3\n            else:\n                return x\n        self.checkScript(return_stmt, (torch.rand(1),))\n\n    def test_for_in_range(self):\n        def fn():\n            c = 0\n            for i in range(100):\n                c += i\n            return c\n        self.checkScript(fn, ())\n\n    def test_for_in_range_dynamic(self):\n        def fn():\n            c = 0\n            for i in range(100):\n                acc = 0\n                for j in range(i):\n                    acc += j\n                c += acc\n            return c\n        self.checkScript(fn, (), optimize=False)\n\n    def test_for_in_range_ast(self):\n        def test_script_for_in_range_ast():\n            c = 0\n            for i in range(100):\n                acc = 0\n                for j in range(i):\n                    acc += j\n                c += acc\n            return c\n\n        self.checkScript(test_script_for_in_range_ast, ())\n\n    def test_for_in_range_if_ast(self):\n        @torch.jit.script\n        def test_script_for_in_range_if_ast(x):\n            output = x\n            for i in range(20):\n                if i == 0:\n                    output = x.unsqueeze(0)\n                else:\n                    output = torch.cat((output, x.unsqueeze(0)), dim=0)\n            return output\n        inputs = self._make_scalar_vars([0], torch.int64)\n\n        self.assertEqual(test_script_for_in_range_if_ast(*inputs).shape[0], 20)\n\n    def test_for_in_range_start_end(self):\n        def fn():\n            x = 0\n            for i in range(7, 100):\n                x += i\n            return x\n        self.checkScript(fn, ())\n\n    def test_for_in_range_start_end_step(self):\n        def fn(start, end, step):\n            # type: (int, int, int) -> int\n            x = 0\n            for i in range(start, end, step):\n                x += i\n            return x\n\n        self.checkScript(fn, (7, 100, 7))\n        self.checkScript(fn, (7, 100, -7))\n        self.checkScript(fn, (2, -11, -3))\n        self.checkScript(fn, (2, -11, 3))\n        self.checkScript(fn, (2, 10, 3))\n        self.checkScript(fn, (-2, -10, -10))\n\n    def test_for_in_range_zero_step(self):\n        @torch.jit.script\n        def fn():\n            x = 0\n            for i in range(2, -11, 0):\n                x += i\n            return x\n\n        with self.assertRaisesRegex(RuntimeError, \"must not be zero\"):\n            fn()\n\n    def test_range_args(self):\n        with self.assertRaisesRegex(RuntimeError, r'range expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def range_no_arg(x):\n                for _ in range():\n                    x += 1\n                return x\n        with self.assertRaisesRegex(RuntimeError, r'found float'):\n            @torch.jit.script\n            def range_non_float():\n                for i in range(.5):\n                    print(i)\n\n    def test_parse_empty_tuple_annotation(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : Tuple[()]) -> Tuple[()]:\n                return x\n        ''')\n\n        foo_code = cu.find_function('foo').code\n        FileCheck().check(\"Tuple[()]\").check(\"Tuple[()]\").run(foo_code)\n\n    def test_parse_empty_tuple_annotation_element_error(self):\n        with self.assertRaisesRegex(\n                RuntimeError, 'Tuple literal in Tuple type annotation must not have any elements'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tuple[(int,)]) -> Tuple[(int,)]:\n                    return x\n            ''')\n\n    def test_parse_none_type_annotation(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : NoneType) -> NoneType:\n                return x\n        ''')\n\n        foo_code = cu.find_function('foo').code\n        FileCheck().check(\": NoneType\").check(\"-> NoneType\").run(foo_code)\n\n    def test_empty_tuple_str(self):\n        empty_tuple_type = torch._C.TupleType([])\n        g = {'Tuple' : typing.Tuple}\n        python_type = eval(empty_tuple_type.annotation_str, g)\n        assert python_type is typing.Tuple[()]\n\n    def test_none_type_str(self):\n        none_type = torch._C.NoneType.get()\n        g = {'NoneType' : type(None)}\n        python_type = eval(none_type.annotation_str, g)\n        assert python_type is type(None)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_zip_enumerate_modulelist(self):\n        class Sub(torch.nn.Module):\n            def __init__(self):\n                super(Sub, self).__init__()\n\n            def forward(self, thing):\n                return thing - 2\n\n        class Double(torch.nn.Module):\n            def __init__(self):\n                super(Double, self).__init__()\n\n            def forward(self, thing):\n                return thing * 2\n\n        # zipping over two\n        class ZipModLists(torch.nn.Module):\n            def __init__(self, mods, mods2):\n                super(ZipModLists, self).__init__()\n                self.mods = mods\n                self.mods2 = mods2\n\n            def forward(self, x):\n                iter = 0\n                for mod1, mod2 in zip(self.mods, self.mods2):\n                    x = mod2(mod1(x))\n                    iter += 1\n                return x, iter\n\n        class ZipWithValues(torch.nn.Module):\n            __constants__ = ['tup_larger', 'tup_smaller']\n\n            def __init__(self, mods, mods2):\n                super(ZipWithValues, self).__init__()\n                self.mods = mods\n                self.mods2 = mods2\n                self.tup_larger = list(range(len(mods2) + 1))\n                self.tup_smaller = list(range(max(len(mods2) + 1, 1)))\n\n            def forward(self, x):\n                iter = 0\n                x2 = x\n                for val, mod1, mod2 in zip(self.tup_larger, self.mods, self.mods2):\n                    x = mod2(mod1(x)) + val\n                    iter += 1\n                for val, mod1, mod2 in zip(self.tup_smaller, self.mods, self.mods2):\n                    x2 = mod2(mod1(x2)) + val\n                    iter += 1\n                return x, iter\n\n        mods = nn.ModuleList([Double()]), nn.ModuleList([Double(), Sub(), Sub()]), nn.ModuleList([Sub(), Double()])\n        for i in range(len(mods)):\n            for j in range(len(mods)):\n                mod = ZipModLists(mods[i], mods[j])\n                self.checkModule(mod, (torch.tensor(.5),))\n                mod2 = ZipWithValues(mods[i], mods[j])\n                self.checkModule(mod2, (torch.tensor(.5),))\n\n\n    def test_enumerate_modlist_range(self):\n        class Double(torch.nn.Module):\n            def forward(self, thing):\n                return thing * 2\n\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.mods = nn.ModuleList([Double(), Double()])\n\n            def forward(self, x):\n                x2 = x\n                iter = 0\n                for val, mod in enumerate(self.mods):\n                    x2 = mod(x2) * val\n                    iter += 1\n                return iter, x, x2\n\n        self.checkModule(Mod(), (torch.tensor(.5),))\n\n        # variable length, modulelist\n        class Mod2(Mod):\n            def forward(self, x):\n                for val, mod in zip(range(int(x)), self.mods):\n                    x = mod(x) * val\n                return x\n\n        with self.assertRaisesRegex(Exception, \"that does not have a statically determinable length\"):\n            torch.jit.script(Mod2())\n\n        # modulelist, variable length\n        class Mod3(Mod):\n            def forward(self, x):\n                for val, mod in zip(self.mods, range(int(x))):\n                    x = mod(x) * val\n                return x\n\n        with self.assertRaisesRegex(Exception, \"that does not have a statically determinable length\"):\n            torch.jit.script(Mod3())\n\n    def test_for_in_enumerate(self):\n        def fn(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn, ([1, 2, 3, 4, 5],))\n\n        def fn_enumerate_start_arg(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x, 1):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_start_arg, ([1, 2, 3, 4, 5],))\n\n        def fn_enumerate_start_kwarg(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x, start=1):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_start_kwarg, ([1, 2, 3, 4, 5],))\n\n        def fn_nested_enumerate(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, (j, v)) in enumerate(enumerate(x)):\n                sum += i * j * v\n\n            return sum\n\n        self.checkScript(fn_nested_enumerate, ([1, 2, 3, 4, 5],))\n\n        with self.assertRaisesRegex(RuntimeError, r'enumerate expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def enumerate_no_arg(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in enumerate():\n                    sum += 1\n\n                return sum\n\n        with self.assertRaisesRegex(RuntimeError, r'enumerate expected at most 2 arguments, got 3'):\n            @torch.jit.script\n            def enumerate_too_many_args(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in enumerate(x, x, x):\n                    sum += 1\n\n                return sum\n\n    def test_list_comprehension_modulelist(self):\n        class Inner(torch.nn.Module):\n            def forward(self, x):\n                return x + 10\n\n        class M(torch.nn.Module):\n            def __init__(self, mod_list):\n                super(M, self).__init__()\n                self.module_list = mod_list\n\n            def forward(self, x):\n                out = torch.jit.annotate(List[Tensor], [mod(x) for mod in self.module_list])\n                return out\n\n        mod = M(nn.ModuleList([Inner(), Inner()]))\n        self.checkModule(mod, (torch.tensor(3),))\n\n        mod = M(nn.ModuleList([]))\n        torch.jit.script(mod)\n\n        class M2(M):\n            def __init__(self, mod_list):\n                super(M2, self).__init__(mod_list)\n\n            def forward(self, x):\n                out = [mod(x) for mod in self.module_list]\n                return out\n\n        mod = M2(nn.ModuleList([Inner(), Inner()]))\n        self.checkModule(mod, (torch.tensor(3),))\n\n        mod = M2(nn.ModuleList([]))\n        # defaults to List of Tensor for empty modulelist\n        self.assertEqual(torch.jit.script(mod)(torch.tensor(.5)), [])\n\n        def bad_type_annotation():\n            out = torch.jit.annotate(int, [x for x in [1, 2, 3]])  # noqa: C416\n            return out\n\n        with self.assertRaisesRegex(Exception, \"Expected an annotation\"\n                                    \" of type List\"):\n            torch.jit.script(bad_type_annotation)\n\n    def test_list_comprehension_variable_write(self):\n        # i in comprehension doesn't write to function scope\n        def foo():\n            i = 1\n            x = [i if i != 5 else 3 for i in range(7)]  # noqa: C416\n            return i, x\n\n        self.assertEqual(foo(), torch.jit.script(foo)())\n\n    def test_for_in_zip(self):\n        def fn(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, j) in zip(x, y):\n                sum += i * j\n\n            return sum\n\n        self.checkScript(fn, ([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]))\n\n        def fn_multi_inputs(x, y, z):\n            # type: (List[int], List[int], List[int]) -> int\n            sum = 0\n            for (i, j, k) in zip(x, y, z):\n                sum += i * j * k\n\n            return sum\n\n        self.checkScript(fn_multi_inputs, ([1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]))\n\n        def fn_nested_zip(x, y, z):\n            # type: (List[int], List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, k)) in zip(x, zip(y, z)):\n                sum += i * j * k\n\n            return sum\n\n        self.checkScript(fn_multi_inputs, ([1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]))\n\n        with self.assertRaisesRegex(RuntimeError, r'zip expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def zip_no_arg(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in zip():\n                    sum += 1\n\n                return sum\n\n        with self.assertRaisesRegex(RuntimeError, r'too many values to unpack: need 2 but found 3'):\n            @torch.jit.script\n            def fn_nested_zip_wrong_target_assign(x, y, z):\n                # type: (List[int], List[int], List[int]) -> int\n                sum = 0\n                for (i, (j, k)) in zip(x, y, z):\n                    sum += i * j * k\n\n                return sum\n\n    def test_for_in_zip_enumerate(self):\n        def fn_zip_enumerate(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, v), k) in zip(x, enumerate(y), range(0, 100)):\n                sum += i * j * v * k\n\n            return sum\n\n        self.checkScript(fn_zip_enumerate, ([1, 2, 3, 4], [2, 3, 4, 5]))\n\n        def fn_enumerate_zip(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, v)) in enumerate(zip(x, y)):\n                sum += i * j * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_zip, ([1, 2, 3, 4], [2, 3, 4, 5]))\n\n    def test_for_in_tensors(self):\n        def test_sizes(x):\n            sumz = 0\n            for s in x:\n                sumz += 1\n            return sumz\n        self.checkScript(test_sizes, (torch.rand(5, 4, 3, 2, 1),))\n        self.checkScript(test_sizes, (torch.rand(777),))\n        self.checkScript(test_sizes, (torch.rand(0),))\n\n    def test_for_in_tensors_rank0(self):\n        with self.assertRaisesRegex(RuntimeError, \"of a 0-d tensor\"):\n            @torch.jit.script\n            def test_sizes(x):\n                sumz = 0\n                for s in x:\n                    sumz += 1\n                return sumz\n\n            test_sizes(torch.tensor(1))\n\n    def test_for_in_tensors_fail_scalar(self):\n        with self.assertRaisesRegex(RuntimeError, \"'float' object is not iterable\"):\n            @torch.jit.script\n            def test_sizes(x):\n                # type: (float) -> int\n                sumz = 0\n                for s in x:\n                    sumz += 1\n                return sumz\n\n            test_sizes(0.0)\n\n    def test_for_in_tensors_nested(self):\n        def test_sizes(x):\n            sumz = 0\n            for n in x:\n                for t in n:\n                    sumz += 1\n            return sumz\n\n        self.checkScript(test_sizes, (torch.rand(5, 4, 3, 2, 1),))\n\n    # to avoid defining sum_list in multiple tests\n    def get_sum_list_fn(self):\n        def sum_list(a):\n            # type: (List[int]) -> int\n            sum = 0\n            for i in a:\n                sum += i\n\n            return sum\n\n        return sum_list\n\n    def test_sum_list_diff_elms(self):\n        self.checkScript(self.get_sum_list_fn(), ([1, 2, 3, 4, 5],))\n\n    def test_sum_list_empty(self):\n        self.checkScript(self.get_sum_list_fn(), ([],))\n\n    def test_sum_list_one(self):\n        self.checkScript(self.get_sum_list_fn(), ([1],))\n\n    def test_sum_list_literal(self):\n\n        def sum_list():\n            # type: () -> int\n            sum = 0\n            for i in [1, 2, 3, 4, 5]:\n                sum += i\n\n            return sum\n\n        self.checkScript(sum_list, ())\n\n    def test_sum_list_wrong_type(self):\n\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not iterable\"):\n            @torch.jit.script\n            def sum_list(a):\n                # type: (int) -> int\n                sum = 0\n                for i in a:  # noqa: T484\n                    sum += i\n\n                return sum\n\n            sum_list(1)\n\n    def test_list_iterables(self):\n        with self.assertRaisesRegex(RuntimeError, 'List of iterables is not supported currently'):\n            cu = torch.jit.CompilationUnit('''\n            def list_iterables(x):\n                for i, j in [2, 3, 4], [5, 6, 7]:\n                    x += i\n                    x += j\n                return x\n            ''')\n\n    def test_for_in_string(self):\n        def test_strings(x):\n            # type: (str) -> str\n            reverse = \"\"\n            for c in x:\n                reverse = c + reverse\n            return reverse\n\n        self.checkScript(test_strings, (\"hello\",))\n        self.checkScript(test_strings, (\"\",))\n\n        def test_list_strings(x):\n            # type: (List[str]) -> str\n            result = \"\"\n            for sub_str in x:\n                result += sub_str\n            return result\n\n        self.checkScript(test_list_strings, ([\"hello\", \"world\"],))\n        self.checkScript(test_list_strings, ([\"hello\", \" \", \"world\", \"\"],))\n\n    def test_for_in_dict(self):\n        def test_dicts(x):\n            # type: (Dict[str, int]) -> int\n            sum = 0\n            for key in x:\n                sum += x[key]\n            return sum\n\n        self.checkScript(test_dicts, ({\"a\": 1, \"b\": 2, \"c\": 3},))\n\n        def test_dict_keys_values(x):\n            # type: (Dict[str, int]) -> Tuple[str, int]\n            key_str = \"\"\n            sum = 0\n            for key in x.keys():\n                key_str += key\n            for val in x.values():\n                sum += val\n            return key_str, sum\n\n        self.checkScript(test_dicts, ({\"a\": 1, \"b\": 2, \"c\": 3},))\n\n    def test_for_tuple_unpack(self):\n        def for_tuple_unpack(x, y):\n            for i, j in [[3, 4], [5, 6], [7, 8]]:\n                x += i\n                y += j\n            return x, y\n\n        self.checkScript(for_tuple_unpack, (torch.tensor(3), torch.tensor(5)))\n\n        def nested_tuple_unpack(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for i, (j, k), v in zip(x, enumerate(x), y):\n                sum += i + j + k + v\n            return sum\n\n        self.checkScript(nested_tuple_unpack, ([1, 3, 5], [2, 4, 6]))\n\n    def test_for_tuple_assign(self):\n        def test_simple_assign(x):\n            # type: (Tuple[int, float]) -> float\n            sum = 0.0\n            for a in x:\n                sum += float(a)\n            return sum\n\n        self.checkScript(test_simple_assign, ((1, 2.5),))\n\n        def test_tuple_assign(x):\n            # type: (Tuple[Tuple[int, int], Tuple[int, int]]) -> int\n            sum = 0\n            for a in x:\n                sum += a[0]\n                sum += a[1]\n            return sum\n\n        self.checkScript(test_tuple_assign, (((1, 2), (4, 7)), ))\n\n    def test_single_starred_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'A Starred expression may only appear on the lhs within the presence'\n                                                  ' of another non-starred expression'):\n            cu = torch.jit.CompilationUnit('''\n            def single_starred_lhs(x):\n                a = (x, x, x)\n                *b, = a\n                return b\n            ''')\n\n    def test_singleton_tuple_unpack(self):\n        def foo(a):\n            b, = (a,)\n            return b + 1\n        self.checkScript(foo, (torch.rand(3),))\n\n    def test_tuple_assignments(self):\n        def var_tuple_assign(x, y):\n            # type: (Tuple[Tensor, Tensor], Tensor) -> Tensor\n            (a, b), c = x, y\n            return a + b + c\n\n        tuple_inputs = (torch.randn(1, 4), torch.randn(3, 4))\n        self.checkScript(var_tuple_assign, (tuple_inputs, torch.randn(3, 4)))\n\n        def nested_tuple_assign(x, y, z):\n            # type: (int, Tuple[int, Tuple[int, int]], Tuple[int, int]) -> int\n            a, (b, (c, d)), (e, f) = x, y, z\n            return a + b + c + d + e + f\n\n        self.checkScript(nested_tuple_assign, ((1, (2, (3, 4)), (5, 6))))\n\n        def subscript_tuple_assign(a, x, i):\n            # type: (List[int], Tensor, int) -> Tuple[int, Tensor, int]\n            a[i], (x[i], b) = 1, (2, 3)\n            return a[i] + 1, x + 5, b\n\n        self.checkScript(subscript_tuple_assign, ([12, 7, 9, 11], torch.tensor((3, 13, 17)), 0))\n\n        def star_tuple_assign():\n            # type: () -> Tuple[int, int, Tuple[int, int], Tuple[int, int]]\n            a, (b, *c), *d = 1, (2, 3, 4), 5, 6\n            return a, b, c, d\n\n        self.checkScript(star_tuple_assign, ())\n\n        def subscript_tuple_augmented_assign(a):\n            # type: (Tuple[int, int]) -> Tuple[int, int]\n            a[0] += 1\n            return a\n\n        with self.assertRaisesRegex(RuntimeError, 'does not support augmented assign'):\n            scripted_aug_assign = torch.jit.script(subscript_tuple_augmented_assign)\n\n        class AttrTupleAssignmentTestClass:\n            def __init__(self, a: int, b: int):\n                self.a = a\n                self.b = b\n\n            def set_ab(self, a: int, b: int):\n                self.a, self.b = (a, b)\n\n            def get(self) -> Tuple[int, int]:\n                return (self.a, self.b)\n\n        make_global(AttrTupleAssignmentTestClass)\n\n        @torch.jit.script\n        def attr_tuple_assignment(o: AttrTupleAssignmentTestClass, a: int, b: int):\n            o.set_ab(a, b)\n            return o\n\n        o = AttrTupleAssignmentTestClass(1, 2)\n        self.assertEqual(attr_tuple_assignment(o, 3, 4).get(), (3, 4))\n\n    def test_multiple_assign(self):\n        def test():\n            a = b, c = d, f = (1, 1)\n\n            # side effect\n            ten = torch.tensor(1)\n            ten1 = ten2 = ten.add_(1)\n\n            # ordering\n            x = 1\n            y = 3\n            x, y = y, x + y\n\n            return a, b, c, d, f, ten, ten1, ten2, x, y\n\n        self.checkScript(test, ())\n\n    def test_multi_reduction(self):\n        with self.assertRaisesRegex(\n                RuntimeError,\n                'augmented assignment can only have one LHS expression'):\n            cu = torch.jit.CompilationUnit('''\n            def multi_reduction(x):\n                a, b += x\n                return a, b\n            ''')\n\n    def test_invalid_call_arguments(self):\n        with self.assertRaisesRegex(RuntimeError, 'but instead found type '):\n            @torch.jit.script\n            def invalid_call_arguments(x):\n                return torch.unsqueeze(3, 4, 5, 6, 7, 8)\n\n    def test_invalid_lhs_assignment(self):\n        with self.assertRaisesRegex(RuntimeError, 'unexpected expression'):\n            cu = torch.jit.CompilationUnit('''\n            def invalid_lhs_assignment(x):\n                x + 1 = x\n                return x\n            ''')\n\n    def test_multi_starred_expr_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Only one starred expression is allowed on the lhs'):\n            cu = torch.jit.CompilationUnit('''\n            def multi_starred_expr_lhs():\n                a, *b, *c = [1, 2, 3, 4, 5, 6]\n                return a\n            ''')\n\n    def test_pack_tuple_into_non_var(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot pack a tuple into a non-variable'):\n            cu = torch.jit.CompilationUnit('''\n            def pack_tuple_into_non_var(x):\n                a, *1 = (3, 4, 5)\n                return x\n            ''')\n\n    def test_print_kwargs(self):\n        with self.assertRaisesRegex(RuntimeError, 'print doesn\\'t accept any keyword arguments'):\n            cu = torch.jit.CompilationUnit('''\n            def print_kwargs(x):\n                print(x, flush=True)\n                return x\n            ''')\n\n    def test_builtin_use_as_value(self):\n        with self.assertRaisesRegex(RuntimeError, 'builtin cannot be used as a value'):\n            @torch.jit.script\n            def builtin_use_as_value(x):\n                return x.unsqueeze\n\n    def test_wrong_use_as_tuple(self):\n        with self.assertRaisesRegex(RuntimeError, 'cannot be used as a tuple'):\n            def test_fn():\n                return 3\n\n            @torch.jit.script\n            def wrong_use_as_tuple(self):\n                a, b = test_fn\n                return a\n\n    def test_wrong_attr_lookup(self):\n        with self.assertRaisesRegex(RuntimeError, 'attribute lookup is not defined on builtin'):\n            @torch.jit.script\n            def wrong_attr_lookup(self, x):\n                a = x.unsqueeze.myattr\n                return a\n\n    def test_wrong_use_as_callable(self):\n        with self.assertRaisesRegex(RuntimeError, 'cannot call a value'):\n            @torch.jit.script\n            def wrong_use_as_callable(x):\n                return x(3, 4, 5)\n\n    def test_python_val_doesnt_have_attr(self):\n        with self.assertRaisesRegex(RuntimeError, 'object has no attribute abcd'):\n\n            @torch.jit.script\n            def python_val_doesnt_have_attr():\n                # this has to be a module otherwise attr lookup would not be\n                # allowed in the first place\n                return shutil.abcd\n\n    def test_wrong_module_attr_lookup(self):\n        with self.assertRaisesRegex(RuntimeError, 'python value of type \\'type\\' cannot be used as a value'):\n            import io\n\n            @torch.jit.script\n            def wrong_module_attr_lookup():\n                return io.BytesIO\n\n    def test_wrong_method_call_inputs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Argument y not provided'):\n            class SomeModule(torch.jit.ScriptModule):\n\n                @torch.jit.script_method\n                def foo(self, x, y):\n                    return x\n\n                @torch.jit.script_method\n                def forward(self, x, y):\n                    return self.foo(x)\n            SomeModule()\n\n    def test_single_starred_expr_for_loop(self):\n        with self.assertRaisesRegex(RuntimeError, 'A Starred expression may only appear'):\n            cu = torch.jit.CompilationUnit('''\n            def test():\n                x = 0\n                for *a in [1, 2, 3]:\n                    x = x + 1\n                return x\n            ''')\n\n    def test_call_ge(self):\n        with self.assertRaisesRegex(RuntimeError, 'Expected at most 1 arguments but found 3'):\n            @_trace(torch.zeros(1, 2, 3))\n            def foo(x):\n                return x\n\n            @torch.jit.script\n            def test_fn():\n                return foo(torch.full([1], 1), torch.full([1], 2), torch.full([1], 3))\n\n    def test_wrong_return_type(self):\n        with self.assertRaisesRegex(RuntimeError, 'but instead got value of type tuple'):\n            @torch.jit.ignore\n            def somefunc():\n                # type: () -> Tuple[Tuple[Tensor, Tensor]]\n                return torch.zeros(3, 4), torch.zeros(4, 5)  # noqa: T484\n\n            @torch.jit.script\n            def wrong_return_type():\n                return somefunc()\n            wrong_return_type()\n\n    # Tests for calling between different front-end modes\n    def test_call_python_fn_from_tracing_fn(self):\n        def python_fn(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return python_fn(x) + 1\n\n        # The neg op in the python function should be properly inlined to the\n        # graph\n        FileCheck().check(\"aten::neg\").run(str(traced_fn.graph))\n\n    def test_call_python_mod_from_tracing_fn(self):\n        class PythonMod(torch.nn.Module):\n            def __init__(self):\n                super(PythonMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3), requires_grad=False)\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        pm = PythonMod()\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return pm(x) + 1.0\n\n        # Note: the parameter self.param from the Python module is inlined\n        # into the graph\n        self.assertTrue(len(list(traced_fn.graph.inputs())) == 1)\n        FileCheck().check(\"aten::mm\").check(\"aten::add\").run(str(traced_fn.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_traced_fn_from_tracing_fn(self):\n        @_trace(torch.rand(3, 4))\n        def traced_fn1(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return traced_fn1(x) + 1\n\n        FileCheck().check(\"traced_fn\").check(\"prim::CallFunction\").check(\"aten::add\") \\\n            .run(str(traced_fn.graph))\n\n    @unittest.skip(\"error in first class mode\")\n    def test_call_traced_mod_from_tracing_fn(self):\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3), requires_grad=False)\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        with self.assertRaisesRegex(RuntimeError, \"must be registered as submodules\"):\n            @_trace(torch.rand(3, 4))\n            def traced_fn(x):\n                return tm(x) + 1.0\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_tracing_fn(self):\n        @torch.jit.script\n        def script_fn(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return script_fn(x) + 1\n\n        FileCheck().check(\"prim::CallFunction\").check(\"aten::add\").run(str(traced_fn.graph))\n\n    @unittest.skip(\"error in first class mode\")\n    def test_call_script_mod_from_tracing_fn(self):\n        with self.assertRaisesRegex(RuntimeError, \"must be registered as submodules\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n                    self.param = torch.nn.Parameter(torch.rand(3, 4), requires_grad=False)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _i in range(4):\n                        x += self.param\n                    return x\n\n            sm = ScriptMod()\n\n            @_trace(torch.rand(3, 4))\n            def traced_fn(x):\n                return sm(x) + 1.0\n\n\n    def test_call_python_fn_from_traced_module(self):\n        def python_fn(x):\n            return torch.neg(x)\n\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            def forward(self, x):\n                return torch.mm(python_fn(x), self.param)\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        # Note: parameter self.param from the traced module should appear as\n        # an input to the graph and the neg op from the Python function should\n        # be properly inlined\n        self.assertTrue(len(list(tm.graph.inputs())) == 2)\n        FileCheck().check(\"aten::neg\").check(\"aten::mm\").run(str(tm.graph))\n\n    def test_call_python_mod_from_traced_module(self):\n        class PythonModule(torch.nn.Module):\n            def __init__(self):\n                super(PythonModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(5, 7))\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 5))\n                self.mod = PythonModule()\n\n            def forward(self, x):\n                return self.mod(torch.mm(x, self.param)) + 1.0\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        FileCheck().check_not(\"value=<Tensor>\").check(\"aten::mm\")\\\n            .check(\"prim::CallMethod[name=\\\"forward\\\"]\").check(\"aten::add\") \\\n            .run(str(tm.graph))\n        FileCheck().check(\"aten::mm\").run(str(tm.mod.graph))\n\n    def test_op_dtype(self):\n\n        def check_equal_and_dtype(a, b):\n            self.assertEqual(a, b)\n            self.assertEqual(a.dtype, b.dtype)\n\n        def fn():\n            a = torch.arange(10)\n            b = torch.arange(10, dtype=torch.float)\n            c = torch.arange(1, 10, 2)\n            d = torch.arange(1, 10, 2, dtype=torch.float)\n            e = torch.arange(1, 10., 2)\n            f = torch.arange(1, 10., 2, dtype=torch.float)\n            return a, b, c, d, e, f\n\n        scripted_fn = torch.jit.script(fn)\n        eager_out = fn()\n        script_out = scripted_fn()\n        for a, b in zip(eager_out, script_out):\n            check_equal_and_dtype(a, b)\n\n    def test_floor_div(self):\n        @torch.jit.script\n        def foo(a, b):\n            # type: (int, int) -> int\n            return a // b\n        for i in range(-8, 8):\n            for j in range(-8, 8):\n                if j != 0:\n                    self.assertEqual(foo(i, j), i // j)\n\n    def test_floordiv(self):\n        funcs_template = dedent('''\n        def fn():\n            ten = {a_construct}\n            ten_or_scalar = {b_construct}\n            return ten // ten_or_scalar, torch.floor_divide(ten, ten_or_scalar)\n        ''')\n\n        lhs = [\"torch.tensor([5.5, 3.2])\", \"torch.tensor([2, 2])\", \"torch.tensor([3, 2])\"]\n        rhs = [\"1.5\", \"2\", \"4\", \"1.1\"] + lhs\n        for tensor in lhs:\n            for tensor_or_scalar in rhs:\n                funcs_str = funcs_template.format(a_construct=tensor, b_construct=tensor_or_scalar)\n                scope = {}\n                execWrapper(funcs_str, globals(), scope)\n                cu = torch.jit.CompilationUnit(funcs_str)\n                f_script = cu.fn\n                f = scope['fn']\n                self.assertEqual(f_script(), f())\n\n    def test_call_python_fn_from_script_fn(self):\n        @torch.jit.ignore\n        def python_fn(x):\n            return torch.neg(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            return python_fn(x) + 1\n\n        # Note: the call to python_fn appears as `^python_fn()` and is called\n        # as a PythonOp in the interpreter\n        a = torch.tensor(1)\n        self.assertEqual(script_fn(a), torch.tensor(0))\n        FileCheck().check(\"python_fn\").run(str(script_fn.graph))\n\n    def test_call_python_mod_from_script_fn(self):\n        class PythonModule(torch.nn.Module):\n            def __init__(self):\n                super(PythonModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(5, 7))\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        pm = PythonModule()\n\n        @torch.jit.script\n        def script_fn(x):\n            return pm(x) + 1\n\n        # Note: call to pm(x) appears as ^<python_value>() in the trace.\n        # Parameters are NOT inlined.\n        FileCheck().check(\"python_value\").check(\"aten::add\").run(str(script_fn.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_script_fn(self):\n        @torch.jit.script\n        def script_fn1(x):\n            return torch.neg(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            return script_fn1(x) + 1\n\n        FileCheck().check(\"prim::CallFunction\").run(str(script_fn.graph))\n\n    def test_call_script_mod_from_script_fn(self):\n        with self.assertRaisesRegex(RuntimeError, \"Cannot call a ScriptModule that is not a submodule of the caller\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    return torch.mm(x, torch.zeros([4, 3]))\n\n            sm = ScriptMod()\n\n            @torch.jit.script\n            def script_fn(x):\n                return sm(x) + 1\n\n    def test_call_python_fn_from_script_module(self):\n        @torch.jit.ignore\n        def python_fn(x):\n            return torch.neg(x)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return python_fn(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        FileCheck().check(\"aten::mm\").check(\"python_fn\") \\\n            .run(str(sm.forward.graph))\n\n    def test_call_python_mod_from_script_module(self):\n        class PythonMod(torch.nn.Module):\n            def __init__(self):\n                super(PythonMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(3, 5))\n\n            @torch.jit.ignore\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n                self.pm = PythonMod()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.pm(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        # Note: the call into PythonMod appears as ^forward(). Parameters\n        # are NOT inlined\n        FileCheck().check(\"aten::mm\").check(\"forward\").run(str(sm.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_script_module(self):\n        @torch.jit.script\n        def script_fn(x):\n            return torch.neg(x)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return script_fn(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        graph = (sm.forward.graph)\n        FileCheck().check(\"aten::mm\").check(\"prim::CallFunction\").run(str(graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_mod_from_script_module(self):\n        class ScriptMod1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod1, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(3, 5))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n                self.tm = ScriptMod1()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.tm(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        # Note: the parameters from both modules should appear in the flattened\n        # input list to the graph. The mm op from ScriptMod1 should be properly\n        # inlined\n        # 3 % values in graph input lists, two mms in body\n        FileCheck().check_count('%', 3).check(\":\").check_count(\"mm\", 1).check(\"prim::CallMethod\").run(str(sm.graph))\n\n    def test_module_with_params_called_fails(self):\n        with self.assertRaisesRegex(RuntimeError, \"Cannot call a ScriptModule that is not a submodule of the caller\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n                    self.param = torch.nn.Parameter(torch.rand(3, 3))\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    return torch.mm(x, self.param)\n\n            sm = ScriptMod()\n\n            @torch.jit.script\n            def some_func(x):\n                return sm(x)\n\n    def test_tuple_index_to_list(self):\n        def test_non_constant_input(a):\n            # type: (bool) -> int\n            if a:\n                b = 1\n            else:\n                b = 0\n            c = (0, 1)\n            return c[b]\n\n        self.checkScript(test_non_constant_input, (True,))\n        self.checkScript(test_non_constant_input, (False,))\n\n        with self.assertRaisesRegex(RuntimeError, \"because we cannot resolve the output type\"):\n            @torch.jit.script\n            def test_non_constant_input(a):\n                # type: (bool) -> None\n                if a:\n                    b = 1\n                else:\n                    b = 0\n                c = (0, 1.1)\n                print(c[b])\n\n    def test_tuple_indexing(self):\n        def tuple_index(a):\n            if bool(a):\n                b = (1, 2)\n            else:\n                b = (0, 2)\n            return b[-2], b[1]\n\n        self.checkScript(tuple_index, (torch.tensor([0]),))\n        self.checkScript(tuple_index, (torch.tensor([1]),))\n        self.checkScript(tuple_index, (torch.tensor([1]),), optimize=True)\n        tuple_comp = torch.jit.script(tuple_index)\n        FileCheck().check_count(\"TupleIndex\", 2, exactly=True).run(str(tuple_comp.graph))\n\n        with self.assertRaisesRegex(RuntimeError, \"index must be an integer\"):\n            @torch.jit.script\n            def test_indexing_float():\n                c = (1, 2)\n                return c[0.1]\n\n        def test_indexing_out_of_bounds_pos():\n            c = (1, 2)\n            return c[2]\n\n        self.checkScriptRaisesRegex(test_indexing_out_of_bounds_pos, (), Exception,\n                                    \"out of range\")\n\n        def test_indexing_out_of_bounds_neg():\n            c = (1, 2)\n            return c[-3]\n\n        self.checkScriptRaisesRegex(test_indexing_out_of_bounds_pos, (), Exception,\n                                    \"out of range\")\n\n        def negative_index():\n            tup = (1, 2, 3, 4)\n            return tup[-1]\n\n        self.checkScript(negative_index, [])\n\n        def really_negative_index():\n            tup = (1, 2, 3, 4)\n            return tup[-100]\n\n        self.checkScriptRaisesRegex(really_negative_index, [], Exception, \"index out of range\")\n\n        def negative_slice():\n            tup = (1, 2, 3, 4)\n            return tup[-3:4]\n\n        self.checkScript(negative_slice, [])\n\n        def really_slice_out_of_bounds():\n            tup = (1, 2, 3, 4)\n            return tup[-300:4000]\n\n        self.checkScript(really_slice_out_of_bounds, [])\n\n    def test_namedtuple_attr(self):\n        def f(x):\n            return x.max(dim=1).indices + torch.max(x, dim=1).indices\n\n        self.checkScript(f, (torch.rand(20, 20, 20),), optimize=True)\n\n        with self.assertRaisesRegex(RuntimeError, \"object has no attribute or method\"):\n            @torch.jit.script\n            def g1(x):\n                return x.max(dim=1).unknown_symbol\n\n        with self.assertRaisesRegex(RuntimeError, \"object has no attribute or method\"):\n            @torch.jit.script\n            def g2(x):\n                print((x, x, x).__doc__)\n                return x\n\n    def test_tuple_len(self):\n        @torch.jit.script\n        def foo():\n            return len((1, \"str\", None))\n\n        self.assertEqual(foo(), 3)\n\n        @torch.jit.script\n        def test_indexing_end_out_of_bounds():\n            c = (1, 2)\n            return c[2:10]\n\n        self.assertEqual(test_indexing_end_out_of_bounds(), ())\n\n    def test_lower_nested_tuples(self):\n        @torch.jit.script\n        def test():\n            return ((1, 2), 3)\n\n        self.run_pass('constant_propagation', test.graph)\n        FileCheck().check(\"prim::Constant\").check_not(\"TupleConstruct\").run(test.graph)\n        # fails if a tuple can't be lowered\n        self.run_pass('lower_all_tuples', test.graph)\n\n    def test_unwrap_optional_builtin(self):\n        def test(x):\n            # type: (Optional[int]) -> int\n            x = torch.jit._unwrap_optional(x)\n            x = x + x  # noqa: T484\n            return x\n\n        self.checkScript(test, (3,))\n\n        with self.assertRaisesRegex(AssertionError, \"Unwrapping null optional\"):\n            test(None)\n\n        test_script = torch.jit.script(test)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            test_script(None)\n\n        @torch.jit.script\n        def test_test():\n            return torch.jit._unwrap_optional(1)\n\n        with self.assertRaisesRegex(RuntimeError, r\"could not be inferred from actual type None\"):\n            @torch.jit.script\n            def test_no_type():\n                # type: () -> int\n                return torch.jit._unwrap_optional(None)\n\n    def test_indexing_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not subscriptable\"):\n            @torch.jit.script\n            def test_wrong_type():\n                a = 8\n                return a[0]\n\n    def test_unsupported_builtin_error(self):\n        with self.assertRaisesRegex(RuntimeError,\n                                    \"Python builtin <built-in function hypot> is currently\"):\n            @torch.jit.script\n            def test_unsupported(a):\n                return math.hypot(a, 2.0)\n\n    def test_annotated_script_fn(self):\n        @torch.jit.script\n        def foo(x, y, z):\n            # type: (Tensor, Tuple[Tensor, Tensor, Tensor], Tuple[Tensor, Tuple[Tensor, Tensor]]) -> Tensor\n            return x\n\n        self.assertExpected(str(foo.schema))\n\n    def test_annotated_script_method(self):\n        class SM(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, y):\n                # type: (Tuple[Tensor, Tensor], Tensor) -> Tuple[Tensor, Tensor, Tensor]\n                return y, y, y\n\n        sm = SM()\n\n        self.assertExpectedStripMangled(str(sm.forward.schema))\n\n    def test_annotated_script_fn_return_mismatch(self):\n        with self.assertRaisesRegex(RuntimeError, \"but is actually of type\"):\n            @torch.jit.script\n            def return_tup(x):\n                # type: (Tensor) -> Tuple[Tuple[Tensor, Tensor], Tensor]\n                return x, x  # noqa: T484\n\n    def test_annotated_script_fn_arg_mismatch(self):\n        with self.assertRaisesRegex(RuntimeError, r\"Arguments for call are not valid\"):\n            @torch.jit.script\n            def tuple_arg(x):\n                # type: (Tuple[Tensor, Tensor]) -> Tensor\n                return x + 1  # noqa: T484\n\n    def test_script_non_tensor_args_outputs(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Tensor, float) -> float\n            return float((x + y).sum())\n\n        x = torch.ones(2, 2)\n        z = fn(x, 1)\n        self.assertIsInstance(z, float)\n        self.assertEqual(z, 8.)\n\n    @unittest.skip('https://github.com/pytorch/pytorch/issues/9595')\n    def test_inline_and_run_annotated_script_fn(self):\n        @torch.jit.script\n        def to_inline(x, y):\n            # type: (Tuple[Tensor, Tensor], Tensor) -> Tensor\n            return y\n\n        @torch.jit.script\n        def some_func(x):\n            return to_inline((x, x), x)\n\n        x = torch.rand(3, 4)\n        self.assertEqual(some_func(x), x)\n\n    def test_file_format_serialization(self):\n        filename = tempfile.mktemp()\n        writer = torch._C.PyTorchFileWriter(filename)\n        buffers = [os.urandom(size) for size in [random.randint(1, 100) for i in range(20)]]\n        offsets = []\n        for i, buf in enumerate(buffers):\n            writer.write_record(str(i), buf, len(buf))\n            offsets.append(i)\n        serialized_offsets = pickle.dumps(offsets)\n        writer.write_record(\"meta\", serialized_offsets, len(serialized_offsets))\n        writer.write_end_of_file()\n\n        reader = torch._C.PyTorchFileReader(filename)\n        serialized_offsets_read = reader.get_record(\"meta\")\n        parsed_serialized_offsets = pickle.loads(serialized_offsets)\n\n        for i, offset in enumerate(parsed_serialized_offsets):\n            data = reader.get_record(str(offset))\n            assert(data == buffers[i])\n\n    # for each type, the input type annotation and corresponding return type annotation\n    def type_input_return_pairs(self):\n        return [\n            ('Tensor', 'Tensor'),\n            ('torch.Tensor', 'Tensor'),\n            ('str', 'str'),\n            ('int', 'int'),\n            ('bool', 'bool'),\n            ('BroadcastingList3[float]', 'List[float]'),\n            ('BroadcastingList2[int]', 'List[int]'),\n            ('List[int]', 'List[int]'),\n            ('Optional[int]', 'Optional[int]'),\n        ]\n\n    # replacing code input & return type pair\n    def format_code(self, code, pair):\n        return code.format(input=pair[0], output=pair[1])\n\n    # ***** Type annotation tests ****\n    # Test combinations of:\n    # {String frontend, Python AST Frontend}\n    # {Python 3-style type annotations, MyPy-style type comments}\n    # {Script method, Script function}\n\n    #  String frontend , Python 3-style type annotations , Script function\n    def test_annot_string_py3_fn(self):\n        code = '''\n            def foo(x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            cu = torch.jit.CompilationUnit(self.format_code(code, pair))\n            test_str.append(str(cu.foo.schema))\n        self.assertExpected(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , Python 3-style type annotations , Script method\n    def test_annot_string_py3_method(self):\n        class TestModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n        code = '''\n            def foo(self, x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            # clear the class registry as we will be defining foo multiple times\n            jit_utils.clear_class_registry()\n            tm = TestModule()\n            tm.define(self.format_code(code, pair))\n            test_str.append(str(tm.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , MyPy-style type comments , Script function\n    def test_annot_string_mypy_fn(self):\n        code = '''\n            def foo(x, y):\n                # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            cu = torch.jit.CompilationUnit(self.format_code(code, pair))\n            test_str.append(str(cu.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , MyPy-style type comments , Script method\n    def test_annot_string_mypy_method(self):\n        class TestModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n        code = '''\n        def foo(self, x, y):\n            # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n            return x, x\n        '''\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            # clear the class registry as we will be defining foo multiple times\n            jit_utils.clear_class_registry()\n            tm = TestModule()\n            tm.define(self.format_code(code, pair))\n            test_str.append(str(tm.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , Python 3-style type annotations , Script function\n    def test_annot_ast_py3_fn(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, BroadcastingList3\n            import torch\n            @torch.jit.script\n            def foo(x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        ''')\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            test_str.append(str(fn.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    def test_multiline_annot_ast_py3_fn(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, BroadcastingList3\n            import torch\n            @torch.jit.script\n            def foo(x,  # type: {input}\n                    y   # type: Tuple[Tensor, Tensor]\n                    ):\n                # type: (...) -> Tuple[{output}, {output}]\n                return x, x\n        ''')\n        test_str = []\n\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            args = fn.schema.arguments\n            returns = fn.schema.returns\n            self.assertEqual(str(args[0].type), pair[1])\n            self.assertEqual(str(args[1].type), \"Tuple[Tensor, Tensor]\")\n            self.assertEqual(str(returns[0].type), \"Tuple[{}, {}]\".format(pair[1], pair[1]))\n\n    def test_bad_multiline_annotations(self):\n        with self.assertRaisesRegex(RuntimeError, \"Return type line\"):\n            @torch.jit.script\n            def bad_type_line(a,  # type: Tensor\n                              b,  # type: Tensor\n                              c   # type: Tensor\n                              ):\n                # type: (int, int, int) -> Tensor\n                # type: bad type line  # noqa: F723\n\n                return a + b + c\n\n        with self.assertRaisesRegex(RuntimeError, \"Return type line\"):\n            @torch.jit.script\n            def bad_return_line(a,  # type: Tensor\n                                b,\n                                c   # type: Tensor\n                                ):\n                # type: (int, int, int) -> Tensor\n                return a + b + c\n\n        # TODO: this should be supported but is difficult to parse\n        with self.assertRaisesRegex(RuntimeError, \"Number of type annotations\"):\n            @torch.jit.script\n            def missing_type(a,  # type: Tensor\n                             b,\n                             c   # type: Tensor\n                             ):\n                # type: (...) -> Tensor\n                return a + b + c\n\n    #  Python AST Frontend , Python 3-style type annotations , Script method\n    def test_annot_ast_py3_method(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, \\\\\n                BroadcastingList3\n            import torch\n            class FooModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def foo(self, x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                    return x, x\n            instance = FooModule()\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'instance')\n            test_str.append(str(fn.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , MyPy-style type comments , Script function\n    def test_annot_ast_mypy_fn(self):\n        code = dedent('''\n            import torch\n            @torch.jit.script\n            def foo(x, y):\n                # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                return x, x\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            test_str.append(str(fn.schema))\n        self.assertExpected(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , MyPy-style type comments , Script method\n    def test_annot_ast_mypy_method(self):\n        code = dedent('''\n            import torch\n            class FooModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def foo(self, x, y):\n                    # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                    return x, x\n            instance = FooModule()\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'instance')\n            test_str.append(str(fn.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    # Tests that \"# type: ignore[*]\" is supported in type lines and is\n    # properly ignored.\n    def test_mypy_type_ignore(self):\n        @torch.jit.script\n        def foo(x):  # type: ignore\n            return x\n\n        @torch.jit.script\n        def bar(x):  # type: ignore[no-redef]\n            return x\n\n    def test_method_casts_script(self):\n        cast_types = [\n            'byte', 'char', 'double', 'float', 'int', 'long', 'short'\n        ]\n\n        for cast_type in cast_types:\n            cu = torch.jit.CompilationUnit('''\n            def cast_to(x):\n                return x.{cast_type}()\n            '''.format(cast_type=cast_type))\n\n            x = torch.rand(3, 4, 5) * 128\n            cu_result = cu.cast_to(x)\n            reference = getattr(x, cast_type)()\n            self.assertEqual(cu_result, reference)\n\n    def test_string_frontend_elif(self):\n        code = '''\n            def func(niter):\n                # type: (int)\n                rv = 0\n                for i in range(niter):\n                    if i % 3 == 0 and i % 5 == 0:\n                        rv += 35\n                    elif i % 3 == 0:\n                        rv += 3\n                    elif i % 5 == 0:\n                        rv += 5\n                    else:\n                        rv += i\n                return rv\n        '''\n\n        self.checkScript(dedent(code), (101,))\n\n    def test_module_parameters_and_buffers(self):\n        weights = torch.randn(10, 10)\n        bias = torch.randn(10)\n        weights2 = torch.randn(10, 10)\n        bias2 = torch.randn(10)\n\n        class TestLinear(torch.nn.Module):\n            def __init__(self, in_features, out_features):\n                super(TestLinear, self).__init__()\n                self.in_features = in_features\n                self.out_features = out_features\n                self.weight = torch.nn.Parameter(torch.empty(out_features, in_features))\n                self.bias = torch.nn.Parameter(torch.empty(out_features))\n                self.register_buffer('counter', torch.ones(out_features))\n                self.reset_parameters()\n\n            def reset_parameters(self):\n                torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n                if self.bias is not None:\n                    fan_in, _ = torch.nn.init._calculate_fan_in_and_fan_out(self.weight)\n                    bound = 1 / math.sqrt(fan_in)\n                    torch.nn.init.uniform_(self.bias, -bound, bound)\n\n            def forward(self, input):\n                return F.linear(input, self.weight, self.bias) + self.counter\n\n        # Initialize a ScriptModule that uses the weak module above multiple times\n        class Strong(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Strong, self).__init__()\n                self.fc1 = TestLinear(10, 10)\n                self.fc1.weight = torch.nn.Parameter(weights)\n                self.fc1.bias = torch.nn.Parameter(bias)\n                self.fc2 = TestLinear(10, 10)\n                self.fc2.weight = torch.nn.Parameter(weights2)\n                self.fc2.bias = torch.nn.Parameter(bias2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.fc1(x) + self.fc1(x) + self.fc2(x)\n\n        strong_mod = Strong()\n\n        # Run same calculation as module\n        inp = torch.ones(10)\n        lin = torch.nn.Linear(10, 10)\n        lin.weight = torch.nn.Parameter(weights)\n        lin.bias = torch.nn.Parameter(bias)\n        lin2 = torch.nn.Linear(10, 10)\n        lin2.weight = torch.nn.Parameter(weights2)\n        lin2.bias = torch.nn.Parameter(bias2)\n        expected_result = inp + (lin(inp) + torch.ones(10)) * 2 + lin2(inp) + torch.ones(10)\n\n        self.assertEqual(strong_mod(inp), expected_result)\n        self.assertExportImportModule(strong_mod, (inp,))\n\n    def test_module_copying(self):\n        class Submodule(torch.nn.Module):\n            def __init__(self):\n                super(Submodule, self).__init__()\n\n            def forward(self, x):\n                return x + 100\n\n        class Weak(torch.nn.Module):\n            def __init__(self, in_features, out_features):\n                super(Weak, self).__init__()\n                self.weight = torch.nn.Parameter(torch.ones(out_features, in_features))\n                self.bias = torch.nn.Parameter(torch.ones(out_features))\n                self.register_buffer(\"buffer\", torch.ones(out_features))\n                self.submodule = Submodule()\n\n            def forward(self, x):\n                return F.linear(x, self.weight, self.bias) \\\n                    + self.buffer + self.submodule(x)\n\n        class Strong(torch.jit.ScriptModule):\n            def __init__(self, weak):\n                super(Strong, self).__init__()\n                self.weak = weak\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.weak(x)\n\n        inp = torch.ones(5, 5) * 5\n        weak_mod = Weak(5, 5)\n        strong_mod = Strong(weak_mod)\n\n        self.assertTrue(isinstance(strong_mod.weak, torch.jit.ScriptModule))\n        self.assertFalse(isinstance(weak_mod, torch.jit.ScriptModule))\n\n        self.assertIs(strong_mod.weak.weight, weak_mod.weight)\n        self.assertIs(strong_mod.weak.buffer, weak_mod.buffer)\n        # strong_mod.weak.submodule has been recursively scripted\n        self.assertIsNot(strong_mod.weak.submodule, weak_mod.submodule)\n\n        weak_mod.weight.data += torch.ones(5, 5) * 100\n        self.assertTrue(strong_mod(inp).allclose(weak_mod(inp)))\n\n        # Re-assignment is not tracked\n        weak_mod.weight = torch.nn.Parameter(torch.ones(5, 5) * 100)\n        self.assertFalse(strong_mod(inp).allclose(weak_mod(inp)))\n\n    def test_backend_cudnn_enabled(self):\n        # Only test that this compiles\n        @torch.jit.script\n        def fn(x):\n            if torch.backends.cudnn.enabled:\n                x = x + 2\n            else:\n                x = x + 3\n            return x\n\n    def test_inplace_add(self):\n\n        def foo(a, b):\n            c = a + b\n            c.add_(b)\n            return c\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_add_out(self):\n        def foo(a, b):\n            c = a + b\n            e = 2 * a\n            torch.add(c, b, out=e)\n            return e\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_tuple_error_msg(self):\n        def fn(t: Any):\n            if isinstance(t, tuple):\n                a, b = t\n            return a + b\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Provided tuple is not fully defined/refined\", \"t\"):\n            s = torch.jit.script(fn)\n\n    def test_augmented_assign(self):\n        def foo(a, b):\n            a += b\n            a -= b\n            a /= b\n            a *= b\n            return a, b\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_ignored_props(self):\n        class A(nn.Module):\n            __jit_ignored_attributes__ = [\"ignored\", \"ignored_return_val\"]\n\n            def __init__(self):\n                super().__init__()\n\n            @property\n            def ignored(self):\n                raise ValueError(\"shouldn't be called\")\n\n            @property\n            def ignored_return_val(self):\n                return 1\n\n            @torch.jit.ignore\n            def call(self):\n                return self.ignored_return_val\n\n        f = torch.jit.script(A())\n        # jank way to test if there is no error\n        self.assertTrue(isinstance(f, torch.jit.ScriptModule))\n        self.assertTrue(isinstance(f.call(), property))\n\n\n    def test_pass(self):\n        def foo(x):\n            # type: (bool) -> int\n            for _i in range(3):\n                pass\n            if x:\n                pass\n            else:\n                pass\n            return 3\n\n        self.checkScript(foo, (True,))\n\n    def test_lhs_indexing(self):\n        def foo(a, b):\n            a = a.clone()\n            a[0] = b\n            return a\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_advanced_indexing_assignment(self):\n        def foo(x, y):\n            a = torch.exp(x)\n            b = x == 1\n            a[b] = y[b]\n            return a\n        self.checkScript(foo, (torch.ones(4, 3), torch.ones(4, 3)))\n\n    def test_lhs_advanced_indexing_augmented_assignment(self):\n        def foo(x, y):\n            a = torch.exp(x)\n            b = x == 1\n            a[b] += y[b]\n            return a\n        self.checkScript(foo, (torch.ones(4, 3), torch.ones(4, 3)))\n\n    def test_lhs_indexing_list(self):\n        def foo(a, b):\n            ls = [a]\n            ls[0] = b\n            return ls\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_inplace_copy_script(self):\n        def foo(x):\n            a = torch.rand(3, 4)\n            a.copy_(x)\n            return a\n        self.checkScript(foo, (torch.rand(3, 4),))\n\n    def test_lhs_indexing_increment(self):\n        def foo(a, b):\n            a[0] += b\n            return a\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_indexing_increment_list(self):\n        def foo(a, b):\n            a = a.clone()\n            ls = [a, b]\n            ls[0] += b\n            return ls\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_indexing_increment_list_prim(self):\n        def foo():\n            ls = [1, 2, 3]\n            ls[0] += 5\n            return ls\n        self.checkScript(foo, ())\n\n    def test_lhs_indexing_multi(self):\n        def foo(a, b):\n            a = a.clone()\n            foo, a[0], bar = (1, b, 3)\n            return foo, a, bar\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_bool_dispatch(self):\n        with torch._jit_internal._disable_emit_hooks():  # TODO: Python print broadcasting list\n            def kwarg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, return_indices=False)\n            self.checkScript(kwarg_false, (torch.randn(3, 3, 3),))\n\n            def kwarg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, return_indices=True)\n            self.checkScript(kwarg_true, (torch.randn(3, 3, 3),))\n\n            def full_kwarg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, ceil_mode=False, return_indices=False)\n            self.checkScript(full_kwarg_false, (torch.randn(3, 3, 3),))\n\n            def full_kwarg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, ceil_mode=False, return_indices=True)\n            self.checkScript(full_kwarg_true, (torch.randn(3, 3, 3),))\n\n            def use_default(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1)\n            self.checkScript(use_default, (torch.randn(3, 3, 3),))\n\n            def arg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, 0, 1, False, False)\n            self.checkScript(arg_false, (torch.randn(3, 3, 3),))\n\n            def arg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, 0, 1, False, True)\n            self.checkScript(arg_true, (torch.randn(3, 3, 3),))\n\n    def test_infer_size(self):\n        from torch._C import _infer_size\n\n        def fn(x, y):\n            # type: (Tensor, Tensor) -> List[int]\n            return _infer_size(x.size(), y.size())\n\n        self.checkScript(fn, (torch.ones(2, 4, 2), torch.ones(2, 4, 2)))\n\n    def test_hash(self):\n        def tester(fn, inputs):\n            for x in inputs:\n                for y in inputs:\n                    if x == y:\n                        self.assertEqual(fn(x), fn(y))\n                    else:\n                        self.assertNotEqual(fn(x), fn(y))\n\n        @torch.jit.script\n        def int_hash(x):\n            # type: (int) -> int\n            return hash(x)\n\n        @torch.jit.script\n        def float_hash(x):\n            # type: (float) -> int\n            return hash(x)\n\n        @torch.jit.script\n        def str_hash(x):\n            # type: (str) -> int\n            return hash(x)\n\n        tester(int_hash, (20, 21, 22))\n        tester(float_hash, (20.0, 21.00001, 22.443))\n        tester(str_hash, (\"\", \"hello\", \"a\"))\n\n    def test_id(self):\n        with self.assertRaisesRegex(RuntimeError, \"Expected a value\"):\n            @torch.jit.script\n            def test_id_scalars():\n                return id(2) == id(None)\n\n        @torch.jit.script\n        class FooTest(object):\n            def __init__(self, x):\n                self.foo = x\n\n            def getFooTest(self):\n                return self.foo\n\n        @torch.jit.script\n        def test_id_class_types():\n            obj1 = FooTest(torch.tensor(3))\n            obj2 = FooTest(torch.tensor(2))\n            assert obj1 is not obj2\n            assert id(obj1) != id(obj2)\n            assert id(obj1) != id(None)\n            return True\n\n        self.assertTrue(test_id_class_types())\n\n    def test_mutable_dce(self):\n        @torch.jit.script\n        def foo():\n            a = torch.rand(2, 3)\n            a += torch.rand(2, 3)\n            b = torch.rand(2, 3)\n            b += torch.rand(2, 3)\n            # b should be cleaned up but not a\n            return a\n\n        FileCheck().check_count(\"aten::rand\", 2, exactly=True) \\\n            .check_count(\"aten::add\", 1, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_block(self):\n        @torch.jit.script\n        def foo():\n            a = torch.rand(2, 3)\n            a += torch.rand(2, 3)\n            b = torch.rand(2, 3)\n            if bool(a > torch.zeros(2, 3)):\n                b += torch.rand(2, 3)\n                a += torch.rand(2, 3)\n            # a should be cleaned up but not b\n            return b\n\n        FileCheck().check(\"prim::If\").check_count(\"aten::rand\", 1, exactly=True) \\\n            .run(str(foo.graph))\n\n    def test_mutable_dce_graph_input(self):\n        @torch.jit.script\n        def foo(a):\n            a += torch.rand(2, 3)\n            # shouldn't clean up `a` even though it's not used in the output\n\n        FileCheck().check(\"aten::rand\").check(\"aten::add\").run(str(foo.graph))\n\n    def test_mutable_dce_list(self):\n        @torch.jit.script\n        def foo(a):\n            l = []\n            l.append(a)\n            c = l[0]\n            b = torch.rand(2, 3)\n            c += torch.rand(2, 3)\n            return b\n\n        # c does not get cleaned up because there is a wildcard + mutation\n        FileCheck().check_count(\"aten::rand\", 2, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_loop(self):\n        @torch.jit.script\n        def foo(a):\n            l = []\n            l.append(a)\n            i = 0\n            b = torch.rand(2, 3)\n            while i < 1:\n                dead = torch.rand(2, 3)\n                c = l[0]\n                c += torch.rand(2, 3)\n                i += 1\n            return b\n\n        FileCheck().check(\"prim::Loop\").check_not(\"aten::rand\").check(\"aten::__getitem__\") \\\n            .check_count(\"aten::rand\", 1, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_indirect_wildcards(self):\n        def fn():\n            x = torch.ones(2, 3)\n            x_1 = x.view(-1)\n            l = []\n            l.append(x_1)\n            x_view = l[0]\n            x.add_(torch.ones(2, 3))\n            return x_view\n        self.checkScript(fn, ())\n\n    def test_mutable_dce_indirect_wildcard_write(self):\n        def fn():\n            indexes = torch.jit.annotate(List[Tensor], [])\n            word_ids = torch.zeros(10, dtype=torch.int32)\n            word_ids[1] = 1\n            indexes.append(word_ids)\n\n            return word_ids\n        self.checkScript(fn, ())\n\n    def test_mutable_dce_wildcards(self):\n        def fn():\n            x = torch.ones(2, 3)\n            l = []\n            l.append(x)\n            x_view = l[0]\n            x.add_(torch.ones(2, 3))\n            return x_view\n\n        self.checkScript(fn, (), profiling=ProfilingMode.SIMPLE)\n\n    def test_cpp_function_tensor_str(self):\n        x = torch.randn(2, 2)\n        scale = torch.randn(2, 2, requires_grad=True)\n        shift = torch.randn(2, 2, requires_grad=True)\n\n        @torch.jit.script\n        def fn(x, scale, shift):\n            return scale * x + shift\n\n        with self.capture_stdout() as captured:\n            print(fn(x, scale, shift))\n\n    def test_string_index(self):\n        def fn(x):\n            # type: (str)\n            return x[2], x[-1]\n\n        self.checkScript(fn, (\"abcde\",))\n\n    def test_ord(self):\n        def fn(x):\n            # type: (str) -> int\n            return ord(x)\n\n        self.checkScript(fn, (\"h\"))\n        self.checkScript(fn, (\"y\"))\n\n        def index_str_to_tensor(s):\n            # type: (str) -> Tensor\n            return torch.tensor(ord(s))  # noqa: T484\n\n        s = u'\\u00a3'.encode('utf8')[:1]\n        self.checkScript(index_str_to_tensor, (s,))\n\n    def test_chr(self):\n        def fn(x):\n            # type: (int) -> str\n            return chr(x)\n\n        self.checkScript(fn, (1,))\n        self.checkScript(fn, (97,))\n\n    def test_round(self):\n        def round_float(x):\n            # type: (float) -> float\n            return round(x)\n\n        def round_int(x):\n            # type: (int) -> float\n            return round(x)\n\n        self.checkScript(round_float, (1.5,))\n        self.checkScript(round_int, (2,))\n\n    def test_convert_base(self):\n        def test_hex(x):\n            # type: (int) -> str\n            return hex(x)\n\n        def test_oct(x):\n            # type: (int) -> str\n            return oct(x)\n\n        def test_bin(x):\n            # type: (int) -> str\n            return bin(x)\n\n        numbers = [-1000, -10, 0, 1, 10, 2343]\n        for n in numbers:\n            self.checkScript(test_bin, (n,))\n            self.checkScript(test_oct, (n,))\n            self.checkScript(test_hex, (n,))\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    def test_get_set_state(self):\n        class Root(torch.jit.ScriptModule):\n            __constants__ = ['number']\n\n            def __init__(self, number):\n                super(Root, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n                self.number = number\n\n            @torch.jit.script_method\n            def __getstate__(self):\n                return (self.buffer1, self.buffer2, 74, self.training)\n\n            @torch.jit.script_method\n            def __setstate__(self, state):\n                self.buffer1 = state[0] + 10\n                self.buffer2 = state[1] + 10\n                self.training = state[3]\n\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['number']\n\n            def __init__(self, number, submodule):\n                super(M, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n                self.number = number\n                self.submodule = submodule\n\n            @torch.jit.script_method\n            def __getstate__(self):\n                return (self.buffer1, self.buffer2, 74, self.submodule, self.training)\n\n            @torch.jit.script_method\n            def __setstate__(self, state):\n                self.buffer1 = state[0] + 10\n                self.buffer2 = state[1] + 10\n                self.submodule = state[3]\n                self.training = state[4]\n\n        with TemporaryFileName() as fname:\n            m = M(23, submodule=Root(99))\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n\n        # Check original module\n        self.assertEqual(m.buffer1, torch.ones(2, 2))\n        self.assertEqual(m.buffer2, torch.ones(2, 2))\n\n        # Check top level module\n        self.assertEqual(loaded.buffer1, torch.ones(2, 2) + 10)\n        self.assertEqual(loaded.buffer2, torch.ones(2, 2) + 10)\n\n        # Check submodule\n        self.assertEqual(loaded.submodule.buffer1, torch.ones(2, 2) + 10)\n        self.assertEqual(loaded.submodule.buffer2, torch.ones(2, 2) + 10)\n\n        # Check simpler module\n        class NoArgState(torch.nn.Module):\n            def __init__(self):\n                super(NoArgState, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n\n            def forward(self):\n                pass\n\n            @torch.jit.export\n            def __getstate__(self):\n                return 5, self.training\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.buffer1 = torch.ones(2, 2) + state[0]\n                self.buffer2 = torch.ones(2, 2) + 10\n                self.training = state[1]\n\n        with TemporaryFileName() as fname:\n            m = torch.jit.script(NoArgState())\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n            self.assertEqual(loaded.buffer1, torch.ones(2, 2) + 5)\n            self.assertEqual(loaded.buffer2, torch.ones(2, 2) + 10)\n\n\n\n    def test_string_slicing(self):\n        def fn1(x):\n            # type: (str) -> str\n            return x[1:3]\n\n        def fn2(x):\n            # type: (str) -> str\n            return x[-1:3]\n\n        def fn3(x):\n            # type: (str) -> str\n            return x[3:1]\n\n        def fn4(x):\n            # type: (str) -> str\n            return x[3:100]\n\n        self.checkScript(fn1, (\"abcdefghi\",))\n        self.checkScript(fn2, (\"abcdefghi\",))\n        self.checkScript(fn3, (\"abcdefghi\",))\n        self.checkScript(fn4, (\"abcdefghi\",))\n\n    def test_early_return_closure(self):\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    pass\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        g = cu.tanh.graph\n        FileCheck().check_count(\"prim::Closure_0\", 2).check(\"NoneType = prim::Constant\") \\\n                   .check_next(\"return\").run(g)\n\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    a = 1\n                    if output:\n                        return 1\n                    else:\n                        a = 2\n                    return a\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        g = cu.tanh.graph\n        FileCheck().check_count(\"prim::Closure_0\", 2).check(\"int = prim::If\") \\\n                   .run(g)\n\n        code = dedent('''\n            def loop_in_closure(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    for i in range(3):\n                        return 1\n                    return 4\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        fc = FileCheck()\n        fc.check(\"prim::Closure\").check(\"(Tensor, NoneType) = prim::TupleConstruct\")\n        # Loop then two if's added in exit transform\n        fc.check(\"prim::Closure\").check(\"prim::Loop\").check_count(\"prim::If\", 2)\n        fc.run(cu.loop_in_closure.graph)\n\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    if 1 == 1:\n                        return 1\n                    else:\n                        return 1.\n                return output, backward\n        ''')\n        with self.assertRaisesRegex(RuntimeError, \"returned a value of type int but\"):\n            cu = torch.jit.CompilationUnit(code)\n\n    @_inline_everything\n    def test_early_return_fork_join(self):\n        @torch.jit.script\n        def foo(x):\n            if x.dim() == 2:\n                return torch.neg(x), x\n            else:\n                return torch.neg(x), x + 1\n\n        x = torch.rand(3, 4)\n\n        @torch.jit.script\n        def wait_script(x):\n            fut = torch.jit._fork(foo, x)\n            y_hat = foo(x)\n            y = torch.jit._wait(fut)\n            return y, y_hat\n\n        FileCheck().check(\"with prim::fork\").check(\"prim::If\").check(\"return\")\\\n                   .run(wait_script.graph)\n\n    def test_early_return_type_refinement(self):\n        @torch.jit.script\n        def test(x):\n            # type: (Optional[int]) -> int\n            if x is None:\n                return 1\n            else:\n                return x\n        self.assertEqual(test(None), 1)\n        self.assertEqual(test(2), 2)\n\n    def test_exceptions_with_control_flow(self):\n        def test_num_ifs(func, num_ifs):\n            g = torch.jit.script(func).graph\n            FileCheck().check_count(\"prim::If\", num_ifs, exactly=True).run(g)\n\n        def no_guard_ifs_added(x):\n            # type: (int) -> int\n            if x == 1:\n                return 1\n            else:\n                if x == 2:\n                    raise RuntimeError(\"hi\")\n                else:\n                    raise RuntimeError(\"hi\")\n\n        self.checkScript(no_guard_ifs_added, (1,))\n        self.checkScriptRaisesRegex(no_guard_ifs_added, (2,), Exception, \"\")\n        test_num_ifs(no_guard_ifs_added, 2)\n\n        # FUNCTION LOOKS LIKE:\n        # graph(%x.1 : int):\n        #   %7 : str = prim::Constant[value=\"Exception\"]()\n        #   %2 : int = prim::Constant[value=1]()\n        #   %5 : int = prim::Constant[value=2]()\n        #   %19 : int = prim::Uninitialized()\n        #   %3 : bool = aten::eq(%x.1, %2)\n        #   %20 : int = prim::If(%3)\n        #     block0():\n        #       -> (%2)\n        #     block1():\n        #       %6 : bool = aten::eq(%x.1, %5)\n        #        = prim::If(%6)\n        #         block0():\n        #            = prim::RaiseException(%7)\n        #           -> ()\n        #         block1():\n        #            = prim::RaiseException(%7)\n        #           -> ()\n        #       -> (%19)\n        #   return (%20)\n\n        def no_ifs_added(x):\n            # type: (int) -> int\n            if x < 0:\n                raise RuntimeError(\"hi\")\n            return x\n\n        self.checkScript(no_ifs_added, (1,))\n        self.checkScriptRaisesRegex(no_ifs_added, (-2,), Exception, \"\")\n        test_num_ifs(no_ifs_added, 1)\n\n        def test_if_might(x):\n            # type: (int)\n            if x > 0:\n                if x == 1:\n                    return 1\n                else:\n                    a = 2\n            else:\n                raise RuntimeError(\"hi\")\n            return a + 2\n\n        self.checkScript(test_if_might, (1,))\n        self.checkScript(test_if_might, (3,))\n        self.checkScriptRaisesRegex(no_ifs_added, (-2,), Exception, \"\")\n        test_num_ifs(test_if_might, 3)  # one if added to guard a + 2\n\n        def test_loop_no_escape(x):\n            # type: (int)\n            if x >= 0:\n                for i in range(x):\n                    raise RuntimeError(\"hi\")\n            else:\n                return 5\n            return x + 3\n\n        self.checkScript(test_loop_no_escape, (0,))\n        self.checkScript(test_loop_no_escape, (-1,))\n        self.checkScriptRaisesRegex(test_loop_no_escape, (1,), Exception, \"\")\n\n        # if guard gets optimized away\n        test_num_ifs(test_loop_no_escape, 1)\n\n        def test_loop_exception_with_continue(x):\n            # type: (int)\n            i = 0\n            for i in range(5):\n                if i == x:\n                    raise RuntimeError(\"hi\")\n                else:\n                    continue\n                print(i)\n            return i + 5\n\n        self.checkScript(test_loop_exception_with_continue, (-1,))\n        self.checkScriptRaisesRegex(test_loop_exception_with_continue, (1,), Exception, \"\")\n        test_num_ifs(test_loop_exception_with_continue, 1)  # no ifs added to guard print\n\n\n    def test_exception_exits_closure(self):\n        code = dedent('''\n            def no_return_func(self):\n                # type: (Tensor) -> Tensor\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    raise RuntimeError(\"Hi\")\n        ''')\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            cu = torch.jit.CompilationUnit(code)\n\n        code = dedent('''\n            def test_exit_pair_reset(x):\n                # type: (int) -> int\n                if x > 0:\n                    a = 0\n                    def backward(grad_output):\n                        raise RuntimeError(\"Hi\")\n                    a = a + 1\n                else:\n                    return x\n                return a + 1\n        ''')\n        func = torch.jit.CompilationUnit(code).test_exit_pair_reset\n        self.assertEqual(func(1,), 2)\n        self.assertEqual(func(-1,), -1)\n        # final a + 1 gets inlined into the first branch and optimized away\n        FileCheck().check_count(\"prim::If\", 1, exactly=True).run(func.graph)\n\n    def test_non_final_return(self):\n        def simple(x):\n            if bool(x > 3):\n                return x + 1\n            else:\n                return x + 2\n            raise RuntimeError(\"nope\")\n\n        def nest(x):\n            x = x + 1\n            if bool(x > 3):\n                if bool(x > 4):\n                    x += 1\n                return x + 1\n            else:\n                return x + 2\n\n        def early_ret(x):\n            x = x + 1\n            if bool(x > 3):\n                return x + 1\n            x = x + 1\n            return x + 2\n\n        def nest_early_ret(x):\n            x = x + 1\n            if bool(x > 3):\n                if bool(x > 4):\n                    return x + 2\n                return x + 1\n            x = x + 1\n            return x + 2\n\n        def not_early_ret(x):\n            s = \"\"\n            if bool(x > 3):\n                if bool(x > 4):\n                    return 1, s\n                s += \"foo\"\n            else:\n                s += \"5\"\n            s += \"hi\"\n            return 7, s\n\n        def not_total_ret(x):\n            s = \"\"\n            if bool(x > 3):\n                if bool(x > 4):\n                    return 1, s\n                else:\n                    return 2, s\n            else:\n                s += \"5\"\n            return 7, s\n\n        for i in range(3):\n            for func in [simple, nest, early_ret, nest_early_ret, not_early_ret,\n                         not_total_ret]:\n                self.checkScript(func, (torch.tensor(2.5 + i),))\n\n        def vars_used_after_ret(x):\n            # type: (int) -> int\n            if x == 0:\n                return x\n            else:\n                y = 2\n                z = 3\n            return x + y * z\n\n        self.checkScript(vars_used_after_ret, (1,))\n        self.checkScript(vars_used_after_ret, (0,))\n\n        def complicated(x):\n            # type: (int) -> int\n            if x:\n                if x == 2:\n                    return 1\n                    assert 1 == 2\n                else:\n                    if x == 3:\n                        return 2\n                        assert 1 == 2\n                    else:\n                        a = 2\n                        b = 3\n            else:\n                a = 4\n                b = 1\n            return a + b\n            assert 1 == 2\n\n        for i in range(4):\n            self.checkScript(complicated, (i,))\n\n    def test_partial_returns(self):\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def no_ret():\n                # type: () -> int\n                pass\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def partial(x):\n                # type: (Tensor) -> int\n                if x:\n                    return 1\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def typed_none():\n                # type: () -> Optional[int]\n                pass\n\n        @torch.jit.script\n        def none_ret():\n            pass\n\n        self.assertIs(none_ret(), None)\n        FileCheck().check(\": None\").run(none_ret.graph)\n\n    def test_early_returns_loops(self):\n        def nest_while_ret(x):\n            # type: (int) -> int\n            y = 4\n            while x < 4:\n                if x < 3:\n                    return y\n                else:\n                    y = y + 1\n                    break\n                y = y + 2\n            y = y + 1\n            return y\n\n        self.checkScript(nest_while_ret, (2,))\n        self.checkScript(nest_while_ret, (3,))\n        self.checkScript(nest_while_ret, (4,))\n\n        def loop_ret(x, y):\n            # type: (int, int) -> (int)\n            i = 0\n            for i in range(x):\n                if x == y:\n                    return x + y\n                i = i + y\n            i = i - 1\n            return i\n\n        self.checkScript(loop_ret, (3, 3))\n        self.checkScript(loop_ret, (2, 3))\n        self.checkScript(loop_ret, (3, 1))\n\n        def test_will_ret(y):\n            # type: (int) -> int\n            for i in range(y):\n                return 2\n            return 1\n\n        self.checkScript(test_will_ret, (0,))\n        self.checkScript(test_will_ret, (1,))\n\n        def test_loop_nest_ret(y):\n            # type: (int) -> int\n            for i in range(y):\n                for i in range(y - 2):\n                    return 10\n                return 5\n            return 0\n\n        self.checkScript(test_loop_nest_ret, (0,))\n        self.checkScript(test_loop_nest_ret, (1,))\n        self.checkScript(test_loop_nest_ret, (2,))\n\n    def test_nn_init(self):\n        tests = (\n            ('constant_', (lambda: (torch.ones(2, 2), 2.5)), \"Tensor, float\"),\n            ('ones_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('zeros_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('uniform_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('normal_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('xavier_normal_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('xavier_uniform_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n        )\n\n        for name, args_fn, type_str in tests:\n            # Build test code\n            arg_str = ', '.join([chr(i + ord('a')) for i in range(len(args_fn()))])\n\n            code = dedent('''\n                def test({arg_str}):\n                    # type: ({type_str})\n                    return torch.nn.init.{name}({arg_str})\n            ''').format(arg_str=arg_str, type_str=type_str, name=name)\n            cu = torch.jit.CompilationUnit(code)\n\n            # Compare functions\n            init_fn = getattr(torch.nn.init, name)\n            script_out = self.runAndSaveRNG(cu.test, args_fn())\n            eager_out = self.runAndSaveRNG(init_fn, args_fn())\n            self.assertEqual(script_out, eager_out)\n\n            FileCheck().check_not(\"prim::PythonOp\").run(cu.test.graph)\n\n    def test_early_return_rewrite(self):\n        def test_foo(x: bool):\n            if x:\n                return 1\n            return 2\n\n        self.checkScript(test_foo, (True,))\n        self.checkScript(test_foo, (False,))\n        FileCheck().check_count(\"prim::If\", 1, exactly=True).run(torch.jit.script(test_foo).graph)\n\n        def test_multiple(x: int):\n            if x == 5:\n                return x * x\n            else:\n                y = 2 * x\n\n            z = y * 2\n            if z == 8:\n                return 1\n\n            if z != 16:\n                z = z - 2\n                abc = 4\n            else:\n                return 3\n\n            z = z * abc\n            return z * z * z\n\n        self.checkScript(test_multiple, (5,))\n        self.checkScript(test_multiple, (2,))\n        self.checkScript(test_multiple, (4,))\n        self.checkScript(test_multiple, (3,))\n        self.checkScript(test_multiple, (10,))\n\n        graph = torch.jit.script(test_multiple).graph\n        FileCheck().check_count(\"prim::If\", 3, exactly=True).run(graph)\n\n    def test_is_scripting_metacompile(self):\n        @torch.jit.script\n        def foo():\n            if torch.jit.is_scripting():\n                return 1\n            else:\n                print(\"hello\") + 2  # will not be compiled\n\n        self.assertEqual(foo(), 1)\n\n    def test_boolean_literal_constant_metacompile(self):\n        class Mod(torch.nn.Module):\n            __constants__ = ['val']\n\n            def __init__(self, val):\n                super(Mod, self).__init__()\n                self.val = val\n\n            def forward(self):\n                if self.val:\n                    return 1\n                else:\n                    return \"2\"\n\n        self.checkModule(Mod(True), ())\n        self.checkModule(Mod(False), ())\n\n        @torch.jit.script\n        def foo():\n            if True:\n                return 1\n            else:\n                return \"2\"\n\n        self.assertEqual(foo(), 1)\n\n    def test_assert_is_scripting_metacompile(self):\n        def foo():\n            assert not torch.jit.is_scripting(), \"TestErrorMsg\"\n            print(\"hello\") + 2  # will not be compiled\n\n        f = torch.jit.script(foo)\n        with self.assertRaisesRegex(torch.jit.Error, \"TestErrorMsg\"):\n            f()\n\n    def test_isinstance_metacompile(self):\n        @torch.jit.script\n        def test_primitive_type(x):\n            # type: (int) -> int\n            if isinstance(x, int):\n                return x + 1\n            else:\n                return x - 1\n\n        self.assertEqual(test_primitive_type(1), 2)\n        with self.assertRaisesRegex(Exception, \"Expected a value of type\"):\n            test_primitive_type(1.5)\n\n        _MyNamedTuple = namedtuple('_MyNamedTuple', ['value'])\n\n        @torch.jit.script\n        def test_non_primitive_types(x):\n            # type: (_MyNamedTuple) -> Tensor\n            if isinstance(1, _MyNamedTuple):\n                return 10\n\n            if isinstance(x, _MyNamedTuple):\n                return x.value + 1\n            else:\n                return 1\n\n        out = test_non_primitive_types(_MyNamedTuple(value=torch.tensor(5.0)))\n        self.assertEqual(out, torch.tensor(6.0))\n\n    def test_namedtuple_type_inference(self):\n        _AnnotatedNamedTuple = NamedTuple('_NamedTupleAnnotated', [('value', int)])\n        _UnannotatedNamedTuple = namedtuple('_NamedTupleUnAnnotated', ['value'])\n\n        def test_check_named_tuple_value():\n            named_tuple = _AnnotatedNamedTuple(1)\n            return named_tuple.value\n\n        self.checkScript(test_check_named_tuple_value, ())\n\n        def test_error():\n            return _UnannotatedNamedTuple(1)\n\n        with self.assertRaisesRegex(RuntimeError, r\"Expected a value of type \\'Tensor \\(inferred\\)\\' \"\n                                                  r\"for argument \\'value\\' but instead found type \\'int\\'.\"):\n            torch.jit.script(test_error)\n\n    def test_namedtuple_default_values_simple_type(self):\n\n        class Point(NamedTuple):\n            x: Optional[int] = None\n            y: int = 2\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=3, y=2)\n\n        self.checkModule(M(), (p,))\n        self.checkModule(M(), (Point(),))\n\n        m = torch.jit.script(M())\n\n        FileCheck().check(r\"NamedTuple(x : int? = None, y : int = 2))\")   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_missing(self):\n\n        class Point(NamedTuple):\n            x: Optional[int]\n            y: int\n            z: int = 3\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p1 = Point(x=3, y=2)\n        p2 = Point(x=3, y=2, z=1)\n\n        self.checkModule(M(), (p1,))\n        self.checkModule(M(), (p2,))\n\n        m = torch.jit.script(M())\n\n        FileCheck().check(r\"NamedTuple(x : int?, y : int, z : int = 3))\")   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_container_type(self):\n\n        class Point(NamedTuple):\n            x: Optional[List[int]] = None\n            y: List[int] = [1, 2, 3]\n            z: Optional[Dict[str, int]] = {\"a\": 1}\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=[4, 5, 6], y=[3, 2, 1], z={\"b\": 2})\n\n        self.checkModule(M(), (p,))\n        self.checkModule(M(), (Point(),))\n\n        m = torch.jit.script(M())\n\n        first_line = r\"NamedTuple(x : int[]? = None, y : int[] = \"    \\\n                     r\"[1, 2, 3], z : Dict(str, int)? = {a: 1}))\"\n\n        FileCheck().check(first_line)   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_Tensor_type(self):\n\n        class Point(NamedTuple):\n            x: torch.Tensor = torch.rand(2, 3)\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=torch.rand(2, 3))\n\n        with self.assertRaisesRegex(RuntimeError, \"Tensors are not \"\n                                    \"supported as default NamedTuple \"\n                                    \"fields\"):\n            m = torch.jit.script(M())\n            m(p)\n\n    @unittest.skipIf(sys.version_info < (3, 7, 0), \"defaults keyword added in Python 3.8\")\n    def test_namedtuple_default_values_using_factory_constructor(self):\n        Pair = namedtuple(\"Pair\", [\"x\", \"y\"], defaults=(1, 2))\n\n        make_global(Pair)\n\n        @torch.jit.script\n        def fn(x: Pair) -> Pair:\n            return x\n\n        # TODO: We can't use `checkScript` with the NamedTuple factory\n        # constructor. Using the factory constructor with TorchScript\n        # TorchScript creates an anonymous `NamedTuple` class instead of\n        # preserving the actual name. For example, the actual generated\n        # signature in this case is:\n        #   graph(%x.1 : NamedTuple(x : Tensor, y : Tensor))\n        # It looks like similar test cases have had this issue as well\n        # (see: `test_namedtuple_python`).\n        FileCheck().check(r\"NamedTuple(x : Tensor = 1, y : Tensor = 2))\")   \\\n                   .check_next(r\"return (%x.1)\")    \\\n                   .run(fn.graph)\n\n    def test_isinstance_dynamic(self):\n        @torch.jit.script\n        def foo(a):\n            # type: (Optional[List[int]]) -> int\n            b = 0\n            if isinstance(a, (int, (float,), list, str)):\n                b += 1\n            if isinstance(a, (int, str)):\n                b += 1\n            if isinstance(a, List[int]):\n                b += 1\n            return b\n        self.assertEqual(foo([3, 4]), 2)\n        self.assertEqual(foo(None), 0)\n\n    def test_function_overloads(self):\n        # TODO: pyflakes currently does not compose @overload annotation with other\n        # decorators. This is fixed on master but not on version 2.1.1.\n        # Next version update remove noqa and add @typing.overload annotation\n\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (int) -> int\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        def test_simple(x1):  # noqa: F811\n            return x1\n\n        def invoke_function():\n            return test_simple(1.0), test_simple(.5)\n\n        self.checkScript(invoke_function, ())\n\n        # testing that the functions are cached\n        compiled_fns_1 = torch.jit._script._get_overloads(test_simple)\n        compiled_fns_2 = torch.jit._script._get_overloads(test_simple)\n        for a, b in zip(compiled_fns_1, compiled_fns_2):\n            self.assertIs(a.graph, b.graph)\n\n        old_func = test_simple\n\n        # testing that new functions added work with caching\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        @torch.jit.script\n        def my_func():\n            return old_func(\"hi\")\n\n        # testing new function same qualified name\n        @torch.jit._overload  # noqa: F811\n        def test_simple(a, b):  # noqa: F811\n            # type: (int, int) -> int\n            pass\n\n        def test_simple(a, b):\n            return a + b\n\n        @torch.jit.script\n        def fn():\n            return test_simple(3, 4)\n\n        self.assertEqual(fn(), 7)\n\n        # currently we take the default values have to be specified in the\n        # overload as well - TODO take them from implementation and apply\n        # where the type is valid.\n        @torch.jit._overload  # noqa: F811\n        def identity(x1):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def identity(x1):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        def identity(x1=1.0):  # noqa: F811\n            return x1\n\n        def invoke():\n            return identity(), identity(.5), identity(\"hi\")\n\n        self.checkScript(invoke, ())\n\n        def schema_match_failure():\n            return identity((1, 2))\n\n        thrown = False\n        try:\n            torch.jit.script(schema_match_failure)\n        except Exception as e:\n            thrown = True\n            self.assertTrue(r\"of type 'str'\" in str(e) and r\"of type 'float\" in str(e))\n        self.assertTrue(thrown)\n\n        with self.assertRaisesRegex(Exception, \"cannot be directly compiled\"):\n            torch.jit.script(identity)\n\n        @torch.jit._overload  # noqa: F811\n        def impl_compile_failure(x, y):  # noqa: F811\n            # type: (str, str) -> (str)\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def impl_compile_failure(x, y):  # noqa: F811\n            # type: (int, int) -> (int)\n            pass\n\n        def impl_compile_failure(x, y):  # noqa: F811\n            return x - y\n\n        def test():\n            impl_compile_failure(\"one\", \"two\")\n\n\n        with self.assertRaisesRegex(Exception, \"Arguments for call are not valid\"):\n            torch.jit.script(test)\n\n        @torch.jit._overload  # noqa: F811\n        def good_overload(x=1):  # noqa: F811\n            # type: (int) -> (int)\n            pass\n\n        def good_overload(x=1):  # noqa: F811\n            return x\n\n        @torch.jit.script\n        def foo():\n            return good_overload()\n\n        self.assertEqual(foo(), 1)\n\n\n        with self.assertRaisesRegex(Exception, \"must equal to the default parameter\"):\n            @torch.jit._overload  # noqa: F811\n            def bad_default_on_overload(x, y=2):  # noqa: F811\n                # type: (int, int) -> (int)\n                pass\n\n            def bad_default_on_overload(x, y=1):  # noqa: F811\n                # type: (int, int) -> (int)\n                pass\n\n            @torch.jit.script\n            def test():\n                return bad_default_on_overload(1, 2)\n\n        @torch.jit._overload  # noqa: F811\n        def diff_default(x):  # noqa: F811\n            # type: (int) -> int\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def diff_default(x):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        def diff_default(x=\"hi\"):  # noqa: F811\n            return x\n\n        def test():\n            return diff_default(), diff_default(2), diff_default(\"abc\")\n\n        self.assertEqual(test(), torch.jit.script(test)())\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params(x):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params(x, y):  # noqa: F811\n            # type: (int, int) -> int\n            pass\n\n        def diff_num_params(x, y=2, z=3):  # noqa: F811\n            # type: (Union[float, int], int, int)\n            return x + y + z\n\n        def test():\n            return diff_num_params(1.0), diff_num_params(1, 2), diff_num_params(1), diff_num_params(1, 2, 3)\n\n        self.assertEqual(test(), torch.jit.script(test)())\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params_no_annot():\n            # type: () -> int\n            pass\n\n        def diff_num_params_no_annot(x=1):    # noqa: F811\n            return x\n\n        def test():\n            return diff_num_params_no_annot(1.0)\n\n        with self.assertRaisesRegex(Exception, \"Parameters not specified\"):\n            torch.jit.script(test)\n\n    def test_function_overload_misuse(self):\n        with self.assertRaisesRegex(RuntimeError, \"Only `pass` statement or `...` can be the body\"):\n            @torch.jit._overload\n            def wrong_decl_body(x: str) -> str:\n                return x + \"0\"\n\n        with self.assertRaisesRegex(RuntimeError, \"Only `pass` statement or `...` can be the body\"):\n            class MyClass:\n                @torch.jit._overload_method\n                def method(self):\n                    return 0\n\n        @torch.jit._overload\n        def null_overload(x: int) -> int: ...  # noqa: E704\n\n        @torch.jit._overload  # noqa: F811\n        def null_overload(x: str) -> str:  # noqa: F811\n            pass\n\n        def null_overload_driver():\n            return null_overload(0)\n\n        with self.assertRaisesRegex(RuntimeError, 'Implementation for the function \".+\" is missing.'):\n            torch.jit.script(null_overload_driver)\n\n        class OverloadMisuse(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            @torch.jit._overload_method\n            def forward(self, x: int):\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x: Tensor):  # noqa: F811\n                pass\n\n        with self.assertRaisesRegex(RuntimeError, 'Implementation for the method \".+\" is missing.'):\n            m = torch.jit.script(OverloadMisuse())\n\n\n    def test_script_method_torch_function_overload(self):\n        class MyCustomTensor(torch.Tensor):\n            pass\n\n        class MyCustomModule(torch.nn.Module):\n            def forward(self, x):\n                return torch.relu(x)\n\n        scripted_mod = torch.jit.script(MyCustomModule())\n        t = torch.tensor([3.0])\n        ref_out = scripted_mod(t)\n\n        t_custom = MyCustomTensor([3.0])\n        out1 = scripted_mod(t_custom)\n        self.assertEqual(out1, ref_out)\n\n        out2 = scripted_mod.forward(t_custom)\n        self.assertEqual(out2, ref_out)\n\n    def test_function_overloading_isinstance(self):\n        @torch.jit._overload  # noqa: F811\n        def my_conv(x, y):  # noqa: F811\n            # type: (float, str) -> (float)\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def my_conv(x, y):  # noqa: F811\n            # type: (float, float) -> (float)\n            pass\n\n        def my_conv(x, y=2.0):  # noqa: F811\n            if isinstance(y, str):\n                if y == \"hi\":\n                    return 4.0 - x\n                else:\n                    return 5.0 - x\n            else:\n                return 2.0 + x\n\n        def test_uses():\n            return my_conv(1.5), my_conv(1.5, \"hi\"), my_conv(1.5, 5.0)\n\n        self.checkScript(test_uses, ())\n\n    def test_method_overloading(self):\n        class Over(torch.nn.Module):\n            def __init__(self):\n                super(Over, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x):  # noqa: F811\n                # type: (Tuple[Tensor, Tensor]) -> Tensor\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x):  # noqa: F811\n                # type: (Tensor) -> Tensor\n                pass\n\n            def forward(self, x):  # noqa: F811\n                if isinstance(x, Tensor):\n                    return x + 20\n                else:\n                    return x[0] + 5\n\n        class S(torch.jit.ScriptModule):\n            def __init__(self):\n                super(S, self).__init__()\n                self.weak = Over()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.weak(x) + self.weak((x, x))\n\n        s_mod = S()\n        x = torch.ones(1)\n        self.assertEqual(s_mod(x), x + 20 + 5 + x)\n\n        over = Over()\n        self.assertEqual(over((x, x)), x + 5)\n        self.assertEqual(over((x)), x + 20)\n\n        class Unannotated(torch.nn.Module):\n            def __init__(self):\n                super(Unannotated, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 3\n\n            def forward(self):\n                return self.hello(1), self.hello(.5)\n\n        w = Unannotated()\n        with self.assertRaisesRegex(Exception, \"explicitly add type annotations to overloaded functions\"):\n            torch.jit.script(w)\n\n        class CompileOverloadError(torch.nn.Module):\n            def __init__(self):\n                super(CompileOverloadError, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (str) -> (int)\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 1\n\n            def forward(self):\n                return self.hello(\"hi\"), self.hello(.5)\n\n        w = CompileOverloadError()\n        with self.assertRaisesRegex(Exception, \"but instead found type \\'str\\'\"):\n            torch.jit.script(w)\n\n        # testing overload declared first, then non-overload\n        with self.assertRaisesRegex(Exception, \"Overloads are not useable when a module\"):\n            class W3(torch.nn.Module):\n                def __init__(self):\n                    super(W3, self).__init__()\n\n                @torch.jit._overload_method  # noqa: F811\n                def forward(self, x):  # noqa: F811\n                    # type: (int) -> int\n                    pass\n\n                @torch.jit._overload_method  # noqa: F811\n                def forward(self, x):  # noqa: F811\n                    # type: (Tensor) -> Tensor\n                    pass\n\n                def forward(self, x):  # noqa: F811\n                    return x + 5\n\n            a = W3()\n            b = torch.jit.script(a)\n\n            class W3(torch.nn.Module):\n                def __init__(self):\n                    super(W3, self).__init__()\n\n                def forward(self, x):  # noqa: F811\n                    return x + 5 + 10\n\n            a = W3()\n            b = torch.jit.script(a)\n\n        # testing non-overload declared first, then overload\n        class W2(torch.nn.Module):\n            def __init__(self):\n                super(W2, self).__init__()\n\n            def hello(self, x1, x2):\n                return x1 + x2\n\n            def forward(self, x):\n                return self.hello(x, x)\n\n        a = torch.jit.script(W2())\n        self.assertEqual(a(torch.tensor(1)), torch.tensor(2))\n\n        class W2(torch.nn.Module):\n            def __init__(self):\n                super(W2, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 5 + 10\n\n            def forward(self, x):\n                return self.hello(1), self.hello(x)\n\n        with self.assertRaisesRegex(Exception, \"Overloads are not useable when a module\"):\n            a = torch.jit.script(W2())\n\n    def test_narrow_copy(self):\n        def foo(a):\n            return a.narrow_copy(0, 0, 5)\n\n        self.checkScript(foo, [torch.rand(10)])\n\n    def test_select_after_chunk(self):\n        def foo(x):\n            chunked = torch.chunk(x, 1)\n            foo = chunked[0]\n            foo.add_(5)\n            return x\n\n        self.checkScript(foo, [torch.rand(2, 3)])\n\n    def test_nn_LSTM_with_layers(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.rnn = nn.LSTM(2, 3, 2, dropout=0)\n\n            @torch.jit.script_method\n            def forward(self, x, lengths, h0, c0):\n                return self.rnn(x, (h0, c0))[0]\n\n        class Eager(torch.nn.Module):\n            def __init__(self):\n                super(Eager, self).__init__()\n                self.rnn = nn.LSTM(2, 3, 2, dropout=0)\n\n            def forward(self, x, lengths, h0, c0):\n                return self.rnn(x, (h0, c0))[0]\n\n        inputs = (torch.randn(1, 1, 2), torch.LongTensor([7]), torch.randn(2, 1, 3), torch.randn(2, 1, 3))\n        eager_out = self.runAndSaveRNG(lambda: Eager()(*inputs), ())[0]\n        script_out = self.runAndSaveRNG(lambda: M()(*inputs), ())[0]\n\n        self.assertEqual(eager_out, script_out)\n\n    def test_nn_LSTM(self):\n        input = torch.nn.utils.rnn.pack_sequence([torch.randn(5, 5)])\n\n        class S(torch.jit.ScriptModule):\n            def __init__(self):\n                super(S, self).__init__()\n                self.x = torch.nn.LSTM(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: PackedSequence) -> Tuple[PackedSequence, Tuple[torch.Tensor, torch.Tensor]]:\n                return self.x(input)\n\n        eager_out = self.runAndSaveRNG(lambda x: torch.nn.LSTM(5, 5)(x), (input,))[0]\n        script_out = self.runAndSaveRNG(lambda x: S()(x), (input,))[0]\n\n        self.assertEqual(eager_out, script_out)\n\n    def test_nn_GRU(self):\n        seq_input = torch.nn.utils.rnn.pack_sequence([torch.randn(5, 5)])\n        tensor_input = torch.randn(5, 5, 5)\n\n        class SeqLengthGRU(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SeqLengthGRU, self).__init__()\n                self.x = torch.nn.GRU(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: PackedSequence) -> Tuple[PackedSequence, torch.Tensor]:\n                return self.x(input)\n\n        class TensorGRU(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TensorGRU, self).__init__()\n                self.x = torch.nn.GRU(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n                return self.x(input)\n\n        seq_eager_out = self.runAndSaveRNG(lambda x: torch.nn.GRU(5, 5)(x), (seq_input,))[0]\n        seq_script_out = self.runAndSaveRNG(lambda x: SeqLengthGRU()(x), (seq_input,))[0]\n        tensor_eager_out = self.runAndSaveRNG(lambda x: torch.nn.GRU(5, 5)(x), (tensor_input,))[0]\n        tensor_script_out = self.runAndSaveRNG(lambda x: TensorGRU()(x), (tensor_input,))[0]\n\n        self.assertEqual(seq_eager_out, seq_script_out)\n        self.assertEqual(tensor_eager_out, tensor_script_out)\n\n    def test_torchscript_memoryformat(self):\n        @torch.jit.script\n        def fn(x):\n            return x.contiguous(memory_format=torch.channels_last)\n        x = torch.randn(4, 3, 6, 6)\n        y = fn(x)\n        self.assertTrue(y.is_contiguous(memory_format=torch.channels_last))\n\n    def test_torchscript_multi_head_attn(self):\n        @torch.jit.script\n        def jit_multihead_attn_forward(query,                   # type: Tensor\n                                       key,                     # type: Tensor\n                                       value,                   # type: Tensor\n                                       embed_dim_to_check,      # type: int\n                                       num_heads,               # type: int\n                                       in_proj_weight,          # type: Tensor\n                                       in_proj_bias,            # type: Tensor\n                                       bias_k,                  # type: Optional[Tensor]\n                                       bias_v,                  # type: Optional[Tensor]\n                                       add_zero_attn,           # type: bool\n                                       dropout,                 # type: float\n                                       out_proj_weight,         # type: Tensor\n                                       out_proj_bias,           # type: Tensor\n                                       training=True,           # type: bool\n                                       key_padding_mask=None,   # type: Optional[Tensor]\n                                       need_weights=True,       # type: bool\n                                       attn_mask=None           # type: Optional[Tensor]\n                                       ):\n            # type: (...) -> Tuple[Tensor, Optional[Tensor]]\n            return torch.nn.functional.multi_head_attention_forward(query, key, value,\n                                                                    embed_dim_to_check, num_heads,\n                                                                    in_proj_weight, in_proj_bias,\n                                                                    bias_k, bias_v,\n                                                                    add_zero_attn, dropout,\n                                                                    out_proj_weight, out_proj_bias,\n                                                                    training, key_padding_mask,\n                                                                    need_weights, attn_mask)\n\n        src_l = 3\n        bsz = 5\n        embed_size = 8\n        nhead = 2\n        multi_head_attn = torch.nn.MultiheadAttention(embed_size, nhead)\n        query = torch.rand((src_l, bsz, embed_size))\n        key = torch.rand((src_l, bsz, embed_size))\n        value = torch.rand((src_l, bsz, embed_size))\n\n        mask = (torch.triu(torch.ones(src_l, src_l)) == 1).transpose(0, 1)\n        mask = mask.float().masked_fill(mask == 0, float('-inf')).masked_fill(mask == 1, float(0.0)).double()\n\n        jit_out = jit_multihead_attn_forward(query, key, value,\n                                             embed_size, nhead,\n                                             multi_head_attn.in_proj_weight,\n                                             multi_head_attn.in_proj_bias,\n                                             multi_head_attn.bias_k, multi_head_attn.bias_v,\n                                             multi_head_attn.add_zero_attn, multi_head_attn.dropout,\n                                             multi_head_attn.out_proj.weight,\n                                             multi_head_attn.out_proj.bias, attn_mask=mask)[0]\n\n        py_out = torch.nn.functional.multi_head_attention_forward(query, key, value,\n                                                                  embed_size, nhead,\n                                                                  multi_head_attn.in_proj_weight,\n                                                                  multi_head_attn.in_proj_bias,\n                                                                  multi_head_attn.bias_k,\n                                                                  multi_head_attn.bias_v,\n                                                                  multi_head_attn.add_zero_attn,\n                                                                  multi_head_attn.dropout,\n                                                                  multi_head_attn.out_proj.weight,\n                                                                  multi_head_attn.out_proj.bias,\n                                                                  attn_mask=mask)[0]\n        # print(\"rel. error: \")\n        # print(jit_out / py_out - 1)\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    def test_torchscript_multi_head_attn_fast_path(self):\n        src_l = 3\n        bsz = 5\n        embed_size = 8\n        nhead = 2\n        multi_head_attn = torch.nn.MultiheadAttention(embed_size, nhead, batch_first=True)\n        multi_head_attn = multi_head_attn.eval()\n\n        query = key = value = torch.rand((bsz, src_l, embed_size))\n\n        with torch.no_grad():\n            py_out = multi_head_attn(query, key, value)\n            mha = torch.jit.script(multi_head_attn)\n            jit_out = mha(query, key, value)\n        torch.testing.assert_close(jit_out, py_out)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_scriptmodule_multi_head_attn_cuda(self):\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, embed_dim, num_heads):\n                super(MyModule, self).__init__()\n                sample_q = torch.randn(3, 2, embed_dim)\n                sample_kv = torch.randn(3, 2, embed_dim)\n                attention = nn.MultiheadAttention(embed_dim, num_heads)\n                attention.eval()\n\n                self.mod = torch.jit.trace(attention,\n                                           (sample_q, sample_kv, sample_kv))\n\n            @torch.jit.script_method\n            def forward(self, q, k, v):\n                return self.mod(q, k, v)\n\n        embed_dim = 8\n        num_heads = 2\n        sl = 3\n        bs = 2\n        model = MyModule(embed_dim, num_heads).cuda()\n        q = torch.randn(sl, bs, embed_dim, device=\"cuda\")\n        kv = torch.randn(sl, bs, embed_dim, device=\"cuda\")\n\n        jit_out = model(q, kv, kv)[0]\n        py_out = torch.nn.functional.multi_head_attention_forward(q, kv, kv,\n                                                                  embed_dim, num_heads,\n                                                                  model.mod.in_proj_weight,\n                                                                  model.mod.in_proj_bias,\n                                                                  None, None, None, 0.0,\n                                                                  model.mod.out_proj.weight,\n                                                                  model.mod.out_proj.bias)[0]\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_scriptmodule_transformer_cuda(self):\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, transformer, sample_q, sample_kv):\n                super(MyModule, self).__init__()\n                transformer.eval()\n\n                self.mod = torch.jit.trace(transformer,\n                                           (sample_q, sample_kv))\n\n            @torch.jit.script_method\n            def forward(self, q, k):\n                return self.mod(q, k)\n\n        d_model = 8\n        nhead = 2\n        num_encoder_layers = 2\n        num_decoder_layers = 2\n        dim_feedforward = 16\n        bsz = 2\n        seq_length = 5\n        tgt_length = 3\n\n        src = torch.randn(seq_length, bsz, d_model)\n        tgt = torch.randn(tgt_length, bsz, d_model)\n        transformer = nn.Transformer(d_model, nhead, num_encoder_layers,\n                                     num_decoder_layers, dim_feedforward, dropout=0.0)\n        model = MyModule(transformer, tgt, src)\n\n        src = torch.randn(seq_length, bsz, d_model)\n        tgt = torch.randn(tgt_length, bsz, d_model)\n        jit_out = model(tgt, src)\n        py_out = transformer(tgt, src)\n\n        # print(jit_out/py_out-1)\n        # print(torch.allclose(jit_out, py_out, atol=5e-4, rtol=1e-4))\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    def test_list_python_op(self):\n        def python_list_op(lst):\n            # type: (List[Tensor]) -> Tensor\n            return lst[0]\n\n        def fn(lst):\n            # type: (List[Tensor]) -> Tensor\n            return python_list_op(lst)\n\n        self.checkScript(fn, ([torch.ones(2) + 2, torch.ones(2)],))\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_weak_cuda(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.lstm = torch.nn.LSTM(5, 5)\n                self.lstm.cuda()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.lstm(x)\n\n        m = M()\n        m.cuda()\n        out = m(torch.ones(5, 5, 5).cuda())\n        self.assertTrue(out[0].is_cuda)\n\n    def test_ignore_decorator(self):\n        with warnings.catch_warnings(record=True) as warns:\n            class M(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M, self).__init__()\n                    tensor = torch.zeros(1, requires_grad=False)\n                    self.register_buffer('some_state', torch.nn.Parameter(tensor))\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    self.ignored_code(x)\n                    return x\n\n                @torch.jit.ignore(drop_on_export=True)\n                def ignored_code(self, x):\n                    self.some_state = torch.tensor((100,))\n\n        FileCheck().check(\"TorchScript will now drop the function\").run(str(warns[0]))\n\n        # Assert ignored code is run\n        m = M()\n\n        m2 = self.getExportImportCopy(m)\n        pp = str(m2.forward.code)\n        self.assertNotIn('ignored_code', pp)\n\n        with self.assertRaisesRegex(torch.jit.Error, \"annotated to be ignored and cannot be run\"):\n            m2.forward(torch.ones(1))\n\n    def test_ignored_as_value(self):\n        class Model(nn.Module):\n            def __init__(self):\n                super(Model, self).__init__()\n\n            @torch.jit.unused\n            def tuple_ignored(self, x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return x, x\n\n            @torch.jit.unused\n            def single_val_ignored(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                return x\n\n            def forward(self, x, use_ignore_path):\n                # type: (Tensor, bool) -> Tuple[Tensor, Tensor]\n                if 1 == 2:\n                    return self.tuple_ignored(x)\n                if use_ignore_path:\n                    return self.single_val_ignored(x, x), self.single_val_ignored(x, x)\n                return x, x\n\n        original = Model()\n        scripted = torch.jit.script(original)\n        self.assertEqual(scripted(torch.tensor(.5), False), (torch.tensor(.5), torch.tensor(.5)))\n\n        buffer = io.BytesIO()\n        torch.jit.save(scripted, buffer)\n        buffer.seek(0)\n        loaded = torch.jit.load(buffer)\n\n        with self.assertRaisesRegex(torch.jit.Error, \"annotated to be ignored and cannot be run\"):\n            loaded(torch.tensor(.5), True)\n\n    def test_module_error(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, foo):\n                return foo\n\n        with self.assertRaisesRegex(RuntimeError, \"cannot be compiled since it inherits from nn.Module\"):\n            torch.jit.script(MyModule)\n\n    def test_view_write(self):\n        def fn(x, y):\n            l = []\n            l.append(x)\n            x_view = l[0]\n            a = x + x\n            x_view.add_(y)\n            b = x + x\n            return a == b\n        self.checkScript(fn, (torch.rand(2, 3), torch.rand(2, 3)))\n\n    def test_module_attrs(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, table):\n                super(M, self).__init__()\n                self.table = torch.jit.Attribute(table, Dict[str, torch.Tensor])\n                self.x = torch.nn.Parameter(torch.tensor([100.0]))\n\n            @torch.jit.script_method\n            def forward(self, key):\n                # type: (str) -> Tensor\n                return self.table[key] + self.x\n\n        with torch._jit_internal._disable_emit_hooks():\n            # TODO: re-enable module hook when Python printing of attributes is\n            # supported\n            m = M({char : torch.ones(1) + ord(char) - ord(\"a\") for char in \"abcdefg\"})\n            self.assertEqual(m(\"c\"), torch.tensor([103.]))\n\n    def test_module_none_attrs(self):\n        class MyMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.optional_value = None\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.optional_value\n\n        graph = MyMod().forward.graph\n        FileCheck().check(\"prim::GetAttr\").run(graph)\n        self.run_pass('peephole', graph)\n        FileCheck().check_not(\"prim::GetAttr\").run(graph)\n\n    def test_tensor_import_export(self):\n        @torch.jit.script\n        def foo(x):\n            a = torch.tensor(1)\n            b = torch.tensor([1, 2])\n            c = [a, b]\n            return c\n\n        self.run_pass('constant_propagation', foo.graph)\n        m = self.createFunctionFromGraph(foo.graph)\n        self.getExportImportCopy(m)\n\n    def get_pickle_values(self):\n        return (('dict', {\"I\": \"am\", \"a test\": \"test\"}, Dict[str, str]),\n                ('float', 2.3, float),\n                ('int', 99, int),\n                ('bool', False, bool),\n                ('tuple', (1, 2, 3, 4), Tuple[int, int, int, int]),\n                ('list', [(1, 2), (3, 4)], List[Tuple[int, int]]),\n                ('tensor', torch.randn(2, 2), torch.Tensor),\n                ('int_list', [1, 2, 3, 4], List[int]),\n                ('tensor_list', [torch.ones(2, 2) + i for i in range(4)], List[torch.Tensor]),\n                ('bool_list', [True, True, False, True], List[bool]),\n                ('float_list', [1., 2., 3., 4.], List[float]),\n                ('str_list', ['hello', 'bye'], List[str]),\n                ('none', None, Optional[int]),\n                ('a_device', torch.device('cpu'), torch.device),\n                ('another_device', torch.device('cuda:1'), torch.device))\n\n    def test_attribute_serialization(self):\n        tester = self\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                for name, value, the_type in tester.get_pickle_values():\n                    setattr(self, name, torch.jit.Attribute(value, the_type))\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.dict, self.float, self.int, self.bool, self.tuple,\n                        self.list, self.int_list, self.tensor_list, self.bool_list,\n                        self.float_list, self.str_list, self.none)\n\n        m = M()\n        imported_m = self.getExportImportCopy(m)\n        self.assertEqual(m(), imported_m())\n\n    def test_string_len(self):\n        def fn(x):\n            # type: (str) -> int\n            return len(x)\n\n        self.checkScript(fn, (\"\",))\n        self.checkScript(fn, (\"h\",))\n        self.checkScript(fn, (\"hello\",))\n\n    def test_multiline_optional_future_refinement(self):\n        @torch.jit.script\n        def fun() -> int:\n            future: Optional[\n                torch.jit.Future[Tuple[torch.Tensor]]\n            ] = None\n\n            return 1\n        self.assertEqual(fun(), 1)\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    def test_attribute_unpickling(self):\n        tensor = torch.randn(2, 2)\n        tester = self\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                for name, value, the_type in tester.get_pickle_values():\n                    setattr(self, \"_\" + name, torch.jit.Attribute(value, the_type))\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self._dict, self._float, self._int, self._bool, self._tuple,\n                        self._list, self._int_list, self._tensor_list, self._bool_list,\n                        self._float_list, self._str_list, self._none)\n\n        with TemporaryFileName() as fname:\n            M().save(fname)\n            loaded = torch.jit.load(fname)\n\n            def is_tensor_value(item):\n                if isinstance(item, torch.Tensor):\n                    return True\n                if isinstance(item, list):\n                    return is_tensor_value(item[0])\n                return False\n            for name, value, the_type in self.get_pickle_values():\n                if is_tensor_value(value):\n                    continue\n                self.assertEqual(value, getattr(loaded, \"_\" + name))\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    @unittest.skipIf(not BUILD_WITH_CAFFE2, \"PyTorch is build without Caffe2 support\")\n    def test_old_models_bc(self):\n        model = {\n            'archive/version': b'1',\n            'archive/code/archive.py':\n                b'''\n                op_version_set = 0\n                def forward(self,\n                    _0: Tensor) -> Tensor:\n                  _1 = torch.zeros([10], dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  result = torch.to(torch.fill_(_1, 5), dtype=6, layout=0, device=torch.device(\"cpu\"),\n                                    non_blocking=False, copy=False)\n                  result2 = torch.rand([10], dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  result3 = torch.rand_like(result2, dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  _2 = torch.add(torch.add(result, result2, alpha=1), result3, alpha=1)\n                  return _2\n                ''',\n            'archive/attributes.pkl': b'\\x80\\x02](e.',\n            'archive/libs.py': b'op_version_set = 0\\n',\n            'archive/model.json':\n                b'''\n                {\n                   \"protoVersion\":\"2\",\n                   \"mainModule\":{\n                      \"torchscriptArena\":{\n                         \"key\":\"code/archive.py\"\n                      },\n                      \"name\":\"archive\",\n                      \"optimize\":true\n                   },\n                   \"producerName\":\"pytorch\",\n                   \"producerVersion\":\"1.0\",\n                   \"libs\":{\n                      \"torchscriptArena\":{\n                         \"key\":\"libs.py\"\n                      }\n                   }\n                }'''}\n        with TemporaryFileName() as fname:\n            archive_name = os.path.basename(os.path.normpath(fname))\n            with zipfile.ZipFile(fname, 'w') as archive:\n                for k, v in model.items():\n                    archive.writestr(k, v)\n\n            with open(fname, \"rb\") as f:\n                fn = torch.jit.load(f)\n\n        x = torch.zeros(10)\n        fn(x)\n\n    def test_submodule_attribute_serialization(self):\n        class S(torch.jit.ScriptModule):\n            def __init__(self, list_data):\n                super(S, self).__init__()\n                self.table = torch.jit.Attribute({\"I\": \"am\", \"a test\": \"test\"}, Dict[str, str])\n                self.list = torch.jit.Attribute(list_data, List[Tuple[int, int]])\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.table, self.list)\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.table = torch.jit.Attribute({\"this\": \"is\", \"a different\": \"dict\"}, Dict[str, str])\n                self.tensor = torch.jit.Attribute(torch.randn(2, 2), torch.Tensor)\n                self.s1 = S([(1, 2)])\n                self.s2 = S([(4, 5)])\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.table, self.tensor, self.s1.table, self.s2.list, self.s1.list)\n\n        m = M()\n        imported_m = self.getExportImportCopy(m)\n        self.assertEqual(m(), imported_m())\n\n    def test_serialization_big_ints(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.int32_max = torch.jit.Attribute(2**31 - 1, int)\n                self.int32_min = torch.jit.Attribute(-2**31, int)\n                self.uint32_max = torch.jit.Attribute(2**32, int)\n\n                self.int64_max = torch.jit.Attribute(2**63 - 1, int)\n                self.int64_min = torch.jit.Attribute(-2**63, int)\n\n                self.tensor = torch.nn.Parameter(torch.ones(2, 2))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (int) -> (int)\n                return x + (self.int32_max + self.int32_min) + (self.int64_max + self.int64_min)\n\n        m = M()\n        imported = self.getExportImportCopy(m)\n        self.assertEqual(m(10), imported(10))\n\n        self.assertEqual(m.int32_max, imported.int32_max)\n        self.assertEqual(m.int32_min, imported.int32_min)\n        self.assertEqual(m.uint32_max, imported.uint32_max)\n        self.assertEqual(m.int64_max, imported.int64_max)\n        self.assertEqual(m.int64_min, imported.int64_min)\n\n    def test_script_scope(self):\n        scripted = torch.jit.script(torch.nn.functional.triplet_margin_loss)\n\n    @unittest.skipIf(IS_WINDOWS, \"NYI: TemporaryFileName on Windows\")\n    def test_serialization_sharing(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.list = torch.jit.Attribute([], List[str])\n\n            @torch.jit.script_method\n            def forward(self, key):\n                # type: (str) -> List[str]\n                self.list.append(key)\n                self.list.append(key)\n                self.list.append(key)\n                return self.list\n\n        # the text of the string should only appear once in the pickling\n        m = M()\n        s1 = \"a long string\"\n        s2 = \"a different, even longer string\"\n        self.assertEqual(m(s1), [s1] * 3)\n        self.assertEqual(m(s2), [s1] * 3 + [s2] * 3)\n        with TemporaryFileName() as fname:\n            m.save(fname)\n            archive_name = os.path.basename(os.path.normpath(fname))\n            archive = zipfile.ZipFile(fname, 'r')\n            pickled_data = archive.read(os.path.join(archive_name, 'data.pkl'))\n\n            out = io.StringIO()\n            pickletools.dis(pickled_data, out=out)\n            disassembled = out.getvalue()\n\n            FileCheck().check_count(s1, 1, exactly=True) \\\n                .check_count(\"BINGET\", 2, exactly=True) \\\n                .check_count(s2, 1, exactly=True) \\\n                .check_count(\"BINGET\", 2, exactly=True).run(out.getvalue())\n\n    def test_sys_stdout_override(self):\n        @torch.jit.script\n        def foo():\n            print('foo')\n\n        class Redirect(object):\n            def __init__(self):\n                self.s = ''\n\n            def write(self, s):\n                self.s += s\n\n        old_stdout = sys.stdout\n        redirect = Redirect()\n        try:\n            sys.stdout = redirect\n            foo()\n        finally:\n            sys.stdout = old_stdout\n\n        FileCheck().check('foo').run(redirect.s)\n\n    def test_dtype_attr(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.dtype = torch.zeros([]).dtype\n\n            def forward(self):\n                return torch.zeros(3, 4, dtype=self.dtype)\n\n        f = Foo()\n        torch.jit.script(f)\n\n\n    def test_named_buffers_are_iterable(self):\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.mod = (torch.nn.ReLU())\n                self.mod2 = (torch.nn.ReLU())\n                self.mod3 = torch.nn.Sequential(torch.nn.Sequential(torch.nn.ReLU()))\n                self.register_buffer('x', torch.zeros(3))\n                self.register_buffer('y', torch.zeros(3))\n                self.z = torch.zeros(3)\n\n            def bleh(self):\n                return self.z + 4\n\n            @torch.jit.export\n            def method(self):\n                names = [\"\"]\n                vals = []\n                for name, buffer in self.named_buffers():\n                    names.append(name)\n                    vals.append(buffer + 2)\n\n                return names, vals\n\n            def forward(self, x):\n                return x\n\n        model = MyMod()\n        x = torch.jit.script(model)\n        z = self.getExportImportCopy(x)\n\n        self.assertEqual(z.method(), x.method())\n        self.assertEqual(z.method(), model.method())\n        self.assertEqual(x.method(), model.method())\n        names = x.method()\n        for name in names:\n            self.assertNotEqual('z', name)\n\n\n    def test_static_if_prop(self):\n        class MaybeHasAttr(torch.nn.Module):\n            def __init__(self, add_attr):\n                super(MaybeHasAttr, self).__init__()\n                if add_attr:\n                    self.maybe_attr = 1\n\n            def forward(self):\n                if hasattr(self, \"maybe_attr\") and True:\n                    return self.maybe_attr\n                else:\n                    return 0\n\n        class MaybeHasAttr2(torch.nn.Module):\n            def __init__(self, add_attr):\n                super(MaybeHasAttr2, self).__init__()\n                if add_attr:\n                    self.maybe_attr = 1\n\n            def forward(self):\n                if not hasattr(self, \"maybe_attr\") or False:\n                    return 0\n                else:\n                    return self.maybe_attr\n\n        torch.jit.script(MaybeHasAttr(True))\n        torch.jit.script(MaybeHasAttr(False))\n        torch.jit.script(MaybeHasAttr2(True))\n        torch.jit.script(MaybeHasAttr2(False))\n\n        class MyMod(torch.nn.Module):\n            def forward(self):\n                if hasattr(self, \"foo\"):\n                    return 1\n                else:\n                    return 0\n\n            @torch.jit.export\n            def fee(self):\n                return 1\n\n        self.checkModule(MyMod(), ())\n\n        class HasAttrMod(torch.nn.Module):\n            __constants__ = [\"fee\"]\n\n            def __init__(self):\n                super().__init__()\n                self.fee = 3\n\n            def forward(self):\n                a = hasattr(self, \"fee\")\n                b = hasattr(self, \"foo\")\n                c = hasattr(self, \"hi\")\n                d = hasattr(self, \"nonexistant\")\n                return (a, b, c, d)\n\n            def foo(self):\n                return 1\n\n            @torch.jit._overload_method\n            def hi(self, x: Tensor): ...  # noqa: E704\n\n            def hi(self, x):  # noqa: F811\n                return 2\n\n        self.checkModule(HasAttrMod(), ())\n\n        @torch.jit.script\n        class FooTest(object):\n            def __init__(self):\n                self.x = 1\n\n            def foo(self, y):\n                return self.x + y\n\n        def foo():\n            a = FooTest()\n            val1 = hasattr(a, \"foo\"), hasattr(a, \"x\"), hasattr(a, \"bla\")\n            val2 = hasattr(FooTest, \"foo\"), hasattr(FooTest, \"a\")\n            return val1, val2\n\n        self.assertEqual(foo(), torch.jit.script(foo)())\n\n    def _test_pickle_checkpoint(self, device):\n        with TemporaryFileName() as fname:\n            class M(torch.jit.ScriptModule):\n                __constants__ = ['fname']\n\n                def __init__(self, tensor):\n                    super(M, self).__init__()\n                    self.fname = fname\n                    self.tensor = torch.nn.Parameter(tensor)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    y = self.tensor + x\n                    torch.save(y, self.fname)\n                    return y\n\n            param = torch.randn(2, 2).to(device)\n            input = torch.randn(2, 2).to(device)\n            m = M(param)\n            m(input)\n            with open(fname, \"rb\") as handle:\n                loaded_tensor = torch.load(fname)\n                self.assertEqual(loaded_tensor, input + param)\n\n    def _test_pickle_checkpoint_views(self, device):\n        with TemporaryFileName() as fname:\n            class M(torch.jit.ScriptModule):\n                __constants__ = ['fname']\n\n                def __init__(self, tensor):\n                    super(M, self).__init__()\n                    self.fname = fname\n                    self.tensor = torch.nn.Parameter(tensor)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    y = self.tensor + x\n                    y_view = y.view(4)\n                    torch.save((y, y_view, y), self.fname)\n                    return y\n\n            param = torch.randn(2, 2).to(device)\n            input = torch.randn(2, 2).to(device)\n            m = M(param)\n            m(input)\n            with open(fname, \"rb\") as handle:\n                loaded_y, loaded_y_view, loaded_y_2 = torch.load(fname)\n                self.assertEqual(loaded_y, input + param)\n                with torch.no_grad():\n                    loaded_y_view[1] += 20\n                    # assert that loaded_y changed as well\n                    self.assertEqual(loaded_y.view(4), loaded_y_view)\n                    self.assertEqual(loaded_y_2.view(4), loaded_y_view)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_pickle_checkpoint_cuda(self):\n        self._test_pickle_checkpoint('cuda')\n        self._test_pickle_checkpoint_views('cuda')\n\n    def test_pickle_checkpoint(self):\n        self._test_pickle_checkpoint('cpu')\n        self._test_pickle_checkpoint_views('cpu')\n\n    def test_pickle_checkpoint_tup(self):\n        @torch.jit.script\n        def foo(fname):\n            # type: (str) -> None\n            torch.save((3, 4), fname)\n        with TemporaryFileName() as name:\n            foo(name)\n            self.assertEqual(torch.load(name), (3, 4))\n\n    def test_string_list(self):\n        def fn(string):\n            # type: (str) -> List[str]\n            return list(string)\n\n        self.checkScript(fn, (\"abcdefgh\",))\n\n    def test_unicode_comments(self):\n        @torch.jit.script\n        def test(self, a):\n            # \ud83e\udd37\ud83e\udd37\ud83e\udd37\ud83e\udd37\n            return torch.nn.functional.relu(a)\n\n    def test_get_set_state_with_tensors(self):\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n                self.tensor = torch.randn(2, 2)\n\n            @torch.jit.export\n            def __getstate__(self):\n                return (self.tensor, self.training)\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.tensor = state[0]\n                self.training = state[1]\n\n            def forward(self, x):\n                return x + self.tensor\n\n        with TemporaryFileName() as fname:\n            m = torch.jit.script(M())\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n            self.assertEqual(loaded.tensor, m.tensor)\n\n    def test_in_for_and_comp_expr(self):\n        def fn(d):\n            # type: (Dict[str, int]) -> List[int]\n            out = [1]\n            for i in range(d[\"hi\"] if \"hi\" in d else 6):\n                out.append(i)\n            return out\n\n        self.checkScript(fn, ({'hi': 2, 'bye': 3},))\n        self.checkScript(fn, ({'bye': 3},))\n\n    def test_for_else(self):\n        def fn():\n            c = 0\n            for i in range(4):\n                c += 10\n            else:\n                print(\"In else block of for...else\")\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, \"else branches of for loops aren't supported\"):\n            torch.jit.script(fn)\n\n    def test_split(self):\n        def split_two(tensor):\n            a, b, c = torch.split(tensor, 2, dim=1)\n            return a, b, c\n        x = torch.randn(3, 6)\n        y = torch.randn(3, 6)\n        self.checkScript(split_two, [(x + y)])\n\n    def test_conv_error(self):\n        @torch.jit.script\n        def fn(x, y):\n            return F.conv2d(x, y)\n\n        try:\n            fn(torch.ones(2, 2), torch.ones(4, 4))\n        except RuntimeError as e:\n            self.assertFalse('frame' in str(e))\n\n    def test_python_op_name(self):\n        import random\n\n        with self.assertRaisesRegex(RuntimeError, \"randint\"):\n            @torch.jit.script\n            def fn():\n                return random.randint()\n\n    def test_dir(self):\n        class M(torch.jit.ScriptModule):\n            def forward(self, t):\n                return t\n\n        self.assertTrue('forward' in dir(M()))\n\n    def test_kwarg_expansion_error(self):\n        @torch.jit.ignore\n        def something_else(h, i):\n            pass\n\n        def fn(x):\n            something_else(**x)\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, \"keyword-arg expansion is not supported\"):\n            torch.jit.script(fn)\n\n    def test_kwargs_error_msg(self):\n        def other(**kwargs):\n            print(kwargs)\n\n        def fn():\n            return other()\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, 'variable number'):\n            torch.jit.script(fn)\n\n        def another_other(*args):\n            print(args)\n\n        def another_fn():\n            return another_other()\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, 'variable number'):\n            torch.jit.script(another_fn)\n\n    def test_inferred_error_msg(self):\n        \"\"\"\n        Test that when we get a type mismatch on a function where we inferred\n        the type to be tensor, a good error message is given.\n        \"\"\"\n        @torch.jit.script\n        def foo(a):\n            return a\n\n        with self.assertRaisesRegex(RuntimeError, (r\"Expected a value of type \\'Tensor \\(inferred\\)\\'\"\n                                                   r\"[\\S\\s]*Inferred \\'a\\' to be of type \\'Tensor\\'\")):\n            foo(\"1\")\n\n    def test_type_comments_in_body(self):\n        @torch.jit.script\n        def foo(a,  # type: int\n                b,  # type: int\n                ):\n            # type: (...) -> int\n            # type: int\n            return a + b\n\n        class M(torch.nn.Module):\n            def __init__(self,\n                         a,  # type: int\n                         b   # type: int\n                         ):\n                # type: (...) -> None\n                super(M, self).__init__()\n                self.a = a  # type: int\n                self.b = b  # type: int\n\n        torch.jit.script(M(2, 3))\n\n    def test_input_keyword_in_schema(self):\n        def f(x):\n            return torch.ceil(input=x)\n\n        inp = torch.randn(10)\n        self.checkScript(f, (inp, ))\n\n    def test_module_method_reassignment(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            def _forward(self, x):\n                return x\n\n            forward = _forward\n\n        sm = torch.jit.script(Foo())\n        input = torch.ones(2, 2)\n        self.assertEqual(input, sm(input))\n\n    # Tests the case where a torch.Tensor subclass (like Parameter) is used as\n    # input.\n    def test_script_module_tensor_subclass_argument(self):\n        @torch.jit.script\n        def parameter_script(x: torch.nn.Parameter):\n            return x\n\n        input = torch.ones(2, 2)\n        self.assertEqual(input, parameter_script(input))\n\n    def test_save_load_attr_error(self):\n        class Inner(nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            def forward(self, x):\n                return x\n\n        class Wrapper(nn.Module):\n            def __init__(self, inner):\n                super().__init__()\n                self.inner = inner\n\n            def forward(self, x):\n                # this attribute doesn't exist on `Inner`\n                return self.inner.b(x)\n\n        inner_module = torch.jit.script(Inner())\n        inner_module = self.getExportImportCopy(inner_module)\n        wrapped = Wrapper(inner_module)\n        # This should properly complain that `self.inner` doesn't have the attribute `b`\n        with self.assertRaisesRegex(RuntimeError, 'has no attribute'):\n            torch.jit.script(wrapped)\n\n    def test_rescripting_loaded_modules(self):\n        class InnerSubmod(nn.Module):\n            __constants__ = ['my_constant']\n\n            def __init__(self):\n                super().__init__()\n                self.register_buffer(\"foo\", torch.ones(1))\n                self.register_parameter(\"bar\", torch.nn.Parameter(torch.ones(1)))\n                self.baz = torch.ones(1)\n                self.my_constant = 1\n\n            def forward(self, x):\n                return x + x\n\n        class Inner(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.submod = InnerSubmod()\n\n            def forward(self, x):\n                return self.submod(x)\n\n        class Wrapper(nn.Module):\n            def __init__(self, inner):\n                super().__init__()\n                self.inner = inner\n\n            def forward(self, x):\n                # access inner elements\n                ret = self.inner.submod(x) + self.inner.submod.foo + self.inner.submod.bar + self.inner.submod.baz\n                ret = ret + self.inner.submod.my_constant\n                return ret\n\n        inner_module = torch.jit.script(Inner())\n        wrapped = Wrapper(inner_module)\n        self.checkModule(wrapped, torch.ones(1))\n\n        inner_module_loaded = self.getExportImportCopy(inner_module)\n        wrapped_loaded = Wrapper(inner_module_loaded)\n        self.assertEqual(wrapped(torch.ones(1)), wrapped_loaded(torch.ones(1)))\n\n    def test_interpret_graph(self):\n        def fn(x):\n            return x.unfold(0, 1, 1)\n\n        graph_str = \"\"\"\n        graph(%a : Tensor, %b : Tensor):\n          %c : Tensor = aten::mul(%a, %b)\n          return (%c)\n        \"\"\"\n        graph = parse_ir(graph_str)\n        a = torch.rand(10)\n        b = torch.rand(10)\n        test = torch._C._jit_interpret_graph(graph, (a, b))\n        ref = a * b\n        self.assertEqual(test, ref)\n\n    def test_signed_float_zero(self):\n\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x):\n                return torch.div(x, -0.)\n\n        inp = torch.ones(1)\n        self.checkModule(MyModule(), inp)\n\n    def test_index_with_tuple(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x):\n                return x[(1,)]\n\n        self.checkModule(MyModule(), (torch.ones(2, 3),))\n\n    def test_context_manager(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x, y):\n                p = x + y\n                q = p + 2.0\n                return q\n\n        x = torch.randn(3, 2, dtype=torch.float)\n        y = torch.randn(3, 2, dtype=torch.float)\n        for fuser_name in ['fuser0', 'fuser1', 'none']:\n            with torch.jit.fuser(fuser_name):\n                self.checkModule(MyModule(), (x, y))\n\n# known to be failing in tracer\nEXCLUDE_TRACED = {\n    # The following fail due to #12024.\n    # A prim::ListConstruct is involved and the indices get traced as TensorType,\n    # which always require_grad. This causes a crash in autodiff.\n    'test___getitem___adv_index',\n    'test___getitem___adv_index_beg',\n    'test___getitem___adv_index_comb',\n    'test___getitem___adv_index_dup',\n    'test___getitem___adv_index_sub',\n    'test___getitem___adv_index_sub_2',\n    'test___getitem___adv_index_sub_3',\n    'test___getitem___adv_index_var',\n\n    # jit doesn't support sparse tensors.\n    'test_to_sparse',\n    'test_to_sparse_dim',\n}\n\nEXCLUDE_TYPE_CHECK = {\n    # slogdet tests use itemgetter to select its only differentiable output,\n    # but this happens outside of the graph we handle, so there are fewer\n    # reference outputs than graph outputs.\n    'test_slogdet_1x1_neg_det',\n    'test_slogdet_1x1_pos_det',\n    'test_slogdet_distinct_singular_values',\n    'test_slogdet_neg_det',\n    'test_slogdet_pos_det',\n    'test_slogdet_symmetric',\n    'test_slogdet_symmetric_pd',\n    'test_slogdet_batched_1x1_neg_det',\n    'test_slogdet_batched_pos_det',\n    'test_slogdet_batched_symmetric',\n    'test_slogdet_batched_symmetric_pd',\n    'test_slogdet_batched_distinct_singular_values'\n}\n\n# chunk returns a list in scripting and we don't unpack the list,\n# Thus it won't be replaced by ConstantChunk and run AD.\n# It's explicitly checked in test_chunk_constant_script_ad\n# Similary for split, it's replaced by split_with_sizes in tracing,\n# but we don't have AD formula for aten::split(Tensor, int[], int),\n# an op registered in JIT so AD is not triggered in scripting.\nEXCLUDE_SCRIPT_AD_CHECK = {\n    'test_chunk',\n    'test_chunk_dim',\n    'test_chunk_dim_neg0',\n    'test_split_size_list',\n    'test_split_size_list_dim',\n    'test_split_size_list_dim_neg0',\n    'test_tensor_indices_sections',\n    'test_tensor_indices_sections_dim',\n    'test_tensor_indices_sections_dim_neg0',\n    'test_tensor_split_sections',\n    'test_tensor_split_sections_dim',\n    'test_tensor_split_sections_dim_neg0'\n}\n\nEXCLUDE_PYTHON_PRINT = {\n    # no support for BroadcastingList in python printer\n    'test_nn_max_unpool1d',\n    'test_nn_max_unpool2d',\n    'test_nn_max_unpool3d',\n    'test_nn_max_pool1d',\n    'test_nn_max_pool2d',\n    'test_nn_max_pool3d',\n    'test_nn_max_pool1d_with_indices',\n}\n\nEXCLUDE_ALIAS = {\n    # aliases, which may appear in method_tests but are tested elsewhere\n    'true_divide',\n\n    # Disable tests for lu from common_methods_invocations.py\n    # TODO(@nikitaved) Enable jit tests once autograd.Function does support scripting\n    'lu'\n}\n\n\nclass TestJitGeneratedModule(JitTestCase):\n    pass\n\n\nclass TestJitGeneratedFunctional(JitTestCase):\n    pass\n\n# UBSAN per-function exclusions don't seem to work with OpenMP pragmas,\n# and we have to disable the failing tests here instead.\nUBSAN_DISABLED_TESTS = [\n    \"test___rdiv___constant\",\n    \"test___rdiv___scalar_constant\",\n    \"test_addcdiv\",\n    \"test_addcdiv_broadcast_all\",\n    \"test_addcdiv_broadcast_rhs\",\n    \"test_addcdiv_scalar\",\n    \"test_addcdiv_scalar_broadcast_lhs\",\n    \"test_addcdiv_scalar_broadcast_rhs\",\n    \"test_addcdiv_scalar_scale\",\n    \"test_addcdiv_scalar_scale_broadcast_lhs\",\n    \"test_addcdiv_scalar_scale_broadcast_rhs\",\n    \"test_addcdiv_scale\",\n    \"test_addcdiv_scale_broadcast_all\",\n    \"test_addcdiv_scale_broadcast_rhs\",\n    \"test_add_broadcast_all\",\n    \"test_add_broadcast_lhs\",\n    \"test_add_broadcast_rhs\",\n    \"test_add_constant\",\n    \"test_add_scalar\",\n    \"test_add_scalar_broadcast_lhs\",\n    \"test_add_scalar_broadcast_rhs\",\n    \"test_div\",\n    \"test_div_broadcast_all\",\n    \"test_div_broadcast_lhs\",\n    \"test_div_broadcast_rhs\",\n    \"test_div_scalar\",\n    \"test_div_scalar_broadcast_lhs\",\n    \"test_div_scalar_broadcast_rhs\",\n    \"test_rsqrt\",\n    \"test_rsqrt_scalar\",\n    \"test_add\",\n    \"test_reciprocal\",\n    \"test_reciprocal_scalar\",\n]\n\nL = 20\nM = 10\nS = 5\n\ndef add_nn_module_test(*args, **kwargs):\n    no_grad = False if 'no_grad' not in kwargs else kwargs['no_grad']\n\n    if 'desc' in kwargs and 'eval' in kwargs['desc']:\n        # eval() is not supported, so skip these tests\n        return\n\n    test_name = get_nn_mod_test_name(**kwargs)\n\n    @suppress_warnings\n    def do_test(self):\n        if test_name in EXCLUDE_SCRIPT_MODULES:\n            return\n        if not kwargs.get('check_jit', True):\n            raise unittest.SkipTest('module test skipped on JIT')\n\n        module_name = get_nn_module_name_from_kwargs(**kwargs)\n\n        if 'constructor' in kwargs:\n            nn_module = kwargs['constructor']\n        else:\n            nn_module = getattr(torch.nn, module_name)\n\n        if \"FunctionalModule\" in str(nn_module):\n            return\n\n        if 'constructor_args_fn' in kwargs:\n            constructor_args = kwargs['constructor_args_fn']()\n        else:\n            constructor_args = kwargs.get('constructor_args', ())\n\n        def create_script_module(*args, **kwargs):\n            \"\"\"Construct a script module that passes arguments through to self.submodule\"\"\"\n            formals, tensors, actuals = get_script_args(args)\n\n            method_args = ', '.join(['self'] + actuals)\n            call_args_str = ', '.join(actuals)\n            call = \"self.submodule({})\".format(call_args_str)\n            script = script_method_template.format(method_args, call)\n\n            submodule_constants = []\n            if kwargs.get('is_constant'):\n                submodule_constants = ['submodule']\n\n            # Create module to use the script method\n            class TheModule(torch.jit.ScriptModule):\n                __constants__ = submodule_constants\n\n                def __init__(self):\n                    super(TheModule, self).__init__()\n                    self.submodule = nn_module(*constructor_args)\n\n            def make_module(script):\n                module = TheModule()\n                # check __repr__\n                str(module)\n                module.define(script)\n                return module\n\n            module = make_module(script)\n            self.assertExportImportModule(module, tensors)\n            create_script_module.last_graph = module.graph\n            mod = module(*args)\n            return mod\n\n        # Construct a normal nn module to stay consistent with create_script_module\n        # and make use of a single global rng_state in module initialization\n        def create_nn_module(*args, **kwargs):\n            module = nn_module(*constructor_args)\n            return module(*args)\n\n        # Set up inputs from tuple of sizes or constructor fn\n        dtype = torch.double\n        if 'input_fn' in kwargs:\n            input = kwargs['input_fn']()\n            if isinstance(input, Tensor):\n                input = (input,)\n\n            if all(tensor.is_complex() for tensor in input):\n                dtype = torch.cdouble\n        else:\n            input = (kwargs['input_size'],)\n\n        if 'target_size' in kwargs:\n            input = input + (kwargs['target_size'],)\n        elif 'target_fn' in kwargs:\n            if torch.is_tensor(input):\n                input = (input,)\n            input = input + (kwargs['target_fn'](),)\n        elif 'target' in kwargs:\n            input = input + (kwargs['target'],)\n\n        # Extra parameters to forward()\n        if 'extra_args' in kwargs:\n            input = input + kwargs['extra_args']\n\n        args_variable, kwargs_variable = create_input(input, dtype=dtype)\n        f_args_variable = deepcopy(unpack_variables(args_variable))\n\n        # TODO(issue#52052) Neither this nor no_grad should be required\n        # if check_against_reference() is updated to check gradients\n        # w.r.t. weights and then only check w.r.t. inputs if any\n        # inputs require it.\n        any_requires_grad = any(input.requires_grad for input in f_args_variable)\n\n        # Check against Python module as reference\n        check_against_reference(self, create_script_module, create_nn_module,\n                                lambda x: x, f_args_variable,\n                                no_grad=no_grad or not any_requires_grad)\n\n    if 'slowTest' in kwargs:\n        do_test = slowTest(do_test)\n\n    post_add_test(test_name, (), do_test, TestJitGeneratedModule)\n\n\ndef post_add_test(test_name, skipTestIf, do_test, test_class):\n    assert not hasattr(test_class, test_name), 'Two tests have the same name: ' + test_name\n\n    for skip in skipTestIf:\n        do_test = skip(do_test)\n\n    if not (TEST_WITH_UBSAN and test_name in UBSAN_DISABLED_TESTS):\n        setattr(test_class, test_name, do_test)\n\n\ndef normalize_check_ad(check_ad, name):\n    # normalized check_ad is 3-element tuple: (bool, List[str], List[str])\n    if len(check_ad) == 0:\n        check_ad = [False, ['aten::' + name], []]\n    elif len(check_ad) == 1:\n        check_ad = [check_ad[0], ['aten::' + name], []]\n    elif len(check_ad) == 2:\n        check_ad = [check_ad[0], check_ad[1], []]\n    elif len(check_ad) == 3:\n        check_ad = list(check_ad)\n    else:\n        raise Exception('Invalid check_ad, requires (bool, str|List[str], str|List[str])')\n\n    check_ad = [[t] if isinstance(t, str) else t for t in check_ad]\n\n    return check_ad\n\n\nclass TestProducerVersion(TestCase):\n\n    def test_version(self):\n        # issue gh-32561\n        self.assertTrue(torch.__version__.startswith(torch.onnx.producer_version))\n\nfor test in module_tests + new_module_tests + additional_module_tests:\n    add_nn_module_test(**test)\n\nfor test in criterion_tests:\n    test['no_grad'] = True\n    add_nn_module_test(**test)\n\nif __name__ == '__main__':\n    run_tests()\n    import jit.test_module_interface\n    suite = unittest.findTestCases(jit.test_module_interface)\n    unittest.TextTestRunner().run(suite)\n", "#include <torch/csrc/jit/frontend/script_type_parser.h>\n\n#include <ATen/core/type_factory.h>\n#include <torch/csrc/jit/frontend/parser.h>\n#include <torch/csrc/jit/ir/ir.h>\n#include <torch/custom_class.h>\n\nnamespace torch {\nnamespace jit {\nnamespace {\n\nbool isTorch(const Expr& expr) {\n  return expr.kind() == TK_VAR && Var(expr).name().name() == \"torch\";\n}\n\nstd::string collectQualname(const Select& select) {\n  Expr base = select.value();\n  if (base.kind() == TK_VAR) {\n    return Var(base).name().name() + \".\" + select.selector().name();\n  }\n  std::string basename = collectQualname(Select(base));\n  return basename + \".\" + select.selector().name();\n}\n\nconst std::unordered_map<std::string, c10::TypePtr>& string_to_type_lut() {\n  return c10::DefaultTypeFactory::basePythonTypes();\n}\n\n} // namespace\n\nTypePtr ScriptTypeParser::subscriptToType(\n    const std::string& typeName,\n    const Subscript& subscript) const {\n  if (typeName == \"Tuple\" || typeName == \"tuple\") {\n    if (subscript.subscript_exprs().size() == 1 &&\n        subscript.subscript_exprs()[0].kind() == TK_TUPLE_LITERAL) {\n      // `typing.Tuple` special cases syntax for empty tuple annotations,\n      // i.e. `typing.Tuple[()]`. Allow for parsing an empty tuple literal\n      // here. See https://docs.python.org/3/library/typing.html#typing.Tuple\n      auto tup_literal = TupleLiteral(subscript.subscript_exprs()[0]);\n      if (tup_literal.inputs().size() > 0) {\n        throw ErrorReport(tup_literal.range())\n            << \"Tuple literal in Tuple type annotation must not \"\n            << \"have any elements!\";\n      }\n      return TupleType::create({});\n    }\n    std::vector<TypePtr> subscript_expr_types;\n    for (auto expr : subscript.subscript_exprs()) {\n      subscript_expr_types.emplace_back(parseTypeFromExprImpl(expr));\n    }\n    return TupleType::create(subscript_expr_types);\n  } else if (typeName == \"List\" || typeName == \"list\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return ListType::create(elem_type);\n\n  } else if (typeName == \"Optional\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return OptionalType::create(elem_type);\n\n  } else if (typeName == \"Union\") {\n    std::vector<TypePtr> subscript_expr_types;\n    subscript_expr_types.reserve(subscript.subscript_exprs().size());\n    for (auto expr : subscript.subscript_exprs()) {\n      subscript_expr_types.emplace_back(parseTypeFromExprImpl(expr));\n    }\n    return UnionType::create(subscript_expr_types);\n  } else if (typeName == \"Future\" || typeName == \"torch.jit.Future\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return FutureType::create(elem_type);\n  } else if (typeName == \"RRef\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return RRefType::create(elem_type);\n  } else if (typeName == \"Dict\" || typeName == \"dict\") {\n    if (subscript.subscript_exprs().size() != 2) {\n      throw ErrorReport(subscript)\n          << \" expected exactly 2 element types but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto key_type = parseTypeFromExprImpl(subscript.subscript_exprs()[0]);\n    auto value_type = parseTypeFromExprImpl(subscript.subscript_exprs()[1]);\n    return DictType::create(key_type, value_type);\n  } else {\n    throw ErrorReport(subscript.range())\n        << \"Unknown type constructor \" << typeName;\n  }\n}\n\nc10::optional<std::pair<TypePtr, int32_t>> ScriptTypeParser::parseBroadcastList(\n    const Expr& expr) const {\n  // Alias torch.nn._common_types._size_?_t to BroadcastingList?[int]\n  if (expr.kind() == TK_VAR) {\n    auto var = Var(expr);\n    auto& name = var.name().name();\n    constexpr auto _size_prefix = \"_size_\";\n    constexpr auto _size_suffix = \"_t\";\n    constexpr auto _size_n_len = 9; // strlen(\"_size_X_t\")\n    constexpr auto _size_prefix_len = 6; // strlen(\"_size_\");\n    if (name.find(_size_prefix) == 0 && name.length() == _size_n_len &&\n        name.find(_size_suffix) == _size_prefix_len + 1 &&\n        ::isdigit(name[_size_prefix_len])) {\n      int n = name[_size_prefix_len] - '0';\n      return std::pair<TypePtr, int32_t>(ListType::create(IntType::get()), n);\n    }\n  }\n\n  if (expr.kind() != TK_SUBSCRIPT)\n    return c10::nullopt;\n  auto subscript = Subscript(expr);\n  if (subscript.value().kind() != TK_VAR)\n    return c10::nullopt;\n  auto var = Var(subscript.value());\n  auto subscript_exprs = subscript.subscript_exprs();\n\n  // handle the case where the BroadcastingList is wrapped in a Optional type\n  if (var.name().name() == \"Optional\") {\n    auto broadcast_list = parseBroadcastList(subscript_exprs[0]);\n    if (broadcast_list) {\n      TypePtr opt_type = OptionalType::create(broadcast_list->first);\n      return std::pair<TypePtr, int32_t>(opt_type, broadcast_list->second);\n    } else {\n      return c10::nullopt;\n    }\n  } else if (var.name().name().find(\"BroadcastingList\") != 0) {\n    return c10::nullopt;\n  }\n\n  if (subscript_exprs.size() != 1)\n    throw ErrorReport(subscript.subscript_exprs().range())\n        << \"BroadcastingList/Optional[BroadcastingList] \"\n           \"must be subscripted with a type\";\n\n  auto typ = subscript_exprs[0];\n  auto len = var.name().name().substr(strlen(\"BroadcastingList\"));\n\n  if (typ.kind() != TK_VAR)\n    throw ErrorReport(subscript.value().range())\n        << \"Subscripted type must be a type identifier\";\n\n  auto value_name = Var(typ).name().name();\n  if (value_name != \"float\" && value_name != \"int\")\n    throw ErrorReport(subscript.value().range())\n        << \"Broadcastable lists only supported for int or float\";\n\n  auto elem_ptr = string_to_type_lut().find(value_name);\n  AT_ASSERT(elem_ptr != string_to_type_lut().end());\n  TypePtr list_ptr = ListType::create(elem_ptr->second);\n\n  const char* len_c = len.c_str();\n  // NOLINTNEXTLINE(cppcoreguidelines-init-variables)\n  char* end;\n  size_t len_v = strtoull(len_c, &end, 10);\n  if (end != len_c + len.size()) {\n    throw ErrorReport(subscript.subscript_exprs().range())\n        << \"subscript of Broadcastable list must be a positive integer\";\n  }\n  return std::pair<TypePtr, int32_t>(list_ptr, len_v);\n}\n\n// gets the base type name given namespaces where the types live\n// turns torch.Tensor -> Tensor, X -> X\nc10::optional<std::string> ScriptTypeParser::parseBaseTypeName(\n    const Expr& expr) const {\n  switch (expr.kind()) {\n    case TK_VAR: {\n      return Var(expr).name().name();\n    }\n    case TK_NONE: {\n      return \"None\";\n    }\n    case TK_NONE_TYPE: {\n      return \"NoneType\";\n    }\n    case '.': {\n      auto select = Select(expr);\n      const std::string& name = select.selector().name();\n      // Special case for torch.Tensor and its' subclasses\n      const std::unordered_set<std::string> tensor_subtypes = {\n          \"Tensor\",\n          \"LongTensor\",\n          \"FloatTensor\",\n          \"DoubleTensor\",\n          \"IntTensor\",\n          \"ShortTensor\",\n          \"HalfTensor\",\n          \"CharTensor\",\n          \"ByteTensor\",\n          \"BoolTensor\"};\n      if (isTorch(select.value()) && tensor_subtypes.count(name) == 1) {\n        return name;\n      } else {\n        // Otherwise, it's a fully qualified class name\n        return collectQualname(select);\n      }\n    } break;\n  }\n  return at::nullopt;\n}\n\nTypePtr ScriptTypeParser::parseTypeFromExpr(const Expr& expr) const {\n  // the resolver needs to recursively resolve the expression, so to avoid\n  // resolving all type expr subtrees we only use it for the top level\n  // expression and base type names.\n  if (resolver_) {\n    if (auto typePtr =\n            resolver_->resolveType(expr.range().text().str(), expr.range())) {\n      return typePtr;\n    }\n  }\n  return parseTypeFromExprImpl(expr);\n}\n\nTypePtr ScriptTypeParser::parseTypeFromExprImpl(const Expr& expr) const {\n  if (expr.kind() == TK_SUBSCRIPT) {\n    auto subscript = Subscript(expr);\n    auto value_name = parseBaseTypeName(subscript.value());\n    if (!value_name) {\n      throw ErrorReport(subscript.value().range())\n          << \"Subscripted type must be a type identifier\";\n    }\n    return subscriptToType(*value_name, subscript);\n\n  } else if (expr.kind() == TK_STRINGLITERAL) {\n    const auto& type_name = StringLiteral(expr).text();\n\n    // Check if the type is a custom class. This is done by checking\n    // if type_name starts with \"torch.classes.\"\n    if (type_name.find(\"torch.classes.\") == 0) {\n      auto custom_class_type = getCustomClass(\"__torch__.\" + type_name);\n      return custom_class_type;\n    }\n\n    // `torch.cuda.Stream` and `torch.cuda.Event` are aliased as\n    // custom classes of type torch.classes.cuda.Stream and\n    // torch.classes.cuda.Event respectively. Return the respective\n    // custom class types for these two cases.\n    if (type_name.find(\"torch.cuda.Stream\") == 0) {\n      auto custom_class_type =\n          getCustomClass(\"__torch__.torch.classes.cuda.Stream\");\n      return custom_class_type;\n    }\n\n    if (type_name.find(\"torch.cuda.Event\") == 0) {\n      auto custom_class_type =\n          getCustomClass(\"__torch__.torch.classes.cuda.Event\");\n      return custom_class_type;\n    }\n\n    if (resolver_) {\n      if (auto typePtr = resolver_->resolveType(type_name, expr.range())) {\n        return typePtr;\n      }\n    }\n\n    throw ErrorReport(expr) << \"Unknown type name '\" << type_name << \"'\";\n  } else if (auto name = parseBaseTypeName(expr)) {\n    auto itr = string_to_type_lut().find(*name);\n    if (itr != string_to_type_lut().end()) {\n      return itr->second;\n    }\n    if (resolver_) {\n      if (auto typePtr = resolver_->resolveType(*name, expr.range())) {\n        return typePtr;\n      }\n    }\n\n    if (auto custom_class_type = getCustomClass(*name)) {\n      return custom_class_type;\n    }\n\n    throw ErrorReport(expr) << \"Unknown type name '\" << *name << \"'\";\n  }\n  throw ErrorReport(expr.range())\n      << \"Expression of type \" << kindToString(expr.kind())\n      << \" cannot be used in a type expression\";\n}\n\nTypePtr ScriptTypeParser::parseType(const std::string& str) {\n  Parser p(std::make_shared<Source>(str));\n  return parseTypeFromExpr(p.parseExp());\n}\n\nstd::vector<IValue> ScriptTypeParser::evaluateDefaults(\n    const SourceRange& r,\n    const std::vector<Expr>& default_types,\n    const std::vector<Expr>& default_exprs) {\n  std::vector<IValue> default_values;\n  if (default_exprs.empty())\n    return default_values;\n  // To evaluate the default expressions, we create a graph with no inputs,\n  // and whose returns are the default values we need.\n  // We then run constant prop on this graph and check the results are\n  // constant. This approach avoids having to have separate handling of\n  // default arguments from standard expressions by piecing together existing\n  // machinery for graph generation, constant propgation, and constant\n  // extraction.\n  auto tuple_type = Subscript::create(\n      r,\n      Var::create(r, Ident::create(r, \"Tuple\")),\n      List<Expr>::create(r, default_types));\n  auto blank_decl = Decl::create(\n      r, List<Param>::create(r, {}), Maybe<Expr>::create(r, tuple_type));\n\n  auto tuple_expr =\n      TupleLiteral::create(r, List<Expr>::create(r, default_exprs));\n  auto ret = Return::create(r, tuple_expr);\n  auto def = Def::create(\n      r,\n      Ident::create(r, \"defaults\"),\n      blank_decl,\n      List<Stmt>::create(r, {ret}));\n\n  CompilationUnit cu;\n  cu.define(\n      c10::nullopt,\n      /*properties=*/{},\n      /*propResolvers=*/{},\n      {def},\n      {resolver_},\n      nullptr);\n  Stack stack;\n  // XXX: We need to turn optimization off here because otherwise we try to\n  // recursively initialize stuff in DecomposeOps.\n  GraphOptimizerEnabledGuard guard(false);\n  cu.get_function(def.name().name()).run(stack);\n  return stack.at(0).toTupleRef().elements().vec();\n}\n\nstd::vector<Argument> ScriptTypeParser::parseArgsFromDecl(\n    const Decl& decl,\n    bool skip_self) {\n  auto params_begin = decl.params().begin();\n  auto params_end = decl.params().end();\n  if (skip_self) {\n    ++params_begin;\n  }\n  std::vector<Argument> retval;\n\n  std::vector<Expr> default_types;\n  std::vector<Expr> default_exprs;\n  // gather any non-empty default arguments\n  for (auto it = params_begin; it != params_end; ++it) {\n    auto param = *it;\n    auto def = param.defaultValue();\n    if (def.present()) {\n      if (!param.type().present()) {\n        // We require explicit type-hints for default expressions.\n        // If param doesn't have a type, we could default to \"Tensor\",\n        // just like what happens in the Python frontend.\n        // However here things are a bit more complicated, because\n        // default expressions are evaluated using a custom-built\n        // graph, and error messages coming out of that in case\n        // the type doesn't match the value are quite obscure.\n        throw ErrorReport(param.range())\n            << \"Keyword arguments with defaults need to be type-hinted (TorchScript C++ frontend)\";\n      }\n      default_types.emplace_back(param.type().get());\n      default_exprs.emplace_back(def.get());\n    }\n  }\n\n  auto default_values =\n      evaluateDefaults(decl.range(), default_types, default_exprs);\n\n  auto defaults_it = default_values.begin();\n  for (auto it = params_begin; it != params_end; ++it) {\n    auto decl_arg = *it;\n\n    TypePtr type;\n    c10::optional<int32_t> N = c10::nullopt;\n    if (!decl_arg.type().present()) {\n      // If this param doesn't have a type, default to \"tensor\"\n      type = TensorType::getInferred();\n    } else {\n      // BroadcastList list can only appear at the argument level\n      Expr type_expr = decl_arg.type().get();\n      if (auto maybe_broad_list = parseBroadcastList(type_expr)) {\n        type = maybe_broad_list->first;\n        N = maybe_broad_list->second;\n      } else {\n        type = parseTypeFromExpr(decl_arg.type().get());\n      }\n    }\n    c10::optional<IValue> default_value = c10::nullopt;\n    if (decl_arg.defaultValue().present()) {\n      default_value = *defaults_it++;\n    }\n    auto arg = Argument(\n        decl_arg.ident().name(),\n        type,\n        N,\n        default_value,\n        decl_arg.kwarg_only(),\n        /*alias_info=*/c10::nullopt);\n    retval.push_back(arg);\n  }\n  return retval;\n}\n\nstd::vector<Argument> ScriptTypeParser::parseReturnFromDecl(const Decl& decl) {\n  // we represent no annoation on a return type as having no values in the\n  // schema's return() list\n  // in emitReturn we take the actual return value to be the value of the\n  // return statement if no one was provided here\n  if (!decl.return_type().present())\n    return {};\n\n  if (parseBroadcastList(decl.return_type().get()))\n    throw ErrorReport(decl.return_type().range())\n        << \"Broadcastable lists cannot appear as a return type\";\n\n  TypePtr parsed_type;\n  Expr type_expr = decl.return_type().get();\n  parsed_type = parseTypeFromExpr(type_expr);\n  return {Argument(\n      \"\",\n      parsed_type,\n      /*N =*/c10::nullopt,\n      /*default_value =*/c10::nullopt,\n      /*kwarg_only =*/false)};\n}\nFunctionSchema ScriptTypeParser::parseSchemaFromDef(\n    const Def& def,\n    bool skip_self) {\n  const auto name = def.name().name();\n  std::vector<Argument> args = parseArgsFromDecl(def.decl(), skip_self);\n  std::vector<Argument> returns = parseReturnFromDecl(def.decl());\n  return FunctionSchema(\n      name, \"\", std::move(args), std::move(returns), false, false);\n}\n\nc10::IValue ScriptTypeParser::parseClassConstant(const Assign& assign) {\n  if (assign.lhs().kind() != TK_VAR) {\n    throw ErrorReport(assign.range())\n        << \"Expected to a variable for class constant\";\n  }\n  const auto final_type = assign.type().get();\n  auto expr = assign.rhs().get();\n  if (final_type.kind() != TK_SUBSCRIPT) {\n    throw ErrorReport(assign.range())\n        << \"Expected subscripted type for class constant\";\n  }\n  auto subscript = Subscript(final_type);\n  auto value_name = parseBaseTypeName(subscript.value());\n  if (!value_name) {\n    throw ErrorReport(subscript.value().range())\n        << \"Subscripted type must be a type identifier\";\n  }\n  if (*value_name != \"Final\") {\n    throw ErrorReport(subscript.range())\n        << \"Base type must be Final for class constant\";\n  }\n  if (subscript.subscript_exprs().size() != 1) {\n    throw ErrorReport(subscript)\n        << \" expected exactly one element type but found \"\n        << subscript.subscript_exprs().size();\n  }\n  auto type = *subscript.subscript_exprs().begin();\n  auto default_val = evaluateDefaults(expr.range(), {type}, {expr});\n  return *default_val.begin();\n}\n\n} // namespace jit\n} // namespace torch\n", "import ast\nimport enum\nimport inspect\nimport re\nimport builtins\nimport torch\nimport warnings\nfrom .._jit_internal import List, Tuple, is_tuple, is_list, Dict, is_dict, Optional, \\\n    is_optional, _qualified_name, Any, Future, is_future, is_ignored_fn, Union, is_union\nfrom .._jit_internal import BroadcastingList1, BroadcastingList2, BroadcastingList3  # type: ignore[attr-defined]\nfrom ._state import _get_script_class\n\nfrom torch._C import TensorType, TupleType, FloatType, IntType, ComplexType, \\\n    ListType, StringType, DictType, BoolType, OptionalType, InterfaceType, AnyType, \\\n    NoneType, DeviceObjType, StreamObjType, FutureType, EnumType, UnionType, NumberType\n\n\nfrom textwrap import dedent\nfrom torch._sources import get_source_lines_and_file\nfrom typing import Type\n\nif torch.distributed.rpc.is_available():\n    from .._jit_internal import RRef, is_rref\n    from torch._C import RRefType\n\nfrom torch._ops import OpOverloadPacket\n\nclass Module(object):\n    def __init__(self, name, members):\n        self.name = name\n        self.members = members\n\n    def __getattr__(self, name):\n        try:\n            return self.members[name]\n        except KeyError:\n            raise RuntimeError(f\"Module {self.name} has no member called {name}\") from None\n\n\nclass EvalEnv(object):\n    env = {\n        'torch': Module('torch', {'Tensor': torch.Tensor}),\n        'Tensor': torch.Tensor,\n        'typing': Module('typing', {'Tuple': Tuple}),\n        'Tuple': Tuple,\n        'List': List,\n        'Dict': Dict,\n        'Optional': Optional,\n        'Union': Union,\n        'Future': Future\n    }\n\n    def __init__(self, rcb):\n        self.rcb = rcb\n        if torch.distributed.rpc.is_available():\n            self.env['RRef'] = RRef\n\n    def __getitem__(self, name):\n        if name in self.env:\n            return self.env[name]\n        if self.rcb is not None:\n            return self.rcb(name)\n        return getattr(builtins, name, None)\n\ndef get_signature(fn, rcb, loc, is_method):\n    if isinstance(fn, OpOverloadPacket):\n        signature = try_real_annotations(fn.op, loc)\n    else:\n        signature = try_real_annotations(fn, loc)\n    if signature is not None and is_method:\n        # If this is a method, then the signature will include a type for\n        # `self`, but type comments do not contain a `self`. So strip it\n        # away here so everything is consistent (`inspect.ismethod` does\n        # not work here since `fn` is unbound at this point)\n        param_types, return_type = signature\n        param_types = param_types[1:]\n        signature = (param_types, return_type)\n\n    if signature is None:\n        type_line, source = None, None\n        try:\n            source = dedent(''.join(get_source_lines_and_file(fn)[0]))\n            type_line = get_type_line(source)\n        except TypeError:\n            pass\n        # This might happen both because we failed to get the source of fn, or\n        # because it didn't have any annotations.\n        if type_line is not None:\n            signature = parse_type_line(type_line, rcb, loc)\n\n    return signature\n\n\ndef is_function_or_method(the_callable):\n    # A stricter version of `inspect.isroutine` that does not pass for built-in\n    # functions\n    return inspect.isfunction(the_callable) or inspect.ismethod(the_callable)\n\n\ndef is_vararg(the_callable):\n    if not is_function_or_method(the_callable) and hasattr(the_callable, '__call__'):  # noqa: B004\n        # If `the_callable` is a class, de-sugar the call so we can still get\n        # the signature\n        the_callable = the_callable.__call__\n\n    if is_function_or_method(the_callable):\n        return inspect.getfullargspec(the_callable).varargs is not None\n    else:\n        return False\n\n\ndef get_param_names(fn, n_args):\n    if isinstance(fn, OpOverloadPacket):\n        fn = fn.op\n\n    if not is_function_or_method(fn) and hasattr(fn, '__call__') and is_function_or_method(fn.__call__):  # noqa: B004\n        # De-sugar calls to classes\n        fn = fn.__call__\n\n    if is_function_or_method(fn):\n        if is_ignored_fn(fn):\n            fn = inspect.unwrap(fn)\n        return inspect.getfullargspec(fn).args\n    else:\n        # The `fn` was not a method or function (maybe a class with a __call__\n        # method, so use a default param name list)\n        return [str(i) for i in range(n_args)]\n\n\ndef check_fn(fn, loc):\n    # Make sure the function definition is not a class instantiation\n    try:\n        source = dedent(''.join(get_source_lines_and_file(fn)[0]))\n    except (TypeError, IOError):\n        return\n    if source is None:\n        return\n\n    py_ast = ast.parse(source)\n    if len(py_ast.body) == 1 and isinstance(py_ast.body[0], ast.ClassDef):\n        raise torch.jit.frontend.FrontendError(\n            loc, f\"Cannot instantiate class '{py_ast.body[0].name}' in a script function\")\n    if len(py_ast.body) != 1 or not isinstance(py_ast.body[0], ast.FunctionDef):\n        raise torch.jit.frontend.FrontendError(loc, \"Expected a single top-level function\")\n\n\ndef parse_type_line(type_line, rcb, loc):\n    \"\"\"Parses a type annotation specified as a comment.\n\n    Example inputs:\n        # type: (Tensor, torch.Tensor) -> Tuple[Tensor]\n        # type: (Tensor, Tuple[Tensor, Tensor]) -> Tensor\n    \"\"\"\n    arg_ann_str, ret_ann_str = split_type_line(type_line)\n\n    try:\n        arg_ann = eval(arg_ann_str, {}, EvalEnv(rcb))  # type: ignore[arg-type] # noqa: P204\n    except (NameError, SyntaxError) as e:\n        raise RuntimeError(\"Failed to parse the argument list of a type annotation\") from e\n\n    if not isinstance(arg_ann, tuple):\n        arg_ann = (arg_ann,)\n\n    try:\n        ret_ann = eval(ret_ann_str, {}, EvalEnv(rcb))  # type: ignore[arg-type] # noqa: P204\n    except (NameError, SyntaxError) as e:\n        raise RuntimeError(\"Failed to parse the return type of a type annotation\") from e\n\n    arg_types = [ann_to_type(ann, loc) for ann in arg_ann]\n    return arg_types, ann_to_type(ret_ann, loc)\n\n\ndef get_type_line(source):\n    \"\"\"Tries to find the line containing a comment with the type annotation.\"\"\"\n    type_comment = '# type:'\n\n    lines = source.split('\\n')\n    lines = [(line_num, line) for line_num, line in enumerate(lines)]\n    type_lines = list(filter(lambda line: type_comment in line[1], lines))\n    # `type: ignore` comments may be needed in JIT'ed functions for mypy, due\n    # to the hack in torch/_VF.py.\n\n    # An ignore type comment can be of following format:\n    #   1) type: ignore\n    #   2) type: ignore[rule-code]\n    # This ignore statement must be at the end of the line\n\n    # adding an extra backslash before the space, to avoid triggering\n    # one of the checks in .github/workflows/lint.yml\n    type_pattern = re.compile(\"# type:\\\\ ignore(\\\\[[a-zA-Z-]+\\\\])?$\")\n    type_lines = list(filter(lambda line: not type_pattern.search(line[1]),\n                             type_lines))\n\n    if len(type_lines) == 0:\n        # Catch common typo patterns like extra spaces, typo in 'ignore', etc.\n        wrong_type_pattern = re.compile(\"#[\\t ]*type[\\t ]*(?!: ignore(\\\\[.*\\\\])?$):\")\n        wrong_type_lines = list(filter(lambda line: wrong_type_pattern.search(line[1]), lines))\n        if len(wrong_type_lines) > 0:\n            raise RuntimeError(\"The annotation prefix in line \" + str(wrong_type_lines[0][0])\n                               + \" is probably invalid.\\nIt must be '# type:'\"\n                               + \"\\nSee PEP 484 (https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code)\"  # noqa: B950\n                               + \"\\nfor examples\")\n        return None\n    elif len(type_lines) == 1:\n        # Only 1 type line, quit now\n        return type_lines[0][1].strip()\n\n    # Parse split up argument types according to PEP 484\n    # https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code\n    return_line = None\n    parameter_type_lines = []\n    for line_num, line in type_lines:\n        if '# type: (...) -> ' in line:\n            return_line = (line_num, line)\n            break\n        elif type_comment in line:\n            parameter_type_lines.append(line)\n    if return_line is None:\n        raise RuntimeError(\n            \"Return type line '# type: (...) -> ...' not found on multiline \"\n            \"type annotation\\nfor type lines:\\n\" +\n            '\\n'.join([line[1] for line in type_lines]) +\n            \"\\n(See PEP 484 https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code)\")\n\n    def get_parameter_type(line):\n        item_type = line[line.find(type_comment) + len(type_comment):]\n        return item_type.strip()\n\n    types = map(get_parameter_type, parameter_type_lines)\n    parameter_types = \", \".join(types)\n\n    return return_line[1].replace(\"...\", parameter_types)\n\n\ndef split_type_line(type_line):\n    \"\"\"Splits the comment with the type annotation into parts for argument and return types.\n\n    For example, for an input of:\n        # type: (Tensor, torch.Tensor) -> Tuple[Tensor, Tensor]\n\n    This function will return:\n        (\"(Tensor, torch.Tensor)\", \"Tuple[Tensor, Tensor]\")\n\n    \"\"\"\n    start_offset = len('# type:')\n    try:\n        arrow_pos = type_line.index('->')\n    except ValueError:\n        raise RuntimeError(\"Syntax error in type annotation (cound't find `->`)\") from None\n    return type_line[start_offset:arrow_pos].strip(), type_line[arrow_pos + 2:].strip()\n\n\ndef try_real_annotations(fn, loc):\n    \"\"\"Tries to use the Py3.5+ annotation syntax to get the type.\"\"\"\n    try:\n        # Note: anything annotated as `Optional[T]` will automatically\n        # be returned as `Union[T, None]` per\n        # https://github.com/python/typing/blob/master/src/typing.py#L850\n        sig = inspect.signature(fn)\n    except ValueError:\n        return None\n\n    all_annots = [sig.return_annotation] + [p.annotation for p in sig.parameters.values()]\n    if all(ann is sig.empty for ann in all_annots):\n        return None\n\n    arg_types = [ann_to_type(p.annotation, loc)\n                 for p in sig.parameters.values()]\n    return_type = ann_to_type(sig.return_annotation, loc)\n    return arg_types, return_type\n\n\n# Finds common type for enum values belonging to an Enum class. If not all\n# values have the same type, AnyType is returned.\ndef get_enum_value_type(e: Type[enum.Enum], loc):\n    enum_values: List[enum.Enum] = list(e)\n    if not enum_values:\n        raise ValueError(f\"No enum values defined for: '{e.__class__}'\")\n\n    types = {type(v.value) for v in enum_values}\n    ir_types = [try_ann_to_type(t, loc) for t in types]\n\n    # If Enum values are of different types, an exception will be raised here.\n    # Even though Python supports this case, we chose to not implement it to\n    # avoid overcomplicate logic here for a rare use case. Please report a\n    # feature request if you find it necessary.\n    res = torch._C.unify_type_list(ir_types)\n    if not res:\n        return AnyType.get()\n    return res\n\ndef is_tensor(ann):\n    if issubclass(ann, torch.Tensor):\n        return True\n\n    if issubclass(ann, (torch.LongTensor, torch.DoubleTensor, torch.FloatTensor,\n                        torch.IntTensor, torch.ShortTensor, torch.HalfTensor,\n                        torch.CharTensor, torch.ByteTensor, torch.BoolTensor)):\n        warnings.warn(\"TorchScript will treat type annotations of Tensor \"\n                      \"dtype-specific subtypes as if they are normal Tensors. \"\n                      \"dtype constraints are not enforced in compilation either.\")\n        return True\n\n    return False\n\n\n\ndef try_ann_to_type(ann, loc):\n    if ann is inspect.Signature.empty:\n        return TensorType.getInferred()\n    if ann is None:\n        return NoneType.get()\n    if inspect.isclass(ann) and is_tensor(ann):\n        return TensorType.get()\n    if is_tuple(ann):\n        # Special case for the empty Tuple type annotation `Tuple[()]`\n        if len(ann.__args__) == 1 and ann.__args__[0] == ():\n            return TupleType([])\n        return TupleType([try_ann_to_type(a, loc) for a in ann.__args__])\n    if is_list(ann):\n        elem_type = try_ann_to_type(ann.__args__[0], loc)\n        if elem_type:\n            return ListType(elem_type)\n    if is_dict(ann):\n        key = try_ann_to_type(ann.__args__[0], loc)\n        value = try_ann_to_type(ann.__args__[1], loc)\n        # Raise error if key or value is None\n        if key is None:\n            raise ValueError(f\"Unknown type annotation: '{ann.__args__[0]}' at {loc.highlight()}\")\n        if value is None:\n            raise ValueError(f\"Unknown type annotation: '{ann.__args__[1]}' at {loc.highlight()}\")\n        return DictType(key, value)\n    if is_optional(ann):\n        if issubclass(ann.__args__[1], type(None)):\n            contained = ann.__args__[0]\n        else:\n            contained = ann.__args__[1]\n        valid_type = try_ann_to_type(contained, loc)\n        msg = \"Unsupported annotation {} could not be resolved because {} could not be resolved.\"\n        assert valid_type, msg.format(repr(ann), repr(contained))\n        return OptionalType(valid_type)\n    if is_union(ann):\n        # TODO: this is hack to recognize NumberType\n        if set(ann.__args__) == set([int, float, complex]):\n            return NumberType.get()\n        inner: List = []\n        # We need these extra checks because both `None` and invalid\n        # values will return `None`\n        # TODO: Determine if the other cases need to be fixed as well\n        for a in ann.__args__:\n            if a is None:\n                inner.append(NoneType.get())\n            maybe_type = try_ann_to_type(a, loc)\n            msg = \"Unsupported annotation {} could not be resolved because {} could not be resolved.\"\n            assert maybe_type, msg.format(repr(ann), repr(maybe_type))\n            inner.append(maybe_type)\n        return UnionType(inner)    # type: ignore[arg-type]\n    if torch.distributed.rpc.is_available() and is_rref(ann):\n        return RRefType(try_ann_to_type(ann.__args__[0], loc))\n    if is_future(ann):\n        return FutureType(try_ann_to_type(ann.__args__[0], loc))\n    if ann is float:\n        return FloatType.get()\n    if ann is complex:\n        return ComplexType.get()\n    if ann is int:\n        return IntType.get()\n    if ann is str:\n        return StringType.get()\n    if ann is bool:\n        return BoolType.get()\n    if ann is Any:\n        return AnyType.get()\n    if ann is type(None):\n        return NoneType.get()\n    if inspect.isclass(ann) and hasattr(ann, \"__torch_script_interface__\"):\n        return InterfaceType(ann.__torch_script_interface__)\n    if ann is torch.device:\n        return DeviceObjType.get()\n    if ann is torch.Stream:\n        return StreamObjType.get()\n    if ann is torch.dtype:\n        return IntType.get()  # dtype not yet bound in as its own type\n    if inspect.isclass(ann) and issubclass(ann, enum.Enum):\n        if _get_script_class(ann) is None:\n            scripted_class = torch.jit._script._recursive_compile_class(ann, loc)\n            name = scripted_class.qualified_name()\n        else:\n            name = _qualified_name(ann)\n        return EnumType(name, get_enum_value_type(ann, loc), list(ann))\n    if inspect.isclass(ann):\n        maybe_script_class = _get_script_class(ann)\n        if maybe_script_class is not None:\n            return maybe_script_class\n        if torch._jit_internal.can_compile_class(ann):\n            return torch.jit._script._recursive_compile_class(ann, loc)\n\n    # Maybe resolve a NamedTuple to a Tuple Type\n    def fake_rcb(key):\n        return None\n    return torch._C._resolve_type_from_object(ann, loc, fake_rcb)\n\n\ndef ann_to_type(ann, loc):\n    the_type = try_ann_to_type(ann, loc)\n    if the_type is not None:\n        return the_type\n    raise ValueError(f\"Unknown type annotation: '{ann}' at {loc.highlight()}\")\n\n\n__all__ = [\n    'Any',\n    'List',\n    'BroadcastingList1',\n    'BroadcastingList2',\n    'BroadcastingList3',\n    'Tuple',\n    'is_tuple',\n    'is_list',\n    'Dict',\n    'is_dict',\n    'is_optional',\n    'is_union',\n    'TensorType',\n    'TupleType',\n    'FloatType',\n    'ComplexType',\n    'IntType',\n    'ListType',\n    'StringType',\n    'DictType',\n    'AnyType',\n    'Module',\n    # TODO: Consider not exporting these during wildcard import (reserve\n    # that for the types; for idiomatic typing code.)\n    'get_signature',\n    'check_fn',\n    'get_param_names',\n    'parse_type_line',\n    'get_type_line',\n    'split_type_line',\n    'try_real_annotations',\n    'try_ann_to_type',\n    'ann_to_type',\n]\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# Owner(s): [\"oncall: jit\"]\n\nimport torch\n\n# This is how we include tests located in test/jit/...\n# They are included here so that they are invoked when you call `test_jit.py`,\n# do not run these test files directly.\nfrom jit.test_tracer import TestTracer, TestMixTracingScripting  # noqa: F401\nfrom jit.test_recursive_script import TestRecursiveScript  # noqa: F401\nfrom jit.test_type_sharing import TestTypeSharing  # noqa: F401\nfrom jit.test_logging import TestLogging  # noqa: F401\nfrom jit.test_backends import TestBackends, TestBackendsWithCompiler  # noqa: F401\nfrom jit.test_backend_nnapi import TestNnapiBackend  # noqa: F401\nfrom jit.test_list_dict import TestList, TestDict, TestNamedTuple, TestScriptDict, TestScriptList  # noqa: F401\nfrom jit.test_async import TestAsync  # noqa: F401\nfrom jit.test_data_parallel import TestDataParallel  # noqa: F401\nfrom jit.test_models import TestModels  # noqa: F401\nfrom jit.test_modules import TestModules  # noqa: F401\nfrom jit.test_autodiff import TestAutodiffJit  # noqa: F401\nfrom jit.test_autodiff_subgraph_slicing import TestAutodiffSubgraphSlicing  # noqa: F401\nfrom jit.test_custom_operators import TestCustomOperators  # noqa: F401\nfrom jit.test_graph_rewrite_passes import TestGraphRewritePasses  # noqa: F401\nfrom jit.test_class_type import TestClassType  # noqa: F401\nfrom jit.test_builtins import TestBuiltins, TestTensorBuiltins  # noqa: F401\nfrom jit.test_ignore_context_manager import TestIgnoreContextManager  # noqa: F401\nfrom jit.test_symbolic_shape_analysis import TestSymbolicShapeAnalysis  # noqa: F401\nfrom jit.test_op_decompositions import TestOpDecompositions  # noqa: F401\nfrom jit.test_unsupported_ops import TestUnsupportedOps  # noqa: F401\nfrom jit.test_freezing import TestFreezing, TestFrozenOptimizations, TestMKLDNNReinplacing  # noqa: F401\nfrom jit.test_peephole import TestPeephole  # noqa: F401\nfrom jit.test_alias_analysis import TestAliasAnalysis  # noqa: F401\nfrom jit.test_save_load import TestSaveLoad, TestSaveLoadFlatbuffer  # noqa: F401\nfrom jit.test_save_load_for_op_version import TestSaveLoadForOpVersion  # noqa: F401\nfrom jit.test_module_containers import TestModuleContainers  # noqa: F401\nfrom jit.test_python_bindings import TestPythonBindings  # noqa: F401\nfrom jit.test_python_ir import TestPythonIr  # noqa: F401\nfrom jit.test_functional_blocks import TestFunctionalBlocks  # noqa: F401\nfrom jit.test_remove_mutation import TestRemoveMutation  # noqa: F401\nfrom jit.test_torchbind import TestTorchbind  # noqa: F401\nfrom jit.test_module_interface import TestModuleInterface  # noqa: F401  # noqa: F401\nfrom jit.test_with import TestWith  # noqa: F401\nfrom jit.test_enum import TestEnum  # noqa: F401\nfrom jit.test_string_formatting import TestStringFormatting  # noqa: F401\nfrom jit.test_profiler import TestProfiler  # noqa: F401\nfrom jit.test_slice import TestSlice  # noqa: F401\nfrom jit.test_ignorable_args import TestIgnorableArgs  # noqa: F401\nfrom jit.test_hooks import TestHooks  # noqa: F401\nfrom jit.test_warn import TestWarn  # noqa: F401\nfrom jit.test_isinstance import TestIsinstance  # noqa: F401\nfrom jit.test_cuda import TestCUDA  # noqa: F401\nfrom jit.test_python_builtins import TestPythonBuiltinOP  # noqa: F401\nfrom jit.test_typing import TestTyping  # noqa: F401\nfrom jit.test_hash import TestHash  # noqa: F401\nfrom jit.test_complex import TestComplex  # noqa: F401\nfrom jit.test_jit_utils import TestJitUtils  # noqa: F401\nfrom jit.test_scriptmod_ann import TestScriptModuleInstanceAttributeTypeAnnotation  # noqa: F401\nfrom jit.test_types import TestTypesAndAnnotation  # noqa: F401\nfrom jit.test_misc import TestMisc  # noqa: F401\nfrom jit.test_upgraders import TestUpgraders  # noqa: F401\nfrom jit.test_pdt import TestPDT  # noqa: F401\nfrom jit.test_tensor_creation_ops import TestTensorCreationOps  # noqa: F401\nfrom jit.test_module_apis import TestModuleAPIs  # noqa: F401\nfrom jit.test_script_profile import TestScriptProfile  # noqa: F401\nfrom jit.test_convert_activation import TestFunctionalToInplaceActivation, TestInplaceToFunctionalActivation  # noqa: F401\nfrom jit.test_parametrization import TestParametrization  # noqa: F401\nfrom jit.test_attr import TestGetDefaultAttr  # noqa: F401\nfrom jit.test_aten_pow import TestAtenPow  # noqa: F401\nfrom jit.test_optimize_for_mobile_preserve_debug_info import TestOptimizeForMobilePreserveDebugInfo  # noqa: F401\nfrom jit.test_union import TestUnion  # noqa: F401\nfrom jit.test_batch_mm import TestBatchMM  # noqa: F401\nfrom jit.test_dtype_analysis import TestDtypeAnalysis, TestDtypeCustomRulesCPU  # noqa: F401\nfrom jit.test_device_analysis import TestDeviceAnalysis  # noqa: F401\nfrom jit.test_dce import TestDCE  # noqa: F401\nfrom jit.test_sparse import TestSparse  # noqa: F401\nfrom jit.test_tensor_methods import TestTensorMethods  # noqa: F401\nfrom jit.test_dataclasses import TestDataclasses  # noqa: F401\n\n# Torch\nfrom torch import Tensor\nfrom torch._C import TensorType, BoolType, parse_ir, _propagate_shapes\nfrom torch.autograd import Variable\nfrom torch.jit.annotations import BroadcastingList2, BroadcastingList3, Any  # noqa: F401\nfrom torch.nn.utils.rnn import PackedSequence\nfrom torch.testing import FileCheck, make_tensor\nimport torch.autograd.profiler\nimport torch.cuda\nimport torch.jit\nimport torch.jit._logging\nimport torch.jit.frontend\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# Testing utils\nfrom torch.testing._internal import jit_utils\nfrom torch.testing._internal.common_jit import check_against_reference\nfrom torch.testing._internal.common_utils import run_tests, IS_WINDOWS, TEST_WITH_UBSAN, \\\n    suppress_warnings, BUILD_WITH_CAFFE2, IS_SANDCASTLE, GRAPH_EXECUTOR, ProfilingMode, TestCase, \\\n    freeze_rng_state, slowTest, TemporaryFileName, \\\n    enable_profiling_mode_for_profiling_tests, TEST_MKL, set_default_dtype, num_profiled_runs, \\\n    skipIfCrossRef, IS_MACOS, skipIfTorchDynamo\nfrom torch.testing._internal.jit_utils import JitTestCase, enable_cpu_fuser, disable_autodiff_subgraph_inlining, \\\n    _trace, do_input_map, get_execution_plan, make_global, \\\n    execWrapper, _inline_everything, _tmp_donotuse_dont_inline_everything, \\\n    RUN_CUDA\nfrom torch.testing._internal.jit_metaprogramming_utils import (\n    get_script_args,\n    create_input, unpack_variables,\n    additional_module_tests, EXCLUDE_SCRIPT_MODULES,\n    get_nn_module_name_from_kwargs, get_nn_mod_test_name, script_method_template)\n\nfrom torch.testing._internal.common_nn import module_tests, new_module_tests, criterion_tests\n\n# For testing truediv in python 2\nfrom torch.testing._internal.test_module.future_div import div_int_future, div_float_future\nfrom torch.testing._internal.test_module.no_future_div import div_int_nofuture, div_float_nofuture\n\n# Standard library\nfrom collections import defaultdict, namedtuple, OrderedDict\nfrom copy import deepcopy\nfrom itertools import product\nfrom textwrap import dedent\nfrom typing import List, Dict, NamedTuple, Optional, Tuple, Union\nimport copy\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport numpy as np\nimport os\nimport pickle\nimport pickletools\nimport random\nimport re\nimport shutil\nimport string\nimport sys\nimport tempfile\nimport types\nimport typing\nimport unittest\nimport warnings\nimport zipfile\n\n\ndef canonical(graph):\n    return torch._C._jit_pass_canonicalize(graph).str(False)\n\ndef LSTMCellF(input, hx, cx, *params):\n    return LSTMCell(input, (hx, cx), *params)\n\ndef doAutodiffCheck(testname):\n    # TODO: setting false on test itself is not working\n    if \"test_t_\" in testname or testname == \"test_t\":\n        return False\n\n    if GRAPH_EXECUTOR == ProfilingMode.SIMPLE:\n        return False\n\n    if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n        return True\n\n\n    # these tests are disabled because BailOut nodes\n    # inserted by ProfilingExecutor interfere with\n    # subgraph slicing of Differentiable Graphs\n    test_exceptions = [\n        # functional\n        'test_nn_dropout',\n        'test_nn_log_softmax',\n        'test_nn_relu',\n        'test_nn_softmax',\n        'test_nn_threshold',\n        'test_nn_lp_pool2d',\n        'test_nn_lp_pool1d',\n        'test_nn_gumbel_softmax_hard',\n        'test_nn_gumbel_softmax',\n        'test_nn_multilabel_soft_margin_loss',\n        'test_nn_batch_norm',\n        'test_nn_max_pool2d_with_indices',\n        # AutogradJitGenerated\n        'test___rdiv___constant',\n        'test___rdiv___scalar_constant',\n        'test_split',\n        'test_split_dim',\n        'test_split_dim_neg0',\n        'test_split_size_list',\n        'test_split_size_list_dim',\n        'test_split_size_list_dim_neg0',\n        'test_split_with_sizes',\n        'test_split_with_sizes_dim',\n        'test_split_with_sizes_dim_neg0',\n        'test_split_with_sizes_size_0',\n        'test_nn_max_pool2d_with_indices',\n    ]\n\n    if testname in test_exceptions:\n        return False\n    return True\n\n\n# TODO: enable TE in PE when all tests are fixed\ntorch._C._jit_set_texpr_fuser_enabled(GRAPH_EXECUTOR == ProfilingMode.PROFILING)\ntorch._C._jit_set_profiling_executor(GRAPH_EXECUTOR != ProfilingMode.LEGACY)\n\ndef LSTMCell(input, hidden, w_ih, w_hh, b_ih=None, b_hh=None):\n    hx, cx = hidden\n    gates = F.linear(input, w_ih, b_ih) + F.linear(hx, w_hh, b_hh)\n\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = torch.sigmoid(ingate)\n    forgetgate = torch.sigmoid(forgetgate)\n    cellgate = torch.tanh(cellgate)\n    outgate = torch.sigmoid(outgate)\n\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * torch.tanh(cy)\n    return hy, cy\n\n\ndef LSTMCellC(*args, **kwargs):\n    hy, cy = LSTMCellF(*args, **kwargs)\n    return torch.cat((hy, cy))\n\n\ndef LSTMCellS(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n    gates = x.mm(w_ih.t()) + hx.mm(w_hh.t()) + b_ih + b_hh\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = torch.sigmoid(ingate)\n    forgetgate = torch.sigmoid(forgetgate)\n    cellgate = torch.tanh(cellgate)\n    outgate = torch.sigmoid(outgate)\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * torch.tanh(cy)\n    return hy, cy\n\n\n# Code reference: https://github.com/pytorch/translate/blob/master/pytorch_translate/rnn_cell.py#L27:44\ndef MiLSTMCell(x, hx, cx, w_ih, w_hh, alpha, beta_i, beta_h, bias):\n    Wx = x.mm(w_ih.t())\n    Uz = hx.mm(w_hh.t())\n    # Section 2.1 in https://arxiv.org/pdf/1606.06630.pdf\n    gates = alpha * Wx * Uz + beta_i * Wx + beta_h * Uz + bias\n    # Same as LSTMCell after this point\n    ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)\n    ingate = ingate.sigmoid()\n    forgetgate = forgetgate.sigmoid()\n    cellgate = cellgate.tanh()\n    outgate = outgate.sigmoid()\n    cy = (forgetgate * cx) + (ingate * cellgate)\n    hy = outgate * cy.tanh()\n    return hy, cy\n\n\n\ndef get_lstm_inputs(device, training=False, seq_length=None):\n    input_shape = (3, 10) if seq_length is None else (seq_length, 3, 10)\n    input = torch.randn(*input_shape, dtype=torch.float, device=device, requires_grad=training)\n    hx = torch.randn(3, 20, dtype=torch.float, device=device, requires_grad=training)\n    cx = torch.randn(3, 20, dtype=torch.float, device=device, requires_grad=training)\n    module = nn.LSTMCell(10, 20).to(device, torch.float)  # Just to allocate weights with correct sizes\n    if training:\n        params = tuple(module.parameters())\n    else:\n        params = tuple(p.requires_grad_(False) for p in module.parameters())\n    return (input, hx, cx) + params\n\n\ndef get_milstm_inputs(device, training=False):\n    minibatch = 3\n    input_size = 10\n    hidden_size = 20\n    x = torch.randn(minibatch, input_size, device=device, dtype=torch.float)\n    hx = torch.randn(minibatch, hidden_size, device=device, dtype=torch.float)\n    cx = torch.randn(minibatch, hidden_size, device=device, dtype=torch.float)\n\n    ih = torch.randn(4 * hidden_size, input_size, device=device, dtype=torch.float, requires_grad=training)\n    hh = torch.randn(4 * hidden_size, hidden_size, device=device, dtype=torch.float, requires_grad=training)\n    alpha = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    ibeta = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    hbeta = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    bias = torch.randn(4 * hidden_size, dtype=torch.float, device=device, requires_grad=training)\n    return x, hx, cx, ih, hh, alpha, ibeta, hbeta, bias\n\n\ndef get_fn(file_name, script_path):\n    import importlib.util\n    spec = importlib.util.spec_from_file_location(file_name, script_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    fn = module.fn\n    return fn\n\ndef get_grad_executor(plan_state, diff_graph_idx=None, skip_check=False):\n    if diff_graph_idx is None:\n        nodes = list(plan_state.graph.nodes())\n\n        if not skip_check:\n            nodes = list(filter(lambda n : n.kind() != \"prim::BailOut\" and n.kind() != \"prim::BailoutTemplate\", nodes))\n            if len(nodes) == 1 or (len(nodes) == 2 and nodes[1].kind() == \"prim::TupleConstruct\"):\n                pass\n            elif len(nodes) == 2 and nodes[0].kind() == \"prim::RequiresGradCheck\" and nodes[1].kind() == \"prim::If\":\n                pass\n            else:\n                raise RuntimeError(\"Can't get a grad_executor for a non-differentiable graph\")\n    grad_executors = list(plan_state.code.grad_executor_states())\n    return grad_executors[diff_graph_idx or 0]\n\n\ndef all_backward_graphs(script_module, diff_graph_idx=None):\n    # Note: for Python 2 the order seems to be unstable\n    ge_state = script_module.get_debug_state()\n    fwd_plan = get_execution_plan(ge_state)\n    grad_executor_state = get_grad_executor(fwd_plan, diff_graph_idx=diff_graph_idx)\n    bwd_plans = list(grad_executor_state.execution_plans.values())\n    return [p.graph.copy() for p in bwd_plans]\n\n\ndef backward_graph(script_module, diff_graph_idx=None, skip_check=False):\n    ge_state = script_module.get_debug_state()\n    fwd_plan = get_execution_plan(ge_state)\n    grad_executor_state = get_grad_executor(fwd_plan, diff_graph_idx=diff_graph_idx, skip_check=skip_check)\n    bwd_plan = get_execution_plan(grad_executor_state)\n    # Running JIT passes requires that we own the graph (with a shared_ptr).\n    # The debug state struct does not own its graph so we make a copy of it.\n    return bwd_plan.graph.copy()\n\n\n# helper function to get sum of List[Tensor]\ndef _sum_of_list(tensorlist):\n    s = 0\n    for t in tensorlist:\n        s += t.sum()\n    return s\n\n\n# has to be at top level or Pickle complains\nclass FooToPickle(torch.nn.Module):\n    def __init__(self):\n        super(FooToPickle, self).__init__()\n        self.bar = torch.jit.ScriptModule()\n\nclass TestJit(JitTestCase):\n    @unittest.skip(\"Requires a lot of RAM\")\n    def test_big(self):\n        m = torch.jit.ScriptModule()\n        gig = int(1024 * 1024 * 1024 / 4)\n        # a small tensor in the first 4GB\n        m.v0 = nn.Parameter(torch.full((2,), 1, dtype=torch.float))\n        # a large tensor in the first 4GB that ends outside of it\n        m.v1 = nn.Parameter(torch.full((5, gig), 2, dtype=torch.float))\n        # a small tensor in >4GB space\n        m.v2 = nn.Parameter(torch.full((2,), 3, dtype=torch.float))\n        # s large tensor in the > 4GB space\n        m.v3 = nn.Parameter(torch.full((5, gig), 4, dtype=torch.float))\n\n        m2 = self.getExportImportCopy(m)\n\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n\n    def test_inferred_as_tensor(self):\n        with self.assertRaisesRegex(RuntimeError, \"Inferred the value for argument 'dim' to be of type 'Tensor' \"\n                                                  \"because it was not annotated with an explicit type\"):\n            @torch.jit.script\n            def dot(points, query, dim):\n                return (points * query).sum(dim)\n\n    def test_constants_pkl(self):\n        # This test asserts that the serialization archive includes a `constants.pkl`\n        # file. This file is used by `torch.load` to determine whether a zip file\n        # is a normal eager-mode serialization zip or a jit serialization zip. If\n        # you are deleting `constants.pkl`, make sure to update `torch.serialization.load`\n        # so it is still able to figure out which is which.\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        buf = io.BytesIO()\n        torch.jit.save(fn, buf)\n        buf.seek(0)\n\n        files = zipfile.ZipFile(buf).filelist\n        self.assertTrue(any(['archive/constants.pkl' == f.filename for f in files]))\n\n    def test_script_fn_pkl(self):\n        with self.assertRaisesRegex(pickle.PickleError, \"ScriptFunction cannot be pickled\"):\n\n            @torch.jit.script\n            def fn(x: torch.Tensor) -> torch.Tensor:\n                return x\n\n            pkl_fn = pickle.dumps(fn, protocol=0)\n\n    def test_restore_device(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, cpu_device_str):\n                super(M, self).__init__()\n                self.p0 = nn.Parameter(torch.tensor([0.3], dtype=torch.float,\n                                                    device=cpu_device_str))\n                self.b0 = torch.tensor([0.9], dtype=torch.float,\n                                       device=cpu_device_str)\n\n        # main purpose is checking map_location works\n        m = M(\"cpu\")\n        m2 = self.getExportImportCopy(m)\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertFalse(m2.p0.is_cuda)\n        self.assertFalse(m2.b0.is_cuda)\n\n    @unittest.skipIf(not RUN_CUDA, \"restore device requires CUDA\")\n    def test_restore_device_cuda(self):\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.register_buffer('b0', torch.randn(1, 3))\n                self.p0 = nn.Parameter(torch.randn(2, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.b0 + self.p0\n\n        m = MyModule()\n        m.cuda(torch.cuda.device_count() - 1)\n        cuda_device_str = 'cuda:' + str(torch.cuda.device_count() - 1)\n\n        self.assertTrue(m.p0.is_cuda)\n        self.assertTrue(m.b0.is_cuda)\n\n        # restore to the saved devices\n        m2 = self.getExportImportCopy(m)\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertEqual(str(m2.p0.device), cuda_device_str)\n        self.assertEqual(str(m2.b0.device), cuda_device_str)\n\n        # restore all to cpu using string\n        cpu_device_str = 'cpu'\n        m3 = self.getExportImportCopy(m, map_location=cpu_device_str)\n        self.assertEqual(str(m3.p0.device), cpu_device_str)\n        self.assertEqual(str(m3.b0.device), cpu_device_str)\n\n        # restore all to first gpu using device\n        m4 = self.getExportImportCopy(\n            m3, map_location=torch.device('cuda:0'))\n        self.assertEqual(str(m4.p0.device), 'cuda:0')\n        self.assertEqual(str(m4.b0.device), 'cuda:0')\n\n        # compute and compare the results\n        input = torch.rand(2, 3).cuda(torch.cuda.device_count() - 1)\n        origin_result = m(input)\n        self.assertEqual(origin_result, m2(input))\n        self.assertEqual(origin_result, m3(input.cpu()))\n        self.assertEqual(origin_result, m4(input.cuda(0)))\n\n    def test_trace_retains_train(self):\n        class M(torch.nn.Module):\n            def forward(self, x):\n                return x\n        m = M()\n        m.eval()\n        tm = torch.jit.trace(m, (torch.rand(3)))\n        self.assertEqual(tm.training, m.training)\n\n    @unittest.skipIf(not RUN_CUDA, \"restore device requires CUDA\")\n    def test_restore_shared_storage_on_cuda(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                whole_tensor = torch.randn(4, 5, dtype=torch.float, device='cpu')\n                self.p0 = nn.Parameter(whole_tensor.narrow(0, 0, 1))\n                self.register_buffer('b0', whole_tensor.narrow(0, 3, 1))\n\n        m = Foo()\n        m2 = self.getExportImportCopy(m, map_location=torch.device('cuda:0'))\n        self.assertEqual(tuple(m.parameters()), tuple(m2.parameters()))\n        self.assertEqual(tuple(m.buffers()), tuple(m2.buffers()))\n        self.assertTrue(m2.p0.is_cuda)\n        self.assertTrue(m2.b0.is_cuda)\n        self.assertTrue(m2.p0.is_shared())\n        self.assertTrue(m2.b0.is_shared())\n        self.assertEqual(m2.b0.storage().data_ptr(), m2.p0.storage().data_ptr())\n\n    def test_add_relu_fusion(self):\n        class M(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(M, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b, c):\n                tmp = torch.add(a, b)\n                x = self.relu_op(tmp)\n                d = torch.add(a, c)\n                return x + d\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        c = torch.rand((7, 11))\n        m = torch.jit.script(M(torch.relu))\n        orig_res = m(a, b, c)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a, b, c)\n        FileCheck().check_not(\"aten::relu(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n\n        # add, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        c = torch.rand((7, 11))\n        m = torch.jit.script(M(torch.relu_))\n        orig_res = m(a, b, c)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a, b, c)\n        FileCheck().check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n\n        class Madd_(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(Madd_, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b):\n                x = a.add_(b)\n                x = self.relu_op(x)\n                return x\n\n        # add_, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        # Because in place add_ will overwrite a\n        a_copy = a.clone()\n        m = torch.jit.script(Madd_(torch.relu_))\n        orig_res = m(a, b)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a_copy, b)\n        FileCheck().check_not(\"aten::add_(\") \\\n            .check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu_(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n        # Since _add_relu_ does inplace mutation ensure\n        # a_copy is modified\n        torch.testing.assert_close(orig_res, a_copy)\n\n        class Madd_out(torch.nn.Module):\n            def __init__(self, relu_op):\n                super(Madd_out, self).__init__()\n                self.relu_op = relu_op\n\n            def forward(self, a, b):\n                x = torch.add(a, b, out=a)\n                x = self.relu_op(x)\n                return x\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n\n        # add_out, relu_\n        a = torch.rand((7, 11))\n        a = a * -10\n        a = a + 5\n        b = torch.rand((7, 11))\n        # Because in place add_ will overwrite a\n        a_copy = a.clone()\n        m = torch.jit.script(Madd_out(torch.relu_))\n        orig_res = m(a, b)\n        torch._C._jit_pass_fuse_add_relu(m.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(m, buffer)\n        buffer.seek(0)\n        m = torch.jit.load(buffer)\n        new_res = m(a_copy, b)\n        FileCheck().check_not(\"aten::add(\") \\\n            .check_not(\"aten::relu_(\") \\\n            .check(\"aten::_add_relu(\") \\\n            .run(m.graph)\n        torch.testing.assert_close(orig_res, new_res)\n        # Since _add_relu_ with out=a does inplace mutation ensure\n        # a_copy is modified\n        torch.testing.assert_close(orig_res, a_copy)\n\n    def test_repeat_interleave_script(self):\n        def fn(input: torch.Tensor, repeats: torch.Tensor) -> torch.Tensor:\n            output = input.repeat_interleave(repeats)\n            return output\n        fn_scripted = torch.jit.script(fn)\n\n        input = torch.tensor([5, 7], dtype=torch.int64)\n        repeats = torch.tensor([3, 6], dtype=torch.int64)\n\n        output = fn(input, repeats)\n        output_scripted = fn_scripted(input, repeats)\n        self.assertEqual(output_scripted, output)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"Simple executor doesn't have shape information\")\n    def test_peephole_optimize_shape_ops(self):\n        def test_input(func, input, result):\n            # if result == 2 we will trigger a bailout and\n            # the unprofiled graph should return the correct result\n            self.assertEqual(func(input, profile_and_replay=True), result)\n            gre = func.graph_for(input)\n            FileCheck().check_not(\"prim::If\").run(gre)\n\n        def test_dim():\n            @torch.jit.script\n            def func(x):\n                if x.dim() == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor([0.5]), 1)\n            test_input(func, torch.tensor([[0.5]]), 2)\n        test_dim()\n\n        def test_size_index():\n            @torch.jit.script\n            def func(x):\n                if x.size(0) == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.rand([1, 2]), 1)\n            test_input(func, torch.rand([1, 3]), 1)\n\n            @torch.jit.script\n            def neg_index(x):\n                if x.size(-2) == 1:\n                    return 1\n                else:\n                    return 2\n\n            test_input(neg_index, torch.rand([1, 2]), 1)\n            test_input(neg_index, torch.rand([1, 3]), 1)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            test_size_index()\n\n        def test_dtype():\n            @torch.jit.script\n            def func(x):\n                if x.dtype == torch.float32:\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor(0.5, dtype=torch.float32), 1)\n            test_input(func, torch.tensor(0.5, dtype=torch.int64), 2)\n        test_dtype()\n\n        def test_is_floating_poiint():\n            @torch.jit.script\n            def func(x):\n                if x.is_floating_point():\n                    return 1\n                else:\n                    return 2\n\n            test_input(func, torch.tensor(0.5, dtype=torch.float32), 1)\n            test_input(func, torch.tensor(0.5, dtype=torch.int64), 2)\n        test_is_floating_poiint()\n\n        def test_device():\n            @torch.jit.script\n            def func_1(x):\n                if x.device == torch.device('cuda:0'):\n                    a = 0\n                else:\n                    a = 1\n                return a\n\n            @torch.jit.script\n            def func_2(x):\n                if x.is_cuda:\n                    a = 0\n                else:\n                    a = 1\n                return a\n\n            test_input(func_1, torch.tensor(0.5), 1)\n            test_input(func_2, torch.tensor(0.5), 1)\n\n            if RUN_CUDA:\n                test_input(func_1, torch.tensor(0.5, device=\"cuda:0\"), 0)\n                test_input(func_2, torch.tensor(0.5, device=\"cuda:0\"), 0)\n\n        test_device()\n\n    def test_attrs(self):\n        def foo(x):\n            return (\n                # x.dtype, TODO: dtype long -> instance conversion\n                x.device,\n                x.shape,\n                x.is_cuda,\n                x.is_mkldnn,\n                x.is_quantized,\n                x.requires_grad,\n                x.T,\n                x.mT,\n                x.H,\n                x.mH\n                # x.layout TODO: layout long -> instance conversion\n            )\n\n        scripted = torch.jit.script(foo)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted(x), foo(x))\n\n    def test_layout(self):\n        @torch.jit.script\n        def check(x, y):\n            return x.layout == y.layout\n\n        x = torch.rand(3, 4)\n        y = torch.rand(3, 4)\n\n        self.assertTrue(check(x, y))\n\n    def test_matrix_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.mT, x.transpose(-2, -1))\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n    def test_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.T, x.t())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n    def test_matrix_conj_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.mH, x.transpose(-2, -1).conj())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n        x = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n        self.assertTrue(check(x))\n\n    def test_conj_transpose(self):\n        @torch.jit.script\n        def check(x):\n            return torch.equal(x.H, x.t().conj())\n\n        x = torch.rand(3, 4)\n        self.assertTrue(check(x))\n\n        x = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n        self.assertTrue(check(x))\n\n    def test_T_mT_H_mH(self):\n        def T(x):\n            return x.mT\n\n        def mT(x):\n            return x.mT\n\n        def H(x):\n            return x.H\n\n        def mH(x):\n            return x.mH\n\n        x = torch.rand(3, 4)\n        y = make_tensor((3, 4), device=\"cpu\", dtype=torch.complex64)\n\n        self.checkScript(T, (x, ))\n        self.checkScript(mT, (x, ))\n        self.checkScript(H, (x, ))\n        self.checkScript(mH, (x, ))\n        self.checkScript(T, (y, ))\n        self.checkScript(mT, (y, ))\n        self.checkScript(H, (y, ))\n        self.checkScript(mH, (y, ))\n\n    def test_nn_conv(self):\n        class Mod(nn.Module):\n            def __init__(self, conv):\n                super().__init__()\n                self.conv = conv\n\n            def forward(self, input):\n                return self.conv(input)\n\n        inputs = [\n            # Conv\n            (Mod(nn.Conv1d(16, 33, 3, stride=2)), torch.randn(20, 16, 5)),\n            (Mod(nn.Conv2d(16, 33, 3, stride=2)), torch.randn(20, 16, 5, 10)),\n            (Mod(nn.Conv3d(16, 33, 3, stride=2)), torch.randn(20, 16, 3, 5, 4)),\n            # ConvTransposed\n            (Mod(nn.ConvTranspose1d(16, 33, 3, stride=2)), torch.randn(20, 16, 5)),\n            (Mod(nn.ConvTranspose2d(16, 33, 3, stride=2)), torch.randn(20, 16, 5, 10)),\n            (Mod(nn.ConvTranspose3d(16, 33, 3, stride=2)), torch.randn(20, 16, 3, 5, 4)),\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, 'Not implemented for Simple or Legacy')\n    def test_debug_flush_compilation_cache(self):\n        def foo(x):\n            return x + 2\n\n        class Mod(nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n\n            def forward(self, t):\n                return t + 2\n\n        m = torch.jit.script(Mod())\n        x = torch.rand(1, 10)\n\n        with enable_profiling_mode_for_profiling_tests():\n            jitted = self.checkScript(foo, (x,))\n            # shouldn't throw\n            states = jitted.get_debug_state()\n\n            # after flushing there shouldn't be\n            # no opt plan\n            jitted._debug_flush_compilation_cache()\n            with self.assertRaisesRegex(RuntimeError, \"INTERNAL ASSERT FAILED\"):\n                states = jitted.get_debug_state()\n\n            NUM_RUNS = 1\n            with num_profiled_runs(NUM_RUNS):\n                m(x)\n                m(x)\n                fwd = m._c._get_method(\"forward\")\n                states = m.get_debug_state()\n\n                # after flushing there shouldn't be\n                # no opt plan\n                fwd._debug_flush_compilation_cache()\n                with self.assertRaisesRegex(RuntimeError, \"INTERNAL ASSERT FAILED\"):\n                    states = m.get_debug_state()\n\n    def test_numel(self):\n        @torch.jit.script\n        def get_numel_script(x):\n            return x.numel()\n\n        x = torch.rand(3, 4)\n        numel = get_numel_script(x)\n        self.assertEqual(numel, x.numel())\n\n    def test_element_size(self):\n        @torch.jit.script\n        def get_element_size_script(x):\n            return x.element_size()\n\n        x = torch.rand(3, 4)\n        element_size = get_element_size_script(x)\n        self.assertEqual(element_size, x.element_size())\n\n    def test_Sequential(self):\n        class Seq(nn.Module):\n            def __init__(self):\n                super(Seq, self).__init__()\n                self.seq = nn.Sequential(nn.Linear(10, 20), nn.Linear(20, 30))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for l in self.seq:\n                    x = l(x)\n                return x\n\n        m = torch.jit.script(Seq())\n        assert m.graph  # ensure jit was able to compile\n\n    def test_ModuleList(self):\n        class Mod(nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.model = nn.ModuleList([nn.Linear(10, 10) for _ in range(10)])\n                self.model += (nn.Linear(10, 20),)\n                self.model.append(nn.Linear(20, 30))\n                self.model.extend([nn.Linear(30, 40), nn.Linear(40, 50)])\n\n            def forward(self, v):\n                for m in self.model:\n                    v = m(v)\n                return v\n\n        m = torch.jit.script(Mod())\n        assert m.graph  # ensure jit was able to compile\n\n    def test_disabled(self):\n        torch.jit._state.disable()\n        try:\n            def f(x, y):\n                return x + y\n\n            self.assertIs(torch.jit.trace(f, (torch.randn(2, 2), torch.randn(2, 2))), f)\n            self.assertIs(torch.jit.script(f), f)\n\n            class MyModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def method(self, x):\n                    return x\n\n            # XXX: Unfortunately ScriptModule won't simply become Module now,\n            # because that requires disabling the JIT at startup time, which\n            # we can't do in here.\n            # We need to or those two conditions to make it work with all versions of Python\n            self.assertTrue(inspect.ismethod(MyModule.method) or inspect.isfunction(MyModule.method))\n        finally:\n            torch.jit._state.enable()\n\n    def test_train_eval(self):\n        class Sub(nn.Module):\n            def forward(self, input):\n                if self.training:\n                    return input\n                else:\n                    return -input\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, module):\n                super(MyModule, self).__init__()\n                self.module = module\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.module(input) + 1\n\n        m = MyModule(Sub())\n        input = torch.rand(3, 4)\n        self.assertEqual(input + 1, m(input))\n        m.eval()\n        self.assertEqual(-input + 1, m(input))\n\n        # test batchnorm and dropout train/eval\n        input = torch.randn(6, 10)\n        batchnorm = nn.BatchNorm1d(10)\n        dropout = nn.Dropout(p=0.2)\n\n        m_batchnorm = MyModule(batchnorm)\n        self.assertEqual(batchnorm(input) + 1, m_batchnorm(input))\n        batchnorm.eval()\n        m_batchnorm.eval()\n        self.assertEqual(batchnorm(input) + 1, m_batchnorm(input))\n\n        m_dropout = MyModule(dropout)\n        dropout.eval()\n        m_dropout.eval()\n        self.assertEqual(dropout(input) + 1, m_dropout(input))\n\n    def test_nn_lp_pool2d(self):\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.l = torch.nn.LPPool2d(2, 3)\n                self.n = torch.nn.LPPool2d(2, (7, 1))\n\n            def forward(self, x):\n                return (self.l(x),\n                        self.n(x),\n                        torch.nn.functional.lp_pool2d(x, float(2), 3),\n                        torch.nn.functional.lp_pool2d(x, 2, 3),\n                        torch.nn.functional.lp_pool2d(x, float(2), (7, 1)))\n\n        self.checkModule(Mod(), (torch.rand(1, 3, 7, 7),))\n\n    def test_nn_lp_pool1d(self):\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.l = torch.nn.LPPool1d(2, 3)\n                self.n = torch.nn.LPPool1d(2, 7)\n\n            def forward(self, x):\n                return (self.l(x),\n                        self.n(x),\n                        torch.nn.functional.lp_pool1d(x, float(2), 3),\n                        torch.nn.functional.lp_pool1d(x, 2, 3),\n                        torch.nn.functional.lp_pool1d(x, float(2), 7))\n\n        self.checkModule(Mod(), (torch.rand(1, 3, 7),))\n\n    def test_nn_padding_functional(self):\n        class Mod(nn.Module):\n            def __init__(self, *pad):\n                super().__init__()\n                self.pad = pad\n\n            def forward(self, x):\n                return F.pad(x, self.pad, mode='constant', value=3.5)\n\n        inputs = [\n            (Mod(1, 2), torch.randn(1, 3, 4)),  # 1D\n            (Mod(1, 2, 3, 4), torch.randn(1, 3, 4)),  # 2D\n            (Mod(1, 2, 3, 4, 5, 6), torch.randn(1, 3, 4)),  # 3D\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    def test_nn_padding(self):\n        class Mod(nn.Module):\n            def __init__(self, padding):\n                super().__init__()\n                self.padding = padding\n\n            def forward(self, input):\n                return self.padding(input)\n\n        inputs = [\n            (Mod(nn.ConstantPad1d(2, 3.5)), torch.randn(1, 2, 4)),\n            (Mod(nn.ConstantPad2d(2, 3.5)), torch.randn(1, 2, 2)),\n            (Mod(nn.ConstantPad3d(3, 3.5)), torch.randn(16, 3, 10, 20, 30)),\n            (Mod(nn.ReflectionPad1d(2)), torch.arange(8, dtype=torch.float).reshape(1, 2, 4)),\n            (Mod(nn.ReflectionPad2d(2)), torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)),\n            (Mod(nn.ReflectionPad3d(3)), torch.randn(16, 3, 8, 32, 48)),\n            (Mod(nn.ReplicationPad1d(2)), torch.arange(8, dtype=torch.float).reshape(1, 2, 4)),\n            (Mod(nn.ReplicationPad2d(2)), torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)),\n            (Mod(nn.ReplicationPad3d(3)), torch.randn(16, 3, 8, 32, 48)),\n            (Mod(nn.ZeroPad2d(2)), torch.randn(1, 1, 3, 3))\n        ]\n\n        for m, inp in inputs:\n            self.checkModule(m, (inp,))\n\n    def test_script_autograd_grad(self):\n        def test_simple_grad(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = x + 2 * y + x * y\n            return torch.autograd.grad((z.sum(), ), (x, y))\n\n        def test_simple_grad_with_grad_outputs(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = x + 2 * y + x * y\n            grad_outputs = torch.jit.annotate(List[Optional[torch.Tensor]], [torch.ones((2, 2)), ])\n            return torch.autograd.grad((z, ), (x, y), grad_outputs)\n\n        def test_one_output_not_requires_grad(x, y):\n            # type: (Tensor, Tensor) -> List[Optional[Tensor]]\n            z = 2 * y + y\n            return torch.autograd.grad((z.sum(),), (x, y), allow_unused=True)\n\n        def test_retain_graph(x, y):\n            # type: (Tensor, Tensor) -> None\n            z = x + 2 * y + x * y\n            torch.autograd.grad((z.sum(), ), (x, y), retain_graph=True)\n            torch.autograd.grad((z.sum(), ), (x, y))\n\n        x = torch.randn(2, 2, requires_grad=True)\n        y = torch.randn(2, 2, requires_grad=True)\n        self.checkScript(test_simple_grad, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_simple_grad_with_grad_outputs, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_one_output_not_requires_grad, (x, y), inputs_requires_grad=True)\n        self.checkScript(test_retain_graph, (x, y), inputs_requires_grad=True)\n\n    def test_script_backward(self):\n        def checkBackwardScript(fn, inputs):\n            scripted_fn = torch.jit.script(fn)\n            FileCheck().check(\"torch.autograd.backward\").run(scripted_fn.code)\n            recording_inputs = do_input_map(lambda t: t.detach().requires_grad_(), inputs)\n\n            fn(*inputs)\n            scripted_fn(*recording_inputs)\n\n            for inp1, inp2 in zip(inputs, recording_inputs):\n                self.assertEqual(inp1.grad, inp2.grad)\n\n        def test_tensor_backward(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            sum_out = output.sum()\n            sum_out.backward()\n\n        def test_torch_autograd_backward(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            torch.autograd.backward(output.sum())\n\n        def test_torch_autograd_backward_with_grad_tensors(input):\n            # type: (Tensor) -> None\n            output = torch.relu(input)\n            output = output.softmax(0)\n            grad_outputs = torch.jit.annotate(List[Optional[torch.Tensor]], [torch.ones((2, 2)), ])\n            torch.autograd.backward((output,), grad_outputs)\n\n        inp = torch.randn(2, 2, requires_grad=True)\n        checkBackwardScript(test_tensor_backward, (inp,))\n        checkBackwardScript(test_torch_autograd_backward, (inp,))\n        checkBackwardScript(test_torch_autograd_backward_with_grad_tensors, (inp,))\n\n    def test_script_backward_twice(self):\n        def checkBackwardTwiceScript(fn, inputs, retain_graph_=False):\n            torch._C._jit_set_profiling_executor(False)\n\n            with torch.jit.optimized_execution(True):\n                scripted_fn = torch.jit.script(fn, inputs)\n                FileCheck().check(\"prim::DifferentiableGraph\").run(scripted_fn.graph_for(*inputs))\n\n                result = scripted_fn(*inputs)\n                result.sum().backward(retain_graph=retain_graph_)\n                if not retain_graph_:\n                    self.assertRaisesRegex(RuntimeError, 'Specify retain_graph=True',\n                                           lambda: result.sum().backward())\n                else:\n                    result.sum().backward()\n\n        def test_script_backward_twice_with_saved_values(input1, input2):\n            # type: (Tensor, Tensor) -> Tensor\n            tmp1 = torch.mul(input1, input2)\n            tmp2 = torch.abs(tmp1)\n            if torch.equal(input1, input2):\n                tmp2 = torch.acos(tmp2)\n            else:\n                tmp2 = torch.atan(tmp2)\n            result = torch.add(tmp2, input2)\n            return result\n\n        inp1 = torch.randn(2, 2, requires_grad=True)\n        inp2 = torch.randn(2, 2, requires_grad=True)\n        checkBackwardTwiceScript(test_script_backward_twice_with_saved_values, (inp1, inp2), False)\n        checkBackwardTwiceScript(test_script_backward_twice_with_saved_values, (inp1, inp2), True)\n\n    def test_diff_subgraph_clones_constants(self):\n        @torch.jit.script\n        def f(x, y):\n            return x + x + y + x + y + x + y + x + y + x\n\n        def count_constants(graph):\n            return sum(node.kind() == 'prim::Constant' for node in graph.nodes())\n\n        graph = f.graph.copy()\n        self.run_pass('cse', graph)\n        self.run_pass('create_autodiff_subgraphs', graph)\n        nodes = list(graph.nodes())\n        self.assertEqual(count_constants(graph), 1)\n        self.assertEqual(count_constants(nodes[1].g('Subgraph')), 1)\n\n    # TODO: adapt this test to check that GraphExecutor treats them differently\n    @unittest.skip(\"Need to be adjusted to Graph Executor\")\n    def test_arg_configurations(self):\n        \"\"\"Different arg configurations should trigger different traces\"\"\"\n        x = Variable(torch.FloatTensor(4, 4).uniform_())\n        x_double = Variable(x.data.double())\n        x_grad = Variable(x.data.clone(), requires_grad=True)\n        y = Variable(torch.randn(4))\n\n        configurations = [\n            (x,),\n            (x_double,),\n            (x_grad,),\n            (y,),\n            ([x, x],),\n            ([x, y],),\n        ]\n        if torch.cuda.is_available():\n            x_cuda = Variable(x.data.cuda())\n            configurations += [\n                (x_cuda,),\n                ([x, x_cuda],),\n                ([x_cuda, x],),\n                ([[x_cuda, x]],),\n            ]\n            if torch.cuda.device_count() > 1:\n                x_cuda_1 = Variable(x.data.cuda(1))\n                configurations += [\n                    (x_cuda_1,),\n                    ([x_cuda, x_cuda_1],),\n                ]\n\n        @torch.jit.compile(nderivs=0)\n        def fn(*args):\n            in_vars, _ = torch._C._jit_flatten(args)\n            return in_vars[0] + 1\n\n        for i, config in enumerate(configurations):\n            self.assertFalse(fn.has_trace_for(*config))\n            fn(*config)\n            self.assertTrue(fn.has_trace_for(*config))\n            for unk_config in configurations[i + 1:]:\n                self.assertFalse(fn.has_trace_for(*unk_config))\n        self.assertEqual(fn.hits, 0)\n\n    def test_torch_sum(self):\n        def fn(x):\n            return torch.sum(x)\n\n        def fn1(x, dim: int):\n            return torch.sum(x, dim)\n\n        x = torch.randn(3, 4)\n        self.checkScript(fn, (x, ))\n        self.checkScript(fn1, (x, 1, ))\n        self.checkScript(fn1, (x, 0, ))\n\n    def test_cse(self):\n        x = torch.tensor([0.4, 0.3], requires_grad=True)\n        y = torch.tensor([0.7, 0.5], requires_grad=True)\n\n        def fn(x, y):\n            w = (x + y) * (x + y) * (x + y)\n            t = torch.tanh(w) + torch.tanh(w)\n            z = (x + y) * (x + y) * (x + y) + t\n            return z\n\n        g, _ = torch.jit._get_trace_graph(fn, (x, y))\n        self.run_pass('cse', g)\n        do_exactly = True\n        FileCheck().check_count(\"add\", 1).check_count(\"mul\", 2, do_exactly) \\\n            .check_count(\"tanh\", 1, do_exactly).check_count(\"add\", 2, do_exactly).check_next(\"return\")  \\\n            .run(str(g))\n\n        self.assertExportImport(g, (x, y))\n\n    def test_cse_not_introduce_aliasing(self):\n        @torch.jit.script\n        def tensor_alias_outputs(x):\n            return x + x, x + x\n\n        self.run_pass('cse', tensor_alias_outputs.graph)\n        FileCheck().check_count(\"aten::add\", 2).run(tensor_alias_outputs.graph)\n\n        @torch.jit.script\n        def ints_alias_outputs(x):\n            # type: (int) -> Tuple[int, int]\n            return x + x, x + x\n\n        # non-aliasing types can be CSEd\n        self.run_pass('cse', ints_alias_outputs.graph)\n        FileCheck().check_count(\"aten::add\", 1, exactly=True).run(ints_alias_outputs.graph)\n\n    def test_recursive_cse(self):\n        input_str = \"\"\"\ngraph(%x : Tensor,\n      %y : Tensor,\n      %20 : int):\n  %2 : int = prim::Constant[value=1]()\n  %3 : Tensor = aten::add(%x, %y, %2)\n  %4 : int = aten::add(%2, %20)\n  %5 : bool = aten::Bool(%4)\n  %z : int = prim::If(%5)\n    # CHECK: block\n    block0():\n      # CHECK-NOT: aten::add\n      %z.1 : int = aten::add(%2, %20)\n      -> (%z.1)\n    block1():\n      -> (%2)\n  return (%z)\n\"\"\"\n        graph = parse_ir(input_str)\n        self.run_pass('cse', graph)\n        FileCheck().run(input_str, graph)\n\n    def test_pattern_based_rewrite(self):\n        # mul(mul(mul(mul(x,y),z),x),y) --> mul(mul(mulmul(x,y,z), x), y) -->\n        # --> mulmul(mulmul(x,y,z), x, y)\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK: my::fused_mulmul\n    %t = aten::mul(%x, %y)\n    %p = aten::mul(%t, %z)\n    # CHECK: my::fused_mulmul\n    %u = aten::mul(%p, %x)\n    %o = aten::mul(%u, %y)\n    return (%o)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c):\n  %q = aten::mul(%a, %b)\n  %r = aten::mul(%q, %c)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c):\n  %r = my::fused_mulmul(%a, %b, %c)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check that overlapping matches are handled correctly\n        # mul(mul(mul(x,y),z),x) --> mul(mulmul(x,y,z), x)\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK: my::fused_mulmul\n    %t = aten::mul(%x, %y)\n    %p = aten::mul(%t, %z)\n    # CHECK-NEXT: aten::mul\n    %u = aten::mul(%p, %x)\n    return (%u)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c):\n  %q = aten::mul(%a, %b)\n  %r = aten::mul(%q, %c)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c):\n  %r = my::fused_mulmul(%a, %b, %c)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check add(mul(x,y),z) --> muladd(x,y,z) replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    # CHECK-NOT: aten::add\n    %c = prim::Const[value=1]()\n    %t = aten::mul(%x, %y)\n    %p = aten::add(%t, %z, %c)\n    # CHECK: my::muladd\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::mul(%a, %b)\n  %r = aten::add(%q, %c, %d)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c, %d):\n  %r = my::muladd(%a, %b, %c, %d)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check add(mul(x,y),z) --> sub(add(x,y),z) replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    # CHECK-NOT: aten::mul\n    %c = prim::Const[value=1]()\n    # CHECK: aten::add\n    %t = aten::mul(%x, %y)\n    # CHECK-NEXT: aten::sub\n    %p = aten::add(%t, %z, %c)\n    # CHECK-NOT: aten::add\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::mul(%a, %b)\n  %r = aten::add(%q, %c, %d)\n  return (%r)\"\"\", \"\"\"\ngraph(%a, %b, %c, %d):\n  %q = aten::add(%a, %b, %d)\n  %r = aten::sub(%q, %c, %d)\n  return (%r)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n        # Check mul(x,y) --> x replacement\n        input_str = \"\"\"\ngraph(%x, %y, %z):\n    %c = prim::Const[value=1]()\n    # CHECK-NOT: aten::mul\n    %t = aten::mul(%x, %y)\n    # CHECK: aten::add(%x, %z\n    %p = aten::add(%t, %z, %c)\n    # CHECK-NEXT: return\n    return (%p)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\ngraph(%Pa, %Pb):\n  %Pq = aten::mul(%Pa, %Pb)\n  return (%Pq)\"\"\", \"\"\"\ngraph(%Ra, %Rb):\n  return (%Ra)\"\"\", graph)\n        FileCheck().run(input_str, graph)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_pattern_based_module_rewrite(self):\n        # Check match::module behavior\n        class Test(torch.nn.Module):\n            def __init__(self):\n                super(Test, self).__init__()\n                self.conv = torch.nn.Conv2d(1, 20, 5, 1)\n                self.bn = torch.nn.BatchNorm2d(num_features=20)\n\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return x\n        m = torch.jit.script(Test())\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\"\"\"\n        graph(%self, %x):\n                %conv = match::module[name=\"Conv2d\"](%self)\n                %y = prim::CallMethod[name=\"forward\"](%conv, %x)\n                %bn = match::module[name=\"BatchNorm2d\"](%self)\n                %z = prim::CallMethod[name=\"forward\"](%bn, %y)\n                return (%z)\"\"\", \"\"\"\n        graph(%self, %x):\n          %z = my::matched_conv_bn(%self, %x)\n          return (%z)\"\"\", m._c._get_method(\"forward\").graph)\n\n        FileCheck().check(\"my::matched_conv_bn\").run(m._c._get_method(\"forward\").graph)\n\n    def test_pattern_based_rewrite_with_source_range_preserved(self):\n        class TestModule1(torch.nn.Module):\n            def __init__(self):\n                super(TestModule1, self).__init__()\n\n            def forward(self, x, y, z, w):\n                x = x + y\n                x = x * z\n                return w - x\n\n        input_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %t = aten::add(%x, %y, %const)\n            %o = aten::mul(%t, %z)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %o = my::add_mul(%x, %y, %z, %const)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule1())\n        graph = scripted_model.graph\n        value_mappings = [(\"o\", \"t\")]\n        for node in graph.nodes():\n            if node.kind() == \"aten::add\":\n                source_range_1 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, scripted_model.graph, value_name_pairs=value_mappings)\n        graph = scripted_model.graph\n        for node in graph.nodes():\n            if node.kind() == \"my::add_mul\":\n                source_range_2 = node.sourceRange()\n        self.assertTrue(source_range_1 == source_range_2)\n\n        class TestModule2(torch.nn.Module):\n            def __init__(self):\n                super(TestModule2, self).__init__()\n\n            def forward(self, x, y, z, w):\n                x = x + y\n                x = x + z\n                x = x * z\n                x = x * w\n                return x - 2\n\n        # Check source range preservation for two node transforms add -> my_add\n        input_pattern = \"\"\"\n        graph(%x, %y, %const):\n            %o = aten::add(%x, %y, %const)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %const):\n            %o = my::add(%x, %y, %const)\n            return (%o)\"\"\"\n        scripted_model = copy.deepcopy(torch.jit.script(TestModule2()))\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"o\", \"o\")]\n        source_range_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_add_1 is None and node.kind() == \"aten::add\":\n                source_range_add_1 = node.sourceRange()\n            if source_range_add_1 is not None and node.kind() == \"aten::add\":\n                source_range_add_2 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        source_range_my_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_my_add_1 is None and node.kind() == \"my::add\":\n                source_range_my_add_1 = node.sourceRange()\n            if source_range_my_add_1 is not None and node.kind() == \"my::add\":\n                source_range_my_add_2 = node.sourceRange()\n        self.assertTrue(source_range_add_1 == source_range_my_add_1)\n        self.assertTrue(source_range_add_2 == source_range_my_add_2)\n\n        # Check source range preservation for add-add -> double_add transform\n        # fuse nodes\n        input_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %t = aten::add(%x, %y, %const)\n            %o = aten::add(%t, %z, %const)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z, %const):\n            %o = my::double_add(%x, %y, %z, %const)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"o\", \"t\")]\n        source_range_1 = None\n        source_range_2 = None\n        for node in graph_copy.nodes():\n            if node.kind() == \"aten::add\":\n                source_range_1 = node.sourceRange()\n                break\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        for node in graph_copy.nodes():\n            if node.kind() == \"my::double_add\":\n                source_range_2 = node.sourceRange()\n        self.assertTrue(source_range_1 == source_range_2)\n\n        # Check source range preservation for mul -> add + add transform\n        # split node\n        input_pattern = \"\"\"\n        graph(%x, %y):\n            %t = aten::mul(%x, %y)\n            return (%t)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y):\n            %t = my::add(%x, %y)\n            %o = my::add(%t, %y)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        value_mappings = [(\"t\", \"t\"), (\"o\", \"t\")]\n        source_range_mul_1 = None\n        for node in graph_copy.nodes():\n            if source_range_mul_1 is None and node.kind() == \"aten::mul\":\n                source_range_mul_1 = node.sourceRange()\n            if source_range_mul_1 is not None and node.kind() == \"aten::mul\":\n                source_range_mul_2 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(\n            input_pattern, replacement_pattern, graph_copy, value_name_pairs=value_mappings)\n        source_range_add_1 = None\n        for node in graph_copy.nodes():\n            if source_range_add_1 is None and node.kind() == \"my::add\":\n                source_range_add_1 = node.sourceRange()\n            if source_range_add_1 is not None and node.kind() == \"my::add\":\n                source_range_add_2 = node.sourceRange()\n        self.assertTrue(source_range_mul_1 == source_range_add_1)\n        self.assertTrue(source_range_mul_2 == source_range_add_2)\n\n        # Check lack of source range preservation for mul-mul-> double_mul transform\n        input_pattern = \"\"\"\n        graph(%x, %y, %z):\n            %t = aten::mul(%x, %y)\n            %o = aten::mul(%t, %z)\n            return (%o)\"\"\"\n        replacement_pattern = \"\"\"\n        graph(%x, %y, %z):\n            %o = my::double_mul(%x, %y, %z)\n            return (%o)\"\"\"\n        scripted_model = torch.jit.script(TestModule2())\n        graph_copy = scripted_model.graph.copy()\n        for node in graph_copy.nodes():\n            if node.kind() == \"aten::mul\":\n                source_range_1 = node.sourceRange()\n        torch._C._jit_pass_custom_pattern_based_rewrite_graph(input_pattern, replacement_pattern, graph_copy)\n        for node in graph_copy.nodes():\n            if node.kind() == \"my::double_mul\":\n                source_range_2 = node.sourceRange()\n        self.assertFalse(source_range_1 == source_range_2)\n\n    def test_expand_quantlint(self):\n        pass\n\n    def test_expand_fold_quant_inputs(self):\n        pass\n\n    def test_shape_analysis_broadcast(self):\n        def broadcast(a, b):\n            return a + b\n\n        x = torch.randn(3, 1, 5, requires_grad=True)\n        y = torch.randn(4, 1, 8, 5, requires_grad=True)\n\n        graph = torch.jit.script(broadcast).graph\n        torch._C._jit_pass_complete_shape_analysis(graph, (x, y), False)\n        FileCheck().check(\"Double(4, 3, 8, 5, strides=[120, 40, 5, 1], device=cpu)\").run(str(graph))\n\n    def test_shape_analysis_unsqueeze_in_loop(self):\n        input_str = \"\"\"graph(%x.1 : Tensor):\n          %4 : bool = prim::Constant[value=1]()\n          %1 : int = prim::Constant[value=2]()\n          %7 : int = prim::Constant[value=0]()\n          # CHECK: FloatTensor(requires_grad=0, device=cpu) = prim::Loop\n          %x : Tensor = prim::Loop(%1, %4, %x.1)\n            # CHECK: : FloatTensor(requires_grad=0, device=cpu)):\n            block0(%i : int, %x.6 : Tensor):\n              # CHECK: FloatTensor(requires_grad=0, device=cpu) = aten::unsqueeze\n              %x.3 : Tensor = aten::unsqueeze(%x.6, %7)\n              -> (%4, %x.3)\n          return (%x)\"\"\"\n        graph = parse_ir(input_str)\n        torch._C._jit_pass_complete_shape_analysis(graph, (torch.zeros(2, 2, dtype=torch.float32),), False)\n        FileCheck().run(input_str, graph)\n\n    def test_script_tensor_type(self):\n        def foo(x, t: torch.dtype):\n            return x.type(t)\n        scr = torch.jit.script(foo)\n        x = torch.rand(3, 4)\n        for t in [torch.int8, torch.float64, torch.float32,\n                  torch.bfloat16, torch.complex64, torch.complex128, torch.bool]:\n            self.assertEqual(scr(x, t), foo(x, t))\n\n    def test_shape_analysis_masked_select(self):\n        input_str = \"\"\"graph(%0 : Float(),\n          %1 : Bool()):\n          # CHECK: Float(*, requires_grad=0, device=cpu) = aten::masked_select\n          %2 : Tensor = aten::masked_select(%0, %1) # test/test_jit.py:15261:0\n          return (%2)\"\"\"\n        graph = parse_ir(input_str)\n        x = torch.ones(1, dtype=torch.float32)[0]\n        mask = x.ge(0.5)\n        torch._C._jit_pass_complete_shape_analysis(graph, (x, mask), False)\n        FileCheck().run(input_str, graph)\n\n    # TODO: update verify to work with GraphExecutors\n    @unittest.skip(\"verify needs to be updated to work with GraphExecutors\")\n    def test_verify(self):\n        x = torch.tensor([0.4], requires_grad=True)\n        y = torch.tensor([0.7], requires_grad=True)\n\n        @torch.jit.compile\n        def f(x, y):\n            z = torch.sigmoid(x * (x + y))\n            w = torch.abs(x * x * x + y) + Variable(torch.ones(1))\n            return z, w\n\n        torch.jit.verify(f, (x, y), loss_fn=lambda z, w: z * w, devices=[])\n\n    # TODO: adapt to a GraphExecutor test\n    @unittest.skip(\"Need to instrument GraphExecutors a bit more\")\n    def test_flags(self):\n        x, y = torch.randn(2, 2)\n        y = Variable(torch.randn(2, 2))\n\n        @torch.jit.compile\n        def fn(x, y):\n            return (x * x + y * y + x * y).sum()\n\n        grads = {}\n        for rx, ry in product((True, False), repeat=2):\n            x.requires_grad = rx\n            y.requires_grad = ry\n\n            self.assertFalse(fn.has_trace_for(x, y))\n            out = fn(x, y)\n\n            self.assertFalse(fn.has_trace_for(x, y))\n            for v, name, compute in [(x, 'x', rx), (y, 'y', ry)]:\n                if not compute:\n                    continue\n                grad_v, = torch.autograd.grad(out, v, retain_graph=True)\n                expected_grad = grads.setdefault(name, grad_v)\n                self.assertEqual(grad_v, expected_grad)\n            self.assertEqual(fn.has_trace_for(x, y), rx or ry)\n\n    def test_python_ir(self):\n        x = torch.tensor([0.4], requires_grad=True)\n        y = torch.tensor([0.7], requires_grad=True)\n\n        def doit(x, y):\n            return torch.sigmoid(torch.tanh(x * (x + y)))\n\n        g, _ = torch.jit._get_trace_graph(doit, (x, y))\n        self.run_pass('dce', g)\n        self.run_pass('canonicalize', g)\n        g2 = torch._C.Graph()\n        g_to_g2 = {}\n        for node in g.inputs():\n            g_to_g2[node] = g2.addInput()\n        for node in g.nodes():\n            n_ = g2.createClone(node, lambda x: g_to_g2[x])\n            g2.appendNode(n_)\n            for o, no in zip(node.outputs(), n_.outputs()):\n                g_to_g2[o] = no\n\n        for node in g.outputs():\n            g2.registerOutput(g_to_g2[node])\n\n        t_node = g2.create(\"prim::TensorTest\").t_(\"a\", torch.ones([2, 2]))\n        self.assertEqual(t_node.attributeNames(), [\"a\"])\n        g2.appendNode(t_node)\n        self.assertTrue(torch.equal(torch.ones(2, 2), t_node.t(\"a\")))\n        for node in g.nodes():\n            self.assertTrue(g2.findNode(node.kind()) is not None)\n\n    def test_permute_inputs_binding(self):\n        @torch.jit.script\n        def foo(i, j, k):\n            pass\n\n        g = foo.graph\n\n        idxs = []\n        for i, inp in enumerate(g.inputs()):\n            inp.setDebugName(f\"inp{i}\")\n            idxs.append(i)\n\n        permuted_idxs = list(np.random.permutation(idxs))\n        g.permuteInputs(permuted_idxs)\n        for i, inp in enumerate(g.inputs()):\n            self.assertEqual(f\"inp{permuted_idxs[i]}\", inp.debugName())\n\n    @unittest.skipIf(IS_MACOS, \"Failing on MacOS only\")\n    def test_python_ir_utils(self):\n        @torch.jit.script\n        def foo(inp):\n            x = inp + 1\n            y = x / 2\n            z = y * y\n            return z\n\n        add_node = foo.graph.findNode(\"aten::add\")\n        div_node = foo.graph.findNode(\"aten::div\")\n\n        with foo.graph.insert_point_guard(add_node):\n            with foo.graph.insert_point_guard(div_node):\n                foo.graph.insertConstant(\"goodbye\")\n            foo.graph.insertConstant(\"hello\")\n        with foo.graph.insert_point_guard(foo.graph.findNode(\"aten::mul\")):\n            foo.graph.insertConstant(\"hello\")\n        FileCheck().check(\"hello\").check(\"goodbye\").check(\"hello\").run(foo.graph)\n\n        self.assertTrue(add_node.matches(add_node.schema()))\n        self.assertFalse(add_node.matches(div_node.schema()))\n\n    def test_python_ir_utils_graph(self):\n        @torch.jit.script\n        def unrolled_mul(x: torch.Tensor, y: int):\n            out = x\n            for _ in range(y - 1):\n                out = out + x\n            return out\n\n        @torch.jit.script\n        def foo(x):\n            return x * 4\n\n        g = foo.graph\n        muls = g.findAllNodes(\"aten::mul\")\n        scalar_muls = filter(lambda x: x.matches(\"aten::mul(Tensor self, Scalar other) -> Tensor\"), muls)\n        mul_constant_int = filter(lambda x: isinstance(list(x.inputs())[1].toIValue(), int), scalar_muls)\n        for mul in mul_constant_int:\n            with g.insert_point_guard(mul):\n                outputs = g.insertGraph(unrolled_mul.graph, list(mul.inputs()))\n                assert len(outputs) == len(list(mul.outputs()))\n                for new_out, old_out in zip(outputs, g.outputs()):\n                    old_out.replaceAllUsesWith(new_out)\n                mul.destroy()\n\n        FileCheck().check_not(\"aten::mul\").check(\"aten::add\").run(foo.graph)\n        self.assertEqual(foo(torch.ones([2, 2])), torch.ones([2, 2]) * 4)\n\n    @unittest.skipIf(IS_SANDCASTLE, \"gtest runs these in sandcastle\")\n    @unittest.skipIf(RUN_CUDA, \"covered by test_cpp_cuda\")\n    @unittest.skipIf(not torch._C._jit_has_cpp_tests(), \"Tests were not built, use BUILD_TEST=1\")\n    def test_cpp(self):\n        from cpp.jit import tests_setup\n        tests_setup.setup()\n        torch._C._jit_run_cpp_tests()\n        tests_setup.shutdown()\n\n    def test_batchnorm(self):\n        x = torch.ones(2, 2, 2, 2)\n        g, outputs, inputs = torch.jit._get_trace_graph(nn.BatchNorm2d(2), x,\n                                                        _force_outplace=True, return_inputs=True)\n        m = self.createFunctionFromGraph(g)\n        self.assertEqual(outputs, m(*inputs))\n\n    def test_dropout(self):\n        x = torch.ones(2, 2)\n        with torch.random.fork_rng(devices=[]):\n            g, outputs, inputs = torch.jit._get_trace_graph(nn.Dropout(0.6), x, return_inputs=True)\n        with torch.random.fork_rng(devices=[]):\n            m = self.createFunctionFromGraph(g)\n            self.assertEqual(outputs, m(*inputs))\n\n    @unittest.skipIf(not RUN_CUDA, \"test requires CUDA\")\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_native_dropout_corner_case(self):\n        with disable_autodiff_subgraph_inlining():\n            def t(x, p: float, t: bool):\n                o = torch.dropout(x, p, t)\n                return o\n\n            jit_t = torch.jit.script(t)\n            x = torch.randn(5).requires_grad_()\n            FileCheck().check(\"prim::DifferentiableGraph\").run(jit_t.graph_for(x, 1.0, True, profile_and_replay=True))\n\n            for train in [True, False]:\n                for p in [0.0, 1.0]:\n                    for device in [\"cuda\", \"cpu\"]:\n                        x = torch.randn(5).to(device=device).requires_grad_()\n                        x_ref = x.detach().requires_grad_()\n                        o = jit_t(x, p, train)\n                        o_ref = t(x_ref, p, train)\n                        o.sum().backward()\n                        o_ref.sum().backward()\n                        assert(o.equal(o_ref))\n                        assert(x.grad.equal(x_ref.grad))\n\n    @slowTest\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, 'Testing differentiable graph')\n    def test_dropout_module_requires_grad(self):\n        with enable_profiling_mode_for_profiling_tests():\n            class MyModule(torch.nn.Module):\n                def __init__(self, M):\n                    super(MyModule, self).__init__()\n                    self.dropout = torch.nn.Dropout(0.5)\n                    self.linear = torch.nn.Linear(M, M)\n\n                def forward(self, input):\n                    input = self.dropout(input)\n                    output = self.linear(input)\n                    return output\n\n            def profile(func, X):\n                with torch.autograd.profiler.profile() as prof:\n                    func(X)\n                return [e.name for e in prof.function_events]\n\n            M = 1000\n            scripted = torch.jit.script(MyModule(M))\n            # To reduce confusion about expected behaviors:\n            #   requires_grad controls whether dropout is symbolically differentiated.\n            #   training controls whether bernoulli_ is called inside symbolic differentiation of dropout.\n            # * When requires_grad == training, the expected behaviors are obvious.\n            # * When requires_grad=True and training=False, bernoulli_ might still show up in the graph.\n            #   But it's in a branch that's not called. That's why we have separate checks for autograd\n            #   profiler to make sure it's not run.\n            # * When requires_grad=False and training=True, bernoulli_ must be run since it's the expected\n            #   behavior for the dropout layer in training mode. It's independent of whether graph requires\n            #   gradient. In fact bernoulli_ comes from autograd instead of autodiff in this case.\n            for training in (True, False):\n                if training:\n                    scripted.train()\n                else:\n                    scripted.eval()\n                for requires_grad in (True, False):\n                    X = torch.randn(M, M, requires_grad=requires_grad)\n                    if requires_grad:\n                        FileCheck().check(\"aten::native_dropout\").run(scripted.graph_for(X, profile_and_replay=True))\n                    self.assertEqual(training, 'aten::bernoulli_' in profile(scripted, X))\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.SIMPLE, 'Testing differentiable graph')\n    @skipIfTorchDynamo(\"Torchdynamo cannot correctly handle profiler.profile calls\")\n    def test_dropout_func_requires_grad(self):\n        def dropout_training(input):\n            return F.dropout(input, 0.5, training=True)\n\n        def dropout_eval(input):\n            return F.dropout(input, 0.5, training=False)\n\n        def profile(func, X):\n            with torch.autograd.profiler.profile() as prof:\n                func(X)\n            return [e.name for e in prof.function_events]\n\n        M = 1000\n        scripted_training = torch.jit.script(dropout_training)\n        scripted_eval = torch.jit.script(dropout_eval)\n        # See comments in test_dropout_module_requires_grad.\n        with disable_autodiff_subgraph_inlining():\n            for requires_grad in (True, False):\n                X = torch.randn(M, M, requires_grad=requires_grad)\n                if requires_grad:\n                    FileCheck().check(\"aten::native_dropout\").run(scripted_training.graph_for(X, profile_and_replay=True))\n                self.assertIn('aten::bernoulli_', profile(scripted_training, X))\n                self.assertNotIn('aten::bernoulli_', profile(scripted_eval, X))\n\n    @unittest.skipIf(not RUN_CUDA, \"test_dropout_cuda require CUDA\")\n    def test_dropout_cuda(self):\n        # Dropout AD is dispatched to _fused_dropout in CUDA case,\n        # which is not included in TestJitGeneratedFunctional\n        def _zero_rate(t):\n            return torch.true_divide((t == 0).sum(), t.numel())\n\n        x = torch.ones(1000, 1000).cuda().requires_grad_()\n\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.nn.functional.dropout(x)\n\n            with freeze_rng_state():\n                out_ref = torch.nn.functional.dropout(x)\n                grad_ref = torch.autograd.grad(out_ref.sum(), x)\n\n            with freeze_rng_state():\n                out = func(x)\n                grad = torch.autograd.grad(out.sum(), x)\n\n            # TODO(#40882): previously we assert exact matches between eager and JIT result:\n            #  self.assertEqual(out, out_ref)\n            #  self.assertEqual(grad, grad_ref)\n            # This test was disabled during legacy -> profiling executor transition.\n            # Currently JIT fused results doesn't match eager result exactly due to some changes merged in between.\n            # We temporarily only check statstical difference but it should be reverted once the issue is fixed.\n            self.assertEqual(_zero_rate(out), _zero_rate(out_ref), rtol=1e-3, atol=1e-4)\n            self.assertEqual(_zero_rate(grad[0]), _zero_rate(grad_ref[0]), rtol=1e-3, atol=1e-4)\n\n    def test_torch_ops_overloaded(self):\n        with self.assertRaisesRegex(RuntimeError, \"failed to many any schema\"):\n            torch.ops.aten.add(\"a\", 1)\n        self.assertEqual(\"ab\", torch.ops.aten.add(\"a\", \"b\"))\n        a, b = torch.rand(3, 4), torch.rand(3, 4)\n        self.assertEqual(a + b, torch.ops.aten.add(a, b))\n        self.assertEqual(a + 1, torch.ops.aten.add(a, 1))\n\n    def test_torch_ops_kwonly(self):\n        a, b = torch.rand(3, 4), torch.rand(3, 4)\n        with self.assertRaisesRegex(RuntimeError, \"positional argument\"):\n            torch.ops.aten.add(a, b, 2)\n        # h/t Chillee for this ambiguous case\n        self.assertEqual(a.prod(1), torch.ops.aten.prod(a, 1))\n\n    def test_torch_complex(self):\n        def fn(real, img):\n            return torch.complex(real, img)\n\n        def fn_out(real, img, out):\n            return torch.complex(real, img, out=out)\n        self.checkScript(fn, (torch.rand(3, 4), torch.rand(3, 4), ))\n        self.checkScript(fn, (torch.ones(5, 1, 4), torch.ones(5, 1, 4), ))\n        self.checkScript(fn, (torch.zeros(1, 6), torch.ones(6, 1), ))\n        self.checkScript(fn, (torch.zeros(1, 6), torch.zeros(6, 1), ))\n        self.checkScript(fn, (torch.empty(3, 4), torch.empty(3, 4), ))\n\n        real = torch.tensor([1, 2], dtype=torch.float32)\n        img = torch.tensor([3, 4], dtype=torch.float32)\n        out = torch.empty([3, 4], dtype=torch.complex64)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.tensor([5, 2], dtype=torch.float64)\n        img = torch.tensor([3, 4], dtype=torch.float64)\n        out = torch.empty([5, 2], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([1, 2])\n        img = torch.ones([1, 2])\n        out = torch.empty([1, 2], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([3, 8, 7])\n        img = torch.ones([3, 8, 7])\n        out = torch.empty([3, 8, 7], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.empty([3, 2, 6])\n        img = torch.empty([3, 2, 6])\n        out = torch.empty([3, 2, 6], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.zeros([1, 3])\n        img = torch.empty([3, 1])\n        out = torch.empty([3, 3], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([2, 5])\n        img = torch.empty([2, 1])\n        out = torch.empty([2, 5], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n        real = torch.ones([2, 5])\n        img = torch.zeros([2, 1])\n        out = torch.empty([2, 5], dtype=torch.complex128)\n        self.checkScript(fn_out, (real, img, out, ))\n\n    def test_einsum(self):\n        def check(fn, jitted, *args):\n            self.assertGraphContains(jitted.graph, kind='aten::einsum')\n            self.assertEqual(fn(*args), jitted(*args))\n\n        def equation_format(x, y):\n            return torch.einsum('i,j->ij', (x, y))\n\n        def equation_format_varargs(x, y):\n            return torch.einsum('i,j->ij', x, y)\n\n        def sublist_format(x, y):\n            return torch.einsum(x, [0], y, [1], [0, 1])\n\n        x = make_tensor((5,), dtype=torch.float32, device=\"cpu\")\n        y = make_tensor((10,), dtype=torch.float32, device=\"cpu\")\n\n        for fn in [equation_format, equation_format_varargs, sublist_format]:\n            check(fn, torch.jit.script(fn), x, y)\n            check(fn, torch.jit.trace(fn, (x, y)), x, y)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_python_ivalue(self):\n        # Test if pure python object can be hold as IValue and conversion\n        # between IValue and PyObject are correct\n        # test for numpy object\n        py_array = np.arange(15)\n        ret_py_obj = torch._C._ivalue_debug_python_object(py_array)\n        self.assertEqual(py_array, ret_py_obj)\n\n        # test for function object\n        ret_py_obj = torch._C._ivalue_debug_python_object(F.relu)\n        self.assertEqual(F.relu, ret_py_obj)\n\n        # test for memory management\n        # we need to ensure IValue correctly call incref/decref to avoid\n        # dangling behavior and potential memory leaks during conversions\n        def test_func_scope_helper(inp):\n            # create a scope and do the conversion -> ivalue -> pyobject\n            # this func return a new pyobject that refcount + 1\n            inp_refcount = sys.getrefcount(inp)\n            ivalue_holder = torch._C._ivalue_debug_python_object(inp)\n            self.assertEqual(inp_refcount + 1, sys.getrefcount(ivalue_holder))\n            return ivalue_holder + 1\n\n        test_input = 2200\n        before_count = sys.getrefcount(test_input)\n        test_func_scope_helper(test_input)\n        after_count = sys.getrefcount(test_input)\n\n        # after the test_func_scope_helper_call, the refcount of\n        # test_input should be equal to the original refcount\n        # otherwise we get either dangling pointer or memory leak!\n        self.assertEqual(before_count, after_count)\n\n    def test_decompose_addmm(self):\n        def does_decompose():\n            @torch.jit.script\n            def addmm(mat, mat1, mat2):\n                a = mat.addmm(mat1, mat2)\n                b = mat.addmm(mat1, mat2, alpha=1.0, beta=1.0)\n                return a + b\n\n            mat = torch.randn(2, 2)\n            mat1 = torch.randn(2, 4)\n            mat2 = torch.randn(4, 2)\n\n            out_ref = addmm(mat, mat1, mat2)\n            self.run_pass('decompose_ops', addmm.graph)\n            out_test = addmm(mat, mat1, mat2)\n            self.assertEqual(out_ref, out_test)\n            FileCheck().check_not(\"addmm\").run(str(addmm.graph))\n\n        def doesnt_decompose():\n            @torch.jit.script\n            def addmm(mat, mat1, mat2, alpha, beta):\n                a = mat.addmm(mat1, mat2, alpha=4.20, beta=2.0)\n                b = mat.addmm(mat1, mat2, alpha=int(alpha), beta=int(beta))\n\n                return a + b\n\n            orig = str(addmm.graph)\n            self.run_pass('decompose_ops', addmm.graph)\n            self.assertTrue(orig == str(addmm.graph))\n\n        does_decompose()\n        doesnt_decompose()\n\n    @suppress_warnings\n    def test_sparse_tensors(self):\n        @torch.jit.ignore\n        def get_sparse():\n            return torch.sparse.FloatTensor(2, 3)\n\n        @torch.jit.script\n        def test_is_sparse(input):\n            # type: (Tensor) -> bool\n            return input.is_sparse\n\n        script_out_is_sparse = test_is_sparse(get_sparse())\n        script_out_is_dense = test_is_sparse(torch.randn(2, 3))\n        self.assertEqual(script_out_is_sparse, True)\n        self.assertEqual(script_out_is_dense, False)\n\n        def test_basic_sparse(input):\n            output = get_sparse()\n            return output, input\n\n        self.checkScript(test_basic_sparse, (get_sparse(),))\n        self.checkScript(test_basic_sparse, (torch.tensor([1]),))\n\n        def test_sparse_sum(input):\n            return torch.sparse.sum(input)\n\n        self.checkScript(test_sparse_sum, (get_sparse(),))\n\n        def test_sparse_mm(input1, input2):\n            return torch.sparse.mm(input1, input2)\n\n        self.checkScript(test_sparse_mm, (get_sparse(), torch.randn(3, 4)))\n\n        def test_sparse_addmm(input, input1, input2):\n            return torch.sparse.addmm(input, input1, input2)\n\n        def test_sparse_addmm_alpha_beta(input, input1, input2):\n            return torch.sparse.addmm(input, input1, input2, alpha=1.3, beta=1.5)\n\n        self.checkScript(test_sparse_addmm, (torch.randn(2, 4), get_sparse(), torch.randn(3, 4)))\n        self.checkScript(test_sparse_addmm_alpha_beta, (torch.randn(2, 4), get_sparse(), torch.randn(3, 4)))\n\n    @suppress_warnings\n    def test_sparse_csr_tensors(self):\n        @torch.jit.ignore\n        def get_sparse_csr():\n            return torch.randn(3, 3).to_sparse_csr()\n\n        @torch.jit.script\n        def test_is_sparse_csr(input):\n            # type: (Tensor) -> bool\n            return input.is_sparse_csr\n\n        script_out_is_sparse_csr = test_is_sparse_csr(get_sparse_csr())\n        script_out_is_dense_csr = test_is_sparse_csr(torch.randn(3, 3))\n\n        self.assertEqual(script_out_is_sparse_csr, True)\n        self.assertEqual(script_out_is_dense_csr, False)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_device_not_equal(self):\n\n        def compare_device(x: torch.device):\n            return x != torch.device(\"cuda:0\")\n\n        def compare_two_device(x: torch.device, y: torch.device):\n            return x != y\n\n        self.checkScript(compare_device, (torch.device(\"cuda:0\"),))\n        self.checkScript(compare_two_device, (torch.device(\"cuda:0\"), torch.device(\"cuda:1\"), ))\n\n    def test_constant_prop_simple(self):\n        @torch.jit.script\n        def constant_prop(input_int):\n            # type: (int) -> int\n            a = 2 * 3\n            b = a + 2\n            return b - input_int\n\n        out_ref = constant_prop(2)\n        self.run_pass('constant_propagation', constant_prop.graph)\n        out_test = constant_prop(2)\n        self.assertEqual(out_ref, out_test)\n        graph_str = str(constant_prop.graph)\n        self.assertTrue(\"aten::add\" not in graph_str and \"aten::mul\" not in graph_str)\n        const = constant_prop.graph.findNode(\"prim::Constant\").output().toIValue()\n        self.assertEqual(const, 8)\n\n    def test_constant_prop_nested(self):\n        @torch.jit.script\n        def constant_prop(a):\n            b = 2 + 1\n            if bool(a < 2):\n                c = b + 2\n            else:\n                c = b - 2\n            return c\n        out_ref = constant_prop(torch.tensor(2))\n        self.run_pass('constant_propagation', constant_prop.graph)\n        out_test = constant_prop(torch.tensor(2))\n        self.assertEqual(out_ref, out_test)\n        if_node = constant_prop.graph.findNode(\"prim::If\")\n        for block in if_node.blocks():\n            for node in block.nodes():\n                self.assertTrue(node.kind() == \"prim::Constant\")\n\n    def test_constant_prop_print(self):\n        @torch.jit.script\n        def constant_prop(input_tensor):\n            a = 2 * 3\n            print(a)\n            b = a + 2\n            return b + input_tensor\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        graph = constant_prop.graph\n        print_node = graph.findNode(\"prim::Print\")\n        self.assertTrue(print_node.input().toIValue() == 6)\n\n    def test_constant_prop_rand(self):\n        @torch.jit.script\n        def constant_prop():\n            a = torch.randn([3])\n            b = a + 2\n            return b\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        self.assertTrue(\"aten::randn\" in str(constant_prop.graph))\n\n    def test_constant_prop_none(self):\n        @torch.jit.script\n        def typed_none():\n            # type: () -> Optional[int]\n            return None\n\n        @torch.jit.script\n        def constant_prop():\n            a = typed_none()\n            b = typed_none()\n            if (a is None and b is None):\n                a = 2\n            else:\n                a = 1\n            return a\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        FileCheck().check(\"prim::Constant\").run(constant_prop.graph)\n\n    def test_constant_prop_if_inline(self):\n        @torch.jit.script\n        def constant_prop():\n            cond = True\n            a = 1\n            if cond:\n                a = 1 * 2\n            else:\n                a = 1 // 0\n            return a\n\n        # testing that 1 // 0 error is not thrownn\n        self.run_pass('constant_propagation', constant_prop.graph)\n\n    def test_constant_prop_exception(self):\n        # checking y = a[4] does not error in constant propagation\n        def bad_index(x):\n            # type: (bool)\n            y = 0\n            if x:\n                a = [1, 2, 3]\n                y = a[4]\n            return y\n\n        self.checkScript(bad_index, (False,))\n\n    def test_constant_prop_aliasing_type(self):\n        @torch.jit.script\n        def foo():\n            return len([1]), len(torch.tensor([2]))\n\n        FileCheck().check_dag(\"aten::tensor\").check_dag(\"aten::len\").run(foo.graph)\n\n        @torch.jit.script\n        def fn():\n            if 1 == 1:\n                return 1\n            else:\n                return 2\n\n        FileCheck().check_not(\"prim::If\").run(fn.graph)\n\n    def test_unchecked_cast(self):\n        def test(cond):\n            # type: (bool)\n            a = torch.tensor([10])\n            if cond:\n                b = None\n            else:\n                b = a\n            if b is not None:\n                b[0] = 5\n            return a.int()\n\n        self.checkScript(test, (True,))\n        self.checkScript(test, (False,))\n\n    def test_constant_prop_if_constant(self):\n        @torch.jit.script\n        def constant_prop(a, b):\n            c0 = 1\n            c1 = 1\n            c2 = 1\n            if bool(a):  # -> c0, c1\n                if bool(b):  # -> c0\n                    if 1 == 1:  # -> c0\n                        c0 = c0 + 1\n                        if 1 == 2:\n                            c1 = c1 + 1\n                            c2 = c2 + 1\n            else:  # -> c0, c1\n                c1 = c1 + 1\n\n            if 1 == 1:  # inlined\n                c0 = c0 + 1  # dynamic\n                c2 = c2 + 4  # set to 5\n            return a + c0 + c1 + c2\n\n        graph = constant_prop.graph\n        self.run_pass('constant_propagation', graph)\n        ifs = graph.findAllNodes(\"prim::If\", recurse=False)\n        snd_if_inlined = len(ifs) == 1\n        self.assertTrue(snd_if_inlined)\n        first_if = ifs[0]\n        self.assertTrue(first_if.outputsSize() == 2)\n        second_if = first_if.findNode(\"prim::If\", recurse=False)\n        self.assertTrue(second_if.outputsSize() == 1)\n        self.assertTrue(second_if.findNode(\"prim::If\") is None)\n\n    def test_constant_prop_loop_constant(self):\n        @torch.jit.script\n        def constant_prop(cond, iter):\n            # type: (bool, int) -> int\n            b = 0\n            while True:\n                print(\"stays\")\n            for _ in range(2):\n                print(\"stays\")\n            for _ in range(iter):\n                print(\"stays\")\n            while cond:\n                print(\"stays\")\n            while False:\n                print(\"removed\")\n            for _i in range(0):\n                print(\"removed\")\n            for _i in range(-4):\n                print(\"removed\")\n            return b\n\n        self.run_pass('constant_propagation', constant_prop.graph)\n        graph = canonical(constant_prop.graph)\n        self.assertTrue(graph.count(\"removed\") == 0)\n        self.assertTrue(graph.count(\"stays\") == 1)  # constant gets pooled\n        self.assertTrue(graph.count(\"prim::Print\") == 4)\n\n    def test_constant_prop_remove_output(self):\n        @torch.jit.script\n        def constant_prop(iter):\n            # type: (int) -> None\n            a = 1\n            b = 1\n            c = 1\n            for i in range(iter):\n                if 1 == 2:\n                    a = 10\n                if i == 5:\n                    b = 2\n                    c = 3\n            print(a, b, c)\n\n        graph = constant_prop.graph\n        self.run_pass('constant_propagation', graph)\n        self.assertTrue(graph.findNode(\"prim::Loop\").outputsSize() == 2)\n\n    # TODO(gmagogsfm): Refactor this test to reduce complexity.\n    def test_constant_insertion(self):\n        funcs_template = dedent('''\n        def func():\n            return {constant_constructor}\n        ''')\n\n        # constants: primitives: int, double, bool, str, lists of primitives,\n        # and tuples\n        def check_constant(constant_constructor):\n            scope = {}\n            funcs_str = funcs_template.format(constant_constructor=constant_constructor)\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            self.run_pass('constant_propagation', f_script.graph)\n            FileCheck().check_count(\"prim::Constant\", 1, exactly=True).run(f_script.graph)\n            self.assertEqual(scope['func'](), f_script())\n            imported = self.getExportImportCopy(f_script)\n            self.assertEqual(imported(), f_script())\n\n        constants = [\"None\", \"-.5\", \"0\", \"1\", \"True\", \"False\", \"''\", \"'a'\", \"'b'\", \"torch.tensor(1)\",\n                     \"[True, False]\", \"[0., .5]\", \"[torch.tensor(4), torch.tensor(2)]\", \"[0, 1]\", \"['0', '1']\",\n                     \"[True, None]\", \"[.5, None, .2]\"]\n\n        for type in [\"Tensor\", \"str\", \"int\", \"float\", \"bool\"]:\n            constants.append(\"torch.jit.annotate(List[ \" + type + \"], [])\")\n\n        for constant in constants:\n            check_constant(constant)\n\n        for key_type in [\"str\", \"int\", \"float\"]:\n            for value_type in [\"Tensor\", \"bool\", \"str\", \"int\", \"float\"]:\n                check_constant(\"torch.jit.annotate(Dict[ \" + key_type + \", \" + value_type + \"], {})\")\n                check_constant(\"torch.jit.annotate(Dict[ \" + key_type + \", Optional[\" + value_type + \"]], {})\")\n\n        for i in range(len(constants)):\n            for j in range(i + 1, len(constants)):\n                tup_constant = constants[i] + \", \" + constants[j]\n                check_constant(tup_constant)\n\n        dict_constants = []\n        for i in range(len(constants)):\n            # check_constant constructs the second dict with another Tensor\n            # which fails the comparison\n            if not isinstance(eval(constants[i]), (str, int, float)):\n                continue\n            for j in range(len(constants)):\n                dict_constant = \"{ \" + constants[i] + \": \" + constants[j] + \"}\"\n                check_constant(dict_constant)\n                dict_constants.append(dict_constant)\n        constants = constants + dict_constants\n\n        # testing node hashing\n        funcs_template = dedent('''\n        def func():\n            print({constant_constructor})\n        ''')\n        single_elem_tuples = (\"(\" + x + \",)\" for x in constants)\n        input_arg = \", \".join(single_elem_tuples)\n        scope = {}\n        funcs_str = funcs_template.format(constant_constructor=input_arg)\n        execWrapper(funcs_str, globals(), scope)\n        cu = torch.jit.CompilationUnit(funcs_str)\n        f_script = cu.func\n        self.run_pass('constant_propagation', f_script.graph)\n        # prim::None return adds one constant\n        self.assertEqual(len(constants) + 1, str(f_script.graph).count(\"prim::Constant\"))\n        self.run_pass('cse', f_script.graph)\n        # node hashing correctly working, no CSE occurs\n        self.assertEqual(len(constants) + 1, str(f_script.graph).count(\"prim::Constant\"))\n\n        funcs_template = dedent('''\n        def func():\n            a = {constant_constructor}\n            print(a)\n            b = {constant_constructor}\n            print(b)\n        ''')\n\n        # generate dicts with built-in types (excluding torch.Tensor)\n        xprod = itertools.product(constants, constants)\n\n        # test that equal tuples and dicts correctly work with node hashing\n        for tup in (\"(\" + x + \",)\" for x in constants):\n            funcs_str = funcs_template.format(constant_constructor=tup)\n            scope = {}\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            self.run_pass('constant_propagation_immutable_types', f_script.graph)\n            num_constants = str(f_script.graph).count(\"prim::Constant\")\n            self.run_pass('cse', f_script.graph)\n            FileCheck().check_count(\"prim::Constant\", num_constants, exactly=True).run(f_script.graph)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_cuda_export_restore(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(3, 4))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mod = Sub()\n\n            @torch.jit.script_method\n            def forward(self, v):\n                return self.mod(v)\n        m = M()\n        m.cuda()\n        m2 = self.getExportImportCopy(m)\n        m2.cuda()\n        input = torch.rand(3, 4).cuda()\n        self.assertEqual(m(input), m2(input))\n\n    @slowTest\n    def test_export_batchnorm(self):\n        for mode in ['eval', 'train']:\n            for clazz in [\n                    torch.nn.BatchNorm1d(100),\n                    torch.nn.BatchNorm1d(100, affine=False),\n                    torch.nn.BatchNorm2d(100),\n                    torch.nn.BatchNorm2d(100, affine=False)]:\n                getattr(clazz, mode)()\n                input = torch.randn(20, 100) if isinstance(clazz, torch.nn.BatchNorm1d) else \\\n                    torch.randn(20, 100, 35, 45)\n                traced = torch.jit.trace(clazz, (input,))\n                imported = self.getExportImportCopy(traced)\n                x = torch.randn(20, 100) if isinstance(clazz, torch.nn.BatchNorm1d) else \\\n                    torch.randn(20, 100, 35, 45)\n                self.assertEqual(traced(x), imported(x))\n\n    def test_export_rnn(self):\n        for clazz in [nn.RNN(10, 20, 2), nn.GRU(10, 20, 2)]:\n            class RNNTest(torch.nn.Module):\n                def __init__(self):\n                    super(RNNTest, self).__init__()\n                    self.rnn = clazz\n\n                def forward(self, x, lengths, h0):\n                    packed = torch.nn.utils.rnn.pack_padded_sequence(x, lengths)\n                    out, h = self.rnn(packed, h0)\n                    padded_outs, _ = torch.nn.utils.rnn.pad_packed_sequence(out)\n                    return padded_outs\n\n            test = RNNTest()\n\n            traced = torch.jit.trace(test, (torch.randn(5, 3, 10), torch.LongTensor([3, 2, 1]), torch.randn(2, 3, 20)))\n            imported = self.getExportImportCopy(traced)\n            # NB: We make sure to pass in a batch with a different max sequence\n            # length to ensure that the argument stashing for pad_packed works\n            # properly.\n            x, lengths, h0 = torch.randn(7, 4, 10), torch.LongTensor([7, 3, 2, 1]), torch.randn(2, 4, 20)\n            self.assertEqual(traced(x, lengths, h0), imported(x, lengths, h0))\n\n    def test_export_lstm(self):\n        class LSTMTest(torch.nn.Module):\n            def __init__(self):\n                super(LSTMTest, self).__init__()\n                self.rnn = nn.LSTM(10, 20, 2)\n\n            def forward(self, x, lengths, hiddens):\n                h0, c0 = hiddens\n                packed = torch.nn.utils.rnn.pack_padded_sequence(x, lengths)\n                out, (h, c) = self.rnn(packed, (h0, c0))\n                padded_outs, _ = torch.nn.utils.rnn.pad_packed_sequence(out)\n                return padded_outs\n\n        test = LSTMTest()\n\n        traced = torch.jit.trace(test, (torch.randn(5, 3, 10),\n                                        torch.LongTensor([3, 2, 1]),\n                                        (torch.randn(2, 3, 20), torch.randn(2, 3, 20))))\n        imported = self.getExportImportCopy(traced)\n        x, lengths, h0, c0 = \\\n            torch.randn(7, 3, 10), torch.LongTensor([7, 5, 2]), torch.randn(2, 3, 20), torch.randn(2, 3, 20)\n        self.assertEqual(traced(x, lengths, (h0, c0)), imported(x, lengths, (h0, c0)))\n\n    def test_unique_state_dict(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                shared_param = torch.nn.Parameter(torch.ones(1))\n                self.register_parameter('w1', shared_param)\n                self.register_parameter('w2', shared_param)\n\n            def forward(self, input):\n                return input + self.w1 + self.w2\n\n        model = MyModule()\n        unittest.TestCase.assertEqual(\n            self, len(torch.jit._unique_state_dict(model, keep_vars=False)), 1)\n        unittest.TestCase.assertEqual(\n            self, len(torch.jit._unique_state_dict(model, keep_vars=True)), 1)\n\n    def test_export_dropout(self):\n        test = torch.nn.Dropout()\n        test.eval()\n\n        traced = torch.jit.trace(test, (torch.rand(3, 4),), check_trace=False)\n        imported = self.getExportImportCopy(traced)\n        x = torch.randn(3, 4)\n        self.assertEqual(traced(x), imported(x))\n\n    def test_pretty_printer(self):\n        @torch.jit.script\n        def if_test(a, b):\n            # FIXME: use 0 instead of a.\n            # c = 0\n            c = a\n            if bool(a < b):\n                c = b\n            else:\n                c = a\n            return c\n\n        @torch.jit.script\n        def if_one(a, b):\n            c = b\n            if bool(a < b):\n                c = a\n            return c\n\n        @torch.jit.script\n        def while_test(a, i):\n            while bool(i < 3):\n                a *= a\n                i += 1\n            return a\n\n        @torch.jit.script\n        def while_if_test(a, b):\n            c = 0\n            while bool(a < 10):\n                a = a + 1\n                b = b + 1\n                if bool(a > b):\n                    c = 2\n                else:\n                    c = 3\n            return a + 1 + c\n\n        @torch.jit.script\n        def loop_use_test(y):\n            x = y + 1\n            z = x + 5\n            while bool(y < 8):\n                y += 1\n                z = x\n            return x, z\n\n        @torch.jit.ignore\n        def python_fn(x):\n            return x + 10\n\n        @torch.jit.script\n        def python_op_name_test(y):\n            return python_fn(y)\n\n        @torch.jit.script\n        def empty_int_list_test(y):\n            x = torch.jit.annotate(List[int], [])\n            return x[0]\n\n        @torch.jit.script\n        def empty_float_list_test(y):\n            return [1.0, 2.0, 3.0]\n\n        @torch.jit.script\n        def print_weird_test(y):\n            print(\"hi\\016\")\n\n        self.assertExpected(if_test.code, \"if_test\")\n        self.assertExpected(if_one.code, \"if_one\")\n        self.assertExpected(while_test.code, \"while_test\")\n        self.assertExpected(while_if_test.code, \"while_if_test\")\n        self.assertExpected(loop_use_test.code, \"loop_use_test\")\n        self.assertExpected(python_op_name_test.code, \"python_op_name_test\")\n        self.assertExpected(empty_int_list_test.code, \"empty_int_list_test\")\n        self.assertExpected(empty_float_list_test.code, \"empty_float_list_test\")\n        self.assertExpected(print_weird_test.code, \"print_weird_test\")\n\n    def test_cu_escaped_number(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                print(\"hi\\016\")\n        ''')\n        self.assertExpected(cu.foo.code)\n\n    def test_import_method(self):\n        with torch._jit_internal._disable_emit_hooks():\n            class Foo(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(Foo, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self, x, y):\n                    return 2 * x + y\n\n            foo = Foo()\n            buffer = io.BytesIO()\n            torch.jit.save(foo, buffer)\n\n            buffer.seek(0)\n            foo_loaded = torch.jit.load(buffer)\n            self.assertExpected(foo_loaded.forward.code)\n\n    @unittest.skip(\"temporarily disable the test for fwd compatibility\")\n    def test_non_ascii_string(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.a = \"Over \\u0e55\\u0e57 57\"\n\n            @torch.jit.script_method\n            def forward(self, x, y):\n                return self.a + \"hi\\xA1\"\n\n        foo = Foo()\n        buffer = io.BytesIO()\n        torch.jit.save(foo, buffer)\n\n        buffer.seek(0)\n        foo_loaded = torch.jit.load(buffer)\n        self.assertExpected(foo_loaded.forward.code)\n\n    def test_function_default_values(self):\n        outer_var = torch.tensor(20)\n        outer_var2 = torch.tensor(30)\n        a = torch.tensor(0.5)\n        b = torch.tensor(10)\n\n        @torch.jit.script\n        def simple_fn(x, a=a, b=b, c=outer_var + outer_var2):\n            return x + a + b + c\n\n        self.assertEqual(\n            simple_fn(torch.ones(1)),\n            torch.ones(1) + 0.5 + 10 + (20 + 30))\n        self.assertEqual(\n            simple_fn(torch.ones(1), torch.tensor(1), torch.tensor(3), torch.tensor(4)),\n            torch.ones(1) + 1 + 3 + 4)\n\n        outer_c = torch.tensor(9)\n        outer_flag = torch.tensor(False)\n\n        @torch.jit.script\n        def bool_fn(x, a=outer_c, flag=outer_flag):\n            if bool(flag):\n                result = x\n            else:\n                result = x + a\n            return result\n\n        self.assertEqual(bool_fn(torch.ones(1)), torch.ones(1) + 9)\n        self.assertEqual(\n            bool_fn(torch.ones(1), torch.tensor(1), torch.tensor(True)),\n            torch.ones(1))\n\n        @torch.jit.script\n        def none_fn(x=None):\n            # type: (Optional[int]) -> Optional[int]\n            return x\n\n        self.assertEqual(none_fn(), None)\n        self.assertEqual(none_fn(1), 1)\n\n        @torch.jit.script\n        def hints(x, a=0.5, b=10):\n            # type: (Tensor, float, int) -> Tensor\n            return x + a + b\n\n        self.assertEqual(hints(torch.ones(1)), torch.ones(1) + 0.5 + 10)\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected a default value\"):\n\n            @torch.jit.script\n            def hints_bad_types(x, a=10, b=0.5):  # noqa: T484\n                # type: (Tensor, float, int) -> Tensor\n                return x + a + b\n        with self.assertRaisesRegex(RuntimeError, \"Expected a default value\"):\n            @torch.jit.script\n            def bad_no_optional(x=None):\n                # type: (Dict[str, int]) -> Dict[str, int]\n                return x\n\n\n    def test_module_default_values(self):\n        four = torch.tensor(4)\n\n        class Test(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Test, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, input, other=four):\n                return input + other\n\n        t = Test()\n        self.assertEqual(t(torch.ones(1)), torch.ones(1) + 4)\n\n    def test_mutable_default_values(self):\n        with self.assertRaisesRegex(Exception, \"Mutable default parameters\"):\n            @torch.jit.script\n            def foo(x=(1, [])):\n                # type: (Tuple[int, List[Tensor]])\n                return x\n\n        class Test(torch.nn.Module):\n            def forward(self, input=[]):  # noqa: B006\n                return input\n\n        with self.assertRaisesRegex(Exception, \"Mutable default parameters\"):\n            torch.jit.script(Test())\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_warnings(self):\n        import warnings\n\n        def fn(x):\n            if bool(x < 2):\n                warnings.warn(\"x is less than 2\")\n            return x\n\n        class M(torch.nn.Module):\n            def forward(self, x):\n                if bool(x < 2):\n                    warnings.warn(\"x is less than 2\")\n                return x\n\n\n        scripted_mod = torch.jit.script(M())\n        scripted_fn = torch.jit.script(fn)\n\n        with warnings.catch_warnings(record=True) as warns:\n            fn(torch.ones(1))\n\n        with warnings.catch_warnings(record=True) as script_warns:\n            scripted_fn(torch.ones(1))\n\n        with warnings.catch_warnings(record=True) as script_mod_warns:\n            scripted_mod(torch.ones(1))\n\n        self.assertEqual(str(warns[0]), str(script_warns[0]))\n        self.assertEqual(len(script_mod_warns), 1)\n        self.assertEqual(str(warns[0].message), str(script_mod_warns[0].message))\n\n    def test_no_erroneous_warnings(self):\n        import warnings\n\n        def fn(x):\n            if bool(x > 0):\n                warnings.warn('This should NOT be printed')\n                x += 1\n            return x\n\n        with warnings.catch_warnings(record=True) as warns:\n            fn_script = torch.jit.script(fn)\n            fn_script(torch.tensor(0))\n        warns = [str(w.message) for w in warns]\n        self.assertEqual(len(warns), 0)\n\n    @unittest.skipIf(True, \"TODO: re-enable with https://github.com/pytorch/pytorch/pull/29339\")\n    def test_torch_load_error(self):\n        class J(torch.jit.ScriptModule):\n            def __init__(self):\n                super(J, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return input + 100\n\n        j = J()\n        with TemporaryFileName() as fname:\n            j.save(fname)\n            with self.assertRaisesRegex(RuntimeError, \"is a zip\"):\n                torch.load(fname)\n\n    def test_torch_load_zipfile_check(self):\n        @torch.jit.script\n        def fn(x):\n            return x + 10\n\n        with TemporaryFileName() as fname:\n            fn.save(fname)\n            with io.open(fname, 'rb') as f:\n                self.assertTrue(torch.serialization._is_zipfile(f))\n\n    def test_python_bindings(self):\n        lstm_cell = torch.jit.script(LSTMCellS)\n\n        def lstm(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n            for i in range(x.size(0)):\n                hx, cx = lstm_cell(x[i], hx, cx, w_ih, w_hh, b_ih, b_hh)\n            return hx\n\n        slstm = torch.jit.script(lstm)\n\n        inputs = get_lstm_inputs('cpu', training=True, seq_length=10)\n        slstm(*inputs).sum().backward()\n        global fw_graph\n        fw_graph = slstm.graph_for(*inputs)\n        nodes = list(fw_graph.nodes())\n        tested_blocks = False\n        for node in nodes:\n            for output in node.outputs():\n                self.assertTrue(hasattr(output, 'type'))\n                self.assertTrue(output.type() is not None)\n            for input in node.inputs():\n                self.assertTrue(hasattr(input, 'type'))\n                self.assertTrue(input.type() is not None)\n            for block in node.blocks():\n                tested_blocks = True\n                self.assertTrue(hasattr(block, 'inputs'))\n                self.assertTrue(hasattr(block, 'outputs'))\n                for output in block.outputs():\n                    self.assertTrue(hasattr(output, 'type'))\n                    self.assertTrue(output.type() is not None)\n                for input in block.inputs():\n                    self.assertTrue(hasattr(input, 'type'))\n                    self.assertTrue(input.type() is not None)\n                self.assertTrue(hasattr(block, 'returnNode'))\n                self.assertTrue(type(block.returnNode()) == torch._C.Node)\n                self.assertTrue(hasattr(block, 'paramNode'))\n                self.assertTrue(type(block.paramNode()) == torch._C.Node)\n        self.assertTrue(tested_blocks)\n\n    def test_export_opnames(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n\n            def one(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                return x + y\n\n            def two(self, x):\n                # type: (Tensor) -> Tensor\n                return 2 * x\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                return self.one(self.two(x), x)\n\n        class Bar(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Bar, self).__init__()\n                self.sub = Foo()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                return self.sub.forward(x)\n\n        bar = Bar()\n        ops = torch.jit.export_opnames(bar)\n        expected = ['aten::add.Tensor', 'aten::mul.Scalar']\n        self.assertTrue(set(expected).issubset(set(ops)))\n\n    def test_pytorch_jit_env_off(self):\n        import subprocess\n        env = os.environ.copy()\n        env['PYTORCH_JIT'] = '0'\n        try:\n            subprocess.check_output([sys.executable, '-c', 'import torch'], env=env)\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(\"Could not 'import torch' with PYTORCH_JIT=0\") from e\n\n    def test_print_op_module(self):\n        # Issue #19351: python2 and python3 go through different paths.\n        # python2 returns '<module 'torch.ops' (built-in)>'\n        # python3 uses __file__ and return\n        # '<module 'torch.ops' from '/scratch/ailzhang/pytorch/torch/_ops.py'>'\n        s = str(torch.ops)\n        self.assertRegex(s, r'ops')\n\n    def test_print_classes_module(self):\n        s = str(torch.classes)\n        self.assertRegex(s, r'classes')\n\n    def test_print_torch_ops_modules(self):\n        s = str(torch._ops.ops.quantized)\n        self.assertRegex(s, r'torch.ops')\n        s = str(torch._ops.ops.atan)\n        self.assertRegex(s, r'torch.ops')\n\n    @unittest.skipIf(IS_WINDOWS, 'TODO: fix occasional windows failure')\n    def test_profiler(self):\n        prev_opt = torch._C._get_graph_executor_optimize()\n        torch._C._set_graph_executor_optimize(False)\n\n        def other_fn(x):\n            return x * 2\n\n        x = torch.rand(3, 4)\n        traced_other_fn = torch.jit.trace(other_fn, x)\n\n        def fn(x):\n            y = traced_other_fn(x)\n            fut = torch.jit._fork(traced_other_fn, x)\n            y = torch.jit._wait(fut)\n            return y\n\n        traced_fn = torch.jit.trace(fn, x)\n        with torch.autograd.profiler.profile() as prof:\n            traced_fn(x)\n\n        # expecting to see other_fn TS function call\n        # with cpu time >= mul cpu time and\n        # a forked other_fn\n\n        mul_events = defaultdict(int)\n        other_fn_events = defaultdict(int)\n        for e in prof.function_events:\n            if e.name == \"aten::mul\":\n                self.assertTrue(e.thread not in mul_events)\n                mul_events[e.thread] = e.time_range.elapsed_us()\n            elif e.name == \"other_fn\":\n                self.assertTrue(e.thread not in other_fn_events)\n                other_fn_events[e.thread] = e.time_range.elapsed_us()\n\n        self.assertTrue(len(mul_events) == 2)\n        self.assertTrue(len(other_fn_events) == 2)\n\n        for thread, mul_time in mul_events.items():\n            self.assertTrue(thread in other_fn_events)\n            self.assertTrue(other_fn_events[thread] >= mul_time)\n\n        torch._C._set_graph_executor_optimize(prev_opt)\n\n    def test_hide_source_ranges_context_manager(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.add(x, x)\n\n        graph = foo.graph\n        source_range_regex = \"# .*\\\\.py\"\n        self.assertRegex(graph.__repr__(), source_range_regex)\n        with torch.jit._hide_source_ranges():\n            self.assertNotRegex(graph.__repr__(), source_range_regex)\n            self.assertRegex(graph.str(print_source_ranges=True), source_range_regex)\n        self.assertRegex(graph.__repr__(), source_range_regex)\n\n\nclass TestFrontend(JitTestCase):\n\n    def test_instancing_error(self):\n        @torch.jit.ignore\n        class MyScriptClass(object):\n            def unscriptable(self):\n                return \"a\" + 200\n\n\n        class TestModule(torch.nn.Module):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n            def forward(self, x):\n                return MyScriptClass()\n\n        with self.assertRaises(torch.jit.frontend.FrontendError) as cm:\n            torch.jit.script(TestModule())\n\n        checker = FileCheck()\n        checker.check(\"Cannot instantiate class\")\n        checker.check(\"def forward\")\n        checker.run(str(cm.exception))\n\n    def test_dictionary_as_example_inputs_for_jit_trace(self):\n        class TestModule_v1(torch.nn.Module):\n            def __init__(self):\n                super(TestModule_v1, self).__init__()\n\n            def forward(self, key2=None, key3=None, key4=None, key5=None, key1=None, key6=None):\n                return key1 + key2 + key3\n\n        class TestModule_v2(torch.nn.Module):\n            def __init__(self):\n                super(TestModule_v2, self).__init__()\n\n            def forward(self, x, y):\n                return x + y\n\n        def test_func(x, y):\n            return x + y\n        model_1 = TestModule_v1()\n        model_2 = TestModule_v2()\n        value1 = torch.ones(1)\n        value2 = torch.ones(1)\n        value3 = torch.ones(1)\n        example_input_dict = {'key1': value1, 'key2': value2, 'key3': value3}\n        example_input_dict_func = {'x': value1, 'y': value2}\n        traced_model_1 = torch.jit.trace(model_1, example_kwarg_inputs=example_input_dict, strict=False)\n        traced_model_1_m = torch.jit.trace_module(\n            model_1, {'forward': example_input_dict}, example_inputs_is_kwarg=True, strict=False)\n        traced_model_2 = torch.jit.trace(model_2, example_kwarg_inputs={'x': torch.rand([2]), 'y': torch.rand([2])})\n        traced_func = torch.jit.trace(test_func, example_kwarg_inputs=example_input_dict_func, strict=False)\n        res_1 = traced_model_1(**example_input_dict)\n        res_1_m = traced_model_1_m(**example_input_dict)\n        self.assertEqual(res_1, 3 * torch.ones(1))\n        self.assertEqual(res_1_m, 3 * torch.ones(1))\n        res_func = traced_func(**example_input_dict_func)\n        self.assertEqual(res_func, 2 * torch.ones(1))\n        with self.assertRaisesRegex(RuntimeError, r\"forward\\(\\) is missing value for argument 'x'.\"):\n            res_2 = traced_model_2(**{'z': torch.rand([2]), 'y': torch.rand([2])})\n        with self.assertRaisesRegex(RuntimeError, r\"forward\\(\\) is missing value for argument 'y'.\"):\n            res_2 = traced_model_2(**{'x': torch.rand([2]), 'z': torch.rand([2])})\n\n\nclass TestScript(JitTestCase):\n\n    # Tests that calling torch.jit.script repeated on function is allowed.\n    def test_repeated_script_on_function(self):\n        @torch.jit.script\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        torch.jit.script(torch.jit.script(fn))\n\n    def test_pretty_print_function(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.nn.functional.interpolate(x)\n\n        FileCheck().check(\"interpolate\").run(foo.code)\n\n    def test_inlined_graph(self):\n        \"\"\"\n        Check that the `inlined_graph` property correctly returns an inlined\n        graph, both through function calls and method calls.\n        \"\"\"\n        @torch.jit.script\n        def foo(x):\n            return torch.add(x, x)\n\n        class MyNestedMod(torch.nn.Module):\n            def __init__(self):\n                super(MyNestedMod, self).__init__()\n\n            def forward(self, x):\n                return torch.sub(x, x)\n\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.nested = MyNestedMod()\n\n            def forward(self, x):\n                x = self.nested(x)  # sub\n                x = foo(x)  # add\n                return torch.mul(x, x)\n\n        m = torch.jit.script(MyMod())\n        FileCheck().check(\"aten::sub\") \\\n            .check(\"aten::add\") \\\n            .check(\"aten::mul\") \\\n            .run(m.inlined_graph)\n\n    def test_static_method_on_module(self):\n        \"\"\"\n        Check that the `@staticmethod` annotation on a function on a module works.\n        \"\"\"\n        class MyCell(torch.nn.Module):\n            def __init__(self):\n                super(MyCell, self).__init__()\n\n            @staticmethod\n            def do_it(x, h):\n                new_h = torch.tanh(x + h)\n                return new_h, new_h\n\n            def forward(self, x, h):\n                return self.do_it(x, h)\n\n        my_cell = torch.jit.script(MyCell())\n        x = torch.rand(3, 4)\n        h = torch.rand(3, 4)\n        jitted_cell = my_cell(x, h)\n        non_jitted_cell = MyCell().do_it(x, h)\n\n        self.assertEqual(jitted_cell, non_jitted_cell)\n\n    def test_code_with_constants(self):\n        \"\"\"\n        Check that the `code_with_constants` property correctly returns graph CONSTANTS in the\n        CONSTANTS.cN format used in the output of the `code` property.\n        \"\"\"\n        @torch.jit.script\n        def foo(x=torch.ones(1)):\n            return x\n\n        class Moddy(torch.nn.Module):\n            def __init__(self):\n                super(Moddy, self).__init__()\n\n            def forward(self, x):\n                return foo()\n\n        m = torch.jit.script(Moddy())\n        src, CONSTANTS = m.code_with_constants\n\n        self.assertEqual(CONSTANTS.c0, torch.ones(1))\n        self.assertEqual(src, m.code)\n\n    def test_code_with_constants_restore(self):\n        \"\"\"\n        Check that the `code_with_constants` property correctly works on restoration after save() + load()\n        \"\"\"\n        @torch.jit.script\n        def foo(x=torch.ones(1)):\n            return x\n\n        class Moddy(torch.nn.Module):\n            def __init__(self):\n                super(Moddy, self).__init__()\n\n            def forward(self, x):\n                return foo()\n\n        m = torch.jit.script(Moddy())\n        src, CONSTANTS = m.code_with_constants\n        eic = self.getExportImportCopy(m)\n\n        src_eic, CONSTANTS_eic = eic.code_with_constants\n\n        self.assertEqual(src, src_eic)\n        self.assertEqual(CONSTANTS.c0, CONSTANTS_eic.c0)\n\n\n    def test_oneline_func(self):\n        def fn(x): return x  # noqa: E704\n\n        self.checkScript(fn, (torch.ones(2, 2), ))\n\n    def test_request_bailout(self):\n        with enable_profiling_mode_for_profiling_tests():\n\n            def fct_loop(x):\n                for i in range(3):\n                    x = torch.cat((x, x), 0)\n                return x\n\n            x = torch.ones(2, 3, 4, dtype=torch.float32)\n            expected = fct_loop(x)\n            jitted = torch.jit.script(fct_loop)\n            # profile\n            jitted(x)\n            # optimize\n            jitted(x)\n            dstate = jitted.get_debug_state()\n            eplan = get_execution_plan(dstate)\n            num_bailouts = eplan.code.num_bailouts()\n\n            for i in range(0, num_bailouts):\n                eplan.code.request_bailout(i)\n                self.assertEqual(jitted(x), expected)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_dominated_bailout(self):\n        with enable_profiling_mode_for_profiling_tests():\n            # functional dominated guard\n            @torch.jit.script\n            def foo(x):\n                dim = x.dim()\n                if dim == 0:\n                    y = int(x)\n                else:\n                    y = x.size()[dim - 1]\n                return y\n\n            x = torch.zeros(2)\n            self.assertEqual(foo(x), 2)\n            self.assertEqual(foo(x), 2)\n            g = torch.jit.last_executed_optimized_graph()\n            g_s = str(g)\n            g_s = g_s[0:g_s.find(\"return\")]\n            FileCheck().check_count(\"prim::BailOut[\", 1, exactly=True).run(g_s)\n\n            # dominated guard of non-functional value\n            @torch.jit.script\n            def foo(x):\n                dim = x.dim()\n                x.add_(3)\n                if dim == 0:\n                    return 0\n                else:\n                    return x.size()[dim - 1]\n\n            x = torch.zeros(2)\n            self.assertEqual(foo(x), 2)\n            self.assertEqual(foo(x), 2)\n            g = torch.jit.last_executed_optimized_graph()\n            FileCheck().check(\"prim::BailOut[\").check(\"aten::add_\").check_next(\"prim::BailOut[\").check(\"return\").run(g)\n\n            with torch.enable_grad():\n                @torch.jit.ignore\n                def disable_grad():\n                    torch.set_grad_enabled(False)\n\n                @torch.jit.ignore\n                def enable_grad():\n                    torch.set_grad_enabled(True)\n\n                @torch.jit.script\n                def foo(x):\n                    x = x + 1\n                    dim = x.dim()\n                    disable_grad()\n                    if dim == 0:\n                        y = int(x)\n                    else:\n                        y = x.size()[dim - 1]\n                    enable_grad()\n                    return y\n\n                x = torch.zeros(2, requires_grad=True)\n                self.assertEqual(foo(x), 2)\n                self.assertEqual(foo(x), 2)\n                g = torch.jit.last_executed_optimized_graph()\n                # there should still be a Bailout after disable_grad call\n                FileCheck().check(\"disable_grad\").check(\"BailOut[\").check(\"BailoutTemplate\").run(g)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_profiling_merge(self):\n        @torch.jit.script\n        def test_not_const(x):\n            if x.size(0) == 1:\n                return 1\n            else:\n                return 2\n\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(2):\n                test_not_const(torch.rand([1, 2]))\n                test_not_const(torch.rand([2, 2]))\n\n                graph_str = torch.jit.last_executed_optimized_graph()\n                FileCheck().check(\"profiled_type=Double(*, 2, strides=[2, 1], requires_grad=0, device=cpu\").run(graph_str)\n                FileCheck().check_not(\"profiled_type=Double(1, 2, strides=[2, 1], requires_grad=0, device=cpu\").run(graph_str)\n\n\n    def test_nested_bailouts(self):\n        @torch.jit.script\n        def fct_loop(x):\n            for i in range(3):\n                x = torch.cat((x, x), 0)\n            return x\n\n        x = torch.ones(2, 3, 4, dtype=torch.float32)\n        out = fct_loop(x)\n        jit_trace = torch.jit.trace(fct_loop, x)\n        out_trace = jit_trace(x)\n\n    def test_no_self_arg_ignore_function(self):\n        class MyModule(nn.Module):\n            @torch.jit.ignore  # noqa: B902\n            def call_np():  # noqa: B902\n                # type: () -> int\n                return np.random.choice(2, p=[.95, .05])\n\n            def forward(self):\n                return self.call_np()\n\n        with self.assertRaisesRegex(Exception, \"does not have a self argument\"):\n            torch.jit.script(MyModule())\n\n    def test_loop_liveness(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def f(i):\n                # type: (int) -> Tensor\n                l = []\n                for n in [2, 1]:\n                    l.append(torch.zeros(n, i))\n\n                return l[0]\n\n            f(2)\n            f(1)\n\n    def test_bailout_loop_carried_deps_name_clash(self):\n        with enable_profiling_mode_for_profiling_tests():\n            NUM_ITERATIONS = 10\n\n            @torch.jit.script\n            def fct_loop(z, size):\n                # type: (int, int) -> Tuple[Tensor, List[int]]\n                counters = torch.jit.annotate(List[int], [])\n                j = 0\n                y = torch.ones(2)\n                for i in range(size):\n                    counters.append(i + j)\n                    y = torch.cat((y, torch.ones(z)), 0)\n                    j = j + 1\n                return y, counters\n\n            inputs = [1, 2, 3, 4]\n            expected = [x * 2 for x in range(NUM_ITERATIONS)]\n            for inp in inputs:\n                results = fct_loop(inp, NUM_ITERATIONS)\n                self.assertEqual(results[1], expected)\n\n    def test_bailout_loop_counter_transition(self):\n        with enable_profiling_mode_for_profiling_tests():\n            NUM_ITERATIONS = 10\n\n            @torch.jit.script\n            def fct_loop(z, size):\n                # type: (int, int) -> Tuple[Tensor, List[int]]\n                counters = torch.jit.annotate(List[int], [])\n                y = torch.ones(2)\n                for i in range(size):\n                    counters.append(i)\n                    y = torch.cat((y, torch.ones(z)), 0)\n                return y, counters\n\n            inputs = [1, 2, 3, 4]\n            expected = list(range(NUM_ITERATIONS))\n            for inp in inputs:\n                results = fct_loop(inp, NUM_ITERATIONS)\n                self.assertEqual(results[1], expected)\n\n    def test_ignored_method_binding(self):\n        class Bar(torch.nn.Module):\n            def __init__(self):\n                super(Bar, self).__init__()\n                self.x : int = 0\n\n            @torch.jit.export\n            def setx(self, x : int):\n                self.x = x\n\n            @torch.jit.export\n            def getx(self):\n                return self.x\n\n            @torch.jit.ignore\n            def ignored_getx(self):\n                return self.x\n\n        b = Bar()\n        b.setx(123)\n        sb = torch.jit.script(b)\n        self.assertEqual(sb.getx(), 123)\n        self.assertEqual(sb.ignored_getx(), 123)\n\n        sb.setx(456)\n        self.assertEqual(sb.getx(), 456)\n        self.assertEqual(sb.ignored_getx(), 456)\n\n    def test_set_attribute_through_optional(self):\n        class A(torch.nn.Module):\n            __annotations__ = {\"x\": Optional[torch.Tensor]}\n\n            def __init__(self):\n                super(A, self).__init__()\n                self.x = None\n\n            @torch.jit.ignore\n            def foo(self):\n                if self.x is None:\n                    self.x = torch.tensor([3])\n                return self.x\n\n            def forward(self, x):\n                a = self.foo()\n                return x + 1\n\n        m = torch.jit.script(A())\n        self.assertEqual(m.x, None)\n        m(torch.rand(1))\n        self.assertEqual(m.x, torch.tensor([3]))\n\n    def test_mutate_constant(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = [\"foo\"]\n\n            def __init__(self, foo):\n                super(M, self).__init__()\n                self.foo = foo\n\n        m = M(5)\n        # m has a constant attribute, but we can't\n        # assign to it\n        with self.assertRaises(RuntimeError):\n            m.foo = 6\n\n    def test_class_attribute(self):\n        class M(torch.jit.ScriptModule):\n            FOO = 0\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.foo = self.FOO\n        m = M()\n        self.assertEqual(m.foo, M.FOO)\n\n    def test_class_attribute_in_script(self):\n        class M(torch.jit.ScriptModule):\n            FOO = 0\n\n            def __init__(self):\n                super(M, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.FOO\n        with self.assertRaises(RuntimeError):\n            M()\n\n    def test_not_initialized_err(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                self.foo = torch.rand(2, 3)\n        with self.assertRaises(RuntimeError):\n            M()\n\n    def test_attribute_in_init(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.foo = torch.jit.Attribute(0.1, float)\n                # we should be able to use self.foo as a float here\n                assert 0.0 < self.foo\n        M()\n\n    def test_scriptable_fn_as_attr(self):\n        class M(torch.nn.Module):\n            def __init__(self, fn):\n                super(M, self).__init__()\n                self.fn = fn\n\n            def forward(self, x):\n                return self.fn(x)\n\n        m = M(torch.sigmoid)\n        inp = torch.rand(2, 3)\n        self.checkModule(m, (inp, ))\n\n    def test_sequence_parsing(self):\n        tests = [\n            (\"return [x, x,]\", True),\n            (\"return [x x]\", \"expected ]\"),\n            (\"return x, x,\", True),\n            (\"return bar(x, x,)\", True),\n            (\"return bar()\", \"Argument x not provided\"),\n            (\"for a, b, in x, x,:\\n        pass\", \"List of iterables\"),\n            (\"a, b, = x, x,\\n    return a + b\", True)\n        ]\n        for exp, result in tests:\n            cu = torch.jit.CompilationUnit()\n            full = \"\"\"\ndef bar(x, y):\n    return x + y\ndef foo(x):\n    {}\n            \"\"\".format(exp)\n            if isinstance(result, str):\n                with self.assertRaisesRegex(RuntimeError, result):\n                    cu.define(full)\n            else:\n                cu.define(full)\n\n    def test_namedtuple_python(self):\n        global MyTuple, MyMod  # see [local resolution in python]\n        MyTuple = namedtuple('MyTuple', ['a'])\n\n        @torch.jit.unused\n        def fn():\n            # type: () -> MyTuple\n            return MyTuple(1)\n\n        # Only check compilation\n        @torch.jit.script\n        def fn2():\n            # type: () -> MyTuple\n            return fn()\n\n        FileCheck().check(\"NamedTuple\").run(fn2.graph)\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n\n            @torch.jit.unused\n            def fn(self):\n                # type: () -> MyTuple\n                return MyTuple(1)\n\n            def forward(self, x):\n                if 1 == 1:\n                    return MyTuple(torch.rand(2, 3))\n                else:\n                    return self.fn()\n\n        # shouldn't throw a type error\n        torch.jit.script(MyMod())\n\n    def test_unused_decorator(self):\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n\n            @torch.jit.unused\n            @torch.no_grad()\n            def fn(self, x):\n                # type: (Tensor) -> int\n                return next(x)  # invalid, but should be ignored\n\n            def forward(self, x):\n                return self.fn(x)\n\n        torch.jit.script(MyMod())\n\n    @_inline_everything\n    def test_lazy_script(self):\n        def untraceable(x):\n            if x.ndim > 2:\n                print(\"hello\")\n            else:\n                print(\"goodbye\")\n            return x + 2\n\n        # Non-working example\n        def fn(x):\n            return untraceable(x)\n\n        with self.capture_stdout():\n            traced_bad = torch.jit.trace(fn, [torch.ones(2, 2)])\n\n        FileCheck().check_not(\"goodbye\").check_not(\"hello\").run(traced_bad.graph)\n\n        # Working example\n        untraceable = torch.jit.script_if_tracing(untraceable)\n\n        def fn2(x):\n            return untraceable(x)\n\n        with self.capture_stdout():\n            traced = torch.jit.trace(fn, [torch.ones(2, 2)])\n\n        FileCheck().check(\"goodbye\").run(traced.graph)\n\n        def foo(x: int):\n            return x + 1\n\n        @torch.jit.script_if_tracing\n        def fee(x: int = 2):\n            return foo(1) + x\n\n        # test directly compiling function\n        fee_compiled = torch.jit.script(fee)\n        self.assertEqual(fee_compiled(), fee())\n\n        # test compiling it within another function\n        @torch.jit.script\n        def hum():\n            return fee(x=3)\n\n        self.assertEqual(hum(), 5)\n\n    def test_big_int_literals(self):\n        def ok():\n            # signed 64 bit max\n            a = 9223372036854775807\n            return a\n\n        def toobig():\n            a = 9223372036854775808\n            return a\n\n        def waytoobig():\n            a = 99999999999999999999\n            return a\n\n        self.checkScript(ok, [])\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(toobig)\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(waytoobig)\n\n    def test_hex_literals(self):\n        def test1():\n            return 0xaaaaaa\n\n        def test2():\n            return 0xaaaaaa\n\n        def test3():\n            return -0xaaaaaa\n\n        self.checkScript(test1, [])\n        self.checkScript(test2, [])\n        self.checkScript(test3, [])\n\n        def ok():\n            a = 0x7FFFFFFFFFFFFFFF\n            return a\n\n        def toobig():\n            a = 0xFFFFFFFFFFFFFFFF\n            return a\n\n        def waytoobig():\n            a = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            return a\n\n        self.checkScript(ok, [])\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(toobig)\n\n        with self.assertRaisesRegex(RuntimeError, \"out of range\"):\n            torch.jit.script(waytoobig)\n\n    def test_big_float_literals(self):\n        def ok():\n            # Python interprets this as inf\n            a = 1.2E400\n            return a\n\n        def check(fn):\n            self.assertTrue(fn() == ok())\n\n        # checkScript doesn't work since assertEqual doesn't consider\n        # `inf` == `inf`\n        check(torch.jit.script(ok))\n\n        cu = torch.jit.CompilationUnit()\n        cu.define(dedent(inspect.getsource(ok)))\n        check(cu.ok)\n\n    def _test_device_type(self, dest):\n        def fn(x):\n            # type: (Device) -> Tuple[str, Optional[int]]\n            return x.type, x.index\n\n        device = torch.ones(2).to(dest).device\n        self.checkScript(fn, [device])\n\n    def test_device_type(self):\n        self._test_device_type('cpu')\n\n    @unittest.skipIf(not RUN_CUDA, \"Requires CUDA\")\n    def test_device_type_cuda(self):\n        self._test_device_type('cuda')\n\n    def test_string_device_implicit_conversion(self):\n        @torch.jit.script\n        def fn(x: torch.device):\n            return x\n\n        self.assertEqual(fn(\"cpu\"), torch.device(\"cpu\"))\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected one of\"):\n            fn(\"invalid_device\")\n\n    def test_eval_python(self):\n        def _test(m):\n            self.assertTrue(m(torch.ones(2, 2)))\n            self.assertTrue(m.training)\n            self.assertTrue(m._c.getattr('training'))\n\n            m.eval()\n\n            self.assertFalse(m.training)\n            self.assertFalse(m._c.getattr('training'))\n            self.assertFalse(m(torch.ones(2, 2)))\n\n            buffer = io.BytesIO()\n            torch.jit.save(m, buffer)\n            buffer.seek(0)\n\n            loaded = torch.jit.load(buffer)\n\n            self.assertFalse(loaded.training)\n            self.assertFalse(loaded._c.getattr('training'))\n\n        class M(nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, x):\n                return self.training\n\n        class OldM(torch.jit.ScriptModule):\n            def __init__(self):\n                super(OldM, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.training\n\n        _test(torch.jit.script(M()))\n        _test(OldM())\n\n    def test_inherit_method(self):\n        class A(torch.jit.ScriptModule):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.bar(x)\n\n        class B(A):\n            def __init__(self):\n                super(B, self).__init__()\n\n            @torch.jit.script_method\n            def bar(self, x):\n                return x * x\n\n        with self.assertRaisesRegex(RuntimeError, 'attribute'):\n            A()  # cannot use because bar is not defined\n\n        v = torch.rand(3, 4)\n        b = B()\n        self.assertEqual(b(v), v + v * v)\n\n        class C(torch.jit.ScriptModule):\n            def __init__(self):\n                super(C, self).__init__()\n\n            @torch.jit.script_method\n            def bar(self, x):\n                return x\n\n        class D(C, B):\n            def __init__(self):\n                super(D, self).__init__()\n\n        self.assertEqual(D()(v), v + v)\n\n    def test_tensor_subclasses(self):\n        def check_subclass(x, tensor):\n            template = dedent(\"\"\"\n                def func(input: {}) -> {}:\n                    return torch.zeros((input.shape[0], 1), dtype=input.dtype)\n                \"\"\")\n\n            self._check_code(template.format(x, x), \"func\", [tensor])\n\n        check_subclass(\"torch.LongTensor\", torch.LongTensor([[1, 2], [3, 4]]))\n        check_subclass(\"torch.DoubleTensor\", torch.DoubleTensor([[1.2, 2.3], [3.4, 4.5]]))\n        check_subclass(\"torch.IntTensor\", torch.IntTensor([[1, 2], [3, 4]]))\n        check_subclass(\"torch.BoolTensor\", torch.BoolTensor([[False, True], [True, False]]))\n\n        def check_subclass_warn(input: torch.LongTensor) -> torch.LongTensor:\n            return torch.zeros((input.shape[0], 1), dtype=input.dtype)\n\n        with warnings.catch_warnings(record=True) as warns:\n            scripted = torch.jit.script(check_subclass_warn)\n        FileCheck().check(\"TorchScript will treat type annotations of Tensor\").run(str(warns[0]))\n\n    def test_first_class_module(self):\n        class Foo(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.foo = nn.Parameter(torch.rand(3, 4))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                self.foo = input\n                return self.foo\n        foo = Foo()\n        input = torch.rand(3, 4)\n        foo.forward(input)\n        self.assertEqual(input, foo.foo)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_first_class_calls(self):\n        @torch.jit.script\n        class Foo(object):\n            def __init__(self, x):\n                self.bar = x\n\n            def stuff(self, x):\n                return self.bar + x\n\n        @torch.jit.script\n        def foo(x):\n            return x * x + Foo(x).stuff(2 * x)\n\n        @torch.jit.script\n        def bar(x):\n            return foo(x) * foo(x)\n\n        x = torch.rand(3, 4)\n        self.assertEqual(bar(x), (x * x + 3 * x) * (x * x + 3 * x))\n\n    def test_static_methods(self):\n        class M(nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            @staticmethod\n            def my_method(x):\n                return x + 100\n\n            def forward(self, x):\n                return x + M.my_method(x)\n\n        class N(nn.Module):\n            def __init__(self):\n                super(N, self).__init__()\n\n            @staticmethod\n            def my_method(x):\n                return x * 100\n\n            def forward(self, x):\n                return x - M.my_method(x) + N.my_method(x)\n\n        self.checkModule(M(), (torch.ones(2, 2),))\n\n        self.checkModule(N(), (torch.ones(2, 2),))\n\n    def test_invalid_prefix_annotation(self):\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation1(a):\n                    #type: (Int) -> Int # noqa: E265\n                    return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation2(a):\n                    #type   : (Int) -> Int # noqa: E265\n                    return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, \"annotation prefix in line\"):\n            with self.capture_stdout() as captured:\n                @torch.jit.script\n                def invalid_prefix_annotation3(a):\n                    #     type: (Int) -> Int\n                    return a + 2\n\n    def test_builtin_function_attributes(self):\n        class Add(nn.Module):\n            def __init__(self):\n                super(Add, self).__init__()\n                self.add = torch.add\n\n            def forward(self, input):\n                return self.add(input, input)\n\n        self.checkModule(Add(), [torch.randn(2, 2)])\n\n    def test_pybind_type_comparisons(self):\n        @torch.jit.script\n        def f():\n            return None\n\n        node = list(f.graph.nodes())[0]\n        t = node.outputsAt(0).type()\n        self.assertIsNotNone(t)\n\n    @unittest.skipIf(IS_WINDOWS and sys.version_info >= (3, 8), 'TODO: need to fix the test case')\n    def test_unmatched_type_annotation(self):\n        message1 = re.escape(\"Number of type annotations (2) did not match the number of function parameters (1):\")\n        message2 = 'def invalid2\\\\(a\\\\):\\n\\\\s*~+\\\\.*\\\\s+<--- HERE\\n\\\\s+# type: \\\\(Int, Int\\\\) -> Int\\n\\\\s+return a \\\\+ 2'\n        message3 = 'def invalid4\\\\(a\\\\):\\n\\\\s*~+\\\\.*\\\\s+<--- HERE\\n\\\\s+# type: \\\\(Int, Int\\\\) -> Int\\n\\\\s+return a \\\\+ 2'\n        with self.assertRaisesRegex(RuntimeError, message1):\n            @torch.jit.script\n            def invalid1(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, message2):\n            @torch.jit.script\n            def invalid2(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n\n        with self.assertRaisesRegex(RuntimeError, message1):\n            def invalid3(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n            torch.jit.script(invalid3)\n\n        with self.assertRaisesRegex(RuntimeError, message3):\n            def invalid4(a):\n                # type: (Int, Int) -> Int\n                return a + 2\n            torch.jit.script(invalid4)\n\n    def test_calls_in_type_annotations(self):\n        with self.assertRaisesRegex(RuntimeError, \"Type annotation should not contain calls\"):\n            def spooky(a):\n                # type: print(\"Hello\") -> Tensor # noqa: F723\n                return a + 2\n            print(torch.__file__)\n            torch.jit.annotations.get_signature(spooky, None, 1, True)\n\n    def test_is_optional(self):\n        ann = Union[List[int], List[float]]\n        torch._jit_internal.is_optional(ann)\n\n    def test_interpreter_fuzz(self):\n        import builtins\n        # This test generates random tree-like programs to fuzz test\n        # that the interpreter does not have a bug in its stack manipulation\n        # code. An assert in that code ensures individual operators are\n        # not reordered.\n        templates = [\n            \"torch.rand(3, 4)\",\n            \"({} + {})\",\n            \"-{}\",\n            \"({} * {})\",\n            \"torch.tanh({})\",\n            \"VAR {}\",\n        ]\n\n        def gen_code():\n            src_lines = ['def f():']\n            exprs = []\n            n_variables = 0\n\n            def get_expr(idx):\n                elem = exprs[idx]\n                exprs[idx] = exprs[-1]\n                exprs.pop()\n                return elem\n\n            def select_expr_or_var():\n                idx = random.randrange(0, len(exprs) + n_variables)\n                if idx < len(exprs):\n                    return get_expr(idx)\n                else:\n                    return 'v{}'.format(idx - len(exprs))\n\n            for i in range(50):\n                n = None\n                while n is None or n > len(exprs) + n_variables:\n                    template = random.choice(templates)\n                    n = template.count('{}')\n\n                if 'VAR' in template:\n                    src_lines.append('  v{} = {}'.format(n_variables, select_expr_or_var()))\n                    n_variables += 1\n                else:\n                    exprs.append(template.format(*(select_expr_or_var() for _ in range(n))))\n\n            src_lines.append('  return ({})\\n'.format(''.join('v{},'.format(i) for i in range(n_variables))))\n            return '\\n'.join(src_lines)\n\n        for i in range(100):\n            g = {'torch': torch}\n            code = gen_code()\n            builtins.exec(code, g, None)\n            cu = torch.jit.CompilationUnit(code)\n            with freeze_rng_state():\n                o1 = g['f']()\n            with freeze_rng_state():\n                o2 = cu.f()\n            self.assertEqual(o1, o2)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_cpp_module_iterator(self):\n        a = nn.Module()\n        a.name = 'a'\n        a.p = nn.Parameter(torch.rand(3, 4))\n        a.foo = nn.Module()\n        a.foo.name = 'foo'\n        a.foo.register_buffer('b', torch.rand(1, 1))\n        a.foo.bar = nn.Module()\n        a.foo.bar.name = 'bar'\n        a.foo.bar.an_int = 4\n        a.another = nn.Module()\n        a.another.name = 'another'\n        sa = torch.jit.script(a)\n        result = torch._C._jit_debug_module_iterators(sa._c)\n\n        def replace(e):\n            if e is a.p:\n                return 'P'\n            elif e is a.foo.b:\n                return 'B'\n            elif isinstance(e, torch._C.ScriptModule):\n                return e.getattr('name')\n\n            return e\n        for k, v in result.items():\n            for i in range(len(v)):\n                if isinstance(v[i], tuple):\n                    n, v2 = v[i]\n                    v[i] = (n, replace(v2))\n                else:\n                    v[i] = replace(v[i])\n            # module type creation is not deterministic, so we have to sort\n            # the result\n            v.sort()\n        expected = {'buffers': [],\n                    'buffers_r': ['B'],\n                    'children': ['another', 'foo'],\n                    'modules': ['a', 'another', 'bar', 'foo'],\n                    'named_attributes': [('_is_full_backward_hook', None),\n                                         ('another', 'another'),\n                                         ('foo', 'foo'),\n                                         ('name', 'a'),\n                                         ('p', 'P'),\n                                         ('training', True)],\n                    'named_attributes_r': [('_is_full_backward_hook', None),\n                                           ('another', 'another'),\n                                           ('another._is_full_backward_hook', None),\n                                           ('another.name', 'another'),\n                                           ('another.training', True),\n                                           ('foo', 'foo'),\n                                           ('foo._is_full_backward_hook', None),\n                                           ('foo.b', 'B'),\n                                           ('foo.bar', 'bar'),\n                                           ('foo.bar._is_full_backward_hook', None),\n                                           ('foo.bar.an_int', 4),\n                                           ('foo.bar.name', 'bar'),\n                                           ('foo.bar.training', True),\n                                           ('foo.name', 'foo'),\n                                           ('foo.training', True),\n                                           ('name', 'a'),\n                                           ('p', 'P'),\n                                           ('training', True)],\n                    'named_buffers': [],\n                    'named_buffers_r': [('foo.b', 'B')],\n                    'named_children': [('another', 'another'), ('foo', 'foo')],\n                    'named_modules': [('', 'a'),\n                                      ('another', 'another'),\n                                      ('foo', 'foo'),\n                                      ('foo.bar', 'bar')],\n                    'named_parameters': [('p', 'P')],\n                    'named_parameters_r': [('p', 'P')],\n                    'parameters': ['P'],\n                    'parameters_r': ['P']}\n        self.assertEqual(expected, result)\n\n    def test_parameter_order(self):\n        m = nn.Module()\n        for i, name in enumerate(string.ascii_letters):\n            setattr(m, name, nn.Parameter(torch.tensor([float(i)])))\n        ms = torch.jit.script(m)\n        print(torch.cat(list(m.parameters())))\n        print(torch.cat(list(ms.parameters())))\n        self.assertEqual(list(m.parameters()), list(ms.parameters()))\n\n    def test_python_op_builtins(self):\n        @torch.jit.unused\n        def fn(x):\n            # type: (List[int]) -> int\n            return sum(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            # type: (List[int]) -> int\n            return fn(x)\n\n    def test_submodule_twice(self):\n        @torch.jit.script\n        def foo(x):\n            return x * x\n\n        class What(torch.jit.ScriptModule):\n            def __init__(self, x):\n                super(What, self).__init__()\n                self.foo = x\n        a = What(foo)\n        c = What(foo)\n\n    def test_training_param(self):\n        class What(torch.jit.ScriptModule):\n            def __init__(self):\n                super(What, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (int) -> int\n                if self.training:\n                    r = x\n                else:\n                    r = x + 4\n                # check double use of training\n                if self.training:\n                    r = r + 1\n                return r\n\n        w = What()\n        self.assertEqual(4, w(3))\n        w.train(False)\n        self.assertEqual(7, w(3))\n        self.assertFalse(\"training\" in w.state_dict())\n\n    def test_class_as_attribute(self):\n        @torch.jit.script\n        class Foo321(object):\n            def __init__(self):\n                self.x = 3\n\n        class FooBar1234(torch.nn.Module):\n            def __init__(self):\n                super(FooBar1234, self).__init__()\n                self.f = Foo321()\n\n            def forward(self, x):\n                return x + self.f.x\n\n        scripted = torch.jit.script(FooBar1234())\n        eic = self.getExportImportCopy(scripted)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted(x), eic(x))\n\n    def test_module_str(self):\n        class Foo(torch.nn.Module):\n            def forward(self, x):\n                return torch.relu(x)\n\n        f = torch.jit.script(Foo())\n        self.assertEqual('ScriptObject', str(f._c))\n\n    def test_jitter_bug(self):\n        @torch.jit.script\n        def fn2(input, kernel_size):\n            # type: (Tensor, List[int]) -> Tensor\n            if kernel_size[0] > 1:\n                _stride = [2]\n            else:\n                _stride = kernel_size\n            print(_stride, kernel_size)\n            return input\n\n        @torch.jit.script\n        def fn(input):\n            # type: (Tensor) -> Tensor\n            return fn2(input, [1])\n\n    def test_parser_kwargonly(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x, *, y) -> Tuple[Tensor, Tensor]:\n                return x, x\n            def bar(x):\n                return foo(x, y=x)\n        ''')\n        self.assertTrue('*' in str(cu.foo.schema))\n        with self.assertRaisesRegex(RuntimeError, \"not provided\"):\n            torch.jit.CompilationUnit('''\n                def foo(x, *, y) -> Tuple[Tensor, Tensor]:\n                    return x, x\n                def bar(x):\n                    return foo(x, x)\n            ''')\n\n    def test_annoying_doubles(self):\n        mod = types.ModuleType(\"temp\")\n        mod.inf = float(\"inf\")\n        mod.ninf = float(\"-inf\")\n        mod.nan = float(\"nan\")\n\n        with torch._jit_internal._disable_emit_hooks():\n            class Foo(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(Foo, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self):\n                    return math.pi, 0.1, mod.inf, mod.ninf, 2.225073858507201e-308, mod.nan\n\n            foo = Foo()\n            buffer = io.BytesIO()\n            torch.jit.save(foo, buffer)\n\n            buffer.seek(0)\n            foo_loaded = torch.jit.load(buffer)\n\n            r = foo()\n            r2 = foo_loaded()\n            # use precise assert, we are checking floating point details\n            self.assertTrue(r[:-1] == r2[:-1])\n            self.assertTrue(math.isnan(r[-1]) and math.isnan(r2[-1]))\n\n    def test_type_annotate(self):\n\n        def foo(a):\n            return torch.jit.annotate(torch.Tensor, a)\n\n        self.checkScript(foo, (torch.rand(3),))\n\n        def bar():\n            a = torch.jit.annotate(List[int], [])\n            for _ in range(10):\n                a.append(4)\n            return a\n\n        self.checkScript(bar, ())\n\n        def baz(a):\n            return torch.jit.annotate(float, a)\n        self.checkScript(baz, (torch.rand(()),))\n\n        # test annotate none types\n        def annotate_none():\n            return torch.jit.annotate(Optional[torch.Tensor], None)\n\n        self.checkScript(annotate_none, ())\n\n\n    def test_robust_op_resolution(self):\n        neg = torch.add  # misleading name to make sure we resolve by function\n\n        def stuff(x):\n            return neg(x, x)\n\n        a = (torch.rand(3),)\n        self.checkScript(stuff, a)\n\n    def test_nested_aug_assign(self):\n        @torch.jit.script\n        class SomeClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __iadd__(self, x):\n                # type: (int)\n                self.num += x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        @torch.jit.script\n        class SomeOutOfPlaceClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __add__(self, x):\n                # type: (int)\n                self.num = x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        class Child(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.x = 2\n                self.o = SomeClass()\n                self.oop = SomeOutOfPlaceClass()\n                self.list = [1, 2, 3]\n\n        class A(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.child = Child()\n\n            def forward(self):\n                self.child.x += 1\n                self.child.o += 5\n                self.child.oop += 5\n                some_list = [1, 2]\n                self.child.list += some_list\n                self.child.list *= 2\n                return self.child.x, self.child.o, self.child.list, self.child.oop\n\n        a = A()\n        sa = torch.jit.script(A())\n        eager_result = a()\n        script_result = sa()\n        self.assertEqual(eager_result, script_result)\n        self.assertEqual(a.child.x, sa.child.x)\n        self.assertEqual(a.child.o, sa.child.o)\n        self.assertEqual(a.child.list, sa.child.list)\n\n        @torch.jit.script\n        class SomeNonAddableClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        # with self.assertRaisesRegex(RuntimeError, \"\")\n        class A(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.x = SomeNonAddableClass()\n\n            def forward(self):\n                self.x += SomeNonAddableClass()\n                return self.x\n\n        with self.assertRaisesRegex(RuntimeError, \"Cannot emit inplace op\"):\n            torch.jit.script(A())\n\n    def test_var_aug_assign(self):\n        @torch.jit.script\n        class SomeNonAddableClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __eq__(self, other):\n                # type: (SomeNonAddableClass) -> bool\n                return self.num == other.num\n\n        with self.assertRaisesRegex(RuntimeError, \"Cannot emit inplace op\"):\n            @torch.jit.script\n            def fn():\n                a = SomeNonAddableClass()\n                a += SomeNonAddableClass()\n                return a\n\n        @torch.jit.script\n        class SomeClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __iadd__(self, x):\n                # type: (int)\n                self.num += x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        @torch.jit.script\n        class SomeOutOfPlaceClass(object):\n            def __init__(self):\n                self.num = 99\n\n            def __add__(self, x):\n                # type: (int)\n                self.num = x\n                return self\n\n            def __eq__(self, other):\n                # type: (SomeClass) -> bool\n                return self.num == other.num\n\n        def fn2():\n            a = SomeClass()\n            a_copy = a\n            a += 20\n            assert a is a_copy\n            b = SomeOutOfPlaceClass()\n            b_copy = b\n            b += 99\n            assert b is b_copy\n            c = [1, 2, 3]\n            c_copy = c\n            c *= 2\n            assert c is c_copy\n            c += [4, 5, 6]\n            d = torch.ones(2, 2)\n            d_copy = d\n            d += torch.ones(2, 2)\n            assert d is d_copy\n            return a, b, c, d\n\n        self.checkScript(fn2, [])\n\n    def test_nested_list_construct(self):\n        def foo():\n            return [[4]] + [[4, 5]]\n        self.checkScript(foo, ())\n\n    def test_file_line_error(self):\n        def foobar(xyz):\n            return torch.blargh(xyz)\n\n        _, lineno = inspect.getsourcelines(foobar)\n        with self.assertRaisesRegex(RuntimeError, \"test_jit.py\\\", line {}\".format(lineno + 1)):\n            scripted = torch.jit.script(foobar)\n\n    def test_file_line_error_class_defn(self):\n        class FooBar(object):\n            def baz(self, xyz):\n                return torch.blargh(xyz)\n\n        _, lineno = inspect.getsourcelines(FooBar)\n        with self.assertRaisesRegex(RuntimeError, \"test_jit.py\\\", line {}\".format(lineno + 2)):\n            torch.jit.script(FooBar)\n\n    def test_file_line_graph(self):\n        def foobar(xyz):\n            return torch.neg(xyz)\n\n        scripted = torch.jit.script(foobar)\n\n        _, lineno = inspect.getsourcelines(foobar)\n        fc = FileCheck().check('test_jit.py:{}:19'.format(lineno + 1))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_file_line_save_load(self):\n        class Scripted(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, xyz):\n                return torch.neg(xyz)\n\n        scripted = Scripted()\n\n        # NB: not using getExportImportCopy because that takes a different\n        # code path that calls CompilationUnit._import rather than\n        # going through the full save/load pathway\n        buffer = scripted.save_to_buffer()\n        bytesio = io.BytesIO(buffer)\n        scripted = torch.jit.load(bytesio)\n\n        _, lineno = inspect.getsourcelines(Scripted)\n        fc = FileCheck().check(':{}'.format(lineno + 3))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_file_line_string(self):\n        scripted = torch.jit.CompilationUnit('''\ndef foo(xyz):\n    return torch.neg(xyz)\n        ''')\n\n        fc = FileCheck().check('<string>:3:11')\n        fc.run(scripted.foo.graph)\n        fc.run(str(scripted.foo.graph))\n\n    @skipIfCrossRef\n    def test_file_line_trace(self):\n        def foobar(xyz):\n            return torch.neg(xyz)\n\n        scripted = torch.jit.trace(foobar, (torch.rand(3, 4)))\n\n        _, lineno = inspect.getsourcelines(foobar)\n        fc = FileCheck().check('test_jit.py:{}:0'.format(lineno + 1))\n        fc.run(scripted.graph)\n        fc.run(str(scripted.graph))\n\n    def test_serialized_source_ranges(self):\n\n        class FooTest(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, w):\n                return torch.mm(x, w.t())\n\n        ft = FooTest()\n        loaded = self.getExportImportCopy(ft)\n        _, lineno = inspect.getsourcelines(FooTest)\n\n        with self.assertRaisesRegex(RuntimeError, 'test_jit.py\\\", line {}'.format(lineno + 3)):\n            loaded(torch.rand(3, 4), torch.rand(30, 40))\n\n    def test_serialized_source_ranges_graph(self):\n\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, w):\n                return torch.mm(x, w.t())\n\n        ft = FooTest3()\n        loaded = self.getExportImportCopy(ft)\n        _, lineno = inspect.getsourcelines(FooTest3)\n\n        fc = FileCheck().check('test_jit.py:{}'.format(lineno + 3))\n        fc.run(loaded.graph)\n\n    def test_serialized_source_ranges2(self):\n\n        class FooTest2(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self):\n                raise RuntimeError('foo')\n\n        _, lineno = inspect.getsourcelines(FooTest2)\n\n        with self.assertRaisesRegex(torch.jit.Error, 'test_jit.py\\\", line {}'.format(lineno + 3)):\n            ft = FooTest2()\n            loaded = self.getExportImportCopy(ft)\n            loaded()\n\n    def test_serialized_source_ranges_dont_jitter(self):\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, lim):\n                first = 1\n                second = 1\n                i = 1\n                somenum = 5\n                dontmutateme = 3\n                third = 0\n                while bool(i < lim):\n                    third = first + second\n                    first = second\n                    second = third\n                    j = 0\n                    while j < 10:\n                        somenum = somenum * 2\n                        j = j + 1\n                    i = i + j\n                    i = i + dontmutateme\n\n                st = second + third\n                fs = first + second\n                return third, st, fs\n\n        ft3 = FooTest3()\n\n        def debug_records_from_mod(self, mod):\n            buffer = io.BytesIO()\n            torch.jit.save(ft3, buffer)\n            buffer.seek(0)\n            archive = zipfile.ZipFile(buffer)\n            files = filter(lambda x: x.startswith('archive/code/'), archive.namelist())\n            debug_files = list(filter(lambda f: f.endswith('.debug_pkl'), files))\n            self.assertEqual(len(debug_files), 1)\n            debug_file = archive.open(debug_files[0])\n            return pickle.load(debug_file), buffer\n\n        records1, buffer = debug_records_from_mod(self, ft3)\n\n        buffer.seek(0)\n        loaded = torch.jit.load(buffer)\n        records2, buffer = debug_records_from_mod(self, loaded)\n\n        buffer.seek(0)\n        loaded2 = torch.jit.load(buffer)\n        records3, _ = debug_records_from_mod(self, loaded2)\n\n        self.assertEqual(records1, records2)\n        self.assertEqual(records2, records3)\n\n    def test_serialized_source_ranges_no_dups(self):\n        class FooTest3(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, lim):\n                first = 1\n                second = 1\n                i = 1\n                somenum = 5\n                dontmutateme = 3\n                third = 0\n                while bool(i < lim):\n                    third = first + second\n                    first = second\n                    second = third\n                    j = 0\n                    while j < 10:\n                        somenum = somenum * 2\n                        j = j + 1\n                    i = i + j\n                    i = i + dontmutateme\n\n                st = second + third\n                fs = first + second\n                return third, st, fs\n\n        ft3 = FooTest3()\n\n        def debug_records_from_mod(mod):\n            buffer = io.BytesIO()\n            torch.jit.save(ft3, buffer)\n            buffer.seek(0)\n            archive = zipfile.ZipFile(buffer)\n            files = list(filter(lambda x: x.startswith('archive/code/'), archive.namelist()))\n            debug_files = filter(lambda f: f.endswith('.debug_pkl'), files)\n            debug_files = (archive.open(f) for f in debug_files)\n            debug_files = (pickle.load(f) for f in debug_files)\n            debug_files = (f[2] for f in debug_files)\n            return list(debug_files)\n\n        debug_files = debug_records_from_mod(ft3)\n        for debug_file in debug_files:\n            for i in range(len(debug_file) - 1):\n                offset, source_range_tag, source_range = debug_file[i]\n                offset2, source_range_tag2, source_range2 = debug_file[i + 1]\n                self.assertNotEqual(source_range, source_range2)\n\n    def test_circular_dependency(self):\n        \"\"\"\n        https://github.com/pytorch/pytorch/issues/25871\n        \"\"\"\n        class A(torch.jit.ScriptModule):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x\n\n        class B(torch.jit.ScriptModule):\n            def __init__(self):\n                super(B, self).__init__()\n                self.foo = torch.nn.ModuleList([A()])\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for f in self.foo:\n                    x = f(x)\n                return x\n\n        class C(torch.jit.ScriptModule):\n            def __init__(self):\n                super(C, self).__init__()\n                self.foo = torch.nn.Sequential(B())\n\n            @torch.jit.script_method\n            def forward(self, x):\n                for f in self.foo:\n                    x = f(x)\n                return x\n        self.getExportImportCopy(C())\n\n    def test_serialize_long_lines(self):\n        class OrderModuleLong(torch.nn.Module):\n            def forward(self, long_arg_name: List[torch.Tensor]):\n                return [(long_arg_name[1],), (long_arg_name[0].argmax(),)]\n        src = str(torch.jit.script(OrderModuleLong()).code)\n        # make long_arg_name[1] does not get reordered after the argmax\n        FileCheck().check(\"long_arg_name[1]\").check(\"argmax\").run(src)\n\n    def test_tensor_shape(self):\n        x = torch.empty(34, 56, 78)\n\n        def f(x):\n            return x.shape\n\n        self.checkScript(f, (x,))\n\n\n    def test_block_input_grad_in_loop(self):\n\n        x = torch.randn(3, 3, requires_grad=False)\n        y = torch.randn(3, 3, requires_grad=True)\n\n        def grad_in_loop(x, y):\n            for i in range(100):\n                x = y @ x\n            return x\n\n        scripted = torch.jit.script(grad_in_loop)\n        outer = scripted.graph_for(x, y)\n        loop = outer.findNode(\"prim::Loop\")\n        loop_block = next(loop.blocks())\n        param_node = loop_block.paramNode()\n        x_value = list(param_node.outputs())[1]\n        self.assertTrue(x_value.requires_grad())\n\n    def test_tensor_grad(self):\n        x = torch.randn(3, 4, requires_grad=True)\n        y = torch.randn(3, 4, requires_grad=False)\n\n        def f_requires_grad(x):\n            return x.requires_grad\n\n        self.checkScript(f_requires_grad, (x,))\n        self.checkScript(f_requires_grad, (y,))\n\n        def f_grad(x):\n            return x.grad\n\n        x.sum().backward()\n        self.checkScript(f_grad, (x,))\n        self.checkScript(f_grad, (y,))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"shape analysis is only enabled in Legacy\")\n    def test_prim_grad_undefined(self):\n\n        x = torch.ones(2)\n\n        def f_grad(x):\n            return x.grad\n\n        scripted = self.checkScript(f_grad, (x,))\n        g = scripted.graph_for(x)\n\n        prim_grad_node = g.findNode(\"prim::grad\")\n        self.assertTrue(next(prim_grad_node.outputs()).type().undefined() is None)\n\n    def test_tensor_data(self):\n        x = torch.randn(3, 4, requires_grad=True)\n        y = torch.randn(4, 5)\n\n        def f_data(x):\n            return x.data\n\n        scripted_f_data = torch.jit.script(f_data)\n\n        scripted_x = scripted_f_data(x)\n        self.assertEqual(scripted_x, f_data(x))\n        self.assertEqual(scripted_x.requires_grad, False)\n\n        scripted_y = scripted_f_data(y)\n        self.assertEqual(scripted_y, f_data(y))\n        self.assertEqual(scripted_x.requires_grad, False)\n\n    def test_tensor_dtype(self):\n        x_byte = torch.empty(34, 56, 78, dtype=torch.uint8)\n        x_long = torch.empty(34, 56, 78, dtype=torch.long)\n        x_float32 = torch.empty(34, 56, 78, dtype=torch.float32)\n\n        @torch.jit.script\n        def byte(x):\n            return x.dtype == torch.uint8\n\n        @torch.jit.script\n        def long(x):\n            return x.dtype == torch.long\n\n        @torch.jit.script\n        def float32(x):\n            return x.dtype == torch.float32\n\n        self.assertTrue(byte(x_byte))\n        self.assertFalse(byte(x_long))\n        self.assertFalse(byte(x_float32))\n        self.assertFalse(long(x_byte))\n        self.assertTrue(long(x_long))\n        self.assertFalse(long(x_float32))\n        self.assertFalse(float32(x_byte))\n        self.assertFalse(float32(x_long))\n        self.assertTrue(float32(x_float32))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_device(self):\n        cpu = torch.empty(34, 56, 78, device='cpu')\n        gpu = torch.empty(34, 56, 78, device='cuda')\n\n        @torch.jit.script\n        def same_device(x, y):\n            return x.device == y.device\n\n        self.assertTrue(same_device(cpu, cpu))\n        self.assertTrue(same_device(gpu, gpu))\n        self.assertFalse(same_device(cpu, gpu))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_to_device(self):\n        def to_device(x):\n            return x.to(device=\"cuda\").to(device=torch.device(\"cpu\"))\n\n        self.checkScript(to_device, (torch.ones(3, 4),))\n\n    def test_tensor_to_cpu(self):\n        def to_cpu(x):\n            return x.cpu()\n\n        x = torch.ones(3, 4)\n        script_fn = torch.jit.script(to_cpu)\n        self.assertEqual(to_cpu(x).device, script_fn(x).device)\n        self.checkScript(to_cpu, (x,))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_tensor_to_cuda(self):\n        def to_cuda(x):\n            return x.cuda()\n\n        x = torch.ones(3, 4)\n        script_fn = torch.jit.script(to_cuda)\n        self.assertEqual(to_cuda(x).device, script_fn(x).device)\n        self.checkScript(to_cuda, (x,))\n\n    def test_generic_list_errors(self):\n        with self.assertRaisesRegex(RuntimeError, \"previously matched to type\"):\n            @torch.jit.script\n            def foo(x):\n                return [[x]] + [[1]]\n\n    def test_script_cu(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                b = a\n                return b\n        ''')\n        a = Variable(torch.rand(1))\n        self.assertEqual(a, cu.foo(a))\n\n    # because the compilation unit ingests python strings\n    # to use an escape sequence escape the backslash (\\\\n = \\n)\n    def test_string_cu(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(a):\n                print(a, \"\"\"a\\\\n\\tb\\\\n\"\"\", 2, \"a\\\na\")\n                return a\n        ''')\n        FileCheck().check(\"aa\").check(\"a\\\\n\\\\tb\\\\n\").run(str(cu.foo.graph))\n\n    def test_function_compilation_caching(self):\n        def fun():\n            return 1 + 2\n\n        fun_compiled = torch.jit.script(fun)\n        # python wrapper around the script function is a different pointer,\n        # but the underlying script function graph is the same\n        self.assertIs(fun_compiled.graph, torch.jit.script(fun).graph)\n\n        def fun():\n            return 3 + 4\n\n        num_ref_counts = sys.getrefcount(fun)\n\n        # caching doesn't get tripped up by same qualname\n        fun_compiled_2 = torch.jit.script(fun)\n        self.assertIsNot(fun_compiled, fun_compiled_2)\n        self.assertEqual(fun_compiled_2(), 7)\n\n        # caching doesnt increase refcounts to function (holds weak reference)\n        self.assertTrue(sys.getrefcount(fun), num_ref_counts)\n\n    def test_string_ops(self):\n        def foo():\n            a = \"a\" + \"b\"\n            return a + a, \"ab\" == \"b\", \"ab\" != \"b\", \"ab\" == \"ab\", \"ab\" != \"ab\"\n\n        self.checkScript(foo, ())\n\n    def test_string_sorted(self):\n        def foo(strs: List[str]):\n            return sorted(strs)\n\n        FileCheck() \\\n            .check(\"graph\") \\\n            .check_next(\"str[] = aten::sorted\") \\\n            .check_next(\"return\") \\\n            .run(str(torch.jit.script(foo).graph))\n\n        inputs = [\"str3\", \"str2\", \"str1\"]\n        self.checkScript(foo, (inputs,))\n\n    def test_string_sort(self):\n        def foo(strs: List[str]):\n            strs.sort()\n            return strs\n\n        inputs = [\"str3\", \"str2\", \"str1\"]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sorted(self):\n        def foo(tups: List[Tuple[int, int]]):\n            return sorted(tups)\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sort(self):\n        def foo(tups: List[Tuple[int, int]]):\n            tups.sort()\n            return tups\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_sort_reverse(self):\n        def foo(tups: List[Tuple[int, int]]):\n            tups.sort(reverse=True)\n            return tups\n\n        inputs = [(1, 2), (0, 2), (1, 3)]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_unsortable_element_type(self):\n        @torch.jit.script\n        def foo():\n            tups = [({1: 2}, {2: 3})]\n            tups.sort()\n            return tups\n\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"are not sortable\", \"tups.sort\"):\n            foo()\n\n    def test_tuple_unsortable_diff_type(self):\n        @torch.jit.script\n        def foo(inputs: List[Any]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, 2), (\"foo\", \"bar\")]\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Only values of same type can be compared\", \"inputs.sort\"):\n            foo(inputs)\n\n    def test_tuple_nested_sort(self):\n        def foo(inputs: List[Tuple[int, Tuple[int, str]]]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, (2, \"foo\")), (1, (2, \"bar\")), (1, (0, \"bar\"))]\n        self.checkScript(foo, (inputs,))\n\n    def test_tuple_unsortable_nested_diff_type(self):\n        @torch.jit.script\n        def foo(inputs: List[Any]):\n            inputs.sort()\n            return inputs\n\n        inputs = [(1, (2, 3)), (2, (\"foo\", \"bar\"))]\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Only values of same type can be compared\", \"inputs.sort\"):\n            foo(inputs)\n\n    def test_string_new_line(self):\n        with self.assertRaisesRegex(RuntimeError, \"expected a valid token*\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a):\n                print(\"\n                    a\")\n                return a\n            ''')\n\n    def test_string_single_escape(self):\n        with self.assertRaisesRegex(RuntimeError, \"expected a valid token*\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a):\n                print(\"\\\\\")\n                return a\n            ''')\n\n    def test_script_annotation(self):\n        @torch.jit.script\n        def foo(a):\n            return a + a + a\n        s = Variable(torch.rand(2))\n        self.assertEqual(s + s + s, foo(s))\n\n    def test_torch_pow(self):\n        def func(a, b):\n            return pow(a, b)\n\n        def func2(a, b, c, d):\n            return pow(pow(c + a, b), d)\n\n        def func3(a : int, b : float):\n            # type: (int, float) -> float\n            return pow(a, b)\n\n        def func4():\n            # type: () -> float\n            return pow(2, -2)\n\n        def func5(x, y):\n            return pow(x.item(), y.item())\n\n        def func6(a : int, b : int):\n            # type: (int, int) -> float\n            return pow(a, b)\n\n        a = torch.rand(1)\n        b = torch.rand(1)\n        c = torch.rand(1)\n        d = torch.rand(1)\n        self.checkScript(func, (a, b))\n        self.checkScript(func2, (a, b, c, d))\n        self.checkScript(func3, (4, -0.5))\n        self.checkScript(func4, ())\n        self.checkScript(func6, (2, 4))\n\n        inputs = [torch.tensor(2), torch.tensor(-2), torch.tensor(.5), torch.tensor(.2)]\n        for x in inputs:\n            for y in inputs:\n                if x < 0:\n                    continue\n                else:\n                    self.checkScript(func5, (x, y))\n\n    @unittest.skipIf(not RUN_CUDA, \"device tests require CUDA\")\n    def test_pow_scalar_backward_cuda(self):\n        # see that scalar exponent works with cuda base (#19253)\n        with enable_profiling_mode_for_profiling_tests():\n            for dtype in [torch.float, torch.double]:\n                @torch.jit.script\n                def func(a, b):\n                    # type: (Tensor, float) -> Tensor\n                    return (a * 2) ** b\n\n                a = torch.rand(1, requires_grad=True, device='cuda', dtype=dtype)\n                func(a, 1, profile_and_replay=True).backward()\n\n                @torch.jit.script\n                def func(a, b):\n                    # type: (float, Tensor) -> Tensor\n                    return a ** (b * 2 + 1)\n\n                a = torch.rand(1, requires_grad=True, device='cuda', dtype=dtype)\n                func(2, a, profile_and_replay=True).backward()\n\n    def _check_code(self, code_str, fn_name, inputs):\n        scope = {}\n        exec(code_str, globals(), scope)\n        cu = torch.jit.CompilationUnit(code_str)\n        self.assertEqual(cu.func(*inputs), scope[fn_name](*inputs))\n\n    @unittest.skipIf(not RUN_CUDA, 'no CUDA')\n    def test_scriptmodule_releases_tensors_cuda(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def fn(x, y):\n                return x.sigmoid() * y.tanh()\n\n            def test(backward=False):\n                x = torch.randn(3, 3, dtype=torch.double, device='cuda', requires_grad=True)\n                y = torch.randn(3, 3, dtype=torch.double, device='cuda', requires_grad=True)\n                out = fn(x, y, profile_and_replay=True)\n                if backward:\n                    out.sum().backward()\n\n            with self.assertLeaksNoCudaTensors():\n                test()\n                test()\n                test()\n\n            if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                with self.assertLeaksNoCudaTensors():\n                    test(backward=True)\n                    test(backward=True)\n                    test(backward=True)\n\n    def test_index(self):\n        def consec(size, start=0):\n            numel = torch.tensor(size).prod().item()\n            return torch.arange(numel).view(size)\n\n        def consec_list(size):\n            return list(range(size))\n\n        def random_string(size):\n            letters = string.ascii_lowercase\n            return \"\".join(random.choice(letters) for i in range(size))\n\n        def check_indexing(indexing, tensor):\n            template = dedent(\"\"\"\n            def func(x):\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [tensor])\n\n        def check_dynamic_indexing(indexing, tensor, value1, value2):\n            value1 = torch.tensor(value1)\n            value2 = torch.tensor(value2)\n\n            template = dedent(\"\"\"\n            def func(x, value1, value2):\n                i = int(value1)\n                j = int(value2)\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [tensor, value1, value2])\n\n        # Torchscript assumes type Tensor by default, so we need this explicit\n        # declaration.\n        def check_indexing_list_int(indexing, list):\n            template = dedent(\"\"\"\n            def func(x):\n                # type: (List[int]) -> Any\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [list])\n\n        def check_indexing_str(indexing, str):\n            template = dedent(\"\"\"\n            def func(x):\n                # type: (str) -> Any\n                return x{}\n            \"\"\")\n\n            self._check_code(template.format(indexing), \"func\", [str])\n\n        # basic slices\n        check_indexing('[0]', consec((3, 3)))\n        check_indexing('[1]', consec((3, 3), 10))\n        check_indexing('[2]', consec((3, 3), 19))\n        check_indexing('[2]', consec((3,)))\n        check_indexing('[-1]', consec((3, 3), 19))\n        check_indexing('[0:2]', consec((3, 3, 3)))\n        check_indexing('[1:-1]', consec((3, 3, 3)))\n        check_indexing('[-3:-1]', consec((6, 3)))\n        check_indexing('[1:]', consec((3, 3)))\n        check_indexing('[:1]', consec((3, 3)))\n        check_indexing('[:]', consec((3, 2)))\n\n        # multi-dim: indexes\n        check_indexing('[0, 1]', consec((3, 3)))\n        check_indexing('[0, 1]', consec((3, 3, 2)))\n        check_indexing('[1, 0, 2]', consec((3, 3, 3)))\n        check_indexing('[2, -1]', consec((3, 3)))\n\n        # multi-dim: mixed slicing and indexing\n        check_indexing('[0, 1:2]', consec((3, 3)))\n        check_indexing('[0, :1]', consec((3, 3, 2)))\n        check_indexing('[1, 2:]', consec((3, 3, 3)))\n        check_indexing('[-1, 1:, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[1:, -1, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, 2:, 1:2]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, 1:, 0]', consec((3, 3, 3, 3)))\n        check_indexing('[-1, :, 0, 2]', consec((3, 3, 3, 3)))\n\n        # zero-sized slices\n        check_indexing('[0:0]', consec((2, 2)))\n        check_indexing('[0:0, 1]', consec((3, 3)))\n\n        # trivial expression usage\n        check_indexing('[1+1]', consec((3, 3)))\n        check_indexing('[1:(0 + 2)]', consec((3, 3, 3)))\n\n        # None for new dimensions\n        check_indexing('[None, 0]', consec((3, 3)))\n        check_indexing('[1, None]', consec((3, 3), 10))\n        check_indexing('[None, None, 2]', consec((3, 3), 19))\n        check_indexing('[None, 2, None]', consec((3,)))\n        check_indexing('[0:2, None]', consec((3, 3, 3)))\n        check_indexing('[None, 1:-1]', consec((3, 3, 3)))\n        check_indexing('[None, -3:-1, None]', consec((6, 3)))\n        check_indexing('[-1, None, 2:, None, 1:2]', consec((3, 3, 3, 3)))\n        check_indexing('[None, -1, None, 2:, None, 1:2, None]', consec((3, 3, 3, 3)))\n\n        # dynamic expression usage\n        check_dynamic_indexing(\"[i + j]\", consec((3, 3)), 0, 1)\n        check_dynamic_indexing(\"[i:j, i]\", consec((3, 3, 2)), 0, 2)\n\n        # positive striding\n        check_indexing_list_int('[0]', consec_list(6))\n        check_indexing_list_int('[1]', consec_list(7))\n        check_indexing_list_int('[2]', consec_list(8))\n        check_indexing_list_int('[2]', consec_list(9))\n        check_indexing_list_int('[-1]', consec_list(10))\n        check_indexing_list_int('[0:2]', consec_list(11))\n        check_indexing_list_int('[1:-1]', consec_list(12))\n        check_indexing_list_int('[-3:-1]', consec_list(13))\n        check_indexing_list_int('[1:]', consec_list(15))\n        check_indexing_list_int('[:1]', consec_list(16))\n        check_indexing_list_int('[:]', consec_list(17))\n        check_indexing_list_int('[::]', consec_list(0))\n        check_indexing_list_int('[1000::]', consec_list(0))\n        check_indexing_list_int('[:1000:]', consec_list(0))\n\n        # negative striding\n        check_indexing_list_int('[::-1]', consec_list(7))\n        check_indexing_list_int('[:3:-1]', consec_list(7))\n        check_indexing_list_int('[3::-1]', consec_list(7))\n        check_indexing_list_int('[1000::-1]', consec_list(7))\n        check_indexing_list_int('[3:0:-1]', consec_list(7))\n        check_indexing_list_int('[3:-1000:-1]', consec_list(7))\n        check_indexing_list_int('[0:0:-1]', consec_list(7))\n        check_indexing_list_int('[0:-1000:-1]', consec_list(7))\n\n        # only step is specified\n        check_indexing_list_int('[::-1]', consec_list(0))\n        check_indexing_list_int('[::-1]', consec_list(7))\n        check_indexing_list_int('[::-2]', consec_list(7))\n        check_indexing_list_int('[::2]', consec_list(7))\n        check_indexing_list_int('[::42]', consec_list(7))\n        check_indexing_list_int('[::-42]', consec_list(7))\n        check_indexing_list_int('[::42]', consec_list(0))\n        check_indexing_list_int('[::-42]', consec_list(0))\n        check_indexing_list_int('[::9223372036854775807]', consec_list(42))\n        check_indexing_list_int('[::-9223372036854775807]', consec_list(42))\n        with self.assertRaisesRegex(RuntimeError, \"out of bounds\"):\n            check_indexing_list_int('[::-9223372036854775808]', consec_list(42))\n        with self.assertRaisesRegex(RuntimeError, \"should have non-zero step\"):\n            check_indexing_list_int('[::0]', consec_list(42))\n\n        # striding strings\n        check_indexing_str('[0]', random_string(6))\n        check_indexing_str('[1]', random_string(7))\n        check_indexing_str('[2]', random_string(8))\n        check_indexing_str('[2]', random_string(9))\n        check_indexing_str('[-1]', random_string(10))\n        check_indexing_str('[0:2]', random_string(11))\n        check_indexing_str('[1:-1]', random_string(12))\n        check_indexing_str('[-3:-1]', random_string(13))\n        check_indexing_str('[1:]', random_string(15))\n        check_indexing_str('[:1]', random_string(16))\n        check_indexing_str('[:]', random_string(17))\n        check_indexing_str('[::]', random_string(0))\n        check_indexing_str('[1000::]', random_string(0))\n        check_indexing_str('[:1000:]', random_string(0))\n\n        check_indexing_str('[::-1]', random_string(7))\n        check_indexing_str('[:3:-1]', random_string(7))\n        check_indexing_str('[3::-1]', random_string(7))\n        check_indexing_str('[1000::-1]', random_string(7))\n        check_indexing_str('[3:0:-1]', random_string(7))\n        check_indexing_str('[3:-1000:-1]', random_string(7))\n        check_indexing_str('[0:0:-1]', random_string(7))\n        check_indexing_str('[0:-1000:-1]', random_string(7))\n\n        check_indexing_str('[::-1]', random_string(0))\n        check_indexing_str('[::-1]', random_string(7))\n        check_indexing_str('[::-2]', random_string(7))\n        check_indexing_str('[::2]', random_string(7))\n        check_indexing_str('[::42]', random_string(7))\n        check_indexing_str('[::-42]', random_string(7))\n        check_indexing_str('[::42]', random_string(0))\n        check_indexing_str('[::-42]', random_string(0))\n        check_indexing_str('[::9223372036854775807]', random_string(42))\n        check_indexing_str('[::-9223372036854775807]', random_string(42))\n        with self.assertRaisesRegex(RuntimeError, \"out of bounds\"):\n            check_indexing_str('[::-9223372036854775808]', random_string(42))\n        with self.assertRaisesRegex(RuntimeError, \"should have non-zero step\"):\n            check_indexing_str('[::0]', random_string(42))\n\n    def test_module_copy_with_attributes(self):\n        class Vocabulary(torch.jit.ScriptModule):\n            def __init__(self, vocab_list):\n                super(Vocabulary, self).__init__()\n                self._vocab = torch.jit.Attribute(vocab_list, List[str])\n                self.some_idx = torch.jit.Attribute(2, int)\n                self.idx = torch.jit.Attribute(\n                    {word: i for i, word in enumerate(vocab_list)}, Dict[str, int]\n                )\n\n            @torch.jit.script_method\n            def lookup_indices_1d(self, values):\n                # type: (List[str]) -> List[int]\n                result = torch.jit.annotate(List[int], [])\n                # Direct list iteration not supported\n                for i in range(len(values)):\n                    value = values[i]\n                    result.append(self.idx.get(value, self.some_idx))\n                return result\n\n            @torch.jit.script_method\n            def forward(self, values):\n                # type: (List[List[str]]) -> List[List[int]]\n                result = torch.jit.annotate(List[List[int]], [])\n                # Direct list iteration not supported\n                for i in range(len(values)):\n                    result.append(self.lookup_indices_1d(values[i]))\n                return result\n\n        v = Vocabulary(list('uabcdefg'))\n        v.__copy__()\n\n    def test_tuple_to_opt_list(self):\n        @torch.jit.script\n        def foo(x):\n            # type: (Optional[List[int]]) -> int\n            return 1\n\n        @torch.jit.script\n        def tuple_call():\n            return foo((1, 2))\n\n    def test_keyword(self):\n        @torch.jit.script\n        def func(x):\n            return torch.sum(x, dim=0)\n\n        x = torch.rand(10, dtype=torch.float, requires_grad=True)\n        y = func(x)\n        y2 = torch.sum(x, dim=0)\n        self.assertEqual(y, y2)\n\n    def test_constant_pooling_none(self):\n        @torch.jit.script\n        def typed_nones(a=None, b=None, c=None):\n            # type: (Optional[int], Optional[bool], Optional[Tensor]) -> Tuple[Optional[int], Optional[bool], Optional[Tensor]]\n            return a, b, c\n\n        @torch.jit.script\n        def test(a):\n            # type: (bool) -> None\n            if a:\n                print(typed_nones())\n            else:\n                print(typed_nones())\n\n        graph_str = str(test.graph)\n        self.assertTrue(graph_str.count(\"NoneType = prim::Constant\") == 1)\n\n    def test_constant_pooling_same_identity(self):\n        def foo():\n            a = torch.tensor([4])\n            b = (a,)\n            index = len(a) - 1\n            c = b[index]\n            d = b[index]\n            return c, d\n\n        foo_script = torch.jit.script(foo)\n        self.run_pass('constant_propagation', foo_script.graph)\n        self.run_pass('constant_pooling', foo_script.graph)\n        # even though the c & d escape scope, we are still able\n        # pool them into one constant because they are the same object\n        FileCheck().check_count(\"prim::Constant\", 1, exactly=True).run(foo_script.graph)\n        self.assertEqual(foo(), foo_script())\n\n    def test_constant_pooling_introduce_aliasing(self):\n        @torch.jit.script\n        def foo():\n            a = torch.tensor(1)\n            b = torch.tensor(1)\n            return a, b\n\n        self.run_pass('constant_propagation', foo.graph)\n        self.run_pass('constant_pooling', foo.graph)\n        # dont pool constants bc it would introduce observable alias relationship changing\n        a, b = foo()\n        self.assertIsNot(a, b)\n\n    def test_literal(self):\n        def func1(a, b):\n            c = a, b\n            d, e = c\n            return d + e\n\n        def func2(a, b):\n            c = a, (a, b)\n            d, e = c\n            f, g = e\n            return d + f + g\n\n        def func3(a, b):\n            # type: (float, float) -> float\n            c = 0., (0., 0.)\n            x = True\n            while x:\n                x = False\n                c = a, (a, b)\n            d, e = c\n            f, g = e\n            return d + f + g\n\n        a = torch.rand(1, requires_grad=True)\n        b = torch.rand(1, requires_grad=True)\n        self.checkScript(func1, (a, b), optimize=True)\n        self.checkScript(func2, (a, b), optimize=True)\n        self.checkScript(func3, (a.item(), b.item()), optimize=True)\n\n    def test_expand(self):\n        @torch.jit.script\n        def func(x, y):\n            return x + y\n\n        x = torch.rand(2, 3, dtype=torch.float, requires_grad=True)\n        y = torch.rand(3, dtype=torch.float, requires_grad=True)\n        out = func(x, y)\n        self.assertEqual(func(x, y), x + y)\n\n        grad = torch.randn(2, 3, dtype=torch.float)\n        out.backward(grad)\n        self.assertEqual(x.grad, grad)\n        self.assertEqual(y.grad, grad.sum(dim=0))\n\n    def test_sum(self):\n        @torch.jit.script\n        def func(x):\n            return x.sum(dim=[4])\n\n        @torch.jit.script\n        def func2(x):\n            return x.sum(dim=4)\n\n        # test that shape analysis is written correctly for sum with OptionalIntArrayRef[1] dim argument\n        self.run_pass('constant_propagation', func.graph)\n        self.run_pass('constant_propagation', func2.graph)\n        g = _propagate_shapes(func.graph, (torch.zeros(1, 1, 1, 1, 4),), False)\n        g2 = _propagate_shapes(func2.graph, (torch.zeros(1, 1, 1, 1, 4),), False)\n\n    def test_cat(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.cat((x, x), dim=0)\n\n            x = torch.rand(10, dtype=torch.float, requires_grad=True)\n            self.assertEqual(func(x, profile_and_replay=True), torch.cat((x, x), dim=0))\n\n            @torch.jit.script\n            def func2(x, y):\n                return torch.cat((x, x), y)\n\n            with disable_autodiff_subgraph_inlining():\n                for sizes in ((2, 2), (0, 2)):\n                    x = torch.rand(sizes).requires_grad_()\n                    y = torch.tensor(1)\n\n                    output = func2(x, y, profile_and_replay=True)\n                    output_ref = torch.cat((x, x), y)\n                    self.assertEqual(output, output_ref)\n\n                    if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                        self.assertAutodiffNode(func2.graph_for(x, y), True, ['aten::cat'], [])\n\n                        grad = torch.autograd.grad(output.sum(), x)\n                        grad_ref = torch.autograd.grad(output_ref.sum(), x)\n                        self.assertEqual(grad, grad_ref)\n\n    def test_cat_lifts(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.cat([x, x], dim=1)\n\n        @torch.jit.script\n        def foo2(x):\n            return torch.cat([], dim=1)\n\n        @torch.jit.script\n        def foo3(x):\n            return torch.cat([x], dim=1)\n\n        for g in [foo.graph, foo2.graph, foo3.graph]:\n            FileCheck().check(\"int =\").check(\"ListConstruct\").check(\"aten::cat\").run(str(g))\n\n    def test_stack(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x):\n                return torch.stack((x, x), dim=1)\n            x = torch.rand(10, 10)\n            self.assertEqual(func(x, profile_and_replay=True), torch.stack((x, x), dim=1))\n\n            @torch.jit.script\n            def func2(x, y):\n                return torch.stack((x, y), dim=0)\n\n            with disable_autodiff_subgraph_inlining():\n                x = torch.randn([2, 2]).requires_grad_()\n                y = torch.randn([2, 2]).requires_grad_()\n\n                output = func2(x, y, profile_and_replay=True)\n                output_ref = torch.stack((x, y), 0)\n                self.assertEqual(output, output_ref)\n                if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                    self.assertAutodiffNode(func2.graph_for(x, y), True, ['aten::stack'], [])\n\n                    grads = torch.autograd.grad(output.sum(), (x, y))\n                    grads_ref = torch.autograd.grad(output_ref.sum(), (x, y))\n                    self.assertEqual(grads, grads_ref)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY,\n                     \"Profiling executor will be using different heuristics for constructing differentiable graphs\")\n    def test_unbind(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(x, y):\n                # type: (Tensor, int) -> List[Tensor]\n                return torch.unbind(x, y)\n\n            with disable_autodiff_subgraph_inlining():\n                x = torch.rand([2, 2]).requires_grad_()\n                y = 0\n                outputs = func(x, y, profile_and_replay=True)\n                outputs_ref = torch.unbind(x, dim=y)\n                self.assertEqual(outputs, outputs_ref)\n                self.assertAutodiffNode(func.graph_for(x, y), True, [], [])\n\n                grad = torch.autograd.grad(_sum_of_list(outputs), x)\n                grad_ref = torch.autograd.grad(_sum_of_list(outputs_ref), x)\n                self.assertEqual(grad, grad_ref)\n\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.PROFILING,\n                     \"Profiling executor fails to recognize that tensors in a list require gradients\")\n    def test_meshgrid(self):\n        with enable_profiling_mode_for_profiling_tests():\n            @torch.jit.script\n            def func(a):\n                # type: (List[Tensor]) -> List[Tensor]\n                return torch.meshgrid(a)\n            with disable_autodiff_subgraph_inlining():\n                a = torch.tensor([1.0, 2, 3]).requires_grad_()\n                b = torch.tensor([1.0, 2, 3, 4]).requires_grad_()\n                inputs = [a, b]\n\n                outputs_ref = torch.meshgrid(inputs)\n                outputs = func(inputs, profile_and_replay=True)\n                self.assertEqual(outputs, outputs_ref)\n\n                if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n                    self.assertAutodiffNode(func.graph_for(inputs), True, [], [])\n\n                    grads = torch.autograd.grad(_sum_of_list(outputs), inputs)\n                    grads_ref = torch.autograd.grad(_sum_of_list(outputs_ref), inputs)\n                    self.assertEqual(grads, grads_ref)\n\n    def test_tensor_len(self):\n        def func(x):\n            return len(x)\n\n        self.checkScript(func, [torch.ones(4, 5, 6)])\n\n    def test_func_call(self):\n        def add(a, b):\n            return a + b\n\n        def mul(a, x):\n            return a * x\n\n        def func(alpha, beta, x, y):\n            return add(mul(alpha, x), mul(beta, y))\n\n        alpha = torch.rand(1, dtype=torch.float, requires_grad=True)\n        beta = torch.rand(1, dtype=torch.float, requires_grad=True)\n        x = torch.rand(3, dtype=torch.float, requires_grad=True)\n        y = torch.rand(3, dtype=torch.float, requires_grad=True)\n\n        # NOTE: cannot optimize yet because broadcasts are not inserted before the fuser runs\n        self.checkScript(func, [alpha, beta, x, y], optimize=False)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_profiling_graph_executor(self):\n        @torch.jit.script\n        def def_in_one_branch(x, z):\n            # type: (Tensor, bool) -> float\n            y = x\n            if z is False:\n                y = x + 1\n\n            return y.sum()\n\n        a = torch.rand(2, 3)\n\n        with enable_profiling_mode_for_profiling_tests():\n            # check prim::profile are inserted\n            profiled_graph_str = str(def_in_one_branch.graph_for(a, True))\n            FileCheck().check_count(\"prim::profile\", 4).run(profiled_graph_str)\n            # this call is optimized for\n            # the given shape of (2, 3)\n            def_in_one_branch(a, False)\n            # change shape to (3)\n            # so we go down a bailout path\n            a = torch.ones(3)\n            # check prim::BailOuts are inserted\n            bailout_graph_str = str(def_in_one_branch.graph_for(a, True))\n            FileCheck().check_count(\"prim::BailOut\", 3).run(bailout_graph_str)\n            # this triggers all 3 bailouts\n            self.assertEqual(def_in_one_branch(a, False), 6.0)\n            # this triggers 2 bailouts\n            self.assertEqual(def_in_one_branch(a, True), 3.0)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_maxpool_guard_elimination(self):\n        @torch.jit.script\n        def my_maxpool(x):\n            return F.max_pool1d(x, kernel_size=[1]) + torch.ones([32, 32, 32])\n\n        a = torch.rand(32, 32, 32)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_maxpool(a)\n            bailout_graph_str = str(my_maxpool.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 1).run(bailout_graph_str)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_slice_guard_elimination(self):\n        @torch.jit.script\n        def my_slice(x):\n            return x[0:16:2] + x[0:16:2]\n\n        a = torch.rand(32, 4)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_slice(a)\n            bailout_graph_str = str(my_slice.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 1).run(bailout_graph_str)\n\n    @unittest.skip(\"bailouts are being deprecated\")\n    def test_unsqueeze_guard_elimination(self):\n        @torch.jit.script\n        def my_unsqueeze(x):\n            return torch.unsqueeze(x, 0) + torch.unsqueeze(x, 0)\n\n        a = torch.rand(32, 4)\n\n        with enable_profiling_mode_for_profiling_tests():\n            my_unsqueeze(a)\n            bailout_graph_str = str(my_unsqueeze.graph_for(a))\n            FileCheck().check_count(\"prim::BailOut\", 2).run(bailout_graph_str)\n\n    def test_resize_input_ops(self):\n        # resize_ and resize_as resize the input tensor. because our shape analysis\n        # is flow invariant, we set any Tensor that can alias a resized Tensor\n        # to the base Tensor Type, without size information.\n\n        # testing that value which is an input of a graph gets handled\n        def out_op_graph_input():\n            @torch.jit.script\n            def test(x, y, z):\n                torch.mul(x, y, out=z)\n                return z\n\n            graph = _propagate_shapes(test.graph,\n                                      (torch.zeros(2, 1), torch.zeros(1, 2), torch.zeros(1, 1, 1)), False)\n            self.assertTrue(next(graph.outputs()).type() == TensorType.get())\n        out_op_graph_input()\n\n        def test_resize():\n            @torch.jit.script\n            def test(x):\n                after_resize_alias = torch.zeros([2])\n                for _i in range(5):\n                    b = x + 1\n                    f = [1]\n                    before_resize_alias = b.sub_(1)\n                    # for i in range(10):\n                    f.append(1)\n                    b.resize_(f)\n                    after_resize_alias = b.add_(1)\n                return after_resize_alias\n\n            self.run_pass('constant_propagation', test.graph)\n            g = _propagate_shapes(test.graph, (torch.zeros(1, 1),), False)\n            resize_node = g.findNode(\"aten::resize_\")\n            # first input and output of b.resize_ is b\n            self.assertTrue(next(resize_node.inputs()).type() == TensorType.get())\n            self.assertTrue(next(resize_node.outputs()).type() == TensorType.get())\n\n            # correctly propagates to b alias set\n            before_resize = g.findNode(\"aten::sub_\")\n            self.assertTrue(next(before_resize.outputs()).type() == TensorType.get())\n\n            after_resize = g.findNode(\"aten::add_\")\n            self.assertTrue(next(after_resize.outputs()).type() == TensorType.get())\n\n        test_resize()\n\n        def test_resize_as():\n            @torch.jit.script\n            def test(x):\n                b = torch.zeros([2, 2])\n                b.resize_as_(x)\n                return b\n\n            g = test.graph\n            self.run_pass('constant_propagation', g)\n            g = _propagate_shapes(test.graph, (torch.zeros(1, 1),), False)\n\n            # x doesn't alias a resized op so it shouldn't be set to base Tensor type\n            self.assertTrue(next(g.inputs()).type() != TensorType.get())\n            # return is resized\n            self.assertTrue(next(g.outputs()).type() == TensorType.get())\n\n        test_resize_as()\n\n    def test_uninitialized(self):\n        graph_str = \"\"\"graph():\n          %1 : int = prim::Uninitialized()\n          %2 : int = prim::Constant[value=1]()\n          %3 : int = aten::add(%1, %2)\n          return (%3)\n        \"\"\"\n        g = parse_ir(graph_str)\n        m = self.createFunctionFromGraph(g)\n        self.getExportImportCopy(m)\n        with self.assertRaisesRegex(RuntimeError, \"isInt\"):\n            m()\n\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.SIMPLE, \"Simple Executor doesn't use requires_grad information\")\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.PROFILING, \"Peeling is now disabled\")\n    def test_requires_grad_loop(self):\n        @torch.jit.script\n        def test(x, y, z):\n            # type: (Tensor, Tensor, int) -> Tensor\n            for _ in range(z):\n                x = y\n            return x\n\n        # x requires grad, y does not\n        # testing that requires grad analysis correctly exits, with its input\n        # to the loop (x) requiring grad and its output to the loop not requiring grad\n        # and the output of the node conservatively setting grad to true\n\n        inps = (torch.tensor(1.0, requires_grad=True), torch.tensor(1), 10)\n        test(*inps, profile_and_replay=True)\n\n        graph = test.graph_for(*inps)\n        loop = graph.findNode(\"prim::Loop\")\n        loop_body = next(loop.blocks())\n        loop_inputs = list(loop_body.inputs())\n        loop_outputs = list(loop_body.outputs())\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            # TODO: simplify this test as it's very sensitive\n            # the optimized graph will have 3 loops\n            # the original loop is peeled\n            # peeled loop also gets unrolled\n            index_of_x_in_peeled_unrolled_loop = -2\n            self.assertTrue(loop_inputs[index_of_x_in_peeled_unrolled_loop].requires_grad())\n            bailouts_in_outer_block = graph.findAllNodes(\"prim::BailOut\", False)\n            last_bailout_index_on_loops_output = -1\n            self.assertFalse(bailouts_in_outer_block[last_bailout_index_on_loops_output].output().requires_grad())\n        else:\n            self.assertTrue(loop_inputs[1].requires_grad())\n            self.assertTrue(loop.output().requires_grad())\n            self.assertFalse(loop_outputs[1].requires_grad())\n\n    def test_view_shape_prop(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_view_shape_prop(a):\n            return a.view(size=[-1])\n        ''')\n        inputs = [torch.zeros(10, 10)]\n        outputs = torch.zeros(100)\n\n        real_outs = cu.test_view_shape_prop(*inputs)\n        self.assertEqual(real_outs, outputs)\n\n    def test_view_listconstruct_shape_prop(self):\n        def fn(x):\n            B = x.size(0)\n            C = x.size(1)\n            T = x.size(2)\n            return x.view(T, B, C)\n\n        x = torch.randn(3, 1, 5, requires_grad=True)\n        fn = torch.jit.script(fn)\n        graph = _propagate_shapes(fn.graph, (x,), False)\n        self.assertTrue(next(graph.outputs()).type().scalarType() == 'Double')\n\n    def test_shape_prop_promotion(self):\n        @torch.jit.script\n        def fn(x, y):\n            return x + y\n\n        x, y = torch.rand(3, 4, dtype=torch.float), torch.rand(3, 4, dtype=torch.double)\n        graph = _propagate_shapes(fn.graph, (x, y), False)\n        FileCheck().check('Double(*, *, device=cpu) = aten::add').run(graph)\n\n    def test_shape_prop_promote_scalar_arg(self):\n        @torch.jit.script\n        def fn(x):\n            return math.pi + x\n\n        x = torch.zeros(3, 4, dtype=torch.long)\n        graph = _propagate_shapes(fn.graph, (x,), False)\n        default = torch.get_default_dtype()\n        if(default == torch.float):\n            FileCheck().check('Float(*, *, requires_grad=0, device=cpu) = aten::add').run(graph)\n        else:\n            FileCheck().check('Double(*, *, requires_grad=0, device=cpu) = aten::add').run(graph)\n\n    def test_integral_shape_inference(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_integral_shape_inference(a):\n            return a * a\n        ''')\n        inputs = [torch.ones(10, 10, dtype=torch.long)]\n        outputs = torch.ones(10, 10, dtype=torch.long)\n\n        self.assertEqual(cu.test_integral_shape_inference(*inputs), outputs)\n\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_batchnorm_fuser_cpu(self):\n        code = '''\n            graph(%3 : Tensor,\n                  %7 : Tensor,\n                  %12 : Float(*, *),\n                  %13 : Tensor,\n                  %25 : Tensor):\n                %23 : int = prim::Constant[value=1]()\n                %22 : float = prim::Constant[value=1e-05]()\n                %26 : Tensor = aten::sqrt(%25)\n                %24 : Tensor = aten::add(%26, %22, %23)\n                %20 : Tensor = aten::reciprocal(%24)\n                %norm_invstd : Tensor = aten::mul(%20, %23)\n                %15 : Tensor = aten::sub(%12, %13, %23)\n                %11 : Tensor = aten::mul(%15, %norm_invstd)\n                %8 : Tensor = aten::mul(%11, %7)\n                %5 : Tensor = aten::add(%8, %3, %23)\n                %1 : Float(*, *) = aten::relu(%5)\n                return (%1)\n        '''\n\n        graph = parse_ir(code)\n        inputs = 5 * [torch.rand(26, 2048, dtype=torch.float)]\n        code = torch._C._jit_fuser_get_fused_kernel_code(graph, inputs)\n        FileCheck().check('sqrtf').run(code)\n\n    @slowTest\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_fuser_double_float_codegen(self):\n        fns = ['log', 'log10', 'log1p', 'log2', 'lgamma', 'exp', 'expm1', 'erf',\n               'erfc', 'cos', 'acos', 'cosh', 'sin', 'asin', 'sinh', 'tan',\n               'atan', 'tanh', 'sqrt', 'ceil', 'floor', 'round', 'trunc',\n               'frac']\n\n        def lookup_c_equivalent_fn(aten_fn):\n            return aten_fn\n\n        def test_dispatch(op, expects, dtype, binary=False):\n            if dtype == torch.double:\n                dtype_str = 'Double'\n            elif dtype == torch.float:\n                dtype_str = 'Float'\n            else:\n                raise RuntimeError('Unknown dtype')\n\n            if binary:\n                code = '''\n                    graph(%3 : Tensor, %4 : Tensor):\n                        %2 : {dtype}(*, *) = aten::{op}(%3, %4)\n                        %1 : {dtype}(*, *) = aten::relu(%2)\n                        return (%1)\n                '''.format(op=op, dtype=dtype_str)\n            else:\n                code = '''\n                    graph(%3 : Tensor):\n                        %2 : {dtype}(*, *) = aten::{op}(%3)\n                        %1 : {dtype}(*, *) = aten::relu(%2)\n                        return (%1)\n                '''.format(op=op, dtype=dtype_str)\n\n            graph = parse_ir(code)\n            inputs = (2 if binary else 1) * [torch.rand(26, 2048, dtype=dtype)]\n            code = torch._C._jit_fuser_get_fused_kernel_code(graph, inputs)\n            FileCheck().check(expects).run(code)\n\n        for fn in fns:\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + '(', torch.double)\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + 'f(', torch.float)\n\n        # 'min', 'max' were previously tested but are now replaced with ternary expressions\n        # instead of fmin() and fmax()\n        binary_fns = ['pow']\n        for fn in binary_fns:\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + '(', torch.double, binary=True)\n            test_dispatch(fn, lookup_c_equivalent_fn(fn) + 'f(', torch.float, binary=True)\n\n    @unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')\n    @unittest.skipIf(IS_SANDCASTLE, \"NYI: fuser support for Sandcastle\")\n    @enable_cpu_fuser\n    def test_fuser_double_literal_precision(self):\n        code = '''\n        graph(%2 : Float(*, *)):\n            %4 : int = prim::Constant[value=1]()\n            %3 : float = prim::Constant[value=1.282549830161864]()\n            %5 : Float(*, *) = aten::add(%2, %3, %4)\n            %1 : Float(*, *) = aten::relu(%5)\n            return (%1)\n        '''\n\n        graph = parse_ir(code)\n        code = torch._C._jit_fuser_get_fused_kernel_code(graph, [torch.rand(3, 4)])\n        FileCheck().check('1.282549830161864').run(code)\n\n    def test_fuser_multiple_blocks(self):\n        cu = torch.jit.CompilationUnit('''\n        def test_fuser_multiple_blocks(this, that, theother, meme):\n            i = 0\n            while i < 20:\n                this = torch.cat([this, meme], dim=0)\n                that = torch.cat([that, meme], dim=0)\n                theother = torch.cat([theother, meme], dim=0)\n                i = i + 1\n            return this, that, theother\n        ''')\n\n        inputs = [torch.ones(0, 10, 10)] * 3\n        inputs += [torch.ones(1, 10, 10)]\n        outputs = [torch.ones(20, 10, 10)] * 3\n\n        self.assertEqual(cu.test_fuser_multiple_blocks(*inputs), outputs)\n\n    @unittest.skip(\"RuntimeError: VariableType::ID() not implemented\")\n    def test_cast(self):\n        script = '''\n        def to_int(x):\n            return int(x)\n        '''\n        x = Variable(torch.FloatTensor([1.1, 2.3]), requires_grad=True)\n        out = Variable(torch.IntTensor([1, 2]), requires_grad=True)\n        self.checkScript(script, [x], optimize=True, outputs=[out], func='to_int')\n\n    def test_str_cast(self):\n        @torch.jit.script\n        def to_str(x):\n            # type: (int) -> str\n            return str((x, x))\n\n        self.assertEqual(\"(1, 1)\", to_str(1))\n\n    def test_int_cast(self):\n        @torch.jit.script\n        def to_int(x):\n            # type: (str) -> int\n            return int(x)\n\n        self.assertEqual(5, to_int('5'))\n        self.assertEqual(-5, to_int('-5'))\n        self.assertEqual(2147483647, to_int('2147483647'))\n        self.assertEqual(-2147483648, to_int('-2147483648'))\n\n        with self.assertRaisesRegex(RuntimeError, \"invalid literal for int()\"):\n            to_int('0x20')\n\n        with self.assertRaisesRegex(RuntimeError, \"invalid literal for int()\"):\n            to_int('0b0001')\n\n    def test_python_frontend(self):\n        def fn(x, y, z):\n            q = None\n            q = x + y - z.sigmoid()\n            print(q)\n            w = -z\n            if not x and not y and z:\n                m = x if not z else y\n            while x < y > z:\n                q = x\n            assert 1 == 1, \"hello\"\n            return x\n\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        self.assertExpected(str(ast))\n\n    def test_python_frontend_source_range(self):\n        def fn():\n            raise Exception(\"hello\")\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        FileCheck().check(\"SourceRange at:\") \\\n                   .check(\"def fn():\") \\\n                   .check(\"~~~~~~~~~\") \\\n                   .check('raise Exception(\"hello\")') \\\n                   .check('~~~~~~~~~~~~~~~~~ <--- HERE') \\\n                   .run(str(ast.range()))\n\n    def test_python_frontend_py3(self):\n        def fn():\n            raise Exception(\"hello\")\n        ast = torch.jit.frontend.get_jit_def(fn, fn.__name__)\n        self.assertExpected(str(ast))\n\n    def _make_scalar_vars(self, arr, dtype):\n        return [torch.tensor(val, dtype=dtype) for val in arr]\n\n\n    def test_string_print(self):\n        def func(a):\n            print(a, \"a\" 'b' '''c''' \"\"\"d\"\"\", 2, 1.5)\n            return a\n\n        inputs = self._make_scalar_vars([1], torch.int64)\n        self.checkScript(func, inputs, capture_output=True)\n\n    def test_while(self):\n        def func(a, b, max):\n            while bool(a < max):\n                a = a + 1\n                b = b + 1\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([1, 1, 10], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_fibb(self):\n        def func(lim):\n            first = 1\n            second = 1\n            i = 1\n            somenum = 5\n            dontmutateme = 3\n            third = 0\n            while bool(i < lim):\n                third = first + second\n                first = second\n                second = third\n                j = 0\n                while j < 10:\n                    somenum = somenum * 2\n                    j = j + 1\n                i = i + j\n                i = i + dontmutateme\n\n            st = second + third\n            fs = first + second\n            return third, st, fs\n\n        inputs = self._make_scalar_vars([10], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_fibb_totally_better(self):\n        def fib(x):\n            # type: (int) -> int\n            prev = 1\n            v = 1\n            for i in range(0, x):\n                save = v\n                v = v + prev\n                prev = save\n            return v\n\n        self.checkScript(fib, (10,))\n\n    def test_if(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            d = 3\n            if bool(a > 10):\n                a = 3 + d\n            else:\n                b = 3 + d\n                d = 4\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([1, -1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_for_in_range(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            d = 3\n            for _ in range(20):\n                if bool(a > 10):\n                    a = 3 + d\n                else:\n                    b = 3 + d\n                    d = 4\n                c = a + b\n            return d\n        inputs = self._make_scalar_vars([1, -1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_noelse(self):\n        def func(a, b):\n            if bool(a > 10):\n                a = 3 + b\n            c = a + b\n            return c\n\n        inputs = self._make_scalar_vars([-1, 1], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_if_is_none_dispatch(self):\n\n        @torch.jit.script\n        def test_lhs_none_rhs_none():\n            # LHS, RHS both alwaysNone, dispatch always_none_branch\n            # only emit one prim::Constant\n            if None is None:\n                return 1\n            elif None is not None:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_none_rhs_none.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_lhs_opt_rhs_none(lhs=None):\n            # type: (Optional[Tensor]) -> int\n            # LHS maybeNone: emit normal if stmt that contains 3 constants\n            if lhs is not None:\n                return 2\n            elif lhs is None:\n                return 1\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_opt_rhs_none.graph).count(': int = prim::Constant') == 3)\n\n        @torch.jit.script\n        def test_lhs_none_rhs_opt(rhs=None):\n            # type: (Optional[Tensor]) -> int\n            # RHS maybeNone, emit normal if stmt that contains 3 constants\n            if None is rhs:\n                return 1\n            elif None is not rhs:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_opt_rhs_none.graph).count(': int = prim::Constant') == 3)\n\n        @torch.jit.script\n        def test_lhs_never_rhs_none(lhs):\n            # LHS neverNone, RHS alwaysNone dispatch never_none_branch\n            # only emit one prim::Constant\n            if lhs is None:\n                return 1\n            elif lhs is not None:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_never_rhs_none.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_lhs_none_rhs_never(rhs):\n            # LHS alwaysNone, RHS neverNone dispatch never_none_branch\n            # only emit one prim::Constant\n            if None is rhs:\n                return 1\n            elif None is not rhs:\n                return 2\n            else:\n                return 3\n\n        self.assertTrue(str(test_lhs_none_rhs_never.graph).count(': int = prim::Constant') == 1)\n\n        @torch.jit.script\n        def test_bool_arith_and(lhs):\n            if lhs is None and lhs is not None:\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_and(torch.zeros(3)), 2)\n        self.assertTrue(str(test_bool_arith_and.graph).count('if') == 0)\n\n        @torch.jit.script\n        def test_bool_arith_or(lhs):\n            if lhs is None or lhs is not None:\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_or(torch.zeros(3)), 1)\n        self.assertTrue(str(test_bool_arith_or.graph).count('if') == 0)\n\n\n        @torch.jit.script\n        def test_bool_arith_not(lhs):\n            if not (lhs is None):\n                return 1\n            else:\n                return 2\n        self.assertEqual(test_bool_arith_not(torch.zeros(3)), 1)\n        self.assertTrue(str(test_bool_arith_not.graph).count('if') == 0)\n\n    def test_conditional_casting(self):\n        def test_bool_cast_tensor(x):\n            if x:\n                return 1\n            else:\n                return 0\n\n        for make_one_dim in [True, False]:\n            for inp_val in [0.1, 0.0, -0.0, -0.1, -1, 0, 1]:\n                inp_val = [inp_val] if make_one_dim else inp_val\n                self.checkScript(test_bool_cast_tensor, (torch.tensor(inp_val),))\n\n        self.checkScriptRaisesRegex(test_bool_cast_tensor, (torch.tensor([1, 1]),), Exception,\n                                    \"Boolean value of Tensor with more than one value\")\n\n        def test_not_cast(x):\n            if not x:\n                return 1\n            else:\n                return 0\n\n        self.checkScript(test_not_cast, (torch.tensor(1),))\n        self.checkScript(test_not_cast, (torch.tensor(0),))\n\n        with self.assertRaisesRegex(RuntimeError, r\"Could not cast value of type Tuple\\[Tensor, Tensor\\]\"):  # noqa: W605\n            @torch.jit.script\n            def test_mult(x, y):\n                return not(x, y)\n\n        def test_cast_int(x):\n            # type: (int) -> int\n            if x:\n                return 1\n            else:\n                return 0\n        self.checkScript(test_cast_int, (1,))\n        self.checkScript(test_cast_int, (0,))\n        self.checkScript(test_cast_int, (-1,))\n\n        def test_cast_float(x):\n            # type: (float) -> int\n            if x:\n                return 1\n            else:\n                return 0\n        self.checkScript(test_cast_float, (1.,))\n        self.checkScript(test_cast_float, (0.,))\n        self.checkScript(test_cast_float, (-1.,))\n\n        with self.assertRaisesRegex(RuntimeError, r\"Could not cast value of type Tuple\\[int, int\\] to bool\"):  # noqa: W605\n\n            @torch.jit.script\n            def test_bad_conditional(x):\n                if (1, 2):  # noqa: F634\n                    return\n                else:\n                    return 0\n\n    def test_while_nonexistent_value(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value x\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a, b):\n                while bool(a < 10):\n                    a = a + x\n                    b = b + 1\n                return a + b\n            ''')\n\n    def test_while_nonexistent_cond_value(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value x\"):\n            torch.jit.CompilationUnit('''\n            def test_while(a, b):\n                while a < x:\n                    a = a + 1\n                    b = b + 1\n                return a + b\n            ''')\n\n        @torch.jit.script\n        def test_ternary(x):\n            # type: (Optional[int]) -> int\n            x = x if x is not None else 2\n            return x\n\n        @torch.jit.script\n        def test_not_none(x):\n            # type: (Optional[int]) -> None\n            if x is not None:\n                print(x + 1)\n\n        @torch.jit.script\n        def test_and(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if x is not None and y is not None:\n                print(x + y)\n\n        @torch.jit.script\n        def test_not(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if not (x is not None and y is not None):\n                pass\n            else:\n                print(x + y)\n\n        @torch.jit.script\n        def test_bool_expression(x):\n            # type: (Optional[int]) -> None\n            if x is not None and x < 2:\n                print(x + 1)\n\n        @torch.jit.script\n        def test_nested_bool_expression(x, y):\n            # type: (Optional[int], Optional[int]) -> int\n            if x is not None and x < 2 and y is not None:\n                x = x + y\n            else:\n                x = 5\n            return x + 2\n\n        @torch.jit.script\n        def test_or(x, y):\n            # type: (Optional[int], Optional[int]) -> None\n            if y is None or x is None:\n                pass\n            else:\n                print(x + y)\n\n        # backwards compatibility\n        @torch.jit.script\n        def test_manual_unwrap_opt(x):\n            # type: (Optional[int]) -> int\n            if x is None:\n                x = 1\n            else:\n                x = torch.jit._unwrap_optional(x)\n            return x  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def or_error(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                if x is None or y is None:\n                    print(x + y)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def and_error(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                if x is None and y is None:\n                    pass\n                else:\n                    print(x + y)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def named_var(x):\n                # type: (Optional[int]) -> None\n                x_none = x is not None\n                if x_none:\n                    print(x + 1)  # noqa: T484\n\n        with self.assertRaisesRegex(RuntimeError, \"Arguments for call are not valid\"):\n            @torch.jit.script\n            def named_var_and(x, y):\n                # type: (Optional[int], Optional[int]) -> None\n                x_none = x is not None\n                if y is not None and x_none:\n                    print(x + y)  # noqa: T484\n\n    def test_assertion_optional_refinement(self):\n        @torch.jit.script\n        def test(x, y):\n            # type: (Optional[int], Optional[int]) -> int\n            assert x is not None and y is not None\n            return x + y\n\n        self.assertEqual(test(2, 2), 4)\n        with self.assertRaisesRegex(Exception, \"\"):\n            test(1, None)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the current version of Profiler doesn't profile/specialize Optionals\")\n    def test_optional_tensor(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Optional[Tensor], int) -> int\n            if x is None:\n                return y\n            else:\n                return 0\n\n        res = fn(None, 1)\n        self.assertEqual(res, 1)\n        g = torch.jit.last_executed_optimized_graph()\n        first_input = next(g.inputs())\n        # check if input is disconnected\n        self.assertEqual(first_input.type().kind(), 'OptionalType')\n        self.assertEqual(first_input.uses(), [])\n        t = torch.ones(1)\n        res = fn(t, 1)\n        self.assertEqual(res, 0)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.inputs()).type().kind(), 'TensorType')\n\n        @torch.jit.script\n        def fn(x, y, b):\n            # type: (Optional[Tensor], Tensor, bool) -> Tensor\n            if b:\n                res = y\n            else:\n                res = torch.jit._unwrap_optional(x)\n            return res\n\n        t2 = torch.zeros(1)\n        res = fn(t, t2, True)\n        self.assertEqual(res, t2)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            res = fn(None, t2, False)\n        res = fn(None, t2, True)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertIn(next(g.outputs()).type().str(), (\"Tensor\", \"Tensor(requires_grad=1)\"))\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the current version of Profiler doesn't profile/specialize Optionals\")\n    def test_optional_list(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Optional[List[int]], int) -> int\n            if x is None:\n                return y\n            else:\n                res = 0\n                for d in x:\n                    res += d\n                return res\n\n        res = fn(None, 1)\n        self.assertEqual(res, 1)\n        g = torch.jit.last_executed_optimized_graph()\n        first_input = next(g.inputs())\n        # check if input is disconnected\n        self.assertEqual(first_input.type().kind(), 'OptionalType')\n        self.assertEqual(first_input.uses(), [])\n        l = [2, 3]\n        res = fn(l, 1)\n        self.assertEqual(res, 5)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.inputs()).type().kind(), 'ListType')\n\n        @torch.jit.script\n        def fn(x, y, b):\n            # type: (Optional[List[int]], List[int], bool) -> List[int]\n            if b:\n                l = torch.jit._unwrap_optional(x)\n            else:\n                l = y\n            return l\n\n        l2 = [0, 1]\n        res = fn(l, l2, True)\n        self.assertEqual(res, l)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            res = fn(None, l2, True)\n        res = fn(None, l2, False)\n        g = torch.jit.last_executed_optimized_graph()\n        self.assertEqual(next(g.outputs()).type().str(), \"int[]\")\n\n    def test_alias_covariant_type_containers(self):\n        @torch.jit.script\n        def foo(x):\n            # type: (bool)\n            if x:\n                a = (None,)\n            else:\n                a = ([],)\n            return a\n\n        @torch.jit.script\n        def foo2(x, li):\n            # type: (bool, Tuple[Optional[List[Tensor]]])\n            if x:\n                li = (None,)\n            return li\n\n    def test_while_write_outer_then_read(self):\n        def func(a, b):\n            while bool(a < 10):\n                a = a + 1\n                b = a + 1\n            return a + b\n\n        inputs = self._make_scalar_vars([42, 1337], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_while_nest_if(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            c = 0\n            while a < 10:\n                a = a + 1\n                b = b + 1\n                if a > b:\n                    c = -a\n                else:\n                    c = -b\n            return c + 1\n\n        inputs = self._make_scalar_vars([-1234, 4321], torch.int64)\n        self.checkScript(func, inputs, optimize=True)\n\n    def test_divmod(self):\n        def func_int(a, b):\n            # type: (int, int) -> Tuple[int, int]\n            return divmod(a, b)\n\n        def func_float(a, b):\n            # type: (float, float) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def func_int_float(a, b):\n            # type: (int, float) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def func_float_int(a, b):\n            # type: (float, int) -> Tuple[float, float]\n            return divmod(a, b)\n\n        def divmod_test_iterator(func, num, den):\n            for i in num:\n                for j in den:\n                    self.checkScript(func, (i, j), frames_up=2)\n\n        num_int = [1024, -1024]\n        den_int = [10, -10]\n        num_float = [5.3, -5.3]\n        den_float = [2.0, -2.0]\n        divmod_test_iterator(func_int, num_int, den_int)\n        divmod_test_iterator(func_float, num_float, den_float)\n        divmod_test_iterator(func_int_float, num_int, den_float)\n        divmod_test_iterator(func_float_int, num_float, den_int)\n\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: integer division or modulo by zero\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_int)))\n            cu.func_int(1024, 0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_float)))\n            cu.func_float(5.3, 0.0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_int_float)))\n            cu.func_int_float(1024, 0.0)\n        with self.assertRaisesRegex(RuntimeError, \"ZeroDivisionError: float divmod()\"):\n            cu = torch.jit.CompilationUnit(dedent(inspect.getsource(func_float_int)))\n            cu.func_float_int(5.3, 0)\n\n    def test_math_ops(self):\n        def checkMathWrap(func_name, num_args=1, is_float=True, **args):\n            if is_float:\n                checkMath(func_name, num_args, True, **args)\n                checkMath(func_name, num_args, False, **args)\n            else:\n                checkMath(func_name, num_args, is_float, **args)\n\n        inf = float(\"inf\")\n        NaN = float(\"nan\")\n        mx_int = 2**31 - 1\n        mn_int = -2**31\n        float_vals = ([inf, NaN, 0.0, 1.0, 2.2, -1.0, -0.0, -2.2, -inf, 1, 0, 2] +\n                      [10.0 ** i for i in range(5)] + [-(10.0 ** i) for i in range(5)])\n        int_vals = list(range(-5, 5, 1)) + [mx_int + 5, mx_int * 2, mn_int - 5, mn_int * 2]\n\n        def checkMath(func_name, num_args, is_float=True, ret_type=\"float\", debug=False, vals=None, args_type=None):\n            funcs_template = dedent('''\n            def func(a, b):\n                # type: {args_type} -> {ret_type}\n                return math.{func}({args})\n            ''')\n            if num_args == 1:\n                args = \"a\"\n            elif num_args == 2:\n                args = \"a, b\"\n            else:\n                raise RuntimeError(\"Test doesn't support more than 2 arguments\")\n            if args_type is None:\n                args_type = \"(float, float)\" if is_float else \"(int, int)\"\n            funcs_str = funcs_template.format(func=func_name, args=args, args_type=args_type, ret_type=ret_type)\n            scope = {}\n            execWrapper(funcs_str, globals(), scope)\n            cu = torch.jit.CompilationUnit(funcs_str)\n            f_script = cu.func\n            f = scope['func']\n\n            if vals is None:\n                vals = float_vals if is_float else int_vals\n                vals = [(i, j) for i in vals for j in vals]\n\n            for a, b in vals:\n                res_python = None\n                res_script = None\n                try:\n                    res_python = f(a, b)\n                except Exception as e:\n                    res_python = e\n                try:\n                    res_script = f_script(a, b)\n                except Exception as e:\n                    res_script = e\n                if debug:\n                    print(\"in: \", a, b)\n                    print(\"out: \", res_python, res_script)\n                # We can't use assertEqual because of a couple of differences:\n                # 1. nan == nan should return true\n                # 2. When python functions throw an exception, we usually want to silently ignore them.\n                # (ie: We want to return `nan` for math.sqrt(-5))\n                if res_python != res_script:\n                    if isinstance(res_python, Exception):\n                        continue\n\n                    if type(res_python) == type(res_script):\n                        if isinstance(res_python, tuple) and (math.isnan(res_python[0]) == math.isnan(res_script[0])):\n                            continue\n                        if isinstance(res_python, float) and math.isnan(res_python) and math.isnan(res_script):\n                            continue\n                    msg = (\"Failed on {func_name} with inputs {a} {b}. Python: {res_python}, Script: {res_script}\"\n                           .format(func_name=func_name, a=a, b=b, res_python=res_python, res_script=res_script))\n                    self.assertEqual(res_python, res_script, msg=msg, atol=(1e-4) * max(abs(res_python), res_script), rtol=0)\n\n        unary_float_ops = [\"log\", \"log1p\", \"log10\", \"exp\", \"sqrt\", \"gamma\", \"lgamma\", \"erf\",\n                           \"erfc\", \"expm1\", \"fabs\", \"acos\", \"asin\", \"atan\", \"cos\", \"sin\", \"tan\",\n                           \"asinh\", \"atanh\", \"acosh\", \"sinh\", \"cosh\", \"tanh\", \"degrees\", \"radians\"]\n        binary_float_ops = [\"atan2\", \"fmod\", \"copysign\"]\n        for op in unary_float_ops:\n            checkMathWrap(op, 1)\n        for op in binary_float_ops:\n            checkMathWrap(op, 2)\n\n        checkMath(\"modf\", 1, ret_type=\"Tuple[float, float]\")\n        checkMath(\"frexp\", 1, ret_type=\"Tuple[float, int]\")\n        checkMath(\"isnan\", 1, ret_type=\"bool\")\n        checkMath(\"isinf\", 1, ret_type=\"bool\")\n        checkMath(\"ldexp\", 2, is_float=False, ret_type=\"float\", args_type=\"(float, int)\",\n                  vals=[(i, j) for i in float_vals for j in range(-10, 10)])\n        checkMath(\"pow\", 2, is_float=False, ret_type=\"float\")\n        checkMath(\"pow\", 2, is_float=True, ret_type=\"float\")\n        checkMathWrap(\"floor\", ret_type=\"int\")\n        checkMathWrap(\"ceil\", ret_type=\"int\")\n        checkMathWrap(\"gcd\", 2, is_float=False, ret_type=\"int\")\n        checkMath(\"isfinite\", 1, ret_type=\"bool\")\n        checkMathWrap(\"remainder\", 2)\n        checkMathWrap(\"factorial\", 1, is_float=False, ret_type=\"int\", vals=[(i, 0) for i in range(-2, 10)])\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_if_nest_while(self):\n        def func(a, b):\n            # type: (int, int) -> int\n            c = 0\n            if a > b:\n                while a > b:\n                    b = b + 1\n                    c = -b\n            return c\n\n        inputs = self._make_scalar_vars([4321, 1234], torch.int64)\n        self.checkScript(func, inputs)\n\n    def test_script_optional_none(self):\n        def none_stmt(x):\n            output = None\n            output = x\n            return output\n\n        def none_args(x):\n            # type: (Optional[Tensor]) -> Optional[Tensor]\n            return None\n\n        self.checkScript(none_stmt, [torch.arange(0, 2)], optimize=True)\n        self.checkScript(none_args, [None], optimize=True)\n\n        # test undefined tensor None as default param\n        def test_script_optional_tensor_none(x=None):\n            # type: (Optional[Tensor]) -> Tensor\n            res = torch.zeros(1, dtype=torch.int8)\n            if x is None:\n                res = res + 1\n            else:\n                res = x\n            return res\n\n        fn = test_script_optional_tensor_none\n        scripted_fn = torch.jit.script(fn)\n        self.assertEqual(fn(), scripted_fn())\n        self.assertEqual(fn(torch.zeros(1)), scripted_fn(torch.zeros(1)))\n\n        # test typical None as default param\n        def test_script_optional_other_none(x=None):\n            # type: (Optional[float]) -> float\n            res = 2.0\n            if x is None:\n                res = res + 1.0\n            else:\n                res = x\n            return res\n\n        fn = test_script_optional_other_none\n        scripted_fn = torch.jit.script(fn)\n        self.assertEqual(fn(), scripted_fn())\n        self.assertEqual(fn(1.0), scripted_fn(1.0))\n\n    def test_script_clamp_none(self):\n        def test_script_clamp_max_none(x):\n            return torch.clamp(x, min=2, max=None)\n\n        def test_script_clamp_max(x):\n            return torch.clamp(x, max=2)\n\n        def test_script_clamp_min_none(x):\n            return torch.clamp(x, min=None, max=2)\n\n        def test_script_clamp_min(x):\n            return torch.clamp(x, min=2)\n\n        input = [torch.arange(0, 3)]\n        self.checkScript(test_script_clamp_max_none, input, optimize=True)\n        self.checkScript(test_script_clamp_max, input, optimize=True)\n        self.checkScript(test_script_clamp_min_none, input, optimize=True)\n        self.checkScript(test_script_clamp_min, input, optimize=True)\n\n    def test_script_bool_constant(self):\n        def test_script_bool_constant():\n            a = True\n            return a\n        self.checkScript(test_script_bool_constant, [])\n\n    def test_ternary(self):\n        def func(a, b):\n            c = 3\n            c = a + b if bool(a > 3) else b\n            return c\n\n        inputs_true = self._make_scalar_vars([5, 2], torch.int64)\n        inputs_false = self._make_scalar_vars([1, 0], torch.int64)\n        self.checkScript(func, inputs_true, optimize=True)\n        self.checkScript(func, inputs_false, optimize=True)\n\n    def test_ternary_module_type_hint(self):\n        class M1(torch.nn.Module):\n            def forward(self) -> Any:\n                return 'out' if self.training else {}\n\n        class M2(torch.nn.Module):\n            def forward(self) -> Any:\n                out: Any = 'out' if self.training else {}\n                return out\n\n        class M3(torch.nn.Module):\n            def forward(self) -> Optional[int]:\n                return None if self.training else 1\n\n        for module in [M1, M2, M3]:\n            self.checkModule(module().train(), ())\n            self.checkModule(module().eval(), ())\n\n    def test_ternary_static_if(self):\n        # Test for True branch when condition variable\n        # is annotated as Final\n        class M1(torch.nn.Module):\n            flag: torch.jit.Final[bool]\n\n            def __init__(self):\n                super().__init__()\n                self.flag = True\n\n            def forward(self) -> torch.Tensor:\n                return torch.ones(3) if self.flag else {}\n\n        # Test for True branch when condition variable\n        # is annotated as Final\n        class M2(torch.nn.Module):\n            flag: torch.jit.Final[bool]\n\n            def __init__(self):\n                super().__init__()\n                self.flag = False\n\n            def forward(self) -> torch.Tensor:\n                return {} if self.flag else torch.ones(3)\n\n        model1 = M1()\n        model2 = M2()\n        script_model_1 = torch.jit.script(model1)\n        script_model_2 = torch.jit.script(model2)\n        self.assertEqual(model1.forward(), script_model_1.forward())\n        self.assertEqual(model2.forward(), script_model_2.forward())\n\n    def test_ternary_right_associative(self):\n        def plus_123(x: int):\n            return x + 1 if x == 1 else x + 2 if x == 2 else x + 3\n        self.checkScript(plus_123, (1,))\n        self.checkScript(plus_123, (2,))\n        self.checkScript(plus_123, (3,))\n\n    def test_print(self):\n        def func(x, y):\n            q = (x + y).sigmoid()\n            print(q, 1, 2, [1, 2], [1.0, 2.0])\n            w = -q\n            return w * w\n\n        x = torch.arange(4., requires_grad=True)\n        y = torch.arange(0., 8, 2, requires_grad=True)\n        self.checkScript(func, [x, y], optimize=True, capture_output=True)\n\n    def test_format(self):\n        def func(x):\n            print(\"{}, I'm a {}\".format(\"Hello\", \"test\"))\n            print(\"format blank\".format())\n            print(\"stuff before {}\".format(\"hi\"))\n            print(\"{} stuff after\".format(\"hi\"))\n            return x + 1\n\n        x = torch.arange(4., requires_grad=True)\n        self.checkScript(func, [x], optimize=True, capture_output=True)\n\n    def test_logical_short_circuit(self):\n        @torch.jit.script\n        def testNoThrows(t):\n            c1 = 1\n            if (False and bool(t[1])) or (True or bool(t[1])):\n                c1 = 0\n            return c1\n\n        FileCheck().check_not(\"prim::If\").run(testNoThrows.graph)\n        self.assertEqual(0, testNoThrows(torch.randn(0)))\n        self.assertEqual(0, testNoThrows(torch.randn([2, 3])))\n\n        @torch.jit.script\n        def throwsOr(t):\n            c0 = False or bool(t[1])\n            print(c0)\n\n        @torch.jit.script\n        def throwsAnd(t):\n            c0 = True and bool(t[1])\n            print(c0)\n\n        t = torch.randn(0)\n        with self.assertRaisesRegex(RuntimeError, \"index 1 out of range for tensor of size\"):\n            throwsOr(t)\n        with self.assertRaisesRegex(RuntimeError, \"index 1 out of range for tensor of size\"):\n            throwsAnd(t)\n\n    def test_type_cast(self):\n        template = dedent('''\n        def func(v):\n            # type: ({from_type}) -> {to_type}\n            return {to_type}(v)\n        ''')\n\n        def check_cast(from_type, to_type, value, raises=False):\n            code = template.format(from_type=from_type, to_type=to_type)\n            self.checkScript(code, (value,))\n\n        check_cast('int', 'float', 1)\n        check_cast('int', 'bool', 1)\n        check_cast('int', 'bool', 0)\n\n        check_cast('float', 'int', 1.)\n        check_cast('float', 'bool', 1.)\n        check_cast('float', 'bool', 0.)\n\n        check_cast('bool', 'int', True)\n        check_cast('bool', 'float', True)\n\n    def test_multiple_assignment(self):\n        def outer_func(x):\n            return x * 2, x + 2\n\n        @torch.jit.script\n        def func(x):\n            y, z = outer_func(x)\n            return y + z\n\n        x = torch.arange(4)\n        self.assertEqual(func(x), x * 2 + x + 2)\n\n    def test_literals(self):\n        def func(a):\n            return a.view(size=[1, 2, 3])\n\n        a = torch.randn(6)\n        self.checkScript(func, [a], optimize=True)\n\n    def test_return(self):\n        def no_return(a):\n            a + 1\n\n        def void_return(a):\n            return\n\n        def one_return(a):\n            return a + 1.\n\n        def multiple_returns(a):\n            return a * 1., a * 2., a * 3.\n\n        a = torch.randn(1, dtype=torch.float)\n        self.checkScript(no_return, [a], optimize=True)\n        self.checkScript(void_return, [a], optimize=True)\n        self.checkScript(one_return, [a], optimize=True)\n        self.checkScript(multiple_returns, [a], optimize=True)\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all paths\"):\n            torch.jit.CompilationUnit('''\n            def no_return_bad_annotation(a):\n                # type: (Tensor) -> Tensor\n                a + 1\n            ''')\n\n    def test_error(self):\n        @torch.jit.script\n        def foo(a):\n            return a.t()\n        s = Variable(torch.rand(5, 5, 5))\n        # XXX: this should stay quiet in stay propagation and only fail in the interpreter\n        with self.assertRaisesRegex(RuntimeError, \"failed in the TorchScript interpreter\"):\n            foo(s)\n\n        @torch.jit.script\n        def bar(c, b):\n            return c + b\n\n        with self.assertRaisesRegex(RuntimeError, \"failed in the TorchScript interpreter\"):\n            bar(Variable(torch.rand(10), requires_grad=True), Variable(torch.rand(9), requires_grad=True))\n\n    def test_error_stacktrace(self):\n        @torch.jit.script\n        def baz(c, b):\n            return c + b\n\n        @torch.jit.script\n        def foo(c, b):\n            return baz(c, b)\n\n        @torch.jit.script\n        def bar(c, b):\n            return foo(c, b)\n\n        with self.assertRaises(RuntimeError) as cm:\n            bar(torch.rand(10), torch.rand(9))\n        FileCheck().check(\"The following operation failed in the TorchScript interpreter\") \\\n                   .check(\"Traceback\") \\\n                   .check(\"in foo\").check(\"in baz\").run(str(cm.exception))\n\n    def test_error_stacktrace_interface(self):\n        @torch.jit.script\n        def baz(c, b):\n            return c + b\n\n        @torch.jit.script\n        def foo(c, b):\n            return baz(c, b)\n\n        @torch.jit.script\n        def bar(c, b):\n            return foo(c, b)\n\n        @torch.jit.script\n        class Bar(object):\n            def one(self, x, y):\n                return bar(x, y)\n\n        @torch.jit.interface\n        class IFace(object):\n            def one(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                pass\n\n        make_global(IFace)\n\n        @torch.jit.script\n        def as_interface(x):\n            # type: (IFace) -> IFace\n            return x\n\n        f = as_interface(Bar())\n\n        with self.assertRaises(RuntimeError) as cm:\n            x = f.one(torch.rand(10), torch.rand(9))\n            bar(torch.rand(10), torch.rand(9))\n        FileCheck().check(\"The following operation failed in the TorchScript interpreter\") \\\n                   .check(\"Traceback\") \\\n                   .check(\"in foo\").check(\"in baz\").run(str(cm.exception))\n\n    def test_operator_precedence(self):\n        def double(x):\n            # type: (int) -> int\n            return 2 * x\n\n        def complicated_arithmetic_operation():\n            # TODO we need to test exponent operator '**' and bitwise not\n            # operator '~' once they are properly supported.\n            list = [0, 1, 2, 3]\n            result = list[1:3][0] + double(4) + (-3 + 8) * 6 // 2 % 4 << 2 + 1 >> 1 | 23 & 16 + 3 ^ 4\n            return result\n\n        self.checkScript(complicated_arithmetic_operation, ())\n\n    def test_in_operator_with_two_strings(self):\n        def fn() -> bool:\n            return \"a\" in \"abcd\"\n        self.checkScript(fn, ())\n\n    def test_bitwise_ops(self):\n\n        def int_test():\n            return 2 & 3, 2 ^ 3, 2 | 3, 2 << 3, 2 >> 3\n\n        self.checkScript(int_test, ())\n\n        def bool_test(x, y):\n            # type: (bool, bool) -> Tuple[bool, bool, bool]\n            return x & y, x ^ y, x | y\n\n        self.checkScript(bool_test, (True, False))\n        self.checkScript(bool_test, (True, True))\n\n        def tensor_test(x, y):\n            return x & y, x ^ y, x | y\n\n        def tensor_with_int_test(x, y):\n            # type: (Tensor, int) -> Tuple[Tensor, Tensor]\n            return x << y, x >> y\n\n        x = torch.tensor(2)\n        y = torch.tensor(3)\n\n        self.checkScript(tensor_test, (x, y))\n        self.checkScript(tensor_with_int_test, (x, 2))\n\n        def not_test(x):\n            return ~x\n\n        self.checkScript(not_test, (torch.tensor([2, 4]), ))\n\n    def test_all(self):\n        @torch.jit.script\n        def test_all_tensor(x):\n            return all(x)\n        self.assertFalse(test_all_tensor(torch.tensor([1, 0, 3], dtype=torch.uint8)))\n        self.assertTrue(test_all_tensor(torch.tensor([3.14, 3, 99], dtype=torch.uint8)))\n        self.assertTrue(test_all_tensor(torch.tensor([True, True], dtype=torch.uint8)))\n        self.assertFalse(test_all_tensor(torch.tensor([True, False], dtype=torch.uint8)))\n\n        @torch.jit.script\n        def test_all_bool_list(x):\n            # type: (List[bool]) -> bool\n            return all(x)\n        self.assertTrue(test_all_bool_list([True, True]))\n        self.assertTrue(test_all_bool_list([True, 1]))\n        self.assertFalse(test_all_bool_list([True, False]))\n        self.assertFalse(test_all_bool_list([True, 0]))\n        self.assertFalse(test_all_bool_list([False, 0]))\n        self.assertTrue(test_all_bool_list([]))\n\n        @torch.jit.script\n        def test_all_int_list(x):\n            # type: (List[int]) -> bool\n            return all(x)\n        self.assertTrue(test_all_int_list([3, 6]))\n        self.assertFalse(test_all_int_list([2, 0]))\n\n        @torch.jit.script\n        def test_all_float_list(x):\n            # type: (List[float]) -> bool\n            return all(x)\n        self.assertTrue(test_all_float_list([3.14, 8.1]))\n        self.assertFalse(test_all_float_list([3.14, 0, 8.9]))\n\n\n    def test_number_math(self):\n        ops_template = dedent('''\n        def func():\n            return {scalar1} {op} {scalar2}\n        ''')\n        ops = ['+', '-', '*', '%', '<', '<=', '>', '>=', '==', '!=', '//']\n        funcs_template = dedent('''\n        def func():\n            return {func}({scalar1}, {scalar2})\n        ''')\n        funcs = ['min', 'max']\n        scalars = ['7', '2', '3', '-3', '3.14', '0.125', '-0.5', '2.0', '-2.0']\n        scalar_pairs = [(scalar1, scalar2) for scalar1 in scalars for scalar2 in scalars]\n\n        def run_test(code):\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n\n            self.assertEqual(cu.func(), scope['func']())\n\n        for scalar1, scalar2 in scalar_pairs:\n            for op in ops:\n                code = ops_template.format(op=op, scalar1=scalar1, scalar2=scalar2)\n                run_test(code)\n            for func in funcs:\n                code = funcs_template.format(func=func, scalar1=scalar1, scalar2=scalar2)\n                run_test(code)\n\n        # test Scalar overloads\n        for scalar1, scalar2 in scalar_pairs:\n            item1 = 'torch.tensor(' + scalar1 + ').item()'\n            item2 = 'torch.tensor(' + scalar2 + ').item()'\n            for op in ops:\n                code = ops_template.format(op=op, scalar1=item1, scalar2=scalar2)\n                run_test(code)\n                code = ops_template.format(op=op, scalar1=scalar1, scalar2=item2)\n                run_test(code)\n                code = ops_template.format(op=op, scalar1=item1, scalar2=item2)\n                run_test(code)\n            for func in funcs:\n                code = funcs_template.format(func=func, scalar1=item1, scalar2=scalar2)\n                run_test(code)\n                code = funcs_template.format(func=func, scalar1=scalar1, scalar2=item2)\n                run_test(code)\n                code = funcs_template.format(func=func, scalar1=item1, scalar2=item2)\n                run_test(code)\n\n    def test_number_abs(self):\n        def func1(x):\n            # type: (float) -> float\n            return abs(x)\n\n        def func2(x):\n            # type: (int) -> int\n            return abs(x)\n\n        def func3(x):\n            return abs(x)\n\n        self.checkScript(func1, (-3.14,))\n        self.checkScript(func1, (3.14,))\n        self.checkScript(func2, (-10,))\n        self.checkScript(func2, (10,))\n        self.checkScript(func3, (torch.tensor([-5, -10, -20]),))\n        self.checkScript(func3, (torch.tensor([5, 10, 20]),))\n        self.checkScript(func3, (torch.tensor([-5, 10, -20]),))\n\n    def test_number_div(self):\n        self.assertEqual(div_int_future(), torch.jit.script(div_int_future)())\n        self.checkScript(div_float_future, ())\n\n        self.checkScript(div_int_nofuture, ())\n        self.checkScript(div_float_nofuture, ())\n\n    # Testing bitwise shorthand aug assignment\n    def test_bool_augassign_bitwise_or(self):\n        def func(a: bool, b: bool) -> bool:\n            a |= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_bool_augassign_bitwise_and(self):\n        def func(a: bool, b: bool) -> bool:\n            a &= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_bool_augassign_bitwise_xor(self):\n        def func(a: bool, b: bool) -> bool:\n            a ^= b\n            return a\n\n        self.checkScript(func, (True, False), optimize=True)\n        self.checkScript(func, (True, True), optimize=True)\n        self.checkScript(func, (False, False), optimize=True)\n        self.checkScript(func, (False, True), optimize=True)\n\n    def test_number_augassign_bitwise_lshift(self):\n        def func() -> int:\n            z = 8\n            z <<= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign_bitwise_rshift(self):\n        def func() -> int:\n            z = 8\n            z >>= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign_bitwise_pow(self):\n        def func() -> float:\n            z = 8\n            z **= 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_number_augassign(self):\n        def func():\n            z = 1\n            z += 2\n            return z\n\n        self.checkScript(func, (), optimize=True)\n\n    def test_nested_select_assign(self):\n        class SubSubModule(torch.nn.Module):\n            def __init__(self):\n                super(SubSubModule, self).__init__()\n                self.abc = 11\n\n            def forward(self, x):\n                return self.abc\n\n        class SubModule(torch.nn.Module):\n            def __init__(self):\n                super(SubModule, self).__init__()\n                self.a = 11\n                self.nested = SubSubModule()\n\n            def forward(self, x):\n                return self.a\n\n        class TestModule(torch.nn.Module):\n            def __init__(self):\n                super(TestModule, self).__init__()\n                self.sub = SubModule()\n                self.hi = 1\n\n            def forward(self):\n                self.hi = 5\n                self.sub.a = 1\n                self.sub.nested.abc = 5\n                return self.sub.a * 20 + self.sub.nested.abc * 3 + self.hi\n\n        self.checkModule(TestModule(), ())\n\n    def test_number_neg(self):\n        # int -> int\n        def func1():\n            return -8\n\n        # float -> float\n        def func2():\n            return -3.14\n\n        self.checkScript(func1, (), optimize=True)\n        self.checkScript(func2, (), optimize=True)\n\n    def test_compare_two_bool_inputs(self):\n        def compare_eq(a: bool, b: bool):\n            return a == b\n\n        def compare_ne(a: bool, b: bool):\n            return a != b\n\n        scripted_fn_eq = torch.jit.script(compare_eq)\n        scripted_fn_ne = torch.jit.script(compare_ne)\n        self.assertEqual(scripted_fn_eq(True, False), compare_eq(True, False))\n        self.assertEqual(scripted_fn_eq(False, True), compare_eq(False, True))\n        self.assertEqual(scripted_fn_eq(True, True), compare_eq(True, True))\n        self.assertEqual(scripted_fn_eq(False, False), compare_eq(False, False))\n\n        self.assertEqual(scripted_fn_ne(True, False), compare_ne(True, False))\n        self.assertEqual(scripted_fn_ne(False, True), compare_ne(False, True))\n        self.assertEqual(scripted_fn_ne(True, True), compare_ne(True, True))\n        self.assertEqual(scripted_fn_ne(False, False), compare_ne(False, False))\n\n\n    def _test_tensor_number_math(self, device='cpu'):\n        template = dedent('''\n        def func(t):\n            return {lhs} {op} {rhs}\n        ''')\n\n        def test(op, tensor, const, swap_args, template=template):\n            args = ('t', const)\n            if swap_args:\n                args = (const, 't')\n\n            code = template.format(lhs=args[0], rhs=args[1], op=op)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            message = 'with code `{} {} {}` and t={}'.format(args[0], op, args[1], tensor)\n            res1 = cu.func(tensor)\n            res2 = scope['func'](tensor)\n            self.assertEqual(res1, res2, msg=message + \"\\nres1=\" + str(res1) + \"\\nres2=\" + str(res2))\n            self.assertEqual(res1.dtype, res2.dtype, msg=message + \"\\nres1=\" + str(res1) + \"\\nres2=\" + str(res2))\n\n        var_int = [2, -2]\n        var_float = [1.4321, -1.2]\n\n        ops = ['+', '-', '*', '%', '<', '<=', '>', '>=', '==', '!=', '/']\n\n        float_tensor = torch.randn(5, 5, device=device)\n        double_tensor = torch.randn(5, 5, dtype=torch.double, device=device)\n        long_tensor = torch.randint(-5, 5, (5, 5), dtype=torch.long, device=device)\n        long_tensor[long_tensor == 0] = 2\n\n        tensors = [float_tensor, double_tensor, long_tensor]\n        consts = var_int + var_float\n\n        for op, tensor, const, swap_args in product(ops, tensors, consts, [True, False]):\n            # FIXME: things like 2 / long_tensor are not implemented correctly\n            # Look in torch/_tensor.py to see how pytorch implements it.\n            if op == '/' and tensor.data_ptr() == long_tensor.data_ptr():\n                continue\n\n            # % operator does not take: const % tensor\n            if op == '%' and swap_args is True:\n                continue\n\n            test(op, tensor, const, swap_args)\n\n    def test_tensor_number_math(self):\n        self._test_tensor_number_math()\n\n    def test_torch_tensor_bad_input(self):\n        with self.assertRaisesRegex(RuntimeError, \"must be of ints, floats, \"\n                                    \"or bools, got None\"):\n            @torch.jit.script\n            def test():\n                return torch.tensor([None])\n            test()\n\n        with self.assertRaisesRegex(RuntimeError, r\"Empty lists default to List\\[Tensor\\]\"):\n            @torch.jit.script\n            def tmp():\n                return torch.tensor([])\n            tmp()\n\n        @torch.jit.script\n        def foo():\n            return torch.tensor([[2, 2], [1]])\n        with self.assertRaisesRegex(RuntimeError, \"Expected sequence of length\"):\n            foo()\n\n    @suppress_warnings\n    def test_torch_tensor_as_tensor_empty_list(self):\n        tensor_template = dedent('''\n        def func():\n            empty_list = torch.jit.annotate(List[int], [])\n            ten1 = torch.{tensor_op}({input})\n            return ten1\n        ''')\n        ops = ['tensor', 'as_tensor']\n        inputs = ['empty_list', '[empty_list, empty_list]', '[[[empty_list]]]']\n\n        for op in ops:\n            for inp in inputs:\n                code = tensor_template.format(tensor_op=op, input=inp)\n                scope = {}\n                exec(code, globals(), scope)\n                cu = torch.jit.CompilationUnit(code)\n                t1 = cu.func()\n                t2 = scope['func']()\n                if inp == 'empty_list':\n                    # torchscript returns int tensor, python returns float tensor\n                    self.assertNotEqual(t1.dtype, t2.dtype)\n                self.assertEqual(t1, t2, exact_dtype=False)\n                self.assertEqual(t1.device, t2.device)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"Simple Executor doesn't have any shapes to propagate\")\n    def test_tensor_as_tensor_shape_prop(self):\n        tensor_template = dedent('''\n        def func():\n            return torch.{tensor_op}({input})\n        ''')\n        ops = ['tensor', 'as_tensor']\n        inputs = ['[1]', '[False]', '[2.5]', '0.5', '1', 'False', '[[1]]', 'torch.jit.annotate(List[List[int]], [])']\n        expected_shape = [\"Long(*, device=cpu)\", \"Bool(*, device=cpu)\",\n                          \"Double(*, device=cpu)\", \"Double(device=cpu)\",\n                          \"Long(device=cpu)\", \"Bool(device=cpu)\", \"Long(*, *, device=cpu)\"]\n\n        for op in ops:\n            for inp, expect in zip(inputs, expected_shape):\n                code = tensor_template.format(tensor_op=op, input=inp)\n                scope = {}\n                exec(code, globals(), scope)\n                cu = torch.jit.CompilationUnit(code)\n                torch._C._jit_pass_complete_shape_analysis(cu.func.graph, (), False)\n                FileCheck().check(expect).check(\"aten::{tensor_op}\".format(tensor_op=op)).run(cu.func.graph)\n\n        @torch.jit.script\n        def test_dtype(inp_dtype: torch.dtype):\n            a = torch.tensor(1.0, dtype=torch.float, requires_grad=True)\n            return a, torch.tensor(1.0, dtype=inp_dtype)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            g = test_dtype.graph_for(5, profile_and_replay=True)\n            # both should have completed shapes\n            FileCheck().check(\"Tensor = aten::tensor\").check(\"Float(device=cpu) = prim::BailOut\") \\\n                       .check(\"Tensor = aten::tensor\").check(\"Half(device=cpu) = prim::BailOut\").run(g)\n        else:\n            g = test_dtype.graph_for(5)\n            # first should have type set second should not\n            FileCheck().check(\"Float(requires_grad=1, device=cpu) = aten::tensor\") \\\n                       .check(\"Tensor(requires_grad=0) = aten::tensor\").run(g)\n\n        @torch.jit.script\n        def test_as_tensor_tensor_input(input):\n            a = torch.as_tensor(input, dtype=input.dtype)\n            return a, torch.as_tensor(input, dtype=torch.float)\n\n        if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n            g = test_as_tensor_tensor_input.graph_for(torch.ones(3, 4), profile_and_replay=True)\n            FileCheck().check(\"Tensor = aten::as_tensor\").check(\"Float(3, 4) = prim::BailOut\") \\\n                       .check(\"Tensor = aten::as_tensor\").check(\"Float(3, 4) = prim::BailOut\").run(g)\n        else:\n            g = test_as_tensor_tensor_input.graph_for(torch.ones(3, 4))\n            FileCheck().check(\"Tensor = aten::as_tensor\").check(\"Float(*, *, requires_grad=0, device=cpu) = aten::as_tensor\").run(g)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"testing legacy behavior\")\n    def test_tensor_requires_grad(self):\n        @torch.jit.script\n        def test(b):\n            # type: (bool) -> Tuple[Tensor, Tensor, Tensor]\n            a = torch.tensor(1., requires_grad=b)\n            b = torch.tensor(1., requires_grad=True)\n            c = torch.tensor(1., requires_grad=False)\n            return a, b, c\n\n        g = test.graph_for(True)\n        out = next(g.outputs())\n        out_inp = list(out.node().inputs())\n\n        self.assertTrue(out_inp[0].requires_grad())\n        self.assertTrue(out_inp[1].requires_grad())\n        self.assertFalse(out_inp[2].requires_grad())\n\n    def test_grad_from_script(self):\n        def test():\n            a = torch.tensor(2.5, requires_grad=True)\n            b = a * 2\n            return a, b\n\n        a, b = test()\n        b.backward()\n\n        a_script, b_script = torch.jit.script(test)()\n        b_script.backward()\n        self.assertEqual(a.grad, a_script.grad)\n\n    def test_torch_tensor_as_tensor(self):\n        tensor_template = dedent('''\n        def func():\n            li = {list_create}\n            ten1 = torch.{tensor_op}(li {options})\n            return ten1\n        ''')\n\n        lists = [\"2.5\", \"4\", \"True\", \"False\", \"[2]\", \"[-.5]\", \"[False, True, False]\", \"[2, 2]\", \"(1, 1)\",\n                 \"torch.jit.annotate(List[List[int]], [])\",\n                 \"torch.jit.annotate(List[int], [])\", \"[2.5, 2.5]\", \"[[2], [2]]\", \"[[-.5], [2.2]]\", \"[[False], [True]]\"]\n\n        dtypes = [\"\", \", dtype=torch.float\", \", dtype=torch.double\", \", dtype=torch.half\",\n                  \", dtype=torch.uint8\", \", dtype=torch.int8\", \", dtype=torch.short\",\n                  \", dtype=torch.int\", \", dtype=torch.long\", \", dtype=torch.cfloat\",\n                  \", dtype=torch.cdouble\"]\n\n        ops = ['tensor', 'as_tensor']\n        devices = ['', \", device='cpu'\"]\n        if RUN_CUDA:\n            devices.append(\", device='cuda'\")\n\n        option_pairs = [dtype + device for dtype in dtypes for device in devices]\n        for op in ops:\n            for li in lists:\n                for option in option_pairs:\n                    # tensor from empty list is type float in python and annotated type in torchscript\n                    if \"annotate\" in li and \"dtype\" not in option:\n                        continue\n                    # Skip unsigned tensor initializaton for signed values on 3.10\n                    if sys.version_info[:2] >= (3, 10) and \"torch.uint8\" in option and \"-\" in li:\n                        continue\n                    code = tensor_template.format(list_create=li, tensor_op=op, options=option)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    cu = torch.jit.CompilationUnit(code)\n                    t1 = cu.func()\n                    t2 = scope['func']()\n                    if t1.dtype == torch.float16:  # equality NYI for half tensor\n                        self.assertTrue(str(t1) == str(t2))\n                    else:\n                        self.assertEqual(t1, t2)\n                    self.assertEqual(t1.dtype, t2.dtype)\n                    self.assertEqual(t1.device, t2.device)\n\n        def test_as_tensor_tensor_input(input):\n            # type: (Tensor) -> Tuple[Tensor, Tensor, Tensor]\n            return torch.as_tensor(input, dtype=torch.cfloat), torch.as_tensor(input, dtype=torch.float), \\\n                torch.as_tensor(input, dtype=torch.int32)\n\n        inp = torch.randn(3, 4, dtype=torch.cfloat)\n        self.checkScript(test_as_tensor_tensor_input, (inp,))\n\n    def test_torch_tensor_dtype(self):\n        def foo(s: float):\n            return torch.tensor(s), torch.tensor([s, s])\n\n        # need to clear function cache so we re run shape analysis\n        with set_default_dtype(torch.double):\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Double\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n        with set_default_dtype(torch.float):\n            del torch.jit._state._jit_caching_layer[foo]\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Float\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n        with set_default_dtype(torch.half):\n            del torch.jit._state._jit_caching_layer[foo]\n            self.assertEqual(torch.jit.script(foo)(1.), foo(1.), exact_dtype=True)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                FileCheck().check(\"Half\").check_same(\"aten::tensor\").run(torch.jit.last_executed_optimized_graph())\n\n    def test_shape_analysis_grad_property(self):\n        @torch.jit.script\n        def foo(x):\n            return torch.sub(x, torch.tanh(x))\n\n        torch._C._jit_pass_complete_shape_analysis(foo.graph, (torch.tensor([0.39]),), False)\n\n        # requires_grad property shouldn't be accidentally set by shape analysis\n        self.assertTrue(foo.graph.findNode(\"aten::sub\").output().requiresGrad() is None)\n\n    def test_empty_like_memory_format_bc(self):\n        def f(x):\n            # type: (Tensor) -> Tensor\n            return torch.zeros_like(x, memory_format=None)\n\n        scripted_f = torch.jit.script(f)\n        x = torch.rand(3, 4)\n        self.assertEqual(scripted_f(x), f(x))\n\n    def test_multiline_string_dedents(self):\n        def foo() -> None:\n            multiline_string_dedent_1 = \"\"\"\nThis is a string dedent \"\"\"\n            multiline_string_dedent_2 = \"\"\" This is a\n  string dedent \"\"\"\n            multiline_string_dedent_3 = \"\"\"\n            This is a string\ndedent \"\"\"\n            multiline_string_dedent_4 = \"\"\" This is a string dedent \"\"\"\n\n        scripted_foo = torch.jit.script(foo)\n        self.assertEqual(scripted_foo(), foo())\n\n    def test_class_with_comment_at_lower_indentation(self):\n        class Foo(torch.nn.Module):\n            def forward(self, x):\n                x = torch.neg(x)\n        # This comment is at the wrong indent\n                return x\n\n        torch.jit.script(Foo())\n\n    # adapted from test in test_torch\n    def test_tensor_to(self):\n        template = dedent('''\n        def func(t):\n            cuda = \"{cuda}\"\n            device = \"{device}\"\n            non_blocking = {non_blocking}\n            return {to_str}\n        ''')\n\n        def s(t, to_str, non_blocking=None, device=None, cuda=None):\n            device = device if device is not None else str(t.device)\n            non_blocking = non_blocking if non_blocking is not None else False\n            cuda = \"cuda\" if cuda is None else cuda\n            code = template.format(to_str=to_str, device=device, non_blocking=non_blocking, cuda=cuda)\n            scope = {}\n            cu = torch.jit.CompilationUnit(code)\n            return cu.func(t, profile_and_replay=True)\n\n        def test_copy_behavior(t, non_blocking=False):\n            self.assertIs(t, s(t, 't.to(t, non_blocking=non_blocking)', non_blocking))\n            self.assertIs(t, s(t, 't.to(t.dtype, non_blocking=non_blocking)', non_blocking))\n            self.assertIs(t, s(t, 't.to(torch.empty_like(t), non_blocking=non_blocking)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(t, non_blocking=non_blocking, copy=True)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(t.dtype, non_blocking=non_blocking, copy=True)', non_blocking))\n            self.assertIsNot(t, s(t, 't.to(torch.empty_like(t), non_blocking=non_blocking, copy=True)', non_blocking))\n\n            devices = [t.device]\n            if t.device.type == 'cuda':\n                if t.device.index == -1:\n                    devices.append('cuda:{}'.format(torch.cuda.current_device()))\n                elif t.device.index == torch.cuda.current_device():\n                    devices.append('cuda')\n            for device in devices:\n                self.assertIs(t, s(t, 't.to(device, non_blocking=non_blocking)', non_blocking, device))\n                self.assertIs(t, s(t, 't.to(device, t.dtype, non_blocking=non_blocking)', non_blocking, device))\n                self.assertIsNot(t, s(t, 't.to(device, non_blocking=non_blocking, copy=True)', non_blocking, device))\n                self.assertIsNot(t, s(t, 't.to(device, t.dtype, non_blocking=non_blocking, copy=True)',\n                                      non_blocking, device))\n\n        t = torch.tensor(5)\n        test_copy_behavior(t)\n\n        self.assertEqual(t.device, s(t, \"t.to('cpu')\").device)\n        self.assertEqual(t.device, s(t, \"t.to('cpu', dtype=torch.float32)\").device)\n        self.assertIs(torch.float32, s(t, \"t.to('cpu', dtype=torch.float32)\").dtype)\n        self.assertEqual(t.device, s(t, \"t.to(torch.float32)\").device)\n        self.assertIs(torch.float32, s(t, \"t.to(dtype=torch.float32)\").dtype)\n        self.assertEqual(t.data_ptr(), s(t, \"t.to('cpu')\").data_ptr())\n        self.assertEqual(t.data_ptr(), s(t, \"t.to(dtype=t.dtype, device=t.device, copy=False)\").data_ptr())\n        self.assertEqual(t.data_ptr(), s(t, \"t.to('cpu', copy=False)\").data_ptr())\n        self.assertNotEqual(t.data_ptr(), s(t, \"t.to('cpu', copy=True)\").data_ptr())\n\n        a = torch.tensor(5)\n        if torch.cuda.is_available():\n            for non_blocking in [True, False]:\n                for cuda in ['cuda', 'cuda:0' if torch.cuda.device_count() == 1 else 'cuda:1']:\n                    b = torch.tensor(5., device=cuda)\n                    test_copy_behavior(b, non_blocking)\n                    self.assertEqual(b.device, s(b, \"t.to(cuda, non_blocking=non_blocking).device\", cuda=cuda))\n                    self.assertEqual(a.device, s(b, \"t.to('cpu', non_blocking=non_blocking).device\"))\n                    self.assertEqual(b.device, s(b, \"t.to(cuda, non_blocking=non_blocking).device\", cuda=cuda))\n                    self.assertIs(torch.int32, s(b, \"t.to('cpu', dtype=torch.int32, non_blocking=non_blocking)\").dtype)\n                    self.assertEqual(a.device, s(b, \"t.to('cpu', dtype=torch.int32, non_blocking=non_blocking)\").device)\n                    self.assertIs(torch.int32, s(b, \"t.to(dtype=torch.int32)\").dtype)\n                    self.assertEqual(b.device, s(b, \"t.to(dtype=torch.int32)\").device)\n\n        # Test AD: aten::to(Tensor self, int dtype, bool non_blocking, bool copy) -> Tensor\n        t = torch.tensor(5).float().requires_grad_()\n        out_ref = t.to(torch.float32)\n        out = s(t, \"t.to(torch.float32)\")\n        self.assertEqual(out_ref, out)\n\n        grad_ref = torch.autograd.grad(out_ref.sum(), t)\n        grad = torch.autograd.grad(out.sum(), t)\n        self.assertEqual(grad_ref, grad)\n\n        # Test AD: aten::to(Tensor self, Device? device, int? dtype, bool non_blocking, bool copy) -> Tensor\n        out_ref = t.to('cpu')\n        out = s(t, \"t.to('cpu')\")\n        self.assertEqual(out_ref, out)\n\n        grad_ref = torch.autograd.grad(out_ref.sum(), t)\n        grad = torch.autograd.grad(out.sum(), t)\n        self.assertEqual(grad_ref, grad)\n\n        # Test AD: aten::to(Tensor self, Tensor other, bool non_blocking, bool copy) -> Tensor\n        @torch.jit.script\n        def func2(t, t_ref):\n            return t.to(t_ref)\n\n        with disable_autodiff_subgraph_inlining():\n            t_ref = torch.tensor(4).double()\n            out_ref = t.to(t_ref)\n            out = func2(t, t_ref)\n            grad_ref = torch.autograd.grad(out_ref.sum(), t)\n            grad = torch.autograd.grad(out.sum(), t)\n            self.assertEqual(grad_ref, grad)\n\n    @unittest.skipIf(not RUN_CUDA, \"No CUDA\")\n    def test_tensor_number_math_cuda(self):\n        self._test_tensor_number_math(device='cuda')\n\n    def test_not(self):\n        # test not operator in python\n        # TODO: add more tests when bool conversions ready\n        def test_not_op(a):\n            return not bool(a > 1)\n\n        self.checkScript(test_not_op, (torch.tensor(2), ), optimize=True)\n\n    def test_is_isnot(self):\n        # test is and is not operator in python\n        template = dedent('''\n        def func():\n            # type: () -> bool\n            return {lhs} {op} {rhs}\n        ''')\n\n        def test(op, args):\n            code = template.format(lhs=args[0], rhs=args[1], op=op)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            self.assertEqual(\n                cu.func(),\n                scope['func'](),\n                msg=\"Failed with op: {}, lhs: {}, rhs: {}\"\n                .format(op, args[0], args[1])\n            )\n\n        ops = ['is', 'is not']\n        type_literals = [True, False, None, [1, 1], 1, 2, .5, 1.5]\n\n        # do literals product to try any types combinations\n        for op, lhs, rhs in product(ops, type_literals, type_literals):\n            test(op, [lhs, rhs])\n\n    def test_isinstance_refinement(self):\n        @torch.jit.script\n        def foo(a):\n            # type: (Optional[int]) -> int\n            if isinstance(a, int):\n                return a + 3\n            else:\n                return 4\n        self.assertEqual(foo(4), 7)\n        self.assertEqual(foo(None), 4)\n\n        @torch.jit.script\n        def foo2(a, b):\n            # type: (Optional[int], Optional[int]) -> int\n            if not isinstance(a, int) or not isinstance(b, int):\n                return 0\n            else:\n                return a + b\n        self.assertEqual(foo2(3, 4), 7)\n        self.assertEqual(foo2(None, 4), 0)\n        self.assertEqual(foo2(4, None), 0)\n\n        @torch.jit.script\n        def any_refinement(a, b):\n            # type: (Any, Any) -> int\n            if isinstance(a, int) and isinstance(b, int):\n                return a + b\n            return 0\n\n        self.assertEqual(any_refinement(3, 4), 7)\n        self.assertEqual(any_refinement(3, \"hi\"), 0)\n\n        @torch.jit.script\n        def any_refinement2(a):\n            # type: (Any) -> Tensor\n            if isinstance(a, Tensor):\n                return a\n            return torch.tensor(3)\n\n        self.assertEqual(any_refinement2(3), torch.tensor(3))\n        self.assertEqual(any_refinement2(torch.tensor(5)), torch.tensor(5))\n\n    @unittest.skipIf(GRAPH_EXECUTOR == ProfilingMode.LEGACY, \"bug persists in deprecated executor\")\n    def test_unspecialized_any_binding(self):\n        # any binding will infer the type, if it infers\n        # a specialized tensor type `x` Dict type will fail isinstance check\n\n        @torch.jit.script\n        def foo(x: Any):\n            assert isinstance(x, Dict[str, torch.Tensor])\n\n        foo({\"1\": torch.tensor(3)})\n        with self.assertRaises(Exception):\n            foo(2)\n\n    def test_isinstance(self):\n        # test isinstance operator for static type checking\n        template = dedent('''\n        def func(x):\n            # type: ({type_hint}) -> bool\n            return isinstance(x, {typ})\n        ''')\n\n        def test(inp, typ, type_hint):\n            code = template.format(typ=typ, type_hint=type_hint)\n            scope = {}\n            execWrapper(code, globals(), scope)\n            cu = torch.jit.CompilationUnit(code)\n            self.assertEqual(\n                cu.func(inp),\n                scope['func'](inp),\n                msg=\"Failed with typ: {}\"\n                .format(typ)\n            )\n\n        inputs = [True, 1, 1.0, torch.tensor(1), [1, 2], (1.0,), [1, 2], 1]\n        type_literals = ['bool', 'int', 'float', 'torch.Tensor', 'list', 'tuple',\n                         '(list, tuple)', '(int, float, bool)']\n        type_annotations = ['bool', 'int', 'float', 'Tensor', 'List[int]', 'Tuple[float]',\n                            'List[int]', 'int']\n\n        # do zipping to try different types\n        for inp, typ, type_hint in zip(inputs, type_literals, type_annotations):\n            test(inp, typ, type_hint)\n\n        # test optional isinstance check\n        @torch.jit.script\n        def opt_func(x):\n            # type: (Optional[int]) -> bool\n            return isinstance(x, int)\n        self.assertTrue(opt_func(3))\n        self.assertFalse(opt_func(None))\n\n    def test_dropout_eval(self):\n        class ScriptedConv2d(torch.jit.ScriptModule):\n            def __init__(self, in_channels, out_channels, **kwargs):\n                super(ScriptedConv2d, self).__init__()\n                self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\n                self.bn = nn.BatchNorm2d(out_channels, eps=0.001)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return F.relu(x, inplace=True)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.Conv2d_1a_3x3 = ScriptedConv2d(3, 32, kernel_size=3, stride=2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                x = self.Conv2d_1a_3x3(x)\n                return F.dropout(x, training=self.training)\n\n        class EagerConv2d(torch.nn.Module):\n            def __init__(self, in_channels, out_channels, **kwargs):\n                super(EagerConv2d, self).__init__()\n                self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\n                self.bn = nn.BatchNorm2d(out_channels, eps=0.001)\n\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.bn(x)\n                return F.relu(x, inplace=True)\n\n        class EagerMod(torch.nn.Module):\n            def __init__(self):\n                super(EagerMod, self).__init__()\n                self.Conv2d_1a_3x3 = EagerConv2d(3, 32, kernel_size=3, stride=2)\n\n            def forward(self, x):\n                x = self.Conv2d_1a_3x3(x)\n                return F.dropout(x, training=self.training)\n\n        script_input = torch.rand(4, 3, 299, 299)\n        eager_input = script_input.clone()\n\n        with freeze_rng_state():\n            script_mod = ScriptMod()\n            script_mod.eval()\n            script_output = script_mod(script_input)\n\n        with freeze_rng_state():\n            eager_mod = EagerMod()\n            eager_mod.eval()\n            eager_output = eager_mod(eager_input)\n\n        self.assertEqual(script_output, eager_output)\n\n        with freeze_rng_state():\n            script_mod = ScriptMod()\n            script_mod.train()\n            script_output = script_mod(script_input)\n\n        with freeze_rng_state():\n            eager_mod = EagerMod()\n            eager_mod.train()\n            eager_output = eager_mod(eager_input)\n\n        self.assertEqual(script_output, eager_output)\n\n    def test_nested_breaks(self):\n        def no_bool_loop_outputs(g):\n            # testing that the \"did exit\" transform values are not loop block\n            # outputs (and thus not affecting one loop from another)\n            loops = g.findAllNodes(\"prim::Loop\")\n            for loop in loops:\n                for out in loop.outputs():\n                    self.assertTrue(out.type() != BoolType.get())\n\n        def test(y):\n            # type: (int)\n            ret = 0\n            tensor = torch.tensor(0)\n            while int(tensor.add_(1)) < 4:\n                if y == 1:\n                    continue\n                for i in range(y):\n                    continue\n                    ret += 1\n                ret += 1\n            return ret, int(tensor)\n\n        self.assertEqual(torch.jit.script(test)(1), test(1))\n        self.assertEqual(torch.jit.script(test)(2), test(2))\n        no_bool_loop_outputs(torch.jit.script(test).graph)\n\n        def foo():\n            y = torch.tensor(0)\n            z = 0\n            while int(y.add_(1)) < 20:\n                if int(y) < 10:\n                    for i in range(6):\n                        if i == 3:\n                            continue\n                        else:\n                            if i > 3:\n                                break\n                        z += 2\n                if int(y) == 18:\n                    break\n                if int(y) == 15:\n                    continue\n                z += 1\n            return int(y), z\n\n        no_bool_loop_outputs(torch.jit.script(foo).graph)\n        self.checkScript(foo, ())\n\n        def test_nested_two():\n            i = 0\n            k = 0\n            while i < 5:\n                for j in range(5):\n                    k += 1\n                    if j == 3:\n                        continue\n                i += 1\n                k += 1\n                if i == 4:\n                    break\n            return i, k\n\n        self.checkScript(test_nested_two, ())\n        no_bool_loop_outputs(torch.jit.script(test_nested_two).graph)\n\n    def test_breaks_continues(self):\n        def foo_continue(cond):\n            # type: (int)\n            j = 1\n            for i in range(5):\n                if i == cond:\n                    continue\n                j += 1\n            return j\n\n        def foo_break(cond):\n            # type: (int)\n            j = 1\n            for i in range(5):\n                if i == cond:\n                    break\n                j += 1\n            return j\n\n        for i in range(1, 4):\n            self.checkScript(foo_continue, (i,))\n            self.checkScript(foo_break, (i,))\n\n        def test_refine_outside_loop():\n            if 1 == 1:\n                x = None\n            else:\n                x = 1\n            i = 0\n            j = 0\n            while (x is None or torch.jit._unwrap_optional(x) > 3):\n                if i < 3:\n                    if i < 3:\n                        x = torch.jit.annotate(Optional[int], None)\n                        i += 1\n                        continue\n                    x = 1\n                else:\n                    x = 1 if x is None else x\n                x = x + 1\n                j = x + x\n\n            return x, j\n\n        self.checkScript(test_refine_outside_loop, ())\n\n        def assign_after_break(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                x = y * 2 + i\n                break\n                x = 4\n            return x\n\n        self.checkScript(assign_after_break, (1,))\n        self.checkScript(assign_after_break, (2,))\n        self.checkScript(assign_after_break, (3,))\n\n        def assign_after_break_nested(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                if y == 1:\n                    x = 5\n                    break\n                    assert 1 == 2\n                else:\n                    x = x + 1\n                    break\n                    assert 1 == 2\n                x = -30\n                assert 1 == 2\n            return x\n\n        self.checkScript(assign_after_break_nested, (1,))\n        self.checkScript(assign_after_break_nested, (2,))\n        self.checkScript(assign_after_break_nested, (3,))\n\n        def may_break(y):\n            # type: (int)\n            x = 0\n            for i in range(y):\n                if y == 1:\n                    x = 5\n                else:\n                    x = x + 1\n                    break\n                x = -30\n            return x\n\n        self.checkScript(may_break, (1,))\n        self.checkScript(may_break, (2,))\n        self.checkScript(may_break, (3,))\n\n        def test(x, y):\n            # type: (int, int)\n            a = 1\n            while (x > 0):\n                if y == 3:\n                    for i in range(y):\n                        a += (1 % (i + 1))\n                        x -= 1\n                if x == 3:\n                    a = x * 3\n                    break\n                if x < 3:\n                    if x == 1:\n                        a -= 2\n                        x -= 1\n                        break\n                a -= 1\n                x -= 3\n            return a, x\n\n        self.checkScript(test, (10, 3))\n        self.checkScript(test, (10, 2))\n        self.checkScript(test, (3, 2))\n        self.checkScript(test, (5, 3))\n        self.checkScript(test, (2, 3))\n\n        def test_delete_after_break(x):\n            # type: (int)\n            a = 1\n            b = 1\n            for i in range(x):\n                a = i * 3\n                break\n                b = i * 5\n            return a, b\n\n        self.checkScript(test_delete_after_break, (0,))\n        self.checkScript(test_delete_after_break, (1,))\n\n        def test_will_break_after_guard(x):\n            # type: (int)\n            a = 1\n            for i in range(x):\n                if i == 4:\n                    a = 3\n                    break\n                a -= 1\n                break\n                assert 1 == 2\n                a -= -100\n            return a\n\n        self.checkScript(test_will_break_after_guard, (0,))\n        self.checkScript(test_will_break_after_guard, (2,))\n        self.checkScript(test_will_break_after_guard, (4,))\n\n        def test_varexit(cond):\n            # type: (int)\n            m = 0\n            for i in range(3):\n                if cond == 2:\n                    if cond == 2:\n                        m = 2\n                        break\n                    k = 1\n                else:\n                    k = 2\n                m += k\n            return m\n\n        # use of k tests the pathway where we have to insert unitialized\n        self.checkScript(test_varexit, (3,))\n        self.checkScript(test_varexit, (2,))\n\n        def test_break_true():\n            i = 0\n            while True:\n                i += 1\n                if i == 3:\n                    break\n            while False:\n                i += 1\n            return i\n\n        self.checkScript(test_break_true, ())\n\n    def test_break_continue_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"Syntax\"):\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                break\n                ''')\n\n        with self.assertRaisesRegex(RuntimeError, \"Syntax\"):\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                for i in range(5):\n                    def foo():\n                        break\n                ''')\n\n        with self.assertRaisesRegex(RuntimeError, \"do not support break or continue inside\"):\n            @torch.jit.script\n            def foo(x):\n                i = 0\n                for a in (1, \"2\", 1.5):\n                    b = a\n                    if x:\n                        break\n                return b\n\n    def test_python_call(self):\n        def pyfunc(a):\n            return a * 3.0\n\n        cu = torch.jit.CompilationUnit('''\n        def other_func(a):\n            return a + a\n\n        def test_call_python(a):\n            b = pyfunc(a)\n            b = other_func(b)\n            i = 0\n            step = 1\n            while i < 10:\n                b = pyfunc(b)\n                if bool(b > 3.0):\n                    b = pyfunc(b)\n                i = 11\n            return b\n        ''')\n        inputs = self._make_scalar_vars([1], torch.float)\n        outputs = self._make_scalar_vars([54], torch.float)\n\n        self.assertEqual(cu.test_call_python(*inputs), outputs[0])\n\n    def test_python_call_failure(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value pyfunc2\"):\n            def pyfunc(a):\n                return a * 3.0\n\n            cu = torch.jit.CompilationUnit('''\n            def other_func(a):\n                return a + a\n\n            def test_call_python(a):\n                b = pyfunc(a)\n                b = other_func(b)\n                i = 0\n                step = 1\n                while i < 10:\n                    b = pyfunc2(b)\n                    if b > 3.0:\n                        b = pyfunc(b)\n                    i = 11\n                return b\n            ''')\n            inputs = self._make_scalar_vars([1], torch.float)\n            outputs = self._make_scalar_vars([54], torch.float)\n\n            self.assertEqual(cu.test_call_python(*inputs), outputs)\n\n    def test_type_call_in_script(self):\n        @torch.jit.script\n        def fn(x):\n            return type(x)\n\n        with self.assertRaisesRegex(RuntimeError, \"value of type _TensorMeta\"):\n            fn(torch.tensor(.5))\n\n    def test_python_call_annotation(self):\n        def pyfunc(a):\n            return a * 3.0\n\n        @torch.jit.script\n        def foo(a):\n            return pyfunc(a) + pyfunc(a)\n\n        inputs = self._make_scalar_vars([1], torch.float)\n        outputs = self._make_scalar_vars([6], torch.float)\n        self.assertEqual(foo(*inputs), outputs[0])\n\n    def test_python_call_annoytation_failure(self):\n        with self.assertRaisesRegex(RuntimeError, \"undefined value pyfunc2\"):\n            def pyfunc(a):\n                return a * 3.0\n\n            @torch.jit.script\n            def foo(a):\n                return pyfunc2(a) + pyfunc(a)\n\n            inputs = self._make_scalar_vars([1], torch.float)\n            outputs = self._make_scalar_vars([6], torch.float)\n\n            self.assertEqual(foo(*inputs), outputs[0])\n\n    def test_desugar_module(self):\n        import torch.nn.functional as F\n\n        def fn(x, slope):\n            a = torch.abs(x)\n            b = torch.nn.functional.prelu(x, slope)\n            c = F.prelu(x, slope)\n            return a, b, c\n\n        x = torch.arange(-3., 4)\n        slope = torch.tensor([0.5])\n        self.checkScript(fn, [x, slope], optimize=True)\n\n    def test_script_docstring(self):\n        @torch.jit.script\n        def with_docstring(x):\n            \"\"\"test str\"\"\"\n            y = x\n            \"\"\"y is the same as x\"\"\"\n            return y\n        self.assertEqual(with_docstring.__doc__, 'test str')\n\n    def test_script_method_docstring(self):\n        class A(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def with_docstring(self, x):\n                \"\"\"test str\"\"\"\n                y = x\n                \"\"\"y is the same as x\"\"\"\n                return y\n        a = A()\n        self.assertEqual(a.with_docstring.__doc__, 'test str')\n\n    def test_script_module(self):\n        class M1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M1, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class PModule(nn.Module):\n            def __init__(self):\n                super(PModule, self).__init__()\n                self.a = nn.Parameter(torch.randn(2, 3))\n\n            def forward(self, a):\n                return self.a.mm(a)\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                # test submodule\n                self.sub = M1()\n                self.sub2 = PModule()\n                # test parameters\n                self.weight = nn.Parameter(torch.randn(2, 3))\n                self.bias = nn.Parameter(torch.randn(2))\n                # test defining a method from a string\n                self.define(\"\"\"\n                    def hi(self, a):\n                        return self.weight.mm(a)\n                \"\"\")\n            # test script methods\n\n            @torch.jit.script_method\n            def doit(self, input):\n                # test use of parameter\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit2(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                a = self.doit(input)\n                b = self.doit2(input)\n                c = self.hi(input)\n                d = self.sub2(input)\n                return a + b + self.bias + self.sub(a) + c + d\n        with torch.jit.optimized_execution(False):\n            m2 = M2()\n            input = torch.randn(3, 2)\n            a = m2.weight.mm(input)\n            b = m2.weight.mm(input)\n            c = m2.weight.mm(input)\n            d = m2.sub2.a.mm(input)\n            ref = a + b + m2.bias + m2.sub.weight + a + c + d\n            self.assertEqual(ref, m2.forward(input))\n            m2.weight = nn.Parameter(torch.zeros_like(m2.weight))\n            m2.bias = nn.Parameter(torch.zeros_like(m2.bias))\n            m2.sub.weight = nn.Parameter(torch.zeros_like(m2.sub.weight))\n            m2.sub2.a.data.zero_()\n            self.assertEqual(torch.zeros(2, 2), m2.forward(torch.randn(3, 2)))\n\n    def test_irparser(self):\n        graph_str = \"\"\"graph(%0 : Double(5, 5)):\n          # CHECK: aten::relu\n          %1 : Double(5, 5) = aten::relu(%0)\n          return (%1)\n        \"\"\"\n        FileCheck().run(graph_str, parse_ir(graph_str))\n\n    def test_parse_tensor_constants(self):\n        def foo():\n            return torch.zeros([4, 4])\n\n        foo_s = torch.jit.script(foo)\n        torch._C._jit_pass_constant_propagation(foo_s.graph)\n\n        g = str(foo_s.graph)\n        g_parsed = parse_ir(g, parse_tensor_constants=True)\n        self.assertEqual(str(canonical(g_parsed)), str(canonical(foo_s.graph)))\n        func = torch._C._create_function_from_graph(\"forward\", g_parsed)\n\n        out_parsed = func()\n        out_func = foo()\n        # not checking data, just dtype, size etc\n        out_parsed[:] = 0\n        out_func[:] = 0\n        self.assertEqual(out_func, out_parsed)\n\n        with self.assertRaises(RuntimeError):\n            parse_ir(g, parse_tensor_constants=False)\n\n    def test_parse_nested_names(self):\n        g_str = \"\"\"\n    graph(%x.1 : Tensor):\n        %3 : int = prim::Constant[value=1]()\n        %2 : int = prim::Constant[value=2]()\n        %hi.submod.value.5 : Tensor = aten::add(%x.1, %2, %3)\n        return (%hi.submod.value.5)\n        \"\"\"\n        g = parse_ir(g_str)\n        round_trip_g = parse_ir(str(g))\n        self.assertEqual(canonical(g), canonical(round_trip_g))\n\n        func1 = torch._C._create_function_from_graph(\"forward\", g)\n        func2 = torch._C._create_function_from_graph(\"forward\", round_trip_g)\n        self.assertEqual(func1(torch.ones([2])), func2(torch.ones([2])))\n\n    def test_is_after_use(self):\n        def sorted_input_use(g):\n            uses = list(next(g.inputs()).uses())\n            return sorted(uses, key=functools.cmp_to_key(type(uses[0]).isAfter))\n\n        @torch.jit.script\n        def foo(x):\n            a = x + 1\n            return (x, x, a)\n\n        uses_sorted = sorted_input_use(foo.graph)\n        # sorts last use to the end\n        self.assertFalse(uses_sorted[0].isAfter(uses_sorted[1]))\n        self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n        self.assertEqual(uses_sorted[1].offset, 0)\n\n        @torch.jit.script\n        def foo(x, cond: bool):\n            if cond:\n                return x + 3\n            else:\n                return x - 3\n\n        uses_sorted = sorted_input_use(foo.graph)\n        self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n        self.assertTrue(uses_sorted[1].user.kind() == \"aten::sub\")\n\n        @torch.jit.script\n        def foo(x, cond: bool, cond2: bool):\n            if cond:\n                return x + 3\n            elif cond2 :\n                return x - 3\n\n            return x / 3\n\n        graph1 = foo.graph\n\n        @torch.jit.script\n        def foo(x, cond: bool, cond2: bool):\n            if cond:\n                return x + 3\n            else:\n                if cond2 :\n                    return x - 3\n                return x / 3\n\n        graph2 = foo.graph\n\n        for graph in [graph1, graph2]:\n            uses_sorted = sorted_input_use(graph)\n            self.assertTrue(uses_sorted[0].user.kind() == \"aten::add\")\n            self.assertTrue(uses_sorted[1].user.kind() == \"aten::sub\")\n            self.assertTrue(uses_sorted[2].user.kind() == \"aten::div\")\n\n    def test_canonicalize_control_outputs(self):\n        def test_all_outputs(g):\n            ifs = g.findAllNodes(\"prim::If\")\n            loops = g.findAllNodes(\"prim::Loop\")\n\n            def contained_blocks(node):\n                return len(node.findAllNodes(\"prim::If\")) * 2 + len(node.findAllNodes(\"prim::Loop\"))\n            for node in ifs + loops:\n                outs = list(node.outputs())\n                out_name = [x.debugName() for x in outs]\n                if len(out_name) == 0:\n                    continue\n                fc = FileCheck()\n                # find the last output, then all subsequent uses\n                fc.check(out_name[-1] + \" : \")\n                # skip past node body\n                for i in range(contained_blocks(node)):\n                    fc.check(\"->\")\n                if (node.kind() == \"prim::If\"):\n                    fc.check(\"->\").check(\"->\").check(\"\\n\")\n                else:\n                    fc.check(\"->\").check(\"\\n\")\n                # the canonical order is the same order as the first use\n                # appears in text\n                for name in out_name:\n                    fc.check(name)\n                fc.run(g)\n\n        @torch.jit.script\n        def test(x):\n            # type: (bool) -> Tuple[int, int]\n            b = 2\n            a = 1\n            if x:\n                a = 1\n                b = 2\n                x = False\n            if x:\n                b = a\n            else:\n                a = b\n\n            return a, b\n        test_all_outputs(test.graph)\n\n        @torch.jit.script\n        def test2(x):\n            # type: (bool) -> Tuple[int, int]\n            b = 2\n            a = 1\n            if x:\n                a = 1\n                b = 2\n                x = False\n            if x:\n                print(a)\n            else:\n                if x:\n                    print(b)\n\n            return a, b\n        test_all_outputs(test2.graph)\n\n        @torch.jit.script\n        def test_loop(x, iter):\n            # type: (bool, int) -> (None)\n            a = 1\n            b = 2\n            c = 3\n            for i in range(iter):\n                a = 4\n                b = 5\n                c = 6\n                x = True\n            print(c)\n            if x:\n                print(a, b)\n        test_all_outputs(test_loop.graph)\n\n        @torch.jit.script\n        def loop_unused(iter):\n            # type: (int) -> (None)\n            a = 1\n            b = 2\n            c = 3\n            for i in range(iter):\n                c = c + 1\n                b = b + 1\n                a = a + 1\n                print(a, b)\n            print(c)\n\n        # c is used, then unused should be ordered by alphabetical\n        FileCheck().check(r\"%c : int, %a : int, %b : int\").run(loop_unused.graph)\n\n    def test_filecheck(self):\n        def test_check():\n            file = \"232\"\n            FileCheck().check(\"2\").check(\"3\").check(\"2\").run(file)\n            FileCheck().check(\"232\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().check(\"22\").run(file)\n            with self.assertRaisesRegex(RuntimeError, \"CHECK: 3\"):\n                FileCheck().check(\"3\").check(\"3\").run(file)\n\n        test_check()\n\n        def test_check_count():\n            file = \"22222\"\n            FileCheck().check_count(\"2\", 5).run(file)\n            FileCheck().check_count(\"22\", 2).run(file)\n            FileCheck().check_count(\"222\", 1).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find'):\n                FileCheck().check_count(\"2\", 4, exactly=True).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().check_count(\"22\", 3).run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"CHECK-COUNT-6: 2\"):\n                FileCheck().check_count(\"2\", 6).run(file)\n\n        test_check_count()\n\n        def test_check_same():\n            file = \"22\\n33\"\n            FileCheck().check_same(\"22\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().check_same(\"33\").run(file)\n\n            file = \"22  1  3\"\n\n            FileCheck().check(\"2\").check_same(\"3\").run(file)\n            FileCheck().check_count(\"2\", 2).check_same(\"3\").run(file)\n\n        test_check_same()\n\n        def test_check_next():\n            file = \"\\n1\\n2\\n3\"\n            FileCheck().check(\"1\").check_next(\"2\").check_next(\"3\").run(file)\n            FileCheck().check_next(\"1\").check_next(\"2\").check_next(\"3\").run(file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to find\"):\n                FileCheck().check(\"1\").check_next(\"2\").run(\"12\")\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().check(\"1\").check_next(\"2\").run(\"1\\n\\n2\")\n\n        test_check_next()\n\n        def test_check_dag():\n            fc = FileCheck().check_dag(\"1\").check_dag(\"2\").check_not(\"2\")\n            fc.run(\"12\")\n            fc.run(\"21\")\n\n            fc = FileCheck()\n            fc.check_not(\"3\").check_dag(\"1\").check_dag(\"2\").check_not(\"3\")\n            fc.run(\"1 3 2\")\n            fc.run(\"2 3 1\")\n\n            fc = FileCheck().check_dag(\"1\").check_dag(\"2\").check(\"3\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"3\" but did not find it'):\n                fc.run(\"1 3 2\")\n\n        test_check_dag()\n\n        def test_check_not():\n            FileCheck().check_not(\"2\").check(\"1\").run(\"12\")\n            FileCheck().check(\"2\").check_not(\"2\").run(\"12\")\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"2\"'):\n                FileCheck().check_not(\"2\").check(\"1\").run(\"21\")\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"1\"'):\n                FileCheck().check(\"2\").check_not(\"1\").run(\"21\")\n\n            # checks with distinct range matchings\n            fb = FileCheck().check_count(\"2\", 2).check_count(\"2\", 2).check_not(\"2\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"2\"'):\n                fb.run(\"22 2 22\")\n\n            fb = FileCheck().check_count(\"2\", 2).check_not(\"1\").check_count(\"2\", 2)\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find \"1\"'):\n                fb.run(\"22 1 22\")\n\n    def _dtype_to_jit_name(self, dtype):\n        if(dtype == torch.float32):\n            return \"Float\"\n        if(dtype == torch.float64):\n            return \"Double\"\n        if(dtype == torch.int64):\n            return \"Long\"\n        if(dtype == torch.int32):\n            return \"Int\"\n        if(dtype == torch.bool):\n            return \"Bool\"\n        raise RuntimeError('dtype not handled')\n\n    def _dtype_to_expect(self, dtype, dim=0):\n        param = ', '.join(['*'] * dim + ['device=cpu'])\n        param = '(' + param + ')'\n        jit_type = self._dtype_to_jit_name(dtype)\n        if dim >= 0:\n            return jit_type + param\n        # special case representing wrapped number\n        else:\n            return jit_type.lower()\n\n\n    def _test_dtype_op_shape(self, ops, args, input_dims=1):\n        if input_dims < 1:\n            raise RuntimeError(\"input dims must be at least 1\")\n        dtypes = [torch.float32, torch.float64, torch.int64, torch.int32]\n        str_args = ', '.join([str(arg) for arg in args]) + (', ' if len(args) else '')\n        tensor_data = ('[' * input_dims) + '1, 2, 3' + (input_dims * ']')\n        template = dedent('''\n        def func():\n            return {return_line}\n        ''')\n\n        for op in ops:\n            for dtype in (dtypes + [None]):\n                for tensor_type in dtypes:\n                    # a couple of ops aren't implemented for non-floating types\n                    if(not tensor_type.is_floating_point or (dtype is not None and not dtype.is_floating_point)):\n                        if op in ['mean', 'softmax', 'log_softmax']:\n                            continue\n                    return_line = \"torch.tensor({}, dtype={}).{}({}dtype={})\".format(tensor_data, tensor_type, op, str_args, dtype)\n                    # uncomment for debugging a failed test:\n                    # print(\"testing {}\".format(return_line))\n                    code = template.format(return_line=return_line)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    cu = torch.jit.CompilationUnit(code)\n                    graph = cu.func.graph\n                    torch._C._jit_pass_complete_shape_analysis(graph, (), False)\n                    input_array = [1, 2, 3]\n                    for _ in range(1, input_dims):\n                        input_array = [input_array]\n                    t = torch.tensor(input_array, dtype=tensor_type)\n                    attr = getattr(t, op)\n                    kwargs = {'dtype': dtype}\n                    result = attr(*args, **kwargs)\n                    expect = self._dtype_to_expect(result.dtype, result.dim())\n                    FileCheck().check(\"aten::tensor\").check(expect).run(graph)\n\n    def test_dtype_op_shape(self):\n        ops = ['prod']\n        self._test_dtype_op_shape(ops, args=[])\n        self._test_dtype_op_shape(ops, args=[0, False])\n        self._test_dtype_op_shape(ops, args=[0, False])\n        self._test_dtype_op_shape(ops, args=[0, True])\n\n    def test_dtype_op_shape2(self):\n        ops = ['cumprod', 'cumsum', 'softmax', 'log_softmax']\n        self._test_dtype_op_shape(ops, args=[0])\n\n        self._test_dtype_op_shape(ops, args=[1], input_dims=4)\n\n\n    def _test_binary_op_shape(self, ops, input_dims=1):\n\n        dtypes = [torch.float32, torch.float64, torch.int64, torch.int32, torch.bool]\n\n        if input_dims == 0:\n            shape = '1'\n        else:\n            shape = '[' + ('1,' * 4) + ']'\n            for _ in range(1, input_dims):\n                shape = '[' + \",\".join([shape] * 4) + ']'\n\n        template = dedent('''\n        def func():\n            arg1 = {}\n            arg2 = {}\n            return torch.{}(arg1, arg2)\n        ''')\n\n        args = []\n        for dtype in dtypes:\n            args = args + [\"torch.tensor({}, dtype={})\".format(shape, dtype)]\n        args = args + [1, 1.5]\n\n        def isBool(arg):\n            return type(arg) == bool or (type(arg) == str and \"torch.bool\" in arg)\n\n        for op in ops:\n            for first_arg in args:\n                for second_arg in args:\n                    # subtract not supported for bool\n                    if (op == 'sub' or op == 'div') and (isBool(first_arg) or isBool(second_arg)):\n                        continue\n                    # div is not implemented correctly for mixed-type or int params\n                    if (op == 'div' and (type(first_arg) != type(second_arg) or\n                       isinstance(first_arg, int) or\n                       (isinstance(first_arg, str) and 'int' in first_arg))):\n                        continue\n                    return_line = \"torch.{}({}, {})\".format(op, first_arg, second_arg)\n                    # uncomment for debugging a failed test:\n                    # print(\"testing {}\".format(return_line))\n                    code = template.format(first_arg, second_arg, op)\n                    scope = {}\n                    exec(code, globals(), scope)\n                    non_jit_result = scope['func']()\n\n                    cu = torch.jit.CompilationUnit(code)\n                    graph = cu.func.graph\n                    torch._C._jit_pass_complete_shape_analysis(graph, (), False)\n                    # use dim=-1 to represent a python/jit scalar.\n                    dim = -1 if type(first_arg) != str and type(second_arg) != str else non_jit_result.dim()\n                    dtype = non_jit_result.dtype\n                    # jit only supports int/float scalars.\n                    if dim < 0:\n                        if dtype == torch.int64:\n                            dtype = torch.int32\n                        if dtype == torch.float64:\n                            dtype = torch.float32\n                    expect = self._dtype_to_expect(dtype, dim)\n                    jit_output = next(graph.outputs())\n\n                    check = FileCheck()\n                    check.check(expect).run(str(jit_output))\n\n    def test_binary_op_shape(self):\n        self._test_binary_op_shape(['mul', 'div', 'add', 'sub'], 0)\n        self._test_binary_op_shape(['mul', 'div', 'add', 'sub'], 3)\n\n    def test_no_dtype_shape(self):\n\n        @torch.jit.script\n        def foo(x):\n            scalar_number = x.item()\n            return x.add(scalar_number)\n\n        @torch.jit.script\n        def foo2(x):\n            scalar_number = x.item()\n            return torch.tensor(1).add(scalar_number)\n\n        t = torch.tensor(5)\n        g = foo.graph_for(t)\n        type = next(g.outputs())\n        self.assertTrue(type.type() == torch._C.TensorType.get())\n        g2 = foo2.graph_for(t)\n        type = next(g.outputs())\n        self.assertTrue(type.type() == torch._C.TensorType.get())\n\n\n    def test_filecheck_parse(self):\n        def test_check():\n            file = \"\"\"\n                # CHECK: 2\n                # CHECK: 3\n                # CHECK: 2\n                232\n                \"\"\"\n            FileCheck().run(checks_file=file, test_file=file)\n            file = \"\"\"\n                # CHECK: 232\n                232\n                \"\"\"\n            FileCheck().run(file, \"232\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"232\"'):\n                FileCheck().run(file, \"22\")\n            with self.assertRaisesRegex(RuntimeError, 'Expected to find \"22\"'):\n                FileCheck().run(\"# CHECK: 22\", \"23\")\n        test_check()\n\n        def test_check_count():\n            file = \"22222\"\n            FileCheck().run(\"# CHECK-COUNT-5: 2\", file)\n            FileCheck().run(\"# CHECK-COUNT-EXACTLY-5: 2\", file)\n            FileCheck().run(\"# CHECK-COUNT-2: 22\", file)\n            FileCheck().run(\"# CHECK-COUNT-1: 222\", file)\n\n            with self.assertRaisesRegex(RuntimeError, 'Expected to not find'):\n                FileCheck().run(\"# CHECK-COUNT-EXACTLY-2: 2\", file)\n        test_check_count()\n\n        def test_check_same():\n            file = \"22\\n33\"\n            FileCheck().run(\"# CHECK-SAME: 22\", file)\n\n            with self.assertRaisesRegex(RuntimeError, \"Expected to not find\"):\n                FileCheck().run(\"# CHECK-SAME: 33\", file)\n\n            file = \"22  1  3\"\n\n            FileCheck().run(\"# CHECK: 2\\n # CHECK-SAME: 3\", file)\n            FileCheck().run(\"# CHECK-COUNT-2: 2\\n # CHECK-SAME: 3\", file)\n        test_check_same()\n\n        def test_bad_input():\n            with self.assertRaisesRegex(RuntimeError, \"Check for bad input\"):\n                FileCheck().run(\"\", \"1\")\n\n            with self.assertRaisesRegex(RuntimeError, \"Could not parse check\"):\n                FileCheck().run(\"# CHECK1\", \"\")\n\n        test_bad_input()\n\n    def test_script_module_call_noscript(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.value = 1\n\n            @torch.jit.ignore\n            def foo(self):\n                return torch.ones(2, 2) + self.value\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return input + self.foo()\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            input = torch.randn(2, 2)\n            o = m(input)\n            self.assertEqual(o, input + torch.ones(2, 2) + 1)\n            # check that we can change python attributes\n            # and that those changes are picked up in script methods\n            m.value = 2\n            o = m(input)\n            self.assertEqual(o, input + torch.ones(2, 2) + 2)\n\n    def test_script_module_nochange_submodule(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.sub = nn.Linear(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.sub(input)\n        with torch.jit.optimized_execution(False):\n            m = M()\n            input = torch.randn(1, 5, 5)\n            o = m(input)\n            self.assertEqual(o, m.sub(input))\n            with self.assertRaisesRegex(RuntimeError, \"Cannot re-assign\"):\n                m.sub = nn.Linear(5, 5)\n\n    def test_module_apis(self):\n        class Sub(torch.nn.Module):\n            def __init__(self):\n                super(Sub, self).__init__()\n\n            def forward(self, thing):\n                return thing - 2\n\n        class Double(torch.nn.Module):\n            def __init__(self):\n                super(Double, self).__init__()\n\n            def forward(self, thing):\n                return thing * 2\n\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.mod = (Sub())\n                self.mod2 = (Sub())\n                self.mod3 = nn.Sequential(nn.Sequential(Sub()))\n                self.mod4 = nn.Sequential(Sub(), Double())\n\n            @torch.jit.export\n            def method(self, x, x1, y, y1):\n                mod_names = \"\"\n                for name, mod in self.named_modules():\n                    mod_names = mod_names + \" \" + name\n                    x = mod(x)\n\n                children_names = \"\"\n                for name, mod in self.named_children():\n                    children_names = children_names + \" \" + name\n                    x1 = mod(x1)\n\n                for mod in self.modules():\n                    y = mod(y)\n\n                for mod in self.children():\n                    y1 = mod(y1)\n\n                return mod_names, children_names, x, x1, y, y1\n\n            def forward(self, x):\n                return x + 2\n\n        mod = torch.jit.script(MyMod())\n        inps = tuple([torch.tensor(i) for i in range(1, 5)])\n        self.assertEqual(mod.method(*inps), MyMod().method(*inps))\n\n    def test_script_module_const(self):\n        class M(torch.jit.ScriptModule):\n\n            __constants__ = ['b', 'i', 'c', 's']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.b = False\n                self.i = 1\n                self.c = 3.5\n                self.s = [\"hello\"]\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.b, self.i, self.c\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            o0, o1, o2 = m()\n        self.assertEqual(o0, 0)\n        self.assertEqual(o1, 1)\n        self.assertEqual(o2, 3.5)\n\n    def test_script_module_fail_exist(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.whatisgoingon\n        with self.assertRaisesRegex(RuntimeError, \"Module 'M' has no attribute\"):\n            M()\n\n    @unittest.skip(\"[module dedupe] currently NoneType refinement on optional attributes doesn't work.\")\n    def test_script_module_none_exist_fail(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, my_optional):\n                super(M, self).__init__()\n                self.my_optional = my_optional\n\n            @torch.jit.script_method\n            def forward(self, x):\n                if self.my_optional is not None:\n                    return torch.neg(x) + self.my_optional\n                return torch.neg(x)\n        with self.assertRaisesRegex(RuntimeError, \"has no attribute 'my_optional'\"):\n            x = torch.rand(3, 4)\n            fb = M(None)\n            fb(x)\n\n    def test_script_module_invalid_consts(self):\n        class Foo(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.invalid = [nn.Linear(3, 4)]\n\n        with self.assertRaisesRegex(\n                TypeError,\n                \"Linear' object in attribute 'Foo.invalid' is not a valid constant\"):\n            Foo()\n\n        class Foo2(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo2, self).__init__()\n                self.invalid = type(1)\n\n        with self.assertRaisesRegex(TypeError, \"not a valid constant\"):\n            Foo2()\n\n        class Foo3(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo3, self).__init__()\n                self.invalid = (3, 4, {})\n\n        with self.assertRaisesRegex(TypeError, \"not a valid constant\"):\n            Foo3()\n\n        class Foo4(torch.jit.ScriptModule):\n            __constants__ = ['invalid']\n\n            def __init__(self):\n                super(Foo4, self).__init__()\n                self.invalid = np.int64(5)\n\n        # verify that we capture human understandable class name\n        with self.assertRaisesRegex(TypeError, \"numpy.int64\"):\n            Foo4()\n\n    def test_script_module_param_buffer_mutation(self):\n        # TODO: add param mutation test case after JIT support it\n        class ModuleBufferMutate(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ModuleBufferMutate, self).__init__()\n                self.register_buffer('running_var', torch.tensor(0, dtype=torch.long))\n\n            @torch.jit.script_method\n            def forward(self):\n                if self.training:\n                    self.running_var += 1\n                return self.running_var\n\n        with torch.jit.optimized_execution(False):\n            m = ModuleBufferMutate()\n            self.assertEqual(m(), 1)\n            m.eval()\n            self.assertEqual(m(), 1)\n\n    def test_script_module_for(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['b']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.b = [1, 2, 3, 4]\n\n            @torch.jit.script_method\n            def forward(self):\n                sum = 0\n                for i in self.b:\n                    sum += i\n                return sum\n\n        with torch.jit.optimized_execution(False):\n            m = M()\n            self.assertEqual(m(), 10)\n\n    def test_override_magic(self):\n        class OverrideMagic(nn.Module):\n            def __init__(self):\n                super(OverrideMagic, self).__init__()\n\n            @torch.jit.export\n            def __len__(self):\n                return 10\n\n        mod = OverrideMagic()\n        self.assertEqual(len(mod), len(torch.jit.script(mod)))\n\n        class OverrideMagicSeq(nn.Sequential):\n            def __init__(self):\n                super(OverrideMagicSeq, self).__init__()\n\n            @torch.jit.export\n            def __len__(self):\n                return 10\n\n        mod = OverrideMagicSeq()\n        self.assertEqual(len(mod), len(torch.jit.script(mod)))\n        self.assertTrue(torch.jit.script(mod))\n\n    def test_script_module_for2(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([Sub() for i in range(10)])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    v = m(v)\n                return v\n\n        with torch.jit.optimized_execution(False):\n            i = torch.empty(2)\n            m = M()\n            o = m(i)\n            v = i\n            for sub in m.mods:\n                v = sub(v)\n            self.assertEqual(o, v)\n            with self.assertRaisesRegex(Exception, \"object is not iterable\"):\n                print(list(m))\n\n    def test_attr_qscheme_script(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.qscheme = torch.per_tensor_affine\n\n            def forward(self):\n                if self.qscheme == torch.per_tensor_symmetric:\n                    return 3\n                else:\n                    return 4\n\n        f = Foo()\n        scripted = torch.jit.script(f)\n        self.assertEqual(f(), scripted())\n\n    def test_script_module_const_submodule_fail(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = [Sub() for _ in range(10)]\n\n            @torch.jit.script_method\n            def forward(self):\n                for _ in self.mods:\n                    print(1)\n                return 4\n\n        with self.assertRaisesRegex(RuntimeError, \"has no attribute 'mods'\"):\n            M()\n\n    class DerivedStateModule(torch.jit.ScriptModule):\n        def __init__(self):\n            super(TestScript.DerivedStateModule, self).__init__()\n            self.param = torch.nn.Parameter(torch.ones(3, 4, dtype=torch.float))\n            self.register_buffer('derived', torch.neg(self.param).detach().clone())\n\n            # This is a flag so we can test that the pack method was called\n            self.register_buffer('pack_called', torch.zeros(1, dtype=torch.long))\n            # This is a flag so we can test that the unpack method was called\n            self.register_buffer('unpack_called', torch.zeros(1, dtype=torch.long))\n\n        @torch.jit.script_method\n        def _pack(self):\n            self.pack_called.set_(torch.ones(1, dtype=torch.long))\n            self.derived.set_(torch.rand(1, dtype=torch.float).detach())\n\n        @torch.jit.script_method\n        def _unpack(self):\n            self.unpack_called.set_(torch.ones(1, dtype=torch.long))\n            self.derived.set_(torch.neg(self.param).detach())\n\n        @torch.jit.script_method\n        def forward(self, x):\n            return x + self.derived\n\n    def test_pack_unpack_state(self):\n        sm = TestScript.DerivedStateModule()\n        x = torch.rand(3, 4, dtype=torch.float)\n        torch.testing.assert_close(sm(x), x + torch.neg(torch.ones(3, 4, dtype=torch.float)))\n\n        # Test save path\n        self.assertFalse(sm.pack_called.item())\n        self.assertFalse(sm.unpack_called.item())\n        imported = self.getExportImportCopyWithPacking(sm)\n        # ensure pack was called before serialization\n        self.assertTrue(sm.pack_called.item())\n        # ensure unpack was called after serialization so as to leave the module in an initialized state\n        self.assertTrue(sm.unpack_called.item())\n\n        torch.testing.assert_close(sm.derived, torch.neg(sm.param))\n\n        # Test load paths\n        self.assertTrue(imported.unpack_called.item())\n        torch.testing.assert_close(imported(x), x + torch.neg(torch.ones(3, 4, dtype=torch.float)))\n\n    @unittest.skipIf(not TEST_MKL, \"PyTorch is built without MKL support\")\n    @unittest.skipIf(True, \"Skipping while landing PR stack\")\n    def test_torch_functional(self):\n        def stft(input, n_fft):\n            # type: (Tensor, int) -> Tensor\n            return torch.stft(input, n_fft, return_complex=True)\n\n        inps = (torch.randn(10), 7)\n        self.assertEqual(stft(*inps), torch.jit.script(stft)(*inps))\n\n        def istft(input, n_fft):\n            # type: (Tensor, int) -> Tensor\n            return torch.istft(input, n_fft)\n\n        inps2 = (stft(*inps), inps[1])\n        self.assertEqual(istft(*inps2), torch.jit.script(istft)(*inps2))\n\n        def lu_unpack(x):\n            A_LU, pivots = torch.linalg.lu_factor(x)\n            return torch.lu_unpack(A_LU, pivots)\n\n        for shape in ((3, 3), (5, 3, 3), (7, 3, 5, 5), (7, 5, 3, 3, 3)):\n            a = torch.randn(*shape)\n            self.checkScript(lu_unpack, (a,))\n\n        def cdist_fn():\n            a = torch.tensor([[0.9041, 0.0196], [-0.3108, -2.4423], [-0.4821, 1.059]])\n            b = torch.tensor([[-2.1763, -0.4713], [-0.6986, 1.3702]])\n            return torch.cdist(a, b, compute_mode=\"use_mm_for_euclid_dist\")\n\n        self.checkScript(cdist_fn, ())\n\n        def norm():\n            c = torch.tensor([[1, 2, 3], [-1, 1, 4]], dtype=torch.float)\n            return torch.norm(c, p=\"fro\"), torch.norm(c, p=\"nuc\"), torch.norm(c), torch.norm(c, p=.5)\n\n        self.checkScript(norm, ())\n\n        def torch_unique(dim: Optional[int]):\n            ten = torch.unique(torch.tensor([[1, 3], [2, 3]], dtype=torch.long))\n            a = torch.unique(ten, dim=dim)\n            b = torch.unique(ten, return_counts=True, dim=dim)\n            c = torch.unique(ten, return_inverse=True, dim=dim)\n            d = torch.unique(ten, return_counts=True, return_inverse=True, dim=dim)\n            return a, b, c, d\n\n        self.checkScript(torch_unique, (None,))\n        self.checkScript(torch_unique, (0,))\n\n        def torch_unique_consecutive(dim: Optional[int]):\n            ten = torch.unique(torch.tensor([[1, 3], [3, 2], [3, 2], [2, 3]], dtype=torch.long))\n            a = torch.unique_consecutive(ten, dim=dim)\n            b = torch.unique_consecutive(ten, return_counts=True, dim=dim)\n            c = torch.unique_consecutive(ten, return_inverse=True, dim=dim)\n            d = torch.unique_consecutive(ten, return_counts=True, return_inverse=True, dim=dim)\n            return a, b, c, d\n\n        self.checkScript(torch_unique_consecutive, (None,))\n        self.checkScript(torch_unique_consecutive, (0,))\n\n    def test_torch_functional_tensordot_int(self):\n        def tensordot_dims_int(a: torch.Tensor, b: torch.Tensor, dims: int):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(120.).reshape(2, 3, 4, 5)\n        b = torch.arange(840.).reshape(4, 5, 6, 7)\n        dims = 2\n        self.checkScript(tensordot_dims_int, (a, b, dims))\n\n    def test_torch_functional_tensordot_tensor(self):\n        def tensordot_dims_tensor(a: torch.Tensor, b: torch.Tensor, dims: torch.Tensor):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(120.).reshape(2, 3, 4, 5)\n        b = torch.arange(840.).reshape(4, 5, 6, 7)\n        dims = torch.tensor([2])\n        self.checkScript(tensordot_dims_tensor, (a, b, dims))\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = torch.tensor([[1, 0], [0, 1]], dtype=torch.long)\n        self.checkScript(tensordot_dims_tensor, (a, b, dims))\n\n    def test_torch_functional_tensordot_list(self):\n        def tensordot_dims_list(a: torch.Tensor, b: torch.Tensor, dims: List[List[int]]):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = [[1, 0], [0, 1]]\n        self.checkScript(tensordot_dims_list, (a, b, dims))\n\n    def test_torch_functional_tensordot_tuple(self):\n        def tensordot_dims_tuple(a: torch.Tensor, b: torch.Tensor, dims: Tuple[List[int], List[int]]):\n            return torch.tensordot(a, b, dims=dims)\n\n        a = torch.arange(60.).reshape(3, 4, 5)\n        b = torch.arange(24.).reshape(4, 3, 2)\n        dims = ([1, 0], [0, 1])\n        self.checkScript(tensordot_dims_tuple, (a, b, dims))\n\n    def test_missing_getstate(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.x = 1\n\n            def forward(self, x):\n                return x * self.x\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.x = state[0]\n                self.training = state[1]\n\n        with self.assertRaisesRegex(RuntimeError, \"getstate\"):\n            scripted = torch.jit.script(Foo())\n\n    def test_inlining_cleanup(self):\n        def foo(x):\n            return F.linear(x, x)\n\n        @torch.jit.script\n        def fee(x):\n            return foo(x)\n\n        # inlining optimizations should have cleaned up linear if statement\n        self.run_pass(\"inline\", fee.graph)\n        FileCheck().check_not(\"prim::If\").run(fee.graph)\n\n    def test_pack_unpack_nested(self):\n        class SubSubMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SubSubMod, self).__init__()\n                self.register_buffer('buf', torch.ones(3, 4) * 3)\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double) * 3)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.buf\n\n        class SubMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SubMod, self).__init__()\n                self.register_buffer('buf', torch.ones(3, 4) * 2)\n                self.ssm = SubSubMod()\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double) * 2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.ssm(x + self.buf)\n\n        class Mod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.submod = SubMod()\n                self.register_buffer('buf', torch.ones(3, 4) * 1)\n\n            @torch.jit.script_method\n            def _pack(self):\n                self.buf.set_(torch.zeros(1, dtype=torch.double))\n\n            @torch.jit.script_method\n            def _unpack(self):\n                self.buf.set_(torch.ones(3, 4, dtype=torch.double))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.submod(x + self.buf)\n\n        m = Mod()\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.ones(3, 4) * 6)\n        m.apply(lambda s: s._pack())\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.zeros(3, 4))\n        m.apply(lambda s: s._unpack())\n        torch.testing.assert_close(m(torch.zeros(3, 4)), torch.ones(3, 4) * 6)\n\n    def test_torch_any(self):\n        def fn(x):\n            return torch.any(x)\n\n        def fn1(x, dim: int):\n            return torch.any(x, dim)\n\n        self.checkScript(fn, (torch.randn(3, 4), ))\n        self.checkScript(fn, (torch.empty(3), ))\n        self.checkScript(fn, (torch.empty(1), ))\n        self.checkScript(fn, (torch.ones(3, 4),))\n        self.checkScript(fn, (torch.zeros(5, 7, 1),))\n        self.checkScript(fn1, (torch.empty(3, 4), -2))\n        self.checkScript(fn1, (torch.randn(3, 8), 1))\n        self.checkScript(fn1, (torch.zeros(3, 6, 9), -3))\n        self.checkScript(fn1, (torch.empty(5), 0))\n\n    def test_any(self):\n        def fn(x: List[int]):\n            return any(x)\n\n        def fn1(x: List[float]):\n            return any(x)\n\n        def fn2(x: List[bool]):\n            return any(x)\n\n        def fn3(x: List[str]):\n            return any(x)\n\n        self.checkScript(fn, ([0, 0, 0, 0], ))\n        self.checkScript(fn, ([0, 3, 0], ))\n        self.checkScript(fn, ([], ))\n        self.checkScript(fn1, ([1.0, 2.0, 3.0], ))\n        self.checkScript(fn1, ([0.0, 0.0, 0.0], ))\n        self.checkScript(fn1, ([0, 0, 0], ))\n        self.checkScript(fn1, ([], ))\n        self.checkScript(fn2, ([True, False, False], ))\n        self.checkScript(fn2, ([False, False, False], ))\n        self.checkScript(fn2, ([True, True, True, True], ))\n        self.checkScript(fn2, ([], ))\n        self.checkScript(fn3, ([\"\", \"\", \"\"], ))\n        self.checkScript(fn3, ([\"\", \"\", \"\", \"-1\"], ))\n        self.checkScript(fn3, ([], ))\n\n    def test_script_module_not_tuple(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['mods']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = 1\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    print(m)\n                return v\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not iterable\"):\n            M()\n\n    def test_attr_module_constants(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self, mod_list):\n                super(M2, self).__init__()\n                self.mods = mod_list\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.mods.forward(x)\n\n        with torch.jit.optimized_execution(False):\n            m = M2(nn.Sequential(nn.ReLU()))\n            self.assertExportImportModule(m, (torch.randn(2, 2),))\n\n    def test_script_sequential_for(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.Sequential(Sub(), Sub(), Sub())\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for m in self.mods:\n                    v = m(v)\n                return v\n\n            @torch.jit.script_method\n            def forward2(self, v):\n                return self.mods(v)\n\n        with torch.jit.optimized_execution(False):\n            i = torch.empty(2)\n            m = M()\n            o = m(i)\n            v = i\n            for sub in m.mods._modules.values():\n                v = sub(v)\n            self.assertEqual(o, v)\n\n            o2 = m.forward2(i)\n            self.assertEqual(o2, v)\n\n    def test_script_sequential_sliced_iteration(self):\n        class seq_mod(nn.Module):\n            def __init__(self):\n                super(seq_mod, self).__init__()\n                self.layers = [nn.ReLU(), nn.ReLU(), nn.ReLU()]\n                self.layers = nn.Sequential(*self.layers)\n\n            def forward(self, input):\n                x = self.layers[0].forward(input)\n                for layer in self.layers[1:3]:\n                    x = layer.forward(x)\n                for layer in self.layers[2:]:\n                    x = layer.forward(x)\n                return x\n\n        seq = seq_mod()\n        self.checkModule(seq, [torch.tensor([-2, 1, -1, 2])])\n\n    def test_script_sequential_orderdict(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.Sequential(OrderedDict([\n                    (\"conv\", nn.Conv2d(1, 20, 5)),\n                    (\"relu\", nn.ReLU())\n                ]))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                return self.mods(input)\n\n        m = M()\n        self.assertTrue('mods.conv.weight' in m.state_dict().keys())\n\n    def test_script_sequential_multi_output_fail(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class ReturnMulti(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ReturnMulti, self).__init__()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x, x, x\n\n        class HaveSequential(torch.jit.ScriptModule):\n            def __init__(self):\n                super(HaveSequential, self).__init__()\n                self.someseq = nn.Sequential(\n                    Sub(),\n                    ReturnMulti(),\n                    Sub()\n                )\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.someseq(x)\n\n        with self.assertRaisesRegex(RuntimeError, \"(Tensor, Tensor, Tensor)\"):\n            with torch.jit.optimized_execution(False):\n                hs = HaveSequential()\n                i = torch.empty(2)\n                hs(i)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_script_sequential_in_mod_list(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([Sub(), nn.Sequential(Sub(), nn.Sequential(Sub(), Sub()), Sub())])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for mod in self.mods:\n                    v = mod(v)\n                return v\n\n        m = M()\n        graph = str(m.graph)\n        self.assertTrue(graph.count(\"prim::CallMethod\") == 2)\n        self.assertTrue(\"python\" not in graph)\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_script_nested_mod_list(self):\n        class Sub(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Sub, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.mods = nn.ModuleList([nn.ModuleList([Sub()]), nn.Sequential(Sub()), nn.ModuleList([Sub(), Sub()])])\n\n            @torch.jit.script_method\n            def forward(self, v):\n                for mod in self.mods:\n                    for m in mod:\n                        v = m(v)\n                return v\n\n        m = M()\n        graph = str(m.graph)\n        self.assertTrue(graph.count(\"prim::CallMethod\") == 4)\n        self.assertTrue(\"python\" not in graph)\n\n    def test_constant_as_attr(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['dim']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.dim = 1\n\n            @torch.jit.script_method\n            def forward(self, v):\n                return torch.cat([v, v, v], dim=self.dim)\n        v = torch.zeros(1, 1)\n        with torch.jit.optimized_execution(False):\n            self.assertEqual(torch.cat([v, v, v], dim=1), M()(v))\n\n    class StarTestSumStarred(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestSumStarred, self).__init__()\n\n        def forward(self, *inputs):\n            output = inputs[0]\n            for i in range(1, len(inputs)):\n                output += inputs[i]\n            return output\n\n    class StarTestReturnThree(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestReturnThree, self).__init__()\n\n        def forward(self, rep):\n            return rep, rep, rep\n\n    def test_script_star_expr(self):\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.m = torch.jit.trace(TestScript.StarTestSumStarred(),\n                                         (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)))\n                self.g = torch.jit.trace(TestScript.StarTestReturnThree(), torch.ones(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, rep):\n                tup = self.g(rep)\n                return self.m(*tup)\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    def test_script_star_expr_string(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.m = torch.jit.trace(TestScript.StarTestSumStarred(),\n                                         (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)))\n                self.g = torch.jit.trace(TestScript.StarTestReturnThree(), torch.ones(4, 3))\n\n                self.define('''\n            def forward(self, rep):\n                tup = self.g(rep)\n                return self.m(*tup)\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    class StarTestSumAndReturnThree(torch.nn.Module):\n        def __init__(self):\n            super(TestScript.StarTestSumAndReturnThree, self).__init__()\n\n        def forward(self, *inputs):\n            output = inputs[0]\n            for i in range(1, len(inputs)):\n                output += inputs[i]\n            return output, output, output\n\n    def test_script_star_assign(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(TestScript.StarTestSumAndReturnThree(), torch.ones(4, 3))\n                self.define('''\n            def forward(self, rep):\n                head, *tail = self.g(rep)\n                return head\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.zeros(4, 3)), 3 * torch.zeros(4, 3))\n\n    def test_script_module_star_assign2(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(\n                    TestScript.StarTestSumAndReturnThree(),\n                    (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)),\n                    _force_outplace=True)\n                self.define('''\n            def forward(self, rep):\n                *head, tail = self.g(rep, rep, rep)\n                return tail\n                ''')\n\n        m = M2()\n        self.assertEqual(m(torch.ones(4, 3)), 3 * torch.ones(4, 3))\n\n    def test_script_module_star_assign2_inplace(self):\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                self.g = torch.jit.trace(\n                    TestScript.StarTestSumAndReturnThree(),\n                    (torch.ones(4, 3), torch.ones(4, 3), torch.ones(4, 3)),\n                    _force_outplace=False)\n                self.define('''\n            def forward(self, rep):\n                *head, tail = self.g(rep, rep, rep)\n                return tail\n                ''')\n\n        m = M2()\n        # since forward() makes three aliases to the input `rep` before passing\n        # it to StarTestSumAndReturnThree(), in-place behavior will be different\n        # than the above out of place.\n        self.assertEqual(m(torch.ones(4, 3)), 4 * torch.ones(4, 3))\n\n    def test_script_module_star_assign_fail_pythonop(self):\n\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            class M2(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M2, self).__init__()\n\n                    @torch.jit.ignore\n                    def myfunc():\n                        return torch.zeros(1, 2, 3), torch.zeros(1, 2, 3)\n\n                    self.define('''\n                def forward(self, rep):\n                    a, *b = myfunc()\n                    return a\n                    ''')\n\n            m = M2()\n            m(torch.zeros(4, 3))\n\n    def test_script_module_star_assign_fail_builtin(self):\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            class M2(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M2, self).__init__()\n\n                    self.define('''\n                def forward(self, rep):\n                    a, *b = torch.neg(rep)\n                    return a\n                    ''')\n\n            m = M2()\n            m(torch.zeros(4, 3))\n\n    def test_script_pack_padded_sequence(self):\n        from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence\n\n        def pack_padded_pad_packed_script(x, seq_lens):\n            x = pack_padded_sequence(x, seq_lens)\n            x, lengths = pad_packed_sequence(x)\n            return x, lengths\n\n        T, B, C = 3, 5, 7\n        x = torch.ones((T, B, C))\n        seq_lens = torch.tensor([3, 3, 2, 2, 1])\n        # set padding value so we can test equivalence\n        for b in range(B):\n            if seq_lens[b] < T:\n                x[seq_lens[b]:, b, :] = 0\n\n        eager_seq, eager_lengths = pack_padded_pad_packed_script(x, seq_lens)\n        with torch._jit_internal._disable_emit_hooks():\n            scripted_pack_padded_seq = torch.jit.script(pack_padded_pad_packed_script)\n        script_seq, script_lengths = scripted_pack_padded_seq(x, seq_lens)\n        self.assertEqual(eager_seq, script_seq)\n        self.assertEqual(eager_lengths, script_lengths)\n\n        class ExperimentalLSTM(torch.nn.Module):\n            def __init__(self, input_dim, hidden_dim):\n                super().__init__()\n\n            def forward(self, input):\n                # type: (Tensor)\n                packed = pack_padded_sequence(\n                    input=input, lengths=torch.tensor([1, 2]), enforce_sorted=False\n                )\n                output, lengths = pad_packed_sequence(\n                    sequence=packed, total_length=2\n                )\n                # lengths is flipped, so is output\n                return output[0]\n\n        lstm = ExperimentalLSTM(input_dim=2, hidden_dim=2)\n\n        with torch._jit_internal._disable_emit_hooks():\n            self.checkModule(lstm, [torch.ones(2, 2)])\n\n    def test_script_pad_sequence_pack_sequence(self):\n        from torch.nn.utils.rnn import pad_sequence, pack_sequence, pad_packed_sequence\n\n        def pad_sequence_func(tensor_list, batch_first=False, padding_value=0.0):\n            # type: (List[Tensor], bool, float) -> Tensor\n            return pad_sequence(tensor_list, batch_first, padding_value)\n\n        def pack_sequence_func(tensor_list, enforce_sorted=True):\n            # type: (List[Tensor], bool) -> Tensor\n            return pad_packed_sequence(pack_sequence(tensor_list, enforce_sorted))[0]\n\n        ones3 = torch.ones(3, 5)\n        ones4 = torch.ones(4, 5)\n        ones5 = torch.ones(5, 5)\n        tensor1 = torch.tensor([1, 2, 3])\n        tensor2 = torch.tensor([4, 5])\n        tensor3 = torch.tensor([6])\n        with torch._jit_internal._disable_emit_hooks():\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5],))\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5], True))\n            self.checkScript(pad_sequence_func,\n                             ([ones3, ones4, ones5], True, 2.5))\n            self.checkScript(pack_sequence_func,\n                             ([tensor1, tensor2, tensor3],))\n            self.checkScript(pack_sequence_func,\n                             ([tensor1, tensor2, tensor3], False))\n\n    def test_script_get_tracing_state(self):\n        def test_if_tracing(x):\n            if torch._C._get_tracing_state():\n                return x + 1\n            else:\n                return x - 1\n\n        inp = torch.randn(3, 3)\n        self.checkScript(test_if_tracing, (inp,))\n\n    def test_script_is_tracing(self):\n        def test_is_tracing(x):\n            if torch.jit.is_tracing():\n                return x + 1\n            else:\n                return x - 1\n\n        inp = torch.randn(3, 3)\n        self.checkScript(test_is_tracing, (inp,))\n\n    def test_is_scripting(self):\n        def foo():\n            return torch.jit.is_scripting()\n\n        self.assertFalse(foo())\n        scripted = torch.jit.script(foo)\n        self.assertTrue(scripted())\n\n    def test_comment_ignore_indent(self):\n        class Model(torch.nn.Module):\n            def __init__(self):\n    # useless comment that is not indented correctly  # noqa: E115\n                super().__init__()\n\n            def forward(self):\n                return 5\n\n        # should compile without an error\n        self.checkModule(Model(), ())\n\n    def test_script_outputs(self):\n        with self.assertRaisesRegex(RuntimeError, \"cannot be used as a tuple\"):\n            @torch.jit.script\n            def foo(a):\n                c, d = a + a\n                return c + d\n\n        @torch.jit.script\n        def return3():\n            return 1, 2, 3\n\n        with self.assertRaisesRegex(RuntimeError, \"too many values to unpack\"):\n            @torch.jit.script\n            def bind2():\n                a, b = return3()\n                print(a)\n                print(b)\n\n    @unittest.skipIf(not RUN_CUDA, \"requires CUDA\")\n    def test_script_get_device_cuda(self):\n        @torch.jit.script\n        def foo(a):\n            return a.get_device()\n\n        v = torch.randn(1, device='cuda')\n        self.assertEqual(foo(v), 0)\n\n    def test_script_chunk(self):\n        @torch.jit.script\n        def foo(a):\n            b, c = torch.chunk(a, dim=0, chunks=2)\n            return b\n        v = torch.rand(10, 3)\n        self.assertEqual(torch.chunk(v, dim=0, chunks=2)[0], foo(v))\n\n    def test_script_copy(self):\n        class M(torch.nn.Module):\n            __annotations__ = {\n                \"val\": Optional[torch.Tensor]\n            }\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.val = None\n\n            def some_method(self):\n                return 3\n\n            def forward(self, x):\n                # type: (Tensor) -> Tensor\n                self.val = x + self.some_method()\n                return x\n\n        m = torch.jit.script(M())\n        # test copy\n        copy.copy(m)\n        copy.deepcopy(m)\n\n    def test_script_forward_method_replacement(self):\n        # We want to support the use case of attaching a different `forward` method\n        class LowLevelModule(torch.nn.Module):\n            def __init__(self):\n                super(LowLevelModule, self).__init__()\n\n            def forward(self, input: torch.Tensor):\n                # Generic forward dispatch\n                return self.forward_pytorch(input) * 2\n\n        class TestModule(LowLevelModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n                # Replace the forward method\n                self.forward = types.MethodType(LowLevelModule.forward, self)\n\n            def forward_pytorch(self, input: torch.Tensor):\n                return torch.tensor(123)\n\n            def forward(self, input: torch.Tensor):\n                # Should not use this forward method\n                raise AssertionError(\"This method should not be used\")\n                return self.forward_pytorch(input)\n\n        m = TestModule()\n        self.assertEqual(m(torch.tensor(1)), torch.tensor(246))\n\n        m_scripted = torch.jit.script(m)\n        self.assertEqual(m_scripted(torch.tensor(1)), torch.tensor(246))\n\n    def test_python_call_non_tensor(self):\n        def foo(a, b, c):\n            # type: (Tensor, int, Tuple[Tensor, int]) -> Tuple[int, Tensor]\n            d, e = c\n            return b + e, a + d\n\n        @torch.jit.script\n        def bar():\n            x = torch.ones(3, 4)\n            a, b = foo(x, 3, (x, 3))\n            return a, b\n\n        self.assertEqual((6, torch.ones(3, 4) + 1), bar())\n\n    def test_python_call_non_tensor_wrong(self):\n        with self.assertRaisesRegex(RuntimeError, r\"but instead got value of type tuple\"):\n            @torch.jit.ignore\n            def foo():\n                # type: () -> Tensor\n                return ((3, 4),)  # noqa: T484\n\n            @torch.jit.script\n            def bar():\n                return foo()\n\n            bar()\n\n    def test_if_different_type(self):\n        with self.assertRaisesRegex(RuntimeError, \"c0 is set to type \"\n                                    \"int in the true branch and type \"\n                                    \"float in the false branch\"):\n            @torch.jit.script\n            def diff_type_used():\n                if 1 == 2:\n                    c0 = 1\n                else:\n                    c0 = 1.0\n                return c0\n\n        with self.assertRaisesRegex(RuntimeError, \"Variable 'c0' previously had type float\"):\n            @torch.jit.script\n            def diff_existing_type(x):\n                c0 = 1.0\n                if 1 == 2:\n                    c0 = 1\n                    print(x)\n                return x\n\n        @torch.jit.script\n        def diff_type_unused():\n            if 1 == 1:\n                c0 = 1\n                print(c0)\n            else:\n                c0 = 1.0\n                print(c0)\n            return 1\n\n    def test_if_not_defined_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"c0 is not defined in the false branch\"):\n            @torch.jit.script\n            def test():\n                if 1 == 1:\n                    c0 = 1\n                return c0\n        with self.assertRaisesRegex(RuntimeError, \"c0 is not defined in the true branch\"):\n            @torch.jit.script\n            def test2():\n                if 1 == 1:\n                    pass\n                else:\n                    c0 = 1\n                return c0\n\n    def test_if_list_cat(self):\n        # testing that different length lists don't throw error on cat in shape prop\n        @torch.jit.script\n        def test_list(x):\n            if bool(x.sum() < 1):\n                c = [x, x]\n            else:\n                c = [x, x, x]\n            return torch.cat(c)\n\n        b = torch.zeros(2, 4)\n        _propagate_shapes(test_list.graph, (b,), False)\n\n    def test_if_supertype(self):\n        @torch.jit.script\n        def tensor_unifying(x, y, z):\n            # testing dynamic is appropriately set for y and z\n            if bool(x):\n                x, y, z = x + 1, y, z\n            else:\n                x, y, z = x + 1, x, y\n\n            return x, y, z\n\n        a = torch.zeros(2, 2, dtype=torch.float)\n        b = torch.zeros(2, 4, dtype=torch.long)\n        c = torch.zeros(2, 4, dtype=torch.float)\n\n        graph = _propagate_shapes(tensor_unifying.graph, (a, b, c), False)\n        if_outputs = list(graph.findNode(\"prim::If\").outputs())\n        self.assertTrue(if_outputs[0].type().str() == \"Float(*, *, requires_grad=0, device=cpu)\")\n        self.assertTrue(if_outputs[1].type().str() == \"Tensor(*, *, requires_grad=0, device=cpu)\")\n        self.assertTrue(if_outputs[2].type().str() == \"Tensor(*, *, requires_grad=0, device=cpu)\")\n\n    def test_list_unify(self):\n        # allowing a unififed int?[] would cause a runtime error b/c\n        # the index operation expects int?[] to be a generic list,\n        # but in the true branch the IValue will be a int list\n        with self.assertRaisesRegex(RuntimeError, \"int[] in the true branch and type None[]\"):\n            @torch.jit.script\n            def list_optional_fails(x):\n                # type: (bool) -> Optional[int]\n                if x:\n                    y = [1]\n                else:\n                    y = [None]  # noqa: T484\n                return y[0]\n\n        @torch.jit.script\n        def list_tensors(x):\n            # type: (bool) -> Tuple[Tensor, List[Tensor]]\n            if x:\n                a = torch.zeros([1, 1])\n                y = [a]\n            else:\n                a = torch.zeros([1, 2])\n                y = [a]\n            return a, y\n\n        self.run_pass('constant_propagation', list_tensors.graph)\n        m = self.createFunctionFromGraph(list_tensors.graph)\n        # testing that tensor type of lists is unified\n        self.getExportImportCopy(m)\n\n    @_inline_everything\n    def test_import_constants_not_specialized(self):\n        class Mod(torch.nn.Module):\n            def forward(self, x):\n                return torch.cat(2 * [x], dim=0)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self, mod):\n                super(ScriptMod, self).__init__()\n                x = torch.zeros(1, 3)\n                mod_fn = lambda : mod(x)  # noqa: E731\n                self.mod = torch.jit.trace(mod_fn, tuple())\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.mod()\n\n        cm = ScriptMod(Mod())\n        # specialized tensor in graph\n        FileCheck().check(\"Double(1, 3, strides=[3, 1], requires_grad=0, device=cpu)\").run(cm.forward.graph)\n        buffer = io.BytesIO()\n        torch.jit.save(cm, buffer)\n        buffer.seek(0)\n        # when tensor is loaded as constant it isnt specialized\n        cm_load = torch.jit.load(buffer)\n        FileCheck().check_not(\"Double(1, 3)\").run(cm_load.forward.graph)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_type_annotations_repeated_list(self):\n        @torch.jit.script\n        def float_fn(x, y):\n            # type: (float, BroadcastingList3[float]) -> List[float]\n            return y\n        self.assertEqual(float_fn(2.0, 1.0), float_fn(2.0, [1.0, 1.0, 1.0]))\n        self.assertEqual(float_fn(2.0, 1.0), float_fn(2.0, (1.0, 1.0, 1.0)))\n\n        @torch.jit.script\n        def float_fn_call():\n            print(float_fn(1.0, 1.0))\n            print(float_fn(1.0, (1.0, 1.0, 1.0)))\n\n        @torch.jit.script\n        def int_fn(x):\n            # type: (BroadcastingList3[int]) -> List[int]\n            return x\n        self.assertEqual(int_fn(1), int_fn([1, 1, 1]))\n        self.assertEqual(int_fn(1), int_fn((1, 1, 1)))\n\n        @torch.jit.script\n        def int_fn_call():\n            print(int_fn(1))\n            print(int_fn((1, 1, 1)))\n\n        with self.assertRaisesRegex(RuntimeError, \"must be a positive integer:\"):\n            @torch.jit.script  # noqa: T484\n            def fn(x):\n                # type: (BroadcastingListx[int]) -> List[int]  # noqa: T484\n                return x\n\n        # using CU so that flake8 error on int[2] is not raised (noqa not working)\n        with self.assertRaisesRegex(RuntimeError, \"Unknown type constructor\"):\n            cu = torch.jit.CompilationUnit('''\n                def nested(x, y):\n                    # type: (int, Tuple[int, int[2]]) -> List[int]\n                    return x  # noqa: T484\n            ''')\n\n        @torch.jit.script\n        def f(x: BroadcastingList2[int]):\n            return x\n\n        out = f(1)\n        self.assertTrue(isinstance(out[0], int))\n        self.assertEqual(out, [1, 1])\n\n    def test_ntuple_builtins(self):\n        from torch.nn.modules.utils import _single, _pair, _triple, _quadruple\n\n        def test_ints():\n            return _single(1), _pair(2), _triple(3), _quadruple(4)\n\n        def test_floats():\n            return _single(1), _pair(2.1), _triple(3.1), _quadruple(4.1)\n\n        self.checkScript(test_ints, ())\n        self.checkScript(test_floats, ())\n\n    def test_embedding_renorm_grad_error(self):\n        # Testing that the builtin call to embedding_renorm_ correctly throws\n        # Error when .backward() is called on its input\n\n        def embedding_norm(input, embedding_matrix, max_norm):\n            F.embedding(input, embedding_matrix, max_norm=0.01)\n\n        @torch.jit.script\n        def embedding_norm_script(input, embedding_matrix, max_norm):\n            # type: (Tensor, Tensor, float) -> None\n            F.embedding(input, embedding_matrix, max_norm=0.01)\n\n        for _ in [embedding_norm, embedding_norm_script]:\n            input = torch.tensor([[1, 2, 4, 5], [4, 3, 2, 9]])\n            embedding_matrix = torch.randn(10, 3)\n\n            var1 = torch.randn(10, 3, requires_grad=True)\n            var2 = var1.detach().requires_grad_()\n            output1 = var1 * embedding_matrix\n            output2 = var2 * embedding_matrix\n\n            output1.sum().backward()\n\n            ignore = F.embedding(input, embedding_matrix, max_norm=0.01)\n            with self.assertRaisesRegex(RuntimeError, \"modified\"):\n                output2.sum().backward()\n\n    def test_type_annotations(self):\n        def fn(x, y):\n            # type: (Tensor, Tensor) -> Tuple[Tensor, Tensor, Tensor]\n            return x, x * 2, x * 3\n\n        with self.assertRaisesRegex(RuntimeError, r\"need 4 values .* found only 3\"):\n            @torch.jit.script\n            def script_fn(x):\n                x, y, z, w = fn(x, x)\n\n        with self.assertRaisesRegex(RuntimeError, r\"too many values .* need 2 but found 3\"):\n            @torch.jit.script\n            def script_fn2(x):\n                x, y = fn(x, x)\n\n        def fn_unpack(x):\n            y, z, w = fn(x, x)\n            return y\n\n        def fn_index(x):\n            q = fn(x, x)\n            return x\n\n        def fn_string(str, strpair):\n            # type: (str, Tuple[str, str]) -> Tuple[str, int, str, str]\n            str1, str2 = strpair\n            return str, 2, str1, str2\n\n        x = torch.ones(2, 2)\n        self.checkScript(fn_unpack, (x,), optimize=True)\n        self.checkScript(fn_index, (x,), optimize=True)\n        self.checkScript(fn_string, (\"1\", (\"3\", \"4\")), optimize=True)\n\n    def test_type_annotations_varargs(self):\n        @torch.jit.ignore\n        def fn_varargs(x, *args):\n            return args[0] if args else x\n\n        def fn1(x, y, z):\n            return fn_varargs(x)\n\n        def fn2(x, y, z):\n            return fn_varargs(x, y)\n\n        def fn3(x, y, z):\n            return fn_varargs(x, y, z)\n\n        x, y, z = [torch.randn(2, 2) for _ in range(3)]\n        self.checkScript(fn1, (x, y, z), optimize=True)\n        self.checkScript(fn2, (x, y, z), optimize=True)\n        self.checkScript(fn3, (x, y, z), optimize=True)\n\n    def test_type_annotation_py3(self):\n        code = dedent(\"\"\"\n        import torch\n        from torch import Tensor\n        from typing import Tuple\n\n        def fn(x : torch.Tensor, y : Tensor, z) -> Tuple[Tensor, Tensor, Tensor]:\n            return (x, y + z, z)\n        \"\"\")\n\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            script_path = os.path.join(tmp_dir, 'script.py')\n            with open(script_path, 'w') as f:\n                f.write(code)\n            fn = get_fn('test_type_annotation_py3', script_path)\n            fn = torch.jit.ignore(fn)\n\n            with self.assertRaisesRegex(RuntimeError, r\"Expected a value of type 'Tensor' for argument\"\n                                                      r\" 'x' but instead found type 'Tuple\\[Tensor,\"):\n                @torch.jit.script\n                def bad_fn(x):\n                    x, y = fn((x, x), x, x)\n                    return y\n\n            with self.assertRaisesRegex(RuntimeError, r\"too many values .* need 2 but found 3\"):\n                @torch.jit.script\n                def bad_fn2(x):\n                    x, y = fn(x, x, x)\n                    return y\n\n            with self.assertRaisesRegex(RuntimeError, r\"need 4 values .* found only 3\"):\n                @torch.jit.script\n                def bad_fn3(x):\n                    x, y, z, w = fn(x, x, x)\n                    return y\n\n            def good_fn(x):\n                y, z, w = fn(x, x, x)\n                return y, z, w\n\n            self.checkScript(good_fn, (torch.ones(2, 2),), optimize=True)\n\n    def test_type_annotation_module(self):\n        class BaseModule(torch.jit.ScriptModule):\n            @torch.jit.ignore\n            def foo(self, x):\n                # type: (Tensor) -> Tensor\n                return x + 1\n\n            @torch.jit.ignore\n            def bar(self, x, y):\n                # type: (Tensor, Tensor) -> Tuple[Tensor, Tensor]\n                return x + y, y\n\n            @torch.jit.ignore\n            def baz(self, x, y):\n                return x\n\n        class ModuleTooMany(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                return self.foo(x, x)\n\n        class ModuleTooFew(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                return self.bar(x)\n\n        class ModuleTooManyAssign(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                y, z, w = self.bar(x, x)\n                return x\n\n        class ModuleDefault(BaseModule):\n            @torch.jit.script_method\n            def method(self, x):\n                y = self.baz(x)\n                return x\n\n        with self.assertRaisesRegex(RuntimeError, \"Expected at most 2 arguments but found 3\"):\n            ModuleTooMany()\n        with self.assertRaisesRegex(RuntimeError, \"Argument y not provided\"):\n            ModuleTooFew()\n        with self.assertRaisesRegex(RuntimeError, \"need 3 values .* found only 2\"):\n            ModuleTooManyAssign()\n        with self.assertRaisesRegex(RuntimeError, \"Argument y not provided.\"):\n            ModuleDefault()\n\n    def test_type_inferred_from_empty_annotation(self):\n        \"\"\"\n        Test that the type inferred from an empty or missing annotation is Torch.Tensor wtih `inferred=true`\n        \"\"\"\n        @torch.jit.script\n        def fn(x):\n            return x\n\n        graph = fn.graph\n        n = next(graph.inputs())\n        self.assertTrue(n.type() == torch._C.TensorType.getInferred())\n\n        with self.assertRaisesRegex(RuntimeError, \"Inferred \\'x\\' to be of type \\'Tensor\"):\n            fn(\"1\")\n\n    def test_script_define_order(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input)\n\n            @torch.jit.script_method\n            def foo(self, input):\n                return input + 1\n        m = M()\n        self.assertEqual(2, m.call_foo(torch.ones((), dtype=torch.int64)))\n\n    def test_script_define_order_recursive_fail(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input)\n\n            @torch.jit.script_method\n            def foo(self, input):\n                self.call_foo(input)\n\n        with self.assertRaisesRegex(RuntimeError, 'called recursively'):\n            M()\n\n    def test_script_kwargs_fn_call(self):\n        class M(torch.jit.ScriptModule):\n\n            @torch.jit.script_method\n            def call_foo(self, input):\n                return self.foo(input=input, bar=1)\n\n            @torch.jit.script_method\n            def foo(self, bar, input):\n                # type: (int, Tensor) -> Tensor\n                return input + bar\n        m = M()\n        self.assertEqual(2, m.call_foo(torch.ones((), dtype=torch.int64)))\n\n    def test_if_define(self):\n        @torch.jit.script\n        def foo(a):\n            if bool(a == 0):\n                b = 1\n            else:\n                b = 0\n            return b + 1\n\n        @torch.jit.script\n        def foo2(a):\n            b = 0\n            if bool(a == 0):\n                b = 1\n            return b + 1\n\n        @torch.jit.script\n        def foo3(a):\n            b = 1\n            if bool(a == 0):\n                c = 4\n            else:\n                b = 0\n            return b + 1\n\n        a = torch.ones(1, dtype=torch.long)\n        b = torch.zeros(1, dtype=torch.long)\n        self.assertEqual(1, foo(a))\n        self.assertEqual(2, foo(b))\n        self.assertEqual(1, foo2(a))\n        self.assertEqual(2, foo2(b))\n        self.assertEqual(1, foo3(a))\n        self.assertEqual(2, foo3(b))\n\n    def test_script_module_export_submodule(self):\n        class M1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M1, self).__init__()\n                self.weight = nn.Parameter(torch.randn(2))\n\n            @torch.jit.script_method\n            def forward(self, thing):\n                return self.weight + thing\n\n        class M2(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M2, self).__init__()\n                # test submodule\n                self.sub = M1()\n                self.weight = nn.Parameter(torch.randn(2, 3))\n                self.bias = nn.Parameter(torch.randn(2))\n                self.define(\"\"\"\n                    def hi(self, a):\n                        return self.weight.mm(a)\n                \"\"\")\n\n            @torch.jit.script_method\n            def doit(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit2(self, input):\n                return self.weight.mm(input)\n\n            @torch.jit.script_method\n            def doit3(self, input):\n                return input + torch.ones([1], dtype=torch.double)\n\n            @torch.jit.script_method\n            def forward(self, input):\n                a = self.doit(input)\n                b = self.doit2(input)\n                c = self.hi(input)\n                return a + b + self.bias + c\n\n        with torch.jit.optimized_execution(False):\n            m_orig = M2()\n            m_import = self.getExportImportCopy(m_orig)\n\n            input = torch.randn(3, 2)\n            self.assertEqual(m_orig.doit(input), m_import.doit(input))\n            self.assertEqual(m_orig.hi(input), m_import.hi(input))\n            self.assertEqual(m_orig.doit3(input), m_import.doit3(input))\n            self.assertEqual(m_orig.forward(input), m_import.forward(input))\n\n    @slowTest\n    def test_compile_module_with_constant(self):\n        class Double(nn.Module):\n            def __init__(self, downsample=None):\n                super(Double, self).__init__()\n\n            def forward(self, input):\n                return input * 2\n\n        class Mod(nn.Module):\n            __constants__ = ['downsample']\n\n            def __init__(self, downsample=None):\n                super(Mod, self).__init__()\n                self.downsample = downsample\n\n            def forward(self, input):\n                if self.downsample is not None:\n                    return self.downsample(input)\n                return input\n\n        none_mod = torch.jit.script(Mod(None))\n        double_mod = torch.jit.script(Mod(Double()))\n        self.assertEqual(none_mod(torch.tensor(1)), torch.tensor(1))\n        self.assertEqual(double_mod(torch.tensor(1)), torch.tensor(1) * 2)\n\n    def test_device_kwarg(self):\n        from torch import device\n\n        def f():\n            return device(type='cuda'), torch.device(type='cpu')\n        self.checkScript(f, ())\n\n    def test_script_module_export_tensor_type(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, type):\n                super(M, self).__init__()\n                self.param = torch.nn.Parameter(torch.zeros((5, 5), dtype=type).random_())\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param\n\n        with torch.jit.optimized_execution(False):\n            for type in [torch.float, torch.double]:\n                m_orig = M(type)\n                m_import = self.getExportImportCopy(m_orig)\n                # check to make sure the storage wasn't resized\n                self.assertTrue(m_orig.param.storage().size() == 25)\n                self.assertEqual(m_orig.foo(), m_import.foo())\n                self.assertTrue(m_orig.foo().dtype == m_import.foo().dtype)\n\n    @unittest.skipIf(not RUN_CUDA, \"testing cuda tensors require CUDA\")\n    def test_script_module_export_tensor_cuda(self):\n        class M(torch.jit.ScriptModule):\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.param = torch.nn.Parameter(torch.zeros((5, 5), device='cuda:0').random_())\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param\n\n        m_orig = M()\n        m_import = self.getExportImportCopy(m_orig)\n        # check to make sure the storage wasn't resized\n        self.assertTrue(m_orig.param.storage().size() == 25)\n        self.assertTrue(m_import.foo().device == torch.device('cuda:0'))\n        self.assertEqual(m_orig.foo(), m_import.foo())\n        self.assertTrue(m_orig.foo().dtype == m_import.foo().dtype)\n\n    def test_script_module_export_blocks(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, n, m):\n                super(M, self).__init__()\n                self.weight = torch.nn.Parameter(torch.rand(n, m))\n\n            @torch.jit.script_method\n            def forward(self, input):\n                if bool(input.sum() > 0):\n                    output = self.weight.mv(input)\n                else:\n                    output = self.weight + input\n                return output\n\n        m_orig = M(200, 200)\n        m_import = self.getExportImportCopy(m_orig)\n\n        t = torch.rand(200)\n        self.assertEqual(m_orig(t), m_import(t))\n\n    def test_script_module_export_shared_storage(self):\n        class M(torch.jit.ScriptModule):\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.param1 = torch.nn.Parameter(torch.rand(5, 5))\n                self.param2 = torch.nn.Parameter(self.param1[3])\n                self.param3 = torch.nn.Parameter(torch.rand(5, 5))\n                self.param4 = torch.nn.Parameter(torch.rand(11, 5)[1:6])\n\n            @torch.jit.script_method\n            def foo(self):\n                return self.param1 + self.param2 + self.param3 + self.param4\n\n        with torch.jit.optimized_execution(False):\n            m_orig = M()\n            m_import = self.getExportImportCopy(m_orig)\n\n            self.assertEqual(m_orig.foo(), m_import.foo())\n\n            self.assertTrue(m_import.param1.storage().data_ptr() == m_import.param2.storage().data_ptr())\n            self.assertTrue(m_import.param1.storage().data_ptr() != m_import.param3.storage().data_ptr())\n\n    def test_sequential_intermediary_types(self):\n        class A(torch.nn.Module):\n            def __init__(self):\n                super(A, self).__init__()\n\n            def forward(self, x):\n                return x + 3\n\n        class B(torch.nn.Module):\n            def __init__(self):\n                super(B, self).__init__()\n\n            def forward(self, x):\n                return {\"1\": x}\n\n        class C(torch.nn.Module):\n            def __init__(self):\n                super(C, self).__init__()\n                self.foo = torch.nn.Sequential(A(), B())\n\n            def forward(self, x):\n                return self.foo(x)\n\n        self.checkModule(C(), (torch.tensor(1),))\n\n    def test_ellipsis_const_mid(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, Ellipsis, 0:4, 4:8].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_mid_select(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, Ellipsis, 4, 4, 4:8, 2].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_start(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[Ellipsis, 0:4, 4:8].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_const_end(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[0:4, 2, Ellipsis].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_mid(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, ..., 0:4, 4:8].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_mid_select(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[2, ..., 4, 4, 4:8, 2].size()\n\n        dummy = torch.zeros(8, 8, 8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_start(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[..., 0:4, 4:8].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_ellipsis_end(self):\n        def ellipsize(x):\n            # type: (Tensor) -> List[int]\n            return x[0:4, 2, ...].size()\n        dummy = torch.zeros(8, 8, 8, 8, 8)\n        self.checkScript(ellipsize, (dummy,), optimize=True)\n\n    def test_torch_manual_seed(self):\n        with freeze_rng_state():\n            def test():\n                torch.manual_seed(2)\n                return torch.rand(1)\n\n            script = torch.jit.script(test)\n            self.assertEqual(test(), script())\n            graph = script.graph_for()\n            FileCheck().check(\"aten::manual_seed\").run(graph)\n\n    def test_index_select_shape_prop(self):\n\n        @torch.jit.script\n        def foo(x, y):\n            return torch.index_select(x, index=y, dim=1)\n\n        a = torch.zeros(2, 2)\n        b = torch.zeros(4, dtype=torch.long)\n        torch._C._jit_pass_complete_shape_analysis(foo.graph, (a, b), False)\n        FileCheck().check(\"Double(2, 4, strides=[4, 1], requires_grad=0, device=cpu)\").run(str(foo.graph))\n\n    def test_shape_analysis_loop(self):\n        def foo(a, b, x):\n            c = a\n            # on the first iteration of the loop it appears that\n            # c should have a expand to the size of b\n            # but on the second+ iterations, there is no broadcast and the\n            # sizes are different.\n            # previously this would cause the compiler to (1) enter an infinite\n            # loop trying to compute the shape, and (2) insert invalid\n            # broadcasts.\n            # this test ensure we don't regress on these issues\n            for _ in range(2):\n                a = c + b\n                c = x\n                b = x\n            return a\n\n        self.checkScript(foo, (torch.zeros(1), torch.zeros(4), torch.zeros(5)), optimize=False)\n\n    def test_intlist_args(self):\n        def func_1(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, 1)\n\n        def func_2(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, output_size=1)\n\n        def func_3(x):\n            return torch.nn.functional.adaptive_avg_pool1d(x, output_size=[1])\n\n        x = torch.randn(8, 8, 8)\n        self.checkScript(func_1, [x], optimize=True)\n        self.checkScript(func_2, [x], optimize=True)\n        self.checkScript(func_3, [x], optimize=True)\n\n    def test_wrong_implicit_expand(self):\n\n        @_trace(torch.zeros(3), torch.zeros(1))\n        def foo(a, b):\n            return a + b\n\n        a = torch.rand(4)\n        b = torch.rand(4)\n        self.assertEqual(a + b, foo(a, b))\n\n    def test_builtin_args_fails(self):\n\n        with self.assertRaisesRegex(RuntimeError, 'Argument self not provided'):\n            @torch.jit.script\n            def f1(a):\n                torch.sum(foo=4)\n\n        with self.assertRaisesRegex(RuntimeError, 'specified twice'):\n            @torch.jit.script\n            def f2(a):\n                torch.sum(a, self=a)\n\n        with self.assertRaisesRegex(RuntimeError, 'not provided'):\n            @torch.jit.script\n            def f3(a):\n                torch.sum(dim=4)\n\n        with self.assertRaisesRegex(RuntimeError, 'for argument \\'tensors\\' but instead found type \\'Tensor'):\n            @torch.jit.script\n            def f4(a):\n                torch.cat(a)\n\n        with self.assertRaisesRegex(RuntimeError, r'argument \\'tensors\\' but instead found type \\'List\\[int\\]'):\n            @torch.jit.script\n            def f5(a):\n                torch.cat([3])\n\n        with self.assertRaisesRegex(RuntimeError, r'Expected a value of'\n                                    r' type \\'List\\[int\\]\\' for argument'\n                                    r' \\'size\\' but instead found type '\n                                    r'\\'List\\[Union\\[List\\[int\\], int\\]\\]'):\n            @torch.jit.script\n            def f6(a):\n                a.expand(size=[3, [4]])\n\n    def test_builtin_args(self):\n\n        def t0(a):\n            # default arg dim\n            return torch.cat([a, a])\n\n        self.checkScript(t0, (torch.zeros(1, 1),))\n\n        def t1(a):\n            # keywords out of order\n            return torch.cat(dim=1, tensors=[a, a])\n\n        self.checkScript(t1, (torch.zeros(1, 1, 2),))\n\n        def t2(a):\n            # mix const/non-const attributes\n            if 1 == 1:\n                b = 1\n            else:\n                b = 0\n            return torch.sum(a, dim=b, keepdim=False)\n\n        self.checkScript(t2, (torch.zeros(1, 1, 2),))\n\n    def test_parser_type_annotations(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : Tensor, y : Tuple[Tuple[Tensor, Tensor], Tensor]) -> Tuple[Tensor, Tensor]:\n                return x, x\n        ''')\n\n        self.assertExpected(str(cu.foo.schema))\n\n    def test_parser_type_annotations_comment(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x, y):\n                # type: (Tensor, Tuple[Tuple[Tensor, Tensor], Tensor]) -> Tuple[Tensor, Tensor]\n                return x, x\n        ''')\n\n        self.assertExpected(str(cu.foo.schema))\n\n    def test_parser_type_annotations_unknown_type(self):\n        with self.assertRaisesRegex(RuntimeError, \"Unknown type name 'Foo'\"):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[Tuple[Foo, Tensor], Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_subscript_non_ident(self):\n        with self.assertRaisesRegex(RuntimeError, r'Subscripted type must be a type identifier'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[Tensor, Tensor][Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_subscript_tensor(self):\n        with self.assertRaisesRegex(RuntimeError, r'Unknown type constructor Tensor'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tensor[Tensor, Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_parser_type_annotations_incompatible_expression(self):\n        with self.assertRaisesRegex(RuntimeError, r'Expression of type \\+ cannot be used in a type expression'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tensor, y : Tuple[3 + 4, Tensor]) -> Tuple[Tensor, Tensor]:\n                    return x, x\n            ''')\n\n    def test_gather_dynamic_index(self):\n        def t(x):\n            gather1 = x[0]\n            idx = 0 + 1\n            gather2 = x[idx]\n            return gather1 + gather2\n\n        self.checkScript(t, (torch.zeros(3, 2, 3),))\n\n    def test_torch_ignore_conversion_to_none(self):\n        class A(torch.nn.Module):\n            def __init__(self):\n                super(A, self).__init__()\n\n            @torch.jit.ignore\n            def ignored(self, a: int) -> None:\n                l: int = len([2 for i in range(a) if i > 2])\n                return\n\n            def forward(self) -> int:\n                a: int = 4\n                b: int = 5\n                self.ignored(a)\n                return a + b\n\n        class B(torch.nn.Module):\n            def __init__(self):\n                super(B, self).__init__()\n\n            @torch.jit.ignore\n            def ignored(self, a: int):\n                l: int = len([2 for i in range(a) if i > 2])\n                return\n\n            def forward(self) -> int:\n                a: int = 4\n                b: int = 5\n                self.ignored(a)\n                return a + b\n\n        modelA = torch.jit.script(A())\n        self.assertEqual(modelA(), 9)\n\n        modelB = torch.jit.script(B())\n        self.assertEqual(modelB(), 9)\n\n    def test_addmm_grad(self):\n        \"\"\" This test checks several things:\n            1. An expand node was inserted before the addmm operating on the\n               bias term.\n            2. The fused form of addmm appears in the ultimate graph that's\n               executed.\n            3. A sum op was emitted for accumulating gradients along the 0th\n               (expanded) dimension of the bias term.\n            4. The correct symbolic representation for the backward pass of the\n               mm operator was emitted (x.t() -> mm)\n\n            TODO: we should actually check these conditions once we have a way\n            to dump the GraphExecutor state. Namely the processed forward graph\n            and the backward graph.\n        \"\"\"\n        @torch.jit.script\n        def addmm_grad_test(b, x, w):\n            return torch.addmm(b, x, w)\n\n        # Initialize param and input values\n        w_init = torch.rand(2, 5)\n        b_init = torch.rand(5)\n        x = torch.rand(3, 2)\n\n        # Clone trainable params\n        b = b_init.clone()\n        b.requires_grad_()\n        w = w_init.clone()\n        w.requires_grad_()\n\n        # Test symbolic differentiation\n        y = addmm_grad_test(b, x, w)\n        y.sum().backward()\n\n        # clone params for autograd reference\n        b_ref = b_init.clone()\n        b_ref.requires_grad_()\n        w_ref = w_init.clone()\n        w_ref.requires_grad_()\n        y_ref = torch.addmm(b_ref, x, w_ref)\n        y_ref.sum().backward()\n\n        self.assertEqual(w.grad, w_ref.grad)\n        self.assertEqual(b.grad, b_ref.grad)\n\n    @unittest.skipIf(not RUN_CUDA, \"running tests on cuda to verify cudnn fix\")\n    def test_batch_norm_inference_backward_cuda(self):\n        with enable_profiling_mode_for_profiling_tests():\n            class MyBatchNorm(torch.nn.Module):\n                def __init__(self, num_features, affine, track_running_stats):\n                    super(MyBatchNorm, self).__init__()\n                    self.bn = torch.nn.BatchNorm2d(\n                        num_features, 1e-5, affine=affine, track_running_stats=track_running_stats).float()\n\n                def forward(self, x: torch.Tensor):\n                    o = self.bn(x)\n                    o = torch.nn.functional.relu(o)\n                    return o\n\n            batch = 4\n            c = 2\n            hw = 3\n            # Initialize param and input values\n            x_init = torch.randn(batch, c, hw, hw, dtype=torch.float).cuda()\n            grad = torch.randn(batch, c, hw, hw, dtype=torch.float).cuda()\n\n            training = False\n            affine = True\n            track_running_stats = True\n\n            module = torch.jit.script(MyBatchNorm(c, affine, track_running_stats)).cuda()\n            ref_module = MyBatchNorm(c, affine, track_running_stats).cuda()\n            module.eval()\n            ref_module.eval()\n\n            jit_module = torch.jit.script(module)\n            ref_module.load_state_dict(module.state_dict())\n\n            x = x_init.detach().clone()\n            x.requires_grad_()\n            x_ref = x_init.detach().clone()\n            x_ref.requires_grad_()\n\n            # Test symbolic differentiation\n            # Run Forward and Backward thrice to trigger autodiff graph\n            for i in range(0, 3):\n                y = jit_module(x)\n                y.backward(grad)\n            x.grad.zero_()\n\n            module.bn.running_mean.zero_()\n            module.bn.running_var.fill_(1.0)\n            ref_module.bn.running_mean.zero_()\n            ref_module.bn.running_var.fill_(1.0)\n\n            # run jitted module\n            y = jit_module(x)\n            y.backward(grad)\n            # reference computation\n            y_ref = ref_module(x_ref)\n            y_ref.backward(grad)\n\n            self.assertEqual(y_ref, y)\n            self.assertEqual(x.grad, x_ref.grad)\n            self.assertEqual(module.bn.running_mean, ref_module.bn.running_mean)\n            self.assertEqual(module.bn.running_var, ref_module.bn.running_var)\n\n    def test_zeros(self):\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['d']\n\n            def __init__(self):\n                super(M, self).__init__()\n                self.d = torch.device('cpu')\n\n            @torch.jit.script_method\n            def create(self):\n                return torch.zeros([1, 1, 2], dtype=torch.float, device=self.d, layout=torch.strided)\n\n        r = M().create()\n        self.assertEqual(r.dtype, torch.float)\n        self.assertEqual(torch.zeros([1, 1, 2], dtype=torch.float), r)\n\n        def fn():\n            return torch.zeros((1, 2, 3))\n\n        self.checkScript(fn, ())\n\n    def test_vararg_zeros(self):\n        def foo():\n            return torch.zeros(3, 4, 5, dtype=torch.int)\n\n        self.checkScript(foo, ())\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.LEGACY, \"the original version of test_rand\")\n    def test_rand(self):\n        def test_rand():\n            a = torch.rand([3, 4])\n            return a + 1.0 - a\n\n        self.checkScript(test_rand, ())\n        fn = torch.jit.script(test_rand)\n        out = fn()\n        self.assertEqual(out.dtype, torch.double)\n        g = fn.graph_for()\n        # Testing shape analysis correctly setting type\n        if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n            FileCheck().check(\"Double(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Float(*, *, requires_grad=0, device=cpu)\").run(g)\n\n        @torch.jit.script\n        def randint():\n            return torch.randint(0, 5, [1, 2])\n        out = randint()\n        self.assertEqual(out.dtype, torch.int64)\n        if GRAPH_EXECUTOR != ProfilingMode.SIMPLE:\n            FileCheck().check(\"Long(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Float(*, *, requires_grad=0, device=cpu)\") \\\n                       .check_not(\"Double(*, *, requires_grad=0, device=cpu)\") \\\n                       .run(randint.graph_for())\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"skip if profiling isn't enabled\")\n    def test_autodiff_complex(self):\n        def foo(x: torch.Tensor, y: torch.Tensor, W: torch.Tensor):\n            return torch.exp(torch.mm(torch.complex(x, y), W.cfloat()))\n\n        @torch.jit.script\n        def jitted_foo(x: torch.Tensor, y: torch.Tensor, W: torch.Tensor):\n            return torch.exp(torch.mm(torch.complex(x, y), W.cfloat()))\n\n        x = torch.randn(128, 16, dtype=torch.float32, device='cuda:0')\n        y = torch.randn(128, 16, dtype=torch.float32, device='cuda:0')\n        W = torch.randn(16, 1, dtype=torch.float32, device='cuda:0', requires_grad=True)\n        W.data /= 4\n\n        with enable_profiling_mode_for_profiling_tests():\n            for i in range(4):\n                self.assertTrue((foo(x, y, W).grad_fn is None) == (jitted_foo(x, y, W).grad_fn is None))\n\n\n    def test_linear_grad(self):\n        with enable_profiling_mode_for_profiling_tests():\n            def t(x: torch.Tensor, w: torch.Tensor, b: Optional[torch.Tensor]):\n                return torch.nn.functional.linear(x, w, b)\n\n            x_init = torch.randn(4, 2)\n            w_init = torch.randn(3, 2)\n            b_init = torch.randn(3)\n            grad = torch.randn(4, 3)\n\n            with disable_autodiff_subgraph_inlining():\n                # script module\n                jit_t = torch.jit.script(t)\n\n                x = x_init.detach().requires_grad_()\n                w = w_init.detach().requires_grad_()\n                b = b_init.detach().requires_grad_()\n                x_ref = x_init.detach().requires_grad_()\n                w_ref = w_init.detach().requires_grad_()\n                b_ref = b_init.detach().requires_grad_()\n\n                # profiling/optimization runs\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n\n                x.grad.zero_()\n                w.grad.zero_()\n                b.grad.zero_()\n                jit_o = jit_t(x, w, b)\n                jit_o.backward(grad)\n                o = t(x_ref, w_ref, b_ref)\n                o.backward(grad)\n\n                self.assertEqual(jit_o, o)\n                self.assertEqual(x.grad, x_ref.grad)\n                self.assertEqual(w.grad, w_ref.grad)\n                self.assertEqual(b.grad, b_ref.grad)\n\n                x.grad.zero_()\n                w.grad.zero_()\n                x_ref.grad.zero_()\n                w_ref.grad.zero_()\n                jit_o = jit_t(x, w, None)\n                jit_o.backward(grad)\n                o = t(x_ref, w_ref, None)\n                o.backward(grad)\n\n                self.assertEqual(jit_o, o)\n                self.assertEqual(x.grad, x_ref.grad)\n                self.assertEqual(w.grad, w_ref.grad)\n\n    @unittest.skipIf(GRAPH_EXECUTOR != ProfilingMode.PROFILING, \"the profiling version of test_rand\")\n    def test_rand_profiling(self):\n        def test_rand():\n            a = torch.rand([3, 4])\n            return a + 1.0 - a\n\n        # Testing shape analysis correctly setting type\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(1):\n                fn = torch.jit.script(test_rand)\n                out = fn()\n                graph_str = torch.jit.last_executed_optimized_graph()\n                self.assertEqual(out.dtype, torch.double)\n                FileCheck().check(\"Double(3, 4, strides=[4, 1], requires_grad=0, device=cpu)\") \\\n                           .check_not(\"Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu)\").run(graph_str)\n\n            # fn = self.checkScript(test_rand, ())\n            # out = fn()\n            # self.assertEqual(out.dtype, torch.double)\n\n        @torch.jit.script\n        def randint():\n            return torch.randint(0, 5, [1, 2])\n\n        with enable_profiling_mode_for_profiling_tests():\n            with num_profiled_runs(1):\n                out = randint()\n                graph_str = torch.jit.last_executed_optimized_graph()\n                self.assertEqual(out.dtype, torch.int64)\n                FileCheck().check(\"profiled_type=Long(1, 2, strides=[2, 1], requires_grad=0, device=cpu)\").run(graph_str)\n\n\n    def test_erase_number_types(self):\n        def func(a):\n            b = 7 + 1 + 3\n            c = a + b\n            c += b\n            return c\n\n        graph = torch.jit.script(func).graph\n        FileCheck().check(\"int = prim::Constant\").check(\"aten::add_\").run(str(graph))\n        self.run_pass(\"erase_number_types\", graph)\n        FileCheck().check_not(\"int = prim::Constant\").run(str(graph))\n\n    def test_refine_tuple_types(self):\n        # TupleConstruct output type is not correct here.\n        graph_str = \"\"\"\n        graph(%a : Float(123), %b : Float(4, 5, 6)):\n          %c : (Tensor, Tensor) = prim::TupleConstruct(%a, %b)\n          return (%c)\n        \"\"\"\n        graph = parse_ir(graph_str)\n        torch._C._jit_pass_refine_tuple_types(graph)\n\n        # After the pass, the output type should've been updated.\n        self.assertTrue('(Float(123), Float(4, 5, 6))' in str(graph.findNode('prim::TupleConstruct').output()))\n\n    # TODO(henrytu): Add test for RefineTypes for NamedTuple when it's supported by IR parser.\n\n    def test_remove_dropout(self):\n        weight_0_shape = (20, 5)\n        weight_1_shape = (20, 20)\n        input_shape = (10, 5)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n                self.weight_0 = torch.nn.Parameter(torch.rand(weight_0_shape))\n                self.weight_1 = torch.nn.Parameter(torch.rand(weight_1_shape))\n\n            def forward(self, x):\n                o = F.linear(x, self.weight_0)\n                o = F.dropout(o, training=self.training)\n                o = F.linear(o, self.weight_1)\n                return o\n\n        data = torch.rand(input_shape)\n        m = M()\n        m = torch.jit.script(m)\n        with self.assertRaisesRegex(RuntimeError, r'Dropout removal module in training mode is not yet supported'):\n            torch._C._jit_pass_remove_dropout(m._c)\n        m.eval()\n        ref_res = m(data)\n        # Need to inline otherwise we see instances of Function.\n        # We would have to use torch.linear/dropout to get around it otherwise.\n        from torch.jit._recursive import wrap_cpp_module\n        m = wrap_cpp_module(torch._C._freeze_module(m._c))\n        torch._C._jit_pass_remove_dropout(m._c)\n        res = m(data)\n        FileCheck().check_not(\"aten::dropout\").run(str(m.graph))\n        torch.testing.assert_close(ref_res, res, rtol=1e-2, atol=1e-3)\n\n    def test_unfold_zero_dim(self):\n        def fn(x):\n            return x.unfold(0, 1, 1)\n\n        graph = torch.jit.script(fn).graph\n        torch._C._jit_pass_complete_shape_analysis(graph, (torch.tensor(0.39),), False)\n        out_dims = fn(torch.tensor(0.3923)).ndim\n        self.assertEqual(graph.findNode(\"aten::unfold\").output().type().dim(), out_dims)\n\n    def test_mm_batching(self):\n\n        with enable_profiling_mode_for_profiling_tests():\n            lstm_cell = torch.jit.script(LSTMCellS)\n\n            def lstm(x, hx, cx, w_ih, w_hh, b_ih, b_hh):\n                for i in range(x.size(0)):\n                    hx, cx = lstm_cell(x[i], hx, cx, w_ih, w_hh, b_ih, b_hh)\n                return hx\n\n            slstm = torch.jit.script(lstm)\n\n            inputs = get_lstm_inputs('cpu', training=True, seq_length=10)\n            slstm(*inputs, profile_and_replay=True).sum().backward(retain_graph=True)\n            if GRAPH_EXECUTOR == ProfilingMode.PROFILING:\n                slstm(*inputs, profile_and_replay=True).sum().backward()\n\n            fw_graph = slstm.graph_for(*inputs)\n            if GRAPH_EXECUTOR == ProfilingMode.LEGACY:\n                bw_graph = backward_graph(slstm, diff_graph_idx=0)\n                self.assertTrue('prim::MMBatchSide' in str(fw_graph))\n                self.assertTrue('prim::MMTreeReduce' in str(bw_graph))\n\n            sout = slstm(*inputs)\n            out = lstm(*inputs)\n            self.assertEqual(sout, out)\n            self.assertEqual(torch.autograd.grad(sout.sum(), inputs),\n                             torch.autograd.grad(out.sum(), inputs))\n\n    def test_loop_unrolling(self):\n        def fn(x):\n            y = 0\n            for i in range(int(x)):\n                y -= i\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        unroll_factor = 8\n        FileCheck().check(\"prim::Loop\").check_count(\"aten::sub\", unroll_factor) \\\n            .check(\"prim::Loop\").check(\"aten::sub\").run(str(graph))\n        self.checkScript(fn, (torch.tensor(10),))\n\n    def test_loop_unrolling_const(self):\n        def fn():\n            y = 0\n            for _ in range(10):\n                y -= 1\n            return y\n\n        def fn2():\n            y = 0\n            for i in range(10):\n                y -= i\n            return y\n\n        def check(fn, name):\n            graph = torch.jit.script(fn).graph\n            self.run_pass('loop_unrolling', graph)\n            # entirely unrolled\n            FileCheck().check_not(\"prim::Loop'\").run(str(graph))\n            self.checkScript(fn, ())\n\n        check(fn, 'add_const')\n        check(fn2, 'add_iter')\n\n    def test_loop_unrolling_nested(self):\n        def fn(x):\n            y = 0\n            for _ in range(10):\n                for j in range(int(x)):\n                    y -= j\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        # inner loop with 8 subs followed by loop epilogue\n        unroll_factor = 8\n        FileCheck().check(\"prim::Loop\").check(\"prim::Loop\").check_count('aten::sub', unroll_factor) \\\n            .check(\"prim::Loop\").check(\"aten::sub\").run(str(graph))\n        self.checkScript(fn, (torch.tensor(10),))\n\n    def test_loop_unroll_unused_counter(self):\n        def fn(x):\n            y = 0\n            for _ in range(int(x)):\n                y -= 1\n            return y\n\n        graph = torch.jit.script(fn).graph\n        self.run_pass('loop_unrolling', graph)\n        FileCheck().check(\"prim::Loop\").check_not(\"aten::add\").check(\"return\") \\\n            .run(str(graph))\n\n    def test_loop_unroll_negative(self):\n        def fn(x):\n            y = 0\n            for _ in range(int(x)):\n                y += 1\n            return y\n\n        self.checkScript(fn, (torch.tensor(-20),))\n        self.checkScript(fn, (torch.tensor(-2),))\n        self.checkScript(fn, (torch.tensor(-1),))\n        self.checkScript(fn, (torch.tensor(0),))\n        self.checkScript(fn, (torch.tensor(1),))\n        self.checkScript(fn, (torch.tensor(2),))\n\n    def test_where(self):\n        def fn(x, y):\n            return torch.where(x > 0.0, x, y)\n\n        self.checkScript(fn, (torch.randn(3, 2, dtype=torch.float), torch.ones(3, 2, dtype=torch.float)))\n\n    def test_where_method(self):\n        def fn(x, y):\n            return x.where(x > 0.0, y)\n\n        self.checkScript(fn, (torch.randn(3, 2, dtype=torch.float), torch.ones(3, 2, dtype=torch.float)))\n\n    def test_union_to_number(self):\n        @torch.jit.script\n        def fn(x: Union[int, complex, float], y: Union[int, complex, float]):\n            return x + y\n        FileCheck().check(\": Scalar):\").run(fn.graph)\n\n    def test_reassign_module_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot re-assign \\'self\\''):\n            class ReassignSelfLHS(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _ in range(20):\n                        self = x\n                    return self\n\n            ReassignSelfLHS()\n\n    def test_reassign_module_rhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot re-assign \\'x\\' to a value of type module'):\n            class ReassignSelfRHS(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _ in range(20):\n                        x = self\n                    return self\n\n            ReassignSelfRHS()\n\n    def test_unknown_builtin(self):\n        with self.assertRaisesRegex(RuntimeError, 'object has no attribute or method'):\n            @torch.jit.script\n            def unknown_builtin(x):\n                return x.splork(3)\n\n    def test_return_tuple(self):\n        def return_tuple(x):\n            a = (x, x)\n            return a, x\n        self.checkScript(return_tuple, (torch.rand(4),))\n\n    def test_add_tuple_optional(self):\n        def foo(input: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]) -> Optional[torch.Tensor]:\n            changed_input = input[0] + 1\n            value: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]] = (changed_input,) + input[1:]\n            return value[2]\n        inp: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]] = (torch.rand(4), None, None)\n        self.checkScript(foo, (inp,))\n\n    def test_add_tuple_non_optional(self):\n        def foo(input: Tuple[torch.Tensor, torch.Tensor, torch.Tensor]) -> torch.Tensor:\n            changed_input = input[0] + 1\n            value: Tuple[torch.Tensor, torch.Tensor, torch.Tensor] = (changed_input,) + input[1:]\n            return torch.sum(value[2]) + 4\n        inp: Tuple[torch.Tensor, torch.Tensor, torch.Tensor] = (torch.rand(4), torch.rand(4), torch.rand(4))\n        self.checkScript(foo, (inp,))\n\n    def test_add_tuple_different_types(self):\n        def foo(a: Tuple[int, float], b: Tuple[int]) -> int:\n            c: Tuple[int, float, int] = a + b\n            d: Tuple[int, float, int, int] = c + b\n            return d[3] + 1\n        a = (1, 2.0)\n        b = (3,)\n        self.checkScript(foo, (a, b))\n\n    def test_add_tuple_same_types(self):\n        def foo(a: Tuple[int, int], b: Tuple[int, int, int]) -> int:\n            c: Tuple[int, int, int, int, int] = a + b\n            d: Tuple[int, int, int, int, int, int, int, int] = c + b\n            return d[6] - 2\n        a = (1, 2)\n        b = (3, 4, 5)\n        self.checkScript(foo, (a, b))\n\n    def test_method_no_self(self):\n        with self.assertRaisesRegex(RuntimeError, 'methods must have a self argument'):\n            class MethodNoSelf(torch.jit.ScriptModule):\n                @torch.jit.script_method  # noqa: B902\n                def forward():  # noqa: B902\n                    return torch.zeros(3, 4)\n\n            MethodNoSelf()\n\n    def test_return_stmt_not_at_end(self):\n        def return_stmt(x):\n            if bool(x > 3):\n                return x + 3\n            else:\n                return x\n        self.checkScript(return_stmt, (torch.rand(1),))\n\n    def test_for_in_range(self):\n        def fn():\n            c = 0\n            for i in range(100):\n                c += i\n            return c\n        self.checkScript(fn, ())\n\n    def test_for_in_range_dynamic(self):\n        def fn():\n            c = 0\n            for i in range(100):\n                acc = 0\n                for j in range(i):\n                    acc += j\n                c += acc\n            return c\n        self.checkScript(fn, (), optimize=False)\n\n    def test_for_in_range_ast(self):\n        def test_script_for_in_range_ast():\n            c = 0\n            for i in range(100):\n                acc = 0\n                for j in range(i):\n                    acc += j\n                c += acc\n            return c\n\n        self.checkScript(test_script_for_in_range_ast, ())\n\n    def test_for_in_range_if_ast(self):\n        @torch.jit.script\n        def test_script_for_in_range_if_ast(x):\n            output = x\n            for i in range(20):\n                if i == 0:\n                    output = x.unsqueeze(0)\n                else:\n                    output = torch.cat((output, x.unsqueeze(0)), dim=0)\n            return output\n        inputs = self._make_scalar_vars([0], torch.int64)\n\n        self.assertEqual(test_script_for_in_range_if_ast(*inputs).shape[0], 20)\n\n    def test_for_in_range_start_end(self):\n        def fn():\n            x = 0\n            for i in range(7, 100):\n                x += i\n            return x\n        self.checkScript(fn, ())\n\n    def test_for_in_range_start_end_step(self):\n        def fn(start, end, step):\n            # type: (int, int, int) -> int\n            x = 0\n            for i in range(start, end, step):\n                x += i\n            return x\n\n        self.checkScript(fn, (7, 100, 7))\n        self.checkScript(fn, (7, 100, -7))\n        self.checkScript(fn, (2, -11, -3))\n        self.checkScript(fn, (2, -11, 3))\n        self.checkScript(fn, (2, 10, 3))\n        self.checkScript(fn, (-2, -10, -10))\n\n    def test_for_in_range_zero_step(self):\n        @torch.jit.script\n        def fn():\n            x = 0\n            for i in range(2, -11, 0):\n                x += i\n            return x\n\n        with self.assertRaisesRegex(RuntimeError, \"must not be zero\"):\n            fn()\n\n    def test_range_args(self):\n        with self.assertRaisesRegex(RuntimeError, r'range expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def range_no_arg(x):\n                for _ in range():\n                    x += 1\n                return x\n        with self.assertRaisesRegex(RuntimeError, r'found float'):\n            @torch.jit.script\n            def range_non_float():\n                for i in range(.5):\n                    print(i)\n\n    def test_parse_empty_tuple_annotation(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : Tuple[()]) -> Tuple[()]:\n                return x\n        ''')\n\n        foo_code = cu.find_function('foo').code\n        FileCheck().check(\"Tuple[()]\").check(\"Tuple[()]\").run(foo_code)\n\n    def test_parse_empty_tuple_annotation_element_error(self):\n        with self.assertRaisesRegex(\n                RuntimeError, 'Tuple literal in Tuple type annotation must not have any elements'):\n            cu = torch.jit.CompilationUnit('''\n                def foo(x : Tuple[(int,)]) -> Tuple[(int,)]:\n                    return x\n            ''')\n\n    def test_parse_none_type_annotation(self):\n        cu = torch.jit.CompilationUnit('''\n            def foo(x : NoneType) -> NoneType:\n                return x\n        ''')\n\n        foo_code = cu.find_function('foo').code\n        FileCheck().check(\": NoneType\").check(\"-> NoneType\").run(foo_code)\n\n    def test_empty_tuple_str(self):\n        empty_tuple_type = torch._C.TupleType([])\n        g = {'Tuple' : typing.Tuple}\n        python_type = eval(empty_tuple_type.annotation_str, g)\n        assert python_type is typing.Tuple[()]\n\n    def test_none_type_str(self):\n        none_type = torch._C.NoneType.get()\n        g = {'NoneType' : type(None)}\n        python_type = eval(none_type.annotation_str, g)\n        assert python_type is type(None)\n\n    @skipIfTorchDynamo(\"TorchDynamo fails with unknown reason\")\n    def test_zip_enumerate_modulelist(self):\n        class Sub(torch.nn.Module):\n            def __init__(self):\n                super(Sub, self).__init__()\n\n            def forward(self, thing):\n                return thing - 2\n\n        class Double(torch.nn.Module):\n            def __init__(self):\n                super(Double, self).__init__()\n\n            def forward(self, thing):\n                return thing * 2\n\n        # zipping over two\n        class ZipModLists(torch.nn.Module):\n            def __init__(self, mods, mods2):\n                super(ZipModLists, self).__init__()\n                self.mods = mods\n                self.mods2 = mods2\n\n            def forward(self, x):\n                iter = 0\n                for mod1, mod2 in zip(self.mods, self.mods2):\n                    x = mod2(mod1(x))\n                    iter += 1\n                return x, iter\n\n        class ZipWithValues(torch.nn.Module):\n            __constants__ = ['tup_larger', 'tup_smaller']\n\n            def __init__(self, mods, mods2):\n                super(ZipWithValues, self).__init__()\n                self.mods = mods\n                self.mods2 = mods2\n                self.tup_larger = list(range(len(mods2) + 1))\n                self.tup_smaller = list(range(max(len(mods2) + 1, 1)))\n\n            def forward(self, x):\n                iter = 0\n                x2 = x\n                for val, mod1, mod2 in zip(self.tup_larger, self.mods, self.mods2):\n                    x = mod2(mod1(x)) + val\n                    iter += 1\n                for val, mod1, mod2 in zip(self.tup_smaller, self.mods, self.mods2):\n                    x2 = mod2(mod1(x2)) + val\n                    iter += 1\n                return x, iter\n\n        mods = nn.ModuleList([Double()]), nn.ModuleList([Double(), Sub(), Sub()]), nn.ModuleList([Sub(), Double()])\n        for i in range(len(mods)):\n            for j in range(len(mods)):\n                mod = ZipModLists(mods[i], mods[j])\n                self.checkModule(mod, (torch.tensor(.5),))\n                mod2 = ZipWithValues(mods[i], mods[j])\n                self.checkModule(mod2, (torch.tensor(.5),))\n\n\n    def test_enumerate_modlist_range(self):\n        class Double(torch.nn.Module):\n            def forward(self, thing):\n                return thing * 2\n\n        class Mod(torch.nn.Module):\n            def __init__(self):\n                super(Mod, self).__init__()\n                self.mods = nn.ModuleList([Double(), Double()])\n\n            def forward(self, x):\n                x2 = x\n                iter = 0\n                for val, mod in enumerate(self.mods):\n                    x2 = mod(x2) * val\n                    iter += 1\n                return iter, x, x2\n\n        self.checkModule(Mod(), (torch.tensor(.5),))\n\n        # variable length, modulelist\n        class Mod2(Mod):\n            def forward(self, x):\n                for val, mod in zip(range(int(x)), self.mods):\n                    x = mod(x) * val\n                return x\n\n        with self.assertRaisesRegex(Exception, \"that does not have a statically determinable length\"):\n            torch.jit.script(Mod2())\n\n        # modulelist, variable length\n        class Mod3(Mod):\n            def forward(self, x):\n                for val, mod in zip(self.mods, range(int(x))):\n                    x = mod(x) * val\n                return x\n\n        with self.assertRaisesRegex(Exception, \"that does not have a statically determinable length\"):\n            torch.jit.script(Mod3())\n\n    def test_for_in_enumerate(self):\n        def fn(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn, ([1, 2, 3, 4, 5],))\n\n        def fn_enumerate_start_arg(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x, 1):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_start_arg, ([1, 2, 3, 4, 5],))\n\n        def fn_enumerate_start_kwarg(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, v) in enumerate(x, start=1):\n                sum += i * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_start_kwarg, ([1, 2, 3, 4, 5],))\n\n        def fn_nested_enumerate(x):\n            # type: (List[int]) -> int\n            sum = 0\n            for (i, (j, v)) in enumerate(enumerate(x)):\n                sum += i * j * v\n\n            return sum\n\n        self.checkScript(fn_nested_enumerate, ([1, 2, 3, 4, 5],))\n\n        with self.assertRaisesRegex(RuntimeError, r'enumerate expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def enumerate_no_arg(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in enumerate():\n                    sum += 1\n\n                return sum\n\n        with self.assertRaisesRegex(RuntimeError, r'enumerate expected at most 2 arguments, got 3'):\n            @torch.jit.script\n            def enumerate_too_many_args(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in enumerate(x, x, x):\n                    sum += 1\n\n                return sum\n\n    def test_list_comprehension_modulelist(self):\n        class Inner(torch.nn.Module):\n            def forward(self, x):\n                return x + 10\n\n        class M(torch.nn.Module):\n            def __init__(self, mod_list):\n                super(M, self).__init__()\n                self.module_list = mod_list\n\n            def forward(self, x):\n                out = torch.jit.annotate(List[Tensor], [mod(x) for mod in self.module_list])\n                return out\n\n        mod = M(nn.ModuleList([Inner(), Inner()]))\n        self.checkModule(mod, (torch.tensor(3),))\n\n        mod = M(nn.ModuleList([]))\n        torch.jit.script(mod)\n\n        class M2(M):\n            def __init__(self, mod_list):\n                super(M2, self).__init__(mod_list)\n\n            def forward(self, x):\n                out = [mod(x) for mod in self.module_list]\n                return out\n\n        mod = M2(nn.ModuleList([Inner(), Inner()]))\n        self.checkModule(mod, (torch.tensor(3),))\n\n        mod = M2(nn.ModuleList([]))\n        # defaults to List of Tensor for empty modulelist\n        self.assertEqual(torch.jit.script(mod)(torch.tensor(.5)), [])\n\n        def bad_type_annotation():\n            out = torch.jit.annotate(int, [x for x in [1, 2, 3]])  # noqa: C416\n            return out\n\n        with self.assertRaisesRegex(Exception, \"Expected an annotation\"\n                                    \" of type List\"):\n            torch.jit.script(bad_type_annotation)\n\n    def test_list_comprehension_variable_write(self):\n        # i in comprehension doesn't write to function scope\n        def foo():\n            i = 1\n            x = [i if i != 5 else 3 for i in range(7)]  # noqa: C416\n            return i, x\n\n        self.assertEqual(foo(), torch.jit.script(foo)())\n\n    def test_for_in_zip(self):\n        def fn(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, j) in zip(x, y):\n                sum += i * j\n\n            return sum\n\n        self.checkScript(fn, ([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]))\n\n        def fn_multi_inputs(x, y, z):\n            # type: (List[int], List[int], List[int]) -> int\n            sum = 0\n            for (i, j, k) in zip(x, y, z):\n                sum += i * j * k\n\n            return sum\n\n        self.checkScript(fn_multi_inputs, ([1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]))\n\n        def fn_nested_zip(x, y, z):\n            # type: (List[int], List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, k)) in zip(x, zip(y, z)):\n                sum += i * j * k\n\n            return sum\n\n        self.checkScript(fn_multi_inputs, ([1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]))\n\n        with self.assertRaisesRegex(RuntimeError, r'zip expected at least 1 arguments, got 0'):\n            @torch.jit.script\n            def zip_no_arg(x):\n                # type: (List[int]) -> int\n                sum = 0\n                for _ in zip():\n                    sum += 1\n\n                return sum\n\n        with self.assertRaisesRegex(RuntimeError, r'too many values to unpack: need 2 but found 3'):\n            @torch.jit.script\n            def fn_nested_zip_wrong_target_assign(x, y, z):\n                # type: (List[int], List[int], List[int]) -> int\n                sum = 0\n                for (i, (j, k)) in zip(x, y, z):\n                    sum += i * j * k\n\n                return sum\n\n    def test_for_in_zip_enumerate(self):\n        def fn_zip_enumerate(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, v), k) in zip(x, enumerate(y), range(0, 100)):\n                sum += i * j * v * k\n\n            return sum\n\n        self.checkScript(fn_zip_enumerate, ([1, 2, 3, 4], [2, 3, 4, 5]))\n\n        def fn_enumerate_zip(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for (i, (j, v)) in enumerate(zip(x, y)):\n                sum += i * j * v\n\n            return sum\n\n        self.checkScript(fn_enumerate_zip, ([1, 2, 3, 4], [2, 3, 4, 5]))\n\n    def test_for_in_tensors(self):\n        def test_sizes(x):\n            sumz = 0\n            for s in x:\n                sumz += 1\n            return sumz\n        self.checkScript(test_sizes, (torch.rand(5, 4, 3, 2, 1),))\n        self.checkScript(test_sizes, (torch.rand(777),))\n        self.checkScript(test_sizes, (torch.rand(0),))\n\n    def test_for_in_tensors_rank0(self):\n        with self.assertRaisesRegex(RuntimeError, \"of a 0-d tensor\"):\n            @torch.jit.script\n            def test_sizes(x):\n                sumz = 0\n                for s in x:\n                    sumz += 1\n                return sumz\n\n            test_sizes(torch.tensor(1))\n\n    def test_for_in_tensors_fail_scalar(self):\n        with self.assertRaisesRegex(RuntimeError, \"'float' object is not iterable\"):\n            @torch.jit.script\n            def test_sizes(x):\n                # type: (float) -> int\n                sumz = 0\n                for s in x:\n                    sumz += 1\n                return sumz\n\n            test_sizes(0.0)\n\n    def test_for_in_tensors_nested(self):\n        def test_sizes(x):\n            sumz = 0\n            for n in x:\n                for t in n:\n                    sumz += 1\n            return sumz\n\n        self.checkScript(test_sizes, (torch.rand(5, 4, 3, 2, 1),))\n\n    # to avoid defining sum_list in multiple tests\n    def get_sum_list_fn(self):\n        def sum_list(a):\n            # type: (List[int]) -> int\n            sum = 0\n            for i in a:\n                sum += i\n\n            return sum\n\n        return sum_list\n\n    def test_sum_list_diff_elms(self):\n        self.checkScript(self.get_sum_list_fn(), ([1, 2, 3, 4, 5],))\n\n    def test_sum_list_empty(self):\n        self.checkScript(self.get_sum_list_fn(), ([],))\n\n    def test_sum_list_one(self):\n        self.checkScript(self.get_sum_list_fn(), ([1],))\n\n    def test_sum_list_literal(self):\n\n        def sum_list():\n            # type: () -> int\n            sum = 0\n            for i in [1, 2, 3, 4, 5]:\n                sum += i\n\n            return sum\n\n        self.checkScript(sum_list, ())\n\n    def test_sum_list_wrong_type(self):\n\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not iterable\"):\n            @torch.jit.script\n            def sum_list(a):\n                # type: (int) -> int\n                sum = 0\n                for i in a:  # noqa: T484\n                    sum += i\n\n                return sum\n\n            sum_list(1)\n\n    def test_list_iterables(self):\n        with self.assertRaisesRegex(RuntimeError, 'List of iterables is not supported currently'):\n            cu = torch.jit.CompilationUnit('''\n            def list_iterables(x):\n                for i, j in [2, 3, 4], [5, 6, 7]:\n                    x += i\n                    x += j\n                return x\n            ''')\n\n    def test_for_in_string(self):\n        def test_strings(x):\n            # type: (str) -> str\n            reverse = \"\"\n            for c in x:\n                reverse = c + reverse\n            return reverse\n\n        self.checkScript(test_strings, (\"hello\",))\n        self.checkScript(test_strings, (\"\",))\n\n        def test_list_strings(x):\n            # type: (List[str]) -> str\n            result = \"\"\n            for sub_str in x:\n                result += sub_str\n            return result\n\n        self.checkScript(test_list_strings, ([\"hello\", \"world\"],))\n        self.checkScript(test_list_strings, ([\"hello\", \" \", \"world\", \"\"],))\n\n    def test_for_in_dict(self):\n        def test_dicts(x):\n            # type: (Dict[str, int]) -> int\n            sum = 0\n            for key in x:\n                sum += x[key]\n            return sum\n\n        self.checkScript(test_dicts, ({\"a\": 1, \"b\": 2, \"c\": 3},))\n\n        def test_dict_keys_values(x):\n            # type: (Dict[str, int]) -> Tuple[str, int]\n            key_str = \"\"\n            sum = 0\n            for key in x.keys():\n                key_str += key\n            for val in x.values():\n                sum += val\n            return key_str, sum\n\n        self.checkScript(test_dicts, ({\"a\": 1, \"b\": 2, \"c\": 3},))\n\n    def test_for_tuple_unpack(self):\n        def for_tuple_unpack(x, y):\n            for i, j in [[3, 4], [5, 6], [7, 8]]:\n                x += i\n                y += j\n            return x, y\n\n        self.checkScript(for_tuple_unpack, (torch.tensor(3), torch.tensor(5)))\n\n        def nested_tuple_unpack(x, y):\n            # type: (List[int], List[int]) -> int\n            sum = 0\n            for i, (j, k), v in zip(x, enumerate(x), y):\n                sum += i + j + k + v\n            return sum\n\n        self.checkScript(nested_tuple_unpack, ([1, 3, 5], [2, 4, 6]))\n\n    def test_for_tuple_assign(self):\n        def test_simple_assign(x):\n            # type: (Tuple[int, float]) -> float\n            sum = 0.0\n            for a in x:\n                sum += float(a)\n            return sum\n\n        self.checkScript(test_simple_assign, ((1, 2.5),))\n\n        def test_tuple_assign(x):\n            # type: (Tuple[Tuple[int, int], Tuple[int, int]]) -> int\n            sum = 0\n            for a in x:\n                sum += a[0]\n                sum += a[1]\n            return sum\n\n        self.checkScript(test_tuple_assign, (((1, 2), (4, 7)), ))\n\n    def test_single_starred_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'A Starred expression may only appear on the lhs within the presence'\n                                                  ' of another non-starred expression'):\n            cu = torch.jit.CompilationUnit('''\n            def single_starred_lhs(x):\n                a = (x, x, x)\n                *b, = a\n                return b\n            ''')\n\n    def test_singleton_tuple_unpack(self):\n        def foo(a):\n            b, = (a,)\n            return b + 1\n        self.checkScript(foo, (torch.rand(3),))\n\n    def test_tuple_assignments(self):\n        def var_tuple_assign(x, y):\n            # type: (Tuple[Tensor, Tensor], Tensor) -> Tensor\n            (a, b), c = x, y\n            return a + b + c\n\n        tuple_inputs = (torch.randn(1, 4), torch.randn(3, 4))\n        self.checkScript(var_tuple_assign, (tuple_inputs, torch.randn(3, 4)))\n\n        def nested_tuple_assign(x, y, z):\n            # type: (int, Tuple[int, Tuple[int, int]], Tuple[int, int]) -> int\n            a, (b, (c, d)), (e, f) = x, y, z\n            return a + b + c + d + e + f\n\n        self.checkScript(nested_tuple_assign, ((1, (2, (3, 4)), (5, 6))))\n\n        def subscript_tuple_assign(a, x, i):\n            # type: (List[int], Tensor, int) -> Tuple[int, Tensor, int]\n            a[i], (x[i], b) = 1, (2, 3)\n            return a[i] + 1, x + 5, b\n\n        self.checkScript(subscript_tuple_assign, ([12, 7, 9, 11], torch.tensor((3, 13, 17)), 0))\n\n        def star_tuple_assign():\n            # type: () -> Tuple[int, int, Tuple[int, int], Tuple[int, int]]\n            a, (b, *c), *d = 1, (2, 3, 4), 5, 6\n            return a, b, c, d\n\n        self.checkScript(star_tuple_assign, ())\n\n        def subscript_tuple_augmented_assign(a):\n            # type: (Tuple[int, int]) -> Tuple[int, int]\n            a[0] += 1\n            return a\n\n        with self.assertRaisesRegex(RuntimeError, 'does not support augmented assign'):\n            scripted_aug_assign = torch.jit.script(subscript_tuple_augmented_assign)\n\n        class AttrTupleAssignmentTestClass:\n            def __init__(self, a: int, b: int):\n                self.a = a\n                self.b = b\n\n            def set_ab(self, a: int, b: int):\n                self.a, self.b = (a, b)\n\n            def get(self) -> Tuple[int, int]:\n                return (self.a, self.b)\n\n        make_global(AttrTupleAssignmentTestClass)\n\n        @torch.jit.script\n        def attr_tuple_assignment(o: AttrTupleAssignmentTestClass, a: int, b: int):\n            o.set_ab(a, b)\n            return o\n\n        o = AttrTupleAssignmentTestClass(1, 2)\n        self.assertEqual(attr_tuple_assignment(o, 3, 4).get(), (3, 4))\n\n    def test_multiple_assign(self):\n        def test():\n            a = b, c = d, f = (1, 1)\n\n            # side effect\n            ten = torch.tensor(1)\n            ten1 = ten2 = ten.add_(1)\n\n            # ordering\n            x = 1\n            y = 3\n            x, y = y, x + y\n\n            return a, b, c, d, f, ten, ten1, ten2, x, y\n\n        self.checkScript(test, ())\n\n    def test_multi_reduction(self):\n        with self.assertRaisesRegex(\n                RuntimeError,\n                'augmented assignment can only have one LHS expression'):\n            cu = torch.jit.CompilationUnit('''\n            def multi_reduction(x):\n                a, b += x\n                return a, b\n            ''')\n\n    def test_invalid_call_arguments(self):\n        with self.assertRaisesRegex(RuntimeError, 'but instead found type '):\n            @torch.jit.script\n            def invalid_call_arguments(x):\n                return torch.unsqueeze(3, 4, 5, 6, 7, 8)\n\n    def test_invalid_lhs_assignment(self):\n        with self.assertRaisesRegex(RuntimeError, 'unexpected expression'):\n            cu = torch.jit.CompilationUnit('''\n            def invalid_lhs_assignment(x):\n                x + 1 = x\n                return x\n            ''')\n\n    def test_multi_starred_expr_lhs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Only one starred expression is allowed on the lhs'):\n            cu = torch.jit.CompilationUnit('''\n            def multi_starred_expr_lhs():\n                a, *b, *c = [1, 2, 3, 4, 5, 6]\n                return a\n            ''')\n\n    def test_pack_tuple_into_non_var(self):\n        with self.assertRaisesRegex(RuntimeError, 'Cannot pack a tuple into a non-variable'):\n            cu = torch.jit.CompilationUnit('''\n            def pack_tuple_into_non_var(x):\n                a, *1 = (3, 4, 5)\n                return x\n            ''')\n\n    def test_print_kwargs(self):\n        with self.assertRaisesRegex(RuntimeError, 'print doesn\\'t accept any keyword arguments'):\n            cu = torch.jit.CompilationUnit('''\n            def print_kwargs(x):\n                print(x, flush=True)\n                return x\n            ''')\n\n    def test_builtin_use_as_value(self):\n        with self.assertRaisesRegex(RuntimeError, 'builtin cannot be used as a value'):\n            @torch.jit.script\n            def builtin_use_as_value(x):\n                return x.unsqueeze\n\n    def test_wrong_use_as_tuple(self):\n        with self.assertRaisesRegex(RuntimeError, 'cannot be used as a tuple'):\n            def test_fn():\n                return 3\n\n            @torch.jit.script\n            def wrong_use_as_tuple(self):\n                a, b = test_fn\n                return a\n\n    def test_wrong_attr_lookup(self):\n        with self.assertRaisesRegex(RuntimeError, 'attribute lookup is not defined on builtin'):\n            @torch.jit.script\n            def wrong_attr_lookup(self, x):\n                a = x.unsqueeze.myattr\n                return a\n\n    def test_wrong_use_as_callable(self):\n        with self.assertRaisesRegex(RuntimeError, 'cannot call a value'):\n            @torch.jit.script\n            def wrong_use_as_callable(x):\n                return x(3, 4, 5)\n\n    def test_python_val_doesnt_have_attr(self):\n        with self.assertRaisesRegex(RuntimeError, 'object has no attribute abcd'):\n\n            @torch.jit.script\n            def python_val_doesnt_have_attr():\n                # this has to be a module otherwise attr lookup would not be\n                # allowed in the first place\n                return shutil.abcd\n\n    def test_wrong_module_attr_lookup(self):\n        with self.assertRaisesRegex(RuntimeError, 'python value of type \\'type\\' cannot be used as a value'):\n            import io\n\n            @torch.jit.script\n            def wrong_module_attr_lookup():\n                return io.BytesIO\n\n    def test_wrong_method_call_inputs(self):\n        with self.assertRaisesRegex(RuntimeError, 'Argument y not provided'):\n            class SomeModule(torch.jit.ScriptModule):\n\n                @torch.jit.script_method\n                def foo(self, x, y):\n                    return x\n\n                @torch.jit.script_method\n                def forward(self, x, y):\n                    return self.foo(x)\n            SomeModule()\n\n    def test_single_starred_expr_for_loop(self):\n        with self.assertRaisesRegex(RuntimeError, 'A Starred expression may only appear'):\n            cu = torch.jit.CompilationUnit('''\n            def test():\n                x = 0\n                for *a in [1, 2, 3]:\n                    x = x + 1\n                return x\n            ''')\n\n    def test_call_ge(self):\n        with self.assertRaisesRegex(RuntimeError, 'Expected at most 1 arguments but found 3'):\n            @_trace(torch.zeros(1, 2, 3))\n            def foo(x):\n                return x\n\n            @torch.jit.script\n            def test_fn():\n                return foo(torch.full([1], 1), torch.full([1], 2), torch.full([1], 3))\n\n    def test_wrong_return_type(self):\n        with self.assertRaisesRegex(RuntimeError, 'but instead got value of type tuple'):\n            @torch.jit.ignore\n            def somefunc():\n                # type: () -> Tuple[Tuple[Tensor, Tensor]]\n                return torch.zeros(3, 4), torch.zeros(4, 5)  # noqa: T484\n\n            @torch.jit.script\n            def wrong_return_type():\n                return somefunc()\n            wrong_return_type()\n\n    # Tests for calling between different front-end modes\n    def test_call_python_fn_from_tracing_fn(self):\n        def python_fn(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return python_fn(x) + 1\n\n        # The neg op in the python function should be properly inlined to the\n        # graph\n        FileCheck().check(\"aten::neg\").run(str(traced_fn.graph))\n\n    def test_call_python_mod_from_tracing_fn(self):\n        class PythonMod(torch.nn.Module):\n            def __init__(self):\n                super(PythonMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3), requires_grad=False)\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        pm = PythonMod()\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return pm(x) + 1.0\n\n        # Note: the parameter self.param from the Python module is inlined\n        # into the graph\n        self.assertTrue(len(list(traced_fn.graph.inputs())) == 1)\n        FileCheck().check(\"aten::mm\").check(\"aten::add\").run(str(traced_fn.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_traced_fn_from_tracing_fn(self):\n        @_trace(torch.rand(3, 4))\n        def traced_fn1(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return traced_fn1(x) + 1\n\n        FileCheck().check(\"traced_fn\").check(\"prim::CallFunction\").check(\"aten::add\") \\\n            .run(str(traced_fn.graph))\n\n    @unittest.skip(\"error in first class mode\")\n    def test_call_traced_mod_from_tracing_fn(self):\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3), requires_grad=False)\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        with self.assertRaisesRegex(RuntimeError, \"must be registered as submodules\"):\n            @_trace(torch.rand(3, 4))\n            def traced_fn(x):\n                return tm(x) + 1.0\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_tracing_fn(self):\n        @torch.jit.script\n        def script_fn(x):\n            return torch.neg(x)\n\n        @_trace(torch.rand(3, 4))\n        def traced_fn(x):\n            return script_fn(x) + 1\n\n        FileCheck().check(\"prim::CallFunction\").check(\"aten::add\").run(str(traced_fn.graph))\n\n    @unittest.skip(\"error in first class mode\")\n    def test_call_script_mod_from_tracing_fn(self):\n        with self.assertRaisesRegex(RuntimeError, \"must be registered as submodules\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n                    self.param = torch.nn.Parameter(torch.rand(3, 4), requires_grad=False)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    for _i in range(4):\n                        x += self.param\n                    return x\n\n            sm = ScriptMod()\n\n            @_trace(torch.rand(3, 4))\n            def traced_fn(x):\n                return sm(x) + 1.0\n\n\n    def test_call_python_fn_from_traced_module(self):\n        def python_fn(x):\n            return torch.neg(x)\n\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            def forward(self, x):\n                return torch.mm(python_fn(x), self.param)\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        # Note: parameter self.param from the traced module should appear as\n        # an input to the graph and the neg op from the Python function should\n        # be properly inlined\n        self.assertTrue(len(list(tm.graph.inputs())) == 2)\n        FileCheck().check(\"aten::neg\").check(\"aten::mm\").run(str(tm.graph))\n\n    def test_call_python_mod_from_traced_module(self):\n        class PythonModule(torch.nn.Module):\n            def __init__(self):\n                super(PythonModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(5, 7))\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class TracedModule(torch.nn.Module):\n            def __init__(self):\n                super(TracedModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 5))\n                self.mod = PythonModule()\n\n            def forward(self, x):\n                return self.mod(torch.mm(x, self.param)) + 1.0\n\n        tm = torch.jit.trace(TracedModule(), torch.rand(3, 4))\n\n        FileCheck().check_not(\"value=<Tensor>\").check(\"aten::mm\")\\\n            .check(\"prim::CallMethod[name=\\\"forward\\\"]\").check(\"aten::add\") \\\n            .run(str(tm.graph))\n        FileCheck().check(\"aten::mm\").run(str(tm.mod.graph))\n\n    def test_op_dtype(self):\n\n        def check_equal_and_dtype(a, b):\n            self.assertEqual(a, b)\n            self.assertEqual(a.dtype, b.dtype)\n\n        def fn():\n            a = torch.arange(10)\n            b = torch.arange(10, dtype=torch.float)\n            c = torch.arange(1, 10, 2)\n            d = torch.arange(1, 10, 2, dtype=torch.float)\n            e = torch.arange(1, 10., 2)\n            f = torch.arange(1, 10., 2, dtype=torch.float)\n            return a, b, c, d, e, f\n\n        scripted_fn = torch.jit.script(fn)\n        eager_out = fn()\n        script_out = scripted_fn()\n        for a, b in zip(eager_out, script_out):\n            check_equal_and_dtype(a, b)\n\n    def test_floor_div(self):\n        @torch.jit.script\n        def foo(a, b):\n            # type: (int, int) -> int\n            return a // b\n        for i in range(-8, 8):\n            for j in range(-8, 8):\n                if j != 0:\n                    self.assertEqual(foo(i, j), i // j)\n\n    def test_floordiv(self):\n        funcs_template = dedent('''\n        def fn():\n            ten = {a_construct}\n            ten_or_scalar = {b_construct}\n            return ten // ten_or_scalar, torch.floor_divide(ten, ten_or_scalar)\n        ''')\n\n        lhs = [\"torch.tensor([5.5, 3.2])\", \"torch.tensor([2, 2])\", \"torch.tensor([3, 2])\"]\n        rhs = [\"1.5\", \"2\", \"4\", \"1.1\"] + lhs\n        for tensor in lhs:\n            for tensor_or_scalar in rhs:\n                funcs_str = funcs_template.format(a_construct=tensor, b_construct=tensor_or_scalar)\n                scope = {}\n                execWrapper(funcs_str, globals(), scope)\n                cu = torch.jit.CompilationUnit(funcs_str)\n                f_script = cu.fn\n                f = scope['fn']\n                self.assertEqual(f_script(), f())\n\n    def test_call_python_fn_from_script_fn(self):\n        @torch.jit.ignore\n        def python_fn(x):\n            return torch.neg(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            return python_fn(x) + 1\n\n        # Note: the call to python_fn appears as `^python_fn()` and is called\n        # as a PythonOp in the interpreter\n        a = torch.tensor(1)\n        self.assertEqual(script_fn(a), torch.tensor(0))\n        FileCheck().check(\"python_fn\").run(str(script_fn.graph))\n\n    def test_call_python_mod_from_script_fn(self):\n        class PythonModule(torch.nn.Module):\n            def __init__(self):\n                super(PythonModule, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(5, 7))\n\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        pm = PythonModule()\n\n        @torch.jit.script\n        def script_fn(x):\n            return pm(x) + 1\n\n        # Note: call to pm(x) appears as ^<python_value>() in the trace.\n        # Parameters are NOT inlined.\n        FileCheck().check(\"python_value\").check(\"aten::add\").run(str(script_fn.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_script_fn(self):\n        @torch.jit.script\n        def script_fn1(x):\n            return torch.neg(x)\n\n        @torch.jit.script\n        def script_fn(x):\n            return script_fn1(x) + 1\n\n        FileCheck().check(\"prim::CallFunction\").run(str(script_fn.graph))\n\n    def test_call_script_mod_from_script_fn(self):\n        with self.assertRaisesRegex(RuntimeError, \"Cannot call a ScriptModule that is not a submodule of the caller\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    return torch.mm(x, torch.zeros([4, 3]))\n\n            sm = ScriptMod()\n\n            @torch.jit.script\n            def script_fn(x):\n                return sm(x) + 1\n\n    def test_call_python_fn_from_script_module(self):\n        @torch.jit.ignore\n        def python_fn(x):\n            return torch.neg(x)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return python_fn(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        FileCheck().check(\"aten::mm\").check(\"python_fn\") \\\n            .run(str(sm.forward.graph))\n\n    def test_call_python_mod_from_script_module(self):\n        class PythonMod(torch.nn.Module):\n            def __init__(self):\n                super(PythonMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(3, 5))\n\n            @torch.jit.ignore\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n                self.pm = PythonMod()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.pm(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        # Note: the call into PythonMod appears as ^forward(). Parameters\n        # are NOT inlined\n        FileCheck().check(\"aten::mm\").check(\"forward\").run(str(sm.graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_fn_from_script_module(self):\n        @torch.jit.script\n        def script_fn(x):\n            return torch.neg(x)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return script_fn(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        graph = (sm.forward.graph)\n        FileCheck().check(\"aten::mm\").check(\"prim::CallFunction\").run(str(graph))\n\n    @_tmp_donotuse_dont_inline_everything\n    def test_call_script_mod_from_script_module(self):\n        class ScriptMod1(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod1, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(3, 5))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return torch.mm(x, self.param)\n\n        class ScriptMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(ScriptMod, self).__init__()\n                self.param = torch.nn.Parameter(torch.rand(4, 3))\n                self.tm = ScriptMod1()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.tm(torch.mm(x, self.param))\n\n        sm = ScriptMod()\n        # Note: the parameters from both modules should appear in the flattened\n        # input list to the graph. The mm op from ScriptMod1 should be properly\n        # inlined\n        # 3 % values in graph input lists, two mms in body\n        FileCheck().check_count('%', 3).check(\":\").check_count(\"mm\", 1).check(\"prim::CallMethod\").run(str(sm.graph))\n\n    def test_module_with_params_called_fails(self):\n        with self.assertRaisesRegex(RuntimeError, \"Cannot call a ScriptModule that is not a submodule of the caller\"):\n            class ScriptMod(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(ScriptMod, self).__init__()\n                    self.param = torch.nn.Parameter(torch.rand(3, 3))\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    return torch.mm(x, self.param)\n\n            sm = ScriptMod()\n\n            @torch.jit.script\n            def some_func(x):\n                return sm(x)\n\n    def test_tuple_index_to_list(self):\n        def test_non_constant_input(a):\n            # type: (bool) -> int\n            if a:\n                b = 1\n            else:\n                b = 0\n            c = (0, 1)\n            return c[b]\n\n        self.checkScript(test_non_constant_input, (True,))\n        self.checkScript(test_non_constant_input, (False,))\n\n        with self.assertRaisesRegex(RuntimeError, \"because we cannot resolve the output type\"):\n            @torch.jit.script\n            def test_non_constant_input(a):\n                # type: (bool) -> None\n                if a:\n                    b = 1\n                else:\n                    b = 0\n                c = (0, 1.1)\n                print(c[b])\n\n    def test_tuple_indexing(self):\n        def tuple_index(a):\n            if bool(a):\n                b = (1, 2)\n            else:\n                b = (0, 2)\n            return b[-2], b[1]\n\n        self.checkScript(tuple_index, (torch.tensor([0]),))\n        self.checkScript(tuple_index, (torch.tensor([1]),))\n        self.checkScript(tuple_index, (torch.tensor([1]),), optimize=True)\n        tuple_comp = torch.jit.script(tuple_index)\n        FileCheck().check_count(\"TupleIndex\", 2, exactly=True).run(str(tuple_comp.graph))\n\n        with self.assertRaisesRegex(RuntimeError, \"index must be an integer\"):\n            @torch.jit.script\n            def test_indexing_float():\n                c = (1, 2)\n                return c[0.1]\n\n        def test_indexing_out_of_bounds_pos():\n            c = (1, 2)\n            return c[2]\n\n        self.checkScriptRaisesRegex(test_indexing_out_of_bounds_pos, (), Exception,\n                                    \"out of range\")\n\n        def test_indexing_out_of_bounds_neg():\n            c = (1, 2)\n            return c[-3]\n\n        self.checkScriptRaisesRegex(test_indexing_out_of_bounds_pos, (), Exception,\n                                    \"out of range\")\n\n        def negative_index():\n            tup = (1, 2, 3, 4)\n            return tup[-1]\n\n        self.checkScript(negative_index, [])\n\n        def really_negative_index():\n            tup = (1, 2, 3, 4)\n            return tup[-100]\n\n        self.checkScriptRaisesRegex(really_negative_index, [], Exception, \"index out of range\")\n\n        def negative_slice():\n            tup = (1, 2, 3, 4)\n            return tup[-3:4]\n\n        self.checkScript(negative_slice, [])\n\n        def really_slice_out_of_bounds():\n            tup = (1, 2, 3, 4)\n            return tup[-300:4000]\n\n        self.checkScript(really_slice_out_of_bounds, [])\n\n    def test_namedtuple_attr(self):\n        def f(x):\n            return x.max(dim=1).indices + torch.max(x, dim=1).indices\n\n        self.checkScript(f, (torch.rand(20, 20, 20),), optimize=True)\n\n        with self.assertRaisesRegex(RuntimeError, \"object has no attribute or method\"):\n            @torch.jit.script\n            def g1(x):\n                return x.max(dim=1).unknown_symbol\n\n        with self.assertRaisesRegex(RuntimeError, \"object has no attribute or method\"):\n            @torch.jit.script\n            def g2(x):\n                print((x, x, x).__doc__)\n                return x\n\n    def test_tuple_len(self):\n        @torch.jit.script\n        def foo():\n            return len((1, \"str\", None))\n\n        self.assertEqual(foo(), 3)\n\n        @torch.jit.script\n        def test_indexing_end_out_of_bounds():\n            c = (1, 2)\n            return c[2:10]\n\n        self.assertEqual(test_indexing_end_out_of_bounds(), ())\n\n    def test_lower_nested_tuples(self):\n        @torch.jit.script\n        def test():\n            return ((1, 2), 3)\n\n        self.run_pass('constant_propagation', test.graph)\n        FileCheck().check(\"prim::Constant\").check_not(\"TupleConstruct\").run(test.graph)\n        # fails if a tuple can't be lowered\n        self.run_pass('lower_all_tuples', test.graph)\n\n    def test_unwrap_optional_builtin(self):\n        def test(x):\n            # type: (Optional[int]) -> int\n            x = torch.jit._unwrap_optional(x)\n            x = x + x  # noqa: T484\n            return x\n\n        self.checkScript(test, (3,))\n\n        with self.assertRaisesRegex(AssertionError, \"Unwrapping null optional\"):\n            test(None)\n\n        test_script = torch.jit.script(test)\n        with self.assertRaisesRegex(RuntimeError, \"Unwrapping null optional\"):\n            test_script(None)\n\n        @torch.jit.script\n        def test_test():\n            return torch.jit._unwrap_optional(1)\n\n        with self.assertRaisesRegex(RuntimeError, r\"could not be inferred from actual type None\"):\n            @torch.jit.script\n            def test_no_type():\n                # type: () -> int\n                return torch.jit._unwrap_optional(None)\n\n    def test_indexing_error(self):\n        with self.assertRaisesRegex(RuntimeError, \"'int' object is not subscriptable\"):\n            @torch.jit.script\n            def test_wrong_type():\n                a = 8\n                return a[0]\n\n    def test_unsupported_builtin_error(self):\n        with self.assertRaisesRegex(RuntimeError,\n                                    \"Python builtin <built-in function hypot> is currently\"):\n            @torch.jit.script\n            def test_unsupported(a):\n                return math.hypot(a, 2.0)\n\n    def test_annotated_script_fn(self):\n        @torch.jit.script\n        def foo(x, y, z):\n            # type: (Tensor, Tuple[Tensor, Tensor, Tensor], Tuple[Tensor, Tuple[Tensor, Tensor]]) -> Tensor\n            return x\n\n        self.assertExpected(str(foo.schema))\n\n    def test_annotated_script_method(self):\n        class SM(torch.jit.ScriptModule):\n            @torch.jit.script_method\n            def forward(self, x, y):\n                # type: (Tuple[Tensor, Tensor], Tensor) -> Tuple[Tensor, Tensor, Tensor]\n                return y, y, y\n\n        sm = SM()\n\n        self.assertExpectedStripMangled(str(sm.forward.schema))\n\n    def test_annotated_script_fn_return_mismatch(self):\n        with self.assertRaisesRegex(RuntimeError, \"but is actually of type\"):\n            @torch.jit.script\n            def return_tup(x):\n                # type: (Tensor) -> Tuple[Tuple[Tensor, Tensor], Tensor]\n                return x, x  # noqa: T484\n\n    def test_annotated_script_fn_arg_mismatch(self):\n        with self.assertRaisesRegex(RuntimeError, r\"Arguments for call are not valid\"):\n            @torch.jit.script\n            def tuple_arg(x):\n                # type: (Tuple[Tensor, Tensor]) -> Tensor\n                return x + 1  # noqa: T484\n\n    def test_script_non_tensor_args_outputs(self):\n        @torch.jit.script\n        def fn(x, y):\n            # type: (Tensor, float) -> float\n            return float((x + y).sum())\n\n        x = torch.ones(2, 2)\n        z = fn(x, 1)\n        self.assertIsInstance(z, float)\n        self.assertEqual(z, 8.)\n\n    @unittest.skip('https://github.com/pytorch/pytorch/issues/9595')\n    def test_inline_and_run_annotated_script_fn(self):\n        @torch.jit.script\n        def to_inline(x, y):\n            # type: (Tuple[Tensor, Tensor], Tensor) -> Tensor\n            return y\n\n        @torch.jit.script\n        def some_func(x):\n            return to_inline((x, x), x)\n\n        x = torch.rand(3, 4)\n        self.assertEqual(some_func(x), x)\n\n    def test_file_format_serialization(self):\n        filename = tempfile.mktemp()\n        writer = torch._C.PyTorchFileWriter(filename)\n        buffers = [os.urandom(size) for size in [random.randint(1, 100) for i in range(20)]]\n        offsets = []\n        for i, buf in enumerate(buffers):\n            writer.write_record(str(i), buf, len(buf))\n            offsets.append(i)\n        serialized_offsets = pickle.dumps(offsets)\n        writer.write_record(\"meta\", serialized_offsets, len(serialized_offsets))\n        writer.write_end_of_file()\n\n        reader = torch._C.PyTorchFileReader(filename)\n        serialized_offsets_read = reader.get_record(\"meta\")\n        parsed_serialized_offsets = pickle.loads(serialized_offsets)\n\n        for i, offset in enumerate(parsed_serialized_offsets):\n            data = reader.get_record(str(offset))\n            assert(data == buffers[i])\n\n    # for each type, the input type annotation and corresponding return type annotation\n    def type_input_return_pairs(self):\n        return [\n            ('Tensor', 'Tensor'),\n            ('torch.Tensor', 'Tensor'),\n            ('str', 'str'),\n            ('int', 'int'),\n            ('bool', 'bool'),\n            ('BroadcastingList3[float]', 'List[float]'),\n            ('BroadcastingList2[int]', 'List[int]'),\n            ('List[int]', 'List[int]'),\n            ('Optional[int]', 'Optional[int]'),\n        ]\n\n    # replacing code input & return type pair\n    def format_code(self, code, pair):\n        return code.format(input=pair[0], output=pair[1])\n\n    # ***** Type annotation tests ****\n    # Test combinations of:\n    # {String frontend, Python AST Frontend}\n    # {Python 3-style type annotations, MyPy-style type comments}\n    # {Script method, Script function}\n\n    #  String frontend , Python 3-style type annotations , Script function\n    def test_annot_string_py3_fn(self):\n        code = '''\n            def foo(x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            cu = torch.jit.CompilationUnit(self.format_code(code, pair))\n            test_str.append(str(cu.foo.schema))\n        self.assertExpected(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , Python 3-style type annotations , Script method\n    def test_annot_string_py3_method(self):\n        class TestModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n        code = '''\n            def foo(self, x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            # clear the class registry as we will be defining foo multiple times\n            jit_utils.clear_class_registry()\n            tm = TestModule()\n            tm.define(self.format_code(code, pair))\n            test_str.append(str(tm.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , MyPy-style type comments , Script function\n    def test_annot_string_mypy_fn(self):\n        code = '''\n            def foo(x, y):\n                # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                return x, x\n        '''\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            cu = torch.jit.CompilationUnit(self.format_code(code, pair))\n            test_str.append(str(cu.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  String frontend , MyPy-style type comments , Script method\n    def test_annot_string_mypy_method(self):\n        class TestModule(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TestModule, self).__init__()\n\n        code = '''\n        def foo(self, x, y):\n            # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n            return x, x\n        '''\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            # clear the class registry as we will be defining foo multiple times\n            jit_utils.clear_class_registry()\n            tm = TestModule()\n            tm.define(self.format_code(code, pair))\n            test_str.append(str(tm.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , Python 3-style type annotations , Script function\n    def test_annot_ast_py3_fn(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, BroadcastingList3\n            import torch\n            @torch.jit.script\n            def foo(x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                return x, x\n        ''')\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            test_str.append(str(fn.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    def test_multiline_annot_ast_py3_fn(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, BroadcastingList3\n            import torch\n            @torch.jit.script\n            def foo(x,  # type: {input}\n                    y   # type: Tuple[Tensor, Tensor]\n                    ):\n                # type: (...) -> Tuple[{output}, {output}]\n                return x, x\n        ''')\n        test_str = []\n\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            args = fn.schema.arguments\n            returns = fn.schema.returns\n            self.assertEqual(str(args[0].type), pair[1])\n            self.assertEqual(str(args[1].type), \"Tuple[Tensor, Tensor]\")\n            self.assertEqual(str(returns[0].type), \"Tuple[{}, {}]\".format(pair[1], pair[1]))\n\n    def test_bad_multiline_annotations(self):\n        with self.assertRaisesRegex(RuntimeError, \"Return type line\"):\n            @torch.jit.script\n            def bad_type_line(a,  # type: Tensor\n                              b,  # type: Tensor\n                              c   # type: Tensor\n                              ):\n                # type: (int, int, int) -> Tensor\n                # type: bad type line  # noqa: F723\n\n                return a + b + c\n\n        with self.assertRaisesRegex(RuntimeError, \"Return type line\"):\n            @torch.jit.script\n            def bad_return_line(a,  # type: Tensor\n                                b,\n                                c   # type: Tensor\n                                ):\n                # type: (int, int, int) -> Tensor\n                return a + b + c\n\n        # TODO: this should be supported but is difficult to parse\n        with self.assertRaisesRegex(RuntimeError, \"Number of type annotations\"):\n            @torch.jit.script\n            def missing_type(a,  # type: Tensor\n                             b,\n                             c   # type: Tensor\n                             ):\n                # type: (...) -> Tensor\n                return a + b + c\n\n    #  Python AST Frontend , Python 3-style type annotations , Script method\n    def test_annot_ast_py3_method(self):\n        code = dedent('''\n            from typing import Tuple, List, Optional\n            from torch import Tensor\n            from torch.jit.annotations import BroadcastingList2, \\\\\n                BroadcastingList3\n            import torch\n            class FooModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def foo(self, x : {input}, y : Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]:\n                    return x, x\n            instance = FooModule()\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'instance')\n            test_str.append(str(fn.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , MyPy-style type comments , Script function\n    def test_annot_ast_mypy_fn(self):\n        code = dedent('''\n            import torch\n            @torch.jit.script\n            def foo(x, y):\n                # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                return x, x\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'foo')\n            test_str.append(str(fn.schema))\n        self.assertExpected(\"\\n\".join(test_str) + \"\\n\")\n\n    #  Python AST Frontend , MyPy-style type comments , Script method\n    def test_annot_ast_mypy_method(self):\n        code = dedent('''\n            import torch\n            class FooModule(torch.jit.ScriptModule):\n                @torch.jit.script_method\n                def foo(self, x, y):\n                    # type: ({input}, Tuple[Tensor, Tensor]) -> Tuple[{output}, {output}]\n                    return x, x\n            instance = FooModule()\n        ''')\n\n        test_str = []\n        for pair in self.type_input_return_pairs():\n            fn = jit_utils._get_py3_code(self.format_code(code, pair), 'instance')\n            test_str.append(str(fn.foo.schema))\n        self.assertExpectedStripMangled(\"\\n\".join(test_str) + \"\\n\")\n\n    # Tests that \"# type: ignore[*]\" is supported in type lines and is\n    # properly ignored.\n    def test_mypy_type_ignore(self):\n        @torch.jit.script\n        def foo(x):  # type: ignore\n            return x\n\n        @torch.jit.script\n        def bar(x):  # type: ignore[no-redef]\n            return x\n\n    def test_method_casts_script(self):\n        cast_types = [\n            'byte', 'char', 'double', 'float', 'int', 'long', 'short'\n        ]\n\n        for cast_type in cast_types:\n            cu = torch.jit.CompilationUnit('''\n            def cast_to(x):\n                return x.{cast_type}()\n            '''.format(cast_type=cast_type))\n\n            x = torch.rand(3, 4, 5) * 128\n            cu_result = cu.cast_to(x)\n            reference = getattr(x, cast_type)()\n            self.assertEqual(cu_result, reference)\n\n    def test_string_frontend_elif(self):\n        code = '''\n            def func(niter):\n                # type: (int)\n                rv = 0\n                for i in range(niter):\n                    if i % 3 == 0 and i % 5 == 0:\n                        rv += 35\n                    elif i % 3 == 0:\n                        rv += 3\n                    elif i % 5 == 0:\n                        rv += 5\n                    else:\n                        rv += i\n                return rv\n        '''\n\n        self.checkScript(dedent(code), (101,))\n\n    def test_module_parameters_and_buffers(self):\n        weights = torch.randn(10, 10)\n        bias = torch.randn(10)\n        weights2 = torch.randn(10, 10)\n        bias2 = torch.randn(10)\n\n        class TestLinear(torch.nn.Module):\n            def __init__(self, in_features, out_features):\n                super(TestLinear, self).__init__()\n                self.in_features = in_features\n                self.out_features = out_features\n                self.weight = torch.nn.Parameter(torch.empty(out_features, in_features))\n                self.bias = torch.nn.Parameter(torch.empty(out_features))\n                self.register_buffer('counter', torch.ones(out_features))\n                self.reset_parameters()\n\n            def reset_parameters(self):\n                torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n                if self.bias is not None:\n                    fan_in, _ = torch.nn.init._calculate_fan_in_and_fan_out(self.weight)\n                    bound = 1 / math.sqrt(fan_in)\n                    torch.nn.init.uniform_(self.bias, -bound, bound)\n\n            def forward(self, input):\n                return F.linear(input, self.weight, self.bias) + self.counter\n\n        # Initialize a ScriptModule that uses the weak module above multiple times\n        class Strong(torch.jit.ScriptModule):\n            def __init__(self):\n                super(Strong, self).__init__()\n                self.fc1 = TestLinear(10, 10)\n                self.fc1.weight = torch.nn.Parameter(weights)\n                self.fc1.bias = torch.nn.Parameter(bias)\n                self.fc2 = TestLinear(10, 10)\n                self.fc2.weight = torch.nn.Parameter(weights2)\n                self.fc2.bias = torch.nn.Parameter(bias2)\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return x + self.fc1(x) + self.fc1(x) + self.fc2(x)\n\n        strong_mod = Strong()\n\n        # Run same calculation as module\n        inp = torch.ones(10)\n        lin = torch.nn.Linear(10, 10)\n        lin.weight = torch.nn.Parameter(weights)\n        lin.bias = torch.nn.Parameter(bias)\n        lin2 = torch.nn.Linear(10, 10)\n        lin2.weight = torch.nn.Parameter(weights2)\n        lin2.bias = torch.nn.Parameter(bias2)\n        expected_result = inp + (lin(inp) + torch.ones(10)) * 2 + lin2(inp) + torch.ones(10)\n\n        self.assertEqual(strong_mod(inp), expected_result)\n        self.assertExportImportModule(strong_mod, (inp,))\n\n    def test_module_copying(self):\n        class Submodule(torch.nn.Module):\n            def __init__(self):\n                super(Submodule, self).__init__()\n\n            def forward(self, x):\n                return x + 100\n\n        class Weak(torch.nn.Module):\n            def __init__(self, in_features, out_features):\n                super(Weak, self).__init__()\n                self.weight = torch.nn.Parameter(torch.ones(out_features, in_features))\n                self.bias = torch.nn.Parameter(torch.ones(out_features))\n                self.register_buffer(\"buffer\", torch.ones(out_features))\n                self.submodule = Submodule()\n\n            def forward(self, x):\n                return F.linear(x, self.weight, self.bias) \\\n                    + self.buffer + self.submodule(x)\n\n        class Strong(torch.jit.ScriptModule):\n            def __init__(self, weak):\n                super(Strong, self).__init__()\n                self.weak = weak\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.weak(x)\n\n        inp = torch.ones(5, 5) * 5\n        weak_mod = Weak(5, 5)\n        strong_mod = Strong(weak_mod)\n\n        self.assertTrue(isinstance(strong_mod.weak, torch.jit.ScriptModule))\n        self.assertFalse(isinstance(weak_mod, torch.jit.ScriptModule))\n\n        self.assertIs(strong_mod.weak.weight, weak_mod.weight)\n        self.assertIs(strong_mod.weak.buffer, weak_mod.buffer)\n        # strong_mod.weak.submodule has been recursively scripted\n        self.assertIsNot(strong_mod.weak.submodule, weak_mod.submodule)\n\n        weak_mod.weight.data += torch.ones(5, 5) * 100\n        self.assertTrue(strong_mod(inp).allclose(weak_mod(inp)))\n\n        # Re-assignment is not tracked\n        weak_mod.weight = torch.nn.Parameter(torch.ones(5, 5) * 100)\n        self.assertFalse(strong_mod(inp).allclose(weak_mod(inp)))\n\n    def test_backend_cudnn_enabled(self):\n        # Only test that this compiles\n        @torch.jit.script\n        def fn(x):\n            if torch.backends.cudnn.enabled:\n                x = x + 2\n            else:\n                x = x + 3\n            return x\n\n    def test_inplace_add(self):\n\n        def foo(a, b):\n            c = a + b\n            c.add_(b)\n            return c\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_add_out(self):\n        def foo(a, b):\n            c = a + b\n            e = 2 * a\n            torch.add(c, b, out=e)\n            return e\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_tuple_error_msg(self):\n        def fn(t: Any):\n            if isinstance(t, tuple):\n                a, b = t\n            return a + b\n        with self.assertRaisesRegexWithHighlight(RuntimeError, \"Provided tuple is not fully defined/refined\", \"t\"):\n            s = torch.jit.script(fn)\n\n    def test_augmented_assign(self):\n        def foo(a, b):\n            a += b\n            a -= b\n            a /= b\n            a *= b\n            return a, b\n        self.checkScript(foo, (torch.rand(3), torch.rand(3)))\n\n    def test_ignored_props(self):\n        class A(nn.Module):\n            __jit_ignored_attributes__ = [\"ignored\", \"ignored_return_val\"]\n\n            def __init__(self):\n                super().__init__()\n\n            @property\n            def ignored(self):\n                raise ValueError(\"shouldn't be called\")\n\n            @property\n            def ignored_return_val(self):\n                return 1\n\n            @torch.jit.ignore\n            def call(self):\n                return self.ignored_return_val\n\n        f = torch.jit.script(A())\n        # jank way to test if there is no error\n        self.assertTrue(isinstance(f, torch.jit.ScriptModule))\n        self.assertTrue(isinstance(f.call(), property))\n\n\n    def test_pass(self):\n        def foo(x):\n            # type: (bool) -> int\n            for _i in range(3):\n                pass\n            if x:\n                pass\n            else:\n                pass\n            return 3\n\n        self.checkScript(foo, (True,))\n\n    def test_lhs_indexing(self):\n        def foo(a, b):\n            a = a.clone()\n            a[0] = b\n            return a\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_advanced_indexing_assignment(self):\n        def foo(x, y):\n            a = torch.exp(x)\n            b = x == 1\n            a[b] = y[b]\n            return a\n        self.checkScript(foo, (torch.ones(4, 3), torch.ones(4, 3)))\n\n    def test_lhs_advanced_indexing_augmented_assignment(self):\n        def foo(x, y):\n            a = torch.exp(x)\n            b = x == 1\n            a[b] += y[b]\n            return a\n        self.checkScript(foo, (torch.ones(4, 3), torch.ones(4, 3)))\n\n    def test_lhs_indexing_list(self):\n        def foo(a, b):\n            ls = [a]\n            ls[0] = b\n            return ls\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_inplace_copy_script(self):\n        def foo(x):\n            a = torch.rand(3, 4)\n            a.copy_(x)\n            return a\n        self.checkScript(foo, (torch.rand(3, 4),))\n\n    def test_lhs_indexing_increment(self):\n        def foo(a, b):\n            a[0] += b\n            return a\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_indexing_increment_list(self):\n        def foo(a, b):\n            a = a.clone()\n            ls = [a, b]\n            ls[0] += b\n            return ls\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_lhs_indexing_increment_list_prim(self):\n        def foo():\n            ls = [1, 2, 3]\n            ls[0] += 5\n            return ls\n        self.checkScript(foo, ())\n\n    def test_lhs_indexing_multi(self):\n        def foo(a, b):\n            a = a.clone()\n            foo, a[0], bar = (1, b, 3)\n            return foo, a, bar\n        self.checkScript(foo, (torch.rand(2, 3), torch.rand(3)))\n\n    def test_bool_dispatch(self):\n        with torch._jit_internal._disable_emit_hooks():  # TODO: Python print broadcasting list\n            def kwarg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, return_indices=False)\n            self.checkScript(kwarg_false, (torch.randn(3, 3, 3),))\n\n            def kwarg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, return_indices=True)\n            self.checkScript(kwarg_true, (torch.randn(3, 3, 3),))\n\n            def full_kwarg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, ceil_mode=False, return_indices=False)\n            self.checkScript(full_kwarg_false, (torch.randn(3, 3, 3),))\n\n            def full_kwarg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, ceil_mode=False, return_indices=True)\n            self.checkScript(full_kwarg_true, (torch.randn(3, 3, 3),))\n\n            def use_default(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1)\n            self.checkScript(use_default, (torch.randn(3, 3, 3),))\n\n            def arg_false(x):\n                # type: (Tensor) -> Tensor\n                return F.max_pool1d(x, 1, 1, 0, 1, False, False)\n            self.checkScript(arg_false, (torch.randn(3, 3, 3),))\n\n            def arg_true(x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return F.max_pool1d(x, 1, 1, 0, 1, False, True)\n            self.checkScript(arg_true, (torch.randn(3, 3, 3),))\n\n    def test_infer_size(self):\n        from torch._C import _infer_size\n\n        def fn(x, y):\n            # type: (Tensor, Tensor) -> List[int]\n            return _infer_size(x.size(), y.size())\n\n        self.checkScript(fn, (torch.ones(2, 4, 2), torch.ones(2, 4, 2)))\n\n    def test_hash(self):\n        def tester(fn, inputs):\n            for x in inputs:\n                for y in inputs:\n                    if x == y:\n                        self.assertEqual(fn(x), fn(y))\n                    else:\n                        self.assertNotEqual(fn(x), fn(y))\n\n        @torch.jit.script\n        def int_hash(x):\n            # type: (int) -> int\n            return hash(x)\n\n        @torch.jit.script\n        def float_hash(x):\n            # type: (float) -> int\n            return hash(x)\n\n        @torch.jit.script\n        def str_hash(x):\n            # type: (str) -> int\n            return hash(x)\n\n        tester(int_hash, (20, 21, 22))\n        tester(float_hash, (20.0, 21.00001, 22.443))\n        tester(str_hash, (\"\", \"hello\", \"a\"))\n\n    def test_id(self):\n        with self.assertRaisesRegex(RuntimeError, \"Expected a value\"):\n            @torch.jit.script\n            def test_id_scalars():\n                return id(2) == id(None)\n\n        @torch.jit.script\n        class FooTest(object):\n            def __init__(self, x):\n                self.foo = x\n\n            def getFooTest(self):\n                return self.foo\n\n        @torch.jit.script\n        def test_id_class_types():\n            obj1 = FooTest(torch.tensor(3))\n            obj2 = FooTest(torch.tensor(2))\n            assert obj1 is not obj2\n            assert id(obj1) != id(obj2)\n            assert id(obj1) != id(None)\n            return True\n\n        self.assertTrue(test_id_class_types())\n\n    def test_mutable_dce(self):\n        @torch.jit.script\n        def foo():\n            a = torch.rand(2, 3)\n            a += torch.rand(2, 3)\n            b = torch.rand(2, 3)\n            b += torch.rand(2, 3)\n            # b should be cleaned up but not a\n            return a\n\n        FileCheck().check_count(\"aten::rand\", 2, exactly=True) \\\n            .check_count(\"aten::add\", 1, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_block(self):\n        @torch.jit.script\n        def foo():\n            a = torch.rand(2, 3)\n            a += torch.rand(2, 3)\n            b = torch.rand(2, 3)\n            if bool(a > torch.zeros(2, 3)):\n                b += torch.rand(2, 3)\n                a += torch.rand(2, 3)\n            # a should be cleaned up but not b\n            return b\n\n        FileCheck().check(\"prim::If\").check_count(\"aten::rand\", 1, exactly=True) \\\n            .run(str(foo.graph))\n\n    def test_mutable_dce_graph_input(self):\n        @torch.jit.script\n        def foo(a):\n            a += torch.rand(2, 3)\n            # shouldn't clean up `a` even though it's not used in the output\n\n        FileCheck().check(\"aten::rand\").check(\"aten::add\").run(str(foo.graph))\n\n    def test_mutable_dce_list(self):\n        @torch.jit.script\n        def foo(a):\n            l = []\n            l.append(a)\n            c = l[0]\n            b = torch.rand(2, 3)\n            c += torch.rand(2, 3)\n            return b\n\n        # c does not get cleaned up because there is a wildcard + mutation\n        FileCheck().check_count(\"aten::rand\", 2, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_loop(self):\n        @torch.jit.script\n        def foo(a):\n            l = []\n            l.append(a)\n            i = 0\n            b = torch.rand(2, 3)\n            while i < 1:\n                dead = torch.rand(2, 3)\n                c = l[0]\n                c += torch.rand(2, 3)\n                i += 1\n            return b\n\n        FileCheck().check(\"prim::Loop\").check_not(\"aten::rand\").check(\"aten::__getitem__\") \\\n            .check_count(\"aten::rand\", 1, exactly=True).run(str(foo.graph))\n\n    def test_mutable_dce_indirect_wildcards(self):\n        def fn():\n            x = torch.ones(2, 3)\n            x_1 = x.view(-1)\n            l = []\n            l.append(x_1)\n            x_view = l[0]\n            x.add_(torch.ones(2, 3))\n            return x_view\n        self.checkScript(fn, ())\n\n    def test_mutable_dce_indirect_wildcard_write(self):\n        def fn():\n            indexes = torch.jit.annotate(List[Tensor], [])\n            word_ids = torch.zeros(10, dtype=torch.int32)\n            word_ids[1] = 1\n            indexes.append(word_ids)\n\n            return word_ids\n        self.checkScript(fn, ())\n\n    def test_mutable_dce_wildcards(self):\n        def fn():\n            x = torch.ones(2, 3)\n            l = []\n            l.append(x)\n            x_view = l[0]\n            x.add_(torch.ones(2, 3))\n            return x_view\n\n        self.checkScript(fn, (), profiling=ProfilingMode.SIMPLE)\n\n    def test_cpp_function_tensor_str(self):\n        x = torch.randn(2, 2)\n        scale = torch.randn(2, 2, requires_grad=True)\n        shift = torch.randn(2, 2, requires_grad=True)\n\n        @torch.jit.script\n        def fn(x, scale, shift):\n            return scale * x + shift\n\n        with self.capture_stdout() as captured:\n            print(fn(x, scale, shift))\n\n    def test_string_index(self):\n        def fn(x):\n            # type: (str)\n            return x[2], x[-1]\n\n        self.checkScript(fn, (\"abcde\",))\n\n    def test_ord(self):\n        def fn(x):\n            # type: (str) -> int\n            return ord(x)\n\n        self.checkScript(fn, (\"h\"))\n        self.checkScript(fn, (\"y\"))\n\n        def index_str_to_tensor(s):\n            # type: (str) -> Tensor\n            return torch.tensor(ord(s))  # noqa: T484\n\n        s = u'\\u00a3'.encode('utf8')[:1]\n        self.checkScript(index_str_to_tensor, (s,))\n\n    def test_chr(self):\n        def fn(x):\n            # type: (int) -> str\n            return chr(x)\n\n        self.checkScript(fn, (1,))\n        self.checkScript(fn, (97,))\n\n    def test_round(self):\n        def round_float(x):\n            # type: (float) -> float\n            return round(x)\n\n        def round_int(x):\n            # type: (int) -> float\n            return round(x)\n\n        self.checkScript(round_float, (1.5,))\n        self.checkScript(round_int, (2,))\n\n    def test_convert_base(self):\n        def test_hex(x):\n            # type: (int) -> str\n            return hex(x)\n\n        def test_oct(x):\n            # type: (int) -> str\n            return oct(x)\n\n        def test_bin(x):\n            # type: (int) -> str\n            return bin(x)\n\n        numbers = [-1000, -10, 0, 1, 10, 2343]\n        for n in numbers:\n            self.checkScript(test_bin, (n,))\n            self.checkScript(test_oct, (n,))\n            self.checkScript(test_hex, (n,))\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    def test_get_set_state(self):\n        class Root(torch.jit.ScriptModule):\n            __constants__ = ['number']\n\n            def __init__(self, number):\n                super(Root, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n                self.number = number\n\n            @torch.jit.script_method\n            def __getstate__(self):\n                return (self.buffer1, self.buffer2, 74, self.training)\n\n            @torch.jit.script_method\n            def __setstate__(self, state):\n                self.buffer1 = state[0] + 10\n                self.buffer2 = state[1] + 10\n                self.training = state[3]\n\n        class M(torch.jit.ScriptModule):\n            __constants__ = ['number']\n\n            def __init__(self, number, submodule):\n                super(M, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n                self.number = number\n                self.submodule = submodule\n\n            @torch.jit.script_method\n            def __getstate__(self):\n                return (self.buffer1, self.buffer2, 74, self.submodule, self.training)\n\n            @torch.jit.script_method\n            def __setstate__(self, state):\n                self.buffer1 = state[0] + 10\n                self.buffer2 = state[1] + 10\n                self.submodule = state[3]\n                self.training = state[4]\n\n        with TemporaryFileName() as fname:\n            m = M(23, submodule=Root(99))\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n\n        # Check original module\n        self.assertEqual(m.buffer1, torch.ones(2, 2))\n        self.assertEqual(m.buffer2, torch.ones(2, 2))\n\n        # Check top level module\n        self.assertEqual(loaded.buffer1, torch.ones(2, 2) + 10)\n        self.assertEqual(loaded.buffer2, torch.ones(2, 2) + 10)\n\n        # Check submodule\n        self.assertEqual(loaded.submodule.buffer1, torch.ones(2, 2) + 10)\n        self.assertEqual(loaded.submodule.buffer2, torch.ones(2, 2) + 10)\n\n        # Check simpler module\n        class NoArgState(torch.nn.Module):\n            def __init__(self):\n                super(NoArgState, self).__init__()\n                self.register_buffer('buffer1', torch.ones(2, 2))\n                self.register_buffer('buffer2', torch.ones(2, 2))\n\n            def forward(self):\n                pass\n\n            @torch.jit.export\n            def __getstate__(self):\n                return 5, self.training\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.buffer1 = torch.ones(2, 2) + state[0]\n                self.buffer2 = torch.ones(2, 2) + 10\n                self.training = state[1]\n\n        with TemporaryFileName() as fname:\n            m = torch.jit.script(NoArgState())\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n            self.assertEqual(loaded.buffer1, torch.ones(2, 2) + 5)\n            self.assertEqual(loaded.buffer2, torch.ones(2, 2) + 10)\n\n\n\n    def test_string_slicing(self):\n        def fn1(x):\n            # type: (str) -> str\n            return x[1:3]\n\n        def fn2(x):\n            # type: (str) -> str\n            return x[-1:3]\n\n        def fn3(x):\n            # type: (str) -> str\n            return x[3:1]\n\n        def fn4(x):\n            # type: (str) -> str\n            return x[3:100]\n\n        self.checkScript(fn1, (\"abcdefghi\",))\n        self.checkScript(fn2, (\"abcdefghi\",))\n        self.checkScript(fn3, (\"abcdefghi\",))\n        self.checkScript(fn4, (\"abcdefghi\",))\n\n    def test_early_return_closure(self):\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    pass\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        g = cu.tanh.graph\n        FileCheck().check_count(\"prim::Closure_0\", 2).check(\"NoneType = prim::Constant\") \\\n                   .check_next(\"return\").run(g)\n\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    a = 1\n                    if output:\n                        return 1\n                    else:\n                        a = 2\n                    return a\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        g = cu.tanh.graph\n        FileCheck().check_count(\"prim::Closure_0\", 2).check(\"int = prim::If\") \\\n                   .run(g)\n\n        code = dedent('''\n            def loop_in_closure(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    for i in range(3):\n                        return 1\n                    return 4\n                return output, backward\n        ''')\n        cu = torch.jit.CompilationUnit(code)\n        fc = FileCheck()\n        fc.check(\"prim::Closure\").check(\"(Tensor, NoneType) = prim::TupleConstruct\")\n        # Loop then two if's added in exit transform\n        fc.check(\"prim::Closure\").check(\"prim::Loop\").check_count(\"prim::If\", 2)\n        fc.run(cu.loop_in_closure.graph)\n\n        code = dedent('''\n            def tanh(self):\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    if 1 == 1:\n                        return 1\n                    else:\n                        return 1.\n                return output, backward\n        ''')\n        with self.assertRaisesRegex(RuntimeError, \"returned a value of type int but\"):\n            cu = torch.jit.CompilationUnit(code)\n\n    @_inline_everything\n    def test_early_return_fork_join(self):\n        @torch.jit.script\n        def foo(x):\n            if x.dim() == 2:\n                return torch.neg(x), x\n            else:\n                return torch.neg(x), x + 1\n\n        x = torch.rand(3, 4)\n\n        @torch.jit.script\n        def wait_script(x):\n            fut = torch.jit._fork(foo, x)\n            y_hat = foo(x)\n            y = torch.jit._wait(fut)\n            return y, y_hat\n\n        FileCheck().check(\"with prim::fork\").check(\"prim::If\").check(\"return\")\\\n                   .run(wait_script.graph)\n\n    def test_early_return_type_refinement(self):\n        @torch.jit.script\n        def test(x):\n            # type: (Optional[int]) -> int\n            if x is None:\n                return 1\n            else:\n                return x\n        self.assertEqual(test(None), 1)\n        self.assertEqual(test(2), 2)\n\n    def test_exceptions_with_control_flow(self):\n        def test_num_ifs(func, num_ifs):\n            g = torch.jit.script(func).graph\n            FileCheck().check_count(\"prim::If\", num_ifs, exactly=True).run(g)\n\n        def no_guard_ifs_added(x):\n            # type: (int) -> int\n            if x == 1:\n                return 1\n            else:\n                if x == 2:\n                    raise RuntimeError(\"hi\")\n                else:\n                    raise RuntimeError(\"hi\")\n\n        self.checkScript(no_guard_ifs_added, (1,))\n        self.checkScriptRaisesRegex(no_guard_ifs_added, (2,), Exception, \"\")\n        test_num_ifs(no_guard_ifs_added, 2)\n\n        # FUNCTION LOOKS LIKE:\n        # graph(%x.1 : int):\n        #   %7 : str = prim::Constant[value=\"Exception\"]()\n        #   %2 : int = prim::Constant[value=1]()\n        #   %5 : int = prim::Constant[value=2]()\n        #   %19 : int = prim::Uninitialized()\n        #   %3 : bool = aten::eq(%x.1, %2)\n        #   %20 : int = prim::If(%3)\n        #     block0():\n        #       -> (%2)\n        #     block1():\n        #       %6 : bool = aten::eq(%x.1, %5)\n        #        = prim::If(%6)\n        #         block0():\n        #            = prim::RaiseException(%7)\n        #           -> ()\n        #         block1():\n        #            = prim::RaiseException(%7)\n        #           -> ()\n        #       -> (%19)\n        #   return (%20)\n\n        def no_ifs_added(x):\n            # type: (int) -> int\n            if x < 0:\n                raise RuntimeError(\"hi\")\n            return x\n\n        self.checkScript(no_ifs_added, (1,))\n        self.checkScriptRaisesRegex(no_ifs_added, (-2,), Exception, \"\")\n        test_num_ifs(no_ifs_added, 1)\n\n        def test_if_might(x):\n            # type: (int)\n            if x > 0:\n                if x == 1:\n                    return 1\n                else:\n                    a = 2\n            else:\n                raise RuntimeError(\"hi\")\n            return a + 2\n\n        self.checkScript(test_if_might, (1,))\n        self.checkScript(test_if_might, (3,))\n        self.checkScriptRaisesRegex(no_ifs_added, (-2,), Exception, \"\")\n        test_num_ifs(test_if_might, 3)  # one if added to guard a + 2\n\n        def test_loop_no_escape(x):\n            # type: (int)\n            if x >= 0:\n                for i in range(x):\n                    raise RuntimeError(\"hi\")\n            else:\n                return 5\n            return x + 3\n\n        self.checkScript(test_loop_no_escape, (0,))\n        self.checkScript(test_loop_no_escape, (-1,))\n        self.checkScriptRaisesRegex(test_loop_no_escape, (1,), Exception, \"\")\n\n        # if guard gets optimized away\n        test_num_ifs(test_loop_no_escape, 1)\n\n        def test_loop_exception_with_continue(x):\n            # type: (int)\n            i = 0\n            for i in range(5):\n                if i == x:\n                    raise RuntimeError(\"hi\")\n                else:\n                    continue\n                print(i)\n            return i + 5\n\n        self.checkScript(test_loop_exception_with_continue, (-1,))\n        self.checkScriptRaisesRegex(test_loop_exception_with_continue, (1,), Exception, \"\")\n        test_num_ifs(test_loop_exception_with_continue, 1)  # no ifs added to guard print\n\n\n    def test_exception_exits_closure(self):\n        code = dedent('''\n            def no_return_func(self):\n                # type: (Tensor) -> Tensor\n                output = torch.tanh(self)\n                def backward(grad_output):\n                    raise RuntimeError(\"Hi\")\n        ''')\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            cu = torch.jit.CompilationUnit(code)\n\n        code = dedent('''\n            def test_exit_pair_reset(x):\n                # type: (int) -> int\n                if x > 0:\n                    a = 0\n                    def backward(grad_output):\n                        raise RuntimeError(\"Hi\")\n                    a = a + 1\n                else:\n                    return x\n                return a + 1\n        ''')\n        func = torch.jit.CompilationUnit(code).test_exit_pair_reset\n        self.assertEqual(func(1,), 2)\n        self.assertEqual(func(-1,), -1)\n        # final a + 1 gets inlined into the first branch and optimized away\n        FileCheck().check_count(\"prim::If\", 1, exactly=True).run(func.graph)\n\n    def test_non_final_return(self):\n        def simple(x):\n            if bool(x > 3):\n                return x + 1\n            else:\n                return x + 2\n            raise RuntimeError(\"nope\")\n\n        def nest(x):\n            x = x + 1\n            if bool(x > 3):\n                if bool(x > 4):\n                    x += 1\n                return x + 1\n            else:\n                return x + 2\n\n        def early_ret(x):\n            x = x + 1\n            if bool(x > 3):\n                return x + 1\n            x = x + 1\n            return x + 2\n\n        def nest_early_ret(x):\n            x = x + 1\n            if bool(x > 3):\n                if bool(x > 4):\n                    return x + 2\n                return x + 1\n            x = x + 1\n            return x + 2\n\n        def not_early_ret(x):\n            s = \"\"\n            if bool(x > 3):\n                if bool(x > 4):\n                    return 1, s\n                s += \"foo\"\n            else:\n                s += \"5\"\n            s += \"hi\"\n            return 7, s\n\n        def not_total_ret(x):\n            s = \"\"\n            if bool(x > 3):\n                if bool(x > 4):\n                    return 1, s\n                else:\n                    return 2, s\n            else:\n                s += \"5\"\n            return 7, s\n\n        for i in range(3):\n            for func in [simple, nest, early_ret, nest_early_ret, not_early_ret,\n                         not_total_ret]:\n                self.checkScript(func, (torch.tensor(2.5 + i),))\n\n        def vars_used_after_ret(x):\n            # type: (int) -> int\n            if x == 0:\n                return x\n            else:\n                y = 2\n                z = 3\n            return x + y * z\n\n        self.checkScript(vars_used_after_ret, (1,))\n        self.checkScript(vars_used_after_ret, (0,))\n\n        def complicated(x):\n            # type: (int) -> int\n            if x:\n                if x == 2:\n                    return 1\n                    assert 1 == 2\n                else:\n                    if x == 3:\n                        return 2\n                        assert 1 == 2\n                    else:\n                        a = 2\n                        b = 3\n            else:\n                a = 4\n                b = 1\n            return a + b\n            assert 1 == 2\n\n        for i in range(4):\n            self.checkScript(complicated, (i,))\n\n    def test_partial_returns(self):\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def no_ret():\n                # type: () -> int\n                pass\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def partial(x):\n                # type: (Tensor) -> int\n                if x:\n                    return 1\n\n        with self.assertRaisesRegex(RuntimeError, \"does not return along all\"):\n            @torch.jit.script\n            def typed_none():\n                # type: () -> Optional[int]\n                pass\n\n        @torch.jit.script\n        def none_ret():\n            pass\n\n        self.assertIs(none_ret(), None)\n        FileCheck().check(\": None\").run(none_ret.graph)\n\n    def test_early_returns_loops(self):\n        def nest_while_ret(x):\n            # type: (int) -> int\n            y = 4\n            while x < 4:\n                if x < 3:\n                    return y\n                else:\n                    y = y + 1\n                    break\n                y = y + 2\n            y = y + 1\n            return y\n\n        self.checkScript(nest_while_ret, (2,))\n        self.checkScript(nest_while_ret, (3,))\n        self.checkScript(nest_while_ret, (4,))\n\n        def loop_ret(x, y):\n            # type: (int, int) -> (int)\n            i = 0\n            for i in range(x):\n                if x == y:\n                    return x + y\n                i = i + y\n            i = i - 1\n            return i\n\n        self.checkScript(loop_ret, (3, 3))\n        self.checkScript(loop_ret, (2, 3))\n        self.checkScript(loop_ret, (3, 1))\n\n        def test_will_ret(y):\n            # type: (int) -> int\n            for i in range(y):\n                return 2\n            return 1\n\n        self.checkScript(test_will_ret, (0,))\n        self.checkScript(test_will_ret, (1,))\n\n        def test_loop_nest_ret(y):\n            # type: (int) -> int\n            for i in range(y):\n                for i in range(y - 2):\n                    return 10\n                return 5\n            return 0\n\n        self.checkScript(test_loop_nest_ret, (0,))\n        self.checkScript(test_loop_nest_ret, (1,))\n        self.checkScript(test_loop_nest_ret, (2,))\n\n    def test_nn_init(self):\n        tests = (\n            ('constant_', (lambda: (torch.ones(2, 2), 2.5)), \"Tensor, float\"),\n            ('ones_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('zeros_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('uniform_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('normal_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('xavier_normal_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n            ('xavier_uniform_', (lambda: (torch.ones(2, 2),)), \"Tensor\"),\n        )\n\n        for name, args_fn, type_str in tests:\n            # Build test code\n            arg_str = ', '.join([chr(i + ord('a')) for i in range(len(args_fn()))])\n\n            code = dedent('''\n                def test({arg_str}):\n                    # type: ({type_str})\n                    return torch.nn.init.{name}({arg_str})\n            ''').format(arg_str=arg_str, type_str=type_str, name=name)\n            cu = torch.jit.CompilationUnit(code)\n\n            # Compare functions\n            init_fn = getattr(torch.nn.init, name)\n            script_out = self.runAndSaveRNG(cu.test, args_fn())\n            eager_out = self.runAndSaveRNG(init_fn, args_fn())\n            self.assertEqual(script_out, eager_out)\n\n            FileCheck().check_not(\"prim::PythonOp\").run(cu.test.graph)\n\n    def test_early_return_rewrite(self):\n        def test_foo(x: bool):\n            if x:\n                return 1\n            return 2\n\n        self.checkScript(test_foo, (True,))\n        self.checkScript(test_foo, (False,))\n        FileCheck().check_count(\"prim::If\", 1, exactly=True).run(torch.jit.script(test_foo).graph)\n\n        def test_multiple(x: int):\n            if x == 5:\n                return x * x\n            else:\n                y = 2 * x\n\n            z = y * 2\n            if z == 8:\n                return 1\n\n            if z != 16:\n                z = z - 2\n                abc = 4\n            else:\n                return 3\n\n            z = z * abc\n            return z * z * z\n\n        self.checkScript(test_multiple, (5,))\n        self.checkScript(test_multiple, (2,))\n        self.checkScript(test_multiple, (4,))\n        self.checkScript(test_multiple, (3,))\n        self.checkScript(test_multiple, (10,))\n\n        graph = torch.jit.script(test_multiple).graph\n        FileCheck().check_count(\"prim::If\", 3, exactly=True).run(graph)\n\n    def test_is_scripting_metacompile(self):\n        @torch.jit.script\n        def foo():\n            if torch.jit.is_scripting():\n                return 1\n            else:\n                print(\"hello\") + 2  # will not be compiled\n\n        self.assertEqual(foo(), 1)\n\n    def test_boolean_literal_constant_metacompile(self):\n        class Mod(torch.nn.Module):\n            __constants__ = ['val']\n\n            def __init__(self, val):\n                super(Mod, self).__init__()\n                self.val = val\n\n            def forward(self):\n                if self.val:\n                    return 1\n                else:\n                    return \"2\"\n\n        self.checkModule(Mod(True), ())\n        self.checkModule(Mod(False), ())\n\n        @torch.jit.script\n        def foo():\n            if True:\n                return 1\n            else:\n                return \"2\"\n\n        self.assertEqual(foo(), 1)\n\n    def test_assert_is_scripting_metacompile(self):\n        def foo():\n            assert not torch.jit.is_scripting(), \"TestErrorMsg\"\n            print(\"hello\") + 2  # will not be compiled\n\n        f = torch.jit.script(foo)\n        with self.assertRaisesRegex(torch.jit.Error, \"TestErrorMsg\"):\n            f()\n\n    def test_isinstance_metacompile(self):\n        @torch.jit.script\n        def test_primitive_type(x):\n            # type: (int) -> int\n            if isinstance(x, int):\n                return x + 1\n            else:\n                return x - 1\n\n        self.assertEqual(test_primitive_type(1), 2)\n        with self.assertRaisesRegex(Exception, \"Expected a value of type\"):\n            test_primitive_type(1.5)\n\n        _MyNamedTuple = namedtuple('_MyNamedTuple', ['value'])\n\n        @torch.jit.script\n        def test_non_primitive_types(x):\n            # type: (_MyNamedTuple) -> Tensor\n            if isinstance(1, _MyNamedTuple):\n                return 10\n\n            if isinstance(x, _MyNamedTuple):\n                return x.value + 1\n            else:\n                return 1\n\n        out = test_non_primitive_types(_MyNamedTuple(value=torch.tensor(5.0)))\n        self.assertEqual(out, torch.tensor(6.0))\n\n    def test_namedtuple_type_inference(self):\n        _AnnotatedNamedTuple = NamedTuple('_NamedTupleAnnotated', [('value', int)])\n        _UnannotatedNamedTuple = namedtuple('_NamedTupleUnAnnotated', ['value'])\n\n        def test_check_named_tuple_value():\n            named_tuple = _AnnotatedNamedTuple(1)\n            return named_tuple.value\n\n        self.checkScript(test_check_named_tuple_value, ())\n\n        def test_error():\n            return _UnannotatedNamedTuple(1)\n\n        with self.assertRaisesRegex(RuntimeError, r\"Expected a value of type \\'Tensor \\(inferred\\)\\' \"\n                                                  r\"for argument \\'value\\' but instead found type \\'int\\'.\"):\n            torch.jit.script(test_error)\n\n    def test_namedtuple_default_values_simple_type(self):\n\n        class Point(NamedTuple):\n            x: Optional[int] = None\n            y: int = 2\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=3, y=2)\n\n        self.checkModule(M(), (p,))\n        self.checkModule(M(), (Point(),))\n\n        m = torch.jit.script(M())\n\n        FileCheck().check(r\"NamedTuple(x : int? = None, y : int = 2))\")   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_missing(self):\n\n        class Point(NamedTuple):\n            x: Optional[int]\n            y: int\n            z: int = 3\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p1 = Point(x=3, y=2)\n        p2 = Point(x=3, y=2, z=1)\n\n        self.checkModule(M(), (p1,))\n        self.checkModule(M(), (p2,))\n\n        m = torch.jit.script(M())\n\n        FileCheck().check(r\"NamedTuple(x : int?, y : int, z : int = 3))\")   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_container_type(self):\n\n        class Point(NamedTuple):\n            x: Optional[List[int]] = None\n            y: List[int] = [1, 2, 3]\n            z: Optional[Dict[str, int]] = {\"a\": 1}\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=[4, 5, 6], y=[3, 2, 1], z={\"b\": 2})\n\n        self.checkModule(M(), (p,))\n        self.checkModule(M(), (Point(),))\n\n        m = torch.jit.script(M())\n\n        first_line = r\"NamedTuple(x : int[]? = None, y : int[] = \"    \\\n                     r\"[1, 2, 3], z : Dict(str, int)? = {a: 1}))\"\n\n        FileCheck().check(first_line)   \\\n                   .run(m.graph)\n\n    def test_namedtuple_default_values_Tensor_type(self):\n\n        class Point(NamedTuple):\n            x: torch.Tensor = torch.rand(2, 3)\n\n        make_global(Point)\n\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n\n            def forward(self, point: Point):\n                return point\n\n        p = Point(x=torch.rand(2, 3))\n\n        with self.assertRaisesRegex(RuntimeError, \"Tensors are not \"\n                                    \"supported as default NamedTuple \"\n                                    \"fields\"):\n            m = torch.jit.script(M())\n            m(p)\n\n    @unittest.skipIf(sys.version_info < (3, 7, 0), \"defaults keyword added in Python 3.8\")\n    def test_namedtuple_default_values_using_factory_constructor(self):\n        Pair = namedtuple(\"Pair\", [\"x\", \"y\"], defaults=(1, 2))\n\n        make_global(Pair)\n\n        @torch.jit.script\n        def fn(x: Pair) -> Pair:\n            return x\n\n        # TODO: We can't use `checkScript` with the NamedTuple factory\n        # constructor. Using the factory constructor with TorchScript\n        # TorchScript creates an anonymous `NamedTuple` class instead of\n        # preserving the actual name. For example, the actual generated\n        # signature in this case is:\n        #   graph(%x.1 : NamedTuple(x : Tensor, y : Tensor))\n        # It looks like similar test cases have had this issue as well\n        # (see: `test_namedtuple_python`).\n        FileCheck().check(r\"NamedTuple(x : Tensor = 1, y : Tensor = 2))\")   \\\n                   .check_next(r\"return (%x.1)\")    \\\n                   .run(fn.graph)\n\n    def test_isinstance_dynamic(self):\n        @torch.jit.script\n        def foo(a):\n            # type: (Optional[List[int]]) -> int\n            b = 0\n            if isinstance(a, (int, (float,), list, str)):\n                b += 1\n            if isinstance(a, (int, str)):\n                b += 1\n            if isinstance(a, List[int]):\n                b += 1\n            return b\n        self.assertEqual(foo([3, 4]), 2)\n        self.assertEqual(foo(None), 0)\n\n    def test_function_overloads(self):\n        # TODO: pyflakes currently does not compose @overload annotation with other\n        # decorators. This is fixed on master but not on version 2.1.1.\n        # Next version update remove noqa and add @typing.overload annotation\n\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (int) -> int\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        def test_simple(x1):  # noqa: F811\n            return x1\n\n        def invoke_function():\n            return test_simple(1.0), test_simple(.5)\n\n        self.checkScript(invoke_function, ())\n\n        # testing that the functions are cached\n        compiled_fns_1 = torch.jit._script._get_overloads(test_simple)\n        compiled_fns_2 = torch.jit._script._get_overloads(test_simple)\n        for a, b in zip(compiled_fns_1, compiled_fns_2):\n            self.assertIs(a.graph, b.graph)\n\n        old_func = test_simple\n\n        # testing that new functions added work with caching\n        @torch.jit._overload  # noqa: F811\n        def test_simple(x1):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        @torch.jit.script\n        def my_func():\n            return old_func(\"hi\")\n\n        # testing new function same qualified name\n        @torch.jit._overload  # noqa: F811\n        def test_simple(a, b):  # noqa: F811\n            # type: (int, int) -> int\n            pass\n\n        def test_simple(a, b):\n            return a + b\n\n        @torch.jit.script\n        def fn():\n            return test_simple(3, 4)\n\n        self.assertEqual(fn(), 7)\n\n        # currently we take the default values have to be specified in the\n        # overload as well - TODO take them from implementation and apply\n        # where the type is valid.\n        @torch.jit._overload  # noqa: F811\n        def identity(x1):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def identity(x1):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        def identity(x1=1.0):  # noqa: F811\n            return x1\n\n        def invoke():\n            return identity(), identity(.5), identity(\"hi\")\n\n        self.checkScript(invoke, ())\n\n        def schema_match_failure():\n            return identity((1, 2))\n\n        thrown = False\n        try:\n            torch.jit.script(schema_match_failure)\n        except Exception as e:\n            thrown = True\n            self.assertTrue(r\"of type 'str'\" in str(e) and r\"of type 'float\" in str(e))\n        self.assertTrue(thrown)\n\n        with self.assertRaisesRegex(Exception, \"cannot be directly compiled\"):\n            torch.jit.script(identity)\n\n        @torch.jit._overload  # noqa: F811\n        def impl_compile_failure(x, y):  # noqa: F811\n            # type: (str, str) -> (str)\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def impl_compile_failure(x, y):  # noqa: F811\n            # type: (int, int) -> (int)\n            pass\n\n        def impl_compile_failure(x, y):  # noqa: F811\n            return x - y\n\n        def test():\n            impl_compile_failure(\"one\", \"two\")\n\n\n        with self.assertRaisesRegex(Exception, \"Arguments for call are not valid\"):\n            torch.jit.script(test)\n\n        @torch.jit._overload  # noqa: F811\n        def good_overload(x=1):  # noqa: F811\n            # type: (int) -> (int)\n            pass\n\n        def good_overload(x=1):  # noqa: F811\n            return x\n\n        @torch.jit.script\n        def foo():\n            return good_overload()\n\n        self.assertEqual(foo(), 1)\n\n\n        with self.assertRaisesRegex(Exception, \"must equal to the default parameter\"):\n            @torch.jit._overload  # noqa: F811\n            def bad_default_on_overload(x, y=2):  # noqa: F811\n                # type: (int, int) -> (int)\n                pass\n\n            def bad_default_on_overload(x, y=1):  # noqa: F811\n                # type: (int, int) -> (int)\n                pass\n\n            @torch.jit.script\n            def test():\n                return bad_default_on_overload(1, 2)\n\n        @torch.jit._overload  # noqa: F811\n        def diff_default(x):  # noqa: F811\n            # type: (int) -> int\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def diff_default(x):  # noqa: F811\n            # type: (str) -> str\n            pass\n\n        def diff_default(x=\"hi\"):  # noqa: F811\n            return x\n\n        def test():\n            return diff_default(), diff_default(2), diff_default(\"abc\")\n\n        self.assertEqual(test(), torch.jit.script(test)())\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params(x):  # noqa: F811\n            # type: (float) -> float\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params(x, y):  # noqa: F811\n            # type: (int, int) -> int\n            pass\n\n        def diff_num_params(x, y=2, z=3):  # noqa: F811\n            # type: (Union[float, int], int, int)\n            return x + y + z\n\n        def test():\n            return diff_num_params(1.0), diff_num_params(1, 2), diff_num_params(1), diff_num_params(1, 2, 3)\n\n        self.assertEqual(test(), torch.jit.script(test)())\n\n        @torch.jit._overload  # noqa: F811\n        def diff_num_params_no_annot():\n            # type: () -> int\n            pass\n\n        def diff_num_params_no_annot(x=1):    # noqa: F811\n            return x\n\n        def test():\n            return diff_num_params_no_annot(1.0)\n\n        with self.assertRaisesRegex(Exception, \"Parameters not specified\"):\n            torch.jit.script(test)\n\n    def test_function_overload_misuse(self):\n        with self.assertRaisesRegex(RuntimeError, \"Only `pass` statement or `...` can be the body\"):\n            @torch.jit._overload\n            def wrong_decl_body(x: str) -> str:\n                return x + \"0\"\n\n        with self.assertRaisesRegex(RuntimeError, \"Only `pass` statement or `...` can be the body\"):\n            class MyClass:\n                @torch.jit._overload_method\n                def method(self):\n                    return 0\n\n        @torch.jit._overload\n        def null_overload(x: int) -> int: ...  # noqa: E704\n\n        @torch.jit._overload  # noqa: F811\n        def null_overload(x: str) -> str:  # noqa: F811\n            pass\n\n        def null_overload_driver():\n            return null_overload(0)\n\n        with self.assertRaisesRegex(RuntimeError, 'Implementation for the function \".+\" is missing.'):\n            torch.jit.script(null_overload_driver)\n\n        class OverloadMisuse(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            @torch.jit._overload_method\n            def forward(self, x: int):\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x: Tensor):  # noqa: F811\n                pass\n\n        with self.assertRaisesRegex(RuntimeError, 'Implementation for the method \".+\" is missing.'):\n            m = torch.jit.script(OverloadMisuse())\n\n\n    def test_script_method_torch_function_overload(self):\n        class MyCustomTensor(torch.Tensor):\n            pass\n\n        class MyCustomModule(torch.nn.Module):\n            def forward(self, x):\n                return torch.relu(x)\n\n        scripted_mod = torch.jit.script(MyCustomModule())\n        t = torch.tensor([3.0])\n        ref_out = scripted_mod(t)\n\n        t_custom = MyCustomTensor([3.0])\n        out1 = scripted_mod(t_custom)\n        self.assertEqual(out1, ref_out)\n\n        out2 = scripted_mod.forward(t_custom)\n        self.assertEqual(out2, ref_out)\n\n    def test_function_overloading_isinstance(self):\n        @torch.jit._overload  # noqa: F811\n        def my_conv(x, y):  # noqa: F811\n            # type: (float, str) -> (float)\n            pass\n\n        @torch.jit._overload  # noqa: F811\n        def my_conv(x, y):  # noqa: F811\n            # type: (float, float) -> (float)\n            pass\n\n        def my_conv(x, y=2.0):  # noqa: F811\n            if isinstance(y, str):\n                if y == \"hi\":\n                    return 4.0 - x\n                else:\n                    return 5.0 - x\n            else:\n                return 2.0 + x\n\n        def test_uses():\n            return my_conv(1.5), my_conv(1.5, \"hi\"), my_conv(1.5, 5.0)\n\n        self.checkScript(test_uses, ())\n\n    def test_method_overloading(self):\n        class Over(torch.nn.Module):\n            def __init__(self):\n                super(Over, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x):  # noqa: F811\n                # type: (Tuple[Tensor, Tensor]) -> Tensor\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def forward(self, x):  # noqa: F811\n                # type: (Tensor) -> Tensor\n                pass\n\n            def forward(self, x):  # noqa: F811\n                if isinstance(x, Tensor):\n                    return x + 20\n                else:\n                    return x[0] + 5\n\n        class S(torch.jit.ScriptModule):\n            def __init__(self):\n                super(S, self).__init__()\n                self.weak = Over()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.weak(x) + self.weak((x, x))\n\n        s_mod = S()\n        x = torch.ones(1)\n        self.assertEqual(s_mod(x), x + 20 + 5 + x)\n\n        over = Over()\n        self.assertEqual(over((x, x)), x + 5)\n        self.assertEqual(over((x)), x + 20)\n\n        class Unannotated(torch.nn.Module):\n            def __init__(self):\n                super(Unannotated, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 3\n\n            def forward(self):\n                return self.hello(1), self.hello(.5)\n\n        w = Unannotated()\n        with self.assertRaisesRegex(Exception, \"explicitly add type annotations to overloaded functions\"):\n            torch.jit.script(w)\n\n        class CompileOverloadError(torch.nn.Module):\n            def __init__(self):\n                super(CompileOverloadError, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (str) -> (int)\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 1\n\n            def forward(self):\n                return self.hello(\"hi\"), self.hello(.5)\n\n        w = CompileOverloadError()\n        with self.assertRaisesRegex(Exception, \"but instead found type \\'str\\'\"):\n            torch.jit.script(w)\n\n        # testing overload declared first, then non-overload\n        with self.assertRaisesRegex(Exception, \"Overloads are not useable when a module\"):\n            class W3(torch.nn.Module):\n                def __init__(self):\n                    super(W3, self).__init__()\n\n                @torch.jit._overload_method  # noqa: F811\n                def forward(self, x):  # noqa: F811\n                    # type: (int) -> int\n                    pass\n\n                @torch.jit._overload_method  # noqa: F811\n                def forward(self, x):  # noqa: F811\n                    # type: (Tensor) -> Tensor\n                    pass\n\n                def forward(self, x):  # noqa: F811\n                    return x + 5\n\n            a = W3()\n            b = torch.jit.script(a)\n\n            class W3(torch.nn.Module):\n                def __init__(self):\n                    super(W3, self).__init__()\n\n                def forward(self, x):  # noqa: F811\n                    return x + 5 + 10\n\n            a = W3()\n            b = torch.jit.script(a)\n\n        # testing non-overload declared first, then overload\n        class W2(torch.nn.Module):\n            def __init__(self):\n                super(W2, self).__init__()\n\n            def hello(self, x1, x2):\n                return x1 + x2\n\n            def forward(self, x):\n                return self.hello(x, x)\n\n        a = torch.jit.script(W2())\n        self.assertEqual(a(torch.tensor(1)), torch.tensor(2))\n\n        class W2(torch.nn.Module):\n            def __init__(self):\n                super(W2, self).__init__()\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                pass\n\n            @torch.jit._overload_method  # noqa: F811\n            def hello(self, x):  # noqa: F811\n                # type: (int) -> (int)\n                pass\n\n            def hello(self, x):  # noqa: F811\n                return x + 5 + 10\n\n            def forward(self, x):\n                return self.hello(1), self.hello(x)\n\n        with self.assertRaisesRegex(Exception, \"Overloads are not useable when a module\"):\n            a = torch.jit.script(W2())\n\n    def test_narrow_copy(self):\n        def foo(a):\n            return a.narrow_copy(0, 0, 5)\n\n        self.checkScript(foo, [torch.rand(10)])\n\n    def test_select_after_chunk(self):\n        def foo(x):\n            chunked = torch.chunk(x, 1)\n            foo = chunked[0]\n            foo.add_(5)\n            return x\n\n        self.checkScript(foo, [torch.rand(2, 3)])\n\n    def test_nn_LSTM_with_layers(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.rnn = nn.LSTM(2, 3, 2, dropout=0)\n\n            @torch.jit.script_method\n            def forward(self, x, lengths, h0, c0):\n                return self.rnn(x, (h0, c0))[0]\n\n        class Eager(torch.nn.Module):\n            def __init__(self):\n                super(Eager, self).__init__()\n                self.rnn = nn.LSTM(2, 3, 2, dropout=0)\n\n            def forward(self, x, lengths, h0, c0):\n                return self.rnn(x, (h0, c0))[0]\n\n        inputs = (torch.randn(1, 1, 2), torch.LongTensor([7]), torch.randn(2, 1, 3), torch.randn(2, 1, 3))\n        eager_out = self.runAndSaveRNG(lambda: Eager()(*inputs), ())[0]\n        script_out = self.runAndSaveRNG(lambda: M()(*inputs), ())[0]\n\n        self.assertEqual(eager_out, script_out)\n\n    def test_nn_LSTM(self):\n        input = torch.nn.utils.rnn.pack_sequence([torch.randn(5, 5)])\n\n        class S(torch.jit.ScriptModule):\n            def __init__(self):\n                super(S, self).__init__()\n                self.x = torch.nn.LSTM(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: PackedSequence) -> Tuple[PackedSequence, Tuple[torch.Tensor, torch.Tensor]]:\n                return self.x(input)\n\n        eager_out = self.runAndSaveRNG(lambda x: torch.nn.LSTM(5, 5)(x), (input,))[0]\n        script_out = self.runAndSaveRNG(lambda x: S()(x), (input,))[0]\n\n        self.assertEqual(eager_out, script_out)\n\n    def test_nn_GRU(self):\n        seq_input = torch.nn.utils.rnn.pack_sequence([torch.randn(5, 5)])\n        tensor_input = torch.randn(5, 5, 5)\n\n        class SeqLengthGRU(torch.jit.ScriptModule):\n            def __init__(self):\n                super(SeqLengthGRU, self).__init__()\n                self.x = torch.nn.GRU(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: PackedSequence) -> Tuple[PackedSequence, torch.Tensor]:\n                return self.x(input)\n\n        class TensorGRU(torch.jit.ScriptModule):\n            def __init__(self):\n                super(TensorGRU, self).__init__()\n                self.x = torch.nn.GRU(5, 5)\n\n            @torch.jit.script_method\n            def forward(self, input: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n                return self.x(input)\n\n        seq_eager_out = self.runAndSaveRNG(lambda x: torch.nn.GRU(5, 5)(x), (seq_input,))[0]\n        seq_script_out = self.runAndSaveRNG(lambda x: SeqLengthGRU()(x), (seq_input,))[0]\n        tensor_eager_out = self.runAndSaveRNG(lambda x: torch.nn.GRU(5, 5)(x), (tensor_input,))[0]\n        tensor_script_out = self.runAndSaveRNG(lambda x: TensorGRU()(x), (tensor_input,))[0]\n\n        self.assertEqual(seq_eager_out, seq_script_out)\n        self.assertEqual(tensor_eager_out, tensor_script_out)\n\n    def test_torchscript_memoryformat(self):\n        @torch.jit.script\n        def fn(x):\n            return x.contiguous(memory_format=torch.channels_last)\n        x = torch.randn(4, 3, 6, 6)\n        y = fn(x)\n        self.assertTrue(y.is_contiguous(memory_format=torch.channels_last))\n\n    def test_torchscript_multi_head_attn(self):\n        @torch.jit.script\n        def jit_multihead_attn_forward(query,                   # type: Tensor\n                                       key,                     # type: Tensor\n                                       value,                   # type: Tensor\n                                       embed_dim_to_check,      # type: int\n                                       num_heads,               # type: int\n                                       in_proj_weight,          # type: Tensor\n                                       in_proj_bias,            # type: Tensor\n                                       bias_k,                  # type: Optional[Tensor]\n                                       bias_v,                  # type: Optional[Tensor]\n                                       add_zero_attn,           # type: bool\n                                       dropout,                 # type: float\n                                       out_proj_weight,         # type: Tensor\n                                       out_proj_bias,           # type: Tensor\n                                       training=True,           # type: bool\n                                       key_padding_mask=None,   # type: Optional[Tensor]\n                                       need_weights=True,       # type: bool\n                                       attn_mask=None           # type: Optional[Tensor]\n                                       ):\n            # type: (...) -> Tuple[Tensor, Optional[Tensor]]\n            return torch.nn.functional.multi_head_attention_forward(query, key, value,\n                                                                    embed_dim_to_check, num_heads,\n                                                                    in_proj_weight, in_proj_bias,\n                                                                    bias_k, bias_v,\n                                                                    add_zero_attn, dropout,\n                                                                    out_proj_weight, out_proj_bias,\n                                                                    training, key_padding_mask,\n                                                                    need_weights, attn_mask)\n\n        src_l = 3\n        bsz = 5\n        embed_size = 8\n        nhead = 2\n        multi_head_attn = torch.nn.MultiheadAttention(embed_size, nhead)\n        query = torch.rand((src_l, bsz, embed_size))\n        key = torch.rand((src_l, bsz, embed_size))\n        value = torch.rand((src_l, bsz, embed_size))\n\n        mask = (torch.triu(torch.ones(src_l, src_l)) == 1).transpose(0, 1)\n        mask = mask.float().masked_fill(mask == 0, float('-inf')).masked_fill(mask == 1, float(0.0)).double()\n\n        jit_out = jit_multihead_attn_forward(query, key, value,\n                                             embed_size, nhead,\n                                             multi_head_attn.in_proj_weight,\n                                             multi_head_attn.in_proj_bias,\n                                             multi_head_attn.bias_k, multi_head_attn.bias_v,\n                                             multi_head_attn.add_zero_attn, multi_head_attn.dropout,\n                                             multi_head_attn.out_proj.weight,\n                                             multi_head_attn.out_proj.bias, attn_mask=mask)[0]\n\n        py_out = torch.nn.functional.multi_head_attention_forward(query, key, value,\n                                                                  embed_size, nhead,\n                                                                  multi_head_attn.in_proj_weight,\n                                                                  multi_head_attn.in_proj_bias,\n                                                                  multi_head_attn.bias_k,\n                                                                  multi_head_attn.bias_v,\n                                                                  multi_head_attn.add_zero_attn,\n                                                                  multi_head_attn.dropout,\n                                                                  multi_head_attn.out_proj.weight,\n                                                                  multi_head_attn.out_proj.bias,\n                                                                  attn_mask=mask)[0]\n        # print(\"rel. error: \")\n        # print(jit_out / py_out - 1)\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    def test_torchscript_multi_head_attn_fast_path(self):\n        src_l = 3\n        bsz = 5\n        embed_size = 8\n        nhead = 2\n        multi_head_attn = torch.nn.MultiheadAttention(embed_size, nhead, batch_first=True)\n        multi_head_attn = multi_head_attn.eval()\n\n        query = key = value = torch.rand((bsz, src_l, embed_size))\n\n        with torch.no_grad():\n            py_out = multi_head_attn(query, key, value)\n            mha = torch.jit.script(multi_head_attn)\n            jit_out = mha(query, key, value)\n        torch.testing.assert_close(jit_out, py_out)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_scriptmodule_multi_head_attn_cuda(self):\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, embed_dim, num_heads):\n                super(MyModule, self).__init__()\n                sample_q = torch.randn(3, 2, embed_dim)\n                sample_kv = torch.randn(3, 2, embed_dim)\n                attention = nn.MultiheadAttention(embed_dim, num_heads)\n                attention.eval()\n\n                self.mod = torch.jit.trace(attention,\n                                           (sample_q, sample_kv, sample_kv))\n\n            @torch.jit.script_method\n            def forward(self, q, k, v):\n                return self.mod(q, k, v)\n\n        embed_dim = 8\n        num_heads = 2\n        sl = 3\n        bs = 2\n        model = MyModule(embed_dim, num_heads).cuda()\n        q = torch.randn(sl, bs, embed_dim, device=\"cuda\")\n        kv = torch.randn(sl, bs, embed_dim, device=\"cuda\")\n\n        jit_out = model(q, kv, kv)[0]\n        py_out = torch.nn.functional.multi_head_attention_forward(q, kv, kv,\n                                                                  embed_dim, num_heads,\n                                                                  model.mod.in_proj_weight,\n                                                                  model.mod.in_proj_bias,\n                                                                  None, None, None, 0.0,\n                                                                  model.mod.out_proj.weight,\n                                                                  model.mod.out_proj.bias)[0]\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_scriptmodule_transformer_cuda(self):\n\n        class MyModule(torch.jit.ScriptModule):\n            def __init__(self, transformer, sample_q, sample_kv):\n                super(MyModule, self).__init__()\n                transformer.eval()\n\n                self.mod = torch.jit.trace(transformer,\n                                           (sample_q, sample_kv))\n\n            @torch.jit.script_method\n            def forward(self, q, k):\n                return self.mod(q, k)\n\n        d_model = 8\n        nhead = 2\n        num_encoder_layers = 2\n        num_decoder_layers = 2\n        dim_feedforward = 16\n        bsz = 2\n        seq_length = 5\n        tgt_length = 3\n\n        src = torch.randn(seq_length, bsz, d_model)\n        tgt = torch.randn(tgt_length, bsz, d_model)\n        transformer = nn.Transformer(d_model, nhead, num_encoder_layers,\n                                     num_decoder_layers, dim_feedforward, dropout=0.0)\n        model = MyModule(transformer, tgt, src)\n\n        src = torch.randn(seq_length, bsz, d_model)\n        tgt = torch.randn(tgt_length, bsz, d_model)\n        jit_out = model(tgt, src)\n        py_out = transformer(tgt, src)\n\n        # print(jit_out/py_out-1)\n        # print(torch.allclose(jit_out, py_out, atol=5e-4, rtol=1e-4))\n        self.assertEqual(jit_out, py_out, atol=5e-4, rtol=1e-4)\n\n    def test_list_python_op(self):\n        def python_list_op(lst):\n            # type: (List[Tensor]) -> Tensor\n            return lst[0]\n\n        def fn(lst):\n            # type: (List[Tensor]) -> Tensor\n            return python_list_op(lst)\n\n        self.checkScript(fn, ([torch.ones(2) + 2, torch.ones(2)],))\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_weak_cuda(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.lstm = torch.nn.LSTM(5, 5)\n                self.lstm.cuda()\n\n            @torch.jit.script_method\n            def forward(self, x):\n                return self.lstm(x)\n\n        m = M()\n        m.cuda()\n        out = m(torch.ones(5, 5, 5).cuda())\n        self.assertTrue(out[0].is_cuda)\n\n    def test_ignore_decorator(self):\n        with warnings.catch_warnings(record=True) as warns:\n            class M(torch.jit.ScriptModule):\n                def __init__(self):\n                    super(M, self).__init__()\n                    tensor = torch.zeros(1, requires_grad=False)\n                    self.register_buffer('some_state', torch.nn.Parameter(tensor))\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    self.ignored_code(x)\n                    return x\n\n                @torch.jit.ignore(drop_on_export=True)\n                def ignored_code(self, x):\n                    self.some_state = torch.tensor((100,))\n\n        FileCheck().check(\"TorchScript will now drop the function\").run(str(warns[0]))\n\n        # Assert ignored code is run\n        m = M()\n\n        m2 = self.getExportImportCopy(m)\n        pp = str(m2.forward.code)\n        self.assertNotIn('ignored_code', pp)\n\n        with self.assertRaisesRegex(torch.jit.Error, \"annotated to be ignored and cannot be run\"):\n            m2.forward(torch.ones(1))\n\n    def test_ignored_as_value(self):\n        class Model(nn.Module):\n            def __init__(self):\n                super(Model, self).__init__()\n\n            @torch.jit.unused\n            def tuple_ignored(self, x):\n                # type: (Tensor) -> Tuple[Tensor, Tensor]\n                return x, x\n\n            @torch.jit.unused\n            def single_val_ignored(self, x, y):\n                # type: (Tensor, Tensor) -> Tensor\n                return x\n\n            def forward(self, x, use_ignore_path):\n                # type: (Tensor, bool) -> Tuple[Tensor, Tensor]\n                if 1 == 2:\n                    return self.tuple_ignored(x)\n                if use_ignore_path:\n                    return self.single_val_ignored(x, x), self.single_val_ignored(x, x)\n                return x, x\n\n        original = Model()\n        scripted = torch.jit.script(original)\n        self.assertEqual(scripted(torch.tensor(.5), False), (torch.tensor(.5), torch.tensor(.5)))\n\n        buffer = io.BytesIO()\n        torch.jit.save(scripted, buffer)\n        buffer.seek(0)\n        loaded = torch.jit.load(buffer)\n\n        with self.assertRaisesRegex(torch.jit.Error, \"annotated to be ignored and cannot be run\"):\n            loaded(torch.tensor(.5), True)\n\n    def test_module_error(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, foo):\n                return foo\n\n        with self.assertRaisesRegex(RuntimeError, \"cannot be compiled since it inherits from nn.Module\"):\n            torch.jit.script(MyModule)\n\n    def test_view_write(self):\n        def fn(x, y):\n            l = []\n            l.append(x)\n            x_view = l[0]\n            a = x + x\n            x_view.add_(y)\n            b = x + x\n            return a == b\n        self.checkScript(fn, (torch.rand(2, 3), torch.rand(2, 3)))\n\n    def test_module_attrs(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self, table):\n                super(M, self).__init__()\n                self.table = torch.jit.Attribute(table, Dict[str, torch.Tensor])\n                self.x = torch.nn.Parameter(torch.tensor([100.0]))\n\n            @torch.jit.script_method\n            def forward(self, key):\n                # type: (str) -> Tensor\n                return self.table[key] + self.x\n\n        with torch._jit_internal._disable_emit_hooks():\n            # TODO: re-enable module hook when Python printing of attributes is\n            # supported\n            m = M({char : torch.ones(1) + ord(char) - ord(\"a\") for char in \"abcdefg\"})\n            self.assertEqual(m(\"c\"), torch.tensor([103.]))\n\n    def test_module_none_attrs(self):\n        class MyMod(torch.jit.ScriptModule):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.optional_value = None\n\n            @torch.jit.script_method\n            def forward(self):\n                return self.optional_value\n\n        graph = MyMod().forward.graph\n        FileCheck().check(\"prim::GetAttr\").run(graph)\n        self.run_pass('peephole', graph)\n        FileCheck().check_not(\"prim::GetAttr\").run(graph)\n\n    def test_tensor_import_export(self):\n        @torch.jit.script\n        def foo(x):\n            a = torch.tensor(1)\n            b = torch.tensor([1, 2])\n            c = [a, b]\n            return c\n\n        self.run_pass('constant_propagation', foo.graph)\n        m = self.createFunctionFromGraph(foo.graph)\n        self.getExportImportCopy(m)\n\n    def get_pickle_values(self):\n        return (('dict', {\"I\": \"am\", \"a test\": \"test\"}, Dict[str, str]),\n                ('float', 2.3, float),\n                ('int', 99, int),\n                ('bool', False, bool),\n                ('tuple', (1, 2, 3, 4), Tuple[int, int, int, int]),\n                ('list', [(1, 2), (3, 4)], List[Tuple[int, int]]),\n                ('tensor', torch.randn(2, 2), torch.Tensor),\n                ('int_list', [1, 2, 3, 4], List[int]),\n                ('tensor_list', [torch.ones(2, 2) + i for i in range(4)], List[torch.Tensor]),\n                ('bool_list', [True, True, False, True], List[bool]),\n                ('float_list', [1., 2., 3., 4.], List[float]),\n                ('str_list', ['hello', 'bye'], List[str]),\n                ('none', None, Optional[int]),\n                ('a_device', torch.device('cpu'), torch.device),\n                ('another_device', torch.device('cuda:1'), torch.device))\n\n    def test_attribute_serialization(self):\n        tester = self\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                for name, value, the_type in tester.get_pickle_values():\n                    setattr(self, name, torch.jit.Attribute(value, the_type))\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.dict, self.float, self.int, self.bool, self.tuple,\n                        self.list, self.int_list, self.tensor_list, self.bool_list,\n                        self.float_list, self.str_list, self.none)\n\n        m = M()\n        imported_m = self.getExportImportCopy(m)\n        self.assertEqual(m(), imported_m())\n\n    def test_string_len(self):\n        def fn(x):\n            # type: (str) -> int\n            return len(x)\n\n        self.checkScript(fn, (\"\",))\n        self.checkScript(fn, (\"h\",))\n        self.checkScript(fn, (\"hello\",))\n\n    def test_multiline_optional_future_refinement(self):\n        @torch.jit.script\n        def fun() -> int:\n            future: Optional[\n                torch.jit.Future[Tuple[torch.Tensor]]\n            ] = None\n\n            return 1\n        self.assertEqual(fun(), 1)\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    def test_attribute_unpickling(self):\n        tensor = torch.randn(2, 2)\n        tester = self\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                for name, value, the_type in tester.get_pickle_values():\n                    setattr(self, \"_\" + name, torch.jit.Attribute(value, the_type))\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self._dict, self._float, self._int, self._bool, self._tuple,\n                        self._list, self._int_list, self._tensor_list, self._bool_list,\n                        self._float_list, self._str_list, self._none)\n\n        with TemporaryFileName() as fname:\n            M().save(fname)\n            loaded = torch.jit.load(fname)\n\n            def is_tensor_value(item):\n                if isinstance(item, torch.Tensor):\n                    return True\n                if isinstance(item, list):\n                    return is_tensor_value(item[0])\n                return False\n            for name, value, the_type in self.get_pickle_values():\n                if is_tensor_value(value):\n                    continue\n                self.assertEqual(value, getattr(loaded, \"_\" + name))\n\n    @unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, \"NYI: TemporaryFileName support for Windows or Sandcastle\")\n    @unittest.skipIf(not BUILD_WITH_CAFFE2, \"PyTorch is build without Caffe2 support\")\n    def test_old_models_bc(self):\n        model = {\n            'archive/version': b'1',\n            'archive/code/archive.py':\n                b'''\n                op_version_set = 0\n                def forward(self,\n                    _0: Tensor) -> Tensor:\n                  _1 = torch.zeros([10], dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  result = torch.to(torch.fill_(_1, 5), dtype=6, layout=0, device=torch.device(\"cpu\"),\n                                    non_blocking=False, copy=False)\n                  result2 = torch.rand([10], dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  result3 = torch.rand_like(result2, dtype=6, layout=0, device=torch.device(\"cpu\"))\n                  _2 = torch.add(torch.add(result, result2, alpha=1), result3, alpha=1)\n                  return _2\n                ''',\n            'archive/attributes.pkl': b'\\x80\\x02](e.',\n            'archive/libs.py': b'op_version_set = 0\\n',\n            'archive/model.json':\n                b'''\n                {\n                   \"protoVersion\":\"2\",\n                   \"mainModule\":{\n                      \"torchscriptArena\":{\n                         \"key\":\"code/archive.py\"\n                      },\n                      \"name\":\"archive\",\n                      \"optimize\":true\n                   },\n                   \"producerName\":\"pytorch\",\n                   \"producerVersion\":\"1.0\",\n                   \"libs\":{\n                      \"torchscriptArena\":{\n                         \"key\":\"libs.py\"\n                      }\n                   }\n                }'''}\n        with TemporaryFileName() as fname:\n            archive_name = os.path.basename(os.path.normpath(fname))\n            with zipfile.ZipFile(fname, 'w') as archive:\n                for k, v in model.items():\n                    archive.writestr(k, v)\n\n            with open(fname, \"rb\") as f:\n                fn = torch.jit.load(f)\n\n        x = torch.zeros(10)\n        fn(x)\n\n    def test_submodule_attribute_serialization(self):\n        class S(torch.jit.ScriptModule):\n            def __init__(self, list_data):\n                super(S, self).__init__()\n                self.table = torch.jit.Attribute({\"I\": \"am\", \"a test\": \"test\"}, Dict[str, str])\n                self.list = torch.jit.Attribute(list_data, List[Tuple[int, int]])\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.table, self.list)\n\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.table = torch.jit.Attribute({\"this\": \"is\", \"a different\": \"dict\"}, Dict[str, str])\n                self.tensor = torch.jit.Attribute(torch.randn(2, 2), torch.Tensor)\n                self.s1 = S([(1, 2)])\n                self.s2 = S([(4, 5)])\n\n            @torch.jit.script_method\n            def forward(self):\n                return (self.table, self.tensor, self.s1.table, self.s2.list, self.s1.list)\n\n        m = M()\n        imported_m = self.getExportImportCopy(m)\n        self.assertEqual(m(), imported_m())\n\n    def test_serialization_big_ints(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.int32_max = torch.jit.Attribute(2**31 - 1, int)\n                self.int32_min = torch.jit.Attribute(-2**31, int)\n                self.uint32_max = torch.jit.Attribute(2**32, int)\n\n                self.int64_max = torch.jit.Attribute(2**63 - 1, int)\n                self.int64_min = torch.jit.Attribute(-2**63, int)\n\n                self.tensor = torch.nn.Parameter(torch.ones(2, 2))\n\n            @torch.jit.script_method\n            def forward(self, x):\n                # type: (int) -> (int)\n                return x + (self.int32_max + self.int32_min) + (self.int64_max + self.int64_min)\n\n        m = M()\n        imported = self.getExportImportCopy(m)\n        self.assertEqual(m(10), imported(10))\n\n        self.assertEqual(m.int32_max, imported.int32_max)\n        self.assertEqual(m.int32_min, imported.int32_min)\n        self.assertEqual(m.uint32_max, imported.uint32_max)\n        self.assertEqual(m.int64_max, imported.int64_max)\n        self.assertEqual(m.int64_min, imported.int64_min)\n\n    def test_script_scope(self):\n        scripted = torch.jit.script(torch.nn.functional.triplet_margin_loss)\n\n    @unittest.skipIf(IS_WINDOWS, \"NYI: TemporaryFileName on Windows\")\n    def test_serialization_sharing(self):\n        class M(torch.jit.ScriptModule):\n            def __init__(self):\n                super(M, self).__init__()\n                self.list = torch.jit.Attribute([], List[str])\n\n            @torch.jit.script_method\n            def forward(self, key):\n                # type: (str) -> List[str]\n                self.list.append(key)\n                self.list.append(key)\n                self.list.append(key)\n                return self.list\n\n        # the text of the string should only appear once in the pickling\n        m = M()\n        s1 = \"a long string\"\n        s2 = \"a different, even longer string\"\n        self.assertEqual(m(s1), [s1] * 3)\n        self.assertEqual(m(s2), [s1] * 3 + [s2] * 3)\n        with TemporaryFileName() as fname:\n            m.save(fname)\n            archive_name = os.path.basename(os.path.normpath(fname))\n            archive = zipfile.ZipFile(fname, 'r')\n            pickled_data = archive.read(os.path.join(archive_name, 'data.pkl'))\n\n            out = io.StringIO()\n            pickletools.dis(pickled_data, out=out)\n            disassembled = out.getvalue()\n\n            FileCheck().check_count(s1, 1, exactly=True) \\\n                .check_count(\"BINGET\", 2, exactly=True) \\\n                .check_count(s2, 1, exactly=True) \\\n                .check_count(\"BINGET\", 2, exactly=True).run(out.getvalue())\n\n    def test_sys_stdout_override(self):\n        @torch.jit.script\n        def foo():\n            print('foo')\n\n        class Redirect(object):\n            def __init__(self):\n                self.s = ''\n\n            def write(self, s):\n                self.s += s\n\n        old_stdout = sys.stdout\n        redirect = Redirect()\n        try:\n            sys.stdout = redirect\n            foo()\n        finally:\n            sys.stdout = old_stdout\n\n        FileCheck().check('foo').run(redirect.s)\n\n    def test_dtype_attr(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super(Foo, self).__init__()\n                self.dtype = torch.zeros([]).dtype\n\n            def forward(self):\n                return torch.zeros(3, 4, dtype=self.dtype)\n\n        f = Foo()\n        torch.jit.script(f)\n\n\n    def test_named_buffers_are_iterable(self):\n        class MyMod(torch.nn.Module):\n            def __init__(self):\n                super(MyMod, self).__init__()\n                self.mod = (torch.nn.ReLU())\n                self.mod2 = (torch.nn.ReLU())\n                self.mod3 = torch.nn.Sequential(torch.nn.Sequential(torch.nn.ReLU()))\n                self.register_buffer('x', torch.zeros(3))\n                self.register_buffer('y', torch.zeros(3))\n                self.z = torch.zeros(3)\n\n            def bleh(self):\n                return self.z + 4\n\n            @torch.jit.export\n            def method(self):\n                names = [\"\"]\n                vals = []\n                for name, buffer in self.named_buffers():\n                    names.append(name)\n                    vals.append(buffer + 2)\n\n                return names, vals\n\n            def forward(self, x):\n                return x\n\n        model = MyMod()\n        x = torch.jit.script(model)\n        z = self.getExportImportCopy(x)\n\n        self.assertEqual(z.method(), x.method())\n        self.assertEqual(z.method(), model.method())\n        self.assertEqual(x.method(), model.method())\n        names = x.method()\n        for name in names:\n            self.assertNotEqual('z', name)\n\n\n    def test_static_if_prop(self):\n        class MaybeHasAttr(torch.nn.Module):\n            def __init__(self, add_attr):\n                super(MaybeHasAttr, self).__init__()\n                if add_attr:\n                    self.maybe_attr = 1\n\n            def forward(self):\n                if hasattr(self, \"maybe_attr\") and True:\n                    return self.maybe_attr\n                else:\n                    return 0\n\n        class MaybeHasAttr2(torch.nn.Module):\n            def __init__(self, add_attr):\n                super(MaybeHasAttr2, self).__init__()\n                if add_attr:\n                    self.maybe_attr = 1\n\n            def forward(self):\n                if not hasattr(self, \"maybe_attr\") or False:\n                    return 0\n                else:\n                    return self.maybe_attr\n\n        torch.jit.script(MaybeHasAttr(True))\n        torch.jit.script(MaybeHasAttr(False))\n        torch.jit.script(MaybeHasAttr2(True))\n        torch.jit.script(MaybeHasAttr2(False))\n\n        class MyMod(torch.nn.Module):\n            def forward(self):\n                if hasattr(self, \"foo\"):\n                    return 1\n                else:\n                    return 0\n\n            @torch.jit.export\n            def fee(self):\n                return 1\n\n        self.checkModule(MyMod(), ())\n\n        class HasAttrMod(torch.nn.Module):\n            __constants__ = [\"fee\"]\n\n            def __init__(self):\n                super().__init__()\n                self.fee = 3\n\n            def forward(self):\n                a = hasattr(self, \"fee\")\n                b = hasattr(self, \"foo\")\n                c = hasattr(self, \"hi\")\n                d = hasattr(self, \"nonexistant\")\n                return (a, b, c, d)\n\n            def foo(self):\n                return 1\n\n            @torch.jit._overload_method\n            def hi(self, x: Tensor): ...  # noqa: E704\n\n            def hi(self, x):  # noqa: F811\n                return 2\n\n        self.checkModule(HasAttrMod(), ())\n\n        @torch.jit.script\n        class FooTest(object):\n            def __init__(self):\n                self.x = 1\n\n            def foo(self, y):\n                return self.x + y\n\n        def foo():\n            a = FooTest()\n            val1 = hasattr(a, \"foo\"), hasattr(a, \"x\"), hasattr(a, \"bla\")\n            val2 = hasattr(FooTest, \"foo\"), hasattr(FooTest, \"a\")\n            return val1, val2\n\n        self.assertEqual(foo(), torch.jit.script(foo)())\n\n    def _test_pickle_checkpoint(self, device):\n        with TemporaryFileName() as fname:\n            class M(torch.jit.ScriptModule):\n                __constants__ = ['fname']\n\n                def __init__(self, tensor):\n                    super(M, self).__init__()\n                    self.fname = fname\n                    self.tensor = torch.nn.Parameter(tensor)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    y = self.tensor + x\n                    torch.save(y, self.fname)\n                    return y\n\n            param = torch.randn(2, 2).to(device)\n            input = torch.randn(2, 2).to(device)\n            m = M(param)\n            m(input)\n            with open(fname, \"rb\") as handle:\n                loaded_tensor = torch.load(fname)\n                self.assertEqual(loaded_tensor, input + param)\n\n    def _test_pickle_checkpoint_views(self, device):\n        with TemporaryFileName() as fname:\n            class M(torch.jit.ScriptModule):\n                __constants__ = ['fname']\n\n                def __init__(self, tensor):\n                    super(M, self).__init__()\n                    self.fname = fname\n                    self.tensor = torch.nn.Parameter(tensor)\n\n                @torch.jit.script_method\n                def forward(self, x):\n                    y = self.tensor + x\n                    y_view = y.view(4)\n                    torch.save((y, y_view, y), self.fname)\n                    return y\n\n            param = torch.randn(2, 2).to(device)\n            input = torch.randn(2, 2).to(device)\n            m = M(param)\n            m(input)\n            with open(fname, \"rb\") as handle:\n                loaded_y, loaded_y_view, loaded_y_2 = torch.load(fname)\n                self.assertEqual(loaded_y, input + param)\n                with torch.no_grad():\n                    loaded_y_view[1] += 20\n                    # assert that loaded_y changed as well\n                    self.assertEqual(loaded_y.view(4), loaded_y_view)\n                    self.assertEqual(loaded_y_2.view(4), loaded_y_view)\n\n    @unittest.skipIf(not RUN_CUDA, \"no CUDA\")\n    def test_pickle_checkpoint_cuda(self):\n        self._test_pickle_checkpoint('cuda')\n        self._test_pickle_checkpoint_views('cuda')\n\n    def test_pickle_checkpoint(self):\n        self._test_pickle_checkpoint('cpu')\n        self._test_pickle_checkpoint_views('cpu')\n\n    def test_pickle_checkpoint_tup(self):\n        @torch.jit.script\n        def foo(fname):\n            # type: (str) -> None\n            torch.save((3, 4), fname)\n        with TemporaryFileName() as name:\n            foo(name)\n            self.assertEqual(torch.load(name), (3, 4))\n\n    def test_string_list(self):\n        def fn(string):\n            # type: (str) -> List[str]\n            return list(string)\n\n        self.checkScript(fn, (\"abcdefgh\",))\n\n    def test_unicode_comments(self):\n        @torch.jit.script\n        def test(self, a):\n            # \ud83e\udd37\ud83e\udd37\ud83e\udd37\ud83e\udd37\n            return torch.nn.functional.relu(a)\n\n    def test_get_set_state_with_tensors(self):\n        class M(torch.nn.Module):\n            def __init__(self):\n                super(M, self).__init__()\n                self.tensor = torch.randn(2, 2)\n\n            @torch.jit.export\n            def __getstate__(self):\n                return (self.tensor, self.training)\n\n            @torch.jit.export\n            def __setstate__(self, state):\n                self.tensor = state[0]\n                self.training = state[1]\n\n            def forward(self, x):\n                return x + self.tensor\n\n        with TemporaryFileName() as fname:\n            m = torch.jit.script(M())\n            m.save(fname)\n            loaded = torch.jit.load(fname)\n            self.assertEqual(loaded.tensor, m.tensor)\n\n    def test_in_for_and_comp_expr(self):\n        def fn(d):\n            # type: (Dict[str, int]) -> List[int]\n            out = [1]\n            for i in range(d[\"hi\"] if \"hi\" in d else 6):\n                out.append(i)\n            return out\n\n        self.checkScript(fn, ({'hi': 2, 'bye': 3},))\n        self.checkScript(fn, ({'bye': 3},))\n\n    def test_for_else(self):\n        def fn():\n            c = 0\n            for i in range(4):\n                c += 10\n            else:\n                print(\"In else block of for...else\")\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, \"else branches of for loops aren't supported\"):\n            torch.jit.script(fn)\n\n    def test_split(self):\n        def split_two(tensor):\n            a, b, c = torch.split(tensor, 2, dim=1)\n            return a, b, c\n        x = torch.randn(3, 6)\n        y = torch.randn(3, 6)\n        self.checkScript(split_two, [(x + y)])\n\n    def test_conv_error(self):\n        @torch.jit.script\n        def fn(x, y):\n            return F.conv2d(x, y)\n\n        try:\n            fn(torch.ones(2, 2), torch.ones(4, 4))\n        except RuntimeError as e:\n            self.assertFalse('frame' in str(e))\n\n    def test_python_op_name(self):\n        import random\n\n        with self.assertRaisesRegex(RuntimeError, \"randint\"):\n            @torch.jit.script\n            def fn():\n                return random.randint()\n\n    def test_dir(self):\n        class M(torch.jit.ScriptModule):\n            def forward(self, t):\n                return t\n\n        self.assertTrue('forward' in dir(M()))\n\n    def test_kwarg_expansion_error(self):\n        @torch.jit.ignore\n        def something_else(h, i):\n            pass\n\n        def fn(x):\n            something_else(**x)\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, \"keyword-arg expansion is not supported\"):\n            torch.jit.script(fn)\n\n    def test_kwargs_error_msg(self):\n        def other(**kwargs):\n            print(kwargs)\n\n        def fn():\n            return other()\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, 'variable number'):\n            torch.jit.script(fn)\n\n        def another_other(*args):\n            print(args)\n\n        def another_fn():\n            return another_other()\n\n        with self.assertRaisesRegex(torch.jit.frontend.NotSupportedError, 'variable number'):\n            torch.jit.script(another_fn)\n\n    def test_inferred_error_msg(self):\n        \"\"\"\n        Test that when we get a type mismatch on a function where we inferred\n        the type to be tensor, a good error message is given.\n        \"\"\"\n        @torch.jit.script\n        def foo(a):\n            return a\n\n        with self.assertRaisesRegex(RuntimeError, (r\"Expected a value of type \\'Tensor \\(inferred\\)\\'\"\n                                                   r\"[\\S\\s]*Inferred \\'a\\' to be of type \\'Tensor\\'\")):\n            foo(\"1\")\n\n    def test_type_comments_in_body(self):\n        @torch.jit.script\n        def foo(a,  # type: int\n                b,  # type: int\n                ):\n            # type: (...) -> int\n            # type: int\n            return a + b\n\n        class M(torch.nn.Module):\n            def __init__(self,\n                         a,  # type: int\n                         b   # type: int\n                         ):\n                # type: (...) -> None\n                super(M, self).__init__()\n                self.a = a  # type: int\n                self.b = b  # type: int\n\n        torch.jit.script(M(2, 3))\n\n    def test_input_keyword_in_schema(self):\n        def f(x):\n            return torch.ceil(input=x)\n\n        inp = torch.randn(10)\n        self.checkScript(f, (inp, ))\n\n    def test_module_method_reassignment(self):\n        class Foo(torch.nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            def _forward(self, x):\n                return x\n\n            forward = _forward\n\n        sm = torch.jit.script(Foo())\n        input = torch.ones(2, 2)\n        self.assertEqual(input, sm(input))\n\n    # Tests the case where a torch.Tensor subclass (like Parameter) is used as\n    # input.\n    def test_script_module_tensor_subclass_argument(self):\n        @torch.jit.script\n        def parameter_script(x: torch.nn.Parameter):\n            return x\n\n        input = torch.ones(2, 2)\n        self.assertEqual(input, parameter_script(input))\n\n    def test_save_load_attr_error(self):\n        class Inner(nn.Module):\n            def __init__(self):\n                super().__init__()\n\n            def forward(self, x):\n                return x\n\n        class Wrapper(nn.Module):\n            def __init__(self, inner):\n                super().__init__()\n                self.inner = inner\n\n            def forward(self, x):\n                # this attribute doesn't exist on `Inner`\n                return self.inner.b(x)\n\n        inner_module = torch.jit.script(Inner())\n        inner_module = self.getExportImportCopy(inner_module)\n        wrapped = Wrapper(inner_module)\n        # This should properly complain that `self.inner` doesn't have the attribute `b`\n        with self.assertRaisesRegex(RuntimeError, 'has no attribute'):\n            torch.jit.script(wrapped)\n\n    def test_rescripting_loaded_modules(self):\n        class InnerSubmod(nn.Module):\n            __constants__ = ['my_constant']\n\n            def __init__(self):\n                super().__init__()\n                self.register_buffer(\"foo\", torch.ones(1))\n                self.register_parameter(\"bar\", torch.nn.Parameter(torch.ones(1)))\n                self.baz = torch.ones(1)\n                self.my_constant = 1\n\n            def forward(self, x):\n                return x + x\n\n        class Inner(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.submod = InnerSubmod()\n\n            def forward(self, x):\n                return self.submod(x)\n\n        class Wrapper(nn.Module):\n            def __init__(self, inner):\n                super().__init__()\n                self.inner = inner\n\n            def forward(self, x):\n                # access inner elements\n                ret = self.inner.submod(x) + self.inner.submod.foo + self.inner.submod.bar + self.inner.submod.baz\n                ret = ret + self.inner.submod.my_constant\n                return ret\n\n        inner_module = torch.jit.script(Inner())\n        wrapped = Wrapper(inner_module)\n        self.checkModule(wrapped, torch.ones(1))\n\n        inner_module_loaded = self.getExportImportCopy(inner_module)\n        wrapped_loaded = Wrapper(inner_module_loaded)\n        self.assertEqual(wrapped(torch.ones(1)), wrapped_loaded(torch.ones(1)))\n\n    def test_interpret_graph(self):\n        def fn(x):\n            return x.unfold(0, 1, 1)\n\n        graph_str = \"\"\"\n        graph(%a : Tensor, %b : Tensor):\n          %c : Tensor = aten::mul(%a, %b)\n          return (%c)\n        \"\"\"\n        graph = parse_ir(graph_str)\n        a = torch.rand(10)\n        b = torch.rand(10)\n        test = torch._C._jit_interpret_graph(graph, (a, b))\n        ref = a * b\n        self.assertEqual(test, ref)\n\n    def test_signed_float_zero(self):\n\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x):\n                return torch.div(x, -0.)\n\n        inp = torch.ones(1)\n        self.checkModule(MyModule(), inp)\n\n    def test_index_with_tuple(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x):\n                return x[(1,)]\n\n        self.checkModule(MyModule(), (torch.ones(2, 3),))\n\n    def test_context_manager(self):\n        class MyModule(torch.nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n\n            def forward(self, x, y):\n                p = x + y\n                q = p + 2.0\n                return q\n\n        x = torch.randn(3, 2, dtype=torch.float)\n        y = torch.randn(3, 2, dtype=torch.float)\n        for fuser_name in ['fuser0', 'fuser1', 'none']:\n            with torch.jit.fuser(fuser_name):\n                self.checkModule(MyModule(), (x, y))\n\n# known to be failing in tracer\nEXCLUDE_TRACED = {\n    # The following fail due to #12024.\n    # A prim::ListConstruct is involved and the indices get traced as TensorType,\n    # which always require_grad. This causes a crash in autodiff.\n    'test___getitem___adv_index',\n    'test___getitem___adv_index_beg',\n    'test___getitem___adv_index_comb',\n    'test___getitem___adv_index_dup',\n    'test___getitem___adv_index_sub',\n    'test___getitem___adv_index_sub_2',\n    'test___getitem___adv_index_sub_3',\n    'test___getitem___adv_index_var',\n\n    # jit doesn't support sparse tensors.\n    'test_to_sparse',\n    'test_to_sparse_dim',\n}\n\nEXCLUDE_TYPE_CHECK = {\n    # slogdet tests use itemgetter to select its only differentiable output,\n    # but this happens outside of the graph we handle, so there are fewer\n    # reference outputs than graph outputs.\n    'test_slogdet_1x1_neg_det',\n    'test_slogdet_1x1_pos_det',\n    'test_slogdet_distinct_singular_values',\n    'test_slogdet_neg_det',\n    'test_slogdet_pos_det',\n    'test_slogdet_symmetric',\n    'test_slogdet_symmetric_pd',\n    'test_slogdet_batched_1x1_neg_det',\n    'test_slogdet_batched_pos_det',\n    'test_slogdet_batched_symmetric',\n    'test_slogdet_batched_symmetric_pd',\n    'test_slogdet_batched_distinct_singular_values'\n}\n\n# chunk returns a list in scripting and we don't unpack the list,\n# Thus it won't be replaced by ConstantChunk and run AD.\n# It's explicitly checked in test_chunk_constant_script_ad\n# Similary for split, it's replaced by split_with_sizes in tracing,\n# but we don't have AD formula for aten::split(Tensor, int[], int),\n# an op registered in JIT so AD is not triggered in scripting.\nEXCLUDE_SCRIPT_AD_CHECK = {\n    'test_chunk',\n    'test_chunk_dim',\n    'test_chunk_dim_neg0',\n    'test_split_size_list',\n    'test_split_size_list_dim',\n    'test_split_size_list_dim_neg0',\n    'test_tensor_indices_sections',\n    'test_tensor_indices_sections_dim',\n    'test_tensor_indices_sections_dim_neg0',\n    'test_tensor_split_sections',\n    'test_tensor_split_sections_dim',\n    'test_tensor_split_sections_dim_neg0'\n}\n\nEXCLUDE_PYTHON_PRINT = {\n    # no support for BroadcastingList in python printer\n    'test_nn_max_unpool1d',\n    'test_nn_max_unpool2d',\n    'test_nn_max_unpool3d',\n    'test_nn_max_pool1d',\n    'test_nn_max_pool2d',\n    'test_nn_max_pool3d',\n    'test_nn_max_pool1d_with_indices',\n}\n\nEXCLUDE_ALIAS = {\n    # aliases, which may appear in method_tests but are tested elsewhere\n    'true_divide',\n\n    # Disable tests for lu from common_methods_invocations.py\n    # TODO(@nikitaved) Enable jit tests once autograd.Function does support scripting\n    'lu'\n}\n\n\nclass TestJitGeneratedModule(JitTestCase):\n    pass\n\n\nclass TestJitGeneratedFunctional(JitTestCase):\n    pass\n\n# UBSAN per-function exclusions don't seem to work with OpenMP pragmas,\n# and we have to disable the failing tests here instead.\nUBSAN_DISABLED_TESTS = [\n    \"test___rdiv___constant\",\n    \"test___rdiv___scalar_constant\",\n    \"test_addcdiv\",\n    \"test_addcdiv_broadcast_all\",\n    \"test_addcdiv_broadcast_rhs\",\n    \"test_addcdiv_scalar\",\n    \"test_addcdiv_scalar_broadcast_lhs\",\n    \"test_addcdiv_scalar_broadcast_rhs\",\n    \"test_addcdiv_scalar_scale\",\n    \"test_addcdiv_scalar_scale_broadcast_lhs\",\n    \"test_addcdiv_scalar_scale_broadcast_rhs\",\n    \"test_addcdiv_scale\",\n    \"test_addcdiv_scale_broadcast_all\",\n    \"test_addcdiv_scale_broadcast_rhs\",\n    \"test_add_broadcast_all\",\n    \"test_add_broadcast_lhs\",\n    \"test_add_broadcast_rhs\",\n    \"test_add_constant\",\n    \"test_add_scalar\",\n    \"test_add_scalar_broadcast_lhs\",\n    \"test_add_scalar_broadcast_rhs\",\n    \"test_div\",\n    \"test_div_broadcast_all\",\n    \"test_div_broadcast_lhs\",\n    \"test_div_broadcast_rhs\",\n    \"test_div_scalar\",\n    \"test_div_scalar_broadcast_lhs\",\n    \"test_div_scalar_broadcast_rhs\",\n    \"test_rsqrt\",\n    \"test_rsqrt_scalar\",\n    \"test_add\",\n    \"test_reciprocal\",\n    \"test_reciprocal_scalar\",\n]\n\nL = 20\nM = 10\nS = 5\n\ndef add_nn_module_test(*args, **kwargs):\n    no_grad = False if 'no_grad' not in kwargs else kwargs['no_grad']\n\n    if 'desc' in kwargs and 'eval' in kwargs['desc']:\n        # eval() is not supported, so skip these tests\n        return\n\n    test_name = get_nn_mod_test_name(**kwargs)\n\n    @suppress_warnings\n    def do_test(self):\n        if test_name in EXCLUDE_SCRIPT_MODULES:\n            return\n        if not kwargs.get('check_jit', True):\n            raise unittest.SkipTest('module test skipped on JIT')\n\n        module_name = get_nn_module_name_from_kwargs(**kwargs)\n\n        if 'constructor' in kwargs:\n            nn_module = kwargs['constructor']\n        else:\n            nn_module = getattr(torch.nn, module_name)\n\n        if \"FunctionalModule\" in str(nn_module):\n            return\n\n        if 'constructor_args_fn' in kwargs:\n            constructor_args = kwargs['constructor_args_fn']()\n        else:\n            constructor_args = kwargs.get('constructor_args', ())\n\n        def create_script_module(*args, **kwargs):\n            \"\"\"Construct a script module that passes arguments through to self.submodule\"\"\"\n            formals, tensors, actuals = get_script_args(args)\n\n            method_args = ', '.join(['self'] + actuals)\n            call_args_str = ', '.join(actuals)\n            call = \"self.submodule({})\".format(call_args_str)\n            script = script_method_template.format(method_args, call)\n\n            submodule_constants = []\n            if kwargs.get('is_constant'):\n                submodule_constants = ['submodule']\n\n            # Create module to use the script method\n            class TheModule(torch.jit.ScriptModule):\n                __constants__ = submodule_constants\n\n                def __init__(self):\n                    super(TheModule, self).__init__()\n                    self.submodule = nn_module(*constructor_args)\n\n            def make_module(script):\n                module = TheModule()\n                # check __repr__\n                str(module)\n                module.define(script)\n                return module\n\n            module = make_module(script)\n            self.assertExportImportModule(module, tensors)\n            create_script_module.last_graph = module.graph\n            mod = module(*args)\n            return mod\n\n        # Construct a normal nn module to stay consistent with create_script_module\n        # and make use of a single global rng_state in module initialization\n        def create_nn_module(*args, **kwargs):\n            module = nn_module(*constructor_args)\n            return module(*args)\n\n        # Set up inputs from tuple of sizes or constructor fn\n        dtype = torch.double\n        if 'input_fn' in kwargs:\n            input = kwargs['input_fn']()\n            if isinstance(input, Tensor):\n                input = (input,)\n\n            if all(tensor.is_complex() for tensor in input):\n                dtype = torch.cdouble\n        else:\n            input = (kwargs['input_size'],)\n\n        if 'target_size' in kwargs:\n            input = input + (kwargs['target_size'],)\n        elif 'target_fn' in kwargs:\n            if torch.is_tensor(input):\n                input = (input,)\n            input = input + (kwargs['target_fn'](),)\n        elif 'target' in kwargs:\n            input = input + (kwargs['target'],)\n\n        # Extra parameters to forward()\n        if 'extra_args' in kwargs:\n            input = input + kwargs['extra_args']\n\n        args_variable, kwargs_variable = create_input(input, dtype=dtype)\n        f_args_variable = deepcopy(unpack_variables(args_variable))\n\n        # TODO(issue#52052) Neither this nor no_grad should be required\n        # if check_against_reference() is updated to check gradients\n        # w.r.t. weights and then only check w.r.t. inputs if any\n        # inputs require it.\n        any_requires_grad = any(input.requires_grad for input in f_args_variable)\n\n        # Check against Python module as reference\n        check_against_reference(self, create_script_module, create_nn_module,\n                                lambda x: x, f_args_variable,\n                                no_grad=no_grad or not any_requires_grad)\n\n    if 'slowTest' in kwargs:\n        do_test = slowTest(do_test)\n\n    post_add_test(test_name, (), do_test, TestJitGeneratedModule)\n\n\ndef post_add_test(test_name, skipTestIf, do_test, test_class):\n    assert not hasattr(test_class, test_name), 'Two tests have the same name: ' + test_name\n\n    for skip in skipTestIf:\n        do_test = skip(do_test)\n\n    if not (TEST_WITH_UBSAN and test_name in UBSAN_DISABLED_TESTS):\n        setattr(test_class, test_name, do_test)\n\n\ndef normalize_check_ad(check_ad, name):\n    # normalized check_ad is 3-element tuple: (bool, List[str], List[str])\n    if len(check_ad) == 0:\n        check_ad = [False, ['aten::' + name], []]\n    elif len(check_ad) == 1:\n        check_ad = [check_ad[0], ['aten::' + name], []]\n    elif len(check_ad) == 2:\n        check_ad = [check_ad[0], check_ad[1], []]\n    elif len(check_ad) == 3:\n        check_ad = list(check_ad)\n    else:\n        raise Exception('Invalid check_ad, requires (bool, str|List[str], str|List[str])')\n\n    check_ad = [[t] if isinstance(t, str) else t for t in check_ad]\n\n    return check_ad\n\n\nclass TestProducerVersion(TestCase):\n\n    def test_version(self):\n        # issue gh-32561\n        self.assertTrue(torch.__version__.startswith(torch.onnx.producer_version))\n\nfor test in module_tests + new_module_tests + additional_module_tests:\n    add_nn_module_test(**test)\n\nfor test in criterion_tests:\n    test['no_grad'] = True\n    add_nn_module_test(**test)\n\nif __name__ == '__main__':\n    run_tests()\n    import jit.test_module_interface\n    suite = unittest.findTestCases(jit.test_module_interface)\n    unittest.TextTestRunner().run(suite)\n", "#include <torch/csrc/jit/frontend/script_type_parser.h>\n\n#include <ATen/core/type_factory.h>\n#include <torch/csrc/jit/frontend/parser.h>\n#include <torch/csrc/jit/ir/ir.h>\n#include <torch/custom_class.h>\n\nnamespace torch {\nnamespace jit {\nnamespace {\n\nbool isTorch(const Expr& expr) {\n  return expr.kind() == TK_VAR && Var(expr).name().name() == \"torch\";\n}\n\nstd::string collectQualname(const Select& select) {\n  Expr base = select.value();\n  if (base.kind() == TK_VAR) {\n    return Var(base).name().name() + \".\" + select.selector().name();\n  }\n  std::string basename = collectQualname(Select(base));\n  return basename + \".\" + select.selector().name();\n}\n\nconst std::unordered_map<std::string, c10::TypePtr>& string_to_type_lut() {\n  return c10::DefaultTypeFactory::basePythonTypes();\n}\n\n} // namespace\n\nTypePtr ScriptTypeParser::subscriptToType(\n    const std::string& typeName,\n    const Subscript& subscript) const {\n  if (typeName == \"Tuple\" || typeName == \"tuple\") {\n    if (subscript.subscript_exprs().size() == 1 &&\n        subscript.subscript_exprs()[0].kind() == TK_TUPLE_LITERAL) {\n      // `typing.Tuple` special cases syntax for empty tuple annotations,\n      // i.e. `typing.Tuple[()]`. Allow for parsing an empty tuple literal\n      // here. See https://docs.python.org/3/library/typing.html#typing.Tuple\n      auto tup_literal = TupleLiteral(subscript.subscript_exprs()[0]);\n      if (tup_literal.inputs().size() > 0) {\n        throw ErrorReport(tup_literal.range())\n            << \"Tuple literal in Tuple type annotation must not \"\n            << \"have any elements!\";\n      }\n      return TupleType::create({});\n    }\n    std::vector<TypePtr> subscript_expr_types;\n    for (auto expr : subscript.subscript_exprs()) {\n      subscript_expr_types.emplace_back(parseTypeFromExprImpl(expr));\n    }\n    return TupleType::create(subscript_expr_types);\n  } else if (typeName == \"List\" || typeName == \"list\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return ListType::create(elem_type);\n\n  } else if (typeName == \"Optional\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return OptionalType::create(elem_type);\n\n  } else if (typeName == \"Union\") {\n    std::vector<TypePtr> subscript_expr_types;\n    subscript_expr_types.reserve(subscript.subscript_exprs().size());\n    for (auto expr : subscript.subscript_exprs()) {\n      subscript_expr_types.emplace_back(parseTypeFromExprImpl(expr));\n    }\n    return UnionType::create(subscript_expr_types);\n  } else if (typeName == \"Future\" || typeName == \"torch.jit.Future\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return FutureType::create(elem_type);\n  } else if (typeName == \"RRef\") {\n    if (subscript.subscript_exprs().size() != 1) {\n      throw ErrorReport(subscript)\n          << \" expected exactly one element type but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto elem_type =\n        parseTypeFromExprImpl(*subscript.subscript_exprs().begin());\n    return RRefType::create(elem_type);\n  } else if (typeName == \"Dict\" || typeName == \"dict\") {\n    if (subscript.subscript_exprs().size() != 2) {\n      throw ErrorReport(subscript)\n          << \" expected exactly 2 element types but found \"\n          << subscript.subscript_exprs().size();\n    }\n    auto key_type = parseTypeFromExprImpl(subscript.subscript_exprs()[0]);\n    auto value_type = parseTypeFromExprImpl(subscript.subscript_exprs()[1]);\n    return DictType::create(key_type, value_type);\n  } else {\n    throw ErrorReport(subscript.range())\n        << \"Unknown type constructor \" << typeName;\n  }\n}\n\nc10::optional<std::pair<TypePtr, int32_t>> ScriptTypeParser::parseBroadcastList(\n    const Expr& expr) const {\n  // Alias torch.nn._common_types._size_?_t to BroadcastingList?[int]\n  if (expr.kind() == TK_VAR) {\n    auto var = Var(expr);\n    auto& name = var.name().name();\n    constexpr auto _size_prefix = \"_size_\";\n    constexpr auto _size_suffix = \"_t\";\n    constexpr auto _size_n_len = 9; // strlen(\"_size_X_t\")\n    constexpr auto _size_prefix_len = 6; // strlen(\"_size_\");\n    if (name.find(_size_prefix) == 0 && name.length() == _size_n_len &&\n        name.find(_size_suffix) == _size_prefix_len + 1 &&\n        ::isdigit(name[_size_prefix_len])) {\n      int n = name[_size_prefix_len] - '0';\n      return std::pair<TypePtr, int32_t>(ListType::create(IntType::get()), n);\n    }\n  }\n\n  if (expr.kind() != TK_SUBSCRIPT)\n    return c10::nullopt;\n  auto subscript = Subscript(expr);\n  if (subscript.value().kind() != TK_VAR)\n    return c10::nullopt;\n  auto var = Var(subscript.value());\n  auto subscript_exprs = subscript.subscript_exprs();\n\n  // handle the case where the BroadcastingList is wrapped in a Optional type\n  if (var.name().name() == \"Optional\") {\n    auto broadcast_list = parseBroadcastList(subscript_exprs[0]);\n    if (broadcast_list) {\n      TypePtr opt_type = OptionalType::create(broadcast_list->first);\n      return std::pair<TypePtr, int32_t>(opt_type, broadcast_list->second);\n    } else {\n      return c10::nullopt;\n    }\n  } else if (var.name().name().find(\"BroadcastingList\") != 0) {\n    return c10::nullopt;\n  }\n\n  if (subscript_exprs.size() != 1)\n    throw ErrorReport(subscript.subscript_exprs().range())\n        << \"BroadcastingList/Optional[BroadcastingList] \"\n           \"must be subscripted with a type\";\n\n  auto typ = subscript_exprs[0];\n  auto len = var.name().name().substr(strlen(\"BroadcastingList\"));\n\n  if (typ.kind() != TK_VAR)\n    throw ErrorReport(subscript.value().range())\n        << \"Subscripted type must be a type identifier\";\n\n  auto value_name = Var(typ).name().name();\n  if (value_name != \"float\" && value_name != \"int\")\n    throw ErrorReport(subscript.value().range())\n        << \"Broadcastable lists only supported for int or float\";\n\n  auto elem_ptr = string_to_type_lut().find(value_name);\n  AT_ASSERT(elem_ptr != string_to_type_lut().end());\n  TypePtr list_ptr = ListType::create(elem_ptr->second);\n\n  const char* len_c = len.c_str();\n  // NOLINTNEXTLINE(cppcoreguidelines-init-variables)\n  char* end;\n  size_t len_v = strtoull(len_c, &end, 10);\n  if (end != len_c + len.size()) {\n    throw ErrorReport(subscript.subscript_exprs().range())\n        << \"subscript of Broadcastable list must be a positive integer\";\n  }\n  return std::pair<TypePtr, int32_t>(list_ptr, len_v);\n}\n\n// gets the base type name given namespaces where the types live\n// turns torch.Tensor -> Tensor, X -> X\nc10::optional<std::string> ScriptTypeParser::parseBaseTypeName(\n    const Expr& expr) const {\n  switch (expr.kind()) {\n    case TK_VAR: {\n      return Var(expr).name().name();\n    }\n    case TK_NONE: {\n      return \"None\";\n    }\n    case TK_NONE_TYPE: {\n      return \"NoneType\";\n    }\n    case '.': {\n      auto select = Select(expr);\n      const std::string& name = select.selector().name();\n      // Special case for torch.Tensor and its' subclasses\n      const std::unordered_set<std::string> tensor_subtypes = {\n          \"Tensor\",\n          \"LongTensor\",\n          \"FloatTensor\",\n          \"DoubleTensor\",\n          \"IntTensor\",\n          \"ShortTensor\",\n          \"HalfTensor\",\n          \"CharTensor\",\n          \"ByteTensor\",\n          \"BoolTensor\"};\n      if (isTorch(select.value()) && tensor_subtypes.count(name) == 1) {\n        return name;\n      } else {\n        // Otherwise, it's a fully qualified class name\n        return collectQualname(select);\n      }\n    } break;\n  }\n  return at::nullopt;\n}\n\nTypePtr ScriptTypeParser::parseTypeFromExpr(const Expr& expr) const {\n  // the resolver needs to recursively resolve the expression, so to avoid\n  // resolving all type expr subtrees we only use it for the top level\n  // expression and base type names.\n  if (resolver_) {\n    if (auto typePtr =\n            resolver_->resolveType(expr.range().text().str(), expr.range())) {\n      return typePtr;\n    }\n  }\n  return parseTypeFromExprImpl(expr);\n}\n\nTypePtr ScriptTypeParser::parseTypeFromExprImpl(const Expr& expr) const {\n  if (expr.kind() == TK_SUBSCRIPT) {\n    auto subscript = Subscript(expr);\n    auto value_name = parseBaseTypeName(subscript.value());\n    if (!value_name) {\n      throw ErrorReport(subscript.value().range())\n          << \"Subscripted type must be a type identifier\";\n    }\n    return subscriptToType(*value_name, subscript);\n\n  } else if (expr.kind() == TK_STRINGLITERAL) {\n    const auto& type_name = StringLiteral(expr).text();\n\n    // Check if the type is a custom class. This is done by checking\n    // if type_name starts with \"torch.classes.\"\n    if (type_name.find(\"torch.classes.\") == 0) {\n      auto custom_class_type = getCustomClass(\"__torch__.\" + type_name);\n      return custom_class_type;\n    }\n\n    // `torch.cuda.Stream` and `torch.cuda.Event` are aliased as\n    // custom classes of type torch.classes.cuda.Stream and\n    // torch.classes.cuda.Event respectively. Return the respective\n    // custom class types for these two cases.\n    if (type_name.find(\"torch.cuda.Stream\") == 0) {\n      auto custom_class_type =\n          getCustomClass(\"__torch__.torch.classes.cuda.Stream\");\n      return custom_class_type;\n    }\n\n    if (type_name.find(\"torch.cuda.Event\") == 0) {\n      auto custom_class_type =\n          getCustomClass(\"__torch__.torch.classes.cuda.Event\");\n      return custom_class_type;\n    }\n\n    if (resolver_) {\n      if (auto typePtr = resolver_->resolveType(type_name, expr.range())) {\n        return typePtr;\n      }\n    }\n\n    throw ErrorReport(expr) << \"Unknown type name '\" << type_name << \"'\";\n  } else if (auto name = parseBaseTypeName(expr)) {\n    auto itr = string_to_type_lut().find(*name);\n    if (itr != string_to_type_lut().end()) {\n      return itr->second;\n    }\n    if (resolver_) {\n      if (auto typePtr = resolver_->resolveType(*name, expr.range())) {\n        return typePtr;\n      }\n    }\n\n    if (auto custom_class_type = getCustomClass(*name)) {\n      return custom_class_type;\n    }\n\n    throw ErrorReport(expr) << \"Unknown type name '\" << *name << \"'\";\n  }\n  throw ErrorReport(expr.range())\n      << \"Expression of type \" << kindToString(expr.kind())\n      << \" cannot be used in a type expression\";\n}\n\nTypePtr ScriptTypeParser::parseType(const std::string& str) {\n  Parser p(std::make_shared<Source>(str));\n  return parseTypeFromExpr(p.parseExp());\n}\n\nstd::vector<IValue> ScriptTypeParser::evaluateDefaults(\n    const SourceRange& r,\n    const std::vector<Expr>& default_types,\n    const std::vector<Expr>& default_exprs) {\n  std::vector<IValue> default_values;\n  if (default_exprs.empty())\n    return default_values;\n  // To evaluate the default expressions, we create a graph with no inputs,\n  // and whose returns are the default values we need.\n  // We then run constant prop on this graph and check the results are\n  // constant. This approach avoids having to have separate handling of\n  // default arguments from standard expressions by piecing together existing\n  // machinery for graph generation, constant propagation, and constant\n  // extraction.\n  auto tuple_type = Subscript::create(\n      r,\n      Var::create(r, Ident::create(r, \"Tuple\")),\n      List<Expr>::create(r, default_types));\n  auto blank_decl = Decl::create(\n      r, List<Param>::create(r, {}), Maybe<Expr>::create(r, tuple_type));\n\n  auto tuple_expr =\n      TupleLiteral::create(r, List<Expr>::create(r, default_exprs));\n  auto ret = Return::create(r, tuple_expr);\n  auto def = Def::create(\n      r,\n      Ident::create(r, \"defaults\"),\n      blank_decl,\n      List<Stmt>::create(r, {ret}));\n\n  CompilationUnit cu;\n  cu.define(\n      c10::nullopt,\n      /*properties=*/{},\n      /*propResolvers=*/{},\n      {def},\n      {resolver_},\n      nullptr);\n  Stack stack;\n  // XXX: We need to turn optimization off here because otherwise we try to\n  // recursively initialize stuff in DecomposeOps.\n  GraphOptimizerEnabledGuard guard(false);\n  cu.get_function(def.name().name()).run(stack);\n  return stack.at(0).toTupleRef().elements().vec();\n}\n\nstd::vector<Argument> ScriptTypeParser::parseArgsFromDecl(\n    const Decl& decl,\n    bool skip_self) {\n  auto params_begin = decl.params().begin();\n  auto params_end = decl.params().end();\n  if (skip_self) {\n    ++params_begin;\n  }\n  std::vector<Argument> retval;\n\n  std::vector<Expr> default_types;\n  std::vector<Expr> default_exprs;\n  // gather any non-empty default arguments\n  for (auto it = params_begin; it != params_end; ++it) {\n    auto param = *it;\n    auto def = param.defaultValue();\n    if (def.present()) {\n      if (!param.type().present()) {\n        // We require explicit type-hints for default expressions.\n        // If param doesn't have a type, we could default to \"Tensor\",\n        // just like what happens in the Python frontend.\n        // However here things are a bit more complicated, because\n        // default expressions are evaluated using a custom-built\n        // graph, and error messages coming out of that in case\n        // the type doesn't match the value are quite obscure.\n        throw ErrorReport(param.range())\n            << \"Keyword arguments with defaults need to be type-hinted (TorchScript C++ frontend)\";\n      }\n      default_types.emplace_back(param.type().get());\n      default_exprs.emplace_back(def.get());\n    }\n  }\n\n  auto default_values =\n      evaluateDefaults(decl.range(), default_types, default_exprs);\n\n  auto defaults_it = default_values.begin();\n  for (auto it = params_begin; it != params_end; ++it) {\n    auto decl_arg = *it;\n\n    TypePtr type;\n    c10::optional<int32_t> N = c10::nullopt;\n    if (!decl_arg.type().present()) {\n      // If this param doesn't have a type, default to \"tensor\"\n      type = TensorType::getInferred();\n    } else {\n      // BroadcastList list can only appear at the argument level\n      Expr type_expr = decl_arg.type().get();\n      if (auto maybe_broad_list = parseBroadcastList(type_expr)) {\n        type = maybe_broad_list->first;\n        N = maybe_broad_list->second;\n      } else {\n        type = parseTypeFromExpr(decl_arg.type().get());\n      }\n    }\n    c10::optional<IValue> default_value = c10::nullopt;\n    if (decl_arg.defaultValue().present()) {\n      default_value = *defaults_it++;\n    }\n    auto arg = Argument(\n        decl_arg.ident().name(),\n        type,\n        N,\n        default_value,\n        decl_arg.kwarg_only(),\n        /*alias_info=*/c10::nullopt);\n    retval.push_back(arg);\n  }\n  return retval;\n}\n\nstd::vector<Argument> ScriptTypeParser::parseReturnFromDecl(const Decl& decl) {\n  // we represent no annoation on a return type as having no values in the\n  // schema's return() list\n  // in emitReturn we take the actual return value to be the value of the\n  // return statement if no one was provided here\n  if (!decl.return_type().present())\n    return {};\n\n  if (parseBroadcastList(decl.return_type().get()))\n    throw ErrorReport(decl.return_type().range())\n        << \"Broadcastable lists cannot appear as a return type\";\n\n  TypePtr parsed_type;\n  Expr type_expr = decl.return_type().get();\n  parsed_type = parseTypeFromExpr(type_expr);\n  return {Argument(\n      \"\",\n      parsed_type,\n      /*N =*/c10::nullopt,\n      /*default_value =*/c10::nullopt,\n      /*kwarg_only =*/false)};\n}\nFunctionSchema ScriptTypeParser::parseSchemaFromDef(\n    const Def& def,\n    bool skip_self) {\n  const auto name = def.name().name();\n  std::vector<Argument> args = parseArgsFromDecl(def.decl(), skip_self);\n  std::vector<Argument> returns = parseReturnFromDecl(def.decl());\n  return FunctionSchema(\n      name, \"\", std::move(args), std::move(returns), false, false);\n}\n\nc10::IValue ScriptTypeParser::parseClassConstant(const Assign& assign) {\n  if (assign.lhs().kind() != TK_VAR) {\n    throw ErrorReport(assign.range())\n        << \"Expected to a variable for class constant\";\n  }\n  const auto final_type = assign.type().get();\n  auto expr = assign.rhs().get();\n  if (final_type.kind() != TK_SUBSCRIPT) {\n    throw ErrorReport(assign.range())\n        << \"Expected subscripted type for class constant\";\n  }\n  auto subscript = Subscript(final_type);\n  auto value_name = parseBaseTypeName(subscript.value());\n  if (!value_name) {\n    throw ErrorReport(subscript.value().range())\n        << \"Subscripted type must be a type identifier\";\n  }\n  if (*value_name != \"Final\") {\n    throw ErrorReport(subscript.range())\n        << \"Base type must be Final for class constant\";\n  }\n  if (subscript.subscript_exprs().size() != 1) {\n    throw ErrorReport(subscript)\n        << \" expected exactly one element type but found \"\n        << subscript.subscript_exprs().size();\n  }\n  auto type = *subscript.subscript_exprs().begin();\n  auto default_val = evaluateDefaults(expr.range(), {type}, {expr});\n  return *default_val.begin();\n}\n\n} // namespace jit\n} // namespace torch\n", "import ast\nimport dis\nimport enum\nimport inspect\nimport re\nimport builtins\nimport torch\nimport warnings\nfrom .._jit_internal import List, Tuple, is_tuple, is_list, Dict, is_dict, Optional, \\\n    is_optional, _qualified_name, Any, Future, is_future, is_ignored_fn, Union, is_union\nfrom .._jit_internal import BroadcastingList1, BroadcastingList2, BroadcastingList3  # type: ignore[attr-defined]\nfrom ._state import _get_script_class\n\nfrom torch._C import TensorType, TupleType, FloatType, IntType, ComplexType, \\\n    ListType, StringType, DictType, BoolType, OptionalType, InterfaceType, AnyType, \\\n    NoneType, DeviceObjType, StreamObjType, FutureType, EnumType, UnionType, NumberType\n\n\nfrom textwrap import dedent\nfrom torch._sources import get_source_lines_and_file\nfrom typing import Type\n\nif torch.distributed.rpc.is_available():\n    from .._jit_internal import RRef, is_rref\n    from torch._C import RRefType\n\nfrom torch._ops import OpOverloadPacket\n\nclass Module(object):\n    def __init__(self, name, members):\n        self.name = name\n        self.members = members\n\n    def __getattr__(self, name):\n        try:\n            return self.members[name]\n        except KeyError:\n            raise RuntimeError(f\"Module {self.name} has no member called {name}\") from None\n\n\nclass EvalEnv(object):\n    env = {\n        'torch': Module('torch', {'Tensor': torch.Tensor}),\n        'Tensor': torch.Tensor,\n        'typing': Module('typing', {'Tuple': Tuple}),\n        'Tuple': Tuple,\n        'List': List,\n        'Dict': Dict,\n        'Optional': Optional,\n        'Union': Union,\n        'Future': Future\n    }\n\n    def __init__(self, rcb):\n        self.rcb = rcb\n        if torch.distributed.rpc.is_available():\n            self.env['RRef'] = RRef\n\n    def __getitem__(self, name):\n        if name in self.env:\n            return self.env[name]\n        if self.rcb is not None:\n            return self.rcb(name)\n        return getattr(builtins, name, None)\n\ndef get_signature(fn, rcb, loc, is_method):\n    if isinstance(fn, OpOverloadPacket):\n        signature = try_real_annotations(fn.op, loc)\n    else:\n        signature = try_real_annotations(fn, loc)\n    if signature is not None and is_method:\n        # If this is a method, then the signature will include a type for\n        # `self`, but type comments do not contain a `self`. So strip it\n        # away here so everything is consistent (`inspect.ismethod` does\n        # not work here since `fn` is unbound at this point)\n        param_types, return_type = signature\n        param_types = param_types[1:]\n        signature = (param_types, return_type)\n\n    if signature is None:\n        type_line, source = None, None\n        try:\n            source = dedent(''.join(get_source_lines_and_file(fn)[0]))\n            type_line = get_type_line(source)\n        except TypeError:\n            pass\n        # This might happen both because we failed to get the source of fn, or\n        # because it didn't have any annotations.\n        if type_line is not None:\n            signature = parse_type_line(type_line, rcb, loc)\n\n    return signature\n\n\ndef is_function_or_method(the_callable):\n    # A stricter version of `inspect.isroutine` that does not pass for built-in\n    # functions\n    return inspect.isfunction(the_callable) or inspect.ismethod(the_callable)\n\n\ndef is_vararg(the_callable):\n    if not is_function_or_method(the_callable) and hasattr(the_callable, '__call__'):  # noqa: B004\n        # If `the_callable` is a class, de-sugar the call so we can still get\n        # the signature\n        the_callable = the_callable.__call__\n\n    if is_function_or_method(the_callable):\n        return inspect.getfullargspec(the_callable).varargs is not None\n    else:\n        return False\n\n\ndef get_param_names(fn, n_args):\n    if isinstance(fn, OpOverloadPacket):\n        fn = fn.op\n\n    if not is_function_or_method(fn) and hasattr(fn, '__call__') and is_function_or_method(fn.__call__):  # noqa: B004\n        # De-sugar calls to classes\n        fn = fn.__call__\n\n    if is_function_or_method(fn):\n        if is_ignored_fn(fn):\n            fn = inspect.unwrap(fn)\n        return inspect.getfullargspec(fn).args\n    else:\n        # The `fn` was not a method or function (maybe a class with a __call__\n        # method, so use a default param name list)\n        return [str(i) for i in range(n_args)]\n\n\ndef check_fn(fn, loc):\n    # Make sure the function definition is not a class instantiation\n    try:\n        source = dedent(''.join(get_source_lines_and_file(fn)[0]))\n    except (TypeError, IOError):\n        return\n    if source is None:\n        return\n\n    py_ast = ast.parse(source)\n    if len(py_ast.body) == 1 and isinstance(py_ast.body[0], ast.ClassDef):\n        raise torch.jit.frontend.FrontendError(\n            loc, f\"Cannot instantiate class '{py_ast.body[0].name}' in a script function\")\n    if len(py_ast.body) != 1 or not isinstance(py_ast.body[0], ast.FunctionDef):\n        raise torch.jit.frontend.FrontendError(loc, \"Expected a single top-level function\")\n\n\ndef _eval_no_call(stmt, glob, loc):\n    \"\"\"Evaluate statement as long as it does not contain any method/function calls\"\"\"\n    bytecode = compile(stmt, \"\", mode=\"eval\")\n    for insn in dis.get_instructions(bytecode):\n        if \"CALL\" in insn.opname:\n            raise RuntimeError(f\"Type annotation should not contain calls, but '{stmt}' does\")\n    return eval(bytecode, glob, loc)  # type: ignore[arg-type] # noqa: P204\n\n\ndef parse_type_line(type_line, rcb, loc):\n    \"\"\"Parses a type annotation specified as a comment.\n\n    Example inputs:\n        # type: (Tensor, torch.Tensor) -> Tuple[Tensor]\n        # type: (Tensor, Tuple[Tensor, Tensor]) -> Tensor\n    \"\"\"\n    arg_ann_str, ret_ann_str = split_type_line(type_line)\n\n    try:\n        arg_ann = _eval_no_call(arg_ann_str, {}, EvalEnv(rcb))\n    except (NameError, SyntaxError) as e:\n        raise RuntimeError(\"Failed to parse the argument list of a type annotation\") from e\n\n    if not isinstance(arg_ann, tuple):\n        arg_ann = (arg_ann,)\n\n    try:\n        ret_ann = _eval_no_call(ret_ann_str, {}, EvalEnv(rcb))\n    except (NameError, SyntaxError) as e:\n        raise RuntimeError(\"Failed to parse the return type of a type annotation\") from e\n\n    arg_types = [ann_to_type(ann, loc) for ann in arg_ann]\n    return arg_types, ann_to_type(ret_ann, loc)\n\n\ndef get_type_line(source):\n    \"\"\"Tries to find the line containing a comment with the type annotation.\"\"\"\n    type_comment = '# type:'\n\n    lines = source.split('\\n')\n    lines = [(line_num, line) for line_num, line in enumerate(lines)]\n    type_lines = list(filter(lambda line: type_comment in line[1], lines))\n    # `type: ignore` comments may be needed in JIT'ed functions for mypy, due\n    # to the hack in torch/_VF.py.\n\n    # An ignore type comment can be of following format:\n    #   1) type: ignore\n    #   2) type: ignore[rule-code]\n    # This ignore statement must be at the end of the line\n\n    # adding an extra backslash before the space, to avoid triggering\n    # one of the checks in .github/workflows/lint.yml\n    type_pattern = re.compile(\"# type:\\\\ ignore(\\\\[[a-zA-Z-]+\\\\])?$\")\n    type_lines = list(filter(lambda line: not type_pattern.search(line[1]),\n                             type_lines))\n\n    if len(type_lines) == 0:\n        # Catch common typo patterns like extra spaces, typo in 'ignore', etc.\n        wrong_type_pattern = re.compile(\"#[\\t ]*type[\\t ]*(?!: ignore(\\\\[.*\\\\])?$):\")\n        wrong_type_lines = list(filter(lambda line: wrong_type_pattern.search(line[1]), lines))\n        if len(wrong_type_lines) > 0:\n            raise RuntimeError(\"The annotation prefix in line \" + str(wrong_type_lines[0][0])\n                               + \" is probably invalid.\\nIt must be '# type:'\"\n                               + \"\\nSee PEP 484 (https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code)\"  # noqa: B950\n                               + \"\\nfor examples\")\n        return None\n    elif len(type_lines) == 1:\n        # Only 1 type line, quit now\n        return type_lines[0][1].strip()\n\n    # Parse split up argument types according to PEP 484\n    # https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code\n    return_line = None\n    parameter_type_lines = []\n    for line_num, line in type_lines:\n        if '# type: (...) -> ' in line:\n            return_line = (line_num, line)\n            break\n        elif type_comment in line:\n            parameter_type_lines.append(line)\n    if return_line is None:\n        raise RuntimeError(\n            \"Return type line '# type: (...) -> ...' not found on multiline \"\n            \"type annotation\\nfor type lines:\\n\" +\n            '\\n'.join([line[1] for line in type_lines]) +\n            \"\\n(See PEP 484 https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code)\")\n\n    def get_parameter_type(line):\n        item_type = line[line.find(type_comment) + len(type_comment):]\n        return item_type.strip()\n\n    types = map(get_parameter_type, parameter_type_lines)\n    parameter_types = \", \".join(types)\n\n    return return_line[1].replace(\"...\", parameter_types)\n\n\ndef split_type_line(type_line):\n    \"\"\"Splits the comment with the type annotation into parts for argument and return types.\n\n    For example, for an input of:\n        # type: (Tensor, torch.Tensor) -> Tuple[Tensor, Tensor]\n\n    This function will return:\n        (\"(Tensor, torch.Tensor)\", \"Tuple[Tensor, Tensor]\")\n\n    \"\"\"\n    start_offset = len('# type:')\n    try:\n        arrow_pos = type_line.index('->')\n    except ValueError:\n        raise RuntimeError(\"Syntax error in type annotation (cound't find `->`)\") from None\n    return type_line[start_offset:arrow_pos].strip(), type_line[arrow_pos + 2:].strip()\n\n\ndef try_real_annotations(fn, loc):\n    \"\"\"Tries to use the Py3.5+ annotation syntax to get the type.\"\"\"\n    try:\n        # Note: anything annotated as `Optional[T]` will automatically\n        # be returned as `Union[T, None]` per\n        # https://github.com/python/typing/blob/master/src/typing.py#L850\n        sig = inspect.signature(fn)\n    except ValueError:\n        return None\n\n    all_annots = [sig.return_annotation] + [p.annotation for p in sig.parameters.values()]\n    if all(ann is sig.empty for ann in all_annots):\n        return None\n\n    arg_types = [ann_to_type(p.annotation, loc)\n                 for p in sig.parameters.values()]\n    return_type = ann_to_type(sig.return_annotation, loc)\n    return arg_types, return_type\n\n\n# Finds common type for enum values belonging to an Enum class. If not all\n# values have the same type, AnyType is returned.\ndef get_enum_value_type(e: Type[enum.Enum], loc):\n    enum_values: List[enum.Enum] = list(e)\n    if not enum_values:\n        raise ValueError(f\"No enum values defined for: '{e.__class__}'\")\n\n    types = {type(v.value) for v in enum_values}\n    ir_types = [try_ann_to_type(t, loc) for t in types]\n\n    # If Enum values are of different types, an exception will be raised here.\n    # Even though Python supports this case, we chose to not implement it to\n    # avoid overcomplicate logic here for a rare use case. Please report a\n    # feature request if you find it necessary.\n    res = torch._C.unify_type_list(ir_types)\n    if not res:\n        return AnyType.get()\n    return res\n\ndef is_tensor(ann):\n    if issubclass(ann, torch.Tensor):\n        return True\n\n    if issubclass(ann, (torch.LongTensor, torch.DoubleTensor, torch.FloatTensor,\n                        torch.IntTensor, torch.ShortTensor, torch.HalfTensor,\n                        torch.CharTensor, torch.ByteTensor, torch.BoolTensor)):\n        warnings.warn(\"TorchScript will treat type annotations of Tensor \"\n                      \"dtype-specific subtypes as if they are normal Tensors. \"\n                      \"dtype constraints are not enforced in compilation either.\")\n        return True\n\n    return False\n\n\n\ndef try_ann_to_type(ann, loc):\n    if ann is inspect.Signature.empty:\n        return TensorType.getInferred()\n    if ann is None:\n        return NoneType.get()\n    if inspect.isclass(ann) and is_tensor(ann):\n        return TensorType.get()\n    if is_tuple(ann):\n        # Special case for the empty Tuple type annotation `Tuple[()]`\n        if len(ann.__args__) == 1 and ann.__args__[0] == ():\n            return TupleType([])\n        return TupleType([try_ann_to_type(a, loc) for a in ann.__args__])\n    if is_list(ann):\n        elem_type = try_ann_to_type(ann.__args__[0], loc)\n        if elem_type:\n            return ListType(elem_type)\n    if is_dict(ann):\n        key = try_ann_to_type(ann.__args__[0], loc)\n        value = try_ann_to_type(ann.__args__[1], loc)\n        # Raise error if key or value is None\n        if key is None:\n            raise ValueError(f\"Unknown type annotation: '{ann.__args__[0]}' at {loc.highlight()}\")\n        if value is None:\n            raise ValueError(f\"Unknown type annotation: '{ann.__args__[1]}' at {loc.highlight()}\")\n        return DictType(key, value)\n    if is_optional(ann):\n        if issubclass(ann.__args__[1], type(None)):\n            contained = ann.__args__[0]\n        else:\n            contained = ann.__args__[1]\n        valid_type = try_ann_to_type(contained, loc)\n        msg = \"Unsupported annotation {} could not be resolved because {} could not be resolved.\"\n        assert valid_type, msg.format(repr(ann), repr(contained))\n        return OptionalType(valid_type)\n    if is_union(ann):\n        # TODO: this is hack to recognize NumberType\n        if set(ann.__args__) == set([int, float, complex]):\n            return NumberType.get()\n        inner: List = []\n        # We need these extra checks because both `None` and invalid\n        # values will return `None`\n        # TODO: Determine if the other cases need to be fixed as well\n        for a in ann.__args__:\n            if a is None:\n                inner.append(NoneType.get())\n            maybe_type = try_ann_to_type(a, loc)\n            msg = \"Unsupported annotation {} could not be resolved because {} could not be resolved.\"\n            assert maybe_type, msg.format(repr(ann), repr(maybe_type))\n            inner.append(maybe_type)\n        return UnionType(inner)    # type: ignore[arg-type]\n    if torch.distributed.rpc.is_available() and is_rref(ann):\n        return RRefType(try_ann_to_type(ann.__args__[0], loc))\n    if is_future(ann):\n        return FutureType(try_ann_to_type(ann.__args__[0], loc))\n    if ann is float:\n        return FloatType.get()\n    if ann is complex:\n        return ComplexType.get()\n    if ann is int:\n        return IntType.get()\n    if ann is str:\n        return StringType.get()\n    if ann is bool:\n        return BoolType.get()\n    if ann is Any:\n        return AnyType.get()\n    if ann is type(None):\n        return NoneType.get()\n    if inspect.isclass(ann) and hasattr(ann, \"__torch_script_interface__\"):\n        return InterfaceType(ann.__torch_script_interface__)\n    if ann is torch.device:\n        return DeviceObjType.get()\n    if ann is torch.Stream:\n        return StreamObjType.get()\n    if ann is torch.dtype:\n        return IntType.get()  # dtype not yet bound in as its own type\n    if inspect.isclass(ann) and issubclass(ann, enum.Enum):\n        if _get_script_class(ann) is None:\n            scripted_class = torch.jit._script._recursive_compile_class(ann, loc)\n            name = scripted_class.qualified_name()\n        else:\n            name = _qualified_name(ann)\n        return EnumType(name, get_enum_value_type(ann, loc), list(ann))\n    if inspect.isclass(ann):\n        maybe_script_class = _get_script_class(ann)\n        if maybe_script_class is not None:\n            return maybe_script_class\n        if torch._jit_internal.can_compile_class(ann):\n            return torch.jit._script._recursive_compile_class(ann, loc)\n\n    # Maybe resolve a NamedTuple to a Tuple Type\n    def fake_rcb(key):\n        return None\n    return torch._C._resolve_type_from_object(ann, loc, fake_rcb)\n\n\ndef ann_to_type(ann, loc):\n    the_type = try_ann_to_type(ann, loc)\n    if the_type is not None:\n        return the_type\n    raise ValueError(f\"Unknown type annotation: '{ann}' at {loc.highlight()}\")\n\n\n__all__ = [\n    'Any',\n    'List',\n    'BroadcastingList1',\n    'BroadcastingList2',\n    'BroadcastingList3',\n    'Tuple',\n    'is_tuple',\n    'is_list',\n    'Dict',\n    'is_dict',\n    'is_optional',\n    'is_union',\n    'TensorType',\n    'TupleType',\n    'FloatType',\n    'ComplexType',\n    'IntType',\n    'ListType',\n    'StringType',\n    'DictType',\n    'AnyType',\n    'Module',\n    # TODO: Consider not exporting these during wildcard import (reserve\n    # that for the types; for idiomatic typing code.)\n    'get_signature',\n    'check_fn',\n    'get_param_names',\n    'parse_type_line',\n    'get_type_line',\n    'split_type_line',\n    'try_real_annotations',\n    'try_ann_to_type',\n    'ann_to_type',\n]\n"], "filenames": ["test/test_jit.py", "torch/csrc/jit/frontend/script_type_parser.cpp", "torch/jit/annotations.py"], "buggy_code_start_loc": [3953, 319, 1], "buggy_code_end_loc": [3953, 320, 166], "fixing_code_start_loc": [3954, 319, 2], "fixing_code_end_loc": [3962, 320, 176], "type": "CWE-77", "message": "In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can cause arbitrary code execution because eval is used unsafely.", "other": {"cve": {"id": "CVE-2022-45907", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-26T02:15:10.253", "lastModified": "2023-04-26T17:39:13.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can cause arbitrary code execution because eval is used unsafely."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:pytorch:*:*:*:*:*:python:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "17B8827A-469E-484D-845F-8DA235DB1BBA"}]}]}], "references": [{"url": "https://github.com/pytorch/pytorch/commit/767f6aa49fe20a2766b9843d01e3b7f7793df6a3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pytorch/pytorch/issues/88868", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pytorch/pytorch/commit/767f6aa49fe20a2766b9843d01e3b7f7793df6a3"}}