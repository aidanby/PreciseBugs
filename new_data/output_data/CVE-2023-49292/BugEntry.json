{"buggy_code": ["package eciesgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// PrivateKey is an instance of secp256k1 private key with nested public key\ntype PrivateKey struct {\n\t*PublicKey\n\tD *big.Int\n}\n\n// GenerateKey generates secp256k1 key pair\nfunc GenerateKey() (*PrivateKey, error) {\n\tcurve := getCurve()\n\n\tp, x, y, err := elliptic.GenerateKey(curve, rand.Reader)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate key pair: %w\", err)\n\t}\n\n\treturn &PrivateKey{\n\t\tPublicKey: &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t},\n\t\tD: new(big.Int).SetBytes(p),\n\t}, nil\n}\n\n// NewPrivateKeyFromHex decodes hex form of private key raw bytes, computes public key and returns PrivateKey instance\nfunc NewPrivateKeyFromHex(s string) (*PrivateKey, error) {\n\tb, err := hex.DecodeString(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot decode hex string: %w\", err)\n\t}\n\n\treturn NewPrivateKeyFromBytes(b), nil\n}\n\n// NewPrivateKeyFromBytes decodes private key raw bytes, computes public key and returns PrivateKey instance\nfunc NewPrivateKeyFromBytes(priv []byte) *PrivateKey {\n\tcurve := getCurve()\n\tx, y := curve.ScalarBaseMult(priv)\n\n\treturn &PrivateKey{\n\t\tPublicKey: &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t},\n\t\tD: new(big.Int).SetBytes(priv),\n\t}\n}\n\n// Bytes returns private key raw bytes\nfunc (k *PrivateKey) Bytes() []byte {\n\treturn k.D.Bytes()\n}\n\n// Hex returns private key bytes in hex form\nfunc (k *PrivateKey) Hex() string {\n\treturn hex.EncodeToString(k.Bytes())\n}\n\n// Encapsulate encapsulates key by using Key Encapsulation Mechanism and returns symmetric key;\n// can be safely used as encryption key\nfunc (k *PrivateKey) Encapsulate(pub *PublicKey) ([]byte, error) {\n\tif pub == nil {\n\t\treturn nil, fmt.Errorf(\"public key is empty\")\n\t}\n\n\tvar secret bytes.Buffer\n\tsecret.Write(k.PublicKey.Bytes(false))\n\n\tsx, sy := pub.Curve.ScalarMult(pub.X, pub.Y, k.D.Bytes())\n\tsecret.Write([]byte{0x04})\n\n\t// Sometimes shared secret coordinates are less than 32 bytes; Big Endian\n\tl := len(pub.Curve.Params().P.Bytes())\n\tsecret.Write(zeroPad(sx.Bytes(), l))\n\tsecret.Write(zeroPad(sy.Bytes(), l))\n\n\treturn kdf(secret.Bytes())\n}\n\n// ECDH derives shared secret;\n// Must not be used as encryption key, it increases chances to perform successful key restoration attack\nfunc (k *PrivateKey) ECDH(pub *PublicKey) ([]byte, error) {\n\tif pub == nil {\n\t\treturn nil, fmt.Errorf(\"public key is empty\")\n\t}\n\n\t// Shared secret generation\n\tsx, sy := pub.Curve.ScalarMult(pub.X, pub.Y, k.D.Bytes())\n\n\tvar ss []byte\n\tif sy.Bit(0) != 0 { // If odd\n\t\tss = append(ss, 0x03)\n\t} else { // If even\n\t\tss = append(ss, 0x02)\n\t}\n\n\t// Sometimes shared secret is less than 32 bytes; Big Endian\n\tl := len(pub.Curve.Params().P.Bytes())\n\tfor i := 0; i < l-len(sx.Bytes()); i++ {\n\t\tss = append(ss, 0x00)\n\t}\n\n\treturn append(ss, sx.Bytes()...), nil\n}\n\n// Equals compares two private keys with constant time (to resist timing attacks)\nfunc (k *PrivateKey) Equals(priv *PrivateKey) bool {\n\tif subtle.ConstantTimeCompare(k.D.Bytes(), priv.D.Bytes()) == 1 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n", "package eciesgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"crypto/subtle\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// PublicKey instance with nested elliptic.Curve interface (secp256k1 instance in our case)\ntype PublicKey struct {\n\telliptic.Curve\n\tX, Y *big.Int\n}\n\n// NewPublicKeyFromHex decodes hex form of public key raw bytes and returns PublicKey instance\nfunc NewPublicKeyFromHex(s string) (*PublicKey, error) {\n\tb, err := hex.DecodeString(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot decode hex string: %w\", err)\n\t}\n\n\treturn NewPublicKeyFromBytes(b)\n}\n\n// NewPublicKeyFromBytes decodes public key raw bytes and returns PublicKey instance;\n// Supports both compressed and uncompressed public keys\nfunc NewPublicKeyFromBytes(b []byte) (*PublicKey, error) {\n\tcurve := getCurve()\n\n\tswitch b[0] {\n\tcase 0x02, 0x03:\n\t\tif len(b) != 33 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx := new(big.Int).SetBytes(b[1:])\n\t\tvar ybit uint\n\t\tswitch b[0] {\n\t\tcase 0x02:\n\t\t\tybit = 0\n\t\tcase 0x03:\n\t\t\tybit = 1\n\t\t}\n\n\t\tif x.Cmp(curve.Params().P) >= 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\t// y^2 = x^3 + b\n\t\t// y   = sqrt(x^3 + b)\n\t\tvar y, x3b big.Int\n\t\tx3b.Mul(x, x)\n\t\tx3b.Mul(&x3b, x)\n\t\tx3b.Add(&x3b, curve.Params().B)\n\t\tx3b.Mod(&x3b, curve.Params().P)\n\t\tif z := y.ModSqrt(&x3b, curve.Params().P); z == nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tif y.Bit(0) != ybit {\n\t\t\ty.Sub(curve.Params().P, &y)\n\t\t}\n\t\tif y.Bit(0) != ybit {\n\t\t\treturn nil, fmt.Errorf(\"incorrectly encoded X and Y bit\")\n\t\t}\n\n\t\treturn &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     &y,\n\t\t}, nil\n\tcase 0x04:\n\t\tif len(b) != 65 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx := new(big.Int).SetBytes(b[1:33])\n\t\ty := new(big.Int).SetBytes(b[33:])\n\n\t\tif x.Cmp(curve.Params().P) >= 0 || y.Cmp(curve.Params().P) >= 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx3 := new(big.Int).Sqrt(x).Mul(x, x)\n\t\tif t := new(big.Int).Sqrt(y).Sub(y, x3.Add(x3, curve.Params().B)); t.IsInt64() && t.Int64() == 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\treturn &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t}\n}\n\n// Bytes returns public key raw bytes;\n// Could be optionally compressed by dropping Y part\nfunc (k *PublicKey) Bytes(compressed bool) []byte {\n\tx := k.X.Bytes()\n\tif len(x) < 32 {\n\t\tfor i := 0; i < 32-len(x); i++ {\n\t\t\tx = append([]byte{0}, x...)\n\t\t}\n\t}\n\n\tif compressed {\n\t\t// If odd\n\t\tif k.Y.Bit(0) != 0 {\n\t\t\treturn bytes.Join([][]byte{{0x03}, x}, nil)\n\t\t}\n\n\t\t// If even\n\t\treturn bytes.Join([][]byte{{0x02}, x}, nil)\n\t}\n\n\ty := k.Y.Bytes()\n\tif len(y) < 32 {\n\t\tfor i := 0; i < 32-len(y); i++ {\n\t\t\ty = append([]byte{0}, y...)\n\t\t}\n\t}\n\n\treturn bytes.Join([][]byte{{0x04}, x, y}, nil)\n}\n\n// Hex returns public key bytes in hex form\nfunc (k *PublicKey) Hex(compressed bool) string {\n\treturn hex.EncodeToString(k.Bytes(compressed))\n}\n\n// Decapsulate decapsulates key by using Key Encapsulation Mechanism and returns symmetric key;\n// can be safely used as encryption key\nfunc (k *PublicKey) Decapsulate(priv *PrivateKey) ([]byte, error) {\n\tif priv == nil {\n\t\treturn nil, fmt.Errorf(\"public key is empty\")\n\t}\n\n\tvar secret bytes.Buffer\n\tsecret.Write(k.Bytes(false))\n\n\tsx, sy := priv.Curve.ScalarMult(k.X, k.Y, priv.D.Bytes())\n\tsecret.Write([]byte{0x04})\n\n\t// Sometimes shared secret coordinates are less than 32 bytes; Big Endian\n\tl := len(priv.Curve.Params().P.Bytes())\n\tsecret.Write(zeroPad(sx.Bytes(), l))\n\tsecret.Write(zeroPad(sy.Bytes(), l))\n\n\treturn kdf(secret.Bytes())\n}\n\n// Equals compares two public keys with constant time (to resist timing attacks)\nfunc (k *PublicKey) Equals(pub *PublicKey) bool {\n\teqX := subtle.ConstantTimeCompare(k.X.Bytes(), pub.X.Bytes()) == 1\n\teqY := subtle.ConstantTimeCompare(k.Y.Bytes(), pub.Y.Bytes()) == 1\n\treturn eqX && eqY\n}\n"], "fixing_code": ["package eciesgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// PrivateKey is an instance of secp256k1 private key with nested public key\ntype PrivateKey struct {\n\t*PublicKey\n\tD *big.Int\n}\n\n// GenerateKey generates secp256k1 key pair\nfunc GenerateKey() (*PrivateKey, error) {\n\tcurve := getCurve()\n\n\tp, x, y, err := elliptic.GenerateKey(curve, rand.Reader)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate key pair: %w\", err)\n\t}\n\n\treturn &PrivateKey{\n\t\tPublicKey: &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t},\n\t\tD: new(big.Int).SetBytes(p),\n\t}, nil\n}\n\n// NewPrivateKeyFromHex decodes hex form of private key raw bytes, computes public key and returns PrivateKey instance\nfunc NewPrivateKeyFromHex(s string) (*PrivateKey, error) {\n\tb, err := hex.DecodeString(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot decode hex string: %w\", err)\n\t}\n\n\treturn NewPrivateKeyFromBytes(b), nil\n}\n\n// NewPrivateKeyFromBytes decodes private key raw bytes, computes public key and returns PrivateKey instance\nfunc NewPrivateKeyFromBytes(priv []byte) *PrivateKey {\n\tcurve := getCurve()\n\tx, y := curve.ScalarBaseMult(priv)\n\n\treturn &PrivateKey{\n\t\tPublicKey: &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t},\n\t\tD: new(big.Int).SetBytes(priv),\n\t}\n}\n\n// Bytes returns private key raw bytes\nfunc (k *PrivateKey) Bytes() []byte {\n\treturn k.D.Bytes()\n}\n\n// Hex returns private key bytes in hex form\nfunc (k *PrivateKey) Hex() string {\n\treturn hex.EncodeToString(k.Bytes())\n}\n\n// Encapsulate encapsulates key by using Key Encapsulation Mechanism and returns symmetric key;\n// can be safely used as encryption key\nfunc (k *PrivateKey) Encapsulate(pub *PublicKey) ([]byte, error) {\n\tif pub == nil {\n\t\treturn nil, fmt.Errorf(\"public key is empty\")\n\t}\n\n\tif !k.Curve.IsOnCurve(pub.X, pub.Y) {\n\t\treturn nil, fmt.Errorf(\"invalid public key\")\n\t}\n\n\tvar secret bytes.Buffer\n\tsecret.Write(k.PublicKey.Bytes(false))\n\n\tsx, sy := pub.Curve.ScalarMult(pub.X, pub.Y, k.D.Bytes())\n\tsecret.Write([]byte{0x04})\n\n\t// Sometimes shared secret coordinates are less than 32 bytes; Big Endian\n\tl := len(pub.Curve.Params().P.Bytes())\n\tsecret.Write(zeroPad(sx.Bytes(), l))\n\tsecret.Write(zeroPad(sy.Bytes(), l))\n\n\treturn kdf(secret.Bytes())\n}\n\n// ECDH derives shared secret;\n// Must not be used as encryption key, it increases chances to perform successful key restoration attack\nfunc (k *PrivateKey) ECDH(pub *PublicKey) ([]byte, error) {\n\tif pub == nil {\n\t\treturn nil, fmt.Errorf(\"public key is empty\")\n\t}\n\n\tif !k.Curve.IsOnCurve(pub.X, pub.Y) {\n\t\treturn nil, fmt.Errorf(\"invalid public key\")\n\t}\n\n\t// Shared secret generation\n\tsx, sy := pub.Curve.ScalarMult(pub.X, pub.Y, k.D.Bytes())\n\n\tvar ss []byte\n\tif sy.Bit(0) != 0 { // If odd\n\t\tss = append(ss, 0x03)\n\t} else { // If even\n\t\tss = append(ss, 0x02)\n\t}\n\n\t// Sometimes shared secret is less than 32 bytes; Big Endian\n\tl := len(pub.Curve.Params().P.Bytes())\n\tfor i := 0; i < l-len(sx.Bytes()); i++ {\n\t\tss = append(ss, 0x00)\n\t}\n\n\treturn append(ss, sx.Bytes()...), nil\n}\n\n// Equals compares two private keys with constant time (to resist timing attacks)\nfunc (k *PrivateKey) Equals(priv *PrivateKey) bool {\n\tif subtle.ConstantTimeCompare(k.D.Bytes(), priv.D.Bytes()) == 1 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n", "package eciesgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"crypto/subtle\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// PublicKey instance with nested elliptic.Curve interface (secp256k1 instance in our case)\ntype PublicKey struct {\n\telliptic.Curve\n\tX, Y *big.Int\n}\n\n// NewPublicKeyFromHex decodes hex form of public key raw bytes and returns PublicKey instance\nfunc NewPublicKeyFromHex(s string) (*PublicKey, error) {\n\tb, err := hex.DecodeString(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot decode hex string: %w\", err)\n\t}\n\n\treturn NewPublicKeyFromBytes(b)\n}\n\n// NewPublicKeyFromBytes decodes public key raw bytes and returns PublicKey instance;\n// Supports both compressed and uncompressed public keys\nfunc NewPublicKeyFromBytes(b []byte) (*PublicKey, error) {\n\tcurve := getCurve()\n\n\tswitch b[0] {\n\tcase 0x02, 0x03:\n\t\tif len(b) != 33 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx := new(big.Int).SetBytes(b[1:])\n\t\tvar ybit uint\n\t\tswitch b[0] {\n\t\tcase 0x02:\n\t\t\tybit = 0\n\t\tcase 0x03:\n\t\t\tybit = 1\n\t\t}\n\n\t\tif x.Cmp(curve.Params().P) >= 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\t// y^2 = x^3 + b\n\t\t// y   = sqrt(x^3 + b)\n\t\tvar y, x3b big.Int\n\t\tx3b.Mul(x, x)\n\t\tx3b.Mul(&x3b, x)\n\t\tx3b.Add(&x3b, curve.Params().B)\n\t\tx3b.Mod(&x3b, curve.Params().P)\n\t\tif z := y.ModSqrt(&x3b, curve.Params().P); z == nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tif y.Bit(0) != ybit {\n\t\t\ty.Sub(curve.Params().P, &y)\n\t\t}\n\t\tif y.Bit(0) != ybit {\n\t\t\treturn nil, fmt.Errorf(\"incorrectly encoded X and Y bit\")\n\t\t}\n\n\t\treturn &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     &y,\n\t\t}, nil\n\tcase 0x04:\n\t\tif len(b) != 65 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx := new(big.Int).SetBytes(b[1:33])\n\t\ty := new(big.Int).SetBytes(b[33:])\n\n\t\tif x.Cmp(curve.Params().P) >= 0 || y.Cmp(curve.Params().P) >= 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\tx3 := new(big.Int).Sqrt(x).Mul(x, x)\n\t\tif t := new(big.Int).Sqrt(y).Sub(y, x3.Add(x3, curve.Params().B)); t.IsInt64() && t.Int64() == 0 {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t\t}\n\n\t\treturn &PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     x,\n\t\t\tY:     y,\n\t\t}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"cannot parse public key\")\n\t}\n}\n\n// Bytes returns public key raw bytes;\n// Could be optionally compressed by dropping Y part\nfunc (k *PublicKey) Bytes(compressed bool) []byte {\n\tx := k.X.Bytes()\n\tif len(x) < 32 {\n\t\tfor i := 0; i < 32-len(x); i++ {\n\t\t\tx = append([]byte{0}, x...)\n\t\t}\n\t}\n\n\tif compressed {\n\t\t// If odd\n\t\tif k.Y.Bit(0) != 0 {\n\t\t\treturn bytes.Join([][]byte{{0x03}, x}, nil)\n\t\t}\n\n\t\t// If even\n\t\treturn bytes.Join([][]byte{{0x02}, x}, nil)\n\t}\n\n\ty := k.Y.Bytes()\n\tif len(y) < 32 {\n\t\tfor i := 0; i < 32-len(y); i++ {\n\t\t\ty = append([]byte{0}, y...)\n\t\t}\n\t}\n\n\treturn bytes.Join([][]byte{{0x04}, x, y}, nil)\n}\n\n// Hex returns public key bytes in hex form\nfunc (k *PublicKey) Hex(compressed bool) string {\n\treturn hex.EncodeToString(k.Bytes(compressed))\n}\n\n// Decapsulate decapsulates key by using Key Encapsulation Mechanism and returns symmetric key;\n// can be safely used as encryption key\nfunc (k *PublicKey) Decapsulate(priv *PrivateKey) ([]byte, error) {\n\tif !k.Curve.IsOnCurve(k.X, k.Y) {\n\t\treturn nil, fmt.Errorf(\"invalid public key\")\n\t}\n\n\tif priv == nil {\n\t\treturn nil, fmt.Errorf(\"private key is empty\")\n\t}\n\n\tvar secret bytes.Buffer\n\tsecret.Write(k.Bytes(false))\n\n\tsx, sy := priv.Curve.ScalarMult(k.X, k.Y, priv.D.Bytes())\n\tsecret.Write([]byte{0x04})\n\n\t// Sometimes shared secret coordinates are less than 32 bytes; Big Endian\n\tl := len(priv.Curve.Params().P.Bytes())\n\tsecret.Write(zeroPad(sx.Bytes(), l))\n\tsecret.Write(zeroPad(sy.Bytes(), l))\n\n\treturn kdf(secret.Bytes())\n}\n\n// Equals compares two public keys with constant time (to resist timing attacks)\nfunc (k *PublicKey) Equals(pub *PublicKey) bool {\n\teqX := subtle.ConstantTimeCompare(k.X.Bytes(), pub.X.Bytes()) == 1\n\teqY := subtle.ConstantTimeCompare(k.Y.Bytes(), pub.Y.Bytes()) == 1\n\treturn eqX && eqY\n}\n"], "filenames": ["privatekey.go", "publickey.go"], "buggy_code_start_loc": [79, 139], "buggy_code_end_loc": [98, 142], "fixing_code_start_loc": [80, 140], "fixing_code_end_loc": [107, 146], "type": "NVD-CWE-noinfo", "message": "ecies is an Elliptic Curve Integrated Encryption Scheme for secp256k1 in Golang. If funcations Encapsulate(), Decapsulate() and ECDH() could be called by an attacker, they could recover any private key that interacts with it. This vulnerability was patched in 2.0.8. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-49292", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-05T00:15:09.627", "lastModified": "2023-12-08T17:20:40.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ecies is an Elliptic Curve Integrated Encryption Scheme for secp256k1 in Golang. If funcations Encapsulate(), Decapsulate() and ECDH() could be called by an attacker, they could recover any private key that interacts with it. This vulnerability was patched in 2.0.8. Users are advised to upgrade."}, {"lang": "es", "value": "ecies es un esquema de cifrado integrado de curva el\u00edptica para secp256k1 en Golang. Si un atacante pudiera llamar a las funciones Encapsulate(), Decapsulate() y ECDH(), podr\u00eda recuperar cualquier clave privada que interact\u00fae con ellas. Esta vulnerabilidad fue parcheada en 2.0.8. Se recomienda a los usuarios que actualicen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ecies:go:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.8", "matchCriteriaId": "B03A6379-B738-4870-806D-614DC8B1ADE2"}]}]}], "references": [{"url": "https://github.com/ashutosh1206/Crypton/blob/master/Diffie-Hellman-Key-Exchange/Attack-Invalid-Curve-Point/README.md", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://github.com/ecies/go/commit/c6e775163866d6ea5233eb8ec8530a9122101ebd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ecies/go/releases/tag/v2.0.8", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/ecies/go/security/advisories/GHSA-8j98-cjfr-qx3h", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ecies/go/commit/c6e775163866d6ea5233eb8ec8530a9122101ebd"}}