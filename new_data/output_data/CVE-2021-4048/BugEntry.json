{"buggy_code": ["*> \\brief \\b CLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download CLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/clarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/clarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE CLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       COMPLEX           Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> CLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by SLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is REAL\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is REAL\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is REAL array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is REAL array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by SLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is REAL\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is REAL\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is REAL array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from SLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is REAL array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is REAL array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is REAL array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is COMPLEX array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is REAL array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in CLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in SLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in SLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in SLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup complexOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE CLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      COMPLEX           Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      COMPLEX            CZERO\n      PARAMETER          ( CZERO = ( 0.0E0, 0.0E0 ) )\n      REAL               ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,\n     $                     TWO = 2.0E0, THREE = 3.0E0,\n     $                     FOUR = 4.0E0, HALF = 0.5E0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      INTEGER            INDIN1, INDIN2\n      REAL               BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      REAL               SLAMCH\n      EXTERNAL           SLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           CLAR1V, CLASET, CSSCAL, SCOPY, SLARRB,\n     $                   SLARRF\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, REAL, MAX, MIN\n      INTRINSIC CMPLX\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( N.LE.0 ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDIN1 = 3*N + 1\n      INDIN2 = 4*N + 1\n      INDWRK = 5*N + 1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL CLASET( 'Full', N, ZUSEDW, CZERO, CZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = SLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = CMPLX( ONE, ZERO )\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL SCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  DO 45 K = 1, IN - 1\n                     D( IBEGIN+K-1 ) = REAL( Z( IBEGIN+K-1,\n     $                                 J ) )\n                     L( IBEGIN+K-1 ) = REAL( Z( IBEGIN+K-1,\n     $                                 J+1 ) )\n   45             CONTINUE\n                  D( IEND ) = REAL( Z( IEND, J ) )\n                  SIGMA = REAL( Z( IEND, J+1 ) )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL CLASET( 'Full', IN, 2, CZERO, CZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL SLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in SLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    SLARRF needs LWORK = 2*N\n                     CALL SLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         WORK( INDIN1 ), WORK( INDIN2 ),\n     $                         WORK( INDWRK ), IINFO )\n*                    In the complex case, SLARRF cannot write\n*                    the new RRR directly into Z and needs an intermediate\n*                    workspace\n                     DO 56 K = 1, IN-1\n                        Z( IBEGIN+K-1, NEWFTT ) =\n     $                     CMPLX( WORK( INDIN1+K-1 ), ZERO )\n                        Z( IBEGIN+K-1, NEWFTT+1 ) =\n     $                     CMPLX( WORK( INDIN2+K-1 ), ZERO )\n   56                CONTINUE\n                     Z( IEND, NEWFTT ) =\n     $                  CMPLX( WORK( INDIN1+IN-1 ), ZERO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by SLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = CMPLX( SSIGMA, ZERO )\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(REAL(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL CLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL CLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL CSSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of CLARRV\n*\n      END\n", "*> \\brief \\b DLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download DLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       DOUBLE PRECISION  Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> DLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by DLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is DOUBLE PRECISION\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is DOUBLE PRECISION\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. \n*>          Note: VU is currently not used by this implementation of DLARRV, VU is\n*>          passed to DLARRV because it could be used compute gaps on the right end\n*>          of the extremal eigenvalues. However, with not much initial accuracy in\n*>          LAMBDA and VU, the formula can lead to an overestimation of the right gap\n*>          and thus to inadequately early RQI 'convergence'. This is currently\n*>          prevented this by forcing a small right gap. And so it turns out that VU\n*>          is currently not used by this implementation of DLARRV.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by DLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is DOUBLE PRECISION\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is DOUBLE PRECISION\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from DLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is DOUBLE PRECISION array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is DOUBLE PRECISION array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is DOUBLE PRECISION array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in DLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in DLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in DLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in DLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup doubleOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      DOUBLE PRECISION  Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      DOUBLE PRECISION   ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,\n     $                     TWO = 2.0D0, THREE = 3.0D0,\n     $                     FOUR = 4.0D0, HALF = 0.5D0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      DOUBLE PRECISION   BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      DOUBLE PRECISION   DLAMCH\n      EXTERNAL           DLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           DCOPY, DLAR1V, DLARRB, DLARRF, DLASET,\n     $                   DSCAL\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, DBLE, MAX, MIN\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( N.LE.0 ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDWRK= 3*N+1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL DLASET( 'Full', N, ZUSEDW, ZERO, ZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = DLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = ONE\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL DCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  CALL DCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 )\n                  CALL DCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),\n     $               1 )\n                  SIGMA = Z( IEND, J+1 )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL DLASET( 'Full', IN, 2, ZERO, ZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL DLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in DLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    DLARRF needs LWORK = 2*N\n                     CALL DLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),\n     $                         WORK( INDWRK ), IINFO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by DLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = SSIGMA\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(DBLE(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL DLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL DLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL DSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of DLARRV\n*\n      END\n", "*> \\brief \\b SLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download SLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       REAL              Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> SLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by SLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is REAL\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is REAL\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. \n*>          Note: VU is currently not used by this implementation of SLARRV, VU is\n*>          passed to SLARRV because it could be used compute gaps on the right end\n*>          of the extremal eigenvalues. However, with not much initial accuracy in\n*>          LAMBDA and VU, the formula can lead to an overestimation of the right gap\n*>          and thus to inadequately early RQI 'convergence'. This is currently\n*>          prevented this by forcing a small right gap. And so it turns out that VU\n*>          is currently not used by this implementation of SLARRV.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is REAL array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is REAL array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by SLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is REAL\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is REAL\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is REAL array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from SLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is REAL array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is REAL array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is REAL array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is REAL array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is REAL array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in SLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in SLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in SLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in SLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup realOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      REAL              Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      REAL               ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,\n     $                     TWO = 2.0E0, THREE = 3.0E0,\n     $                     FOUR = 4.0E0, HALF = 0.5E0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      REAL               BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      REAL              SLAMCH\n      EXTERNAL           SLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           SCOPY, SLAR1V, SLARRB, SLARRF, SLASET,\n     $                   SSCAL\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, REAL, MAX, MIN\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( N.LE.0 ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDWRK= 3*N+1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL SLASET( 'Full', N, ZUSEDW, ZERO, ZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = SLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = ONE\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL SCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  CALL SCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 )\n                  CALL SCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),\n     $               1 )\n                  SIGMA = Z( IEND, J+1 )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL SLASET( 'Full', IN, 2, ZERO, ZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL SLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in SLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    SLARRF needs LWORK = 2*N\n                     CALL SLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),\n     $                         WORK( INDWRK ), IINFO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by SLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = SSIGMA\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(REAL(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL SLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL SLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL SSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of SLARRV\n*\n      END\n", "*> \\brief \\b ZLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download ZLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE ZLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       COMPLEX*16        Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> ZLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by DLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is DOUBLE PRECISION\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is DOUBLE PRECISION\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by DLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is DOUBLE PRECISION\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is DOUBLE PRECISION\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from DLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is DOUBLE PRECISION array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is DOUBLE PRECISION array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is COMPLEX*16 array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is DOUBLE PRECISION array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in ZLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in DLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in DLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in DLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup complex16OTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE ZLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      COMPLEX*16        Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      COMPLEX*16         CZERO\n      PARAMETER          ( CZERO = ( 0.0D0, 0.0D0 ) )\n      DOUBLE PRECISION   ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,\n     $                     TWO = 2.0D0, THREE = 3.0D0,\n     $                     FOUR = 4.0D0, HALF = 0.5D0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      INTEGER            INDIN1, INDIN2\n      DOUBLE PRECISION   BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      DOUBLE PRECISION   DLAMCH\n      EXTERNAL           DLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           DCOPY, DLARRB, DLARRF, ZDSCAL, ZLAR1V,\n     $                   ZLASET\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, DBLE, MAX, MIN\n      INTRINSIC DCMPLX\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( N.LE.0 ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDIN1 = 3*N + 1\n      INDIN2 = 4*N + 1\n      INDWRK = 5*N + 1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL ZLASET( 'Full', N, ZUSEDW, CZERO, CZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = DLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = DCMPLX( ONE, ZERO )\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL DCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  DO 45 K = 1, IN - 1\n                     D( IBEGIN+K-1 ) = DBLE( Z( IBEGIN+K-1,\n     $                                 J ) )\n                     L( IBEGIN+K-1 ) = DBLE( Z( IBEGIN+K-1,\n     $                                 J+1 ) )\n   45             CONTINUE\n                  D( IEND ) = DBLE( Z( IEND, J ) )\n                  SIGMA = DBLE( Z( IEND, J+1 ) )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL ZLASET( 'Full', IN, 2, CZERO, CZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL DLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in DLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    DLARRF needs LWORK = 2*N\n                     CALL DLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         WORK( INDIN1 ), WORK( INDIN2 ),\n     $                         WORK( INDWRK ), IINFO )\n*                    In the complex case, DLARRF cannot write\n*                    the new RRR directly into Z and needs an intermediate\n*                    workspace\n                     DO 56 K = 1, IN-1\n                        Z( IBEGIN+K-1, NEWFTT ) =\n     $                     DCMPLX( WORK( INDIN1+K-1 ), ZERO )\n                        Z( IBEGIN+K-1, NEWFTT+1 ) =\n     $                     DCMPLX( WORK( INDIN2+K-1 ), ZERO )\n   56                CONTINUE\n                     Z( IEND, NEWFTT ) =\n     $                  DCMPLX( WORK( INDIN1+IN-1 ), ZERO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by DLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = DCMPLX( SSIGMA, ZERO )\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(DBLE(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL ZLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL ZLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL ZDSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of ZLARRV\n*\n      END\n"], "fixing_code": ["*> \\brief \\b CLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download CLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/clarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/clarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE CLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       COMPLEX           Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> CLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by SLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is REAL\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is REAL\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is REAL array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is REAL array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by SLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is REAL\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is REAL\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is REAL array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from SLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is REAL array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is REAL array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is REAL array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is COMPLEX array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is REAL array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in CLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in SLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in SLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in SLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup complexOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE CLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      COMPLEX           Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      COMPLEX            CZERO\n      PARAMETER          ( CZERO = ( 0.0E0, 0.0E0 ) )\n      REAL               ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,\n     $                     TWO = 2.0E0, THREE = 3.0E0,\n     $                     FOUR = 4.0E0, HALF = 0.5E0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      INTEGER            INDIN1, INDIN2\n      REAL               BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      REAL               SLAMCH\n      EXTERNAL           SLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           CLAR1V, CLASET, CSSCAL, SCOPY, SLARRB,\n     $                   SLARRF\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, REAL, MAX, MIN\n      INTRINSIC CMPLX\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( (N.LE.0).OR.(M.LE.0) ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDIN1 = 3*N + 1\n      INDIN2 = 4*N + 1\n      INDWRK = 5*N + 1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL CLASET( 'Full', N, ZUSEDW, CZERO, CZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = SLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = CMPLX( ONE, ZERO )\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL SCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  DO 45 K = 1, IN - 1\n                     D( IBEGIN+K-1 ) = REAL( Z( IBEGIN+K-1,\n     $                                 J ) )\n                     L( IBEGIN+K-1 ) = REAL( Z( IBEGIN+K-1,\n     $                                 J+1 ) )\n   45             CONTINUE\n                  D( IEND ) = REAL( Z( IEND, J ) )\n                  SIGMA = REAL( Z( IEND, J+1 ) )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL CLASET( 'Full', IN, 2, CZERO, CZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL SLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in SLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    SLARRF needs LWORK = 2*N\n                     CALL SLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         WORK( INDIN1 ), WORK( INDIN2 ),\n     $                         WORK( INDWRK ), IINFO )\n*                    In the complex case, SLARRF cannot write\n*                    the new RRR directly into Z and needs an intermediate\n*                    workspace\n                     DO 56 K = 1, IN-1\n                        Z( IBEGIN+K-1, NEWFTT ) =\n     $                     CMPLX( WORK( INDIN1+K-1 ), ZERO )\n                        Z( IBEGIN+K-1, NEWFTT+1 ) =\n     $                     CMPLX( WORK( INDIN2+K-1 ), ZERO )\n   56                CONTINUE\n                     Z( IEND, NEWFTT ) =\n     $                  CMPLX( WORK( INDIN1+IN-1 ), ZERO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by SLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = CMPLX( SSIGMA, ZERO )\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(REAL(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL CLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL CLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL CSSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of CLARRV\n*\n      END\n", "*> \\brief \\b DLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download DLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       DOUBLE PRECISION  Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> DLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by DLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is DOUBLE PRECISION\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is DOUBLE PRECISION\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. \n*>          Note: VU is currently not used by this implementation of DLARRV, VU is\n*>          passed to DLARRV because it could be used compute gaps on the right end\n*>          of the extremal eigenvalues. However, with not much initial accuracy in\n*>          LAMBDA and VU, the formula can lead to an overestimation of the right gap\n*>          and thus to inadequately early RQI 'convergence'. This is currently\n*>          prevented this by forcing a small right gap. And so it turns out that VU\n*>          is currently not used by this implementation of DLARRV.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by DLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is DOUBLE PRECISION\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is DOUBLE PRECISION\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from DLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is DOUBLE PRECISION array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is DOUBLE PRECISION array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is DOUBLE PRECISION array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in DLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in DLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in DLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in DLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup doubleOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      DOUBLE PRECISION  Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      DOUBLE PRECISION   ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,\n     $                     TWO = 2.0D0, THREE = 3.0D0,\n     $                     FOUR = 4.0D0, HALF = 0.5D0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      DOUBLE PRECISION   BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      DOUBLE PRECISION   DLAMCH\n      EXTERNAL           DLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           DCOPY, DLAR1V, DLARRB, DLARRF, DLASET,\n     $                   DSCAL\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, DBLE, MAX, MIN\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( (N.LE.0).OR.(M.LE.0) ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDWRK= 3*N+1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL DLASET( 'Full', N, ZUSEDW, ZERO, ZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = DLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = ONE\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL DCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  CALL DCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 )\n                  CALL DCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),\n     $               1 )\n                  SIGMA = Z( IEND, J+1 )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL DLASET( 'Full', IN, 2, ZERO, ZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL DLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in DLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    DLARRF needs LWORK = 2*N\n                     CALL DLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),\n     $                         WORK( INDWRK ), IINFO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by DLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = SSIGMA\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(DBLE(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL DLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL DLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL DSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of DLARRV\n*\n      END\n", "*> \\brief \\b SLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download SLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       REAL              Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> SLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by SLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is REAL\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is REAL\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. \n*>          Note: VU is currently not used by this implementation of SLARRV, VU is\n*>          passed to SLARRV because it could be used compute gaps on the right end\n*>          of the extremal eigenvalues. However, with not much initial accuracy in\n*>          LAMBDA and VU, the formula can lead to an overestimation of the right gap\n*>          and thus to inadequately early RQI 'convergence'. This is currently\n*>          prevented this by forcing a small right gap. And so it turns out that VU\n*>          is currently not used by this implementation of SLARRV.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is REAL array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is REAL array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by SLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is REAL\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is REAL\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is REAL\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is REAL array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from SLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is REAL array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is REAL array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is REAL array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is REAL array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is REAL array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in SLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in SLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in SLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in SLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup realOTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE SLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      REAL               MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      REAL               D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      REAL              Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      REAL               ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0,\n     $                     TWO = 2.0E0, THREE = 3.0E0,\n     $                     FOUR = 4.0E0, HALF = 0.5E0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      REAL               BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      REAL              SLAMCH\n      EXTERNAL           SLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           SCOPY, SLAR1V, SLARRB, SLARRF, SLASET,\n     $                   SSCAL\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, REAL, MAX, MIN\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( (N.LE.0).OR.(M.LE.0) ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDWRK= 3*N+1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL SLASET( 'Full', N, ZUSEDW, ZERO, ZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = SLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = ONE\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL SCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  CALL SCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 )\n                  CALL SCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),\n     $               1 )\n                  SIGMA = Z( IEND, J+1 )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL SLASET( 'Full', IN, 2, ZERO, ZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL SLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in SLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    SLARRF needs LWORK = 2*N\n                     CALL SLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),\n     $                         WORK( INDWRK ), IINFO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by SLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = SSIGMA\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(REAL(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL SLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL SLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL SLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL SSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of SLARRV\n*\n      END\n", "*> \\brief \\b ZLARRV computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L D LT.\n*\n*  =========== DOCUMENTATION ===========\n*\n* Online html documentation available at\n*            http://www.netlib.org/lapack/explore-html/\n*\n*> \\htmlonly\n*> Download ZLARRV + dependencies\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [TGZ]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [ZIP]</a>\n*> <a href=\"http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/zlarrv.f\">\n*> [TXT]</a>\n*> \\endhtmlonly\n*\n*  Definition:\n*  ===========\n*\n*       SUBROUTINE ZLARRV( N, VL, VU, D, L, PIVMIN,\n*                          ISPLIT, M, DOL, DOU, MINRGP,\n*                          RTOL1, RTOL2, W, WERR, WGAP,\n*                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n*                          WORK, IWORK, INFO )\n*\n*       .. Scalar Arguments ..\n*       INTEGER            DOL, DOU, INFO, LDZ, M, N\n*       DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*       ..\n*       .. Array Arguments ..\n*       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n*      $                   ISUPPZ( * ), IWORK( * )\n*       DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n*      $                   WGAP( * ), WORK( * )\n*       COMPLEX*16        Z( LDZ, * )\n*       ..\n*\n*\n*> \\par Purpose:\n*  =============\n*>\n*> \\verbatim\n*>\n*> ZLARRV computes the eigenvectors of the tridiagonal matrix\n*> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.\n*> The input eigenvalues should have been computed by DLARRE.\n*> \\endverbatim\n*\n*  Arguments:\n*  ==========\n*\n*> \\param[in] N\n*> \\verbatim\n*>          N is INTEGER\n*>          The order of the matrix.  N >= 0.\n*> \\endverbatim\n*>\n*> \\param[in] VL\n*> \\verbatim\n*>          VL is DOUBLE PRECISION\n*>          Lower bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in] VU\n*> \\verbatim\n*>          VU is DOUBLE PRECISION\n*>          Upper bound of the interval that contains the desired\n*>          eigenvalues. VL < VU. Needed to compute gaps on the left or right\n*>          end of the extremal eigenvalues in the desired RANGE.\n*> \\endverbatim\n*>\n*> \\param[in,out] D\n*> \\verbatim\n*>          D is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the N diagonal elements of the diagonal matrix D.\n*>          On exit, D may be overwritten.\n*> \\endverbatim\n*>\n*> \\param[in,out] L\n*> \\verbatim\n*>          L is DOUBLE PRECISION array, dimension (N)\n*>          On entry, the (N-1) subdiagonal elements of the unit\n*>          bidiagonal matrix L are in elements 1 to N-1 of L\n*>          (if the matrix is not split.) At the end of each block\n*>          is stored the corresponding shift as given by DLARRE.\n*>          On exit, L is overwritten.\n*> \\endverbatim\n*>\n*> \\param[in] PIVMIN\n*> \\verbatim\n*>          PIVMIN is DOUBLE PRECISION\n*>          The minimum pivot allowed in the Sturm sequence.\n*> \\endverbatim\n*>\n*> \\param[in] ISPLIT\n*> \\verbatim\n*>          ISPLIT is INTEGER array, dimension (N)\n*>          The splitting points, at which T breaks up into blocks.\n*>          The first block consists of rows/columns 1 to\n*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1\n*>          through ISPLIT( 2 ), etc.\n*> \\endverbatim\n*>\n*> \\param[in] M\n*> \\verbatim\n*>          M is INTEGER\n*>          The total number of input eigenvalues.  0 <= M <= N.\n*> \\endverbatim\n*>\n*> \\param[in] DOL\n*> \\verbatim\n*>          DOL is INTEGER\n*> \\endverbatim\n*>\n*> \\param[in] DOU\n*> \\verbatim\n*>          DOU is INTEGER\n*>          If the user wants to compute only selected eigenvectors from all\n*>          the eigenvalues supplied, he can specify an index range DOL:DOU.\n*>          Or else the setting DOL=1, DOU=M should be applied.\n*>          Note that DOL and DOU refer to the order in which the eigenvalues\n*>          are stored in W.\n*>          If the user wants to compute only selected eigenpairs, then\n*>          the columns DOL-1 to DOU+1 of the eigenvector space Z contain the\n*>          computed eigenvectors. All other columns of Z are set to zero.\n*> \\endverbatim\n*>\n*> \\param[in] MINRGP\n*> \\verbatim\n*>          MINRGP is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL1\n*> \\verbatim\n*>          RTOL1 is DOUBLE PRECISION\n*> \\endverbatim\n*>\n*> \\param[in] RTOL2\n*> \\verbatim\n*>          RTOL2 is DOUBLE PRECISION\n*>           Parameters for bisection.\n*>           An interval [LEFT,RIGHT] has converged if\n*>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )\n*> \\endverbatim\n*>\n*> \\param[in,out] W\n*> \\verbatim\n*>          W is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements of W contain the APPROXIMATE eigenvalues for\n*>          which eigenvectors are to be computed.  The eigenvalues\n*>          should be grouped by split-off block and ordered from\n*>          smallest to largest within the block ( The output array\n*>          W from DLARRE is expected here ). Furthermore, they are with\n*>          respect to the shift of the corresponding root representation\n*>          for their block. On exit, W holds the eigenvalues of the\n*>          UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[in,out] WERR\n*> \\verbatim\n*>          WERR is DOUBLE PRECISION array, dimension (N)\n*>          The first M elements contain the semiwidth of the uncertainty\n*>          interval of the corresponding eigenvalue in W\n*> \\endverbatim\n*>\n*> \\param[in,out] WGAP\n*> \\verbatim\n*>          WGAP is DOUBLE PRECISION array, dimension (N)\n*>          The separation from the right neighbor eigenvalue in W.\n*> \\endverbatim\n*>\n*> \\param[in] IBLOCK\n*> \\verbatim\n*>          IBLOCK is INTEGER array, dimension (N)\n*>          The indices of the blocks (submatrices) associated with the\n*>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue\n*>          W(i) belongs to the first block from the top, =2 if W(i)\n*>          belongs to the second block, etc.\n*> \\endverbatim\n*>\n*> \\param[in] INDEXW\n*> \\verbatim\n*>          INDEXW is INTEGER array, dimension (N)\n*>          The indices of the eigenvalues within each block (submatrix);\n*>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the\n*>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.\n*> \\endverbatim\n*>\n*> \\param[in] GERS\n*> \\verbatim\n*>          GERS is DOUBLE PRECISION array, dimension (2*N)\n*>          The N Gerschgorin intervals (the i-th Gerschgorin interval\n*>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should\n*>          be computed from the original UNshifted matrix.\n*> \\endverbatim\n*>\n*> \\param[out] Z\n*> \\verbatim\n*>          Z is COMPLEX*16 array, dimension (LDZ, max(1,M) )\n*>          If INFO = 0, the first M columns of Z contain the\n*>          orthonormal eigenvectors of the matrix T\n*>          corresponding to the input eigenvalues, with the i-th\n*>          column of Z holding the eigenvector associated with W(i).\n*>          Note: the user must ensure that at least max(1,M) columns are\n*>          supplied in the array Z.\n*> \\endverbatim\n*>\n*> \\param[in] LDZ\n*> \\verbatim\n*>          LDZ is INTEGER\n*>          The leading dimension of the array Z.  LDZ >= 1, and if\n*>          JOBZ = 'V', LDZ >= max(1,N).\n*> \\endverbatim\n*>\n*> \\param[out] ISUPPZ\n*> \\verbatim\n*>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )\n*>          The support of the eigenvectors in Z, i.e., the indices\n*>          indicating the nonzero elements in Z. The I-th eigenvector\n*>          is nonzero only in elements ISUPPZ( 2*I-1 ) through\n*>          ISUPPZ( 2*I ).\n*> \\endverbatim\n*>\n*> \\param[out] WORK\n*> \\verbatim\n*>          WORK is DOUBLE PRECISION array, dimension (12*N)\n*> \\endverbatim\n*>\n*> \\param[out] IWORK\n*> \\verbatim\n*>          IWORK is INTEGER array, dimension (7*N)\n*> \\endverbatim\n*>\n*> \\param[out] INFO\n*> \\verbatim\n*>          INFO is INTEGER\n*>          = 0:  successful exit\n*>\n*>          > 0:  A problem occurred in ZLARRV.\n*>          < 0:  One of the called subroutines signaled an internal problem.\n*>                Needs inspection of the corresponding parameter IINFO\n*>                for further information.\n*>\n*>          =-1:  Problem in DLARRB when refining a child's eigenvalues.\n*>          =-2:  Problem in DLARRF when computing the RRR of a child.\n*>                When a child is inside a tight cluster, it can be difficult\n*>                to find an RRR. A partial remedy from the user's point of\n*>                view is to make the parameter MINRGP smaller and recompile.\n*>                However, as the orthogonality of the computed vectors is\n*>                proportional to 1/MINRGP, the user should be aware that\n*>                he might be trading in precision when he decreases MINRGP.\n*>          =-3:  Problem in DLARRB when refining a single eigenvalue\n*>                after the Rayleigh correction was rejected.\n*>          = 5:  The Rayleigh Quotient Iteration failed to converge to\n*>                full accuracy in MAXITR steps.\n*> \\endverbatim\n*\n*  Authors:\n*  ========\n*\n*> \\author Univ. of Tennessee\n*> \\author Univ. of California Berkeley\n*> \\author Univ. of Colorado Denver\n*> \\author NAG Ltd.\n*\n*> \\ingroup complex16OTHERauxiliary\n*\n*> \\par Contributors:\n*  ==================\n*>\n*> Beresford Parlett, University of California, Berkeley, USA \\n\n*> Jim Demmel, University of California, Berkeley, USA \\n\n*> Inderjit Dhillon, University of Texas, Austin, USA \\n\n*> Osni Marques, LBNL/NERSC, USA \\n\n*> Christof Voemel, University of California, Berkeley, USA\n*\n*  =====================================================================\n      SUBROUTINE ZLARRV( N, VL, VU, D, L, PIVMIN,\n     $                   ISPLIT, M, DOL, DOU, MINRGP,\n     $                   RTOL1, RTOL2, W, WERR, WGAP,\n     $                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK auxiliary routine --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*\n*     .. Scalar Arguments ..\n      INTEGER            DOL, DOU, INFO, LDZ, M, N\n      DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),\n     $                   ISUPPZ( * ), IWORK( * )\n      DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),\n     $                   WGAP( * ), WORK( * )\n      COMPLEX*16        Z( LDZ, * )\n*     ..\n*\n*  =====================================================================\n*\n*     .. Parameters ..\n      INTEGER            MAXITR\n      PARAMETER          ( MAXITR = 10 )\n      COMPLEX*16         CZERO\n      PARAMETER          ( CZERO = ( 0.0D0, 0.0D0 ) )\n      DOUBLE PRECISION   ZERO, ONE, TWO, THREE, FOUR, HALF\n      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,\n     $                     TWO = 2.0D0, THREE = 3.0D0,\n     $                     FOUR = 4.0D0, HALF = 0.5D0)\n*     ..\n*     .. Local Scalars ..\n      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ\n      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,\n     $                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,\n     $                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,\n     $                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS,\n     $                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,\n     $                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,\n     $                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,\n     $                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,\n     $                   ZUSEDW\n      INTEGER            INDIN1, INDIN2\n      DOUBLE PRECISION   BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU,\n     $                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,\n     $                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,\n     $                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ\n*     ..\n*     .. External Functions ..\n      DOUBLE PRECISION   DLAMCH\n      EXTERNAL           DLAMCH\n*     ..\n*     .. External Subroutines ..\n      EXTERNAL           DCOPY, DLARRB, DLARRF, ZDSCAL, ZLAR1V,\n     $                   ZLASET\n*     ..\n*     .. Intrinsic Functions ..\n      INTRINSIC ABS, DBLE, MAX, MIN\n      INTRINSIC DCMPLX\n*     ..\n*     .. Executable Statements ..\n*     ..\n\n      INFO = 0\n*\n*     Quick return if possible\n*\n      IF( (N.LE.0).OR.(M.LE.0) ) THEN\n         RETURN\n      END IF\n*\n*     The first N entries of WORK are reserved for the eigenvalues\n      INDLD = N+1\n      INDLLD= 2*N+1\n      INDIN1 = 3*N + 1\n      INDIN2 = 4*N + 1\n      INDWRK = 5*N + 1\n      MINWSIZE = 12 * N\n\n      DO 5 I= 1,MINWSIZE\n         WORK( I ) = ZERO\n 5    CONTINUE\n\n*     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the\n*     factorization used to compute the FP vector\n      IINDR = 0\n*     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the current\n*     layer and the one above.\n      IINDC1 = N\n      IINDC2 = 2*N\n      IINDWK = 3*N + 1\n\n      MINIWSIZE = 7 * N\n      DO 10 I= 1,MINIWSIZE\n         IWORK( I ) = 0\n 10   CONTINUE\n\n      ZUSEDL = 1\n      IF(DOL.GT.1) THEN\n*        Set lower bound for use of Z\n         ZUSEDL = DOL-1\n      ENDIF\n      ZUSEDU = M\n      IF(DOU.LT.M) THEN\n*        Set lower bound for use of Z\n         ZUSEDU = DOU+1\n      ENDIF\n*     The width of the part of Z that is used\n      ZUSEDW = ZUSEDU - ZUSEDL + 1\n\n\n      CALL ZLASET( 'Full', N, ZUSEDW, CZERO, CZERO,\n     $                    Z(1,ZUSEDL), LDZ )\n\n      EPS = DLAMCH( 'Precision' )\n      RQTOL = TWO * EPS\n*\n*     Set expert flags for standard code.\n      TRYRQC = .TRUE.\n\n      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n      ELSE\n*        Only selected eigenpairs are computed. Since the other evalues\n*        are not refined by RQ iteration, bisection has to compute to full\n*        accuracy.\n         RTOL1 = FOUR * EPS\n         RTOL2 = FOUR * EPS\n      ENDIF\n\n*     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the\n*     desired eigenvalues. The support of the nonzero eigenvector\n*     entries is contained in the interval IBEGIN:IEND.\n*     Remark that if k eigenpairs are desired, then the eigenvectors\n*     are stored in k contiguous columns of Z.\n\n*     DONE is the number of eigenvectors already computed\n      DONE = 0\n      IBEGIN = 1\n      WBEGIN = 1\n      DO 170 JBLK = 1, IBLOCK( M )\n         IEND = ISPLIT( JBLK )\n         SIGMA = L( IEND )\n*        Find the eigenvectors of the submatrix indexed IBEGIN\n*        through IEND.\n         WEND = WBEGIN - 1\n 15      CONTINUE\n         IF( WEND.LT.M ) THEN\n            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN\n               WEND = WEND + 1\n               GO TO 15\n            END IF\n         END IF\n         IF( WEND.LT.WBEGIN ) THEN\n            IBEGIN = IEND + 1\n            GO TO 170\n         ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN\n            IBEGIN = IEND + 1\n            WBEGIN = WEND + 1\n            GO TO 170\n         END IF\n\n*        Find local spectral diameter of the block\n         GL = GERS( 2*IBEGIN-1 )\n         GU = GERS( 2*IBEGIN )\n         DO 20 I = IBEGIN+1 , IEND\n            GL = MIN( GERS( 2*I-1 ), GL )\n            GU = MAX( GERS( 2*I ), GU )\n 20      CONTINUE\n         SPDIAM = GU - GL\n\n*        OLDIEN is the last index of the previous block\n         OLDIEN = IBEGIN - 1\n*        Calculate the size of the current block\n         IN = IEND - IBEGIN + 1\n*        The number of eigenvalues in the current block\n         IM = WEND - WBEGIN + 1\n\n*        This is for a 1x1 block\n         IF( IBEGIN.EQ.IEND ) THEN\n            DONE = DONE+1\n            Z( IBEGIN, WBEGIN ) = DCMPLX( ONE, ZERO )\n            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN\n            ISUPPZ( 2*WBEGIN ) = IBEGIN\n            W( WBEGIN ) = W( WBEGIN ) + SIGMA\n            WORK( WBEGIN ) = W( WBEGIN )\n            IBEGIN = IEND + 1\n            WBEGIN = WBEGIN + 1\n            GO TO 170\n         END IF\n\n*        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND)\n*        Note that these can be approximations, in this case, the corresp.\n*        entries of WERR give the size of the uncertainty interval.\n*        The eigenvalue approximations will be refined when necessary as\n*        high relative accuracy is required for the computation of the\n*        corresponding eigenvectors.\n         CALL DCOPY( IM, W( WBEGIN ), 1,\n     $                   WORK( WBEGIN ), 1 )\n\n*        We store in W the eigenvalue approximations w.r.t. the original\n*        matrix T.\n         DO 30 I=1,IM\n            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA\n 30      CONTINUE\n\n\n*        NDEPTH is the current depth of the representation tree\n         NDEPTH = 0\n*        PARITY is either 1 or 0\n         PARITY = 1\n*        NCLUS is the number of clusters for the next level of the\n*        representation tree, we start with NCLUS = 1 for the root\n         NCLUS = 1\n         IWORK( IINDC1+1 ) = 1\n         IWORK( IINDC1+2 ) = IM\n\n*        IDONE is the number of eigenvectors already computed in the current\n*        block\n         IDONE = 0\n*        loop while( IDONE.LT.IM )\n*        generate the representation tree for the current block and\n*        compute the eigenvectors\n   40    CONTINUE\n         IF( IDONE.LT.IM ) THEN\n*           This is a crude protection against infinitely deep trees\n            IF( NDEPTH.GT.M ) THEN\n               INFO = -2\n               RETURN\n            ENDIF\n*           breadth first processing of the current level of the representation\n*           tree: OLDNCL = number of clusters on current level\n            OLDNCL = NCLUS\n*           reset NCLUS to count the number of child clusters\n            NCLUS = 0\n*\n            PARITY = 1 - PARITY\n            IF( PARITY.EQ.0 ) THEN\n               OLDCLS = IINDC1\n               NEWCLS = IINDC2\n            ELSE\n               OLDCLS = IINDC2\n               NEWCLS = IINDC1\n            END IF\n*           Process the clusters on the current level\n            DO 150 I = 1, OLDNCL\n               J = OLDCLS + 2*I\n*              OLDFST, OLDLST = first, last index of current cluster.\n*                               cluster indices start with 1 and are relative\n*                               to WBEGIN when accessing W, WGAP, WERR, Z\n               OLDFST = IWORK( J-1 )\n               OLDLST = IWORK( J )\n               IF( NDEPTH.GT.0 ) THEN\n*                 Retrieve relatively robust representation (RRR) of cluster\n*                 that has been computed at the previous level\n*                 The RRR is stored in Z and overwritten once the eigenvectors\n*                 have been computed or when the cluster is refined\n\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Get representation from location of the leftmost evalue\n*                    of the cluster\n                     J = WBEGIN + OLDFST - 1\n                  ELSE\n                     IF(WBEGIN+OLDFST-1.LT.DOL) THEN\n*                       Get representation from the left end of Z array\n                        J = DOL - 1\n                     ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN\n*                       Get representation from the right end of Z array\n                        J = DOU\n                     ELSE\n                        J = WBEGIN + OLDFST - 1\n                     ENDIF\n                  ENDIF\n                  DO 45 K = 1, IN - 1\n                     D( IBEGIN+K-1 ) = DBLE( Z( IBEGIN+K-1,\n     $                                 J ) )\n                     L( IBEGIN+K-1 ) = DBLE( Z( IBEGIN+K-1,\n     $                                 J+1 ) )\n   45             CONTINUE\n                  D( IEND ) = DBLE( Z( IEND, J ) )\n                  SIGMA = DBLE( Z( IEND, J+1 ) )\n\n*                 Set the corresponding entries in Z to zero\n                  CALL ZLASET( 'Full', IN, 2, CZERO, CZERO,\n     $                         Z( IBEGIN, J), LDZ )\n               END IF\n\n*              Compute DL and DLL of current RRR\n               DO 50 J = IBEGIN, IEND-1\n                  TMP = D( J )*L( J )\n                  WORK( INDLD-1+J ) = TMP\n                  WORK( INDLLD-1+J ) = TMP*L( J )\n   50          CONTINUE\n\n               IF( NDEPTH.GT.0 ) THEN\n*                 P and Q are index of the first and last eigenvalue to compute\n*                 within the current block\n                  P = INDEXW( WBEGIN-1+OLDFST )\n                  Q = INDEXW( WBEGIN-1+OLDLST )\n*                 Offset for the arrays WORK, WGAP and WERR, i.e., the P-OFFSET\n*                 through the Q-OFFSET elements of these arrays are to be used.\n*                  OFFSET = P-OLDFST\n                  OFFSET = INDEXW( WBEGIN ) - 1\n*                 perform limited bisection (if necessary) to get approximate\n*                 eigenvalues to the precision needed.\n                  CALL DLARRB( IN, D( IBEGIN ),\n     $                         WORK(INDLLD+IBEGIN-1),\n     $                         P, Q, RTOL1, RTOL2, OFFSET,\n     $                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),\n     $                         WORK( INDWRK ), IWORK( IINDWK ),\n     $                         PIVMIN, SPDIAM, IN, IINFO )\n                  IF( IINFO.NE.0 ) THEN\n                     INFO = -1\n                     RETURN\n                  ENDIF\n*                 We also recompute the extremal gaps. W holds all eigenvalues\n*                 of the unshifted matrix and must be used for computation\n*                 of WGAP, the entries of WORK might stem from RRRs with\n*                 different shifts. The gaps from WBEGIN-1+OLDFST to\n*                 WBEGIN-1+OLDLST are correctly computed in DLARRB.\n*                 However, we only allow the gaps to become greater since\n*                 this is what should happen when we decrease WERR\n                  IF( OLDFST.GT.1) THEN\n                     WGAP( WBEGIN+OLDFST-2 ) =\n     $             MAX(WGAP(WBEGIN+OLDFST-2),\n     $                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)\n     $                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )\n                  ENDIF\n                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN\n                     WGAP( WBEGIN+OLDLST-1 ) =\n     $               MAX(WGAP(WBEGIN+OLDLST-1),\n     $                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)\n     $                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )\n                  ENDIF\n*                 Each time the eigenvalues in WORK get refined, we store\n*                 the newly found approximation with all shifts applied in W\n                  DO 53 J=OLDFST,OLDLST\n                     W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA\n 53               CONTINUE\n               END IF\n\n*              Process the current node.\n               NEWFST = OLDFST\n               DO 140 J = OLDFST, OLDLST\n                  IF( J.EQ.OLDLST ) THEN\n*                    we are at the right end of the cluster, this is also the\n*                    boundary of the child cluster\n                     NEWLST = J\n                  ELSE IF ( WGAP( WBEGIN + J -1).GE.\n     $                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN\n*                    the right relative gap is big enough, the child cluster\n*                    (NEWFST,..,NEWLST) is well separated from the following\n                     NEWLST = J\n                   ELSE\n*                    inside a child cluster, the relative gap is not\n*                    big enough.\n                     GOTO 140\n                  END IF\n\n*                 Compute size of child cluster found\n                  NEWSIZ = NEWLST - NEWFST + 1\n\n*                 NEWFTT is the place in Z where the new RRR or the computed\n*                 eigenvector is to be stored\n                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN\n*                    Store representation at location of the leftmost evalue\n*                    of the cluster\n                     NEWFTT = WBEGIN + NEWFST - 1\n                  ELSE\n                     IF(WBEGIN+NEWFST-1.LT.DOL) THEN\n*                       Store representation at the left end of Z array\n                        NEWFTT = DOL - 1\n                     ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN\n*                       Store representation at the right end of Z array\n                        NEWFTT = DOU\n                     ELSE\n                        NEWFTT = WBEGIN + NEWFST - 1\n                     ENDIF\n                  ENDIF\n\n                  IF( NEWSIZ.GT.1) THEN\n*\n*                    Current child is not a singleton but a cluster.\n*                    Compute and store new representation of child.\n*\n*\n*                    Compute left and right cluster gap.\n*\n*                    LGAP and RGAP are not computed from WORK because\n*                    the eigenvalue approximations may stem from RRRs\n*                    different shifts. However, W hold all eigenvalues\n*                    of the unshifted matrix. Still, the entries in WGAP\n*                    have to be computed from WORK since the entries\n*                    in W might be of the same order so that gaps are not\n*                    exhibited correctly for very close eigenvalues.\n                     IF( NEWFST.EQ.1 ) THEN\n                        LGAP = MAX( ZERO,\n     $                       W(WBEGIN)-WERR(WBEGIN) - VL )\n                    ELSE\n                        LGAP = WGAP( WBEGIN+NEWFST-2 )\n                     ENDIF\n                     RGAP = WGAP( WBEGIN+NEWLST-1 )\n*\n*                    Compute left- and rightmost eigenvalue of child\n*                    to high precision in order to shift as close\n*                    as possible and obtain as large relative gaps\n*                    as possible\n*\n                     DO 55 K =1,2\n                        IF(K.EQ.1) THEN\n                           P = INDEXW( WBEGIN-1+NEWFST )\n                        ELSE\n                           P = INDEXW( WBEGIN-1+NEWLST )\n                        ENDIF\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK( INDLLD+IBEGIN-1 ),P,P,\n     $                       RQTOL, RQTOL, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       IN, IINFO )\n 55                  CONTINUE\n*\n                     IF((WBEGIN+NEWLST-1.LT.DOL).OR.\n     $                  (WBEGIN+NEWFST-1.GT.DOU)) THEN\n*                       if the cluster contains no desired eigenvalues\n*                       skip the computation of that branch of the rep. tree\n*\n*                       We could skip before the refinement of the extremal\n*                       eigenvalues of the child, but then the representation\n*                       tree could be different from the one when nothing is\n*                       skipped. For this reason we skip at this place.\n                        IDONE = IDONE + NEWLST - NEWFST + 1\n                        GOTO 139\n                     ENDIF\n*\n*                    Compute RRR of child cluster.\n*                    Note that the new RRR is stored in Z\n*\n*                    DLARRF needs LWORK = 2*N\n                     CALL DLARRF( IN, D( IBEGIN ), L( IBEGIN ),\n     $                         WORK(INDLD+IBEGIN-1),\n     $                         NEWFST, NEWLST, WORK(WBEGIN),\n     $                         WGAP(WBEGIN), WERR(WBEGIN),\n     $                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,\n     $                         WORK( INDIN1 ), WORK( INDIN2 ),\n     $                         WORK( INDWRK ), IINFO )\n*                    In the complex case, DLARRF cannot write\n*                    the new RRR directly into Z and needs an intermediate\n*                    workspace\n                     DO 56 K = 1, IN-1\n                        Z( IBEGIN+K-1, NEWFTT ) =\n     $                     DCMPLX( WORK( INDIN1+K-1 ), ZERO )\n                        Z( IBEGIN+K-1, NEWFTT+1 ) =\n     $                     DCMPLX( WORK( INDIN2+K-1 ), ZERO )\n   56                CONTINUE\n                     Z( IEND, NEWFTT ) =\n     $                  DCMPLX( WORK( INDIN1+IN-1 ), ZERO )\n                     IF( IINFO.EQ.0 ) THEN\n*                       a new RRR for the cluster was found by DLARRF\n*                       update shift and store it\n                        SSIGMA = SIGMA + TAU\n                        Z( IEND, NEWFTT+1 ) = DCMPLX( SSIGMA, ZERO )\n*                       WORK() are the midpoints and WERR() the semi-width\n*                       Note that the entries in W are unchanged.\n                        DO 116 K = NEWFST, NEWLST\n                           FUDGE =\n     $                          THREE*EPS*ABS(WORK(WBEGIN+K-1))\n                           WORK( WBEGIN + K - 1 ) =\n     $                          WORK( WBEGIN + K - 1) - TAU\n                           FUDGE = FUDGE +\n     $                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))\n*                          Fudge errors\n                           WERR( WBEGIN + K - 1 ) =\n     $                          WERR( WBEGIN + K - 1 ) + FUDGE\n*                          Gaps are not fudged. Provided that WERR is small\n*                          when eigenvalues are close, a zero gap indicates\n*                          that a new representation is needed for resolving\n*                          the cluster. A fudge could lead to a wrong decision\n*                          of judging eigenvalues 'separated' which in\n*                          reality are not. This could have a negative impact\n*                          on the orthogonality of the computed eigenvectors.\n 116                    CONTINUE\n\n                        NCLUS = NCLUS + 1\n                        K = NEWCLS + 2*NCLUS\n                        IWORK( K-1 ) = NEWFST\n                        IWORK( K ) = NEWLST\n                     ELSE\n                        INFO = -2\n                        RETURN\n                     ENDIF\n                  ELSE\n*\n*                    Compute eigenvector of singleton\n*\n                     ITER = 0\n*\n                     TOL = FOUR * LOG(DBLE(IN)) * EPS\n*\n                     K = NEWFST\n                     WINDEX = WBEGIN + K - 1\n                     WINDMN = MAX(WINDEX - 1,1)\n                     WINDPL = MIN(WINDEX + 1,M)\n                     LAMBDA = WORK( WINDEX )\n                     DONE = DONE + 1\n*                    Check if eigenvector computation is to be skipped\n                     IF((WINDEX.LT.DOL).OR.\n     $                  (WINDEX.GT.DOU)) THEN\n                        ESKIP = .TRUE.\n                        GOTO 125\n                     ELSE\n                        ESKIP = .FALSE.\n                     ENDIF\n                     LEFT = WORK( WINDEX ) - WERR( WINDEX )\n                     RIGHT = WORK( WINDEX ) + WERR( WINDEX )\n                     INDEIG = INDEXW( WINDEX )\n*                    Note that since we compute the eigenpairs for a child,\n*                    all eigenvalue approximations are w.r.t the same shift.\n*                    In this case, the entries in WORK should be used for\n*                    computing the gaps since they exhibit even very small\n*                    differences in the eigenvalues, as opposed to the\n*                    entries in W which might \"look\" the same.\n\n                     IF( K .EQ. 1) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VL, the formula\n*                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )\n*                       can lead to an overestimation of the left gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small left gap.\n                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        LGAP = WGAP(WINDMN)\n                     ENDIF\n                     IF( K .EQ. IM) THEN\n*                       In the case RANGE='I' and with not much initial\n*                       accuracy in LAMBDA and VU, the formula\n*                       can lead to an overestimation of the right gap and\n*                       thus to inadequately early RQI 'convergence'.\n*                       Prevent this by forcing a small right gap.\n                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT))\n                     ELSE\n                        RGAP = WGAP(WINDEX)\n                     ENDIF\n                     GAP = MIN( LGAP, RGAP )\n                     IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN\n*                       The eigenvector support can become wrong\n*                       because significant entries could be cut off due to a\n*                       large GAPTOL parameter in LAR1V. Prevent this.\n                        GAPTOL = ZERO\n                     ELSE\n                        GAPTOL = GAP * EPS\n                     ENDIF\n                     ISUPMN = IN\n                     ISUPMX = 1\n*                    Update WGAP so that it holds the minimum gap\n*                    to the left or the right. This is crucial in the\n*                    case where bisection is used to ensure that the\n*                    eigenvalue is refined up to the required precision.\n*                    The correct value is restored afterwards.\n                     SAVGAP = WGAP(WINDEX)\n                     WGAP(WINDEX) = GAP\n*                    We want to use the Rayleigh Quotient Correction\n*                    as often as possible since it converges quadratically\n*                    when we are close enough to the desired eigenvalue.\n*                    However, the Rayleigh Quotient can have the wrong sign\n*                    and lead us away from the desired eigenvalue. In this\n*                    case, the best we can do is to use bisection.\n                     USEDBS = .FALSE.\n                     USEDRQ = .FALSE.\n*                    Bisection is initially turned off unless it is forced\n                     NEEDBS =  .NOT.TRYRQC\n 120                 CONTINUE\n*                    Check if bisection should be used to refine eigenvalue\n                     IF(NEEDBS) THEN\n*                       Take the bisection as new iterate\n                        USEDBS = .TRUE.\n                        ITMP1 = IWORK( IINDR+WINDEX )\n                        OFFSET = INDEXW( WBEGIN ) - 1\n                        CALL DLARRB( IN, D(IBEGIN),\n     $                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,\n     $                       ZERO, TWO*EPS, OFFSET,\n     $                       WORK(WBEGIN),WGAP(WBEGIN),\n     $                       WERR(WBEGIN),WORK( INDWRK ),\n     $                       IWORK( IINDWK ), PIVMIN, SPDIAM,\n     $                       ITMP1, IINFO )\n                        IF( IINFO.NE.0 ) THEN\n                           INFO = -3\n                           RETURN\n                        ENDIF\n                        LAMBDA = WORK( WINDEX )\n*                       Reset twist index from inaccurate LAMBDA to\n*                       force computation of true MINGMA\n                        IWORK( IINDR+WINDEX ) = 0\n                     ENDIF\n*                    Given LAMBDA, compute the eigenvector.\n                     CALL ZLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),\n     $                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),\n     $                    WORK(INDLLD+IBEGIN-1),\n     $                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),\n     $                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                     IF(ITER .EQ. 0) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ELSEIF(RESID.LT.BSTRES) THEN\n                        BSTRES = RESID\n                        BSTW = LAMBDA\n                     ENDIF\n                     ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 ))\n                     ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX ))\n                     ITER = ITER + 1\n\n*                    sin alpha <= |resid|/gap\n*                    Note that both the residual and the gap are\n*                    proportional to the matrix, so ||T|| doesn't play\n*                    a role in the quotient\n\n*\n*                    Convergence test for Rayleigh-Quotient iteration\n*                    (omitted when Bisection has been used)\n*\n                     IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.\n     $                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)\n     $                    THEN\n*                       We need to check that the RQCORR update doesn't\n*                       move the eigenvalue away from the desired one and\n*                       towards a neighbor. -> protection with bisection\n                        IF(INDEIG.LE.NEGCNT) THEN\n*                          The wanted eigenvalue lies to the left\n                           SGNDEF = -ONE\n                        ELSE\n*                          The wanted eigenvalue lies to the right\n                           SGNDEF = ONE\n                        ENDIF\n*                       We only use the RQCORR if it improves the\n*                       the iterate reasonably.\n                        IF( ( RQCORR*SGNDEF.GE.ZERO )\n     $                       .AND.( LAMBDA + RQCORR.LE. RIGHT)\n     $                       .AND.( LAMBDA + RQCORR.GE. LEFT)\n     $                       ) THEN\n                           USEDRQ = .TRUE.\n*                          Store new midpoint of bisection interval in WORK\n                           IF(SGNDEF.EQ.ONE) THEN\n*                             The current LAMBDA is on the left of the true\n*                             eigenvalue\n                              LEFT = LAMBDA\n*                             We prefer to assume that the error estimate\n*                             is correct. We could make the interval not\n*                             as a bracket but to be modified if the RQCORR\n*                             chooses to. In this case, the RIGHT side should\n*                             be modified as follows:\n*                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)\n                           ELSE\n*                             The current LAMBDA is on the right of the true\n*                             eigenvalue\n                              RIGHT = LAMBDA\n*                             See comment about assuming the error estimate is\n*                             correct above.\n*                              LEFT = MIN(LEFT, LAMBDA + RQCORR)\n                           ENDIF\n                           WORK( WINDEX ) =\n     $                       HALF * (RIGHT + LEFT)\n*                          Take RQCORR since it has the correct sign and\n*                          improves the iterate reasonably\n                           LAMBDA = LAMBDA + RQCORR\n*                          Update width of error interval\n                           WERR( WINDEX ) =\n     $                             HALF * (RIGHT-LEFT)\n                        ELSE\n                           NEEDBS = .TRUE.\n                        ENDIF\n                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN\n*                             The eigenvalue is computed to bisection accuracy\n*                             compute eigenvector and stop\n                           USEDBS = .TRUE.\n                           GOTO 120\n                        ELSEIF( ITER.LT.MAXITR ) THEN\n                           GOTO 120\n                        ELSEIF( ITER.EQ.MAXITR ) THEN\n                           NEEDBS = .TRUE.\n                           GOTO 120\n                        ELSE\n                           INFO = 5\n                           RETURN\n                        END IF\n                     ELSE\n                        STP2II = .FALSE.\n        IF(USEDRQ .AND. USEDBS .AND.\n     $                     BSTRES.LE.RESID) THEN\n                           LAMBDA = BSTW\n                           STP2II = .TRUE.\n                        ENDIF\n                        IF (STP2II) THEN\n*                          improve error angle by second step\n                           CALL ZLAR1V( IN, 1, IN, LAMBDA,\n     $                          D( IBEGIN ), L( IBEGIN ),\n     $                          WORK(INDLD+IBEGIN-1),\n     $                          WORK(INDLLD+IBEGIN-1),\n     $                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),\n     $                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,\n     $                          IWORK( IINDR+WINDEX ),\n     $                          ISUPPZ( 2*WINDEX-1 ),\n     $                          NRMINV, RESID, RQCORR, WORK( INDWRK ) )\n                        ENDIF\n                        WORK( WINDEX ) = LAMBDA\n                     END IF\n*\n*                    Compute FP-vector support w.r.t. whole matrix\n*\n                     ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN\n                     ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN\n                     ZFROM = ISUPPZ( 2*WINDEX-1 )\n                     ZTO = ISUPPZ( 2*WINDEX )\n                     ISUPMN = ISUPMN + OLDIEN\n                     ISUPMX = ISUPMX + OLDIEN\n*                    Ensure vector is ok if support in the RQI has changed\n                     IF(ISUPMN.LT.ZFROM) THEN\n                        DO 122 II = ISUPMN,ZFROM-1\n                           Z( II, WINDEX ) = ZERO\n 122                    CONTINUE\n                     ENDIF\n                     IF(ISUPMX.GT.ZTO) THEN\n                        DO 123 II = ZTO+1,ISUPMX\n                           Z( II, WINDEX ) = ZERO\n 123                    CONTINUE\n                     ENDIF\n                     CALL ZDSCAL( ZTO-ZFROM+1, NRMINV,\n     $                       Z( ZFROM, WINDEX ), 1 )\n 125                 CONTINUE\n*                    Update W\n                     W( WINDEX ) = LAMBDA+SIGMA\n*                    Recompute the gaps on the left and right\n*                    But only allow them to become larger and not\n*                    smaller (which can only happen through \"bad\"\n*                    cancellation and doesn't reflect the theory\n*                    where the initial gaps are underestimated due\n*                    to WERR being too crude.)\n                     IF(.NOT.ESKIP) THEN\n                        IF( K.GT.1) THEN\n                           WGAP( WINDMN ) = MAX( WGAP(WINDMN),\n     $                          W(WINDEX)-WERR(WINDEX)\n     $                          - W(WINDMN)-WERR(WINDMN) )\n                        ENDIF\n                        IF( WINDEX.LT.WEND ) THEN\n                           WGAP( WINDEX ) = MAX( SAVGAP,\n     $                          W( WINDPL )-WERR( WINDPL )\n     $                          - W( WINDEX )-WERR( WINDEX) )\n                        ENDIF\n                     ENDIF\n                     IDONE = IDONE + 1\n                  ENDIF\n*                 here ends the code for the current child\n*\n 139              CONTINUE\n*                 Proceed to any remaining child nodes\n                  NEWFST = J + 1\n 140           CONTINUE\n 150        CONTINUE\n            NDEPTH = NDEPTH + 1\n            GO TO 40\n         END IF\n         IBEGIN = IEND + 1\n         WBEGIN = WEND + 1\n 170  CONTINUE\n*\n\n      RETURN\n*\n*     End of ZLARRV\n*\n      END\n"], "filenames": ["SRC/clarrv.f", "SRC/dlarrv.f", "SRC/slarrv.f", "SRC/zlarrv.f"], "buggy_code_start_loc": [351, 353, 353, 351], "buggy_code_end_loc": [352, 354, 354, 352], "fixing_code_start_loc": [351, 353, 353, 351], "fixing_code_end_loc": [352, 354, 354, 352], "type": "CWE-125", "message": "An out-of-bounds read flaw was found in the CLARRV, DLARRV, SLARRV, and ZLARRV functions in lapack through version 3.10.0, as also used in OpenBLAS before version 0.3.18. Specially crafted inputs passed to these functions could cause an application using lapack to crash or possibly disclose portions of its memory.", "other": {"cve": {"id": "CVE-2021-4048", "sourceIdentifier": "secalert@redhat.com", "published": "2021-12-08T22:15:10.220", "lastModified": "2022-01-04T16:09:22.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds read flaw was found in the CLARRV, DLARRV, SLARRV, and ZLARRV functions in lapack through version 3.10.0, as also used in OpenBLAS before version 0.3.18. Specially crafted inputs passed to these functions could cause an application using lapack to crash or possibly disclose portions of its memory."}, {"lang": "es", "value": "Se ha encontrado un fallo de lectura fuera de l\u00edmites en las funciones CLARRV, DLARRV, SLARRV y ZLARRV de lapack versiones hasta 3.10.0, usadas tambi\u00e9n en OpenBLAS versiones anteriores a 0.3.18. Las entradas especialmente dise\u00f1adas que se pasan a estas funciones podr\u00edan causar que una aplicaci\u00f3n que use lapack se bloquee o posiblemente revele partes de su memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lapack_project:lapack:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.10.0", "matchCriteriaId": "860F1070-052A-491D-AF07-7179ABFF53DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openblas_project:openblas:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.18", "matchCriteriaId": "8C8DAA17-150E-4182-ADD1-4317FD35ED9D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.6.3", "matchCriteriaId": "50A99E6E-EE4D-443C-AEB3-C141F6CF2266"}, {"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:1.7.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "24F54DC9-8AC4-4578-B9B2-ECED81AA515B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:1.7.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "FA4C5004-D212-444C-82B5-2A4B013E0442"}, {"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:1.7.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "C3B59E6B-37B8-461B-9701-1FD3CCC15014"}, {"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:1.7.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "DF1A3614-9C2C-4604-BC11-046866C656EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:julialang:julia:1.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "2AD33935-9843-4F09-B5D9-A6C3D86E1022"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "D07DF15E-FE6B-4DAF-99BB-2147CF7D7EEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "516F4E8E-ED2F-4282-9DAB-D8B378F61258"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6E54096-5D45-4CB2-AC9A-DDB55BF2B94C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "4E37E1B3-6F68-4502-85D6-68333643BDFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FB187A4-F3A6-4993-AEF2-7808F1485EE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_data_foundation:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0E2C021C-A9F0-4EB4-ADED-81D8B57B4563"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/JuliaLang/julia/issues/42415", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Reference-LAPACK/lapack/commit/38f3eeee3108b18158409ca2a100e6fe03754781", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Reference-LAPACK/lapack/pull/625", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/xianyi/OpenBLAS/commit/2be5ee3cca97a597f2ee2118808a2d5eacea050c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xianyi/OpenBLAS/commit/337b65133df174796794871b3988cd03426e6d41", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xianyi/OpenBLAS/commit/ddb0ff5353637bb5f5ad060c9620e334c143e3d7", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xianyi/OpenBLAS/commit/fe497efa0510466fd93578aaf9da1ad8ed4edbe7", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6QFEVOCUG2UXMVMFMTU4ONJVDEHY2LW2/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DROZM4M2QRKSD6FBO4BHSV2QMIRJQPHT/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Reference-LAPACK/lapack/commit/38f3eeee3108b18158409ca2a100e6fe03754781"}}