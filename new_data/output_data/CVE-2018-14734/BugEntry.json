{"buggy_code": ["/*\n * Copyright (c) 2005-2006 Intel Corporation.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *\tcopyright notice, this list of conditions and the following\n *\tdisclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *\tcopyright notice, this list of conditions and the following\n *\tdisclaimer in the documentation and/or other materials\n *\tprovided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/completion.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/nsproxy.h>\n\n#include <rdma/rdma_user_cm.h>\n#include <rdma/ib_marshall.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/rdma_cm_ib.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib.h>\n\nMODULE_AUTHOR(\"Sean Hefty\");\nMODULE_DESCRIPTION(\"RDMA Userspace Connection Manager Access\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic unsigned int max_backlog = 1024;\n\nstatic struct ctl_table_header *ucma_ctl_table_hdr;\nstatic struct ctl_table ucma_ctl_table[] = {\n\t{\n\t\t.procname\t= \"max_backlog\",\n\t\t.data\t\t= &max_backlog,\n\t\t.maxlen\t\t= sizeof max_backlog,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstruct ucma_file {\n\tstruct mutex\t\tmut;\n\tstruct file\t\t*filp;\n\tstruct list_head\tctx_list;\n\tstruct list_head\tevent_list;\n\twait_queue_head_t\tpoll_wait;\n\tstruct workqueue_struct\t*close_wq;\n};\n\nstruct ucma_context {\n\tint\t\t\tid;\n\tstruct completion\tcomp;\n\tatomic_t\t\tref;\n\tint\t\t\tevents_reported;\n\tint\t\t\tbacklog;\n\n\tstruct ucma_file\t*file;\n\tstruct rdma_cm_id\t*cm_id;\n\tu64\t\t\tuid;\n\n\tstruct list_head\tlist;\n\tstruct list_head\tmc_list;\n\t/* mark that device is in process of destroying the internal HW\n\t * resources, protected by the global mut\n\t */\n\tint\t\t\tclosing;\n\t/* sync between removal event and id destroy, protected by file mut */\n\tint\t\t\tdestroying;\n\tstruct work_struct\tclose_work;\n};\n\nstruct ucma_multicast {\n\tstruct ucma_context\t*ctx;\n\tint\t\t\tid;\n\tint\t\t\tevents_reported;\n\n\tu64\t\t\tuid;\n\tu8\t\t\tjoin_state;\n\tstruct list_head\tlist;\n\tstruct sockaddr_storage\taddr;\n};\n\nstruct ucma_event {\n\tstruct ucma_context\t*ctx;\n\tstruct ucma_multicast\t*mc;\n\tstruct list_head\tlist;\n\tstruct rdma_cm_id\t*cm_id;\n\tstruct rdma_ucm_event_resp resp;\n\tstruct work_struct\tclose_work;\n};\n\nstatic DEFINE_MUTEX(mut);\nstatic DEFINE_IDR(ctx_idr);\nstatic DEFINE_IDR(multicast_idr);\n\nstatic inline struct ucma_context *_ucma_find_context(int id,\n\t\t\t\t\t\t      struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = idr_find(&ctx_idr, id);\n\tif (!ctx)\n\t\tctx = ERR_PTR(-ENOENT);\n\telse if (ctx->file != file || !ctx->cm_id)\n\t\tctx = ERR_PTR(-EINVAL);\n\treturn ctx;\n}\n\nstatic struct ucma_context *ucma_get_ctx(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx;\n\n\tmutex_lock(&mut);\n\tctx = _ucma_find_context(id, file);\n\tif (!IS_ERR(ctx)) {\n\t\tif (ctx->closing)\n\t\t\tctx = ERR_PTR(-EIO);\n\t\telse\n\t\t\tatomic_inc(&ctx->ref);\n\t}\n\tmutex_unlock(&mut);\n\treturn ctx;\n}\n\nstatic void ucma_put_ctx(struct ucma_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->ref))\n\t\tcomplete(&ctx->comp);\n}\n\n/*\n * Same as ucm_get_ctx but requires that ->cm_id->device is valid, eg that the\n * CM_ID is bound.\n */\nstatic struct ucma_context *ucma_get_ctx_dev(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx = ucma_get_ctx(file, id);\n\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\tif (!ctx->cm_id->device) {\n\t\tucma_put_ctx(ctx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn ctx;\n}\n\nstatic void ucma_close_event_id(struct work_struct *work)\n{\n\tstruct ucma_event *uevent_close =  container_of(work, struct ucma_event, close_work);\n\n\trdma_destroy_id(uevent_close->cm_id);\n\tkfree(uevent_close);\n}\n\nstatic void ucma_close_id(struct work_struct *work)\n{\n\tstruct ucma_context *ctx =  container_of(work, struct ucma_context, close_work);\n\n\t/* once all inflight tasks are finished, we close all underlying\n\t * resources. The context is still alive till its explicit destryoing\n\t * by its creator.\n\t */\n\tucma_put_ctx(ctx);\n\twait_for_completion(&ctx->comp);\n\t/* No new events will be generated after destroying the id. */\n\trdma_destroy_id(ctx->cm_id);\n}\n\nstatic struct ucma_context *ucma_alloc_ctx(struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tINIT_WORK(&ctx->close_work, ucma_close_id);\n\tatomic_set(&ctx->ref, 1);\n\tinit_completion(&ctx->comp);\n\tINIT_LIST_HEAD(&ctx->mc_list);\n\tctx->file = file;\n\n\tmutex_lock(&mut);\n\tctx->id = idr_alloc(&ctx_idr, ctx, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (ctx->id < 0)\n\t\tgoto error;\n\n\tlist_add_tail(&ctx->list, &file->ctx_list);\n\treturn ctx;\n\nerror:\n\tkfree(ctx);\n\treturn NULL;\n}\n\nstatic struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}\n\nstatic void ucma_copy_conn_event(struct rdma_ucm_conn_param *dst,\n\t\t\t\t struct rdma_conn_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources =src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num;\n}\n\nstatic void ucma_copy_ud_event(struct ib_device *device,\n\t\t\t       struct rdma_ucm_ud_param *dst,\n\t\t\t       struct rdma_ud_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tib_copy_ah_attr_to_user(device, &dst->ah_attr, &src->ah_attr);\n\tdst->qp_num = src->qp_num;\n\tdst->qkey = src->qkey;\n}\n\nstatic void ucma_set_event_context(struct ucma_context *ctx,\n\t\t\t\t   struct rdma_cm_event *event,\n\t\t\t\t   struct ucma_event *uevent)\n{\n\tuevent->ctx = ctx;\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_MULTICAST_JOIN:\n\tcase RDMA_CM_EVENT_MULTICAST_ERROR:\n\t\tuevent->mc = (struct ucma_multicast *)\n\t\t\t     event->param.ud.private_data;\n\t\tuevent->resp.uid = uevent->mc->uid;\n\t\tuevent->resp.id = uevent->mc->id;\n\t\tbreak;\n\tdefault:\n\t\tuevent->resp.uid = ctx->uid;\n\t\tuevent->resp.id = ctx->id;\n\t\tbreak;\n\t}\n}\n\n/* Called with file->mut locked for the relevant context. */\nstatic void ucma_removal_event_handler(struct rdma_cm_id *cm_id)\n{\n\tstruct ucma_context *ctx = cm_id->context;\n\tstruct ucma_event *con_req_eve;\n\tint event_found = 0;\n\n\tif (ctx->destroying)\n\t\treturn;\n\n\t/* only if context is pointing to cm_id that it owns it and can be\n\t * queued to be closed, otherwise that cm_id is an inflight one that\n\t * is part of that context event list pending to be detached and\n\t * reattached to its new context as part of ucma_get_event,\n\t * handled separately below.\n\t */\n\tif (ctx->cm_id == cm_id) {\n\t\tmutex_lock(&mut);\n\t\tctx->closing = 1;\n\t\tmutex_unlock(&mut);\n\t\tqueue_work(ctx->file->close_wq, &ctx->close_work);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(con_req_eve, &ctx->file->event_list, list) {\n\t\tif (con_req_eve->cm_id == cm_id &&\n\t\t    con_req_eve->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\t\tlist_del(&con_req_eve->list);\n\t\t\tINIT_WORK(&con_req_eve->close_work, ucma_close_event_id);\n\t\t\tqueue_work(ctx->file->close_wq, &con_req_eve->close_work);\n\t\t\tevent_found = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!event_found)\n\t\tpr_err(\"ucma_removal_event_handler: warning: connect request event wasn't found\\n\");\n}\n\nstatic int ucma_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t      struct rdma_cm_event *event)\n{\n\tstruct ucma_event *uevent;\n\tstruct ucma_context *ctx = cm_id->context;\n\tint ret = 0;\n\n\tuevent = kzalloc(sizeof(*uevent), GFP_KERNEL);\n\tif (!uevent)\n\t\treturn event->event == RDMA_CM_EVENT_CONNECT_REQUEST;\n\n\tmutex_lock(&ctx->file->mut);\n\tuevent->cm_id = cm_id;\n\tucma_set_event_context(ctx, event, uevent);\n\tuevent->resp.event = event->event;\n\tuevent->resp.status = event->status;\n\tif (cm_id->qp_type == IB_QPT_UD)\n\t\tucma_copy_ud_event(cm_id->device, &uevent->resp.param.ud,\n\t\t\t\t   &event->param.ud);\n\telse\n\t\tucma_copy_conn_event(&uevent->resp.param.conn,\n\t\t\t\t     &event->param.conn);\n\n\tif (event->event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\tif (!ctx->backlog) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(uevent);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->backlog--;\n\t} else if (!ctx->uid || ctx->cm_id != cm_id) {\n\t\t/*\n\t\t * We ignore events for new connections until userspace has set\n\t\t * their context.  This can only happen if an error occurs on a\n\t\t * new connection before the user accepts it.  This is okay,\n\t\t * since the accept will just fail later. However, we do need\n\t\t * to release the underlying HW resources in case of a device\n\t\t * removal event.\n\t\t */\n\t\tif (event->event == RDMA_CM_EVENT_DEVICE_REMOVAL)\n\t\t\tucma_removal_event_handler(cm_id);\n\n\t\tkfree(uevent);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&uevent->list, &ctx->file->event_list);\n\twake_up_interruptible(&ctx->file->poll_wait);\n\tif (event->event == RDMA_CM_EVENT_DEVICE_REMOVAL)\n\t\tucma_removal_event_handler(cm_id);\nout:\n\tmutex_unlock(&ctx->file->mut);\n\treturn ret;\n}\n\nstatic ssize_t ucma_get_event(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct ucma_context *ctx;\n\tstruct rdma_ucm_get_event cmd;\n\tstruct ucma_event *uevent;\n\tint ret = 0;\n\n\t/*\n\t * Old 32 bit user space does not send the 4 byte padding in the\n\t * reserved field. We don't care, allow it to keep working.\n\t */\n\tif (out_len < sizeof(uevent->resp) - sizeof(uevent->resp.reserved))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&file->mut);\n\twhile (list_empty(&file->event_list)) {\n\t\tmutex_unlock(&file->mut);\n\n\t\tif (file->filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(file->poll_wait,\n\t\t\t\t\t     !list_empty(&file->event_list)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tmutex_lock(&file->mut);\n\t}\n\n\tuevent = list_entry(file->event_list.next, struct ucma_event, list);\n\n\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\tctx = ucma_alloc_ctx(file);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tuevent->ctx->backlog++;\n\t\tctx->cm_id = uevent->cm_id;\n\t\tctx->cm_id->context = ctx;\n\t\tuevent->resp.id = ctx->id;\n\t}\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &uevent->resp,\n\t\t\t min_t(size_t, out_len, sizeof(uevent->resp)))) {\n\t\tret = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tlist_del(&uevent->list);\n\tuevent->ctx->events_reported++;\n\tif (uevent->mc)\n\t\tuevent->mc->events_reported++;\n\tkfree(uevent);\ndone:\n\tmutex_unlock(&file->mut);\n\treturn ret;\n}\n\nstatic int ucma_get_qp_type(struct rdma_ucm_create_id *cmd, enum ib_qp_type *qp_type)\n{\n\tswitch (cmd->ps) {\n\tcase RDMA_PS_TCP:\n\t\t*qp_type = IB_QPT_RC;\n\t\treturn 0;\n\tcase RDMA_PS_UDP:\n\tcase RDMA_PS_IPOIB:\n\t\t*qp_type = IB_QPT_UD;\n\t\treturn 0;\n\tcase RDMA_PS_IB:\n\t\t*qp_type = cmd->qp_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ucma_create_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_create_id cmd;\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct rdma_cm_id *cm_id;\n\tenum ib_qp_type qp_type;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tret = ucma_get_qp_type(&cmd, &qp_type);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&file->mut);\n\tctx = ucma_alloc_ctx(file);\n\tmutex_unlock(&file->mut);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->uid = cmd.uid;\n\tcm_id = __rdma_create_id(current->nsproxy->net_ns,\n\t\t\t\t ucma_event_handler, ctx, cmd.ps, qp_type, NULL);\n\tif (IS_ERR(cm_id)) {\n\t\tret = PTR_ERR(cm_id);\n\t\tgoto err1;\n\t}\n\n\tresp.id = ctx->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err2;\n\t}\n\n\tctx->cm_id = cm_id;\n\treturn 0;\n\nerr2:\n\trdma_destroy_id(cm_id);\nerr1:\n\tmutex_lock(&mut);\n\tidr_remove(&ctx_idr, ctx->id);\n\tmutex_unlock(&mut);\n\tmutex_lock(&file->mut);\n\tlist_del(&ctx->list);\n\tmutex_unlock(&file->mut);\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic void ucma_cleanup_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc, *tmp;\n\n\tmutex_lock(&mut);\n\tlist_for_each_entry_safe(mc, tmp, &ctx->mc_list, list) {\n\t\tlist_del(&mc->list);\n\t\tidr_remove(&multicast_idr, mc->id);\n\t\tkfree(mc);\n\t}\n\tmutex_unlock(&mut);\n}\n\nstatic void ucma_cleanup_mc_events(struct ucma_multicast *mc)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\n\t\tif (uevent->mc != mc)\n\t\t\tcontinue;\n\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n}\n\n/*\n * ucma_free_ctx is called after the underlying rdma CM-ID is destroyed. At\n * this point, no new events will be reported from the hardware. However, we\n * still need to cleanup the UCMA context for this ID. Specifically, there\n * might be events that have not yet been consumed by the user space software.\n * These might include pending connect requests which we have not completed\n * processing.  We cannot call rdma_destroy_id while holding the lock of the\n * context (file->mut), as it might cause a deadlock. We therefore extract all\n * relevant events from the context pending events list while holding the\n * mutex. After that we release them as needed.\n */\nstatic int ucma_free_ctx(struct ucma_context *ctx)\n{\n\tint events_reported;\n\tstruct ucma_event *uevent, *tmp;\n\tLIST_HEAD(list);\n\n\n\tucma_cleanup_multicast(ctx);\n\n\t/* Cleanup events not yet reported to the user. */\n\tmutex_lock(&ctx->file->mut);\n\tlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list) {\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &list);\n\t}\n\tlist_del(&ctx->list);\n\tmutex_unlock(&ctx->file->mut);\n\n\tlist_for_each_entry_safe(uevent, tmp, &list, list) {\n\t\tlist_del(&uevent->list);\n\t\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST)\n\t\t\trdma_destroy_id(uevent->cm_id);\n\t\tkfree(uevent);\n\t}\n\n\tevents_reported = ctx->events_reported;\n\tkfree(ctx);\n\treturn events_reported;\n}\n\nstatic ssize_t ucma_destroy_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_context *ctx;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mut);\n\tctx = _ucma_find_context(cmd.id, file);\n\tif (!IS_ERR(ctx))\n\t\tidr_remove(&ctx_idr, ctx->id);\n\tmutex_unlock(&mut);\n\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->file->mut);\n\tctx->destroying = 1;\n\tmutex_unlock(&ctx->file->mut);\n\n\tflush_workqueue(ctx->file->close_wq);\n\t/* At this point it's guaranteed that there is no inflight\n\t * closing task */\n\tmutex_lock(&mut);\n\tif (!ctx->closing) {\n\t\tmutex_unlock(&mut);\n\t\tucma_put_ctx(ctx);\n\t\twait_for_completion(&ctx->comp);\n\t\trdma_destroy_id(ctx->cm_id);\n\t} else {\n\t\tmutex_unlock(&mut);\n\t}\n\n\tresp.events_reported = ucma_free_ctx(ctx);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind_ip(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_in6(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind(struct ucma_file *file, const char __user *inbuf,\n\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved || !cmd.addr_size ||\n\t    cmd.addr_size != rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_ip(struct ucma_file *file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif ((cmd.src_addr.sin6_family && !rdma_addr_size_in6(&cmd.src_addr)) ||\n\t    !rdma_addr_size_in6(&cmd.dst_addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_addr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_addr cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved ||\n\t    (cmd.src_size && (cmd.src_size != rdma_addr_size_kss(&cmd.src_addr))) ||\n\t    !cmd.dst_size || (cmd.dst_size != rdma_addr_size_kss(&cmd.dst_addr)))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_route(struct ucma_file *file,\n\t\t\t\t  const char __user *inbuf,\n\t\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_route cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_route(ctx->cm_id, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_ib_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tresp->num_paths = route->num_paths;\n\tswitch (route->num_paths) {\n\tcase 0:\n\t\tdev_addr = &route->addr.dev_addr;\n\t\trdma_addr_get_dgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].dgid);\n\t\trdma_addr_get_sgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\t/* fall through */\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iboe_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t\t struct rdma_route *route)\n{\n\n\tresp->num_paths = route->num_paths;\n\tswitch (route->num_paths) {\n\tcase 0:\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.dst_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].dgid);\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.src_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(0xffff);\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\t/* fall through */\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iw_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tdev_addr = &route->addr.dev_addr;\n\trdma_addr_get_dgid(dev_addr, (union ib_gid *) &resp->ib_route[0].dgid);\n\trdma_addr_get_sgid(dev_addr, (union ib_gid *) &resp->ib_route[0].sgid);\n}\n\nstatic ssize_t ucma_query_route(struct ucma_file *file,\n\t\t\t\tconst char __user *inbuf,\n\t\t\t\tint in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct rdma_ucm_query_route_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmemset(&resp, 0, sizeof resp);\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tmemcpy(&resp.src_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tmemcpy(&resp.dst_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\tif (!ctx->cm_id->device)\n\t\tgoto out;\n\n\tresp.node_guid = (__force __u64) ctx->cm_id->device->node_guid;\n\tresp.port_num = ctx->cm_id->port_num;\n\n\tif (rdma_cap_ib_sa(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_ib_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_roce(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iboe_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_iwarp(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iw_route(&resp, &ctx->cm_id->route);\n\nout:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_query_device_addr(struct rdma_cm_id *cm_id,\n\t\t\t\t   struct rdma_ucm_query_addr_resp *resp)\n{\n\tif (!cm_id->device)\n\t\treturn;\n\n\tresp->node_guid = (__force __u64) cm_id->device->node_guid;\n\tresp->port_num = cm_id->port_num;\n\tresp->pkey = (__force __u16) cpu_to_be16(\n\t\t     ib_addr_get_pkey(&cm_id->route.addr.dev_addr));\n}\n\nstatic ssize_t ucma_query_addr(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tresp.src_size = rdma_addr_size(addr);\n\tmemcpy(&resp.src_addr, addr, resp.src_size);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tresp.dst_size = rdma_addr_size(addr);\n\tmemcpy(&resp.dst_addr, addr, resp.dst_size);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\tif (copy_to_user(response, &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_path(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_path_resp *resp;\n\tint i, ret = 0;\n\n\tif (out_len < sizeof(*resp))\n\t\treturn -ENOSPC;\n\n\tresp = kzalloc(out_len, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tresp->num_paths = ctx->cm_id->route.num_paths;\n\tfor (i = 0, out_len -= sizeof(*resp);\n\t     i < resp->num_paths && out_len > sizeof(struct ib_path_rec_data);\n\t     i++, out_len -= sizeof(struct ib_path_rec_data)) {\n\t\tstruct sa_path_rec *rec = &ctx->cm_id->route.path_rec[i];\n\n\t\tresp->path_data[i].flags = IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t   IB_PATH_BIDIRECTIONAL;\n\t\tif (rec->rec_type == SA_PATH_REC_TYPE_OPA) {\n\t\t\tstruct sa_path_rec ib;\n\n\t\t\tsa_convert_path_opa_to_ib(&ib, rec);\n\t\t\tib_sa_pack_path(&ib, &resp->path_data[i].path_rec);\n\n\t\t} else {\n\t\t\tib_sa_pack_path(rec, &resp->path_data[i].path_rec);\n\t\t}\n\t}\n\n\tif (copy_to_user(response, resp,\n\t\t\t sizeof(*resp) + (i * sizeof(struct ib_path_rec_data))))\n\t\tret = -EFAULT;\n\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_gid(struct ucma_context *ctx,\n\t\t\t      void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr_ib *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\taddr = (struct sockaddr_ib *) &resp.src_addr;\n\tresp.src_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.src_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.src_addr, resp.src_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, (union ib_gid *)&addr->sib_addr,\n\t\t\t       NULL);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.src_addr);\n\t}\n\n\taddr = (struct sockaddr_ib *) &resp.dst_addr;\n\tresp.dst_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.dst_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.dst_addr, resp.dst_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, NULL,\n\t\t\t       (union ib_gid *)&addr->sib_addr);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.dst_addr);\n\t}\n\n\tif (copy_to_user(response, &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query(struct ucma_file *file,\n\t\t\t  const char __user *inbuf,\n\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct ucma_context *ctx;\n\tvoid __user *response;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tresponse = u64_to_user_ptr(cmd.response);\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tswitch (cmd.option) {\n\tcase RDMA_USER_CM_QUERY_ADDR:\n\t\tret = ucma_query_addr(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_PATH:\n\t\tret = ucma_query_path(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_GID:\n\t\tret = ucma_query_gid(ctx, response, out_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_conn_param(struct rdma_cm_id *id,\n\t\t\t\t struct rdma_conn_param *dst,\n\t\t\t\t struct rdma_ucm_conn_param *src)\n{\n\tdst->private_data = src->private_data;\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources =src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num;\n\tdst->qkey = (id->route.addr.src_addr.ss_family == AF_IB) ? src->qkey : 0;\n}\n\nstatic ssize_t ucma_connect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_ucm_connect cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!cmd.conn_param.valid)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\tret = rdma_connect(ctx->cm_id, &conn_param);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_listen(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_listen cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tctx->backlog = cmd.backlog > 0 && cmd.backlog < max_backlog ?\n\t\t       cmd.backlog : max_backlog;\n\tret = rdma_listen(ctx->cm_id, ctx->backlog);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_accept cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (cmd.conn_param.valid) {\n\t\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\t\tmutex_lock(&file->mut);\n\t\tret = __rdma_accept(ctx->cm_id, &conn_param, NULL);\n\t\tif (!ret)\n\t\t\tctx->uid = cmd.uid;\n\t\tmutex_unlock(&file->mut);\n\t} else\n\t\tret = __rdma_accept(ctx->cm_id, NULL, NULL);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_reject(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_reject cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_reject(ctx->cm_id, cmd.private_data, cmd.private_data_len);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_disconnect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_disconnect cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_disconnect(ctx->cm_id);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_init_qp_attr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_init_qp_attr cmd;\n\tstruct ib_uverbs_qp_attr resp;\n\tstruct ucma_context *ctx;\n\tstruct ib_qp_attr qp_attr;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.qp_state > IB_QPS_ERR)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tresp.qp_attr_mask = 0;\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = cmd.qp_state;\n\tret = rdma_init_qp_attr(ctx->cm_id, &qp_attr, &resp.qp_attr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\tib_copy_qp_attr_to_user(ctx->cm_id->device, &resp, &qp_attr);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic int ucma_set_option_id(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret = 0;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_ID_TOS:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trdma_set_service_type(ctx->cm_id, *((u8 *) optval));\n\t\tbreak;\n\tcase RDMA_OPTION_ID_REUSEADDR:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_AFONLY:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_ib_path(struct ucma_context *ctx,\n\t\t\t    struct ib_path_rec_data *path_data, size_t optlen)\n{\n\tstruct sa_path_rec sa_path;\n\tstruct rdma_cm_event event;\n\tint ret;\n\n\tif (optlen % sizeof(*path_data))\n\t\treturn -EINVAL;\n\n\tfor (; optlen; optlen -= sizeof(*path_data), path_data++) {\n\t\tif (path_data->flags == (IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t IB_PATH_BIDIRECTIONAL))\n\t\t\tbreak;\n\t}\n\n\tif (!optlen)\n\t\treturn -EINVAL;\n\n\tif (!ctx->cm_id->device)\n\t\treturn -EINVAL;\n\n\tmemset(&sa_path, 0, sizeof(sa_path));\n\n\tsa_path.rec_type = SA_PATH_REC_TYPE_IB;\n\tib_sa_unpack_path(path_data->path_rec, &sa_path);\n\n\tif (rdma_cap_opa_ah(ctx->cm_id->device, ctx->cm_id->port_num)) {\n\t\tstruct sa_path_rec opa;\n\n\t\tsa_convert_path_ib_to_opa(&opa, &sa_path);\n\t\tret = rdma_set_ib_path(ctx->cm_id, &opa);\n\t} else {\n\t\tret = rdma_set_ib_path(ctx->cm_id, &sa_path);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&event, 0, sizeof event);\n\tevent.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\n\treturn ucma_event_handler(ctx->cm_id, &event);\n}\n\nstatic int ucma_set_option_ib(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_IB_PATH:\n\t\tret = ucma_set_ib_path(ctx, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_option_level(struct ucma_context *ctx, int level,\n\t\t\t\t int optname, void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (level) {\n\tcase RDMA_OPTION_ID:\n\t\tret = ucma_set_option_id(ctx, optname, optval, optlen);\n\t\tbreak;\n\tcase RDMA_OPTION_IB:\n\t\tret = ucma_set_option_ib(ctx, optname, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_set_option(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_set_option cmd;\n\tstruct ucma_context *ctx;\n\tvoid *optval;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmd.optlen > KMALLOC_MAX_SIZE))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\toptval = memdup_user(u64_to_user_ptr(cmd.optval),\n\t\t\t     cmd.optlen);\n\tif (IS_ERR(optval)) {\n\t\tret = PTR_ERR(optval);\n\t\tgoto out;\n\t}\n\n\tret = ucma_set_option_level(ctx, cmd.level, cmd.optname, optval,\n\t\t\t\t    cmd.optlen);\n\tkfree(optval);\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_notify(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_notify cmd;\n\tstruct ucma_context *ctx;\n\tint ret = -EINVAL;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (ctx->cm_id->device)\n\t\tret = rdma_notify(ctx->cm_id, (enum ib_event_type)cmd.event);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\n\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_join_ip_multicast(struct ucma_file *file,\n\t\t\t\t      const char __user *inbuf,\n\t\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size_in6(&cmd.addr);\n\tif (!join_cmd.addr_size)\n\t\treturn -EINVAL;\n\n\tjoin_cmd.join_flags = RDMA_MC_JOIN_FLAG_FULLMEMBER;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n}\n\nstatic ssize_t ucma_join_multicast(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_mcast cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\treturn ucma_process_join(file, &cmd, out_len);\n}\n\nstatic ssize_t ucma_leave_multicast(struct ucma_file *file,\n\t\t\t\t    const char __user *inbuf,\n\t\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_multicast *mc;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mut);\n\tmc = idr_find(&multicast_idr, cmd.id);\n\tif (!mc)\n\t\tmc = ERR_PTR(-ENOENT);\n\telse if (mc->ctx->file != file)\n\t\tmc = ERR_PTR(-EINVAL);\n\telse if (!atomic_inc_not_zero(&mc->ctx->ref))\n\t\tmc = ERR_PTR(-ENXIO);\n\telse\n\t\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\n\tif (IS_ERR(mc)) {\n\t\tret = PTR_ERR(mc);\n\t\tgoto out;\n\t}\n\n\trdma_leave_multicast(mc->ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tmutex_lock(&mc->ctx->file->mut);\n\tucma_cleanup_mc_events(mc);\n\tlist_del(&mc->list);\n\tmutex_unlock(&mc->ctx->file->mut);\n\n\tucma_put_ctx(mc->ctx);\n\tresp.events_reported = mc->events_reported;\n\tkfree(mc);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\nout:\n\treturn ret;\n}\n\nstatic void ucma_lock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\t/* Acquire mutex's based on pointer comparison to prevent deadlock. */\n\tif (file1 < file2) {\n\t\tmutex_lock(&file1->mut);\n\t\tmutex_lock_nested(&file2->mut, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tmutex_lock(&file2->mut);\n\t\tmutex_lock_nested(&file1->mut, SINGLE_DEPTH_NESTING);\n\t}\n}\n\nstatic void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\tif (file1 < file2) {\n\t\tmutex_unlock(&file2->mut);\n\t\tmutex_unlock(&file1->mut);\n\t} else {\n\t\tmutex_unlock(&file1->mut);\n\t\tmutex_unlock(&file2->mut);\n\t}\n}\n\nstatic void ucma_move_events(struct ucma_context *ctx, struct ucma_file *file)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list)\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &file->event_list);\n}\n\nstatic ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* Get current fd to protect against it being closed */\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\n\t/* Validate current fd and prevent destruction of id. */\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tresp.events_reported = ctx->events_reported;\n\t\tgoto response;\n\t}\n\n\t/*\n\t * Migrate events between fd's, maintaining order, and avoiding new\n\t * events being added before existing events.\n\t */\n\tucma_lock_files(cur_file, new_file);\n\tmutex_lock(&mut);\n\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\n\tmutex_unlock(&mut);\n\tucma_unlock_files(cur_file, new_file);\n\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic ssize_t (*ucma_cmd_table[])(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len) = {\n\t[RDMA_USER_CM_CMD_CREATE_ID] \t = ucma_create_id,\n\t[RDMA_USER_CM_CMD_DESTROY_ID]\t = ucma_destroy_id,\n\t[RDMA_USER_CM_CMD_BIND_IP]\t = ucma_bind_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_IP]\t = ucma_resolve_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_ROUTE] = ucma_resolve_route,\n\t[RDMA_USER_CM_CMD_QUERY_ROUTE]\t = ucma_query_route,\n\t[RDMA_USER_CM_CMD_CONNECT]\t = ucma_connect,\n\t[RDMA_USER_CM_CMD_LISTEN]\t = ucma_listen,\n\t[RDMA_USER_CM_CMD_ACCEPT]\t = ucma_accept,\n\t[RDMA_USER_CM_CMD_REJECT]\t = ucma_reject,\n\t[RDMA_USER_CM_CMD_DISCONNECT]\t = ucma_disconnect,\n\t[RDMA_USER_CM_CMD_INIT_QP_ATTR]\t = ucma_init_qp_attr,\n\t[RDMA_USER_CM_CMD_GET_EVENT]\t = ucma_get_event,\n\t[RDMA_USER_CM_CMD_GET_OPTION]\t = NULL,\n\t[RDMA_USER_CM_CMD_SET_OPTION]\t = ucma_set_option,\n\t[RDMA_USER_CM_CMD_NOTIFY]\t = ucma_notify,\n\t[RDMA_USER_CM_CMD_JOIN_IP_MCAST] = ucma_join_ip_multicast,\n\t[RDMA_USER_CM_CMD_LEAVE_MCAST]\t = ucma_leave_multicast,\n\t[RDMA_USER_CM_CMD_MIGRATE_ID]\t = ucma_migrate_id,\n\t[RDMA_USER_CM_CMD_QUERY]\t = ucma_query,\n\t[RDMA_USER_CM_CMD_BIND]\t\t = ucma_bind,\n\t[RDMA_USER_CM_CMD_RESOLVE_ADDR]\t = ucma_resolve_addr,\n\t[RDMA_USER_CM_CMD_JOIN_MCAST]\t = ucma_join_multicast\n};\n\nstatic ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\n\tif (!ib_safe_file_access(filp)) {\n\t\tpr_err_once(\"ucma_write: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\\n\",\n\t\t\t    task_tgid_vnr(current), current->comm);\n\t\treturn -EACCES;\n\t}\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n\nstatic __poll_t ucma_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct ucma_file *file = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &file->poll_wait, wait);\n\n\tif (!list_empty(&file->event_list))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * ucma_open() does not need the BKL:\n *\n *  - no global state is referred to;\n *  - there is no ioctl method to race against;\n *  - no further module initialization is required for open to work\n *    after the device is registered.\n */\nstatic int ucma_open(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file;\n\n\tfile = kmalloc(sizeof *file, GFP_KERNEL);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tfile->close_wq = alloc_ordered_workqueue(\"ucma_close_id\",\n\t\t\t\t\t\t WQ_MEM_RECLAIM);\n\tif (!file->close_wq) {\n\t\tkfree(file);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&file->event_list);\n\tINIT_LIST_HEAD(&file->ctx_list);\n\tinit_waitqueue_head(&file->poll_wait);\n\tmutex_init(&file->mut);\n\n\tfilp->private_data = file;\n\tfile->filp = filp;\n\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic int ucma_close(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct ucma_context *ctx, *tmp;\n\n\tmutex_lock(&file->mut);\n\tlist_for_each_entry_safe(ctx, tmp, &file->ctx_list, list) {\n\t\tctx->destroying = 1;\n\t\tmutex_unlock(&file->mut);\n\n\t\tmutex_lock(&mut);\n\t\tidr_remove(&ctx_idr, ctx->id);\n\t\tmutex_unlock(&mut);\n\n\t\tflush_workqueue(file->close_wq);\n\t\t/* At that step once ctx was marked as destroying and workqueue\n\t\t * was flushed we are safe from any inflights handlers that\n\t\t * might put other closing task.\n\t\t */\n\t\tmutex_lock(&mut);\n\t\tif (!ctx->closing) {\n\t\t\tmutex_unlock(&mut);\n\t\t\t/* rdma_destroy_id ensures that no event handlers are\n\t\t\t * inflight for that id before releasing it.\n\t\t\t */\n\t\t\trdma_destroy_id(ctx->cm_id);\n\t\t} else {\n\t\t\tmutex_unlock(&mut);\n\t\t}\n\n\t\tucma_free_ctx(ctx);\n\t\tmutex_lock(&file->mut);\n\t}\n\tmutex_unlock(&file->mut);\n\tdestroy_workqueue(file->close_wq);\n\tkfree(file);\n\treturn 0;\n}\n\nstatic const struct file_operations ucma_fops = {\n\t.owner \t = THIS_MODULE,\n\t.open \t = ucma_open,\n\t.release = ucma_close,\n\t.write\t = ucma_write,\n\t.poll    = ucma_poll,\n\t.llseek\t = no_llseek,\n};\n\nstatic struct miscdevice ucma_misc = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"rdma_cm\",\n\t.nodename\t= \"infiniband/rdma_cm\",\n\t.mode\t\t= 0666,\n\t.fops\t\t= &ucma_fops,\n};\n\nstatic ssize_t show_abi_version(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", RDMA_USER_CM_ABI_VERSION);\n}\nstatic DEVICE_ATTR(abi_version, S_IRUGO, show_abi_version, NULL);\n\nstatic int __init ucma_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&ucma_misc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_create_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tif (ret) {\n\t\tpr_err(\"rdma_ucm: couldn't create abi_version attr\\n\");\n\t\tgoto err1;\n\t}\n\n\tucma_ctl_table_hdr = register_net_sysctl(&init_net, \"net/rdma_ucm\", ucma_ctl_table);\n\tif (!ucma_ctl_table_hdr) {\n\t\tpr_err(\"rdma_ucm: couldn't register sysctl paths\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\treturn 0;\nerr2:\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\nerr1:\n\tmisc_deregister(&ucma_misc);\n\treturn ret;\n}\n\nstatic void __exit ucma_cleanup(void)\n{\n\tunregister_net_sysctl_table(ucma_ctl_table_hdr);\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tmisc_deregister(&ucma_misc);\n\tidr_destroy(&ctx_idr);\n\tidr_destroy(&multicast_idr);\n}\n\nmodule_init(ucma_init);\nmodule_exit(ucma_cleanup);\n"], "fixing_code": ["/*\n * Copyright (c) 2005-2006 Intel Corporation.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *\tcopyright notice, this list of conditions and the following\n *\tdisclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *\tcopyright notice, this list of conditions and the following\n *\tdisclaimer in the documentation and/or other materials\n *\tprovided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/completion.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/nsproxy.h>\n\n#include <rdma/rdma_user_cm.h>\n#include <rdma/ib_marshall.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/rdma_cm_ib.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib.h>\n\nMODULE_AUTHOR(\"Sean Hefty\");\nMODULE_DESCRIPTION(\"RDMA Userspace Connection Manager Access\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic unsigned int max_backlog = 1024;\n\nstatic struct ctl_table_header *ucma_ctl_table_hdr;\nstatic struct ctl_table ucma_ctl_table[] = {\n\t{\n\t\t.procname\t= \"max_backlog\",\n\t\t.data\t\t= &max_backlog,\n\t\t.maxlen\t\t= sizeof max_backlog,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstruct ucma_file {\n\tstruct mutex\t\tmut;\n\tstruct file\t\t*filp;\n\tstruct list_head\tctx_list;\n\tstruct list_head\tevent_list;\n\twait_queue_head_t\tpoll_wait;\n\tstruct workqueue_struct\t*close_wq;\n};\n\nstruct ucma_context {\n\tint\t\t\tid;\n\tstruct completion\tcomp;\n\tatomic_t\t\tref;\n\tint\t\t\tevents_reported;\n\tint\t\t\tbacklog;\n\n\tstruct ucma_file\t*file;\n\tstruct rdma_cm_id\t*cm_id;\n\tu64\t\t\tuid;\n\n\tstruct list_head\tlist;\n\tstruct list_head\tmc_list;\n\t/* mark that device is in process of destroying the internal HW\n\t * resources, protected by the global mut\n\t */\n\tint\t\t\tclosing;\n\t/* sync between removal event and id destroy, protected by file mut */\n\tint\t\t\tdestroying;\n\tstruct work_struct\tclose_work;\n};\n\nstruct ucma_multicast {\n\tstruct ucma_context\t*ctx;\n\tint\t\t\tid;\n\tint\t\t\tevents_reported;\n\n\tu64\t\t\tuid;\n\tu8\t\t\tjoin_state;\n\tstruct list_head\tlist;\n\tstruct sockaddr_storage\taddr;\n};\n\nstruct ucma_event {\n\tstruct ucma_context\t*ctx;\n\tstruct ucma_multicast\t*mc;\n\tstruct list_head\tlist;\n\tstruct rdma_cm_id\t*cm_id;\n\tstruct rdma_ucm_event_resp resp;\n\tstruct work_struct\tclose_work;\n};\n\nstatic DEFINE_MUTEX(mut);\nstatic DEFINE_IDR(ctx_idr);\nstatic DEFINE_IDR(multicast_idr);\n\nstatic inline struct ucma_context *_ucma_find_context(int id,\n\t\t\t\t\t\t      struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = idr_find(&ctx_idr, id);\n\tif (!ctx)\n\t\tctx = ERR_PTR(-ENOENT);\n\telse if (ctx->file != file || !ctx->cm_id)\n\t\tctx = ERR_PTR(-EINVAL);\n\treturn ctx;\n}\n\nstatic struct ucma_context *ucma_get_ctx(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx;\n\n\tmutex_lock(&mut);\n\tctx = _ucma_find_context(id, file);\n\tif (!IS_ERR(ctx)) {\n\t\tif (ctx->closing)\n\t\t\tctx = ERR_PTR(-EIO);\n\t\telse\n\t\t\tatomic_inc(&ctx->ref);\n\t}\n\tmutex_unlock(&mut);\n\treturn ctx;\n}\n\nstatic void ucma_put_ctx(struct ucma_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->ref))\n\t\tcomplete(&ctx->comp);\n}\n\n/*\n * Same as ucm_get_ctx but requires that ->cm_id->device is valid, eg that the\n * CM_ID is bound.\n */\nstatic struct ucma_context *ucma_get_ctx_dev(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx = ucma_get_ctx(file, id);\n\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\tif (!ctx->cm_id->device) {\n\t\tucma_put_ctx(ctx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn ctx;\n}\n\nstatic void ucma_close_event_id(struct work_struct *work)\n{\n\tstruct ucma_event *uevent_close =  container_of(work, struct ucma_event, close_work);\n\n\trdma_destroy_id(uevent_close->cm_id);\n\tkfree(uevent_close);\n}\n\nstatic void ucma_close_id(struct work_struct *work)\n{\n\tstruct ucma_context *ctx =  container_of(work, struct ucma_context, close_work);\n\n\t/* once all inflight tasks are finished, we close all underlying\n\t * resources. The context is still alive till its explicit destryoing\n\t * by its creator.\n\t */\n\tucma_put_ctx(ctx);\n\twait_for_completion(&ctx->comp);\n\t/* No new events will be generated after destroying the id. */\n\trdma_destroy_id(ctx->cm_id);\n}\n\nstatic struct ucma_context *ucma_alloc_ctx(struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tINIT_WORK(&ctx->close_work, ucma_close_id);\n\tatomic_set(&ctx->ref, 1);\n\tinit_completion(&ctx->comp);\n\tINIT_LIST_HEAD(&ctx->mc_list);\n\tctx->file = file;\n\n\tmutex_lock(&mut);\n\tctx->id = idr_alloc(&ctx_idr, ctx, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (ctx->id < 0)\n\t\tgoto error;\n\n\tlist_add_tail(&ctx->list, &file->ctx_list);\n\treturn ctx;\n\nerror:\n\tkfree(ctx);\n\treturn NULL;\n}\n\nstatic struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}\n\nstatic void ucma_copy_conn_event(struct rdma_ucm_conn_param *dst,\n\t\t\t\t struct rdma_conn_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources =src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num;\n}\n\nstatic void ucma_copy_ud_event(struct ib_device *device,\n\t\t\t       struct rdma_ucm_ud_param *dst,\n\t\t\t       struct rdma_ud_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tib_copy_ah_attr_to_user(device, &dst->ah_attr, &src->ah_attr);\n\tdst->qp_num = src->qp_num;\n\tdst->qkey = src->qkey;\n}\n\nstatic void ucma_set_event_context(struct ucma_context *ctx,\n\t\t\t\t   struct rdma_cm_event *event,\n\t\t\t\t   struct ucma_event *uevent)\n{\n\tuevent->ctx = ctx;\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_MULTICAST_JOIN:\n\tcase RDMA_CM_EVENT_MULTICAST_ERROR:\n\t\tuevent->mc = (struct ucma_multicast *)\n\t\t\t     event->param.ud.private_data;\n\t\tuevent->resp.uid = uevent->mc->uid;\n\t\tuevent->resp.id = uevent->mc->id;\n\t\tbreak;\n\tdefault:\n\t\tuevent->resp.uid = ctx->uid;\n\t\tuevent->resp.id = ctx->id;\n\t\tbreak;\n\t}\n}\n\n/* Called with file->mut locked for the relevant context. */\nstatic void ucma_removal_event_handler(struct rdma_cm_id *cm_id)\n{\n\tstruct ucma_context *ctx = cm_id->context;\n\tstruct ucma_event *con_req_eve;\n\tint event_found = 0;\n\n\tif (ctx->destroying)\n\t\treturn;\n\n\t/* only if context is pointing to cm_id that it owns it and can be\n\t * queued to be closed, otherwise that cm_id is an inflight one that\n\t * is part of that context event list pending to be detached and\n\t * reattached to its new context as part of ucma_get_event,\n\t * handled separately below.\n\t */\n\tif (ctx->cm_id == cm_id) {\n\t\tmutex_lock(&mut);\n\t\tctx->closing = 1;\n\t\tmutex_unlock(&mut);\n\t\tqueue_work(ctx->file->close_wq, &ctx->close_work);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(con_req_eve, &ctx->file->event_list, list) {\n\t\tif (con_req_eve->cm_id == cm_id &&\n\t\t    con_req_eve->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\t\tlist_del(&con_req_eve->list);\n\t\t\tINIT_WORK(&con_req_eve->close_work, ucma_close_event_id);\n\t\t\tqueue_work(ctx->file->close_wq, &con_req_eve->close_work);\n\t\t\tevent_found = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!event_found)\n\t\tpr_err(\"ucma_removal_event_handler: warning: connect request event wasn't found\\n\");\n}\n\nstatic int ucma_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t      struct rdma_cm_event *event)\n{\n\tstruct ucma_event *uevent;\n\tstruct ucma_context *ctx = cm_id->context;\n\tint ret = 0;\n\n\tuevent = kzalloc(sizeof(*uevent), GFP_KERNEL);\n\tif (!uevent)\n\t\treturn event->event == RDMA_CM_EVENT_CONNECT_REQUEST;\n\n\tmutex_lock(&ctx->file->mut);\n\tuevent->cm_id = cm_id;\n\tucma_set_event_context(ctx, event, uevent);\n\tuevent->resp.event = event->event;\n\tuevent->resp.status = event->status;\n\tif (cm_id->qp_type == IB_QPT_UD)\n\t\tucma_copy_ud_event(cm_id->device, &uevent->resp.param.ud,\n\t\t\t\t   &event->param.ud);\n\telse\n\t\tucma_copy_conn_event(&uevent->resp.param.conn,\n\t\t\t\t     &event->param.conn);\n\n\tif (event->event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\tif (!ctx->backlog) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(uevent);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->backlog--;\n\t} else if (!ctx->uid || ctx->cm_id != cm_id) {\n\t\t/*\n\t\t * We ignore events for new connections until userspace has set\n\t\t * their context.  This can only happen if an error occurs on a\n\t\t * new connection before the user accepts it.  This is okay,\n\t\t * since the accept will just fail later. However, we do need\n\t\t * to release the underlying HW resources in case of a device\n\t\t * removal event.\n\t\t */\n\t\tif (event->event == RDMA_CM_EVENT_DEVICE_REMOVAL)\n\t\t\tucma_removal_event_handler(cm_id);\n\n\t\tkfree(uevent);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&uevent->list, &ctx->file->event_list);\n\twake_up_interruptible(&ctx->file->poll_wait);\n\tif (event->event == RDMA_CM_EVENT_DEVICE_REMOVAL)\n\t\tucma_removal_event_handler(cm_id);\nout:\n\tmutex_unlock(&ctx->file->mut);\n\treturn ret;\n}\n\nstatic ssize_t ucma_get_event(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct ucma_context *ctx;\n\tstruct rdma_ucm_get_event cmd;\n\tstruct ucma_event *uevent;\n\tint ret = 0;\n\n\t/*\n\t * Old 32 bit user space does not send the 4 byte padding in the\n\t * reserved field. We don't care, allow it to keep working.\n\t */\n\tif (out_len < sizeof(uevent->resp) - sizeof(uevent->resp.reserved))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&file->mut);\n\twhile (list_empty(&file->event_list)) {\n\t\tmutex_unlock(&file->mut);\n\n\t\tif (file->filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(file->poll_wait,\n\t\t\t\t\t     !list_empty(&file->event_list)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tmutex_lock(&file->mut);\n\t}\n\n\tuevent = list_entry(file->event_list.next, struct ucma_event, list);\n\n\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST) {\n\t\tctx = ucma_alloc_ctx(file);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tuevent->ctx->backlog++;\n\t\tctx->cm_id = uevent->cm_id;\n\t\tctx->cm_id->context = ctx;\n\t\tuevent->resp.id = ctx->id;\n\t}\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &uevent->resp,\n\t\t\t min_t(size_t, out_len, sizeof(uevent->resp)))) {\n\t\tret = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tlist_del(&uevent->list);\n\tuevent->ctx->events_reported++;\n\tif (uevent->mc)\n\t\tuevent->mc->events_reported++;\n\tkfree(uevent);\ndone:\n\tmutex_unlock(&file->mut);\n\treturn ret;\n}\n\nstatic int ucma_get_qp_type(struct rdma_ucm_create_id *cmd, enum ib_qp_type *qp_type)\n{\n\tswitch (cmd->ps) {\n\tcase RDMA_PS_TCP:\n\t\t*qp_type = IB_QPT_RC;\n\t\treturn 0;\n\tcase RDMA_PS_UDP:\n\tcase RDMA_PS_IPOIB:\n\t\t*qp_type = IB_QPT_UD;\n\t\treturn 0;\n\tcase RDMA_PS_IB:\n\t\t*qp_type = cmd->qp_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ucma_create_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_create_id cmd;\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct rdma_cm_id *cm_id;\n\tenum ib_qp_type qp_type;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tret = ucma_get_qp_type(&cmd, &qp_type);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&file->mut);\n\tctx = ucma_alloc_ctx(file);\n\tmutex_unlock(&file->mut);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->uid = cmd.uid;\n\tcm_id = __rdma_create_id(current->nsproxy->net_ns,\n\t\t\t\t ucma_event_handler, ctx, cmd.ps, qp_type, NULL);\n\tif (IS_ERR(cm_id)) {\n\t\tret = PTR_ERR(cm_id);\n\t\tgoto err1;\n\t}\n\n\tresp.id = ctx->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err2;\n\t}\n\n\tctx->cm_id = cm_id;\n\treturn 0;\n\nerr2:\n\trdma_destroy_id(cm_id);\nerr1:\n\tmutex_lock(&mut);\n\tidr_remove(&ctx_idr, ctx->id);\n\tmutex_unlock(&mut);\n\tmutex_lock(&file->mut);\n\tlist_del(&ctx->list);\n\tmutex_unlock(&file->mut);\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic void ucma_cleanup_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc, *tmp;\n\n\tmutex_lock(&mut);\n\tlist_for_each_entry_safe(mc, tmp, &ctx->mc_list, list) {\n\t\tlist_del(&mc->list);\n\t\tidr_remove(&multicast_idr, mc->id);\n\t\tkfree(mc);\n\t}\n\tmutex_unlock(&mut);\n}\n\nstatic void ucma_cleanup_mc_events(struct ucma_multicast *mc)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\n\t\tif (uevent->mc != mc)\n\t\t\tcontinue;\n\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n}\n\n/*\n * ucma_free_ctx is called after the underlying rdma CM-ID is destroyed. At\n * this point, no new events will be reported from the hardware. However, we\n * still need to cleanup the UCMA context for this ID. Specifically, there\n * might be events that have not yet been consumed by the user space software.\n * These might include pending connect requests which we have not completed\n * processing.  We cannot call rdma_destroy_id while holding the lock of the\n * context (file->mut), as it might cause a deadlock. We therefore extract all\n * relevant events from the context pending events list while holding the\n * mutex. After that we release them as needed.\n */\nstatic int ucma_free_ctx(struct ucma_context *ctx)\n{\n\tint events_reported;\n\tstruct ucma_event *uevent, *tmp;\n\tLIST_HEAD(list);\n\n\n\tucma_cleanup_multicast(ctx);\n\n\t/* Cleanup events not yet reported to the user. */\n\tmutex_lock(&ctx->file->mut);\n\tlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list) {\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &list);\n\t}\n\tlist_del(&ctx->list);\n\tmutex_unlock(&ctx->file->mut);\n\n\tlist_for_each_entry_safe(uevent, tmp, &list, list) {\n\t\tlist_del(&uevent->list);\n\t\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST)\n\t\t\trdma_destroy_id(uevent->cm_id);\n\t\tkfree(uevent);\n\t}\n\n\tevents_reported = ctx->events_reported;\n\tkfree(ctx);\n\treturn events_reported;\n}\n\nstatic ssize_t ucma_destroy_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_context *ctx;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mut);\n\tctx = _ucma_find_context(cmd.id, file);\n\tif (!IS_ERR(ctx))\n\t\tidr_remove(&ctx_idr, ctx->id);\n\tmutex_unlock(&mut);\n\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->file->mut);\n\tctx->destroying = 1;\n\tmutex_unlock(&ctx->file->mut);\n\n\tflush_workqueue(ctx->file->close_wq);\n\t/* At this point it's guaranteed that there is no inflight\n\t * closing task */\n\tmutex_lock(&mut);\n\tif (!ctx->closing) {\n\t\tmutex_unlock(&mut);\n\t\tucma_put_ctx(ctx);\n\t\twait_for_completion(&ctx->comp);\n\t\trdma_destroy_id(ctx->cm_id);\n\t} else {\n\t\tmutex_unlock(&mut);\n\t}\n\n\tresp.events_reported = ucma_free_ctx(ctx);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind_ip(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_in6(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind(struct ucma_file *file, const char __user *inbuf,\n\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved || !cmd.addr_size ||\n\t    cmd.addr_size != rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_ip(struct ucma_file *file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif ((cmd.src_addr.sin6_family && !rdma_addr_size_in6(&cmd.src_addr)) ||\n\t    !rdma_addr_size_in6(&cmd.dst_addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_addr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_addr cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved ||\n\t    (cmd.src_size && (cmd.src_size != rdma_addr_size_kss(&cmd.src_addr))) ||\n\t    !cmd.dst_size || (cmd.dst_size != rdma_addr_size_kss(&cmd.dst_addr)))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_route(struct ucma_file *file,\n\t\t\t\t  const char __user *inbuf,\n\t\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_route cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_resolve_route(ctx->cm_id, cmd.timeout_ms);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_ib_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tresp->num_paths = route->num_paths;\n\tswitch (route->num_paths) {\n\tcase 0:\n\t\tdev_addr = &route->addr.dev_addr;\n\t\trdma_addr_get_dgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].dgid);\n\t\trdma_addr_get_sgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\t/* fall through */\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iboe_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t\t struct rdma_route *route)\n{\n\n\tresp->num_paths = route->num_paths;\n\tswitch (route->num_paths) {\n\tcase 0:\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.dst_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].dgid);\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.src_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(0xffff);\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\t/* fall through */\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iw_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tdev_addr = &route->addr.dev_addr;\n\trdma_addr_get_dgid(dev_addr, (union ib_gid *) &resp->ib_route[0].dgid);\n\trdma_addr_get_sgid(dev_addr, (union ib_gid *) &resp->ib_route[0].sgid);\n}\n\nstatic ssize_t ucma_query_route(struct ucma_file *file,\n\t\t\t\tconst char __user *inbuf,\n\t\t\t\tint in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct rdma_ucm_query_route_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmemset(&resp, 0, sizeof resp);\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tmemcpy(&resp.src_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tmemcpy(&resp.dst_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\tif (!ctx->cm_id->device)\n\t\tgoto out;\n\n\tresp.node_guid = (__force __u64) ctx->cm_id->device->node_guid;\n\tresp.port_num = ctx->cm_id->port_num;\n\n\tif (rdma_cap_ib_sa(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_ib_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_roce(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iboe_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_iwarp(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iw_route(&resp, &ctx->cm_id->route);\n\nout:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_query_device_addr(struct rdma_cm_id *cm_id,\n\t\t\t\t   struct rdma_ucm_query_addr_resp *resp)\n{\n\tif (!cm_id->device)\n\t\treturn;\n\n\tresp->node_guid = (__force __u64) cm_id->device->node_guid;\n\tresp->port_num = cm_id->port_num;\n\tresp->pkey = (__force __u16) cpu_to_be16(\n\t\t     ib_addr_get_pkey(&cm_id->route.addr.dev_addr));\n}\n\nstatic ssize_t ucma_query_addr(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tresp.src_size = rdma_addr_size(addr);\n\tmemcpy(&resp.src_addr, addr, resp.src_size);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tresp.dst_size = rdma_addr_size(addr);\n\tmemcpy(&resp.dst_addr, addr, resp.dst_size);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\tif (copy_to_user(response, &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_path(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_path_resp *resp;\n\tint i, ret = 0;\n\n\tif (out_len < sizeof(*resp))\n\t\treturn -ENOSPC;\n\n\tresp = kzalloc(out_len, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tresp->num_paths = ctx->cm_id->route.num_paths;\n\tfor (i = 0, out_len -= sizeof(*resp);\n\t     i < resp->num_paths && out_len > sizeof(struct ib_path_rec_data);\n\t     i++, out_len -= sizeof(struct ib_path_rec_data)) {\n\t\tstruct sa_path_rec *rec = &ctx->cm_id->route.path_rec[i];\n\n\t\tresp->path_data[i].flags = IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t   IB_PATH_BIDIRECTIONAL;\n\t\tif (rec->rec_type == SA_PATH_REC_TYPE_OPA) {\n\t\t\tstruct sa_path_rec ib;\n\n\t\t\tsa_convert_path_opa_to_ib(&ib, rec);\n\t\t\tib_sa_pack_path(&ib, &resp->path_data[i].path_rec);\n\n\t\t} else {\n\t\t\tib_sa_pack_path(rec, &resp->path_data[i].path_rec);\n\t\t}\n\t}\n\n\tif (copy_to_user(response, resp,\n\t\t\t sizeof(*resp) + (i * sizeof(struct ib_path_rec_data))))\n\t\tret = -EFAULT;\n\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_gid(struct ucma_context *ctx,\n\t\t\t      void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr_ib *addr;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\taddr = (struct sockaddr_ib *) &resp.src_addr;\n\tresp.src_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.src_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.src_addr, resp.src_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, (union ib_gid *)&addr->sib_addr,\n\t\t\t       NULL);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.src_addr);\n\t}\n\n\taddr = (struct sockaddr_ib *) &resp.dst_addr;\n\tresp.dst_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.dst_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.dst_addr, resp.dst_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, NULL,\n\t\t\t       (union ib_gid *)&addr->sib_addr);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.dst_addr);\n\t}\n\n\tif (copy_to_user(response, &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query(struct ucma_file *file,\n\t\t\t  const char __user *inbuf,\n\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct ucma_context *ctx;\n\tvoid __user *response;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tresponse = u64_to_user_ptr(cmd.response);\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tswitch (cmd.option) {\n\tcase RDMA_USER_CM_QUERY_ADDR:\n\t\tret = ucma_query_addr(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_PATH:\n\t\tret = ucma_query_path(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_GID:\n\t\tret = ucma_query_gid(ctx, response, out_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_conn_param(struct rdma_cm_id *id,\n\t\t\t\t struct rdma_conn_param *dst,\n\t\t\t\t struct rdma_ucm_conn_param *src)\n{\n\tdst->private_data = src->private_data;\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources =src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num;\n\tdst->qkey = (id->route.addr.src_addr.ss_family == AF_IB) ? src->qkey : 0;\n}\n\nstatic ssize_t ucma_connect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_ucm_connect cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!cmd.conn_param.valid)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\tret = rdma_connect(ctx->cm_id, &conn_param);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_listen(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_listen cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tctx->backlog = cmd.backlog > 0 && cmd.backlog < max_backlog ?\n\t\t       cmd.backlog : max_backlog;\n\tret = rdma_listen(ctx->cm_id, ctx->backlog);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_accept cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (cmd.conn_param.valid) {\n\t\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\t\tmutex_lock(&file->mut);\n\t\tret = __rdma_accept(ctx->cm_id, &conn_param, NULL);\n\t\tif (!ret)\n\t\t\tctx->uid = cmd.uid;\n\t\tmutex_unlock(&file->mut);\n\t} else\n\t\tret = __rdma_accept(ctx->cm_id, NULL, NULL);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_reject(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_reject cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_reject(ctx->cm_id, cmd.private_data, cmd.private_data_len);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_disconnect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_disconnect cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tret = rdma_disconnect(ctx->cm_id);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_init_qp_attr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_init_qp_attr cmd;\n\tstruct ib_uverbs_qp_attr resp;\n\tstruct ucma_context *ctx;\n\tstruct ib_qp_attr qp_attr;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.qp_state > IB_QPS_ERR)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tresp.qp_attr_mask = 0;\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = cmd.qp_state;\n\tret = rdma_init_qp_attr(ctx->cm_id, &qp_attr, &resp.qp_attr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\tib_copy_qp_attr_to_user(ctx->cm_id->device, &resp, &qp_attr);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic int ucma_set_option_id(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret = 0;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_ID_TOS:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trdma_set_service_type(ctx->cm_id, *((u8 *) optval));\n\t\tbreak;\n\tcase RDMA_OPTION_ID_REUSEADDR:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_AFONLY:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_ib_path(struct ucma_context *ctx,\n\t\t\t    struct ib_path_rec_data *path_data, size_t optlen)\n{\n\tstruct sa_path_rec sa_path;\n\tstruct rdma_cm_event event;\n\tint ret;\n\n\tif (optlen % sizeof(*path_data))\n\t\treturn -EINVAL;\n\n\tfor (; optlen; optlen -= sizeof(*path_data), path_data++) {\n\t\tif (path_data->flags == (IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t IB_PATH_BIDIRECTIONAL))\n\t\t\tbreak;\n\t}\n\n\tif (!optlen)\n\t\treturn -EINVAL;\n\n\tif (!ctx->cm_id->device)\n\t\treturn -EINVAL;\n\n\tmemset(&sa_path, 0, sizeof(sa_path));\n\n\tsa_path.rec_type = SA_PATH_REC_TYPE_IB;\n\tib_sa_unpack_path(path_data->path_rec, &sa_path);\n\n\tif (rdma_cap_opa_ah(ctx->cm_id->device, ctx->cm_id->port_num)) {\n\t\tstruct sa_path_rec opa;\n\n\t\tsa_convert_path_ib_to_opa(&opa, &sa_path);\n\t\tret = rdma_set_ib_path(ctx->cm_id, &opa);\n\t} else {\n\t\tret = rdma_set_ib_path(ctx->cm_id, &sa_path);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&event, 0, sizeof event);\n\tevent.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\n\treturn ucma_event_handler(ctx->cm_id, &event);\n}\n\nstatic int ucma_set_option_ib(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_IB_PATH:\n\t\tret = ucma_set_ib_path(ctx, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_option_level(struct ucma_context *ctx, int level,\n\t\t\t\t int optname, void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (level) {\n\tcase RDMA_OPTION_ID:\n\t\tret = ucma_set_option_id(ctx, optname, optval, optlen);\n\t\tbreak;\n\tcase RDMA_OPTION_IB:\n\t\tret = ucma_set_option_ib(ctx, optname, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_set_option(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_set_option cmd;\n\tstruct ucma_context *ctx;\n\tvoid *optval;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmd.optlen > KMALLOC_MAX_SIZE))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\toptval = memdup_user(u64_to_user_ptr(cmd.optval),\n\t\t\t     cmd.optlen);\n\tif (IS_ERR(optval)) {\n\t\tret = PTR_ERR(optval);\n\t\tgoto out;\n\t}\n\n\tret = ucma_set_option_level(ctx, cmd.level, cmd.optname, optval,\n\t\t\t\t    cmd.optlen);\n\tkfree(optval);\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_notify(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_notify cmd;\n\tstruct ucma_context *ctx;\n\tint ret = -EINVAL;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (ctx->cm_id->device)\n\t\tret = rdma_notify(ctx->cm_id, (enum ib_event_type)cmd.event);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\n\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_join_ip_multicast(struct ucma_file *file,\n\t\t\t\t      const char __user *inbuf,\n\t\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size_in6(&cmd.addr);\n\tif (!join_cmd.addr_size)\n\t\treturn -EINVAL;\n\n\tjoin_cmd.join_flags = RDMA_MC_JOIN_FLAG_FULLMEMBER;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n}\n\nstatic ssize_t ucma_join_multicast(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_mcast cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\treturn ucma_process_join(file, &cmd, out_len);\n}\n\nstatic ssize_t ucma_leave_multicast(struct ucma_file *file,\n\t\t\t\t    const char __user *inbuf,\n\t\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_multicast *mc;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mut);\n\tmc = idr_find(&multicast_idr, cmd.id);\n\tif (!mc)\n\t\tmc = ERR_PTR(-ENOENT);\n\telse if (mc->ctx->file != file)\n\t\tmc = ERR_PTR(-EINVAL);\n\telse if (!atomic_inc_not_zero(&mc->ctx->ref))\n\t\tmc = ERR_PTR(-ENXIO);\n\telse\n\t\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\n\tif (IS_ERR(mc)) {\n\t\tret = PTR_ERR(mc);\n\t\tgoto out;\n\t}\n\n\trdma_leave_multicast(mc->ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tmutex_lock(&mc->ctx->file->mut);\n\tucma_cleanup_mc_events(mc);\n\tlist_del(&mc->list);\n\tmutex_unlock(&mc->ctx->file->mut);\n\n\tucma_put_ctx(mc->ctx);\n\tresp.events_reported = mc->events_reported;\n\tkfree(mc);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\nout:\n\treturn ret;\n}\n\nstatic void ucma_lock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\t/* Acquire mutex's based on pointer comparison to prevent deadlock. */\n\tif (file1 < file2) {\n\t\tmutex_lock(&file1->mut);\n\t\tmutex_lock_nested(&file2->mut, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tmutex_lock(&file2->mut);\n\t\tmutex_lock_nested(&file1->mut, SINGLE_DEPTH_NESTING);\n\t}\n}\n\nstatic void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\tif (file1 < file2) {\n\t\tmutex_unlock(&file2->mut);\n\t\tmutex_unlock(&file1->mut);\n\t} else {\n\t\tmutex_unlock(&file1->mut);\n\t\tmutex_unlock(&file2->mut);\n\t}\n}\n\nstatic void ucma_move_events(struct ucma_context *ctx, struct ucma_file *file)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list)\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &file->event_list);\n}\n\nstatic ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t/* Get current fd to protect against it being closed */\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\n\t/* Validate current fd and prevent destruction of id. */\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tresp.events_reported = ctx->events_reported;\n\t\tgoto response;\n\t}\n\n\t/*\n\t * Migrate events between fd's, maintaining order, and avoiding new\n\t * events being added before existing events.\n\t */\n\tucma_lock_files(cur_file, new_file);\n\tmutex_lock(&mut);\n\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\n\tmutex_unlock(&mut);\n\tucma_unlock_files(cur_file, new_file);\n\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic ssize_t (*ucma_cmd_table[])(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len) = {\n\t[RDMA_USER_CM_CMD_CREATE_ID] \t = ucma_create_id,\n\t[RDMA_USER_CM_CMD_DESTROY_ID]\t = ucma_destroy_id,\n\t[RDMA_USER_CM_CMD_BIND_IP]\t = ucma_bind_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_IP]\t = ucma_resolve_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_ROUTE] = ucma_resolve_route,\n\t[RDMA_USER_CM_CMD_QUERY_ROUTE]\t = ucma_query_route,\n\t[RDMA_USER_CM_CMD_CONNECT]\t = ucma_connect,\n\t[RDMA_USER_CM_CMD_LISTEN]\t = ucma_listen,\n\t[RDMA_USER_CM_CMD_ACCEPT]\t = ucma_accept,\n\t[RDMA_USER_CM_CMD_REJECT]\t = ucma_reject,\n\t[RDMA_USER_CM_CMD_DISCONNECT]\t = ucma_disconnect,\n\t[RDMA_USER_CM_CMD_INIT_QP_ATTR]\t = ucma_init_qp_attr,\n\t[RDMA_USER_CM_CMD_GET_EVENT]\t = ucma_get_event,\n\t[RDMA_USER_CM_CMD_GET_OPTION]\t = NULL,\n\t[RDMA_USER_CM_CMD_SET_OPTION]\t = ucma_set_option,\n\t[RDMA_USER_CM_CMD_NOTIFY]\t = ucma_notify,\n\t[RDMA_USER_CM_CMD_JOIN_IP_MCAST] = ucma_join_ip_multicast,\n\t[RDMA_USER_CM_CMD_LEAVE_MCAST]\t = ucma_leave_multicast,\n\t[RDMA_USER_CM_CMD_MIGRATE_ID]\t = ucma_migrate_id,\n\t[RDMA_USER_CM_CMD_QUERY]\t = ucma_query,\n\t[RDMA_USER_CM_CMD_BIND]\t\t = ucma_bind,\n\t[RDMA_USER_CM_CMD_RESOLVE_ADDR]\t = ucma_resolve_addr,\n\t[RDMA_USER_CM_CMD_JOIN_MCAST]\t = ucma_join_multicast\n};\n\nstatic ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\n\tif (!ib_safe_file_access(filp)) {\n\t\tpr_err_once(\"ucma_write: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\\n\",\n\t\t\t    task_tgid_vnr(current), current->comm);\n\t\treturn -EACCES;\n\t}\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n\nstatic __poll_t ucma_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct ucma_file *file = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &file->poll_wait, wait);\n\n\tif (!list_empty(&file->event_list))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * ucma_open() does not need the BKL:\n *\n *  - no global state is referred to;\n *  - there is no ioctl method to race against;\n *  - no further module initialization is required for open to work\n *    after the device is registered.\n */\nstatic int ucma_open(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file;\n\n\tfile = kmalloc(sizeof *file, GFP_KERNEL);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tfile->close_wq = alloc_ordered_workqueue(\"ucma_close_id\",\n\t\t\t\t\t\t WQ_MEM_RECLAIM);\n\tif (!file->close_wq) {\n\t\tkfree(file);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&file->event_list);\n\tINIT_LIST_HEAD(&file->ctx_list);\n\tinit_waitqueue_head(&file->poll_wait);\n\tmutex_init(&file->mut);\n\n\tfilp->private_data = file;\n\tfile->filp = filp;\n\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic int ucma_close(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct ucma_context *ctx, *tmp;\n\n\tmutex_lock(&file->mut);\n\tlist_for_each_entry_safe(ctx, tmp, &file->ctx_list, list) {\n\t\tctx->destroying = 1;\n\t\tmutex_unlock(&file->mut);\n\n\t\tmutex_lock(&mut);\n\t\tidr_remove(&ctx_idr, ctx->id);\n\t\tmutex_unlock(&mut);\n\n\t\tflush_workqueue(file->close_wq);\n\t\t/* At that step once ctx was marked as destroying and workqueue\n\t\t * was flushed we are safe from any inflights handlers that\n\t\t * might put other closing task.\n\t\t */\n\t\tmutex_lock(&mut);\n\t\tif (!ctx->closing) {\n\t\t\tmutex_unlock(&mut);\n\t\t\t/* rdma_destroy_id ensures that no event handlers are\n\t\t\t * inflight for that id before releasing it.\n\t\t\t */\n\t\t\trdma_destroy_id(ctx->cm_id);\n\t\t} else {\n\t\t\tmutex_unlock(&mut);\n\t\t}\n\n\t\tucma_free_ctx(ctx);\n\t\tmutex_lock(&file->mut);\n\t}\n\tmutex_unlock(&file->mut);\n\tdestroy_workqueue(file->close_wq);\n\tkfree(file);\n\treturn 0;\n}\n\nstatic const struct file_operations ucma_fops = {\n\t.owner \t = THIS_MODULE,\n\t.open \t = ucma_open,\n\t.release = ucma_close,\n\t.write\t = ucma_write,\n\t.poll    = ucma_poll,\n\t.llseek\t = no_llseek,\n};\n\nstatic struct miscdevice ucma_misc = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"rdma_cm\",\n\t.nodename\t= \"infiniband/rdma_cm\",\n\t.mode\t\t= 0666,\n\t.fops\t\t= &ucma_fops,\n};\n\nstatic ssize_t show_abi_version(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", RDMA_USER_CM_ABI_VERSION);\n}\nstatic DEVICE_ATTR(abi_version, S_IRUGO, show_abi_version, NULL);\n\nstatic int __init ucma_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&ucma_misc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_create_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tif (ret) {\n\t\tpr_err(\"rdma_ucm: couldn't create abi_version attr\\n\");\n\t\tgoto err1;\n\t}\n\n\tucma_ctl_table_hdr = register_net_sysctl(&init_net, \"net/rdma_ucm\", ucma_ctl_table);\n\tif (!ucma_ctl_table_hdr) {\n\t\tpr_err(\"rdma_ucm: couldn't register sysctl paths\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\treturn 0;\nerr2:\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\nerr1:\n\tmisc_deregister(&ucma_misc);\n\treturn ret;\n}\n\nstatic void __exit ucma_cleanup(void)\n{\n\tunregister_net_sysctl_table(ucma_ctl_table_hdr);\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tmisc_deregister(&ucma_misc);\n\tidr_destroy(&ctx_idr);\n\tidr_destroy(&multicast_idr);\n}\n\nmodule_init(ucma_init);\nmodule_exit(ucma_cleanup);\n"], "filenames": ["drivers/infiniband/core/ucma.c"], "buggy_code_start_loc": [238], "buggy_code_end_loc": [1422], "fixing_code_start_loc": [238], "fixing_code_end_loc": [1427], "type": "CWE-416", "message": "drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free).", "other": {"cve": {"id": "CVE-2018-14734", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-29T23:29:00.267", "lastModified": "2019-04-23T17:29:01.660", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free)."}, {"lang": "es", "value": "drivers/infiniband/core/ucma.c en el kernel de Linux hasta la versi\u00f3n 4.17.11 permite que ucma_leave_multicast acceda a cierta estructura de datos tras un paso de limpieza en ucma_process_join, lo que permite que los atacantes provoquen una denegaci\u00f3n de servicio (uso de memoria previamente liberada)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "COMPLETE", "baseScore": 6.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 8.5, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.17.11", "matchCriteriaId": "54818847-024D-471A-8E46-6E9884CD925E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=cb2595c1393b4a5211534e6f0a0fbad369e21ad8", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0831", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/cb2595c1393b4a5211534e6f0a0fbad369e21ad8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3797-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3797-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4308", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cb2595c1393b4a5211534e6f0a0fbad369e21ad8"}}