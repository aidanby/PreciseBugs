{"buggy_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\n\nfrom typing import Any, Dict, List, Mapping, Optional, Sequence, Text\n\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib import cache\n\nfrom zerver.lib.test_helpers import (\n    queries_captured, tornado_redirected_to_list\n)\n\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\n\nfrom zerver.decorator import (\n    JsonableError\n)\n\nfrom zerver.lib.response import (\n    json_error,\n    json_success,\n)\n\nfrom zerver.lib.test_runner import (\n    slow\n)\n\nfrom zerver.models import (\n    get_display_recipient, Message, Realm, Recipient, Stream, Subscription,\n    UserProfile, get_user_profile_by_id\n)\n\nfrom zerver.lib.actions import (\n    do_add_default_stream, do_change_is_admin, do_set_realm_waiting_period_threshold,\n    do_create_realm, do_remove_default_stream, do_set_realm_create_stream_by_admins_only,\n    gather_subscriptions_helper, bulk_add_subscriptions, bulk_remove_subscriptions,\n    gather_subscriptions, get_default_streams_for_realm, get_realm, get_stream,\n    get_user_profile_by_email, set_default_streams, get_subscription,\n    create_stream_if_needed, create_streams_if_needed, active_user_ids\n)\n\nfrom zerver.views.streams import (\n    compose_views\n)\n\nfrom django.http import HttpResponse\nimport mock\nimport random\nimport ujson\nimport six\nfrom six.moves import range, urllib, zip\n\nclass TestCreateStreams(ZulipTestCase):\n    def test_creating_streams(self):\n        # type: () -> None\n        stream_names = [u'new1', u'new2', u'new3']\n        stream_descriptions = [u'des1', u'des2', u'des3']\n        realm = get_realm('zulip')\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [{\"name\": stream_name,\n              \"description\": stream_description,\n              \"invite_only\": True}\n             for (stream_name, stream_description) in zip(stream_names, stream_descriptions)])\n\n        self.assertEqual(len(new_streams), 3)\n        self.assertEqual(len(existing_streams), 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.invite_only)\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [{\"name\": stream_name,\n              \"description\": stream_description,\n              \"invite_only\": True}\n             for (stream_name, stream_description) in zip(stream_names, stream_descriptions)])\n\n        self.assertEqual(len(new_streams), 0)\n        self.assertEqual(len(existing_streams), 3)\n\n        actual_stream_names = {stream.name for stream in existing_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in existing_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in existing_streams:\n            self.assertTrue(stream.invite_only)\n\nclass RecipientTest(ZulipTestCase):\n    def test_recipient(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        stream = get_stream('Verona', realm)\n        recipient = Recipient.objects.get(\n            type_id=stream.id,\n            type=Recipient.STREAM,\n        )\n        self.assertEqual(str(recipient), '<Recipient: Verona (%d, %d)>' % (\n            stream.id, Recipient.STREAM))\n\nclass StreamAdminTest(ZulipTestCase):\n    def test_make_stream_public(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        self.make_stream('private_stream', invite_only=True)\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('private_stream'),\n            'is_private': ujson.dumps(False)\n        }\n        stream_id = get_stream('private_stream', user_profile.realm).id\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_error(result, 'You are not invited to this stream.')\n\n        self.subscribe_to_stream(email, 'private_stream')\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('private_stream'),\n            'is_private': ujson.dumps(False)\n        }\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_success(result)\n\n        realm = user_profile.realm\n        stream = get_stream('private_stream', realm)\n        self.assertFalse(stream.invite_only)\n\n    def test_make_stream_private(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.make_stream('public_stream', realm=realm)\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('public_stream'),\n            'is_private': ujson.dumps(True)\n        }\n        stream_id = get_stream('public_stream', realm).id\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_success(result)\n        stream = get_stream('public_stream', realm)\n        self.assertTrue(stream.invite_only)\n\n    def test_deactivate_stream_backend(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        stream = self.make_stream('new_stream')\n        self.subscribe_to_stream(user_profile.email, stream.name)\n        do_change_is_admin(user_profile, True)\n\n        result = self.client_delete('/json/streams/%d' % (stream.id,))\n        self.assert_json_success(result)\n        subscription_exists = Subscription.objects.filter(\n            user_profile=user_profile,\n            recipient__type_id=stream.id,\n            recipient__type=Recipient.STREAM,\n            active=True,\n        ).exists()\n        self.assertFalse(subscription_exists)\n\n    def test_deactivate_stream_backend_requires_existing_stream(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        self.make_stream('new_stream')\n        do_change_is_admin(user_profile, True)\n\n        result = self.client_delete('/json/streams/999999999')\n        self.assert_json_error(result, u'Invalid stream id')\n\n    def test_deactivate_stream_backend_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        self.subscribe_to_stream(email, 'new_stream')\n\n        stream_id = get_stream('new_stream', user_profile.realm).id\n        result = self.client_delete('/json/streams/%d' % (stream_id,))\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def test_private_stream_live_updates(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        user_profile = get_user_profile_by_email(email)\n        do_change_is_admin(user_profile, True)\n\n        self.make_stream('private_stream', invite_only=True)\n        self.subscribe_to_stream(email, 'private_stream')\n        self.subscribe_to_stream('cordelia@zulip.com', 'private_stream')\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('private_stream', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'description': ujson.dumps('Test description')})\n        self.assert_json_success(result)\n        # Should be just a description change event\n        self.assert_length(events, 1)\n\n        cordelia = get_user_profile_by_email('cordelia@zulip.com')\n        prospero = get_user_profile_by_email('prospero@zulip.com')\n\n        notified_user_ids = set(events[-1]['users'])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        events = []\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('private_stream', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps('whatever')})\n        self.assert_json_success(result)\n        # Should be a name event and an email address event\n        self.assert_length(events, 2)\n\n        notified_user_ids = set(events[-1]['users'])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n    def test_rename_stream(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, True)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('stream_name1', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps('stream_name2')})\n        self.assert_json_success(result)\n\n        event = events[1]['event']\n        self.assertEqual(event, dict(\n            op='update',\n            type='stream',\n            property='name',\n            value='stream_name2',\n            name='stream_name1'\n        ))\n        notified_user_ids = set(events[1]['users'])\n\n        stream_name1_exists = get_stream('stream_name1', realm)\n        self.assertFalse(stream_name1_exists)\n        stream_name2_exists = get_stream('stream_name2', realm)\n        self.assertTrue(stream_name2_exists)\n\n        self.assertEqual(notified_user_ids, set(active_user_ids(realm)))\n        self.assertIn(user_profile.id,\n                      notified_user_ids)\n        self.assertIn(get_user_profile_by_email('prospero@zulip.com').id,\n                      notified_user_ids)\n\n        # Test case to handle unicode stream name change\n        # *NOTE: Here Encoding is needed when Unicode string is passed as an argument*\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name2_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'\u0928\u092f\u093e \u0928\u093e\u092e'.encode('utf-8'))})\n        self.assert_json_success(result)\n        # While querying, system can handle unicode strings.\n        stream_name_uni_exists = get_stream(u'\u0928\u092f\u093e \u0928\u093e\u092e', realm)\n        self.assertTrue(stream_name_uni_exists)\n\n        # Test case to handle changing of unicode stream name to newer name\n        # NOTE: Unicode string being part of URL is handled cleanly\n        # by client_patch call, encoding of URL is not needed.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_uni_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947'.encode('utf-8'))})\n        self.assert_json_success(result)\n        # While querying, system can handle unicode strings.\n        stream_name_old_uni_exists = get_stream(u'\u0928\u092f\u093e \u0928\u093e\u092e', realm)\n        self.assertFalse(stream_name_old_uni_exists)\n        stream_name_new_uni_exists = get_stream(u'\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947', realm)\n        self.assertTrue(stream_name_new_uni_exists)\n\n        # Test case to change name from one language to other.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_new_uni_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'fran\u00e7ais'.encode('utf-8'))})\n        self.assert_json_success(result)\n        stream_name_fr_exists = get_stream(u'fran\u00e7ais', realm)\n        self.assertTrue(stream_name_fr_exists)\n\n        # Test case to change name to mixed language name.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_fr_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'fran\u00e7ais name'.encode('utf-8'))})\n        self.assert_json_success(result)\n        stream_name_mixed_exists = get_stream(u'fran\u00e7ais name', realm)\n        self.assertTrue(stream_name_mixed_exists)\n\n    def test_rename_stream_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        self.make_stream('stream_name1')\n\n        stream_id = get_stream('stream_name1', user_profile.realm).id\n        result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                   {'new_name': ujson.dumps('stream_name2')})\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def test_change_stream_description(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, True)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('stream_name1', realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'description': ujson.dumps('Test description')})\n        self.assert_json_success(result)\n\n        event = events[0]['event']\n        self.assertEqual(event, dict(\n            op='update',\n            type='stream',\n            property='description',\n            value='Test description',\n            name='stream_name1'\n        ))\n        notified_user_ids = set(events[0]['users'])\n\n        stream = get_stream('stream_name1', realm)\n        self.assertEqual(notified_user_ids, set(active_user_ids(realm)))\n        self.assertIn(user_profile.id,\n                      notified_user_ids)\n        self.assertIn(get_user_profile_by_email('prospero@zulip.com').id,\n                      notified_user_ids)\n\n        self.assertEqual('Test description', stream.description)\n\n    def test_change_stream_description_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, False)\n\n        stream_id = get_stream('stream_name1', user_profile.realm).id\n        result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                   {'description': ujson.dumps('Test description')})\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def set_up_stream_for_deletion(self, stream_name, invite_only=False,\n                                   subscribed=True):\n        # type: (str, bool, bool) -> Stream\n        \"\"\"\n        Create a stream for deletion by an administrator.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        stream = self.make_stream(stream_name, invite_only=invite_only)\n\n        # For testing deleting streams you aren't on.\n        if subscribed:\n            self.subscribe_to_stream(email, stream_name)\n\n        do_change_is_admin(user_profile, True)\n\n        return stream\n\n    def delete_stream(self, stream, subscribed=True):\n        # type: (Stream, bool) -> None\n        \"\"\"\n        Delete the stream and assess the result.\n        \"\"\"\n        active_name = stream.name\n        realm = stream.realm\n        stream_id = stream.id\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            result = self.client_delete('/json/streams/' + str(stream_id))\n        self.assert_json_success(result)\n\n        deletion_events = [e['event'] for e in events if e['event']['type'] == 'subscription']\n        if subscribed:\n            self.assertEqual(deletion_events[0], dict(\n                op='remove',\n                type='subscription',\n                subscriptions=[{'name': active_name, 'stream_id': stream.id}]\n            ))\n        else:\n            # You could delete the stream, but you weren't on it so you don't\n            # receive an unsubscription event.\n            self.assertEqual(deletion_events, [])\n\n        with self.assertRaises(Stream.DoesNotExist):\n            Stream.objects.get(realm=get_realm(\"zulip\"), name=active_name)\n\n        # A deleted stream's name is changed, is deactivated, is invite-only,\n        # and has no subscribers.\n        deactivated_stream_name = \"!DEACTIVATED:\" + active_name\n        deactivated_stream = get_stream(deactivated_stream_name, realm)\n        self.assertTrue(deactivated_stream.deactivated)\n        self.assertTrue(deactivated_stream.invite_only)\n        self.assertEqual(deactivated_stream.name, deactivated_stream_name)\n        subscribers = self.users_subscribed_to_stream(\n            deactivated_stream_name, realm)\n        self.assertEqual(subscribers, [])\n\n        # It doesn't show up in the list of public streams anymore.\n        result = self.client_get(\"/json/streams?include_subscribed=false\")\n        public_streams = [s[\"name\"] for s in ujson.loads(result.content)[\"streams\"]]\n        self.assertNotIn(active_name, public_streams)\n        self.assertNotIn(deactivated_stream_name, public_streams)\n\n        # Even if you could guess the new name, you can't subscribe to it.\n        result = self.client_post(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": ujson.dumps([{\"name\": deactivated_stream_name}])})\n        self.assert_json_error(\n            result, \"Unable to access stream (%s).\" % (deactivated_stream_name,))\n\n    def test_delete_public_stream(self):\n        # type: () -> None\n        \"\"\"\n        When an administrator deletes a public stream, that stream is not\n        visible to users at all anymore.\n        \"\"\"\n        stream = self.set_up_stream_for_deletion(\"newstream\")\n        self.delete_stream(stream)\n\n    def test_delete_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        Administrators can delete private streams they are on.\n        \"\"\"\n        stream = self.set_up_stream_for_deletion(\"newstream\", invite_only=True)\n        self.delete_stream(stream)\n\n    def test_delete_streams_youre_not_on(self):\n        # type: () -> None\n        \"\"\"\n        Administrators can delete public streams they aren't on, but cannot\n        delete private streams they aren't on.\n        \"\"\"\n        pub_stream = self.set_up_stream_for_deletion(\n            \"pubstream\", subscribed=False)\n        self.delete_stream(pub_stream, subscribed=False)\n\n        priv_stream = self.set_up_stream_for_deletion(\n            \"privstream\", subscribed=False, invite_only=True)\n\n        result = self.client_delete('/json/streams/' + str(priv_stream.id))\n        self.assert_json_error(\n            result, \"Cannot administer invite-only streams this way\")\n\n    def attempt_unsubscribe_of_principal(self, is_admin=False, is_subbed=True,\n                                         invite_only=False, other_user_subbed=True):\n        # type: (bool, bool, bool, bool) -> HttpResponse\n\n        # Set up the main user, who is in most cases an admin.\n        email = \"hamlet@zulip.com\"\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        if is_admin:\n            do_change_is_admin(user_profile, True)\n\n        # Set up the stream.\n        stream_name = u\"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name, invite_only=invite_only)\n\n        # Set up the principal to be unsubscribed.\n        other_email = \"cordelia@zulip.com\"\n        other_user_profile = get_user_profile_by_email(other_email)\n\n        # Subscribe the admin and/or principal as specified in the flags.\n        if is_subbed:\n            self.subscribe_to_stream(user_profile.email, stream_name)\n        if other_user_subbed:\n            self.subscribe_to_stream(other_user_profile.email, stream_name)\n\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": ujson.dumps([stream_name]),\n             \"principals\": ujson.dumps([other_email])})\n\n        # If the removal succeeded, then assert that Cordelia is no longer subscribed.\n        if result.status_code not in [400]:\n            subbed_users = self.users_subscribed_to_stream(stream_name, other_user_profile.realm)\n            self.assertNotIn(other_user_profile, subbed_users)\n\n        return result\n\n    def test_cant_remove_others_from_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're not an admin, you can't remove other people from streams.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=False, is_subbed=True, invite_only=False,\n            other_user_subbed=True)\n        self.assert_json_error(\n            result, \"This action requires administrative rights\")\n\n    def test_admin_remove_others_from_public_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're an admin, you can remove people from public streams, even\n        those you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=True, invite_only=False,\n            other_user_subbed=True)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 1)\n        self.assertEqual(len(json[\"not_subscribed\"]), 0)\n\n    def test_admin_remove_others_from_subbed_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're an admin, you can remove other people from private streams you\n        are on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=True, invite_only=True,\n            other_user_subbed=True)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 1)\n        self.assertEqual(len(json[\"not_subscribed\"]), 0)\n\n    def test_admin_remove_others_from_unsubbed_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        Even if you're an admin, you can't remove people from private\n        streams you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=False, invite_only=True,\n            other_user_subbed=True)\n        self.assert_json_error(\n            result, \"Cannot administer invite-only streams this way\")\n\n    def test_create_stream_by_admins_only_setting(self):\n        # type: () -> None\n        \"\"\"\n        When realm.create_stream_by_admins_only setting is active and\n        the number of days since the user had joined is less than waiting period\n        threshold, non admin users shouldn't be able to create new streams.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        do_set_realm_create_stream_by_admins_only(user_profile.realm, True)\n\n        stream_name = ['adminsonlysetting']\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_error(result, 'User cannot create streams.')\n\n    def test_create_stream_by_waiting_period_threshold(self):\n        # type: () -> None\n        \"\"\"\n        Non admin users with account age greater or equal to waiting period\n        threshold should be able to create new streams.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        do_change_is_admin(user_profile, False)\n\n        do_set_realm_waiting_period_threshold(user_profile.realm, 10)\n\n        stream_name = ['waitingperiodtest']\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_error(result, 'User cannot create streams.')\n\n        do_set_realm_waiting_period_threshold(user_profile.realm, 0)\n\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_success(result)\n\n    def test_remove_already_not_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Trying to unsubscribe someone who already isn't subscribed to a stream\n        fails gracefully.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=False, invite_only=False,\n            other_user_subbed=False)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 0)\n        self.assertEqual(len(json[\"not_subscribed\"]), 1)\n\n    def test_remove_invalid_user(self):\n        # type: () -> None\n        \"\"\"\n        Trying to unsubscribe an invalid user from a stream fails gracefully.\n        \"\"\"\n        admin_email = \"hamlet@zulip.com\"\n        self.login(admin_email)\n        user_profile = get_user_profile_by_email(admin_email)\n        do_change_is_admin(user_profile, True)\n\n        stream_name = u\"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name)\n\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps([stream_name]),\n                                     \"principals\": ujson.dumps([\"baduser@zulip.com\"])})\n        self.assert_json_error(\n            result,\n            \"User not authorized to execute queries on behalf of 'baduser@zulip.com'\",\n            status_code=403)\n\nclass DefaultStreamTest(ZulipTestCase):\n    def get_default_stream_names(self, realm):\n        # type: (Realm) -> Set[Text]\n        streams = get_default_streams_for_realm(realm)\n        stream_names = [s.name for s in streams]\n        return set(stream_names)\n\n    def get_default_stream_descriptions(self, realm):\n        # type: (Realm) -> Set[Text]\n        streams = get_default_streams_for_realm(realm)\n        stream_descriptions = [s.description for s in streams]\n        return set(stream_descriptions)\n\n    def test_set_default_streams(self):\n        # type: () -> None\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n        stream_dict = {\n            \"apple\": {\"description\": \"A red fruit\", \"invite_only\": False},\n            \"banana\": {\"description\": \"A yellow fruit\", \"invite_only\": False},\n            \"Carrot Cake\": {\"description\": \"A delicious treat\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        expected_names = list(stream_dict.keys())\n        expected_names.append(\"announce\")\n        expected_descriptions = [i[\"description\"] for i in stream_dict.values()] + [\"\"]\n        set_default_streams(realm, stream_dict)\n        stream_names_set = self.get_default_stream_names(realm)\n        stream_descriptions_set = self.get_default_stream_descriptions(realm)\n        self.assertEqual(stream_names_set, set(expected_names))\n        self.assertEqual(stream_descriptions_set, set(expected_descriptions))\n\n    def test_set_default_streams_no_notifications_stream(self):\n        # type: () -> None\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n        realm.notifications_stream = None\n        realm.save(update_fields=[\"notifications_stream\"])\n        stream_dict = {\n            \"apple\": {\"description\": \"A red fruit\", \"invite_only\": False},\n            \"banana\": {\"description\": \"A yellow fruit\", \"invite_only\": False},\n            \"Carrot Cake\": {\"description\": \"A delicious treat\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        expected_names = list(stream_dict.keys())\n        expected_descriptions = [i[\"description\"] for i in stream_dict.values()]\n        set_default_streams(realm, stream_dict)\n        stream_names_set = self.get_default_stream_names(realm)\n        stream_descriptions_set = self.get_default_stream_descriptions(realm)\n        self.assertEqual(stream_names_set, set(expected_names))\n        self.assertEqual(stream_descriptions_set, set(expected_descriptions))\n\n    def test_add_and_remove_default_stream(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        orig_stream_names = self.get_default_stream_names(realm)\n        do_add_default_stream(realm, 'Added Stream')\n        new_stream_names = self.get_default_stream_names(realm)\n        added_stream_names = new_stream_names - orig_stream_names\n        self.assertEqual(added_stream_names, set(['Added Stream']))\n        # idempotentcy--2nd call to add_default_stream should be a noop\n        do_add_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), new_stream_names)\n\n        # start removing\n        do_remove_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n        # idempotentcy--2nd call to remove_default_stream should be a noop\n        do_remove_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n\n    def test_api_calls(self):\n        # type: () -> None\n        self.login(\"hamlet@zulip.com\")\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        do_change_is_admin(user_profile, True)\n        stream_name = 'stream ADDED via api'\n        result = self.client_post('/json/default_streams', dict(stream_name=stream_name))\n        self.assert_json_success(result)\n        self.assertTrue(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # and remove it\n        result = self.client_delete('/json/default_streams', dict(stream_name=stream_name))\n        self.assert_json_success(result)\n        self.assertFalse(stream_name in self.get_default_stream_names(user_profile.realm))\n\nclass SubscriptionPropertiesTest(ZulipTestCase):\n    def test_set_stream_color(self):\n        # type: () -> None\n        \"\"\"\n        A POST request to /json/subscriptions/property with stream_name and\n        color data sets the stream color, and for that stream only.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        old_subs, _ = gather_subscriptions(get_user_profile_by_email(test_email))\n        sub = old_subs[0]\n        stream_name = sub['name']\n        new_color = \"#ffffff\" # TODO: ensure that this is different from old_color\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": stream_name,\n                                                \"value\": \"#ffffff\"}])})\n\n        self.assert_json_success(result)\n\n        new_subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        found_sub = None\n        for sub in new_subs:\n            if sub['name'] == stream_name:\n                found_sub = sub\n                break\n\n        self.assertIsNotNone(found_sub)\n        self.assertEqual(found_sub['color'], new_color)\n\n        new_subs.remove(found_sub)\n        for sub in old_subs:\n            if sub['name'] == stream_name:\n                found_sub = sub\n                break\n        old_subs.remove(found_sub)\n        self.assertEqual(old_subs, new_subs)\n\n    def test_set_color_missing_stream_name(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a `stream` key.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"value\": \"#ffffff\"}])})\n\n        self.assert_json_error(\n            result, \"stream key is missing from subscription_data[0]\")\n\n    def test_set_color_unsubscribed_stream_name(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a subscribed stream.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        unsubs_stream = 'Rome'\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": unsubs_stream,\n                                                \"value\": \"#ffffff\"}])})\n        self.assert_json_error(\n            result, \"Not subscribed to stream %s\" % (unsubs_stream,))\n\n    def test_json_subscription_property_invalid_verb(self):\n        # type: () -> None\n        \"\"\"\n        Called by invalid request method. No other request method other than\n        'post' is allowed in this case.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n\n        result = self.client_get(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"in_home_view\",\n                                                \"stream\": subs[0][\"name\"],\n                                                \"value\": False}])})\n        self.assert_json_error(result, \"Invalid verb\")\n\n    def test_set_color_missing_color(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a color.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(\n            result, \"value key is missing from subscription_data[0]\")\n\n    def test_set_pin_to_top(self):\n        # type: () -> None\n        \"\"\"\n        A POST request to /json/subscriptions/property with stream_name and\n        pin_to_top data pins the stream.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        user_profile = get_user_profile_by_email(test_email)\n        old_subs, _ = gather_subscriptions(user_profile)\n        sub = old_subs[0]\n        stream_name = sub['name']\n        new_pin_to_top = not sub['pin_to_top']\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"pin_to_top\",\n                                                \"stream\": stream_name,\n                                                \"value\": new_pin_to_top}])})\n\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(stream_name, user_profile)\n\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.pin_to_top, new_pin_to_top)\n\n    def test_set_subscription_property_incorrect(self):\n        # type: () -> None\n        \"\"\"\n        Trying to set a property incorrectly returns a JSON error.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n\n        property_name = \"in_home_view\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"desktop_notifications\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"audible_notifications\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"color\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": False,\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a string' % (property_name,))\n\n    def test_json_subscription_property_invalid_stream(self):\n        # type: () -> None\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        stream_name = \"invalid_stream\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"in_home_view\",\n                                                \"stream\": stream_name,\n                                                \"value\": False}])})\n\n        self.assert_json_error(result, \"Invalid stream %s\" % (stream_name,))\n\n    def test_set_invalid_property(self):\n        # type: () -> None\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"bad\",\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               \"Unknown subscription property: bad\")\n\nclass SubscriptionRestApiTest(ZulipTestCase):\n    def test_basic_add_delete(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        # add\n        request = {\n            'add': ujson.dumps([{'name': 'my_test_stream_1'}])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_success(result)\n        streams = self.get_streams(email)\n        self.assertTrue('my_test_stream_1' in streams)\n\n        # now delete the same stream\n        request = {\n            'delete': ujson.dumps(['my_test_stream_1'])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_success(result)\n        streams = self.get_streams(email)\n        self.assertTrue('my_test_stream_1' not in streams)\n\n    def test_bad_add_parameters(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        def check_for_error(val, expected_message):\n            # type: (Any, str) -> None\n            request = {\n                'add': ujson.dumps(val)\n            }\n            result = self.client_patch(\n                \"/api/v1/users/me/subscriptions\",\n                request,\n                **self.api_auth(email)\n            )\n            self.assert_json_error(result, expected_message)\n\n        check_for_error(['foo'], 'add[0] is not a dict')\n        check_for_error([{'bogus': 'foo'}], 'name key is missing from add[0]')\n        check_for_error([{'name': {}}], 'add[0][\"name\"] is not a string')\n\n    def test_bad_principals(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        request = {\n            'add': ujson.dumps([{'name': 'my_new_stream'}]),\n            'principals': ujson.dumps([{}]),\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result, 'principals[0] is not a string')\n\n    def test_bad_delete_parameters(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        request = {\n            'delete': ujson.dumps([{'name': 'my_test_stream_1'}])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result, \"delete[0] is not a string\")\n\n    def test_add_or_delete_not_specified(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            {},\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               'Nothing to do. Specify at least one of \"add\" or \"delete\".')\n\n    def test_patch_enforces_valid_stream_name_check(self):\n        # type: () -> None\n        \"\"\"\n        Only way to force an error is with a empty string.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        invalid_stream_name = \"\"\n        request = {\n            'delete': ujson.dumps([invalid_stream_name])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               \"Invalid stream name (%s).\" % (invalid_stream_name,))\n\n    def test_stream_name_too_long(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        long_stream_name = \"a\" * 61\n        request = {\n            'delete': ujson.dumps([long_stream_name])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               \"Stream name (%s) too long.\" % (long_stream_name,))\n\n    def test_compose_views_rollback(self):\n        # type: () -> None\n        '''\n        The compose_views function() is used under the hood by\n        update_subscriptions_backend.  It's a pretty simple method in terms of\n        control flow, but it uses a Django rollback, which may make it brittle\n        code when we upgrade Django.  We test the functions's rollback logic\n        here with a simple scenario to avoid false positives related to\n        subscription complications.\n        '''\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        user_profile.full_name = 'Hamlet'\n        user_profile.save()\n\n        def method1(req, user_profile):\n            # type: (HttpRequest, UserProfile) -> HttpResponse\n            user_profile.full_name = 'Should not be committed'\n            user_profile.save()\n            return json_success()\n\n        def method2(req, user_profile):\n            # type: (HttpRequest, UserProfile) -> HttpResponse\n            return json_error(_('random failure'))\n\n        with self.assertRaises(JsonableError):\n            compose_views(None, user_profile, [(method1, {}), (method2, {})])\n\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        self.assertEqual(user_profile.full_name, 'Hamlet')\n\nclass SubscriptionAPITest(ZulipTestCase):\n\n    def setUp(self):\n        # type: () -> None\n        \"\"\"\n        All tests will be logged in as hamlet. Also save various useful values\n        as attributes that tests can access.\n        \"\"\"\n        self.test_email = \"hamlet@zulip.com\"\n        self.login(self.test_email)\n        self.user_profile = get_user_profile_by_email(self.test_email)\n        self.realm = self.user_profile.realm\n        self.streams = self.get_streams(self.test_email)\n\n    def make_random_stream_names(self, existing_stream_names):\n        # type: (List[Text]) -> List[Text]\n        \"\"\"\n        Helper function to make up random stream names. It takes\n        existing_stream_names and randomly appends a digit to the end of each,\n        but avoids names that appear in the list names_to_avoid.\n        \"\"\"\n        random_streams = []\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.realm)]\n        for stream in existing_stream_names:\n            random_stream = stream + str(random.randint(0, 9))\n            if random_stream not in all_stream_names:\n                random_streams.append(random_stream)\n        return random_streams\n\n    def test_successful_subscriptions_list(self):\n        # type: () -> None\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        email = self.test_email\n        result = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json['subscriptions']:\n            self.assertIsInstance(stream['name'], six.string_types)\n            self.assertIsInstance(stream['color'], six.string_types)\n            self.assertIsInstance(stream['invite_only'], bool)\n            # check that the stream name corresponds to an actual stream\n            try:\n                get_stream(stream['name'], self.realm)\n            except Stream.DoesNotExist:\n                self.fail(\"stream does not exist\")\n        list_streams = [stream['name'] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def helper_check_subs_before_and_after_add(self, subscriptions, other_params,\n                                               subscribed, already_subscribed,\n                                               email, new_subs, invite_only=False):\n        # type: (List[Text], Dict[str, Any], List[Text], List[Text], Text, List[Text], bool) -> None\n        \"\"\"\n        Check result of adding subscriptions.\n\n        You can add subscriptions for yourself or possibly many\n        principals, which is why e-mails map to subscriptions in the\n        result.\n\n        The result json is of the form\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"already_subscribed\": {\"iago@zulip.com\": [\"Venice\", \"Verona\"]},\n         \"subscribed\": {\"iago@zulip.com\": [\"Venice8\"]}}\n        \"\"\"\n        result = self.common_subscribe_to_streams(self.test_email, subscriptions,\n                                                  other_params, invite_only=invite_only)\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(sorted(subscribed), sorted(json[\"subscribed\"][email]))\n        self.assertEqual(sorted(already_subscribed), sorted(json[\"already_subscribed\"][email]))\n        new_streams = self.get_streams(email)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_add(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        add_streams = [u\"Verona2\", u\"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)  # necessary for full test coverage\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            self.helper_check_subs_before_and_after_add(self.streams + add_streams, {},\n                                                        add_streams, self.streams, self.test_email, self.streams + add_streams)\n        self.assert_length(events, 6)\n\n    def test_successful_subscriptions_add_with_announce(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)\n        add_streams = [u\"Verona2\", u\"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)\n        events = [] # type: List[Dict[str, Any]]\n        other_params = {\n            'announce': 'true',\n        }\n        notifications_stream = get_stream(self.streams[0], self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(self.test_email))\n        with tornado_redirected_to_list(events):\n            self.helper_check_subs_before_and_after_add(self.streams + add_streams, other_params,\n                                                        add_streams, self.streams, self.test_email, self.streams + add_streams)\n        self.assertEqual(len(events), 7)\n\n    def test_successful_subscriptions_notifies_pm(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                'announce': 'true',\n                'principals': '[\"%s\"]' % (self.user_profile.email,)\n            },\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.PERSONAL)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"Hi there!  %s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_subscriptions_notifies_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n\n        notifications_stream = get_stream(current_stream, self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(invitee))\n\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data=dict(\n                announce='true',\n                principals='[\"%s\"]' % (self.user_profile.email,)\n            ),\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"%s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_cross_realm_notification(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions in a new realm\n        should notify with a proper new stream link\n        \"\"\"\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n\n        notifications_stream = Stream.objects.get(name='announce', realm=realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        invite_streams = [\"cross_stream\"]\n\n        user = get_user_profile_by_email(\"AARON@zulip.com\")\n        user.realm = realm\n        user.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(user.email))\n\n        result = self.common_subscribe_to_streams(\n            user.email,\n            invite_streams,\n            extra_post_data=dict(\n                announce='true'\n            ),\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        stream_id = Stream.objects.latest('id').id\n        expected_rendered_msg = '<p>%s just created a new stream <a class=\"stream\" data-stream-id=\"%d\" href=\"/#narrow/stream/%s\">#%s</a>.</p>' % (\n            user.full_name, stream_id, invite_streams[0], invite_streams[0])\n        self.assertEqual(msg.rendered_content, expected_rendered_msg)\n\n    def test_successful_subscriptions_notifies_with_escaping(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        notifications_stream = get_stream(current_stream, self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        invite_streams = ['strange ) \\\\ test']\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                'announce': 'true',\n                'principals': '[\"%s\"]' % (self.user_profile.email,)\n            },\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"%s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_non_ascii_stream_subscription(self):\n        # type: () -> None\n        \"\"\"\n        Subscribing to a stream name with non-ASCII characters succeeds.\n        \"\"\"\n        self.helper_check_subs_before_and_after_add(self.streams + [u\"h\u00fcmb\u00fc\u01f5\"], {},\n                                                    [u\"h\u00fcmb\u00fc\u01f5\"], self.streams, self.test_email, self.streams + [u\"h\u00fcmb\u00fc\u01f5\"])\n\n    def test_subscriptions_add_too_long(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is >60\n        characters should return a JSON error.\n        \"\"\"\n        # character limit is 60 characters\n        long_stream_name = \"a\" * 61\n        result = self.common_subscribe_to_streams(self.test_email, [long_stream_name])\n        self.assert_json_error(result,\n                               \"Stream name (%s) too long.\" % (long_stream_name,))\n\n    def test_user_settings_for_adding_streams(self):\n        # type: () -> None\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=False):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream1'])\n            self.assert_json_error(result, 'User cannot create streams.')\n\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=True):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream2'])\n            self.assert_json_success(result)\n\n        # User should still be able to subscribe to an existing stream\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=False):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream2'])\n            self.assert_json_success(result)\n\n    def test_subscriptions_add_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid name is the empty string\n        invalid_stream_name = \"\"\n        result = self.common_subscribe_to_streams(self.test_email, [invalid_stream_name])\n        self.assert_json_error(result,\n                               \"Invalid stream name (%s).\" % (invalid_stream_name,))\n\n    def assert_adding_subscriptions_for_principal(self, invitee, streams, invite_only=False):\n        # type: (Text, List[Text], bool) -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on behalf of another principal (for\n        whom you have permission to add subscriptions) should successfully add\n        those subscriptions and send a message to the subscribee notifying\n        them.\n        \"\"\"\n        other_profile = get_user_profile_by_email(invitee)\n        current_streams = self.get_streams(invitee)\n        self.assertIsInstance(other_profile, UserProfile)\n        self.assertNotEqual(len(current_streams), 0)  # necessary for full test coverage\n        self.assertNotEqual(len(streams), 0)  # necessary for full test coverage\n        streams_to_sub = streams[:1]  # just add one, to make the message easier to check\n        streams_to_sub.extend(current_streams)\n        self.helper_check_subs_before_and_after_add(streams_to_sub,\n                                                    {\"principals\": ujson.dumps([invitee])}, streams[:1], current_streams,\n                                                    invitee, streams_to_sub, invite_only=invite_only)\n        # verify that the user was sent a message informing them about the subscription\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, msg.recipient.PERSONAL)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email(\"notification-bot@zulip.com\").id)\n        expected_msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                        \"subscribed you to the %sstream #**%s**.\"\n                        % (self.user_profile.full_name,\n                           '**invite-only** ' if invite_only else '',\n                           streams[0]))\n\n        if not get_stream(streams[0], other_profile.realm).invite_only:\n            expected_msg += (\"\\nYou can see historical content on a \"\n                             \"non-invite-only stream by narrowing to it.\")\n        self.assertEqual(msg.content, expected_msg)\n        recipients = get_display_recipient(msg.recipient)\n        self.assertEqual(len(recipients), 1)\n        assert isinstance(recipients, Sequence)\n        assert isinstance(recipients[0], Mapping)\n        # The 2 assert statements above are required to make the mypy check pass.\n        # They inform mypy that in the line below, recipients is a Sequence of Mappings.\n        self.assertEqual(recipients[0]['email'], invitee)\n\n    def test_multi_user_subscription(self):\n        # type: () -> None\n        email1 = 'cordelia@zulip.com'\n        email2 = 'iago@zulip.com'\n        realm = get_realm(\"zulip\")\n        streams_to_sub = ['multi_user_stream']\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams_to_sub,\n                    dict(principals=ujson.dumps([email1, email2])),\n                )\n        self.assert_max_length(queries, 43)\n\n        self.assert_length(events, 8)\n        for ev in [x for x in events if x['event']['type'] not in ('message', 'stream')]:\n            if isinstance(ev['event']['subscriptions'][0], dict):\n                self.assertEqual(ev['event']['op'], 'add')\n                self.assertEqual(\n                    set(ev['event']['subscriptions'][0]['subscribers']),\n                    set([email1, email2])\n                )\n            else:\n                # Check \"peer_add\" events for streams users were\n                # never subscribed to, in order for the neversubscribed\n                # structure to stay up-to-date.\n                self.assertEqual(ev['event']['op'], 'peer_add')\n\n        stream = get_stream('multi_user_stream', realm)\n        self.assertEqual(stream.num_subscribers(), 2)\n\n        # Now add ourselves\n        events = []\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams_to_sub,\n                    dict(principals=ujson.dumps([self.test_email])),\n                )\n        self.assert_max_length(queries, 8)\n\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [get_user_profile_by_email(self.test_email).id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([email1, email2, self.test_email])\n        )\n\n        self.assertEqual(len(add_peer_event['users']), 16)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], self.user_profile.id)\n\n        stream = get_stream('multi_user_stream', realm)\n        self.assertEqual(stream.num_subscribers(), 3)\n\n        # Finally, add othello.\n        events = []\n        email3 = 'othello@zulip.com'\n        user_profile = get_user_profile_by_email(email3)\n        stream = get_stream('multi_user_stream', realm)\n        with tornado_redirected_to_list(events):\n            bulk_add_subscriptions([stream], [user_profile])\n\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [get_user_profile_by_email(email3).id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([email1, email2, email3, self.test_email])\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event['users'])\n        self.assertEqual(len(add_peer_event['users']), 16)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], user_profile.id)\n\n    def test_private_stream_subscription(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n\n        # Create a private stream with Hamlet subscribed\n        stream_name = \"private\"\n        (stream, _) = create_stream_if_needed(realm, stream_name, invite_only=True)\n\n        existing_email = \"hamlet@zulip.com\"\n        existing_user_profile = get_user_profile_by_email(existing_email)\n        bulk_add_subscriptions([stream], [existing_user_profile])\n\n        # Now subscribe Cordelia to the stream, capturing events\n        email = 'cordelia@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            bulk_add_subscriptions([stream], [user_profile])\n\n        self.assert_length(events, 3)\n        create_event, add_event, add_peer_event = events\n\n        self.assertEqual(create_event['event']['type'], 'stream')\n        self.assertEqual(create_event['event']['op'], 'create')\n        self.assertEqual(create_event['users'], [user_profile.id])\n        self.assertEqual(create_event['event']['streams'][0]['name'], stream_name)\n\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [user_profile.id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([user_profile.email, existing_user_profile.email])\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event['users'])\n        self.assertEqual(len(add_peer_event['users']), 1)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], user_profile.id)\n\n    def test_users_getting_add_peer_event(self):\n        # type: () -> None\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        streams_to_sub = ['multi_user_stream']\n        users_to_subscribe = [self.test_email, \"othello@zulip.com\"]\n        self.common_subscribe_to_streams(\n            self.test_email,\n            streams_to_sub,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n\n        new_users_to_subscribe = [\"iago@zulip.com\", \"cordelia@zulip.com\"]\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            self.common_subscribe_to_streams(\n                self.test_email,\n                streams_to_sub,\n                dict(principals=ujson.dumps(new_users_to_subscribe)),\n            )\n\n        add_peer_events = [events[2], events[3]]\n        for add_peer_event in add_peer_events:\n            self.assertEqual(add_peer_event['event']['type'], 'subscription')\n            self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n            event_sent_to_ids = add_peer_event['users']\n            user_dict = [get_user_profile_by_id(user_id).email\n                         for user_id in event_sent_to_ids]\n            for user in new_users_to_subscribe:\n                # Make sure new users subscribed to stream is not in\n                # peer_add event recipient list\n                self.assertNotIn(user, user_dict)\n            for old_user in users_to_subscribe:\n                # Check non new users are in peer_add event recipient list.\n                self.assertIn(old_user, user_dict)\n\n    def test_users_getting_remove_peer_event(self):\n        # type: () -> None\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        email1 = 'othello@zulip.com'\n        email2 = 'cordelia@zulip.com'\n        email3 = 'hamlet@zulip.com'\n        email4 = 'iago@zulip.com'\n\n        stream1 = self.make_stream('stream1')\n        stream2 = self.make_stream('stream2')\n        private = self.make_stream('private_stream', invite_only=True)\n\n        self.subscribe_to_stream(email1, 'stream1')\n        self.subscribe_to_stream(email2, 'stream1')\n        self.subscribe_to_stream(email3, 'stream1')\n\n        self.subscribe_to_stream(email2, 'stream2')\n\n        self.subscribe_to_stream(email1, 'private_stream')\n        self.subscribe_to_stream(email2, 'private_stream')\n        self.subscribe_to_stream(email3, 'private_stream')\n\n        user1 = get_user_profile_by_email(email1)\n        user2 = get_user_profile_by_email(email2)\n        user3 = get_user_profile_by_email(email3)\n        user4 = get_user_profile_by_email(email4)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            bulk_remove_subscriptions(\n                users=[user1, user2],\n                streams=[stream1, stream2, private]\n            )\n\n        peer_events = [e for e in events\n                       if e['event'].get('op') == 'peer_remove']\n\n        notifications = set()\n        for event in peer_events:\n            for user_id in event['users']:\n                for stream_name in event['event']['subscriptions']:\n                    removed_user_id = event['event']['user_id']\n                    notifications.add((user_id, removed_user_id, stream_name))\n\n        # POSITIVE CASES FIRST\n        self.assertIn((user3.id, user1.id, 'stream1'), notifications)\n        self.assertIn((user4.id, user1.id, 'stream1'), notifications)\n\n        self.assertIn((user3.id, user2.id, 'stream1'), notifications)\n        self.assertIn((user4.id, user2.id, 'stream1'), notifications)\n\n        self.assertIn((user1.id, user2.id, 'stream2'), notifications)\n        self.assertIn((user3.id, user2.id, 'stream2'), notifications)\n        self.assertIn((user4.id, user2.id, 'stream2'), notifications)\n\n        self.assertIn((user3.id, user1.id, 'private_stream'), notifications)\n        self.assertIn((user3.id, user2.id, 'private_stream'), notifications)\n\n        # NEGATIVE\n\n        # don't be notified if you are being removed yourself\n        self.assertNotIn((user1.id, user1.id, 'stream1'), notifications)\n\n        # don't send false notifications for folks that weren't actually\n        # subscribed int he first place\n        self.assertNotIn((user3.id, user1.id, 'stream2'), notifications)\n\n        # don't send notifications for random people\n        self.assertNotIn((user3.id, user4.id, 'stream2'), notifications)\n\n        # don't send notifications to unsubscribed people for private streams\n        self.assertNotIn((user4.id, user1.id, 'private_stream'), notifications)\n\n    def test_bulk_subscribe_MIT(self):\n        # type: () -> None\n        realm = get_realm(\"mit\")\n        streams = [\"stream_%s\" % i for i in range(40)]\n        for stream_name in streams:\n            self.make_stream(stream_name, realm=realm)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    'starnine@mit.edu',\n                    streams,\n                    dict(principals=ujson.dumps(['starnine@mit.edu'])),\n                )\n        # Make sure Zephyr mirroring realms such as MIT do not get\n        # any tornado subscription events\n        self.assert_length(events, 0)\n        self.assert_max_length(queries, 7)\n\n    def test_bulk_subscribe_many(self):\n        # type: () -> None\n\n        # Create a whole bunch of streams\n        streams = [\"stream_%s\" % i for i in range(20)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams,\n                    dict(principals=ujson.dumps([self.test_email])),\n                )\n        # Make sure we don't make O(streams) queries\n        self.assert_max_length(queries, 10)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_subscriptions_add_for_principal(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to streams.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_subscriptions_add_for_principal_invite_only(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to invite only streams.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams,\n                                                       invite_only=True)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_non_ascii_subscription_for_principal(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to streams even if they containing\n        non-ASCII characters.\n        \"\"\"\n        self.assert_adding_subscriptions_for_principal(\"iago@zulip.com\", [u\"h\u00fcmb\u00fc\u01f5\"])\n\n    def test_subscription_add_invalid_principal(self):\n        # type: () -> None\n        \"\"\"\n        Calling subscribe on behalf of a principal that does not exist\n        should return a JSON error.\n        \"\"\"\n        invalid_principal = \"rosencrantz-and-guildenstern@zulip.com\"\n        # verify that invalid_principal actually doesn't exist\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user_profile_by_email(invalid_principal)\n        result = self.common_subscribe_to_streams(self.test_email, self.streams,\n                                                  {\"principals\": ujson.dumps([invalid_principal])})\n        self.assert_json_error(result, \"User not authorized to execute queries on behalf of '%s'\"\n                               % (invalid_principal,), status_code=403)\n\n    def test_subscription_add_principal_other_realm(self):\n        # type: () -> None\n        \"\"\"\n        Calling subscribe on behalf of a principal in another realm\n        should return a JSON error.\n        \"\"\"\n        principal = \"starnine@mit.edu\"\n        profile = get_user_profile_by_email(principal)\n        # verify that principal exists (thus, the reason for the error is the cross-realming)\n        self.assertIsInstance(profile, UserProfile)\n        result = self.common_subscribe_to_streams(self.test_email, self.streams,\n                                                  {\"principals\": ujson.dumps([principal])})\n        self.assert_json_error(result, \"User not authorized to execute queries on behalf of '%s'\"\n                               % (principal,), status_code=403)\n\n    def helper_check_subs_before_and_after_remove(self, subscriptions, json_dict,\n                                                  email, new_subs):\n        # type: (List[Text], Dict[str, Any], Text, List[Text]) -> None\n        \"\"\"\n        Check result of removing subscriptions.\n\n        Unlike adding subscriptions, you can only remove subscriptions\n        for yourself, so the result format is different.\n\n        {\"msg\": \"\",\n         \"removed\": [\"Denmark\", \"Scotland\", \"Verona\"],\n         \"not_subscribed\": [\"Rome\"], \"result\": \"success\"}\n        \"\"\"\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps(subscriptions)})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        for key, val in six.iteritems(json_dict):\n            self.assertEqual(sorted(val), sorted(json[key]))  # we don't care about the order of the items\n        new_streams = self.get_streams(email)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_remove(self):\n        # type: () -> None\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions should successfully remove streams,\n        and should determine which were removed vs which weren't subscribed to.\n        We cannot randomly generate stream names because the remove code\n        verifies whether streams exist.\n        \"\"\"\n        if len(self.streams) < 2:\n            self.fail()  # necesssary for full test coverage\n        streams_to_remove = self.streams[1:]\n        not_subbed = []\n        for stream in Stream.objects.all():\n            if stream.name not in self.streams:\n                not_subbed.append(stream.name)\n        random.shuffle(not_subbed)\n        self.assertNotEqual(len(not_subbed), 0)  # necessary for full test coverage\n        try_to_remove = not_subbed[:3]  # attempt to remove up to 3 streams not already subbed to\n        streams_to_remove.extend(try_to_remove)\n        self.helper_check_subs_before_and_after_remove(streams_to_remove,\n                                                       {\"removed\": self.streams[1:], \"not_subscribed\": try_to_remove},\n                                                       self.test_email, [self.streams[0]])\n\n    def test_subscriptions_remove_fake_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions on a stream that doesn't exist\n        should return a JSON error.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        streams_to_remove = random_streams[:1]  # pick only one fake stream, to make checking the error message easy\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps(streams_to_remove)})\n        self.assert_json_error(result, \"Stream(s) (%s) do not exist\" % (random_streams[0],))\n\n    def helper_subscriptions_exists(self, stream, exists, subscribed):\n        # type: (Text, bool, bool) -> None\n        \"\"\"\n        A helper function that calls /json/subscriptions/exists on a stream and\n        verifies that the returned JSON dictionary has the exists and\n        subscribed values passed in as parameters. (If subscribed should not be\n        present, pass in None.)\n        \"\"\"\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": stream})\n        json = ujson.loads(result.content)\n        self.assertIn(\"exists\", json)\n        self.assertEqual(json[\"exists\"], exists)\n        if exists:\n            self.assert_json_success(result)\n        else:\n            self.assertEqual(result.status_code, 404)\n        if subscribed:\n            self.assertIn(\"subscribed\", json)\n            self.assertEqual(json[\"subscribed\"], subscribed)\n\n    def test_successful_subscriptions_exists_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are subbed\n        should return that it exists and that you are subbed.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(self.streams[0], True, True)\n\n    def test_successful_subscriptions_exists_not_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are not\n        subbed should return that it exists and that you are not subbed.\n        \"\"\"\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.realm)]\n        streams_not_subbed = list(set(all_stream_names) - set(self.streams))\n        self.assertNotEqual(len(streams_not_subbed), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(streams_not_subbed[0], True, False)\n\n    def test_subscriptions_does_not_exist(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream that doesn't exist should\n        return that it doesn't exist.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(random_streams[0], False, False)\n\n    def test_subscriptions_exist_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid stream name is the empty string\n        invalid_stream_name = \"\"\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": invalid_stream_name})\n        self.assert_json_error(result, \"Invalid characters in stream name\")\n\n    def test_existing_subscriptions_autosubscription(self):\n        # type: () -> None\n        \"\"\"\n        Call /json/subscriptions/exist on an existing stream and autosubscribe to it.\n        \"\"\"\n        stream_name = self.streams[0]\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": stream_name, \"autosubscribe\": True})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"exists\", json)\n        self.assertTrue(json[\"exists\"])\n\n    def get_subscription(self, user_profile, stream_name):\n        # type: (UserProfile, Text) -> Subscription\n        stream = get_stream(stream_name, self.realm)\n        return Subscription.objects.get(\n            user_profile=user_profile,\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=stream.id,\n        )\n\n    def test_subscriptions_add_notification_default_true(self):\n        # type: () -> None\n        \"\"\"\n        When creating a subscription, the desktop and audible notification\n        settings for that stream are derived from the global notification\n        settings.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        user_profile = get_user_profile_by_email(invitee)\n        user_profile.enable_stream_desktop_notifications = True\n        user_profile.enable_stream_sounds = True\n        user_profile.save()\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n\n        with mock.patch('zerver.models.Recipient.__unicode__', return_value='recip'):\n            self.assertEqual(str(subscription),\n                             u'<Subscription: '\n                             '<UserProfile: iago@zulip.com <Realm: zulip.com 1>> -> recip>')\n\n        self.assertTrue(subscription.desktop_notifications)\n        self.assertTrue(subscription.audible_notifications)\n\n    def test_subscriptions_add_notification_default_false(self):\n        # type: () -> None\n        \"\"\"\n        When creating a subscription, the desktop and audible notification\n        settings for that stream are derived from the global notification\n        settings.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        user_profile = get_user_profile_by_email(invitee)\n        user_profile.enable_stream_desktop_notifications = False\n        user_profile.enable_stream_sounds = False\n        user_profile.save()\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n        self.assertFalse(subscription.desktop_notifications)\n        self.assertFalse(subscription.audible_notifications)\n\n\nclass GetPublicStreamsTest(ZulipTestCase):\n\n    def test_public_streams_api(self):\n        # type: () -> None\n        \"\"\"\n        Ensure that the query we use to get public streams successfully returns\n        a list of streams\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        # Check it correctly lists the user's subs with include_public=false\n        result = self.client_get(\"/api/v1/streams?include_public=false\", **self.api_auth(email))\n        result2 = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n\n        self.assertIn(\"streams\", json)\n\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(result2)\n        json2 = ujson.loads(result2.content)\n\n        self.assertEqual(sorted([s[\"name\"] for s in json[\"streams\"]]),\n                         sorted([s[\"name\"] for s in json2[\"subscriptions\"]]))\n\n        # Check it correctly lists all public streams with include_subscribed=false\n        result = self.client_get(\"/api/v1/streams?include_public=true&include_subscribed=false\",\n                                 **self.api_auth(email))\n        self.assert_json_success(result)\n\n        json = ujson.loads(result.content)\n        all_streams = [stream.name for stream in\n                       Stream.objects.filter(realm=get_user_profile_by_email(email).realm)]\n        self.assertEqual(sorted(s[\"name\"] for s in json[\"streams\"]),\n                         sorted(all_streams))\n\n        # Check non-superuser can't use include_all_active\n        result = self.client_get(\"/api/v1/streams?include_all_active=true\",\n                                 **self.api_auth(email))\n        self.assertEqual(result.status_code, 400)\n\nclass StreamIdTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email = \"hamlet@zulip.com\"\n        self.user_profile = get_user_profile_by_email(self.email)\n        self.login(self.email)\n\n    def test_get_stream_id(self):\n        # type: () -> None\n        stream = gather_subscriptions(self.user_profile)[0][0]\n        result = self.client_get(\"/json/get_stream_id?stream=%s\" % (stream['name'],))\n        self.assert_json_success(result)\n        self.assertEqual(result.json()['stream_id'], stream['stream_id'])\n\n    def test_get_stream_id_wrong_name(self):\n        # type: () -> None\n        result = self.client_get(\"/json/get_stream_id?stream=wrongname\")\n        self.assert_json_error(result, u'No such stream name')\n\nclass InviteOnlyStreamTest(ZulipTestCase):\n    def test_must_be_subbed_to_send(self):\n        # type: () -> None\n        \"\"\"\n        If you try to send a message to an invite-only stream to which\n        you aren't subscribed, you'll get a 400.\n        \"\"\"\n        self.login(\"hamlet@zulip.com\")\n        # Create Saxony as an invite-only stream.\n        self.assert_json_success(\n            self.common_subscribe_to_streams(\"hamlet@zulip.com\", [\"Saxony\"],\n                                             invite_only=True))\n\n        email = \"cordelia@zulip.com\"\n        with self.assertRaises(JsonableError):\n            self.send_message(email, \"Saxony\", Recipient.STREAM)\n\n    def test_list_respects_invite_only_bit(self):\n        # type: () -> None\n        \"\"\"\n        Make sure that /api/v1/users/me/subscriptions properly returns\n        the invite-only bit for streams that are invite-only\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        result1 = self.common_subscribe_to_streams(email, [\"Saxony\"], invite_only=True)\n        self.assert_json_success(result1)\n        result2 = self.common_subscribe_to_streams(email, [\"Normandy\"], invite_only=False)\n        self.assert_json_success(result2)\n        result = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"subscriptions\", json)\n        for sub in json[\"subscriptions\"]:\n            if sub['name'] == \"Normandy\":\n                self.assertEqual(sub['invite_only'], False, \"Normandy was mistakenly marked invite-only\")\n            if sub['name'] == \"Saxony\":\n                self.assertEqual(sub['invite_only'], True, \"Saxony was not properly marked invite-only\")\n\n    @slow(\"lots of queries\")\n    def test_inviteonly(self):\n        # type: () -> None\n        # Creating an invite-only stream is allowed\n        email = 'hamlet@zulip.com'\n        stream_name = \"Saxony\"\n\n        result = self.common_subscribe_to_streams(email, [stream_name], invite_only=True)\n        self.assert_json_success(result)\n\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"subscribed\"], {email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Subscribing oneself to an invite-only stream is not allowed\n        email = \"othello@zulip.com\"\n        self.login(email)\n        result = self.common_subscribe_to_streams(email, [stream_name])\n        self.assert_json_error(result, 'Unable to access stream (Saxony).')\n\n        # authorization_errors_fatal=False works\n        email = \"othello@zulip.com\"\n        self.login(email)\n        result = self.common_subscribe_to_streams(email, [stream_name],\n                                                  extra_post_data={'authorization_errors_fatal': ujson.dumps(False)})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"unauthorized\"], [stream_name])\n        self.assertEqual(json[\"subscribed\"], {})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Inviting another user to an invite-only stream is allowed\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        result = self.common_subscribe_to_streams(\n            email, [stream_name],\n            extra_post_data={'principals': ujson.dumps([\"othello@zulip.com\"])})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"subscribed\"], {\"othello@zulip.com\": [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Make sure both users are subscribed to this stream\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.client_get(\"/api/v1/streams/%d/members\" % (stream_id,),\n                                 **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n\n        self.assertTrue('othello@zulip.com' in json['subscribers'])\n        self.assertTrue('hamlet@zulip.com' in json['subscribers'])\n\nclass GetSubscribersTest(ZulipTestCase):\n\n    def setUp(self):\n        # type: () -> None\n        self.email = \"hamlet@zulip.com\"\n        self.user_profile = get_user_profile_by_email(self.email)\n        self.login(self.email)\n\n    def check_well_formed_result(self, result, stream_name, realm):\n        # type: (Dict[str, Any], Text, Realm) -> None\n        \"\"\"\n        A successful call to get_subscribers returns the list of subscribers in\n        the form:\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"subscribers\": [\"hamlet@zulip.com\", \"prospero@zulip.com\"]}\n        \"\"\"\n        self.assertIn(\"subscribers\", result)\n        self.assertIsInstance(result[\"subscribers\"], list)\n        true_subscribers = [user_profile.email for user_profile in self.users_subscribed_to_stream(\n            stream_name, realm)]\n        self.assertEqual(sorted(result[\"subscribers\"]), sorted(true_subscribers))\n\n    def make_subscriber_request(self, stream_id, email=None):\n        # type: (int, Optional[str]) -> HttpResponse\n        if email is None:\n            email = self.email\n        return self.client_get(\"/api/v1/streams/%d/members\" % (stream_id,),\n                               **self.api_auth(email))\n\n    def make_successful_subscriber_request(self, stream_name):\n        # type: (Text) -> None\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        result = self.make_subscriber_request(stream_id)\n        self.assert_json_success(result)\n        self.check_well_formed_result(ujson.loads(result.content),\n                                      stream_name, self.user_profile.realm)\n\n    def test_subscriber(self):\n        # type: () -> None\n        \"\"\"\n        get_subscribers returns the list of subscribers.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0]['name']\n        self.make_successful_subscriber_request(stream_name)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_gather_subscriptions(self):\n        # type: () -> None\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        streams = [\"stream_%s\" % i for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        users_to_subscribe = [self.email, \"othello@zulip.com\", \"cordelia@zulip.com\"]\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            streams,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n        self.assert_json_success(ret)\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            [\"stream_invite_only_1\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n\n        with queries_captured() as queries:\n            subscriptions = gather_subscriptions(self.user_profile)\n        self.assertTrue(len(subscriptions[0]) >= 11)\n        for sub in subscriptions[0]:\n            if not sub[\"name\"].startswith(\"stream_\"):\n                continue\n            self.assertTrue(len(sub[\"subscribers\"]) == len(users_to_subscribe))\n        self.assert_length(queries, 4)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_never_subscribed_streams(self):\n        # type: () -> None\n        \"\"\"\n        Check never_subscribed streams are fetched correctly and not include invite_only streams.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        streams = [\"stream_%s\" % i for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name, realm=realm)\n        users_to_subscribe = [\"othello@zulip.com\", \"cordelia@zulip.com\"]\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            streams,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n        self.assert_json_success(ret)\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            [\"stream_invite_only_1\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n        with queries_captured() as queries:\n            subscribed, unsubscribed, never_subscribed = gather_subscriptions_helper(self.user_profile)\n        self.assertTrue(len(never_subscribed) >= 10)\n\n        # Invite only stream should not be there in never_subscribed streams\n        for stream_dict in never_subscribed:\n            if stream_dict[\"name\"].startswith(\"stream_\"):\n                self.assertFalse(stream_dict['name'] == \"stream_invite_only_1\")\n                self.assertTrue(len(stream_dict[\"subscribers\"]) == len(users_to_subscribe))\n        self.assert_length(queries, 3)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_gather_subscriptions_mit(self):\n        # type: () -> None\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        # Subscribe only ourself because invites are disabled on mit.edu\n        users_to_subscribe = [\"starnine@mit.edu\", \"espuser@mit.edu\"]\n        for email in users_to_subscribe:\n            self.subscribe_to_stream(email, \"mit_stream\")\n\n        ret = self.common_subscribe_to_streams(\n            \"starnine@mit.edu\",\n            [\"mit_invite_only\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n\n        with queries_captured() as queries:\n            subscriptions = gather_subscriptions(get_user_profile_by_email(\"starnine@mit.edu\"))\n\n        self.assertTrue(len(subscriptions[0]) >= 2)\n        for sub in subscriptions[0]:\n            if not sub[\"name\"].startswith(\"mit_\"):\n                continue\n            if sub[\"name\"] == \"mit_invite_only\":\n                self.assertTrue(len(sub[\"subscribers\"]) == len(users_to_subscribe))\n            else:\n                self.assertTrue(len(sub[\"subscribers\"]) == 0)\n        self.assert_length(queries, 4)\n\n    def test_nonsubscriber(self):\n        # type: () -> None\n        \"\"\"\n        Even a non-subscriber to a public stream can query a stream's membership\n        with get_subscribers.\n        \"\"\"\n        # Create a stream for which Hamlet is the only subscriber.\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.email, [stream_name])\n        other_email = \"othello@zulip.com\"\n\n        # Fetch the subscriber list as a non-member.\n        self.login(other_email)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_subscriber_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        A subscriber to a private stream can query that stream's membership.\n        \"\"\"\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.email, [stream_name],\n                                         invite_only=True)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_json_get_subscribers_stream_not_exist(self):\n        # type: () -> None\n        \"\"\"\n        json_get_subscribers also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_id = 99999999\n        result = self.client_get(\"/json/streams/%d/members\" % (stream_id,))\n        self.assert_json_error(result, u'Invalid stream id')\n\n    def test_json_get_subscribers(self):\n        # type: () -> None\n        \"\"\"\n        json_get_subscribers in zerver/views/streams.py\n        also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0]['name']\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        expected_subscribers = gather_subscriptions(self.user_profile)[0][0]['subscribers']\n        result = self.client_get(\"/json/streams/%d/members\" % (stream_id,))\n        self.assert_json_success(result)\n        result_dict = ujson.loads(result.content)\n        self.assertIn('subscribers', result_dict)\n        self.assertIsInstance(result_dict['subscribers'], list)\n        subscribers = [] # type: List[Text]\n        for subscriber in result_dict['subscribers']:\n            self.assertIsInstance(subscriber, six.string_types)\n            subscribers.append(subscriber)\n        self.assertEqual(set(subscribers), set(expected_subscribers))\n\n    def test_nonsubscriber_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        A non-subscriber to a private stream can't query that stream's membership.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        stream_name = \"NewStream\"\n        self.common_subscribe_to_streams(self.email, [stream_name],\n                                         invite_only=True)\n        other_email = \"othello@zulip.com\"\n        user_profile = get_user_profile_by_email(other_email)\n\n        # Try to fetch the subscriber list as a non-member.\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.make_subscriber_request(stream_id, email=other_email)\n        self.assert_json_error(result,\n                               \"Unable to retrieve subscribers for invite-only stream\")\n", "from __future__ import absolute_import\nfrom typing import Any, Optional, Tuple, List, Set, Iterable, Mapping, Callable, Dict\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.http import HttpRequest, HttpResponse\n\nfrom zerver.lib.request import JsonableError, REQ, has_request_variables\nfrom zerver.decorator import authenticated_json_post_view, \\\n    authenticated_json_view, \\\n    get_user_profile_by_email, require_realm_admin, to_non_negative_int\nfrom zerver.lib.actions import bulk_remove_subscriptions, \\\n    do_change_subscription_property, internal_prep_message, \\\n    create_streams_if_needed, gather_subscriptions, subscribed_to_stream, \\\n    bulk_add_subscriptions, do_send_messages, get_subscriber_emails, do_rename_stream, \\\n    do_deactivate_stream, do_make_stream_public, do_add_default_stream, \\\n    do_change_stream_description, do_get_streams, do_make_stream_private, \\\n    do_remove_default_stream, get_topic_history_for_stream\nfrom zerver.lib.response import json_success, json_error, json_response\nfrom zerver.lib.validator import check_string, check_list, check_dict, \\\n    check_bool, check_variable_type\nfrom zerver.models import UserProfile, Stream, Realm, Subscription, \\\n    Recipient, get_recipient, get_stream, bulk_get_streams, \\\n    bulk_get_recipients, valid_stream_name, get_active_user_dicts_in_realm\n\nfrom collections import defaultdict\nimport ujson\nfrom six.moves import urllib\n\nimport six\nfrom typing import Text\n\ndef is_active_subscriber(user_profile, recipient):\n    # type: (UserProfile, Recipient) -> bool\n    return Subscription.objects.filter(user_profile=user_profile,\n                                       recipient=recipient,\n                                       active=True).exists()\n\ndef list_to_streams(streams_raw, user_profile, autocreate=False):\n    # type: (Iterable[Mapping[str, Any]], UserProfile, Optional[bool]) -> Tuple[List[Stream], List[Stream]]\n    \"\"\"Converts list of dicts to a list of Streams, validating input in the process\n\n    For each stream name, we validate it to ensure it meets our\n    requirements for a proper stream name: that is, that it is shorter\n    than Stream.MAX_NAME_LENGTH characters and passes\n    valid_stream_name.\n\n    This function in autocreate mode should be atomic: either an exception will be raised\n    during a precheck, or all the streams specified will have been created if applicable.\n\n    @param streams_raw The list of stream dictionaries to process;\n      names should already be stripped of whitespace by the caller.\n    @param user_profile The user for whom we are retreiving the streams\n    @param autocreate Whether we should create streams if they don't already exist\n    \"\"\"\n    # Validate all streams, getting extant ones, then get-or-creating the rest.\n\n    stream_set = set(stream_dict[\"name\"] for stream_dict in streams_raw)\n\n    for stream_name in stream_set:\n        # Stream names should already have been stripped by the\n        # caller, but it makes sense to verify anyway.\n        assert stream_name == stream_name.strip()\n        if len(stream_name) > Stream.MAX_NAME_LENGTH:\n            raise JsonableError(_(\"Stream name (%s) too long.\") % (stream_name,))\n        if not valid_stream_name(stream_name):\n            raise JsonableError(_(\"Invalid stream name (%s).\") % (stream_name,))\n\n    existing_streams = [] # type: List[Stream]\n    missing_stream_dicts = [] # type: List[Mapping[str, Any]]\n    existing_stream_map = bulk_get_streams(user_profile.realm, stream_set)\n\n    for stream_dict in streams_raw:\n        stream_name = stream_dict[\"name\"]\n        stream = existing_stream_map.get(stream_name.lower())\n        if stream is None:\n            missing_stream_dicts.append(stream_dict)\n        else:\n            existing_streams.append(stream)\n\n    if len(missing_stream_dicts) == 0:\n        # This is the happy path for callers who expected all of these\n        # streams to exist already.\n        created_streams = [] # type: List[Stream]\n    else:\n        # autocreate=True path starts here\n        if not user_profile.can_create_streams():\n            raise JsonableError(_('User cannot create streams.'))\n        elif not autocreate:\n            raise JsonableError(_(\"Stream(s) (%s) do not exist\") % \", \".join(\n                stream_dict[\"name\"] for stream_dict in missing_stream_dicts))\n\n        # We already filtered out existing streams, so dup_streams\n        # will normally be an empty list below, but we protect against somebody\n        # else racing to create the same stream.  (This is not an entirely\n        # paranoid approach, since often on Zulip two people will discuss\n        # creating a new stream, and both people eagerly do it.)\n        created_streams, dup_streams = create_streams_if_needed(realm=user_profile.realm,\n                                                                stream_dicts=missing_stream_dicts)\n        existing_streams += dup_streams\n\n    return existing_streams, created_streams\n\nclass PrincipalError(JsonableError):\n    def __init__(self, principal, status_code=403):\n        # type: (Text, int) -> None\n        self.principal = principal # type: Text\n        self.status_code = status_code # type: int\n\n    def to_json_error_msg(self):\n        # type: () -> Text\n        return (\"User not authorized to execute queries on behalf of '%s'\"\n                % (self.principal,))\n\ndef principal_to_user_profile(agent, principal):\n    # type: (UserProfile, Text) -> UserProfile\n    principal_doesnt_exist = False\n    try:\n        principal_user_profile = get_user_profile_by_email(principal)\n    except UserProfile.DoesNotExist:\n        principal_doesnt_exist = True\n\n    if (principal_doesnt_exist or\n            agent.realm != principal_user_profile.realm):\n        # We have to make sure we don't leak information about which users\n        # are registered for Zulip in a different realm.  We could do\n        # something a little more clever and check the domain part of the\n        # principal to maybe give a better error message\n        raise PrincipalError(principal)\n\n    return principal_user_profile\n\n@require_realm_admin\ndef deactivate_stream_backend(request, user_profile, stream_id):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    target = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n\n    if target.invite_only and not subscribed_to_stream(user_profile, target):\n        return json_error(_('Cannot administer invite-only streams this way'))\n\n    do_deactivate_stream(target)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef add_default_stream(request, user_profile, stream_name=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    do_add_default_stream(user_profile.realm, stream_name)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef remove_default_stream(request, user_profile, stream_name=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    do_remove_default_stream(user_profile.realm, stream_name)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef update_stream_backend(request, user_profile, stream_id,\n                          description=REQ(validator=check_string, default=None),\n                          is_private=REQ(validator=check_bool, default=None),\n                          new_name=REQ(validator=check_string, default=None)):\n    # type: (HttpRequest, UserProfile, int, Optional[Text], Optional[bool], Optional[Text]) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    stream_name = stream.name\n\n    if description is not None:\n        do_change_stream_description(user_profile.realm, stream_name, description)\n    if stream_name is not None and new_name is not None:\n        do_rename_stream(user_profile.realm, stream_name, new_name)\n    if is_private is not None:\n        if is_private:\n            do_make_stream_private(user_profile.realm, stream_name)\n        else:\n            do_make_stream_public(user_profile, user_profile.realm, stream_name)\n    return json_success()\n\ndef list_subscriptions_backend(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n    return json_success({\"subscriptions\": gather_subscriptions(user_profile)[0]})\n\nFuncKwargPair = Tuple[Callable[..., HttpResponse], Dict[str, Iterable[Any]]]\n\n@has_request_variables\ndef update_subscriptions_backend(request, user_profile,\n                                 delete=REQ(validator=check_list(check_string), default=[]),\n                                 add=REQ(validator=check_list(check_dict([('name', check_string)])), default=[])):\n    # type: (HttpRequest, UserProfile, Iterable[Text], Iterable[Mapping[str, Any]]) -> HttpResponse\n    if not add and not delete:\n        return json_error(_('Nothing to do. Specify at least one of \"add\" or \"delete\".'))\n\n    method_kwarg_pairs = [\n        (add_subscriptions_backend, dict(streams_raw=add)),\n        (remove_subscriptions_backend, dict(streams_raw=delete))\n    ] # type: List[FuncKwargPair]\n    return compose_views(request, user_profile, method_kwarg_pairs)\n\ndef compose_views(request, user_profile, method_kwarg_pairs):\n    # type: (HttpRequest, UserProfile, List[FuncKwargPair]) -> HttpResponse\n    '''\n    This takes a series of view methods from method_kwarg_pairs and calls\n    them in sequence, and it smushes all the json results into a single\n    response when everything goes right.  (This helps clients avoid extra\n    latency hops.)  It rolls back the transaction when things go wrong in\n    any one of the composed methods.\n\n    TODO: Move this a utils-like module if we end up using it more widely.\n    '''\n\n    json_dict = {} # type: Dict[str, Any]\n    with transaction.atomic():\n        for method, kwargs in method_kwarg_pairs:\n            response = method(request, user_profile, **kwargs)\n            if response.status_code != 200:\n                raise JsonableError(response.content)\n            json_dict.update(ujson.loads(response.content))\n    return json_success(json_dict)\n\n@authenticated_json_post_view\ndef json_remove_subscriptions(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n    return remove_subscriptions_backend(request, user_profile)\n\n@has_request_variables\ndef remove_subscriptions_backend(request, user_profile,\n                                 streams_raw = REQ(\"subscriptions\", validator=check_list(check_string)),\n                                 principals = REQ(validator=check_list(check_string), default=None)):\n    # type: (HttpRequest, UserProfile, Iterable[Text], Optional[Iterable[Text]]) -> HttpResponse\n\n    removing_someone_else = principals and \\\n        set(principals) != set((user_profile.email,))\n    if removing_someone_else and not user_profile.is_realm_admin:\n        # You can only unsubscribe other people from a stream if you are a realm\n        # admin.\n        return json_error(_(\"This action requires administrative rights\"))\n\n    streams_as_dict = []\n    for stream_name in streams_raw:\n        streams_as_dict.append({\"name\": stream_name.strip()})\n\n    streams, __ = list_to_streams(streams_as_dict, user_profile)\n\n    for stream in streams:\n        if removing_someone_else and stream.invite_only and \\\n                not subscribed_to_stream(user_profile, stream):\n            # Even as an admin, you can't remove other people from an\n            # invite-only stream you're not on.\n            return json_error(_(\"Cannot administer invite-only streams this way\"))\n\n    if principals:\n        people_to_unsub = set(principal_to_user_profile(\n            user_profile, principal) for principal in principals)\n    else:\n        people_to_unsub = set([user_profile])\n\n    result = dict(removed=[], not_subscribed=[]) # type: Dict[str, List[Text]]\n    (removed, not_subscribed) = bulk_remove_subscriptions(people_to_unsub, streams)\n\n    for (subscriber, stream) in removed:\n        result[\"removed\"].append(stream.name)\n    for (subscriber, stream) in not_subscribed:\n        result[\"not_subscribed\"].append(stream.name)\n\n    return json_success(result)\n\ndef filter_stream_authorization(user_profile, streams):\n    # type: (UserProfile, Iterable[Stream]) -> Tuple[List[Stream], List[Stream]]\n    streams_subscribed = set() # type: Set[int]\n    recipients_map = bulk_get_recipients(Recipient.STREAM, [stream.id for stream in streams])\n    subs = Subscription.objects.filter(user_profile=user_profile,\n                                       recipient__in=list(recipients_map.values()),\n                                       active=True)\n\n    for sub in subs:\n        streams_subscribed.add(sub.recipient.type_id)\n\n    unauthorized_streams = [] # type: List[Stream]\n    for stream in streams:\n        # The user is authorized for his own streams\n        if stream.id in streams_subscribed:\n            continue\n\n        # The user is not authorized for invite_only streams\n        if stream.invite_only:\n            unauthorized_streams.append(stream)\n\n    authorized_streams = [stream for stream in streams if\n                          stream.id not in set(stream.id for stream in unauthorized_streams)]\n    return authorized_streams, unauthorized_streams\n\n@has_request_variables\ndef add_subscriptions_backend(request, user_profile,\n                              streams_raw = REQ(\"subscriptions\",\n                                                validator=check_list(check_dict([('name', check_string)]))),\n                              invite_only = REQ(validator=check_bool, default=False),\n                              announce = REQ(validator=check_bool, default=False),\n                              principals = REQ(validator=check_list(check_string), default=None),\n                              authorization_errors_fatal = REQ(validator=check_bool, default=True)):\n    # type: (HttpRequest, UserProfile, Iterable[Mapping[str, Text]], bool, bool, Optional[List[Text]], bool) -> HttpResponse\n    stream_dicts = []\n    for stream_dict in streams_raw:\n        stream_dict_copy = {} # type: Dict[str, Any]\n        for field in stream_dict:\n            stream_dict_copy[field] = stream_dict[field]\n        # Strip the stream name here.\n        stream_dict_copy['name'] = stream_dict_copy['name'].strip()\n        stream_dict_copy[\"invite_only\"] = invite_only\n        stream_dicts.append(stream_dict_copy)\n\n    # Validation of the streams arguments, including enforcement of\n    # can_create_streams policy and valid_stream_name policy is inside\n    # list_to_streams.\n    existing_streams, created_streams = \\\n        list_to_streams(stream_dicts, user_profile, autocreate=True)\n    authorized_streams, unauthorized_streams = \\\n        filter_stream_authorization(user_profile, existing_streams)\n    if len(unauthorized_streams) > 0 and authorization_errors_fatal:\n        return json_error(_(\"Unable to access stream (%s).\") % unauthorized_streams[0].name)\n    # Newly created streams are also authorized for the creator\n    streams = authorized_streams + created_streams\n\n    if principals is not None:\n        if user_profile.realm.is_zephyr_mirror_realm and not all(stream.invite_only for stream in streams):\n            return json_error(_(\"You can only invite other Zephyr mirroring users to invite-only streams.\"))\n        subscribers = set(principal_to_user_profile(user_profile, principal) for principal in principals)\n    else:\n        subscribers = set([user_profile])\n\n    (subscribed, already_subscribed) = bulk_add_subscriptions(streams, subscribers)\n\n    result = dict(subscribed=defaultdict(list), already_subscribed=defaultdict(list)) # type: Dict[str, Any]\n    for (subscriber, stream) in subscribed:\n        result[\"subscribed\"][subscriber.email].append(stream.name)\n    for (subscriber, stream) in already_subscribed:\n        result[\"already_subscribed\"][subscriber.email].append(stream.name)\n\n    private_streams = dict((stream.name, stream.invite_only) for stream in streams)\n    bots = dict((subscriber.email, subscriber.is_bot) for subscriber in subscribers)\n\n    # Inform the user if someone else subscribed them to stuff,\n    # or if a new stream was created with the \"announce\" option.\n    notifications = []\n    if principals and result[\"subscribed\"]:\n        for email, subscriptions in six.iteritems(result[\"subscribed\"]):\n            if email == user_profile.email:\n                # Don't send a Zulip if you invited yourself.\n                continue\n            if bots[email]:\n                # Don't send invitation Zulips to bots\n                continue\n\n            if len(subscriptions) == 1:\n                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                       \"subscribed you to the%s stream #**%s**.\"\n                       % (user_profile.full_name,\n                          \" **invite-only**\" if private_streams[subscriptions[0]] else \"\",\n                          subscriptions[0],\n                          ))\n            else:\n                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                       \"subscribed you to the following streams: \\n\\n\"\n                       % (user_profile.full_name,))\n                for stream in subscriptions:\n                    msg += \"* #**%s**%s\\n\" % (\n                        stream,\n                        \" (**invite-only**)\" if private_streams[stream] else \"\")\n\n            if len([s for s in subscriptions if not private_streams[s]]) > 0:\n                msg += \"\\nYou can see historical content on a non-invite-only stream by narrowing to it.\"\n            notifications.append(internal_prep_message(\n                user_profile.realm, settings.NOTIFICATION_BOT,\n                \"private\", email, \"\", msg))\n\n    if announce and len(created_streams) > 0:\n        notifications_stream = user_profile.realm.notifications_stream\n        if notifications_stream is not None:\n            if len(created_streams) > 1:\n                stream_msg = \"the following streams: %s\" % (\", \".join('#**%s**' % s.name for s in created_streams))\n            else:\n                stream_msg = \"a new stream #**%s**.\" % created_streams[0].name\n            msg = (\"%s just created %s\" % (user_profile.full_name, stream_msg))\n            notifications.append(\n                internal_prep_message(user_profile.realm, settings.NOTIFICATION_BOT,\n                                      \"stream\",\n                                      notifications_stream.name, \"Streams\", msg))\n        else:\n            msg = (\"Hi there!  %s just created a new stream #**%s**.\"\n                   % (user_profile.full_name, created_streams[0].name))\n            for realm_user_dict in get_active_user_dicts_in_realm(user_profile.realm):\n                # Don't announce to yourself or to people you explicitly added\n                # (who will get the notification above instead).\n                if realm_user_dict['email'] in principals or realm_user_dict['email'] == user_profile.email:\n                    continue\n                notifications.append(internal_prep_message(\n                    user_profile.realm, settings.NOTIFICATION_BOT,\n                    \"private\",\n                    realm_user_dict['email'], \"\", msg))\n\n    if len(notifications) > 0:\n        do_send_messages(notifications)\n\n    result[\"subscribed\"] = dict(result[\"subscribed\"])\n    result[\"already_subscribed\"] = dict(result[\"already_subscribed\"])\n    if not authorization_errors_fatal:\n        result[\"unauthorized\"] = [stream.name for stream in unauthorized_streams]\n    return json_success(result)\n\n@has_request_variables\ndef get_subscribers_backend(request, user_profile,\n                            stream_id=REQ('stream', converter=to_non_negative_int)):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    subscribers = get_subscriber_emails(stream, user_profile)\n\n    return json_success({'subscribers': subscribers})\n\n# By default, lists all streams that the user has access to --\n# i.e. public streams plus invite-only streams that the user is on\n@has_request_variables\ndef get_streams_backend(request, user_profile,\n                        include_public=REQ(validator=check_bool, default=True),\n                        include_subscribed=REQ(validator=check_bool, default=True),\n                        include_all_active=REQ(validator=check_bool, default=False),\n                        include_default=REQ(validator=check_bool, default=False)):\n    # type: (HttpRequest, UserProfile, bool, bool, bool, bool) -> HttpResponse\n\n    streams = do_get_streams(user_profile, include_public=include_public,\n                             include_subscribed=include_subscribed,\n                             include_all_active=include_all_active,\n                             include_default=include_default)\n    return json_success({\"streams\": streams})\n\n@has_request_variables\ndef get_topics_backend(request, user_profile,\n                       stream_id=REQ(converter=to_non_negative_int)):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n\n    if stream.realm_id != user_profile.realm_id:\n        return json_error(_(\"Invalid stream id\"))\n\n    recipient = get_recipient(Recipient.STREAM, stream.id)\n\n    if not stream.is_public():\n        if not is_active_subscriber(user_profile=user_profile,\n                                    recipient=recipient):\n            return json_error(_(\"Invalid stream id\"))\n\n    result = get_topic_history_for_stream(\n        user_profile=user_profile,\n        recipient=recipient,\n    )\n\n    # Our data structure here is a list of tuples of\n    # (topic name, unread count), and it's reverse chronological,\n    # so the most recent topic is the first element of the list.\n    return json_success(dict(topics=result))\n\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_stream_exists(request, user_profile, stream=REQ(),\n                       autosubscribe=REQ(default=False)):\n    # type: (HttpRequest, UserProfile, Text, bool) -> HttpResponse\n    if not valid_stream_name(stream):\n        return json_error(_(\"Invalid characters in stream name\"))\n    try:\n        stream_id = Stream.objects.get(realm=user_profile.realm, name=stream).id\n    except Stream.DoesNotExist:\n        stream_id = None\n    return stream_exists_backend(request, user_profile, stream_id, autosubscribe)\n\ndef stream_exists_backend(request, user_profile, stream_id, autosubscribe):\n    # type: (HttpRequest, UserProfile, int, bool) -> HttpResponse\n    try:\n        stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    except JsonableError:\n        stream = None\n    result = {\"exists\": bool(stream)}\n    if stream is not None:\n        recipient = get_recipient(Recipient.STREAM, stream.id)\n        if autosubscribe:\n            bulk_add_subscriptions([stream], [user_profile])\n        result[\"subscribed\"] = is_active_subscriber(\n            user_profile=user_profile,\n            recipient=recipient)\n\n        return json_success(result) # results are ignored for HEAD requests\n    return json_response(data=result, status=404)\n\ndef get_and_validate_stream_by_id(stream_id, realm):\n    # type: (int, Realm) -> Stream\n    try:\n        stream = Stream.objects.get(pk=stream_id, realm_id=realm.id)\n    except Stream.DoesNotExist:\n        raise JsonableError(_(\"Invalid stream id\"))\n    return stream\n\n@has_request_variables\ndef json_get_stream_id(request, user_profile, stream=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    try:\n        stream_id = Stream.objects.get(realm=user_profile.realm, name=stream).id\n    except Stream.DoesNotExist:\n        return json_error(_(\"No such stream name\"))\n    return json_success({'stream_id': stream_id})\n\ndef get_subscription_or_die(stream_name, user_profile):\n    # type: (Text, UserProfile) -> Subscription\n    stream = get_stream(stream_name, user_profile.realm)\n    if not stream:\n        raise JsonableError(_(\"Invalid stream %s\") % (stream_name,))\n    recipient = get_recipient(Recipient.STREAM, stream.id)\n    subscription = Subscription.objects.filter(user_profile=user_profile,\n                                               recipient=recipient, active=True)\n\n    if not subscription.exists():\n        raise JsonableError(_(\"Not subscribed to stream %s\") % (stream_name,))\n\n    return subscription\n\n@authenticated_json_view\n@has_request_variables\ndef json_subscription_property(request, user_profile, subscription_data=REQ(\n        validator=check_list(\n            check_dict([(\"stream\", check_string),\n                        (\"property\", check_string),\n                        (\"value\", check_variable_type(\n                            [check_string, check_bool]))])))):\n    # type: (HttpRequest, UserProfile, List[Dict[str, Any]]) -> HttpResponse\n    \"\"\"\n    This is the entry point to changing subscription properties. This\n    is a bulk endpoint: requestors always provide a subscription_data\n    list containing dictionaries for each stream of interest.\n\n    Requests are of the form:\n\n    [{\"stream\": \"devel\", \"property\": \"in_home_view\", \"value\": False},\n     {\"stream\": \"devel\", \"property\": \"color\", \"value\": \"#c2c2c2\"}]\n    \"\"\"\n    if request.method != \"POST\":\n        return json_error(_(\"Invalid verb\"))\n\n    property_converters = {\"color\": check_string, \"in_home_view\": check_bool,\n                           \"desktop_notifications\": check_bool,\n                           \"audible_notifications\": check_bool,\n                           \"pin_to_top\": check_bool}\n    response_data = []\n\n    for change in subscription_data:\n        stream_name = change[\"stream\"]\n        property = change[\"property\"]\n        value = change[\"value\"]\n\n        if property not in property_converters:\n            return json_error(_(\"Unknown subscription property: %s\") % (property,))\n\n        sub = get_subscription_or_die(stream_name, user_profile)[0]\n\n        property_conversion = property_converters[property](property, value)\n        if property_conversion:\n            return json_error(property_conversion)\n\n        do_change_subscription_property(user_profile, sub, stream_name,\n                                        property, value)\n\n        response_data.append({'stream': stream_name,\n                              'property': property,\n                              'value': value})\n\n    return json_success({\"subscription_data\": response_data})\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\n\nfrom typing import Any, Dict, List, Mapping, Optional, Sequence, Text\n\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib import cache\n\nfrom zerver.lib.test_helpers import (\n    queries_captured, tornado_redirected_to_list\n)\n\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\n\nfrom zerver.decorator import (\n    JsonableError\n)\n\nfrom zerver.lib.response import (\n    json_error,\n    json_success,\n)\n\nfrom zerver.lib.test_runner import (\n    slow\n)\n\nfrom zerver.models import (\n    get_display_recipient, Message, Realm, Recipient, Stream, Subscription,\n    UserProfile, get_user_profile_by_id\n)\n\nfrom zerver.lib.actions import (\n    do_add_default_stream, do_change_is_admin, do_set_realm_waiting_period_threshold,\n    do_create_realm, do_remove_default_stream, do_set_realm_create_stream_by_admins_only,\n    gather_subscriptions_helper, bulk_add_subscriptions, bulk_remove_subscriptions,\n    gather_subscriptions, get_default_streams_for_realm, get_realm, get_stream,\n    get_user_profile_by_email, set_default_streams, get_subscription,\n    create_stream_if_needed, create_streams_if_needed, active_user_ids\n)\n\nfrom zerver.views.streams import (\n    compose_views\n)\n\nfrom django.http import HttpResponse\nimport mock\nimport random\nimport ujson\nimport six\nfrom six.moves import range, urllib, zip\n\nclass TestCreateStreams(ZulipTestCase):\n    def test_creating_streams(self):\n        # type: () -> None\n        stream_names = [u'new1', u'new2', u'new3']\n        stream_descriptions = [u'des1', u'des2', u'des3']\n        realm = get_realm('zulip')\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [{\"name\": stream_name,\n              \"description\": stream_description,\n              \"invite_only\": True}\n             for (stream_name, stream_description) in zip(stream_names, stream_descriptions)])\n\n        self.assertEqual(len(new_streams), 3)\n        self.assertEqual(len(existing_streams), 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.invite_only)\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [{\"name\": stream_name,\n              \"description\": stream_description,\n              \"invite_only\": True}\n             for (stream_name, stream_description) in zip(stream_names, stream_descriptions)])\n\n        self.assertEqual(len(new_streams), 0)\n        self.assertEqual(len(existing_streams), 3)\n\n        actual_stream_names = {stream.name for stream in existing_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in existing_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in existing_streams:\n            self.assertTrue(stream.invite_only)\n\nclass RecipientTest(ZulipTestCase):\n    def test_recipient(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        stream = get_stream('Verona', realm)\n        recipient = Recipient.objects.get(\n            type_id=stream.id,\n            type=Recipient.STREAM,\n        )\n        self.assertEqual(str(recipient), '<Recipient: Verona (%d, %d)>' % (\n            stream.id, Recipient.STREAM))\n\nclass StreamAdminTest(ZulipTestCase):\n    def test_make_stream_public(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        self.make_stream('private_stream', invite_only=True)\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('private_stream'),\n            'is_private': ujson.dumps(False)\n        }\n        stream_id = get_stream('private_stream', user_profile.realm).id\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_error(result, 'You are not invited to this stream.')\n\n        self.subscribe_to_stream(email, 'private_stream')\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('private_stream'),\n            'is_private': ujson.dumps(False)\n        }\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_success(result)\n\n        realm = user_profile.realm\n        stream = get_stream('private_stream', realm)\n        self.assertFalse(stream.invite_only)\n\n    def test_make_stream_private(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.make_stream('public_stream', realm=realm)\n\n        do_change_is_admin(user_profile, True)\n        params = {\n            'stream_name': ujson.dumps('public_stream'),\n            'is_private': ujson.dumps(True)\n        }\n        stream_id = get_stream('public_stream', realm).id\n        result = self.client_patch(\"/json/streams/%d\" % (stream_id,), params)\n        self.assert_json_success(result)\n        stream = get_stream('public_stream', realm)\n        self.assertTrue(stream.invite_only)\n\n    def test_deactivate_stream_backend(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        stream = self.make_stream('new_stream')\n        self.subscribe_to_stream(user_profile.email, stream.name)\n        do_change_is_admin(user_profile, True)\n\n        result = self.client_delete('/json/streams/%d' % (stream.id,))\n        self.assert_json_success(result)\n        subscription_exists = Subscription.objects.filter(\n            user_profile=user_profile,\n            recipient__type_id=stream.id,\n            recipient__type=Recipient.STREAM,\n            active=True,\n        ).exists()\n        self.assertFalse(subscription_exists)\n\n    def test_deactivate_stream_backend_requires_existing_stream(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        self.make_stream('new_stream')\n        do_change_is_admin(user_profile, True)\n\n        result = self.client_delete('/json/streams/999999999')\n        self.assert_json_error(result, u'Invalid stream id')\n\n    def test_deactivate_stream_backend_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        self.subscribe_to_stream(email, 'new_stream')\n\n        stream_id = get_stream('new_stream', user_profile.realm).id\n        result = self.client_delete('/json/streams/%d' % (stream_id,))\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def test_private_stream_live_updates(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        user_profile = get_user_profile_by_email(email)\n        do_change_is_admin(user_profile, True)\n\n        self.make_stream('private_stream', invite_only=True)\n        self.subscribe_to_stream(email, 'private_stream')\n        self.subscribe_to_stream('cordelia@zulip.com', 'private_stream')\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('private_stream', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'description': ujson.dumps('Test description')})\n        self.assert_json_success(result)\n        # Should be just a description change event\n        self.assert_length(events, 1)\n\n        cordelia = get_user_profile_by_email('cordelia@zulip.com')\n        prospero = get_user_profile_by_email('prospero@zulip.com')\n\n        notified_user_ids = set(events[-1]['users'])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        events = []\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('private_stream', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps('whatever')})\n        self.assert_json_success(result)\n        # Should be a name event and an email address event\n        self.assert_length(events, 2)\n\n        notified_user_ids = set(events[-1]['users'])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n    def test_rename_stream(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, True)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('stream_name1', user_profile.realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps('stream_name2')})\n        self.assert_json_success(result)\n\n        event = events[1]['event']\n        self.assertEqual(event, dict(\n            op='update',\n            type='stream',\n            property='name',\n            value='stream_name2',\n            name='stream_name1'\n        ))\n        notified_user_ids = set(events[1]['users'])\n\n        stream_name1_exists = get_stream('stream_name1', realm)\n        self.assertFalse(stream_name1_exists)\n        stream_name2_exists = get_stream('stream_name2', realm)\n        self.assertTrue(stream_name2_exists)\n\n        self.assertEqual(notified_user_ids, set(active_user_ids(realm)))\n        self.assertIn(user_profile.id,\n                      notified_user_ids)\n        self.assertIn(get_user_profile_by_email('prospero@zulip.com').id,\n                      notified_user_ids)\n\n        # Test case to handle unicode stream name change\n        # *NOTE: Here Encoding is needed when Unicode string is passed as an argument*\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name2_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'\u0928\u092f\u093e \u0928\u093e\u092e'.encode('utf-8'))})\n        self.assert_json_success(result)\n        # While querying, system can handle unicode strings.\n        stream_name_uni_exists = get_stream(u'\u0928\u092f\u093e \u0928\u093e\u092e', realm)\n        self.assertTrue(stream_name_uni_exists)\n\n        # Test case to handle changing of unicode stream name to newer name\n        # NOTE: Unicode string being part of URL is handled cleanly\n        # by client_patch call, encoding of URL is not needed.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_uni_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947'.encode('utf-8'))})\n        self.assert_json_success(result)\n        # While querying, system can handle unicode strings.\n        stream_name_old_uni_exists = get_stream(u'\u0928\u092f\u093e \u0928\u093e\u092e', realm)\n        self.assertFalse(stream_name_old_uni_exists)\n        stream_name_new_uni_exists = get_stream(u'\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947', realm)\n        self.assertTrue(stream_name_new_uni_exists)\n\n        # Test case to change name from one language to other.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_new_uni_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'fran\u00e7ais'.encode('utf-8'))})\n        self.assert_json_success(result)\n        stream_name_fr_exists = get_stream(u'fran\u00e7ais', realm)\n        self.assertTrue(stream_name_fr_exists)\n\n        # Test case to change name to mixed language name.\n        with tornado_redirected_to_list(events):\n            stream_id = stream_name_fr_exists.id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'new_name': ujson.dumps(u'fran\u00e7ais name'.encode('utf-8'))})\n        self.assert_json_success(result)\n        stream_name_mixed_exists = get_stream(u'fran\u00e7ais name', realm)\n        self.assertTrue(stream_name_mixed_exists)\n\n    def test_rename_stream_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        self.make_stream('stream_name1')\n\n        stream_id = get_stream('stream_name1', user_profile.realm).id\n        result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                   {'new_name': ujson.dumps('stream_name2')})\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def test_change_stream_description(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        realm = user_profile.realm\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, True)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            stream_id = get_stream('stream_name1', realm).id\n            result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                       {'description': ujson.dumps('Test description')})\n        self.assert_json_success(result)\n\n        event = events[0]['event']\n        self.assertEqual(event, dict(\n            op='update',\n            type='stream',\n            property='description',\n            value='Test description',\n            name='stream_name1'\n        ))\n        notified_user_ids = set(events[0]['users'])\n\n        stream = get_stream('stream_name1', realm)\n        self.assertEqual(notified_user_ids, set(active_user_ids(realm)))\n        self.assertIn(user_profile.id,\n                      notified_user_ids)\n        self.assertIn(get_user_profile_by_email('prospero@zulip.com').id,\n                      notified_user_ids)\n\n        self.assertEqual('Test description', stream.description)\n\n    def test_change_stream_description_requires_realm_admin(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n\n        self.subscribe_to_stream(email, 'stream_name1')\n        do_change_is_admin(user_profile, False)\n\n        stream_id = get_stream('stream_name1', user_profile.realm).id\n        result = self.client_patch('/json/streams/%d' % (stream_id,),\n                                   {'description': ujson.dumps('Test description')})\n        self.assert_json_error(result, 'Must be a realm administrator')\n\n    def set_up_stream_for_deletion(self, stream_name, invite_only=False,\n                                   subscribed=True):\n        # type: (str, bool, bool) -> Stream\n        \"\"\"\n        Create a stream for deletion by an administrator.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        stream = self.make_stream(stream_name, invite_only=invite_only)\n\n        # For testing deleting streams you aren't on.\n        if subscribed:\n            self.subscribe_to_stream(email, stream_name)\n\n        do_change_is_admin(user_profile, True)\n\n        return stream\n\n    def delete_stream(self, stream, subscribed=True):\n        # type: (Stream, bool) -> None\n        \"\"\"\n        Delete the stream and assess the result.\n        \"\"\"\n        active_name = stream.name\n        realm = stream.realm\n        stream_id = stream.id\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            result = self.client_delete('/json/streams/' + str(stream_id))\n        self.assert_json_success(result)\n\n        deletion_events = [e['event'] for e in events if e['event']['type'] == 'subscription']\n        if subscribed:\n            self.assertEqual(deletion_events[0], dict(\n                op='remove',\n                type='subscription',\n                subscriptions=[{'name': active_name, 'stream_id': stream.id}]\n            ))\n        else:\n            # You could delete the stream, but you weren't on it so you don't\n            # receive an unsubscription event.\n            self.assertEqual(deletion_events, [])\n\n        with self.assertRaises(Stream.DoesNotExist):\n            Stream.objects.get(realm=get_realm(\"zulip\"), name=active_name)\n\n        # A deleted stream's name is changed, is deactivated, is invite-only,\n        # and has no subscribers.\n        deactivated_stream_name = \"!DEACTIVATED:\" + active_name\n        deactivated_stream = get_stream(deactivated_stream_name, realm)\n        self.assertTrue(deactivated_stream.deactivated)\n        self.assertTrue(deactivated_stream.invite_only)\n        self.assertEqual(deactivated_stream.name, deactivated_stream_name)\n        subscribers = self.users_subscribed_to_stream(\n            deactivated_stream_name, realm)\n        self.assertEqual(subscribers, [])\n\n        # It doesn't show up in the list of public streams anymore.\n        result = self.client_get(\"/json/streams?include_subscribed=false\")\n        public_streams = [s[\"name\"] for s in ujson.loads(result.content)[\"streams\"]]\n        self.assertNotIn(active_name, public_streams)\n        self.assertNotIn(deactivated_stream_name, public_streams)\n\n        # Even if you could guess the new name, you can't subscribe to it.\n        result = self.client_post(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": ujson.dumps([{\"name\": deactivated_stream_name}])})\n        self.assert_json_error(\n            result, \"Unable to access stream (%s).\" % (deactivated_stream_name,))\n\n    def test_delete_public_stream(self):\n        # type: () -> None\n        \"\"\"\n        When an administrator deletes a public stream, that stream is not\n        visible to users at all anymore.\n        \"\"\"\n        stream = self.set_up_stream_for_deletion(\"newstream\")\n        self.delete_stream(stream)\n\n    def test_delete_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        Administrators can delete private streams they are on.\n        \"\"\"\n        stream = self.set_up_stream_for_deletion(\"newstream\", invite_only=True)\n        self.delete_stream(stream)\n\n    def test_delete_streams_youre_not_on(self):\n        # type: () -> None\n        \"\"\"\n        Administrators can delete public streams they aren't on, but cannot\n        delete private streams they aren't on.\n        \"\"\"\n        pub_stream = self.set_up_stream_for_deletion(\n            \"pubstream\", subscribed=False)\n        self.delete_stream(pub_stream, subscribed=False)\n\n        priv_stream = self.set_up_stream_for_deletion(\n            \"privstream\", subscribed=False, invite_only=True)\n\n        result = self.client_delete('/json/streams/' + str(priv_stream.id))\n        self.assert_json_error(\n            result, \"Cannot administer invite-only streams this way\")\n\n    def attempt_unsubscribe_of_principal(self, is_admin=False, is_subbed=True,\n                                         invite_only=False, other_user_subbed=True):\n        # type: (bool, bool, bool, bool) -> HttpResponse\n\n        # Set up the main user, who is in most cases an admin.\n        email = \"hamlet@zulip.com\"\n        self.login(email)\n        user_profile = get_user_profile_by_email(email)\n        if is_admin:\n            do_change_is_admin(user_profile, True)\n\n        # Set up the stream.\n        stream_name = u\"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name, invite_only=invite_only)\n\n        # Set up the principal to be unsubscribed.\n        other_email = \"cordelia@zulip.com\"\n        other_user_profile = get_user_profile_by_email(other_email)\n\n        # Subscribe the admin and/or principal as specified in the flags.\n        if is_subbed:\n            self.subscribe_to_stream(user_profile.email, stream_name)\n        if other_user_subbed:\n            self.subscribe_to_stream(other_user_profile.email, stream_name)\n\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": ujson.dumps([stream_name]),\n             \"principals\": ujson.dumps([other_email])})\n\n        # If the removal succeeded, then assert that Cordelia is no longer subscribed.\n        if result.status_code not in [400]:\n            subbed_users = self.users_subscribed_to_stream(stream_name, other_user_profile.realm)\n            self.assertNotIn(other_user_profile, subbed_users)\n\n        return result\n\n    def test_cant_remove_others_from_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're not an admin, you can't remove other people from streams.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=False, is_subbed=True, invite_only=False,\n            other_user_subbed=True)\n        self.assert_json_error(\n            result, \"This action requires administrative rights\")\n\n    def test_admin_remove_others_from_public_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're an admin, you can remove people from public streams, even\n        those you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=True, invite_only=False,\n            other_user_subbed=True)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 1)\n        self.assertEqual(len(json[\"not_subscribed\"]), 0)\n\n    def test_admin_remove_others_from_subbed_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        If you're an admin, you can remove other people from private streams you\n        are on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=True, invite_only=True,\n            other_user_subbed=True)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 1)\n        self.assertEqual(len(json[\"not_subscribed\"]), 0)\n\n    def test_admin_remove_others_from_unsubbed_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        Even if you're an admin, you can't remove people from private\n        streams you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=False, invite_only=True,\n            other_user_subbed=True)\n        self.assert_json_error(\n            result, \"Cannot administer invite-only streams this way\")\n\n    def test_create_stream_by_admins_only_setting(self):\n        # type: () -> None\n        \"\"\"\n        When realm.create_stream_by_admins_only setting is active and\n        the number of days since the user had joined is less than waiting period\n        threshold, non admin users shouldn't be able to create new streams.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        do_set_realm_create_stream_by_admins_only(user_profile.realm, True)\n\n        stream_name = ['adminsonlysetting']\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_error(result, 'User cannot create streams.')\n\n    def test_create_stream_by_waiting_period_threshold(self):\n        # type: () -> None\n        \"\"\"\n        Non admin users with account age greater or equal to waiting period\n        threshold should be able to create new streams.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        do_change_is_admin(user_profile, False)\n\n        do_set_realm_waiting_period_threshold(user_profile.realm, 10)\n\n        stream_name = ['waitingperiodtest']\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_error(result, 'User cannot create streams.')\n\n        do_set_realm_waiting_period_threshold(user_profile.realm, 0)\n\n        result = self.common_subscribe_to_streams(\n            email,\n            stream_name\n        )\n        self.assert_json_success(result)\n\n    def test_remove_already_not_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Trying to unsubscribe someone who already isn't subscribed to a stream\n        fails gracefully.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            is_admin=True, is_subbed=False, invite_only=False,\n            other_user_subbed=False)\n        json = self.assert_json_success(result)\n        self.assertEqual(len(json[\"removed\"]), 0)\n        self.assertEqual(len(json[\"not_subscribed\"]), 1)\n\n    def test_remove_invalid_user(self):\n        # type: () -> None\n        \"\"\"\n        Trying to unsubscribe an invalid user from a stream fails gracefully.\n        \"\"\"\n        admin_email = \"hamlet@zulip.com\"\n        self.login(admin_email)\n        user_profile = get_user_profile_by_email(admin_email)\n        do_change_is_admin(user_profile, True)\n\n        stream_name = u\"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name)\n\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps([stream_name]),\n                                     \"principals\": ujson.dumps([\"baduser@zulip.com\"])})\n        self.assert_json_error(\n            result,\n            \"User not authorized to execute queries on behalf of 'baduser@zulip.com'\",\n            status_code=403)\n\nclass DefaultStreamTest(ZulipTestCase):\n    def get_default_stream_names(self, realm):\n        # type: (Realm) -> Set[Text]\n        streams = get_default_streams_for_realm(realm)\n        stream_names = [s.name for s in streams]\n        return set(stream_names)\n\n    def get_default_stream_descriptions(self, realm):\n        # type: (Realm) -> Set[Text]\n        streams = get_default_streams_for_realm(realm)\n        stream_descriptions = [s.description for s in streams]\n        return set(stream_descriptions)\n\n    def test_set_default_streams(self):\n        # type: () -> None\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n        stream_dict = {\n            \"apple\": {\"description\": \"A red fruit\", \"invite_only\": False},\n            \"banana\": {\"description\": \"A yellow fruit\", \"invite_only\": False},\n            \"Carrot Cake\": {\"description\": \"A delicious treat\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        expected_names = list(stream_dict.keys())\n        expected_names.append(\"announce\")\n        expected_descriptions = [i[\"description\"] for i in stream_dict.values()] + [\"\"]\n        set_default_streams(realm, stream_dict)\n        stream_names_set = self.get_default_stream_names(realm)\n        stream_descriptions_set = self.get_default_stream_descriptions(realm)\n        self.assertEqual(stream_names_set, set(expected_names))\n        self.assertEqual(stream_descriptions_set, set(expected_descriptions))\n\n    def test_set_default_streams_no_notifications_stream(self):\n        # type: () -> None\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n        realm.notifications_stream = None\n        realm.save(update_fields=[\"notifications_stream\"])\n        stream_dict = {\n            \"apple\": {\"description\": \"A red fruit\", \"invite_only\": False},\n            \"banana\": {\"description\": \"A yellow fruit\", \"invite_only\": False},\n            \"Carrot Cake\": {\"description\": \"A delicious treat\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        expected_names = list(stream_dict.keys())\n        expected_descriptions = [i[\"description\"] for i in stream_dict.values()]\n        set_default_streams(realm, stream_dict)\n        stream_names_set = self.get_default_stream_names(realm)\n        stream_descriptions_set = self.get_default_stream_descriptions(realm)\n        self.assertEqual(stream_names_set, set(expected_names))\n        self.assertEqual(stream_descriptions_set, set(expected_descriptions))\n\n    def test_add_and_remove_default_stream(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        orig_stream_names = self.get_default_stream_names(realm)\n        do_add_default_stream(realm, 'Added Stream')\n        new_stream_names = self.get_default_stream_names(realm)\n        added_stream_names = new_stream_names - orig_stream_names\n        self.assertEqual(added_stream_names, set(['Added Stream']))\n        # idempotentcy--2nd call to add_default_stream should be a noop\n        do_add_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), new_stream_names)\n\n        # start removing\n        do_remove_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n        # idempotentcy--2nd call to remove_default_stream should be a noop\n        do_remove_default_stream(realm, 'Added Stream')\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n\n    def test_api_calls(self):\n        # type: () -> None\n        self.login(\"hamlet@zulip.com\")\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        do_change_is_admin(user_profile, True)\n        stream_name = 'stream ADDED via api'\n        result = self.client_post('/json/default_streams', dict(stream_name=stream_name))\n        self.assert_json_success(result)\n        self.assertTrue(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # and remove it\n        result = self.client_delete('/json/default_streams', dict(stream_name=stream_name))\n        self.assert_json_success(result)\n        self.assertFalse(stream_name in self.get_default_stream_names(user_profile.realm))\n\nclass SubscriptionPropertiesTest(ZulipTestCase):\n    def test_set_stream_color(self):\n        # type: () -> None\n        \"\"\"\n        A POST request to /json/subscriptions/property with stream_name and\n        color data sets the stream color, and for that stream only.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        old_subs, _ = gather_subscriptions(get_user_profile_by_email(test_email))\n        sub = old_subs[0]\n        stream_name = sub['name']\n        new_color = \"#ffffff\" # TODO: ensure that this is different from old_color\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": stream_name,\n                                                \"value\": \"#ffffff\"}])})\n\n        self.assert_json_success(result)\n\n        new_subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        found_sub = None\n        for sub in new_subs:\n            if sub['name'] == stream_name:\n                found_sub = sub\n                break\n\n        self.assertIsNotNone(found_sub)\n        self.assertEqual(found_sub['color'], new_color)\n\n        new_subs.remove(found_sub)\n        for sub in old_subs:\n            if sub['name'] == stream_name:\n                found_sub = sub\n                break\n        old_subs.remove(found_sub)\n        self.assertEqual(old_subs, new_subs)\n\n    def test_set_color_missing_stream_name(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a `stream` key.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"value\": \"#ffffff\"}])})\n\n        self.assert_json_error(\n            result, \"stream key is missing from subscription_data[0]\")\n\n    def test_set_color_unsubscribed_stream_name(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a subscribed stream.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        unsubs_stream = 'Rome'\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": unsubs_stream,\n                                                \"value\": \"#ffffff\"}])})\n        self.assert_json_error(\n            result, \"Not subscribed to stream %s\" % (unsubs_stream,))\n\n    def test_json_subscription_property_invalid_verb(self):\n        # type: () -> None\n        \"\"\"\n        Called by invalid request method. No other request method other than\n        'post' is allowed in this case.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n\n        result = self.client_get(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"in_home_view\",\n                                                \"stream\": subs[0][\"name\"],\n                                                \"value\": False}])})\n        self.assert_json_error(result, \"Invalid verb\")\n\n    def test_set_color_missing_color(self):\n        # type: () -> None\n        \"\"\"\n        Updating the color property requires a color.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"color\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(\n            result, \"value key is missing from subscription_data[0]\")\n\n    def test_set_pin_to_top(self):\n        # type: () -> None\n        \"\"\"\n        A POST request to /json/subscriptions/property with stream_name and\n        pin_to_top data pins the stream.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        user_profile = get_user_profile_by_email(test_email)\n        old_subs, _ = gather_subscriptions(user_profile)\n        sub = old_subs[0]\n        stream_name = sub['name']\n        new_pin_to_top = not sub['pin_to_top']\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"pin_to_top\",\n                                                \"stream\": stream_name,\n                                                \"value\": new_pin_to_top}])})\n\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(stream_name, user_profile)\n\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.pin_to_top, new_pin_to_top)\n\n    def test_set_subscription_property_incorrect(self):\n        # type: () -> None\n        \"\"\"\n        Trying to set a property incorrectly returns a JSON error.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n\n        property_name = \"in_home_view\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"desktop_notifications\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"audible_notifications\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a boolean' % (property_name,))\n\n        property_name = \"color\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": property_name,\n                                                \"value\": False,\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               '%s is not a string' % (property_name,))\n\n    def test_json_subscription_property_invalid_stream(self):\n        # type: () -> None\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n\n        stream_name = \"invalid_stream\"\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"in_home_view\",\n                                                \"stream\": stream_name,\n                                                \"value\": False}])})\n\n        self.assert_json_error(result, \"Invalid stream %s\" % (stream_name,))\n\n    def test_set_invalid_property(self):\n        # type: () -> None\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n        test_email = \"hamlet@zulip.com\"\n        self.login(test_email)\n        subs = gather_subscriptions(get_user_profile_by_email(test_email))[0]\n        result = self.client_post(\n            \"/json/subscriptions/property\",\n            {\"subscription_data\": ujson.dumps([{\"property\": \"bad\",\n                                                \"value\": \"bad\",\n                                                \"stream\": subs[0][\"name\"]}])})\n\n        self.assert_json_error(result,\n                               \"Unknown subscription property: bad\")\n\nclass SubscriptionRestApiTest(ZulipTestCase):\n    def test_basic_add_delete(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        # add\n        request = {\n            'add': ujson.dumps([{'name': 'my_test_stream_1'}])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_success(result)\n        streams = self.get_streams(email)\n        self.assertTrue('my_test_stream_1' in streams)\n\n        # now delete the same stream\n        request = {\n            'delete': ujson.dumps(['my_test_stream_1'])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_success(result)\n        streams = self.get_streams(email)\n        self.assertTrue('my_test_stream_1' not in streams)\n\n    def test_bad_add_parameters(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        def check_for_error(val, expected_message):\n            # type: (Any, str) -> None\n            request = {\n                'add': ujson.dumps(val)\n            }\n            result = self.client_patch(\n                \"/api/v1/users/me/subscriptions\",\n                request,\n                **self.api_auth(email)\n            )\n            self.assert_json_error(result, expected_message)\n\n        check_for_error(['foo'], 'add[0] is not a dict')\n        check_for_error([{'bogus': 'foo'}], 'name key is missing from add[0]')\n        check_for_error([{'name': {}}], 'add[0][\"name\"] is not a string')\n\n    def test_bad_principals(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        request = {\n            'add': ujson.dumps([{'name': 'my_new_stream'}]),\n            'principals': ujson.dumps([{}]),\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result, 'principals[0] is not a string')\n\n    def test_bad_delete_parameters(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        request = {\n            'delete': ujson.dumps([{'name': 'my_test_stream_1'}])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result, \"delete[0] is not a string\")\n\n    def test_add_or_delete_not_specified(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            {},\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               'Nothing to do. Specify at least one of \"add\" or \"delete\".')\n\n    def test_patch_enforces_valid_stream_name_check(self):\n        # type: () -> None\n        \"\"\"\n        Only way to force an error is with a empty string.\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        invalid_stream_name = \"\"\n        request = {\n            'delete': ujson.dumps([invalid_stream_name])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               \"Invalid stream name (%s).\" % (invalid_stream_name,))\n\n    def test_stream_name_too_long(self):\n        # type: () -> None\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        long_stream_name = \"a\" * 61\n        request = {\n            'delete': ujson.dumps([long_stream_name])\n        }\n        result = self.client_patch(\n            \"/api/v1/users/me/subscriptions\",\n            request,\n            **self.api_auth(email)\n        )\n        self.assert_json_error(result,\n                               \"Stream name (%s) too long.\" % (long_stream_name,))\n\n    def test_compose_views_rollback(self):\n        # type: () -> None\n        '''\n        The compose_views function() is used under the hood by\n        update_subscriptions_backend.  It's a pretty simple method in terms of\n        control flow, but it uses a Django rollback, which may make it brittle\n        code when we upgrade Django.  We test the functions's rollback logic\n        here with a simple scenario to avoid false positives related to\n        subscription complications.\n        '''\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        user_profile.full_name = 'Hamlet'\n        user_profile.save()\n\n        def method1(req, user_profile):\n            # type: (HttpRequest, UserProfile) -> HttpResponse\n            user_profile.full_name = 'Should not be committed'\n            user_profile.save()\n            return json_success()\n\n        def method2(req, user_profile):\n            # type: (HttpRequest, UserProfile) -> HttpResponse\n            return json_error(_('random failure'))\n\n        with self.assertRaises(JsonableError):\n            compose_views(None, user_profile, [(method1, {}), (method2, {})])\n\n        user_profile = get_user_profile_by_email('hamlet@zulip.com')\n        self.assertEqual(user_profile.full_name, 'Hamlet')\n\nclass SubscriptionAPITest(ZulipTestCase):\n\n    def setUp(self):\n        # type: () -> None\n        \"\"\"\n        All tests will be logged in as hamlet. Also save various useful values\n        as attributes that tests can access.\n        \"\"\"\n        self.test_email = \"hamlet@zulip.com\"\n        self.login(self.test_email)\n        self.user_profile = get_user_profile_by_email(self.test_email)\n        self.realm = self.user_profile.realm\n        self.streams = self.get_streams(self.test_email)\n\n    def make_random_stream_names(self, existing_stream_names):\n        # type: (List[Text]) -> List[Text]\n        \"\"\"\n        Helper function to make up random stream names. It takes\n        existing_stream_names and randomly appends a digit to the end of each,\n        but avoids names that appear in the list names_to_avoid.\n        \"\"\"\n        random_streams = []\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.realm)]\n        for stream in existing_stream_names:\n            random_stream = stream + str(random.randint(0, 9))\n            if random_stream not in all_stream_names:\n                random_streams.append(random_stream)\n        return random_streams\n\n    def test_successful_subscriptions_list(self):\n        # type: () -> None\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        email = self.test_email\n        result = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json['subscriptions']:\n            self.assertIsInstance(stream['name'], six.string_types)\n            self.assertIsInstance(stream['color'], six.string_types)\n            self.assertIsInstance(stream['invite_only'], bool)\n            # check that the stream name corresponds to an actual stream\n            try:\n                get_stream(stream['name'], self.realm)\n            except Stream.DoesNotExist:\n                self.fail(\"stream does not exist\")\n        list_streams = [stream['name'] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def helper_check_subs_before_and_after_add(self, subscriptions, other_params,\n                                               subscribed, already_subscribed,\n                                               email, new_subs, invite_only=False):\n        # type: (List[Text], Dict[str, Any], List[Text], List[Text], Text, List[Text], bool) -> None\n        \"\"\"\n        Check result of adding subscriptions.\n\n        You can add subscriptions for yourself or possibly many\n        principals, which is why e-mails map to subscriptions in the\n        result.\n\n        The result json is of the form\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"already_subscribed\": {\"iago@zulip.com\": [\"Venice\", \"Verona\"]},\n         \"subscribed\": {\"iago@zulip.com\": [\"Venice8\"]}}\n        \"\"\"\n        result = self.common_subscribe_to_streams(self.test_email, subscriptions,\n                                                  other_params, invite_only=invite_only)\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(sorted(subscribed), sorted(json[\"subscribed\"][email]))\n        self.assertEqual(sorted(already_subscribed), sorted(json[\"already_subscribed\"][email]))\n        new_streams = self.get_streams(email)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_add(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        add_streams = [u\"Verona2\", u\"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)  # necessary for full test coverage\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            self.helper_check_subs_before_and_after_add(self.streams + add_streams, {},\n                                                        add_streams, self.streams, self.test_email, self.streams + add_streams)\n        self.assert_length(events, 6)\n\n    def test_successful_subscriptions_add_with_announce(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)\n        add_streams = [u\"Verona2\", u\"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)\n        events = [] # type: List[Dict[str, Any]]\n        other_params = {\n            'announce': 'true',\n        }\n        notifications_stream = get_stream(self.streams[0], self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(self.test_email))\n        with tornado_redirected_to_list(events):\n            self.helper_check_subs_before_and_after_add(self.streams + add_streams, other_params,\n                                                        add_streams, self.streams, self.test_email, self.streams + add_streams)\n        self.assertEqual(len(events), 7)\n\n    def test_successful_subscriptions_notifies_pm(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                'announce': 'true',\n                'principals': '[\"%s\"]' % (self.user_profile.email,)\n            },\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.PERSONAL)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"Hi there!  %s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_subscriptions_notifies_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n\n        notifications_stream = get_stream(current_stream, self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(invitee))\n\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data=dict(\n                announce='true',\n                principals='[\"%s\"]' % (self.user_profile.email,)\n            ),\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"%s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_cross_realm_notification(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions in a new realm\n        should notify with a proper new stream link\n        \"\"\"\n        (realm, _) = do_create_realm(\"testrealm\", \"Test Realm\")\n\n        notifications_stream = Stream.objects.get(name='announce', realm=realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        invite_streams = [\"cross_stream\"]\n\n        user = get_user_profile_by_email(\"AARON@zulip.com\")\n        user.realm = realm\n        user.save()\n\n        # Delete the UserProfile from the cache so the realm change will be\n        # picked up\n        cache.cache_delete(cache.user_profile_by_email_cache_key(user.email))\n\n        result = self.common_subscribe_to_streams(\n            user.email,\n            invite_streams,\n            extra_post_data=dict(\n                announce='true'\n            ),\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        stream_id = Stream.objects.latest('id').id\n        expected_rendered_msg = '<p>%s just created a new stream <a class=\"stream\" data-stream-id=\"%d\" href=\"/#narrow/stream/%s\">#%s</a>.</p>' % (\n            user.full_name, stream_id, invite_streams[0], invite_streams[0])\n        self.assertEqual(msg.rendered_content, expected_rendered_msg)\n\n    def test_successful_subscriptions_notifies_with_escaping(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        invitee_full_name = 'Iago'\n\n        current_stream = self.get_streams(invitee)[0]\n        notifications_stream = get_stream(current_stream, self.realm)\n        self.realm.notifications_stream = notifications_stream\n        self.realm.save()\n\n        invite_streams = ['strange ) \\\\ test']\n        result = self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                'announce': 'true',\n                'principals': '[\"%s\"]' % (self.user_profile.email,)\n            },\n        )\n        self.assert_json_success(result)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email('notification-bot@zulip.com').id)\n        expected_msg = \"%s just created a new stream #**%s**.\" % (invitee_full_name, invite_streams[0])\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_non_ascii_stream_subscription(self):\n        # type: () -> None\n        \"\"\"\n        Subscribing to a stream name with non-ASCII characters succeeds.\n        \"\"\"\n        self.helper_check_subs_before_and_after_add(self.streams + [u\"h\u00fcmb\u00fc\u01f5\"], {},\n                                                    [u\"h\u00fcmb\u00fc\u01f5\"], self.streams, self.test_email, self.streams + [u\"h\u00fcmb\u00fc\u01f5\"])\n\n    def test_subscriptions_add_too_long(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is >60\n        characters should return a JSON error.\n        \"\"\"\n        # character limit is 60 characters\n        long_stream_name = \"a\" * 61\n        result = self.common_subscribe_to_streams(self.test_email, [long_stream_name])\n        self.assert_json_error(result,\n                               \"Stream name (%s) too long.\" % (long_stream_name,))\n\n    def test_user_settings_for_adding_streams(self):\n        # type: () -> None\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=False):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream1'])\n            self.assert_json_error(result, 'User cannot create streams.')\n\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=True):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream2'])\n            self.assert_json_success(result)\n\n        # User should still be able to subscribe to an existing stream\n        with mock.patch('zerver.models.UserProfile.can_create_streams', return_value=False):\n            result = self.common_subscribe_to_streams(self.test_email, ['stream2'])\n            self.assert_json_success(result)\n\n    def test_subscriptions_add_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid name is the empty string\n        invalid_stream_name = \"\"\n        result = self.common_subscribe_to_streams(self.test_email, [invalid_stream_name])\n        self.assert_json_error(result,\n                               \"Invalid stream name (%s).\" % (invalid_stream_name,))\n\n    def assert_adding_subscriptions_for_principal(self, invitee, streams, invite_only=False):\n        # type: (Text, List[Text], bool) -> None\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on behalf of another principal (for\n        whom you have permission to add subscriptions) should successfully add\n        those subscriptions and send a message to the subscribee notifying\n        them.\n        \"\"\"\n        other_profile = get_user_profile_by_email(invitee)\n        current_streams = self.get_streams(invitee)\n        self.assertIsInstance(other_profile, UserProfile)\n        self.assertNotEqual(len(current_streams), 0)  # necessary for full test coverage\n        self.assertNotEqual(len(streams), 0)  # necessary for full test coverage\n        streams_to_sub = streams[:1]  # just add one, to make the message easier to check\n        streams_to_sub.extend(current_streams)\n        self.helper_check_subs_before_and_after_add(streams_to_sub,\n                                                    {\"principals\": ujson.dumps([invitee])}, streams[:1], current_streams,\n                                                    invitee, streams_to_sub, invite_only=invite_only)\n        # verify that the user was sent a message informing them about the subscription\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, msg.recipient.PERSONAL)\n        self.assertEqual(msg.sender_id,\n                         get_user_profile_by_email(\"notification-bot@zulip.com\").id)\n        expected_msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                        \"subscribed you to the %sstream #**%s**.\"\n                        % (self.user_profile.full_name,\n                           '**invite-only** ' if invite_only else '',\n                           streams[0]))\n\n        if not get_stream(streams[0], other_profile.realm).invite_only:\n            expected_msg += (\"\\nYou can see historical content on a \"\n                             \"non-invite-only stream by narrowing to it.\")\n        self.assertEqual(msg.content, expected_msg)\n        recipients = get_display_recipient(msg.recipient)\n        self.assertEqual(len(recipients), 1)\n        assert isinstance(recipients, Sequence)\n        assert isinstance(recipients[0], Mapping)\n        # The 2 assert statements above are required to make the mypy check pass.\n        # They inform mypy that in the line below, recipients is a Sequence of Mappings.\n        self.assertEqual(recipients[0]['email'], invitee)\n\n    def test_multi_user_subscription(self):\n        # type: () -> None\n        email1 = 'cordelia@zulip.com'\n        email2 = 'iago@zulip.com'\n        realm = get_realm(\"zulip\")\n        streams_to_sub = ['multi_user_stream']\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams_to_sub,\n                    dict(principals=ujson.dumps([email1, email2])),\n                )\n        self.assert_max_length(queries, 43)\n\n        self.assert_length(events, 8)\n        for ev in [x for x in events if x['event']['type'] not in ('message', 'stream')]:\n            if isinstance(ev['event']['subscriptions'][0], dict):\n                self.assertEqual(ev['event']['op'], 'add')\n                self.assertEqual(\n                    set(ev['event']['subscriptions'][0]['subscribers']),\n                    set([email1, email2])\n                )\n            else:\n                # Check \"peer_add\" events for streams users were\n                # never subscribed to, in order for the neversubscribed\n                # structure to stay up-to-date.\n                self.assertEqual(ev['event']['op'], 'peer_add')\n\n        stream = get_stream('multi_user_stream', realm)\n        self.assertEqual(stream.num_subscribers(), 2)\n\n        # Now add ourselves\n        events = []\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams_to_sub,\n                    dict(principals=ujson.dumps([self.test_email])),\n                )\n        self.assert_max_length(queries, 8)\n\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [get_user_profile_by_email(self.test_email).id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([email1, email2, self.test_email])\n        )\n\n        self.assertEqual(len(add_peer_event['users']), 16)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], self.user_profile.id)\n\n        stream = get_stream('multi_user_stream', realm)\n        self.assertEqual(stream.num_subscribers(), 3)\n\n        # Finally, add othello.\n        events = []\n        email3 = 'othello@zulip.com'\n        user_profile = get_user_profile_by_email(email3)\n        stream = get_stream('multi_user_stream', realm)\n        with tornado_redirected_to_list(events):\n            bulk_add_subscriptions([stream], [user_profile])\n\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [get_user_profile_by_email(email3).id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([email1, email2, email3, self.test_email])\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event['users'])\n        self.assertEqual(len(add_peer_event['users']), 16)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], user_profile.id)\n\n    def test_private_stream_subscription(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n\n        # Create a private stream with Hamlet subscribed\n        stream_name = \"private\"\n        (stream, _) = create_stream_if_needed(realm, stream_name, invite_only=True)\n\n        existing_email = \"hamlet@zulip.com\"\n        existing_user_profile = get_user_profile_by_email(existing_email)\n        bulk_add_subscriptions([stream], [existing_user_profile])\n\n        # Now subscribe Cordelia to the stream, capturing events\n        email = 'cordelia@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            bulk_add_subscriptions([stream], [user_profile])\n\n        self.assert_length(events, 3)\n        create_event, add_event, add_peer_event = events\n\n        self.assertEqual(create_event['event']['type'], 'stream')\n        self.assertEqual(create_event['event']['op'], 'create')\n        self.assertEqual(create_event['users'], [user_profile.id])\n        self.assertEqual(create_event['event']['streams'][0]['name'], stream_name)\n\n        self.assertEqual(add_event['event']['type'], 'subscription')\n        self.assertEqual(add_event['event']['op'], 'add')\n        self.assertEqual(add_event['users'], [user_profile.id])\n        self.assertEqual(\n            set(add_event['event']['subscriptions'][0]['subscribers']),\n            set([user_profile.email, existing_user_profile.email])\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event['users'])\n        self.assertEqual(len(add_peer_event['users']), 1)\n        self.assertEqual(add_peer_event['event']['type'], 'subscription')\n        self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n        self.assertEqual(add_peer_event['event']['user_id'], user_profile.id)\n\n    def test_users_getting_add_peer_event(self):\n        # type: () -> None\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        streams_to_sub = ['multi_user_stream']\n        users_to_subscribe = [self.test_email, \"othello@zulip.com\"]\n        self.common_subscribe_to_streams(\n            self.test_email,\n            streams_to_sub,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n\n        new_users_to_subscribe = [\"iago@zulip.com\", \"cordelia@zulip.com\"]\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            self.common_subscribe_to_streams(\n                self.test_email,\n                streams_to_sub,\n                dict(principals=ujson.dumps(new_users_to_subscribe)),\n            )\n\n        add_peer_events = [events[2], events[3]]\n        for add_peer_event in add_peer_events:\n            self.assertEqual(add_peer_event['event']['type'], 'subscription')\n            self.assertEqual(add_peer_event['event']['op'], 'peer_add')\n            event_sent_to_ids = add_peer_event['users']\n            user_dict = [get_user_profile_by_id(user_id).email\n                         for user_id in event_sent_to_ids]\n            for user in new_users_to_subscribe:\n                # Make sure new users subscribed to stream is not in\n                # peer_add event recipient list\n                self.assertNotIn(user, user_dict)\n            for old_user in users_to_subscribe:\n                # Check non new users are in peer_add event recipient list.\n                self.assertIn(old_user, user_dict)\n\n    def test_users_getting_remove_peer_event(self):\n        # type: () -> None\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        email1 = 'othello@zulip.com'\n        email2 = 'cordelia@zulip.com'\n        email3 = 'hamlet@zulip.com'\n        email4 = 'iago@zulip.com'\n\n        stream1 = self.make_stream('stream1')\n        stream2 = self.make_stream('stream2')\n        private = self.make_stream('private_stream', invite_only=True)\n\n        self.subscribe_to_stream(email1, 'stream1')\n        self.subscribe_to_stream(email2, 'stream1')\n        self.subscribe_to_stream(email3, 'stream1')\n\n        self.subscribe_to_stream(email2, 'stream2')\n\n        self.subscribe_to_stream(email1, 'private_stream')\n        self.subscribe_to_stream(email2, 'private_stream')\n        self.subscribe_to_stream(email3, 'private_stream')\n\n        user1 = get_user_profile_by_email(email1)\n        user2 = get_user_profile_by_email(email2)\n        user3 = get_user_profile_by_email(email3)\n        user4 = get_user_profile_by_email(email4)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            bulk_remove_subscriptions(\n                users=[user1, user2],\n                streams=[stream1, stream2, private]\n            )\n\n        peer_events = [e for e in events\n                       if e['event'].get('op') == 'peer_remove']\n\n        notifications = set()\n        for event in peer_events:\n            for user_id in event['users']:\n                for stream_name in event['event']['subscriptions']:\n                    removed_user_id = event['event']['user_id']\n                    notifications.add((user_id, removed_user_id, stream_name))\n\n        # POSITIVE CASES FIRST\n        self.assertIn((user3.id, user1.id, 'stream1'), notifications)\n        self.assertIn((user4.id, user1.id, 'stream1'), notifications)\n\n        self.assertIn((user3.id, user2.id, 'stream1'), notifications)\n        self.assertIn((user4.id, user2.id, 'stream1'), notifications)\n\n        self.assertIn((user1.id, user2.id, 'stream2'), notifications)\n        self.assertIn((user3.id, user2.id, 'stream2'), notifications)\n        self.assertIn((user4.id, user2.id, 'stream2'), notifications)\n\n        self.assertIn((user3.id, user1.id, 'private_stream'), notifications)\n        self.assertIn((user3.id, user2.id, 'private_stream'), notifications)\n\n        # NEGATIVE\n\n        # don't be notified if you are being removed yourself\n        self.assertNotIn((user1.id, user1.id, 'stream1'), notifications)\n\n        # don't send false notifications for folks that weren't actually\n        # subscribed int he first place\n        self.assertNotIn((user3.id, user1.id, 'stream2'), notifications)\n\n        # don't send notifications for random people\n        self.assertNotIn((user3.id, user4.id, 'stream2'), notifications)\n\n        # don't send notifications to unsubscribed people for private streams\n        self.assertNotIn((user4.id, user1.id, 'private_stream'), notifications)\n\n    def test_bulk_subscribe_MIT(self):\n        # type: () -> None\n        realm = get_realm(\"mit\")\n        streams = [\"stream_%s\" % i for i in range(40)]\n        for stream_name in streams:\n            self.make_stream(stream_name, realm=realm)\n\n        events = [] # type: List[Dict[str, Any]]\n        with tornado_redirected_to_list(events):\n            with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    'starnine@mit.edu',\n                    streams,\n                    dict(principals=ujson.dumps(['starnine@mit.edu'])),\n                )\n        # Make sure Zephyr mirroring realms such as MIT do not get\n        # any tornado subscription events\n        self.assert_length(events, 0)\n        self.assert_max_length(queries, 7)\n\n    def test_bulk_subscribe_many(self):\n        # type: () -> None\n\n        # Create a whole bunch of streams\n        streams = [\"stream_%s\" % i for i in range(20)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        with queries_captured() as queries:\n                self.common_subscribe_to_streams(\n                    self.test_email,\n                    streams,\n                    dict(principals=ujson.dumps([self.test_email])),\n                )\n        # Make sure we don't make O(streams) queries\n        self.assert_max_length(queries, 10)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_subscriptions_add_for_principal(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to streams.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_subscriptions_add_for_principal_invite_only(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to invite only streams.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams,\n                                                       invite_only=True)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_non_ascii_subscription_for_principal(self):\n        # type: () -> None\n        \"\"\"\n        You can subscribe other people to streams even if they containing\n        non-ASCII characters.\n        \"\"\"\n        self.assert_adding_subscriptions_for_principal(\"iago@zulip.com\", [u\"h\u00fcmb\u00fc\u01f5\"])\n\n    def test_subscription_add_invalid_principal(self):\n        # type: () -> None\n        \"\"\"\n        Calling subscribe on behalf of a principal that does not exist\n        should return a JSON error.\n        \"\"\"\n        invalid_principal = \"rosencrantz-and-guildenstern@zulip.com\"\n        # verify that invalid_principal actually doesn't exist\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user_profile_by_email(invalid_principal)\n        result = self.common_subscribe_to_streams(self.test_email, self.streams,\n                                                  {\"principals\": ujson.dumps([invalid_principal])})\n        self.assert_json_error(result, \"User not authorized to execute queries on behalf of '%s'\"\n                               % (invalid_principal,), status_code=403)\n\n    def test_subscription_add_principal_other_realm(self):\n        # type: () -> None\n        \"\"\"\n        Calling subscribe on behalf of a principal in another realm\n        should return a JSON error.\n        \"\"\"\n        principal = \"starnine@mit.edu\"\n        profile = get_user_profile_by_email(principal)\n        # verify that principal exists (thus, the reason for the error is the cross-realming)\n        self.assertIsInstance(profile, UserProfile)\n        result = self.common_subscribe_to_streams(self.test_email, self.streams,\n                                                  {\"principals\": ujson.dumps([principal])})\n        self.assert_json_error(result, \"User not authorized to execute queries on behalf of '%s'\"\n                               % (principal,), status_code=403)\n\n    def helper_check_subs_before_and_after_remove(self, subscriptions, json_dict,\n                                                  email, new_subs):\n        # type: (List[Text], Dict[str, Any], Text, List[Text]) -> None\n        \"\"\"\n        Check result of removing subscriptions.\n\n        Unlike adding subscriptions, you can only remove subscriptions\n        for yourself, so the result format is different.\n\n        {\"msg\": \"\",\n         \"removed\": [\"Denmark\", \"Scotland\", \"Verona\"],\n         \"not_subscribed\": [\"Rome\"], \"result\": \"success\"}\n        \"\"\"\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps(subscriptions)})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        for key, val in six.iteritems(json_dict):\n            self.assertEqual(sorted(val), sorted(json[key]))  # we don't care about the order of the items\n        new_streams = self.get_streams(email)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_remove(self):\n        # type: () -> None\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions should successfully remove streams,\n        and should determine which were removed vs which weren't subscribed to.\n        We cannot randomly generate stream names because the remove code\n        verifies whether streams exist.\n        \"\"\"\n        if len(self.streams) < 2:\n            self.fail()  # necesssary for full test coverage\n        streams_to_remove = self.streams[1:]\n        not_subbed = []\n        for stream in Stream.objects.all():\n            if stream.name not in self.streams:\n                not_subbed.append(stream.name)\n        random.shuffle(not_subbed)\n        self.assertNotEqual(len(not_subbed), 0)  # necessary for full test coverage\n        try_to_remove = not_subbed[:3]  # attempt to remove up to 3 streams not already subbed to\n        streams_to_remove.extend(try_to_remove)\n        self.helper_check_subs_before_and_after_remove(streams_to_remove,\n                                                       {\"removed\": self.streams[1:], \"not_subscribed\": try_to_remove},\n                                                       self.test_email, [self.streams[0]])\n\n    def test_subscriptions_remove_fake_stream(self):\n        # type: () -> None\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions on a stream that doesn't exist\n        should return a JSON error.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        streams_to_remove = random_streams[:1]  # pick only one fake stream, to make checking the error message easy\n        result = self.client_delete(\"/json/users/me/subscriptions\",\n                                    {\"subscriptions\": ujson.dumps(streams_to_remove)})\n        self.assert_json_error(result, \"Stream(s) (%s) do not exist\" % (random_streams[0],))\n\n    def helper_subscriptions_exists(self, stream, exists, subscribed):\n        # type: (Text, bool, bool) -> None\n        \"\"\"\n        A helper function that calls /json/subscriptions/exists on a stream and\n        verifies that the returned JSON dictionary has the exists and\n        subscribed values passed in as parameters. (If subscribed should not be\n        present, pass in None.)\n        \"\"\"\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": stream})\n        json = ujson.loads(result.content)\n        self.assertIn(\"exists\", json)\n        self.assertEqual(json[\"exists\"], exists)\n        if exists:\n            self.assert_json_success(result)\n        else:\n            self.assertEqual(result.status_code, 404)\n        if subscribed:\n            self.assertIn(\"subscribed\", json)\n            self.assertEqual(json[\"subscribed\"], subscribed)\n\n    def test_successful_subscriptions_exists_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are subbed\n        should return that it exists and that you are subbed.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(self.streams[0], True, True)\n\n    def test_successful_subscriptions_exists_not_subbed(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are not\n        subbed should return that it exists and that you are not subbed.\n        \"\"\"\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.realm)]\n        streams_not_subbed = list(set(all_stream_names) - set(self.streams))\n        self.assertNotEqual(len(streams_not_subbed), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(streams_not_subbed[0], True, False)\n\n    def test_subscriptions_does_not_exist(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream that doesn't exist should\n        return that it doesn't exist.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(random_streams[0], False, False)\n\n    def test_subscriptions_exist_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid stream name is the empty string\n        invalid_stream_name = \"\"\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": invalid_stream_name})\n        self.assert_json_error(result, \"Invalid characters in stream name\")\n\n    def test_existing_subscriptions_autosubscription(self):\n        # type: () -> None\n        \"\"\"\n        Call /json/subscriptions/exist on an existing stream and autosubscribe to it.\n        \"\"\"\n        stream_name = self.streams[0]\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": stream_name, \"autosubscribe\": True})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"exists\", json)\n        self.assertTrue(json[\"exists\"])\n\n    def test_existing_subscriptions_autosubscription_private_stream(self):\n        # type: () -> None\n        \"\"\"Call /json/subscriptions/exist on an existing private stream with\n        autosubscribe should fail.\n        \"\"\"\n        stream_name = \"Saxony\"\n        result = self.common_subscribe_to_streams(\"cordelia@zulip.com\", [stream_name],\n                                                  invite_only=True)\n        stream = get_stream(stream_name, self.realm)\n\n        result = self.client_post(\"/json/subscriptions/exists\",\n                                  {\"stream\": stream_name, \"autosubscribe\": True})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"exists\", json)\n        self.assertTrue(json[\"exists\"])\n        self.assertIn(\"subscribed\", json)\n        # Importantly, we are not now subscribed\n        self.assertFalse(json[\"subscribed\"])\n        self.assertEqual(Subscription.objects.filter(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=stream.id).count(), 1)\n\n    def get_subscription(self, user_profile, stream_name):\n        # type: (UserProfile, Text) -> Subscription\n        stream = get_stream(stream_name, self.realm)\n        return Subscription.objects.get(\n            user_profile=user_profile,\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=stream.id,\n        )\n\n    def test_subscriptions_add_notification_default_true(self):\n        # type: () -> None\n        \"\"\"\n        When creating a subscription, the desktop and audible notification\n        settings for that stream are derived from the global notification\n        settings.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        user_profile = get_user_profile_by_email(invitee)\n        user_profile.enable_stream_desktop_notifications = True\n        user_profile.enable_stream_sounds = True\n        user_profile.save()\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n\n        with mock.patch('zerver.models.Recipient.__unicode__', return_value='recip'):\n            self.assertEqual(str(subscription),\n                             u'<Subscription: '\n                             '<UserProfile: iago@zulip.com <Realm: zulip.com 1>> -> recip>')\n\n        self.assertTrue(subscription.desktop_notifications)\n        self.assertTrue(subscription.audible_notifications)\n\n    def test_subscriptions_add_notification_default_false(self):\n        # type: () -> None\n        \"\"\"\n        When creating a subscription, the desktop and audible notification\n        settings for that stream are derived from the global notification\n        settings.\n        \"\"\"\n        invitee = \"iago@zulip.com\"\n        user_profile = get_user_profile_by_email(invitee)\n        user_profile.enable_stream_desktop_notifications = False\n        user_profile.enable_stream_sounds = False\n        user_profile.save()\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(invitee, invite_streams)\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n        self.assertFalse(subscription.desktop_notifications)\n        self.assertFalse(subscription.audible_notifications)\n\n\nclass GetPublicStreamsTest(ZulipTestCase):\n\n    def test_public_streams_api(self):\n        # type: () -> None\n        \"\"\"\n        Ensure that the query we use to get public streams successfully returns\n        a list of streams\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        # Check it correctly lists the user's subs with include_public=false\n        result = self.client_get(\"/api/v1/streams?include_public=false\", **self.api_auth(email))\n        result2 = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n\n        self.assertIn(\"streams\", json)\n\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(result2)\n        json2 = ujson.loads(result2.content)\n\n        self.assertEqual(sorted([s[\"name\"] for s in json[\"streams\"]]),\n                         sorted([s[\"name\"] for s in json2[\"subscriptions\"]]))\n\n        # Check it correctly lists all public streams with include_subscribed=false\n        result = self.client_get(\"/api/v1/streams?include_public=true&include_subscribed=false\",\n                                 **self.api_auth(email))\n        self.assert_json_success(result)\n\n        json = ujson.loads(result.content)\n        all_streams = [stream.name for stream in\n                       Stream.objects.filter(realm=get_user_profile_by_email(email).realm)]\n        self.assertEqual(sorted(s[\"name\"] for s in json[\"streams\"]),\n                         sorted(all_streams))\n\n        # Check non-superuser can't use include_all_active\n        result = self.client_get(\"/api/v1/streams?include_all_active=true\",\n                                 **self.api_auth(email))\n        self.assertEqual(result.status_code, 400)\n\nclass StreamIdTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email = \"hamlet@zulip.com\"\n        self.user_profile = get_user_profile_by_email(self.email)\n        self.login(self.email)\n\n    def test_get_stream_id(self):\n        # type: () -> None\n        stream = gather_subscriptions(self.user_profile)[0][0]\n        result = self.client_get(\"/json/get_stream_id?stream=%s\" % (stream['name'],))\n        self.assert_json_success(result)\n        self.assertEqual(result.json()['stream_id'], stream['stream_id'])\n\n    def test_get_stream_id_wrong_name(self):\n        # type: () -> None\n        result = self.client_get(\"/json/get_stream_id?stream=wrongname\")\n        self.assert_json_error(result, u'No such stream name')\n\nclass InviteOnlyStreamTest(ZulipTestCase):\n    def test_must_be_subbed_to_send(self):\n        # type: () -> None\n        \"\"\"\n        If you try to send a message to an invite-only stream to which\n        you aren't subscribed, you'll get a 400.\n        \"\"\"\n        self.login(\"hamlet@zulip.com\")\n        # Create Saxony as an invite-only stream.\n        self.assert_json_success(\n            self.common_subscribe_to_streams(\"hamlet@zulip.com\", [\"Saxony\"],\n                                             invite_only=True))\n\n        email = \"cordelia@zulip.com\"\n        with self.assertRaises(JsonableError):\n            self.send_message(email, \"Saxony\", Recipient.STREAM)\n\n    def test_list_respects_invite_only_bit(self):\n        # type: () -> None\n        \"\"\"\n        Make sure that /api/v1/users/me/subscriptions properly returns\n        the invite-only bit for streams that are invite-only\n        \"\"\"\n        email = 'hamlet@zulip.com'\n        self.login(email)\n\n        result1 = self.common_subscribe_to_streams(email, [\"Saxony\"], invite_only=True)\n        self.assert_json_success(result1)\n        result2 = self.common_subscribe_to_streams(email, [\"Normandy\"], invite_only=False)\n        self.assert_json_success(result2)\n        result = self.client_get(\"/api/v1/users/me/subscriptions\", **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertIn(\"subscriptions\", json)\n        for sub in json[\"subscriptions\"]:\n            if sub['name'] == \"Normandy\":\n                self.assertEqual(sub['invite_only'], False, \"Normandy was mistakenly marked invite-only\")\n            if sub['name'] == \"Saxony\":\n                self.assertEqual(sub['invite_only'], True, \"Saxony was not properly marked invite-only\")\n\n    @slow(\"lots of queries\")\n    def test_inviteonly(self):\n        # type: () -> None\n        # Creating an invite-only stream is allowed\n        email = 'hamlet@zulip.com'\n        stream_name = \"Saxony\"\n\n        result = self.common_subscribe_to_streams(email, [stream_name], invite_only=True)\n        self.assert_json_success(result)\n\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"subscribed\"], {email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Subscribing oneself to an invite-only stream is not allowed\n        email = \"othello@zulip.com\"\n        self.login(email)\n        result = self.common_subscribe_to_streams(email, [stream_name])\n        self.assert_json_error(result, 'Unable to access stream (Saxony).')\n\n        # authorization_errors_fatal=False works\n        email = \"othello@zulip.com\"\n        self.login(email)\n        result = self.common_subscribe_to_streams(email, [stream_name],\n                                                  extra_post_data={'authorization_errors_fatal': ujson.dumps(False)})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"unauthorized\"], [stream_name])\n        self.assertEqual(json[\"subscribed\"], {})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Inviting another user to an invite-only stream is allowed\n        email = 'hamlet@zulip.com'\n        user_profile = get_user_profile_by_email(email)\n        self.login(email)\n        result = self.common_subscribe_to_streams(\n            email, [stream_name],\n            extra_post_data={'principals': ujson.dumps([\"othello@zulip.com\"])})\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n        self.assertEqual(json[\"subscribed\"], {\"othello@zulip.com\": [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Make sure both users are subscribed to this stream\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.client_get(\"/api/v1/streams/%d/members\" % (stream_id,),\n                                 **self.api_auth(email))\n        self.assert_json_success(result)\n        json = ujson.loads(result.content)\n\n        self.assertTrue('othello@zulip.com' in json['subscribers'])\n        self.assertTrue('hamlet@zulip.com' in json['subscribers'])\n\nclass GetSubscribersTest(ZulipTestCase):\n\n    def setUp(self):\n        # type: () -> None\n        self.email = \"hamlet@zulip.com\"\n        self.user_profile = get_user_profile_by_email(self.email)\n        self.login(self.email)\n\n    def check_well_formed_result(self, result, stream_name, realm):\n        # type: (Dict[str, Any], Text, Realm) -> None\n        \"\"\"\n        A successful call to get_subscribers returns the list of subscribers in\n        the form:\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"subscribers\": [\"hamlet@zulip.com\", \"prospero@zulip.com\"]}\n        \"\"\"\n        self.assertIn(\"subscribers\", result)\n        self.assertIsInstance(result[\"subscribers\"], list)\n        true_subscribers = [user_profile.email for user_profile in self.users_subscribed_to_stream(\n            stream_name, realm)]\n        self.assertEqual(sorted(result[\"subscribers\"]), sorted(true_subscribers))\n\n    def make_subscriber_request(self, stream_id, email=None):\n        # type: (int, Optional[str]) -> HttpResponse\n        if email is None:\n            email = self.email\n        return self.client_get(\"/api/v1/streams/%d/members\" % (stream_id,),\n                               **self.api_auth(email))\n\n    def make_successful_subscriber_request(self, stream_name):\n        # type: (Text) -> None\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        result = self.make_subscriber_request(stream_id)\n        self.assert_json_success(result)\n        self.check_well_formed_result(ujson.loads(result.content),\n                                      stream_name, self.user_profile.realm)\n\n    def test_subscriber(self):\n        # type: () -> None\n        \"\"\"\n        get_subscribers returns the list of subscribers.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0]['name']\n        self.make_successful_subscriber_request(stream_name)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_gather_subscriptions(self):\n        # type: () -> None\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        streams = [\"stream_%s\" % i for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        users_to_subscribe = [self.email, \"othello@zulip.com\", \"cordelia@zulip.com\"]\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            streams,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n        self.assert_json_success(ret)\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            [\"stream_invite_only_1\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n\n        with queries_captured() as queries:\n            subscriptions = gather_subscriptions(self.user_profile)\n        self.assertTrue(len(subscriptions[0]) >= 11)\n        for sub in subscriptions[0]:\n            if not sub[\"name\"].startswith(\"stream_\"):\n                continue\n            self.assertTrue(len(sub[\"subscribers\"]) == len(users_to_subscribe))\n        self.assert_length(queries, 4)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_never_subscribed_streams(self):\n        # type: () -> None\n        \"\"\"\n        Check never_subscribed streams are fetched correctly and not include invite_only streams.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        streams = [\"stream_%s\" % i for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name, realm=realm)\n        users_to_subscribe = [\"othello@zulip.com\", \"cordelia@zulip.com\"]\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            streams,\n            dict(principals=ujson.dumps(users_to_subscribe)))\n        self.assert_json_success(ret)\n        ret = self.common_subscribe_to_streams(\n            self.email,\n            [\"stream_invite_only_1\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n        with queries_captured() as queries:\n            subscribed, unsubscribed, never_subscribed = gather_subscriptions_helper(self.user_profile)\n        self.assertTrue(len(never_subscribed) >= 10)\n\n        # Invite only stream should not be there in never_subscribed streams\n        for stream_dict in never_subscribed:\n            if stream_dict[\"name\"].startswith(\"stream_\"):\n                self.assertFalse(stream_dict['name'] == \"stream_invite_only_1\")\n                self.assertTrue(len(stream_dict[\"subscribers\"]) == len(users_to_subscribe))\n        self.assert_length(queries, 3)\n\n    @slow(\"common_subscribe_to_streams is slow\")\n    def test_gather_subscriptions_mit(self):\n        # type: () -> None\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        # Subscribe only ourself because invites are disabled on mit.edu\n        users_to_subscribe = [\"starnine@mit.edu\", \"espuser@mit.edu\"]\n        for email in users_to_subscribe:\n            self.subscribe_to_stream(email, \"mit_stream\")\n\n        ret = self.common_subscribe_to_streams(\n            \"starnine@mit.edu\",\n            [\"mit_invite_only\"],\n            dict(principals=ujson.dumps(users_to_subscribe)),\n            invite_only=True)\n        self.assert_json_success(ret)\n\n        with queries_captured() as queries:\n            subscriptions = gather_subscriptions(get_user_profile_by_email(\"starnine@mit.edu\"))\n\n        self.assertTrue(len(subscriptions[0]) >= 2)\n        for sub in subscriptions[0]:\n            if not sub[\"name\"].startswith(\"mit_\"):\n                continue\n            if sub[\"name\"] == \"mit_invite_only\":\n                self.assertTrue(len(sub[\"subscribers\"]) == len(users_to_subscribe))\n            else:\n                self.assertTrue(len(sub[\"subscribers\"]) == 0)\n        self.assert_length(queries, 4)\n\n    def test_nonsubscriber(self):\n        # type: () -> None\n        \"\"\"\n        Even a non-subscriber to a public stream can query a stream's membership\n        with get_subscribers.\n        \"\"\"\n        # Create a stream for which Hamlet is the only subscriber.\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.email, [stream_name])\n        other_email = \"othello@zulip.com\"\n\n        # Fetch the subscriber list as a non-member.\n        self.login(other_email)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_subscriber_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        A subscriber to a private stream can query that stream's membership.\n        \"\"\"\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.email, [stream_name],\n                                         invite_only=True)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_json_get_subscribers_stream_not_exist(self):\n        # type: () -> None\n        \"\"\"\n        json_get_subscribers also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_id = 99999999\n        result = self.client_get(\"/json/streams/%d/members\" % (stream_id,))\n        self.assert_json_error(result, u'Invalid stream id')\n\n    def test_json_get_subscribers(self):\n        # type: () -> None\n        \"\"\"\n        json_get_subscribers in zerver/views/streams.py\n        also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0]['name']\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        expected_subscribers = gather_subscriptions(self.user_profile)[0][0]['subscribers']\n        result = self.client_get(\"/json/streams/%d/members\" % (stream_id,))\n        self.assert_json_success(result)\n        result_dict = ujson.loads(result.content)\n        self.assertIn('subscribers', result_dict)\n        self.assertIsInstance(result_dict['subscribers'], list)\n        subscribers = [] # type: List[Text]\n        for subscriber in result_dict['subscribers']:\n            self.assertIsInstance(subscriber, six.string_types)\n            subscribers.append(subscriber)\n        self.assertEqual(set(subscribers), set(expected_subscribers))\n\n    def test_nonsubscriber_private_stream(self):\n        # type: () -> None\n        \"\"\"\n        A non-subscriber to a private stream can't query that stream's membership.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        stream_name = \"NewStream\"\n        self.common_subscribe_to_streams(self.email, [stream_name],\n                                         invite_only=True)\n        other_email = \"othello@zulip.com\"\n        user_profile = get_user_profile_by_email(other_email)\n\n        # Try to fetch the subscriber list as a non-member.\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.make_subscriber_request(stream_id, email=other_email)\n        self.assert_json_error(result,\n                               \"Unable to retrieve subscribers for invite-only stream\")\n", "from __future__ import absolute_import\nfrom typing import Any, Optional, Tuple, List, Set, Iterable, Mapping, Callable, Dict\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.http import HttpRequest, HttpResponse\n\nfrom zerver.lib.request import JsonableError, REQ, has_request_variables\nfrom zerver.decorator import authenticated_json_post_view, \\\n    authenticated_json_view, \\\n    get_user_profile_by_email, require_realm_admin, to_non_negative_int\nfrom zerver.lib.actions import bulk_remove_subscriptions, \\\n    do_change_subscription_property, internal_prep_message, \\\n    create_streams_if_needed, gather_subscriptions, subscribed_to_stream, \\\n    bulk_add_subscriptions, do_send_messages, get_subscriber_emails, do_rename_stream, \\\n    do_deactivate_stream, do_make_stream_public, do_add_default_stream, \\\n    do_change_stream_description, do_get_streams, do_make_stream_private, \\\n    do_remove_default_stream, get_topic_history_for_stream\nfrom zerver.lib.response import json_success, json_error, json_response\nfrom zerver.lib.validator import check_string, check_list, check_dict, \\\n    check_bool, check_variable_type\nfrom zerver.models import UserProfile, Stream, Realm, Subscription, \\\n    Recipient, get_recipient, get_stream, bulk_get_streams, \\\n    bulk_get_recipients, valid_stream_name, get_active_user_dicts_in_realm\n\nfrom collections import defaultdict\nimport ujson\nfrom six.moves import urllib\n\nimport six\nfrom typing import Text\n\ndef is_active_subscriber(user_profile, recipient):\n    # type: (UserProfile, Recipient) -> bool\n    return Subscription.objects.filter(user_profile=user_profile,\n                                       recipient=recipient,\n                                       active=True).exists()\n\ndef list_to_streams(streams_raw, user_profile, autocreate=False):\n    # type: (Iterable[Mapping[str, Any]], UserProfile, Optional[bool]) -> Tuple[List[Stream], List[Stream]]\n    \"\"\"Converts list of dicts to a list of Streams, validating input in the process\n\n    For each stream name, we validate it to ensure it meets our\n    requirements for a proper stream name: that is, that it is shorter\n    than Stream.MAX_NAME_LENGTH characters and passes\n    valid_stream_name.\n\n    This function in autocreate mode should be atomic: either an exception will be raised\n    during a precheck, or all the streams specified will have been created if applicable.\n\n    @param streams_raw The list of stream dictionaries to process;\n      names should already be stripped of whitespace by the caller.\n    @param user_profile The user for whom we are retreiving the streams\n    @param autocreate Whether we should create streams if they don't already exist\n    \"\"\"\n    # Validate all streams, getting extant ones, then get-or-creating the rest.\n\n    stream_set = set(stream_dict[\"name\"] for stream_dict in streams_raw)\n\n    for stream_name in stream_set:\n        # Stream names should already have been stripped by the\n        # caller, but it makes sense to verify anyway.\n        assert stream_name == stream_name.strip()\n        if len(stream_name) > Stream.MAX_NAME_LENGTH:\n            raise JsonableError(_(\"Stream name (%s) too long.\") % (stream_name,))\n        if not valid_stream_name(stream_name):\n            raise JsonableError(_(\"Invalid stream name (%s).\") % (stream_name,))\n\n    existing_streams = [] # type: List[Stream]\n    missing_stream_dicts = [] # type: List[Mapping[str, Any]]\n    existing_stream_map = bulk_get_streams(user_profile.realm, stream_set)\n\n    for stream_dict in streams_raw:\n        stream_name = stream_dict[\"name\"]\n        stream = existing_stream_map.get(stream_name.lower())\n        if stream is None:\n            missing_stream_dicts.append(stream_dict)\n        else:\n            existing_streams.append(stream)\n\n    if len(missing_stream_dicts) == 0:\n        # This is the happy path for callers who expected all of these\n        # streams to exist already.\n        created_streams = [] # type: List[Stream]\n    else:\n        # autocreate=True path starts here\n        if not user_profile.can_create_streams():\n            raise JsonableError(_('User cannot create streams.'))\n        elif not autocreate:\n            raise JsonableError(_(\"Stream(s) (%s) do not exist\") % \", \".join(\n                stream_dict[\"name\"] for stream_dict in missing_stream_dicts))\n\n        # We already filtered out existing streams, so dup_streams\n        # will normally be an empty list below, but we protect against somebody\n        # else racing to create the same stream.  (This is not an entirely\n        # paranoid approach, since often on Zulip two people will discuss\n        # creating a new stream, and both people eagerly do it.)\n        created_streams, dup_streams = create_streams_if_needed(realm=user_profile.realm,\n                                                                stream_dicts=missing_stream_dicts)\n        existing_streams += dup_streams\n\n    return existing_streams, created_streams\n\nclass PrincipalError(JsonableError):\n    def __init__(self, principal, status_code=403):\n        # type: (Text, int) -> None\n        self.principal = principal # type: Text\n        self.status_code = status_code # type: int\n\n    def to_json_error_msg(self):\n        # type: () -> Text\n        return (\"User not authorized to execute queries on behalf of '%s'\"\n                % (self.principal,))\n\ndef principal_to_user_profile(agent, principal):\n    # type: (UserProfile, Text) -> UserProfile\n    principal_doesnt_exist = False\n    try:\n        principal_user_profile = get_user_profile_by_email(principal)\n    except UserProfile.DoesNotExist:\n        principal_doesnt_exist = True\n\n    if (principal_doesnt_exist or\n            agent.realm != principal_user_profile.realm):\n        # We have to make sure we don't leak information about which users\n        # are registered for Zulip in a different realm.  We could do\n        # something a little more clever and check the domain part of the\n        # principal to maybe give a better error message\n        raise PrincipalError(principal)\n\n    return principal_user_profile\n\n@require_realm_admin\ndef deactivate_stream_backend(request, user_profile, stream_id):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    target = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n\n    if target.invite_only and not subscribed_to_stream(user_profile, target):\n        return json_error(_('Cannot administer invite-only streams this way'))\n\n    do_deactivate_stream(target)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef add_default_stream(request, user_profile, stream_name=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    do_add_default_stream(user_profile.realm, stream_name)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef remove_default_stream(request, user_profile, stream_name=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    do_remove_default_stream(user_profile.realm, stream_name)\n    return json_success()\n\n@require_realm_admin\n@has_request_variables\ndef update_stream_backend(request, user_profile, stream_id,\n                          description=REQ(validator=check_string, default=None),\n                          is_private=REQ(validator=check_bool, default=None),\n                          new_name=REQ(validator=check_string, default=None)):\n    # type: (HttpRequest, UserProfile, int, Optional[Text], Optional[bool], Optional[Text]) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    stream_name = stream.name\n\n    if description is not None:\n        do_change_stream_description(user_profile.realm, stream_name, description)\n    if stream_name is not None and new_name is not None:\n        do_rename_stream(user_profile.realm, stream_name, new_name)\n    if is_private is not None:\n        if is_private:\n            do_make_stream_private(user_profile.realm, stream_name)\n        else:\n            do_make_stream_public(user_profile, user_profile.realm, stream_name)\n    return json_success()\n\ndef list_subscriptions_backend(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n    return json_success({\"subscriptions\": gather_subscriptions(user_profile)[0]})\n\nFuncKwargPair = Tuple[Callable[..., HttpResponse], Dict[str, Iterable[Any]]]\n\n@has_request_variables\ndef update_subscriptions_backend(request, user_profile,\n                                 delete=REQ(validator=check_list(check_string), default=[]),\n                                 add=REQ(validator=check_list(check_dict([('name', check_string)])), default=[])):\n    # type: (HttpRequest, UserProfile, Iterable[Text], Iterable[Mapping[str, Any]]) -> HttpResponse\n    if not add and not delete:\n        return json_error(_('Nothing to do. Specify at least one of \"add\" or \"delete\".'))\n\n    method_kwarg_pairs = [\n        (add_subscriptions_backend, dict(streams_raw=add)),\n        (remove_subscriptions_backend, dict(streams_raw=delete))\n    ] # type: List[FuncKwargPair]\n    return compose_views(request, user_profile, method_kwarg_pairs)\n\ndef compose_views(request, user_profile, method_kwarg_pairs):\n    # type: (HttpRequest, UserProfile, List[FuncKwargPair]) -> HttpResponse\n    '''\n    This takes a series of view methods from method_kwarg_pairs and calls\n    them in sequence, and it smushes all the json results into a single\n    response when everything goes right.  (This helps clients avoid extra\n    latency hops.)  It rolls back the transaction when things go wrong in\n    any one of the composed methods.\n\n    TODO: Move this a utils-like module if we end up using it more widely.\n    '''\n\n    json_dict = {} # type: Dict[str, Any]\n    with transaction.atomic():\n        for method, kwargs in method_kwarg_pairs:\n            response = method(request, user_profile, **kwargs)\n            if response.status_code != 200:\n                raise JsonableError(response.content)\n            json_dict.update(ujson.loads(response.content))\n    return json_success(json_dict)\n\n@authenticated_json_post_view\ndef json_remove_subscriptions(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n    return remove_subscriptions_backend(request, user_profile)\n\n@has_request_variables\ndef remove_subscriptions_backend(request, user_profile,\n                                 streams_raw = REQ(\"subscriptions\", validator=check_list(check_string)),\n                                 principals = REQ(validator=check_list(check_string), default=None)):\n    # type: (HttpRequest, UserProfile, Iterable[Text], Optional[Iterable[Text]]) -> HttpResponse\n\n    removing_someone_else = principals and \\\n        set(principals) != set((user_profile.email,))\n    if removing_someone_else and not user_profile.is_realm_admin:\n        # You can only unsubscribe other people from a stream if you are a realm\n        # admin.\n        return json_error(_(\"This action requires administrative rights\"))\n\n    streams_as_dict = []\n    for stream_name in streams_raw:\n        streams_as_dict.append({\"name\": stream_name.strip()})\n\n    streams, __ = list_to_streams(streams_as_dict, user_profile)\n\n    for stream in streams:\n        if removing_someone_else and stream.invite_only and \\\n                not subscribed_to_stream(user_profile, stream):\n            # Even as an admin, you can't remove other people from an\n            # invite-only stream you're not on.\n            return json_error(_(\"Cannot administer invite-only streams this way\"))\n\n    if principals:\n        people_to_unsub = set(principal_to_user_profile(\n            user_profile, principal) for principal in principals)\n    else:\n        people_to_unsub = set([user_profile])\n\n    result = dict(removed=[], not_subscribed=[]) # type: Dict[str, List[Text]]\n    (removed, not_subscribed) = bulk_remove_subscriptions(people_to_unsub, streams)\n\n    for (subscriber, stream) in removed:\n        result[\"removed\"].append(stream.name)\n    for (subscriber, stream) in not_subscribed:\n        result[\"not_subscribed\"].append(stream.name)\n\n    return json_success(result)\n\ndef filter_stream_authorization(user_profile, streams):\n    # type: (UserProfile, Iterable[Stream]) -> Tuple[List[Stream], List[Stream]]\n    streams_subscribed = set() # type: Set[int]\n    recipients_map = bulk_get_recipients(Recipient.STREAM, [stream.id for stream in streams])\n    subs = Subscription.objects.filter(user_profile=user_profile,\n                                       recipient__in=list(recipients_map.values()),\n                                       active=True)\n\n    for sub in subs:\n        streams_subscribed.add(sub.recipient.type_id)\n\n    unauthorized_streams = [] # type: List[Stream]\n    for stream in streams:\n        # The user is authorized for his own streams\n        if stream.id in streams_subscribed:\n            continue\n\n        # The user is not authorized for invite_only streams\n        if stream.invite_only:\n            unauthorized_streams.append(stream)\n\n    authorized_streams = [stream for stream in streams if\n                          stream.id not in set(stream.id for stream in unauthorized_streams)]\n    return authorized_streams, unauthorized_streams\n\n@has_request_variables\ndef add_subscriptions_backend(request, user_profile,\n                              streams_raw = REQ(\"subscriptions\",\n                                                validator=check_list(check_dict([('name', check_string)]))),\n                              invite_only = REQ(validator=check_bool, default=False),\n                              announce = REQ(validator=check_bool, default=False),\n                              principals = REQ(validator=check_list(check_string), default=None),\n                              authorization_errors_fatal = REQ(validator=check_bool, default=True)):\n    # type: (HttpRequest, UserProfile, Iterable[Mapping[str, Text]], bool, bool, Optional[List[Text]], bool) -> HttpResponse\n    stream_dicts = []\n    for stream_dict in streams_raw:\n        stream_dict_copy = {} # type: Dict[str, Any]\n        for field in stream_dict:\n            stream_dict_copy[field] = stream_dict[field]\n        # Strip the stream name here.\n        stream_dict_copy['name'] = stream_dict_copy['name'].strip()\n        stream_dict_copy[\"invite_only\"] = invite_only\n        stream_dicts.append(stream_dict_copy)\n\n    # Validation of the streams arguments, including enforcement of\n    # can_create_streams policy and valid_stream_name policy is inside\n    # list_to_streams.\n    existing_streams, created_streams = \\\n        list_to_streams(stream_dicts, user_profile, autocreate=True)\n    authorized_streams, unauthorized_streams = \\\n        filter_stream_authorization(user_profile, existing_streams)\n    if len(unauthorized_streams) > 0 and authorization_errors_fatal:\n        return json_error(_(\"Unable to access stream (%s).\") % unauthorized_streams[0].name)\n    # Newly created streams are also authorized for the creator\n    streams = authorized_streams + created_streams\n\n    if principals is not None:\n        if user_profile.realm.is_zephyr_mirror_realm and not all(stream.invite_only for stream in streams):\n            return json_error(_(\"You can only invite other Zephyr mirroring users to invite-only streams.\"))\n        subscribers = set(principal_to_user_profile(user_profile, principal) for principal in principals)\n    else:\n        subscribers = set([user_profile])\n\n    (subscribed, already_subscribed) = bulk_add_subscriptions(streams, subscribers)\n\n    result = dict(subscribed=defaultdict(list), already_subscribed=defaultdict(list)) # type: Dict[str, Any]\n    for (subscriber, stream) in subscribed:\n        result[\"subscribed\"][subscriber.email].append(stream.name)\n    for (subscriber, stream) in already_subscribed:\n        result[\"already_subscribed\"][subscriber.email].append(stream.name)\n\n    private_streams = dict((stream.name, stream.invite_only) for stream in streams)\n    bots = dict((subscriber.email, subscriber.is_bot) for subscriber in subscribers)\n\n    # Inform the user if someone else subscribed them to stuff,\n    # or if a new stream was created with the \"announce\" option.\n    notifications = []\n    if principals and result[\"subscribed\"]:\n        for email, subscriptions in six.iteritems(result[\"subscribed\"]):\n            if email == user_profile.email:\n                # Don't send a Zulip if you invited yourself.\n                continue\n            if bots[email]:\n                # Don't send invitation Zulips to bots\n                continue\n\n            if len(subscriptions) == 1:\n                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                       \"subscribed you to the%s stream #**%s**.\"\n                       % (user_profile.full_name,\n                          \" **invite-only**\" if private_streams[subscriptions[0]] else \"\",\n                          subscriptions[0],\n                          ))\n            else:\n                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n                       \"subscribed you to the following streams: \\n\\n\"\n                       % (user_profile.full_name,))\n                for stream in subscriptions:\n                    msg += \"* #**%s**%s\\n\" % (\n                        stream,\n                        \" (**invite-only**)\" if private_streams[stream] else \"\")\n\n            if len([s for s in subscriptions if not private_streams[s]]) > 0:\n                msg += \"\\nYou can see historical content on a non-invite-only stream by narrowing to it.\"\n            notifications.append(internal_prep_message(\n                user_profile.realm, settings.NOTIFICATION_BOT,\n                \"private\", email, \"\", msg))\n\n    if announce and len(created_streams) > 0:\n        notifications_stream = user_profile.realm.notifications_stream\n        if notifications_stream is not None:\n            if len(created_streams) > 1:\n                stream_msg = \"the following streams: %s\" % (\", \".join('#**%s**' % s.name for s in created_streams))\n            else:\n                stream_msg = \"a new stream #**%s**.\" % created_streams[0].name\n            msg = (\"%s just created %s\" % (user_profile.full_name, stream_msg))\n            notifications.append(\n                internal_prep_message(user_profile.realm, settings.NOTIFICATION_BOT,\n                                      \"stream\",\n                                      notifications_stream.name, \"Streams\", msg))\n        else:\n            msg = (\"Hi there!  %s just created a new stream #**%s**.\"\n                   % (user_profile.full_name, created_streams[0].name))\n            for realm_user_dict in get_active_user_dicts_in_realm(user_profile.realm):\n                # Don't announce to yourself or to people you explicitly added\n                # (who will get the notification above instead).\n                if realm_user_dict['email'] in principals or realm_user_dict['email'] == user_profile.email:\n                    continue\n                notifications.append(internal_prep_message(\n                    user_profile.realm, settings.NOTIFICATION_BOT,\n                    \"private\",\n                    realm_user_dict['email'], \"\", msg))\n\n    if len(notifications) > 0:\n        do_send_messages(notifications)\n\n    result[\"subscribed\"] = dict(result[\"subscribed\"])\n    result[\"already_subscribed\"] = dict(result[\"already_subscribed\"])\n    if not authorization_errors_fatal:\n        result[\"unauthorized\"] = [stream.name for stream in unauthorized_streams]\n    return json_success(result)\n\n@has_request_variables\ndef get_subscribers_backend(request, user_profile,\n                            stream_id=REQ('stream', converter=to_non_negative_int)):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    subscribers = get_subscriber_emails(stream, user_profile)\n\n    return json_success({'subscribers': subscribers})\n\n# By default, lists all streams that the user has access to --\n# i.e. public streams plus invite-only streams that the user is on\n@has_request_variables\ndef get_streams_backend(request, user_profile,\n                        include_public=REQ(validator=check_bool, default=True),\n                        include_subscribed=REQ(validator=check_bool, default=True),\n                        include_all_active=REQ(validator=check_bool, default=False),\n                        include_default=REQ(validator=check_bool, default=False)):\n    # type: (HttpRequest, UserProfile, bool, bool, bool, bool) -> HttpResponse\n\n    streams = do_get_streams(user_profile, include_public=include_public,\n                             include_subscribed=include_subscribed,\n                             include_all_active=include_all_active,\n                             include_default=include_default)\n    return json_success({\"streams\": streams})\n\n@has_request_variables\ndef get_topics_backend(request, user_profile,\n                       stream_id=REQ(converter=to_non_negative_int)):\n    # type: (HttpRequest, UserProfile, int) -> HttpResponse\n    stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n\n    if stream.realm_id != user_profile.realm_id:\n        return json_error(_(\"Invalid stream id\"))\n\n    recipient = get_recipient(Recipient.STREAM, stream.id)\n\n    if not stream.is_public():\n        if not is_active_subscriber(user_profile=user_profile,\n                                    recipient=recipient):\n            return json_error(_(\"Invalid stream id\"))\n\n    result = get_topic_history_for_stream(\n        user_profile=user_profile,\n        recipient=recipient,\n    )\n\n    # Our data structure here is a list of tuples of\n    # (topic name, unread count), and it's reverse chronological,\n    # so the most recent topic is the first element of the list.\n    return json_success(dict(topics=result))\n\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_stream_exists(request, user_profile, stream=REQ(),\n                       autosubscribe=REQ(default=False)):\n    # type: (HttpRequest, UserProfile, Text, bool) -> HttpResponse\n    if not valid_stream_name(stream):\n        return json_error(_(\"Invalid characters in stream name\"))\n    try:\n        stream_id = Stream.objects.get(realm=user_profile.realm, name=stream).id\n    except Stream.DoesNotExist:\n        stream_id = None\n    return stream_exists_backend(request, user_profile, stream_id, autosubscribe)\n\ndef stream_exists_backend(request, user_profile, stream_id, autosubscribe):\n    # type: (HttpRequest, UserProfile, int, bool) -> HttpResponse\n    try:\n        stream = get_and_validate_stream_by_id(stream_id, user_profile.realm)\n    except JsonableError:\n        stream = None\n    result = {\"exists\": bool(stream)}\n    if stream is not None:\n        recipient = get_recipient(Recipient.STREAM, stream.id)\n        if not stream.invite_only and autosubscribe:\n            bulk_add_subscriptions([stream], [user_profile])\n        result[\"subscribed\"] = is_active_subscriber(\n            user_profile=user_profile,\n            recipient=recipient)\n\n        return json_success(result) # results are ignored for HEAD requests\n    return json_response(data=result, status=404)\n\ndef get_and_validate_stream_by_id(stream_id, realm):\n    # type: (int, Realm) -> Stream\n    try:\n        stream = Stream.objects.get(pk=stream_id, realm_id=realm.id)\n    except Stream.DoesNotExist:\n        raise JsonableError(_(\"Invalid stream id\"))\n    return stream\n\n@has_request_variables\ndef json_get_stream_id(request, user_profile, stream=REQ()):\n    # type: (HttpRequest, UserProfile, Text) -> HttpResponse\n    try:\n        stream_id = Stream.objects.get(realm=user_profile.realm, name=stream).id\n    except Stream.DoesNotExist:\n        return json_error(_(\"No such stream name\"))\n    return json_success({'stream_id': stream_id})\n\ndef get_subscription_or_die(stream_name, user_profile):\n    # type: (Text, UserProfile) -> Subscription\n    stream = get_stream(stream_name, user_profile.realm)\n    if not stream:\n        raise JsonableError(_(\"Invalid stream %s\") % (stream_name,))\n    recipient = get_recipient(Recipient.STREAM, stream.id)\n    subscription = Subscription.objects.filter(user_profile=user_profile,\n                                               recipient=recipient, active=True)\n\n    if not subscription.exists():\n        raise JsonableError(_(\"Not subscribed to stream %s\") % (stream_name,))\n\n    return subscription\n\n@authenticated_json_view\n@has_request_variables\ndef json_subscription_property(request, user_profile, subscription_data=REQ(\n        validator=check_list(\n            check_dict([(\"stream\", check_string),\n                        (\"property\", check_string),\n                        (\"value\", check_variable_type(\n                            [check_string, check_bool]))])))):\n    # type: (HttpRequest, UserProfile, List[Dict[str, Any]]) -> HttpResponse\n    \"\"\"\n    This is the entry point to changing subscription properties. This\n    is a bulk endpoint: requestors always provide a subscription_data\n    list containing dictionaries for each stream of interest.\n\n    Requests are of the form:\n\n    [{\"stream\": \"devel\", \"property\": \"in_home_view\", \"value\": False},\n     {\"stream\": \"devel\", \"property\": \"color\", \"value\": \"#c2c2c2\"}]\n    \"\"\"\n    if request.method != \"POST\":\n        return json_error(_(\"Invalid verb\"))\n\n    property_converters = {\"color\": check_string, \"in_home_view\": check_bool,\n                           \"desktop_notifications\": check_bool,\n                           \"audible_notifications\": check_bool,\n                           \"pin_to_top\": check_bool}\n    response_data = []\n\n    for change in subscription_data:\n        stream_name = change[\"stream\"]\n        property = change[\"property\"]\n        value = change[\"value\"]\n\n        if property not in property_converters:\n            return json_error(_(\"Unknown subscription property: %s\") % (property,))\n\n        sub = get_subscription_or_die(stream_name, user_profile)[0]\n\n        property_conversion = property_converters[property](property, value)\n        if property_conversion:\n            return json_error(property_conversion)\n\n        do_change_subscription_property(user_profile, sub, stream_name,\n                                        property, value)\n\n        response_data.append({'stream': stream_name,\n                              'property': property,\n                              'value': value})\n\n    return json_success({\"subscription_data\": response_data})\n"], "filenames": ["zerver/tests/test_subs.py", "zerver/views/streams.py"], "buggy_code_start_loc": [1938, 484], "buggy_code_end_loc": [1938, 485], "fixing_code_start_loc": [1939, 484], "fixing_code_end_loc": [1962, 485], "type": "CWE-863", "message": "An error in the implementation of an autosubscribe feature in the check_stream_exists route of the Zulip group chat application server before 1.4.3 allowed an authenticated user to subscribe to a private stream that should have required an invitation from an existing member to join. The issue affects all previously released versions of the Zulip server.", "other": {"cve": {"id": "CVE-2017-0881", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:01.463", "lastModified": "2019-10-09T23:21:06.807", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An error in the implementation of an autosubscribe feature in the check_stream_exists route of the Zulip group chat application server before 1.4.3 allowed an authenticated user to subscribe to a private stream that should have required an invitation from an existing member to join. The issue affects all previously released versions of the Zulip server."}, {"lang": "es", "value": "Un error en la implementaci\u00f3n de una funci\u00f3n de suscripci\u00f3n autom\u00e1tica en la ruta check_stream_exists del servidor de aplicaciones de chat en grupo Zulip en versiones anteriores a 1.4.3 permiti\u00f3 a un usuario autenticado suscribirse a un flujo privado que deber\u00eda haber requerido una invitaci\u00f3n de un miembro existente para unirse. El problema afecta a todas las versiones liberadas anteriormente del servidor Zulip."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "C798D82E-5E3A-4784-9D67-3977B15FE8D5"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97159", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "Vendor Advisory"]}, {"url": "https://github.com/zulip/zulip/commit/7ecda1ac8e26d8fb3725e954b2dc4723dda2255f", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/zulip-announce/VyawgRuoY34/NTBwnTArGwAJ", "source": "support@hackerone.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/7ecda1ac8e26d8fb3725e954b2dc4723dda2255f"}}