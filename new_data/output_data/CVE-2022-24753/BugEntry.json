{"buggy_code": ["package config\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/mitchellh/go-homedir\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/viper\"\n\tprefixed \"github.com/x-cray/logrus-prefixed-formatter\"\n\n\t\"github.com/stripe/stripe-cli/pkg/ansi\"\n)\n\n// ColorOn represnets the on-state for colors\nconst ColorOn = \"on\"\n\n// ColorOff represents the off-state for colors\nconst ColorOff = \"off\"\n\n// ColorAuto represents the auto-state for colors\nconst ColorAuto = \"auto\"\n\n// Config handles all overall configuration for the CLI\ntype Config struct {\n\tColor        string\n\tLogLevel     string\n\tProfile      Profile\n\tProfilesFile string\n}\n\n// GetConfigFolder retrieves the folder where the profiles file is stored\n// It searches for the xdg environment path first and will secondarily\n// place it in the home directory\nfunc (c *Config) GetConfigFolder(xdgPath string) string {\n\tconfigPath := xdgPath\n\n\tlog.WithFields(log.Fields{\n\t\t\"prefix\": \"config.Config.GetProfilesFolder\",\n\t\t\"path\":   configPath,\n\t}).Debug(\"Using profiles file\")\n\n\tif configPath == \"\" {\n\t\thome, err := homedir.Dir()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tconfigPath = filepath.Join(home, \".config\")\n\t}\n\n\treturn filepath.Join(configPath, \"stripe\")\n}\n\n// InitConfig reads in profiles file and ENV variables if set.\nfunc (c *Config) InitConfig() {\n\tlogFormatter := &prefixed.TextFormatter{\n\t\tFullTimestamp:   true,\n\t\tTimestampFormat: time.RFC1123,\n\t}\n\n\tif c.ProfilesFile != \"\" {\n\t\tviper.SetConfigFile(c.ProfilesFile)\n\t} else {\n\t\tconfigFolder := c.GetConfigFolder(os.Getenv(\"XDG_CONFIG_HOME\"))\n\t\tconfigFile := filepath.Join(configFolder, \"config.toml\")\n\t\tc.ProfilesFile = configFile\n\t\tviper.SetConfigType(\"toml\")\n\t\tviper.SetConfigFile(configFile)\n\t\tviper.SetConfigPermissions(os.FileMode(0600))\n\n\t\t// Try to change permissions manually, because we used to create files\n\t\t// with default permissions (0644)\n\t\terr := os.Chmod(configFile, os.FileMode(0600))\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\tlog.Fatalf(\"%s\", err)\n\t\t}\n\t}\n\n\t// If a profiles file is found, read it in.\n\tif err := viper.ReadInConfig(); err == nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"prefix\": \"config.Config.InitConfig\",\n\t\t\t\"path\":   viper.ConfigFileUsed(),\n\t\t}).Debug(\"Using profiles file\")\n\t}\n\n\tif c.Profile.DeviceName == \"\" {\n\t\tdeviceName, err := os.Hostname()\n\t\tif err != nil {\n\t\t\tdeviceName = \"unknown\"\n\t\t}\n\n\t\tc.Profile.DeviceName = deviceName\n\t}\n\n\tcolor, err := c.Profile.GetColor()\n\tif err != nil {\n\t\tlog.Fatalf(\"%s\", err)\n\t}\n\n\tswitch color {\n\tcase ColorOn:\n\t\tansi.ForceColors = true\n\t\tlogFormatter.ForceColors = true\n\tcase ColorOff:\n\t\tansi.DisableColors = true\n\t\tlogFormatter.DisableColors = true\n\tcase ColorAuto:\n\t\t// Nothing to do\n\tdefault:\n\t\tlog.Fatalf(\"Unrecognized color value: %s. Expected one of on, off, auto.\", c.Color)\n\t}\n\n\tlog.SetFormatter(logFormatter)\n\n\t// Set log level\n\tswitch c.LogLevel {\n\tcase \"debug\":\n\t\tlog.SetLevel(log.DebugLevel)\n\tcase \"info\":\n\t\tlog.SetLevel(log.InfoLevel)\n\tcase \"trace\":\n\t\tlog.SetLevel(log.TraceLevel)\n\tcase \"warn\":\n\t\tlog.SetLevel(log.WarnLevel)\n\tcase \"error\":\n\t\tlog.SetLevel(log.ErrorLevel)\n\tdefault:\n\t\tlog.Fatalf(\"Unrecognized log level value: %s. Expected one of debug, info, warn, error.\", c.LogLevel)\n\t}\n}\n\n// EditConfig opens the configuration file in the default editor.\nfunc (c *Config) EditConfig() error {\n\tvar err error\n\n\tfmt.Println(\"Opening config file:\", c.ProfilesFile)\n\n\tswitch runtime.GOOS {\n\tcase \"darwin\", \"linux\":\n\t\teditor := os.Getenv(\"EDITOR\")\n\t\tif editor == \"\" {\n\t\t\teditor = \"vi\"\n\t\t}\n\n\t\tcmd := exec.Command(editor, c.ProfilesFile)\n\t\t// Some editors detect whether they have control of stdin/out and will\n\t\t// fail if they do not.\n\t\tcmd.Stdin = os.Stdin\n\t\tcmd.Stdout = os.Stdout\n\n\t\treturn cmd.Run()\n\tcase \"windows\":\n\t\t// As far as I can tell, Windows doesn't have an easily accesible or\n\t\t// comparable option to $EDITOR, so default to notepad for now\n\t\terr = exec.Command(\"notepad\", c.ProfilesFile).Run()\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported platform\")\n\t}\n\n\treturn err\n}\n\n// PrintConfig outputs the contents of the configuration file.\nfunc (c *Config) PrintConfig() error {\n\tif c.Profile.ProfileName == \"default\" {\n\t\tconfigFile, err := ioutil.ReadFile(c.ProfilesFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(string(configFile))\n\t} else {\n\t\tconfigs := viper.GetStringMapString(c.Profile.ProfileName)\n\n\t\tif len(configs) > 0 {\n\t\t\tfmt.Printf(\"[%s]\\n\", c.Profile.ProfileName)\n\t\t\tfor field, value := range configs {\n\t\t\t\tfmt.Printf(\"  %s=%s\\n\", field, value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// RemoveProfile removes the profile whose name matches the provided\n// profileName from the config file.\nfunc (c *Config) RemoveProfile(profileName string) error {\n\truntimeViper := viper.GetViper()\n\tvar err error\n\n\tfor field, value := range runtimeViper.AllSettings() {\n\t\tif isProfile(value) && field == profileName {\n\t\t\truntimeViper, err = removeKey(runtimeViper, field)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn syncConfig(runtimeViper)\n}\n\n// RemoveAllProfiles removes all the profiles from the config file.\nfunc (c *Config) RemoveAllProfiles() error {\n\truntimeViper := viper.GetViper()\n\tvar err error\n\n\tfor field, value := range runtimeViper.AllSettings() {\n\t\tif isProfile(value) {\n\t\t\truntimeViper, err = removeKey(runtimeViper, field)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn syncConfig(runtimeViper)\n}\n\n// isProfile identifies whether a value in the config pertains to a profile.\nfunc isProfile(value interface{}) bool {\n\t// TODO: ianjabour - ideally find a better way to identify projects in config\n\t_, ok := value.(map[string]interface{})\n\treturn ok\n}\n\n// syncConfig merges a runtimeViper instance with the config file being used.\nfunc syncConfig(runtimeViper *viper.Viper) error {\n\truntimeViper.MergeInConfig()\n\tprofilesFile := viper.ConfigFileUsed()\n\truntimeViper.SetConfigFile(profilesFile)\n\t// Ensure we preserve the config file type\n\truntimeViper.SetConfigType(filepath.Ext(profilesFile))\n\n\terr := runtimeViper.WriteConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Temporary workaround until https://github.com/spf13/viper/pull/519 can remove a key from viper\nfunc removeKey(v *viper.Viper, key string) (*viper.Viper, error) {\n\tconfigMap := v.AllSettings()\n\tpath := strings.Split(key, \".\")\n\tlastKey := strings.ToLower(path[len(path)-1])\n\tdeepestMap := deepSearch(configMap, path[0:len(path)-1])\n\tdelete(deepestMap, lastKey)\n\n\tbuf := new(bytes.Buffer)\n\n\tencodeErr := toml.NewEncoder(buf).Encode(configMap)\n\tif encodeErr != nil {\n\t\treturn nil, encodeErr\n\t}\n\n\tnv := viper.New()\n\tnv.SetConfigType(\"toml\") // hint to viper that we've encoded the data as toml\n\n\terr := nv.ReadConfig(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nv, nil\n}\n\nfunc makePath(path string) error {\n\tdir := filepath.Dir(path)\n\n\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(dir, os.ModePerm)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// taken from https://github.com/spf13/viper/blob/master/util.go#L199,\n// we need this to delete configs, remove when viper supprts unset natively\nfunc deepSearch(m map[string]interface{}, path []string) map[string]interface{} {\n\tfor _, k := range path {\n\t\tm2, ok := m[k]\n\t\tif !ok {\n\t\t\t// intermediate key does not exist\n\t\t\t// => create it and continue from there\n\t\t\tm3 := make(map[string]interface{})\n\t\t\tm[k] = m3\n\t\t\tm = m3\n\n\t\t\tcontinue\n\t\t}\n\n\t\tm3, ok := m2.(map[string]interface{})\n\t\tif !ok {\n\t\t\t// intermediate key is a value\n\t\t\t// => replace with a new map\n\t\t\tm3 = make(map[string]interface{})\n\t\t\tm[k] = m3\n\t\t}\n\n\t\t// continue search from here\n\t\tm = m3\n\t}\n\n\treturn m\n}\n", "package open\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"runtime\"\n)\n\nvar execCommand = exec.Command\n\n// Browser takes a url and opens it using the default browser on the operating system\nfunc Browser(url string) error {\n\tvar err error\n\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\terr = execCommand(\"xdg-open\", url).Start()\n\tcase \"windows\":\n\t\terr = execCommand(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n\tcase \"darwin\":\n\t\terr = execCommand(\"open\", url).Start()\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported platform\")\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CanOpenBrowser determines if no browser is set in linux\nfunc CanOpenBrowser() bool {\n\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"darwin\" {\n\t\treturn true\n\t}\n\n\toutput, err := execCommand(\"xdg-settings\", \"get\", \"default-web-browser\").Output()\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif string(output) == \"\" {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"], "fixing_code": ["package config\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\texec \"golang.org/x/sys/execabs\"\n\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/mitchellh/go-homedir\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/viper\"\n\tprefixed \"github.com/x-cray/logrus-prefixed-formatter\"\n\n\t\"github.com/stripe/stripe-cli/pkg/ansi\"\n)\n\n// ColorOn represnets the on-state for colors\nconst ColorOn = \"on\"\n\n// ColorOff represents the off-state for colors\nconst ColorOff = \"off\"\n\n// ColorAuto represents the auto-state for colors\nconst ColorAuto = \"auto\"\n\n// Config handles all overall configuration for the CLI\ntype Config struct {\n\tColor        string\n\tLogLevel     string\n\tProfile      Profile\n\tProfilesFile string\n}\n\n// GetConfigFolder retrieves the folder where the profiles file is stored\n// It searches for the xdg environment path first and will secondarily\n// place it in the home directory\nfunc (c *Config) GetConfigFolder(xdgPath string) string {\n\tconfigPath := xdgPath\n\n\tlog.WithFields(log.Fields{\n\t\t\"prefix\": \"config.Config.GetProfilesFolder\",\n\t\t\"path\":   configPath,\n\t}).Debug(\"Using profiles file\")\n\n\tif configPath == \"\" {\n\t\thome, err := homedir.Dir()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tconfigPath = filepath.Join(home, \".config\")\n\t}\n\n\treturn filepath.Join(configPath, \"stripe\")\n}\n\n// InitConfig reads in profiles file and ENV variables if set.\nfunc (c *Config) InitConfig() {\n\tlogFormatter := &prefixed.TextFormatter{\n\t\tFullTimestamp:   true,\n\t\tTimestampFormat: time.RFC1123,\n\t}\n\n\tif c.ProfilesFile != \"\" {\n\t\tviper.SetConfigFile(c.ProfilesFile)\n\t} else {\n\t\tconfigFolder := c.GetConfigFolder(os.Getenv(\"XDG_CONFIG_HOME\"))\n\t\tconfigFile := filepath.Join(configFolder, \"config.toml\")\n\t\tc.ProfilesFile = configFile\n\t\tviper.SetConfigType(\"toml\")\n\t\tviper.SetConfigFile(configFile)\n\t\tviper.SetConfigPermissions(os.FileMode(0600))\n\n\t\t// Try to change permissions manually, because we used to create files\n\t\t// with default permissions (0644)\n\t\terr := os.Chmod(configFile, os.FileMode(0600))\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\tlog.Fatalf(\"%s\", err)\n\t\t}\n\t}\n\n\t// If a profiles file is found, read it in.\n\tif err := viper.ReadInConfig(); err == nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"prefix\": \"config.Config.InitConfig\",\n\t\t\t\"path\":   viper.ConfigFileUsed(),\n\t\t}).Debug(\"Using profiles file\")\n\t}\n\n\tif c.Profile.DeviceName == \"\" {\n\t\tdeviceName, err := os.Hostname()\n\t\tif err != nil {\n\t\t\tdeviceName = \"unknown\"\n\t\t}\n\n\t\tc.Profile.DeviceName = deviceName\n\t}\n\n\tcolor, err := c.Profile.GetColor()\n\tif err != nil {\n\t\tlog.Fatalf(\"%s\", err)\n\t}\n\n\tswitch color {\n\tcase ColorOn:\n\t\tansi.ForceColors = true\n\t\tlogFormatter.ForceColors = true\n\tcase ColorOff:\n\t\tansi.DisableColors = true\n\t\tlogFormatter.DisableColors = true\n\tcase ColorAuto:\n\t\t// Nothing to do\n\tdefault:\n\t\tlog.Fatalf(\"Unrecognized color value: %s. Expected one of on, off, auto.\", c.Color)\n\t}\n\n\tlog.SetFormatter(logFormatter)\n\n\t// Set log level\n\tswitch c.LogLevel {\n\tcase \"debug\":\n\t\tlog.SetLevel(log.DebugLevel)\n\tcase \"info\":\n\t\tlog.SetLevel(log.InfoLevel)\n\tcase \"trace\":\n\t\tlog.SetLevel(log.TraceLevel)\n\tcase \"warn\":\n\t\tlog.SetLevel(log.WarnLevel)\n\tcase \"error\":\n\t\tlog.SetLevel(log.ErrorLevel)\n\tdefault:\n\t\tlog.Fatalf(\"Unrecognized log level value: %s. Expected one of debug, info, warn, error.\", c.LogLevel)\n\t}\n}\n\n// EditConfig opens the configuration file in the default editor.\nfunc (c *Config) EditConfig() error {\n\tvar err error\n\n\tfmt.Println(\"Opening config file:\", c.ProfilesFile)\n\n\tswitch runtime.GOOS {\n\tcase \"darwin\", \"linux\":\n\t\teditor := os.Getenv(\"EDITOR\")\n\t\tif editor == \"\" {\n\t\t\teditor = \"vi\"\n\t\t}\n\n\t\tcmd := exec.Command(editor, c.ProfilesFile)\n\t\t// Some editors detect whether they have control of stdin/out and will\n\t\t// fail if they do not.\n\t\tcmd.Stdin = os.Stdin\n\t\tcmd.Stdout = os.Stdout\n\n\t\treturn cmd.Run()\n\tcase \"windows\":\n\t\t// As far as I can tell, Windows doesn't have an easily accesible or\n\t\t// comparable option to $EDITOR, so default to notepad for now\n\t\terr = exec.Command(\"notepad\", c.ProfilesFile).Run()\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported platform\")\n\t}\n\n\treturn err\n}\n\n// PrintConfig outputs the contents of the configuration file.\nfunc (c *Config) PrintConfig() error {\n\tif c.Profile.ProfileName == \"default\" {\n\t\tconfigFile, err := ioutil.ReadFile(c.ProfilesFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Print(string(configFile))\n\t} else {\n\t\tconfigs := viper.GetStringMapString(c.Profile.ProfileName)\n\n\t\tif len(configs) > 0 {\n\t\t\tfmt.Printf(\"[%s]\\n\", c.Profile.ProfileName)\n\t\t\tfor field, value := range configs {\n\t\t\t\tfmt.Printf(\"  %s=%s\\n\", field, value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// RemoveProfile removes the profile whose name matches the provided\n// profileName from the config file.\nfunc (c *Config) RemoveProfile(profileName string) error {\n\truntimeViper := viper.GetViper()\n\tvar err error\n\n\tfor field, value := range runtimeViper.AllSettings() {\n\t\tif isProfile(value) && field == profileName {\n\t\t\truntimeViper, err = removeKey(runtimeViper, field)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn syncConfig(runtimeViper)\n}\n\n// RemoveAllProfiles removes all the profiles from the config file.\nfunc (c *Config) RemoveAllProfiles() error {\n\truntimeViper := viper.GetViper()\n\tvar err error\n\n\tfor field, value := range runtimeViper.AllSettings() {\n\t\tif isProfile(value) {\n\t\t\truntimeViper, err = removeKey(runtimeViper, field)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn syncConfig(runtimeViper)\n}\n\n// isProfile identifies whether a value in the config pertains to a profile.\nfunc isProfile(value interface{}) bool {\n\t// TODO: ianjabour - ideally find a better way to identify projects in config\n\t_, ok := value.(map[string]interface{})\n\treturn ok\n}\n\n// syncConfig merges a runtimeViper instance with the config file being used.\nfunc syncConfig(runtimeViper *viper.Viper) error {\n\truntimeViper.MergeInConfig()\n\tprofilesFile := viper.ConfigFileUsed()\n\truntimeViper.SetConfigFile(profilesFile)\n\t// Ensure we preserve the config file type\n\truntimeViper.SetConfigType(filepath.Ext(profilesFile))\n\n\terr := runtimeViper.WriteConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Temporary workaround until https://github.com/spf13/viper/pull/519 can remove a key from viper\nfunc removeKey(v *viper.Viper, key string) (*viper.Viper, error) {\n\tconfigMap := v.AllSettings()\n\tpath := strings.Split(key, \".\")\n\tlastKey := strings.ToLower(path[len(path)-1])\n\tdeepestMap := deepSearch(configMap, path[0:len(path)-1])\n\tdelete(deepestMap, lastKey)\n\n\tbuf := new(bytes.Buffer)\n\n\tencodeErr := toml.NewEncoder(buf).Encode(configMap)\n\tif encodeErr != nil {\n\t\treturn nil, encodeErr\n\t}\n\n\tnv := viper.New()\n\tnv.SetConfigType(\"toml\") // hint to viper that we've encoded the data as toml\n\n\terr := nv.ReadConfig(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nv, nil\n}\n\nfunc makePath(path string) error {\n\tdir := filepath.Dir(path)\n\n\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(dir, os.ModePerm)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// taken from https://github.com/spf13/viper/blob/master/util.go#L199,\n// we need this to delete configs, remove when viper supprts unset natively\nfunc deepSearch(m map[string]interface{}, path []string) map[string]interface{} {\n\tfor _, k := range path {\n\t\tm2, ok := m[k]\n\t\tif !ok {\n\t\t\t// intermediate key does not exist\n\t\t\t// => create it and continue from there\n\t\t\tm3 := make(map[string]interface{})\n\t\t\tm[k] = m3\n\t\t\tm = m3\n\n\t\t\tcontinue\n\t\t}\n\n\t\tm3, ok := m2.(map[string]interface{})\n\t\tif !ok {\n\t\t\t// intermediate key is a value\n\t\t\t// => replace with a new map\n\t\t\tm3 = make(map[string]interface{})\n\t\t\tm[k] = m3\n\t\t}\n\n\t\t// continue search from here\n\t\tm = m3\n\t}\n\n\treturn m\n}\n", "package open\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\n\texec \"golang.org/x/sys/execabs\"\n)\n\nvar execCommand = exec.Command\n\n// Browser takes a url and opens it using the default browser on the operating system\nfunc Browser(url string) error {\n\tvar err error\n\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\terr = execCommand(\"xdg-open\", url).Start()\n\tcase \"windows\":\n\t\terr = execCommand(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n\tcase \"darwin\":\n\t\terr = execCommand(\"open\", url).Start()\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported platform\")\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CanOpenBrowser determines if no browser is set in linux\nfunc CanOpenBrowser() bool {\n\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"darwin\" {\n\t\treturn true\n\t}\n\n\toutput, err := execCommand(\"xdg-settings\", \"get\", \"default-web-browser\").Output()\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif string(output) == \"\" {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"], "filenames": ["pkg/config/config.go", "pkg/open/open.go"], "buggy_code_start_loc": [8, 5], "buggy_code_end_loc": [12, 6], "fixing_code_start_loc": [7, 4], "fixing_code_end_loc": [14, 8], "type": "NVD-CWE-noinfo", "message": "Stripe CLI is a command-line tool for the Stripe eCommerce platform. A vulnerability in Stripe CLI exists on Windows when certain commands are run in a directory where an attacker has planted files. The commands are `stripe login`, `stripe config -e`, `stripe community`, and `stripe open`. MacOS and Linux are unaffected. An attacker who successfully exploits the vulnerability can run arbitrary code in the context of the current user. The update addresses the vulnerability by throwing an error in these situations before the code can run.Users are advised to upgrade to version 1.7.13. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-24753", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-09T23:15:08.440", "lastModified": "2022-03-12T02:51:41.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stripe CLI is a command-line tool for the Stripe eCommerce platform. A vulnerability in Stripe CLI exists on Windows when certain commands are run in a directory where an attacker has planted files. The commands are `stripe login`, `stripe config -e`, `stripe community`, and `stripe open`. MacOS and Linux are unaffected. An attacker who successfully exploits the vulnerability can run arbitrary code in the context of the current user. The update addresses the vulnerability by throwing an error in these situations before the code can run.Users are advised to upgrade to version 1.7.13. There are no known workarounds for this issue."}, {"lang": "es", "value": "Stripe CLI es una herramienta de l\u00ednea de comandos para la plataforma de comercio electr\u00f3nico Stripe. Se presenta una vulnerabilidad en Stripe CLI en Windows cuando determinados comandos se ejecutan en un directorio donde un atacante ha plantado archivos. Los comandos son \"stripe login\", \"stripe config -e\", \"stripe community\" y \"stripe open\". MacOS y Linux no est\u00e1n afectados. Un atacante que explote con \u00e9xito la vulnerabilidad puede ejecutar c\u00f3digo arbitrario en el contexto del usuario actual. La actualizaci\u00f3n aborda la vulnerabilidad al lanzar un error en estas situaciones antes de que el c\u00f3digo pueda ejecutarse. Es recomendado a usuarios actualizar a versi\u00f3n 1.7.13. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stripe:stripe_cli:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.13", "matchCriteriaId": "16C71D5D-D3AA-4C52-86ED-9EF9A5DE2213"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/stripe/stripe-cli/commit/be38da5c0191adb77f661f769ffff2fbc7ddf6cd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/stripe/stripe-cli/security/advisories/GHSA-4cx6-fj7j-pjx9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stripe/stripe-cli/commit/be38da5c0191adb77f661f769ffff2fbc7ddf6cd"}}