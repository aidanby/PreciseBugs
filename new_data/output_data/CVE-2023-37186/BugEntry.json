{"buggy_code": ["/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n/*********************************************************************\n  This codec is meant to leverage multidimensionality for getting\n  better compression ratios.  The idea is to look for similarities\n  in places that are closer in a euclidean metric, not the typical\n  linear one.\n**********************************************************************/\n\n#include \"ndlz4x4.h\"\n#include \"ndlz.h\"\n#include \"xxhash.h\"\n#include \"../plugins/plugin_utils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Give hints to the compiler for branch prediction optimization.\n */\n#if defined(__GNUC__) && (__GNUC__ > 2)\n#define NDLZ_EXPECT_CONDITIONAL(c)    (__builtin_expect((c), 1))\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (__builtin_expect((c), 0))\n#else\n#define NDLZ_EXPECT_CONDITIONAL(c)    (c)\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (c)\n#endif\n\n/*\n * Use inlined functions for supported systems.\n */\n#if defined(_MSC_VER) && !defined(__cplusplus)   /* Visual Studio */\n#define inline __inline  /* Visual C is not C99, but supports some kind of inline */\n#endif\n\n#define MAX_COPY 32U\n#define MAX_DISTANCE 65535\n\n\n#ifdef BLOSC_STRICT_ALIGN\n#define NDLZ_READU16(p) ((p)[0] | (p)[1]<<8)\n#define NDLZ_READU32(p) ((p)[0] | (p)[1]<<8 | (p)[2]<<16 | (p)[3]<<24)\n#else\n#define NDLZ_READU16(p) *((const uint16_t*)(p))\n#define NDLZ_READU32(p) *((const uint32_t*)(p))\n#endif\n\n#define HASH_LOG (12)\n\n\nint ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                   uint8_t meta, blosc2_cparams *cparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  uint8_t *smeta;\n  int32_t smeta_len;\n\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (input_len != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {\n    BLOSC_TRACE_ERROR(\"Output too small\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t *op_limit;\n  uint32_t hval, hash_cell;\n  uint32_t hash_triple[2] = {0};\n  uint32_t hash_pair[3] = {0};\n  uint8_t bufarea[16];\n  uint8_t *buf_cell = bufarea;\n  uint8_t buf_triple[12];\n  uint8_t buf_pair[8];\n  uint8_t *buf_aux;\n  uint32_t tab_cell[1U << 12U] = {0};\n  uint32_t tab_triple[1U << 12U] = {0};\n  uint32_t tab_pair[1U << 12U] = {0};\n  uint32_t update_triple[2] = {0};\n  uint32_t update_pair[3] = {0};\n\n  // Minimum cratios before issuing and _early giveup_\n  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)\n\n  op_limit = op + output_len;\n\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << 12U); i++) {\n    tab_cell[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;\n  if (input_len < 16 || output_len < overhead) {\n    BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");\n    return 0;\n  }\n\n  uint8_t *obase = op;\n\n  /* we start with literal copy */\n  *op++ = ndim;\n  memcpy(op, &blockshape[0], 4);\n  op += 4;\n  memcpy(op, &blockshape[1], 4);\n  op += 4;\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = (blockshape[i] + 3) / 4;\n  }\n\n  /* main loop */\n  uint32_t padding[2];\n  uint32_t ii[2];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      uint8_t token;\n      for (int h = 0; h < 2; h++) {         // new cell -> new possible references\n        update_triple[h] = 0;\n        update_pair[h] = 0;\n      }\n      update_pair[2] = 0;\n\n      if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||\n          ((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {\n        token = 0;                                   // padding -> literal copy\n        *op++ = token;\n        if (ii[0] == i_stop[0] - 1) {\n          padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n        } else {\n          padding[0] = 4;\n        }\n        if (ii[1] == i_stop[1] - 1) {\n          padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n        } else {\n          padding[1] = 4;\n        }\n        for (uint32_t i = 0; i < padding[0]; i++) {\n          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);\n          op += padding[1];\n        }\n      } else {\n        for (uint64_t i = 0; i < 4; i++) {           // fill cell buffer\n          uint64_t ind = orig + i * blockshape[1];\n          memcpy(buf_cell, &ip[ind], 4);\n          buf_cell += 4;\n        }\n        buf_cell -= 16;\n\n        const uint8_t *ref;\n        uint32_t distance;\n        uint8_t *anchor = op;    /* comparison starting-point */\n\n        /* find potential match */\n        hash_cell = XXH32(buf_cell, 16, 1);        // calculate cell hash\n        hash_cell >>= 32U - 12U;\n        ref = obase + tab_cell[hash_cell];\n\n        /* calculate distance to the match */\n        if (tab_cell[hash_cell] == 0) {\n          distance = 0;\n        } else {\n          bool same = true;\n          buf_aux = obase + tab_cell[hash_cell];\n          for (int i = 0; i < 16; i++) {\n            if (buf_cell[i] != buf_aux[i]) {\n              same = false;\n              break;\n            }\n          }\n          if (same) {\n            distance = (int32_t) (anchor - ref);\n          } else {\n            distance = 0;\n          }\n        }\n\n        bool alleq = true;\n        for (int i = 1; i < 16; i++) {\n          if (buf_cell[i] != buf_cell[0]) {\n            alleq = false;\n            break;\n          }\n        }\n        if (alleq) {                              // all elements of the cell equal\n          token = (uint8_t) (1U << 6U);\n          *op++ = token;\n          *op++ = buf_cell[0];\n\n        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match\n          bool literal = true;\n\n          // 2 rows pairs matches\n          for (int j = 1; j < 4; j++) {\n            memcpy(buf_pair, buf_cell, 4);\n            memcpy(&buf_pair[4], &buf_cell[j * 4], 4);\n            hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n            hval >>= 32U - 12U;\n            ref = obase + tab_pair[hval];\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_pair[hval] != 0) {\n              buf_aux = obase + tab_pair[hval];\n              for (int k = 0; k < 8; k++) {\n                if (buf_pair[k] != buf_aux[k]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n            } else {\n              same = false;\n            }\n            if (same) {\n              distance = (int32_t) (anchor - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */\n              int k, m, l = -1;\n              for (k = 1; k < 4; k++) {\n                if (k != j) {\n                  if (l == -1) {\n                    l = k;\n                  } else {\n                    m = k;\n                  }\n                }\n              }\n              memcpy(buf_pair, &buf_cell[l * 4], 4);\n              memcpy(&buf_pair[4], &buf_cell[m * 4], 4);\n              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n              hval >>= 32U - 12U;\n              ref = obase + tab_pair[hval];\n              same = true;\n              if (tab_pair[hval] != 0) {\n                buf_aux = obase + tab_pair[hval];\n                for (k = 0; k < 8; k++) {\n                  if (buf_pair[k] != buf_aux[k]) {\n                    same = false;\n                    break;\n                  }\n                }\n              } else {\n                same = false;\n              }\n              if (same) {\n                distance = (int32_t) (anchor + l * 4 - ref);\n              } else {\n                distance = 0;\n              }\n              if ((distance != 0) && (distance < MAX_DISTANCE)) {   /* 2 pair matches */\n                literal = false;\n                token = (uint8_t) ((1U << 5U) | (j << 3U));\n                *op++ = token;\n                uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);\n                *(uint16_t *) op = offset;\n                op += sizeof(offset);\n                *(uint16_t *) op = offset_2;\n                op += sizeof(offset_2);\n                goto match;\n              }\n            }\n          }\n\n          // rows triples\n          for (int i = 0; i < 2; i++) {\n            memcpy(buf_triple, &buf_cell[i * 4], 4);\n            for (int j = i + 1; j < 3; j++) {\n              memcpy(&buf_triple[4], &buf_cell[j * 4], 4);\n              for (int k = j + 1; k < 4; k++) {\n                memcpy(&buf_triple[8], &buf_cell[k * 4], 4);\n                hval = XXH32(buf_triple, 12, 1);        // calculate triple hash\n                hval >>= 32U - 12U;\n                /* calculate distance to the match */\n                bool same = true;\n                uint16_t offset;\n                if (tab_triple[hval] != 0) {\n                  buf_aux = obase + tab_triple[hval];\n                  for (int l = 0; l < 12; l++) {\n                    if (buf_triple[l] != buf_aux[l]) {\n                      same = false;\n                      break;\n                    }\n                  }\n                  offset = (uint16_t) (anchor - obase - tab_triple[hval]);\n                } else {\n                  same = false;\n                  if ((j - i == 1) && (k - j == 1)) {\n                    update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */\n                    hash_triple[i] = hval;\n                  }\n                }\n                ref = obase + tab_triple[hval];\n\n                if (same) {\n                  distance = (int32_t) (anchor + i * 4 - ref);\n                } else {\n                  distance = 0;\n                }\n                if ((distance != 0) && (distance < MAX_DISTANCE)) {\n                  literal = false;\n                  if (i == 1) {\n                    token = (uint8_t) (7U << 5U);\n                  } else {\n                    token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));\n                  }\n                  *op++ = token;\n                  memcpy(op, &offset, 2);\n                  op += 2;\n                  for (int l = 0; l < 4; l++) {\n                    if ((l != i) && (l != j) && (l != k)) {\n                      memcpy(op, &buf_cell[4 * l], 4);\n                      op += 4;\n                      goto match;\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          // rows pairs\n          for (int i = 0; i < 3; i++) {\n            memcpy(buf_pair, &buf_cell[i * 4], 4);\n            for (int j = i + 1; j < 4; j++) {\n              memcpy(&buf_pair[4], &buf_cell[j * 4], 4);\n              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n              hval >>= 32U - 12U;\n              ref = obase + tab_pair[hval];\n              /* calculate distance to the match */\n              bool same = true;\n              uint16_t offset;\n              if (tab_pair[hval] != 0) {\n                buf_aux = obase + tab_pair[hval];\n                for (int k = 0; k < 8; k++) {\n                  if (buf_pair[k] != buf_aux[k]) {\n                    same = false;\n                    break;\n                  }\n                }\n                offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n              } else {\n                same = false;\n                if (j - i == 1) {\n                  update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */\n                  hash_pair[i] = hval;\n                }\n              }\n              if (same) {\n                distance = (int32_t) (anchor + i * 4 - ref);\n              } else {\n                distance = 0;\n              }\n              if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */\n                literal = false;\n                if (i == 2) {\n                  token = (uint8_t) (1U << 7U);\n                } else {\n                  token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));\n                }\n                *op++ = token;\n                memcpy(op, &offset, 2);\n                op += 2;\n                for (int k = 0; k < 4; k++) {\n                  if ((k != i) && (k != j)) {\n                    memcpy(op, &buf_cell[4 * k], 4);\n                    op += 4;\n                  }\n                }\n                goto match;\n              }\n            }\n          }\n\n          match:\n          if (literal) {\n            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */\n            if (update_triple[0] != 0) {\n              for (int h = 0; h < 2; h++) {\n                tab_triple[hash_triple[h]] = update_triple[h];\n              }\n            }\n            if (update_pair[0] != 0) {\n              for (int h = 0; h < 3; h++) {\n                tab_pair[hash_pair[h]] = update_pair[h];\n              }\n            }\n            token = 0;\n            *op++ = token;\n            memcpy(op, buf_cell, 16);\n            op += 16;\n          }\n\n        } else {   // cell match\n          token = (uint8_t) ((1U << 7U) | (1U << 6U));\n          *op++ = token;\n          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);\n          memcpy(op, &offset, 2);\n          op += 2;\n        }\n\n      }\n      if ((op - obase) > input_len) {\n        BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");\n        return 0;\n      }\n    }\n  }\n\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  return (int) (op - obase);\n}\n\n\n// See https://habr.com/en/company/yandex/blog/457612/\n#ifdef __AVX2__\n\n#if defined(_MSC_VER)\n#define ALIGNED_(x) __declspec(align(x))\n#else\n#if defined(__GNUC__)\n#define ALIGNED_(x) __attribute__ ((aligned(x)))\n#endif\n#endif\n#define ALIGNED_TYPE_(t, x) t ALIGNED_(x)\n\nstatic unsigned char* copy_match_16(unsigned char *op, const unsigned char *match, int32_t len)\n{\n  size_t offset = op - match;\n  while (len >= 16) {\n\n    static const ALIGNED_TYPE_(uint8_t, 16) masks[] =\n      {\n                0,  1,  2,  1,  4,  1,  4,  2,  8,  7,  6,  5,  4,  3,  2,  1, // offset = 0, not used as mask, but for shift\n                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // offset = 1\n                0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,\n                0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,\n                0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,\n                0,  1,  2,  3,  4,  5,  0,  1,  2,  3,  4,  5,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  0,  1,  2,  3,  4,  5,  6,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  0,  1,  2,  3,  4,  5,  6,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,  2,  3,  4,  5,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  1,  2,  3,  4,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  1,  2,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  0,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  15, // offset = 16\n      };\n\n    _mm_storeu_si128((__m128i *)(op),\n                     _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(match)),\n                                      _mm_load_si128((const __m128i *)(masks) + offset)));\n\n    match += masks[offset];\n\n    op += 16;\n    len -= 16;\n  }\n  // Deal with remainders\n  for (; len > 0; len--) {\n    *op++ = *match++;\n  }\n  return op;\n}\n#endif\n\n\nint ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}\n", "/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n/*********************************************************************\n  This codec is meant to leverage multidimensionality for getting\n  better compression ratios.  The idea is to look for similarities\n  in places that are closer in a euclidean metric, not the typical\n  linear one.\n**********************************************************************/\n\n#include \"ndlz8x8.h\"\n#include \"ndlz.h\"\n#include \"xxhash.h\"\n#include \"../plugins/plugin_utils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Give hints to the compiler for branch prediction optimization.\n */\n#if defined(__GNUC__) && (__GNUC__ > 2)\n#define NDLZ_EXPECT_CONDITIONAL(c)    (__builtin_expect((c), 1))\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (__builtin_expect((c), 0))\n#else\n#define NDLZ_EXPECT_CONDITIONAL(c)    (c)\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (c)\n#endif\n\n/*\n * Use inlined functions for supported systems.\n */\n#if defined(_MSC_VER) && !defined(__cplusplus)   /* Visual Studio */\n#define inline __inline  /* Visual C is not C99, but supports some kind of inline */\n#endif\n\n#define MAX_COPY 32U\n#define MAX_DISTANCE 65535\n\n\n#ifdef BLOSC_STRICT_ALIGN\n#define NDLZ_READU16(p) ((p)[0] | (p)[1]<<8)\n#define NDLZ_READU32(p) ((p)[0] | (p)[1]<<8 | (p)[2]<<16 | (p)[3]<<24)\n#else\n#define NDLZ_READU16(p) *((const uint16_t*)(p))\n#define NDLZ_READU32(p) *((const uint32_t*)(p))\n#endif\n\n#define HASH_LOG (12)\n\n\nint ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                   uint8_t meta, blosc2_cparams *cparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  uint8_t *smeta;\n  int32_t smeta_len;\n\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (input_len != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {\n    BLOSC_TRACE_ERROR(\"Output too small\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t *op_limit;\n  uint32_t hval, hash_cell;\n  uint32_t hash_triple[6] = {0};\n  uint32_t hash_pair[7] = {0};\n  uint8_t *bufarea = malloc(cell_size);\n  uint8_t *buf_cell = bufarea;\n  uint8_t *buf_aux;\n  uint32_t tab_cell[1U << 12U] = {0};\n  uint32_t tab_triple[1U << 12U] = {0};\n  uint32_t tab_pair[1U << 12U] = {0};\n  uint32_t update_triple[6] = {0};\n  uint32_t update_pair[7] = {0};\n\n  // Minimum cratios before issuing and _early giveup_\n  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)\n\n  op_limit = op + output_len;\n\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << 12U); i++) {\n    tab_cell[i] = 0;\n    tab_triple[i] = 0;\n    tab_pair[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 64 (cells are 8x8) */\n  int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;\n  if (input_len < cell_size || output_len < overhead) {\n    BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");\n    return 0;\n  }\n\n  uint8_t *obase = op;\n\n  /* we start with literal copy */\n  *op++ = ndim;\n  memcpy(op, &blockshape[0], 4);\n  op += 4;\n  memcpy(op, &blockshape[1], 4);\n  op += 4;\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t padding[2];\n  uint32_t ii[2];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      for (int h = 0; h < 7; h++) {         // new cell -> new possible references\n        update_pair[h] = 0;\n        if (h != 6) {\n          update_triple[h] = 0;\n        }\n      }\n\n      if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        free(bufarea);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||\n          ((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {\n        uint8_t token = 0;                                   // padding -> literal copy\n        *op++ = token;\n        if (ii[0] == i_stop[0] - 1) {\n          padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n        } else {\n          padding[0] = cell_shape;\n        }\n        if (ii[1] == i_stop[1] - 1) {\n          padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n        } else {\n          padding[1] = cell_shape;\n        }\n        for (uint32_t i = 0; i < padding[0]; i++) {\n          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);\n          op += padding[1];\n        }\n      } else {\n        for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {           // fill cell buffer\n          uint64_t ind = orig + i * blockshape[1];\n          memcpy(buf_cell, &ip[ind], cell_shape);\n          buf_cell += cell_shape;\n        }\n        buf_cell -= cell_size;\n\n        const uint8_t *ref;\n        uint32_t distance;\n        uint8_t *anchor = op;    /* comparison starting-point */\n\n        /* find potential match */\n        hash_cell = XXH32(buf_cell, cell_size, 1);        // calculate cell hash\n        hash_cell >>= 32U - 12U;\n        ref = obase + tab_cell[hash_cell];\n\n        /* calculate distance to the match */\n        if (tab_cell[hash_cell] == 0) {\n          distance = 0;\n        } else {\n          bool same = true;\n          buf_aux = obase + tab_cell[hash_cell];\n          for (int i = 0; i < cell_size; i++) {\n            if (buf_cell[i] != buf_aux[i]) {\n              same = false;\n              break;\n            }\n          }\n          if (same) {\n            distance = (int32_t) (anchor - ref);\n          } else {\n            distance = 0;\n          }\n        }\n\n        bool alleq = true;\n        for (int i = 1; i < cell_size; i++) {\n          if (buf_cell[i] != buf_cell[0]) {\n            alleq = false;\n            break;\n          }\n        }\n        if (alleq) {                              // all elements of the cell equal\n          uint8_t token = (uint8_t) (1U << 6U);\n          *op++ = token;\n          *op++ = buf_cell[0];\n\n        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match\n          bool literal = true;\n\n          // rows triples matches\n          for (int i = 0; i < 6; i++) {\n            int triple_start = i * cell_shape;\n            hval = XXH32(&buf_cell[triple_start], 24, 1);        // calculate triple hash\n            hval >>= 32U - 12U;\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_triple[hval] != 0) {\n              buf_aux = obase + tab_triple[hval];\n              for (int l = 0; l < 24; l++) {\n                if (buf_cell[triple_start + l] != buf_aux[l]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_triple[hval]);\n            } else {\n              same = false;\n              update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     /* update hash table */\n              hash_triple[i] = hval;\n            }\n            ref = obase + tab_triple[hval];\n            if (same) {\n              distance = (int32_t) (anchor + triple_start - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     // 3 rows match\n              literal = false;\n              uint8_t token = (uint8_t) ((21 << 3U) | i);\n              *op++ = token;\n              memcpy(op, &offset, 2);\n              op += 2;\n              for (int l = 0; l < 8; l++) {\n                if ((l < i) || (l > i + 2)) {\n                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);\n                  op += cell_shape;\n                }\n              }\n              goto match;\n            }\n          }\n\n          // rows pairs matches\n          for (int i = 0; i < 7; i++) {\n            int pair_start = i * cell_shape;\n            hval = XXH32(&buf_cell[pair_start], 16, 1);        // calculate rows pair hash\n            hval >>= 32U - 12U;\n            ref = obase + tab_pair[hval];\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_pair[hval] != 0) {\n              buf_aux = obase + tab_pair[hval];\n              for (int k = 0; k < 16; k++) {\n                if (buf_cell[pair_start + k] != buf_aux[k]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n            } else {\n              same = false;\n              update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     /* update hash table */\n              hash_pair[i] = hval;\n            }\n            if (same) {\n              distance = (int32_t) (anchor + pair_start - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* 1 rows pair match */\n              literal = false;\n              uint8_t token = (uint8_t) ((17 << 3U) | i);\n              *op++ = token;\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n              memcpy(op, &offset, 2);\n              op += 2;\n              for (int l = 0; l < 8; l++) {\n                if ((l < i) || (l > i + 1)) {\n                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);\n                  op += cell_shape;\n                }\n              }\n              goto match;\n            }\n          }\n\n          match:\n          if (literal) {\n            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */\n\n            if (update_triple[0] != 0) {\n              for (int h = 0; h < 6; h++) {\n                tab_triple[hash_triple[h]] = update_triple[h];\n              }\n            }\n            if (update_pair[0] != 0) {\n              for (int h = 0; h < 7; h++) {\n                tab_pair[hash_pair[h]] = update_pair[h];\n              }\n            }\n            uint8_t token = 0;\n            *op++ = token;\n            memcpy(op, buf_cell, cell_size);\n            op += cell_size;\n\n          }\n\n        } else {   // cell match\n          uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));\n          *op++ = token;\n          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);\n          memcpy(op, &offset, 2);\n          op += 2;\n\n        }\n\n      }\n      if ((op - obase) > input_len) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        free(bufarea);\n        BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");\n        return 0;\n      }\n    }\n  }\n\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n  free(bufarea);\n\n  return (int) (op - obase);\n}\n\n\n// See https://habr.com/en/company/yandex/blog/457612/\n#ifdef __AVX2__\n\n#if defined(_MSC_VER)\n#define ALIGNED_(x) __declspec(align(x))\n#else\n#if defined(__GNUC__)\n#define ALIGNED_(x) __attribute__ ((aligned(x)))\n#endif\n#endif\n#define ALIGNED_TYPE_(t, x) t ALIGNED_(x)\n\nstatic unsigned char* copy_match_16(unsigned char *op, const unsigned char *match, int32_t len)\n{\n  size_t offset = op - match;\n  while (len >= 16) {\n\n    static const ALIGNED_TYPE_(uint8_t, 16) masks[] =\n      {\n                0,  1,  2,  1,  4,  1,  4,  2,  8,  7,  6,  5,  4,  3,  2,  1, // offset = 0, not used as mask, but for shift\n                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // offset = 1\n                0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,\n                0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,\n                0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,\n                0,  1,  2,  3,  4,  5,  0,  1,  2,  3,  4,  5,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  0,  1,  2,  3,  4,  5,  6,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  0,  1,  2,  3,  4,  5,  6,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,  2,  3,  4,  5,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  1,  2,  3,  4,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  1,  2,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  0,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  15, // offset = 16\n      };\n\n    _mm_storeu_si128((__m128i *)(op),\n                     _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(match)),\n                                      _mm_load_si128((const __m128i *)(masks) + offset)));\n\n    match += masks[offset];\n\n    op += 16;\n    len -= 16;\n  }\n  // Deal with remainders\n  for (; len > 0; len--) {\n    *op++ = *match++;\n  }\n  return op;\n}\n#endif\n\n\nint ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}\n"], "fixing_code": ["/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n/*********************************************************************\n  This codec is meant to leverage multidimensionality for getting\n  better compression ratios.  The idea is to look for similarities\n  in places that are closer in a euclidean metric, not the typical\n  linear one.\n**********************************************************************/\n\n#include \"ndlz4x4.h\"\n#include \"ndlz.h\"\n#include \"xxhash.h\"\n#include \"../plugins/plugin_utils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Give hints to the compiler for branch prediction optimization.\n */\n#if defined(__GNUC__) && (__GNUC__ > 2)\n#define NDLZ_EXPECT_CONDITIONAL(c)    (__builtin_expect((c), 1))\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (__builtin_expect((c), 0))\n#else\n#define NDLZ_EXPECT_CONDITIONAL(c)    (c)\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (c)\n#endif\n\n/*\n * Use inlined functions for supported systems.\n */\n#if defined(_MSC_VER) && !defined(__cplusplus)   /* Visual Studio */\n#define inline __inline  /* Visual C is not C99, but supports some kind of inline */\n#endif\n\n#define MAX_COPY 32U\n#define MAX_DISTANCE 65535\n\n\n#ifdef BLOSC_STRICT_ALIGN\n#define NDLZ_READU16(p) ((p)[0] | (p)[1]<<8)\n#define NDLZ_READU32(p) ((p)[0] | (p)[1]<<8 | (p)[2]<<16 | (p)[3]<<24)\n#else\n#define NDLZ_READU16(p) *((const uint16_t*)(p))\n#define NDLZ_READU32(p) *((const uint32_t*)(p))\n#endif\n\n#define HASH_LOG (12)\n\n\nint ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                   uint8_t meta, blosc2_cparams *cparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n  uint8_t *smeta;\n  int32_t smeta_len;\n\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (input_len != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {\n    BLOSC_TRACE_ERROR(\"Output too small\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t *op_limit;\n  uint32_t hval, hash_cell;\n  uint32_t hash_triple[2] = {0};\n  uint32_t hash_pair[3] = {0};\n  uint8_t bufarea[16];\n  uint8_t *buf_cell = bufarea;\n  uint8_t buf_triple[12];\n  uint8_t buf_pair[8];\n  uint8_t *buf_aux;\n  uint32_t tab_cell[1U << 12U] = {0};\n  uint32_t tab_triple[1U << 12U] = {0};\n  uint32_t tab_pair[1U << 12U] = {0};\n  uint32_t update_triple[2] = {0};\n  uint32_t update_pair[3] = {0};\n\n  // Minimum cratios before issuing and _early giveup_\n  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)\n\n  op_limit = op + output_len;\n\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << 12U); i++) {\n    tab_cell[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;\n  if (input_len < 16 || output_len < overhead) {\n    BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");\n    return 0;\n  }\n\n  uint8_t *obase = op;\n\n  /* we start with literal copy */\n  *op++ = ndim;\n  memcpy(op, &blockshape[0], 4);\n  op += 4;\n  memcpy(op, &blockshape[1], 4);\n  op += 4;\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = (blockshape[i] + 3) / 4;\n  }\n\n  /* main loop */\n  uint32_t padding[2];\n  uint32_t ii[2];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      uint8_t token;\n      for (int h = 0; h < 2; h++) {         // new cell -> new possible references\n        update_triple[h] = 0;\n        update_pair[h] = 0;\n      }\n      update_pair[2] = 0;\n\n      if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||\n          ((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {\n        token = 0;                                   // padding -> literal copy\n        *op++ = token;\n        if (ii[0] == i_stop[0] - 1) {\n          padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n        } else {\n          padding[0] = 4;\n        }\n        if (ii[1] == i_stop[1] - 1) {\n          padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n        } else {\n          padding[1] = 4;\n        }\n        for (uint32_t i = 0; i < padding[0]; i++) {\n          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);\n          op += padding[1];\n        }\n      } else {\n        for (uint64_t i = 0; i < 4; i++) {           // fill cell buffer\n          uint64_t ind = orig + i * blockshape[1];\n          memcpy(buf_cell, &ip[ind], 4);\n          buf_cell += 4;\n        }\n        buf_cell -= 16;\n\n        const uint8_t *ref;\n        uint32_t distance;\n        uint8_t *anchor = op;    /* comparison starting-point */\n\n        /* find potential match */\n        hash_cell = XXH32(buf_cell, 16, 1);        // calculate cell hash\n        hash_cell >>= 32U - 12U;\n        ref = obase + tab_cell[hash_cell];\n\n        /* calculate distance to the match */\n        if (tab_cell[hash_cell] == 0) {\n          distance = 0;\n        } else {\n          bool same = true;\n          buf_aux = obase + tab_cell[hash_cell];\n          for (int i = 0; i < 16; i++) {\n            if (buf_cell[i] != buf_aux[i]) {\n              same = false;\n              break;\n            }\n          }\n          if (same) {\n            distance = (int32_t) (anchor - ref);\n          } else {\n            distance = 0;\n          }\n        }\n\n        bool alleq = true;\n        for (int i = 1; i < 16; i++) {\n          if (buf_cell[i] != buf_cell[0]) {\n            alleq = false;\n            break;\n          }\n        }\n        if (alleq) {                              // all elements of the cell equal\n          token = (uint8_t) (1U << 6U);\n          *op++ = token;\n          *op++ = buf_cell[0];\n\n        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match\n          bool literal = true;\n\n          // 2 rows pairs matches\n          for (int j = 1; j < 4; j++) {\n            memcpy(buf_pair, buf_cell, 4);\n            memcpy(&buf_pair[4], &buf_cell[j * 4], 4);\n            hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n            hval >>= 32U - 12U;\n            ref = obase + tab_pair[hval];\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_pair[hval] != 0) {\n              buf_aux = obase + tab_pair[hval];\n              for (int k = 0; k < 8; k++) {\n                if (buf_pair[k] != buf_aux[k]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n            } else {\n              same = false;\n            }\n            if (same) {\n              distance = (int32_t) (anchor - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */\n              int k, m, l = -1;\n              for (k = 1; k < 4; k++) {\n                if (k != j) {\n                  if (l == -1) {\n                    l = k;\n                  } else {\n                    m = k;\n                  }\n                }\n              }\n              memcpy(buf_pair, &buf_cell[l * 4], 4);\n              memcpy(&buf_pair[4], &buf_cell[m * 4], 4);\n              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n              hval >>= 32U - 12U;\n              ref = obase + tab_pair[hval];\n              same = true;\n              if (tab_pair[hval] != 0) {\n                buf_aux = obase + tab_pair[hval];\n                for (k = 0; k < 8; k++) {\n                  if (buf_pair[k] != buf_aux[k]) {\n                    same = false;\n                    break;\n                  }\n                }\n              } else {\n                same = false;\n              }\n              if (same) {\n                distance = (int32_t) (anchor + l * 4 - ref);\n              } else {\n                distance = 0;\n              }\n              if ((distance != 0) && (distance < MAX_DISTANCE)) {   /* 2 pair matches */\n                literal = false;\n                token = (uint8_t) ((1U << 5U) | (j << 3U));\n                *op++ = token;\n                uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);\n                *(uint16_t *) op = offset;\n                op += sizeof(offset);\n                *(uint16_t *) op = offset_2;\n                op += sizeof(offset_2);\n                goto match;\n              }\n            }\n          }\n\n          // rows triples\n          for (int i = 0; i < 2; i++) {\n            memcpy(buf_triple, &buf_cell[i * 4], 4);\n            for (int j = i + 1; j < 3; j++) {\n              memcpy(&buf_triple[4], &buf_cell[j * 4], 4);\n              for (int k = j + 1; k < 4; k++) {\n                memcpy(&buf_triple[8], &buf_cell[k * 4], 4);\n                hval = XXH32(buf_triple, 12, 1);        // calculate triple hash\n                hval >>= 32U - 12U;\n                /* calculate distance to the match */\n                bool same = true;\n                uint16_t offset;\n                if (tab_triple[hval] != 0) {\n                  buf_aux = obase + tab_triple[hval];\n                  for (int l = 0; l < 12; l++) {\n                    if (buf_triple[l] != buf_aux[l]) {\n                      same = false;\n                      break;\n                    }\n                  }\n                  offset = (uint16_t) (anchor - obase - tab_triple[hval]);\n                } else {\n                  same = false;\n                  if ((j - i == 1) && (k - j == 1)) {\n                    update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */\n                    hash_triple[i] = hval;\n                  }\n                }\n                ref = obase + tab_triple[hval];\n\n                if (same) {\n                  distance = (int32_t) (anchor + i * 4 - ref);\n                } else {\n                  distance = 0;\n                }\n                if ((distance != 0) && (distance < MAX_DISTANCE)) {\n                  literal = false;\n                  if (i == 1) {\n                    token = (uint8_t) (7U << 5U);\n                  } else {\n                    token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));\n                  }\n                  *op++ = token;\n                  memcpy(op, &offset, 2);\n                  op += 2;\n                  for (int l = 0; l < 4; l++) {\n                    if ((l != i) && (l != j) && (l != k)) {\n                      memcpy(op, &buf_cell[4 * l], 4);\n                      op += 4;\n                      goto match;\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          // rows pairs\n          for (int i = 0; i < 3; i++) {\n            memcpy(buf_pair, &buf_cell[i * 4], 4);\n            for (int j = i + 1; j < 4; j++) {\n              memcpy(&buf_pair[4], &buf_cell[j * 4], 4);\n              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash\n              hval >>= 32U - 12U;\n              ref = obase + tab_pair[hval];\n              /* calculate distance to the match */\n              bool same = true;\n              uint16_t offset;\n              if (tab_pair[hval] != 0) {\n                buf_aux = obase + tab_pair[hval];\n                for (int k = 0; k < 8; k++) {\n                  if (buf_pair[k] != buf_aux[k]) {\n                    same = false;\n                    break;\n                  }\n                }\n                offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n              } else {\n                same = false;\n                if (j - i == 1) {\n                  update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */\n                  hash_pair[i] = hval;\n                }\n              }\n              if (same) {\n                distance = (int32_t) (anchor + i * 4 - ref);\n              } else {\n                distance = 0;\n              }\n              if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */\n                literal = false;\n                if (i == 2) {\n                  token = (uint8_t) (1U << 7U);\n                } else {\n                  token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));\n                }\n                *op++ = token;\n                memcpy(op, &offset, 2);\n                op += 2;\n                for (int k = 0; k < 4; k++) {\n                  if ((k != i) && (k != j)) {\n                    memcpy(op, &buf_cell[4 * k], 4);\n                    op += 4;\n                  }\n                }\n                goto match;\n              }\n            }\n          }\n\n          match:\n          if (literal) {\n            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */\n            if (update_triple[0] != 0) {\n              for (int h = 0; h < 2; h++) {\n                tab_triple[hash_triple[h]] = update_triple[h];\n              }\n            }\n            if (update_pair[0] != 0) {\n              for (int h = 0; h < 3; h++) {\n                tab_pair[hash_pair[h]] = update_pair[h];\n              }\n            }\n            token = 0;\n            *op++ = token;\n            memcpy(op, buf_cell, 16);\n            op += 16;\n          }\n\n        } else {   // cell match\n          token = (uint8_t) ((1U << 7U) | (1U << 6U));\n          *op++ = token;\n          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);\n          memcpy(op, &offset, 2);\n          op += 2;\n        }\n\n      }\n      if ((op - obase) > input_len) {\n        BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");\n        return 0;\n      }\n    }\n  }\n\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  return (int) (op - obase);\n}\n\n\n// See https://habr.com/en/company/yandex/blog/457612/\n#ifdef __AVX2__\n\n#if defined(_MSC_VER)\n#define ALIGNED_(x) __declspec(align(x))\n#else\n#if defined(__GNUC__)\n#define ALIGNED_(x) __attribute__ ((aligned(x)))\n#endif\n#endif\n#define ALIGNED_TYPE_(t, x) t ALIGNED_(x)\n\nstatic unsigned char* copy_match_16(unsigned char *op, const unsigned char *match, int32_t len)\n{\n  size_t offset = op - match;\n  while (len >= 16) {\n\n    static const ALIGNED_TYPE_(uint8_t, 16) masks[] =\n      {\n                0,  1,  2,  1,  4,  1,  4,  2,  8,  7,  6,  5,  4,  3,  2,  1, // offset = 0, not used as mask, but for shift\n                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // offset = 1\n                0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,\n                0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,\n                0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,\n                0,  1,  2,  3,  4,  5,  0,  1,  2,  3,  4,  5,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  0,  1,  2,  3,  4,  5,  6,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  0,  1,  2,  3,  4,  5,  6,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,  2,  3,  4,  5,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  1,  2,  3,  4,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  1,  2,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  0,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  15, // offset = 16\n      };\n\n    _mm_storeu_si128((__m128i *)(op),\n                     _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(match)),\n                                      _mm_load_si128((const __m128i *)(masks) + offset)));\n\n    match += masks[offset];\n\n    op += 16;\n    len -= 16;\n  }\n  // Deal with remainders\n  for (; len > 0; len--) {\n    *op++ = *match++;\n  }\n  return op;\n}\n#endif\n\n\nint ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}\n", "/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n/*********************************************************************\n  This codec is meant to leverage multidimensionality for getting\n  better compression ratios.  The idea is to look for similarities\n  in places that are closer in a euclidean metric, not the typical\n  linear one.\n**********************************************************************/\n\n#include \"ndlz8x8.h\"\n#include \"ndlz.h\"\n#include \"xxhash.h\"\n#include \"../plugins/plugin_utils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Give hints to the compiler for branch prediction optimization.\n */\n#if defined(__GNUC__) && (__GNUC__ > 2)\n#define NDLZ_EXPECT_CONDITIONAL(c)    (__builtin_expect((c), 1))\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (__builtin_expect((c), 0))\n#else\n#define NDLZ_EXPECT_CONDITIONAL(c)    (c)\n#define NDLZ_UNEXPECT_CONDITIONAL(c)  (c)\n#endif\n\n/*\n * Use inlined functions for supported systems.\n */\n#if defined(_MSC_VER) && !defined(__cplusplus)   /* Visual Studio */\n#define inline __inline  /* Visual C is not C99, but supports some kind of inline */\n#endif\n\n#define MAX_COPY 32U\n#define MAX_DISTANCE 65535\n\n\n#ifdef BLOSC_STRICT_ALIGN\n#define NDLZ_READU16(p) ((p)[0] | (p)[1]<<8)\n#define NDLZ_READU32(p) ((p)[0] | (p)[1]<<8 | (p)[2]<<16 | (p)[3]<<24)\n#else\n#define NDLZ_READU16(p) *((const uint16_t*)(p))\n#define NDLZ_READU32(p) *((const uint32_t*)(p))\n#endif\n\n#define HASH_LOG (12)\n\n\nint ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                   uint8_t meta, blosc2_cparams *cparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n  uint8_t *smeta;\n  int32_t smeta_len;\n\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (input_len != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {\n    BLOSC_TRACE_ERROR(\"Output too small\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t *op_limit;\n  uint32_t hval, hash_cell;\n  uint32_t hash_triple[6] = {0};\n  uint32_t hash_pair[7] = {0};\n  uint8_t *bufarea = malloc(cell_size);\n  uint8_t *buf_cell = bufarea;\n  uint8_t *buf_aux;\n  uint32_t tab_cell[1U << 12U] = {0};\n  uint32_t tab_triple[1U << 12U] = {0};\n  uint32_t tab_pair[1U << 12U] = {0};\n  uint32_t update_triple[6] = {0};\n  uint32_t update_pair[7] = {0};\n\n  // Minimum cratios before issuing and _early giveup_\n  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)\n\n  op_limit = op + output_len;\n\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << 12U); i++) {\n    tab_cell[i] = 0;\n    tab_triple[i] = 0;\n    tab_pair[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 64 (cells are 8x8) */\n  int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;\n  if (input_len < cell_size || output_len < overhead) {\n    BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");\n    return 0;\n  }\n\n  uint8_t *obase = op;\n\n  /* we start with literal copy */\n  *op++ = ndim;\n  memcpy(op, &blockshape[0], 4);\n  op += 4;\n  memcpy(op, &blockshape[1], 4);\n  op += 4;\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t padding[2];\n  uint32_t ii[2];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      for (int h = 0; h < 7; h++) {         // new cell -> new possible references\n        update_pair[h] = 0;\n        if (h != 6) {\n          update_triple[h] = 0;\n        }\n      }\n\n      if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        free(bufarea);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||\n          ((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {\n        uint8_t token = 0;                                   // padding -> literal copy\n        *op++ = token;\n        if (ii[0] == i_stop[0] - 1) {\n          padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n        } else {\n          padding[0] = cell_shape;\n        }\n        if (ii[1] == i_stop[1] - 1) {\n          padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n        } else {\n          padding[1] = cell_shape;\n        }\n        for (uint32_t i = 0; i < padding[0]; i++) {\n          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);\n          op += padding[1];\n        }\n      } else {\n        for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {           // fill cell buffer\n          uint64_t ind = orig + i * blockshape[1];\n          memcpy(buf_cell, &ip[ind], cell_shape);\n          buf_cell += cell_shape;\n        }\n        buf_cell -= cell_size;\n\n        const uint8_t *ref;\n        uint32_t distance;\n        uint8_t *anchor = op;    /* comparison starting-point */\n\n        /* find potential match */\n        hash_cell = XXH32(buf_cell, cell_size, 1);        // calculate cell hash\n        hash_cell >>= 32U - 12U;\n        ref = obase + tab_cell[hash_cell];\n\n        /* calculate distance to the match */\n        if (tab_cell[hash_cell] == 0) {\n          distance = 0;\n        } else {\n          bool same = true;\n          buf_aux = obase + tab_cell[hash_cell];\n          for (int i = 0; i < cell_size; i++) {\n            if (buf_cell[i] != buf_aux[i]) {\n              same = false;\n              break;\n            }\n          }\n          if (same) {\n            distance = (int32_t) (anchor - ref);\n          } else {\n            distance = 0;\n          }\n        }\n\n        bool alleq = true;\n        for (int i = 1; i < cell_size; i++) {\n          if (buf_cell[i] != buf_cell[0]) {\n            alleq = false;\n            break;\n          }\n        }\n        if (alleq) {                              // all elements of the cell equal\n          uint8_t token = (uint8_t) (1U << 6U);\n          *op++ = token;\n          *op++ = buf_cell[0];\n\n        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match\n          bool literal = true;\n\n          // rows triples matches\n          for (int i = 0; i < 6; i++) {\n            int triple_start = i * cell_shape;\n            hval = XXH32(&buf_cell[triple_start], 24, 1);        // calculate triple hash\n            hval >>= 32U - 12U;\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_triple[hval] != 0) {\n              buf_aux = obase + tab_triple[hval];\n              for (int l = 0; l < 24; l++) {\n                if (buf_cell[triple_start + l] != buf_aux[l]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_triple[hval]);\n            } else {\n              same = false;\n              update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     /* update hash table */\n              hash_triple[i] = hval;\n            }\n            ref = obase + tab_triple[hval];\n            if (same) {\n              distance = (int32_t) (anchor + triple_start - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     // 3 rows match\n              literal = false;\n              uint8_t token = (uint8_t) ((21 << 3U) | i);\n              *op++ = token;\n              memcpy(op, &offset, 2);\n              op += 2;\n              for (int l = 0; l < 8; l++) {\n                if ((l < i) || (l > i + 2)) {\n                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);\n                  op += cell_shape;\n                }\n              }\n              goto match;\n            }\n          }\n\n          // rows pairs matches\n          for (int i = 0; i < 7; i++) {\n            int pair_start = i * cell_shape;\n            hval = XXH32(&buf_cell[pair_start], 16, 1);        // calculate rows pair hash\n            hval >>= 32U - 12U;\n            ref = obase + tab_pair[hval];\n            /* calculate distance to the match */\n            bool same = true;\n            uint16_t offset;\n            if (tab_pair[hval] != 0) {\n              buf_aux = obase + tab_pair[hval];\n              for (int k = 0; k < 16; k++) {\n                if (buf_cell[pair_start + k] != buf_aux[k]) {\n                  same = false;\n                  break;\n                }\n              }\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n            } else {\n              same = false;\n              update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     /* update hash table */\n              hash_pair[i] = hval;\n            }\n            if (same) {\n              distance = (int32_t) (anchor + pair_start - ref);\n            } else {\n              distance = 0;\n            }\n            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* 1 rows pair match */\n              literal = false;\n              uint8_t token = (uint8_t) ((17 << 3U) | i);\n              *op++ = token;\n              offset = (uint16_t) (anchor - obase - tab_pair[hval]);\n              memcpy(op, &offset, 2);\n              op += 2;\n              for (int l = 0; l < 8; l++) {\n                if ((l < i) || (l > i + 1)) {\n                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);\n                  op += cell_shape;\n                }\n              }\n              goto match;\n            }\n          }\n\n          match:\n          if (literal) {\n            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */\n\n            if (update_triple[0] != 0) {\n              for (int h = 0; h < 6; h++) {\n                tab_triple[hash_triple[h]] = update_triple[h];\n              }\n            }\n            if (update_pair[0] != 0) {\n              for (int h = 0; h < 7; h++) {\n                tab_pair[hash_pair[h]] = update_pair[h];\n              }\n            }\n            uint8_t token = 0;\n            *op++ = token;\n            memcpy(op, buf_cell, cell_size);\n            op += cell_size;\n\n          }\n\n        } else {   // cell match\n          uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));\n          *op++ = token;\n          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);\n          memcpy(op, &offset, 2);\n          op += 2;\n\n        }\n\n      }\n      if ((op - obase) > input_len) {\n        free(shape);\n        free(chunkshape);\n        free(blockshape);\n        free(bufarea);\n        BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");\n        return 0;\n      }\n    }\n  }\n\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n  free(bufarea);\n\n  return (int) (op - obase);\n}\n\n\n// See https://habr.com/en/company/yandex/blog/457612/\n#ifdef __AVX2__\n\n#if defined(_MSC_VER)\n#define ALIGNED_(x) __declspec(align(x))\n#else\n#if defined(__GNUC__)\n#define ALIGNED_(x) __attribute__ ((aligned(x)))\n#endif\n#endif\n#define ALIGNED_TYPE_(t, x) t ALIGNED_(x)\n\nstatic unsigned char* copy_match_16(unsigned char *op, const unsigned char *match, int32_t len)\n{\n  size_t offset = op - match;\n  while (len >= 16) {\n\n    static const ALIGNED_TYPE_(uint8_t, 16) masks[] =\n      {\n                0,  1,  2,  1,  4,  1,  4,  2,  8,  7,  6,  5,  4,  3,  2,  1, // offset = 0, not used as mask, but for shift\n                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // offset = 1\n                0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,\n                0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,\n                0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,  1,  2,  3,  4,  0,\n                0,  1,  2,  3,  4,  5,  0,  1,  2,  3,  4,  5,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  0,  1,  2,  3,  4,  5,  6,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  0,  1,  2,  3,  4,  5,  6,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,  2,  3,  4,  5,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  1,  2,  3,  4,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,  0,  1,  2,  3,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  1,  2,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  0,  1,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  0,\n                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  15, // offset = 16\n      };\n\n    _mm_storeu_si128((__m128i *)(op),\n                     _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(match)),\n                                      _mm_load_si128((const __m128i *)(masks) + offset)));\n\n    match += masks[offset];\n\n    op += 16;\n    len -= 16;\n  }\n  // Deal with remainders\n  for (; len > 0; len--) {\n    *op++ = *match++;\n  }\n  return op;\n}\n#endif\n\n\nint ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}\n"], "filenames": ["plugins/codecs/ndlz/ndlz4x4.c", "plugins/codecs/ndlz/ndlz8x8.c"], "buggy_code_start_loc": [61, 61], "buggy_code_end_loc": [545, 463], "fixing_code_start_loc": [62, 62], "fixing_code_end_loc": [549, 466], "type": "CWE-476", "message": "C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.", "other": {"cve": {"id": "CVE-2023-37186", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-25T07:15:08.980", "lastModified": "2023-12-29T18:38:38.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset."}, {"lang": "es", "value": "Se descubri\u00f3 que C-blosc2 anterior a 2.9.3 conten\u00eda una desreferencia de puntero NULL en ndlz/ndlz8x8.c a trav\u00e9s de un puntero NULL a memset."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.3", "matchCriteriaId": "075116F3-2BB5-414B-82A9-D132E60D4769"}]}]}], "references": [{"url": "https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/Blosc/c-blosc2/issues/522", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3"}}