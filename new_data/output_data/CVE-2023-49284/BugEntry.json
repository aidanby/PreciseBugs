{"buggy_code": ["// Various functions, mostly string utilities, that are used by most parts of fish.\n#include \"config.h\"\n\n#ifdef HAVE_BACKTRACE_SYMBOLS\n#include <cxxabi.h>\n#endif\n\n#include <ctype.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <sys/time.h>\n#include <termios.h>\n#include <unistd.h>\n\n#ifdef HAVE_EXECINFO_H\n#include <execinfo.h>\n#endif\n\n#ifdef __linux__\n// Includes for WSL detection\n#include <sys/utsname.h>\n#endif\n\n#include <algorithm>\n#include <csignal>\n#include <cstdlib>\n#include <cstring>\n#include <cwchar>\n#include <memory>\n\n#include \"common.h\"\n#include \"expand.h\"\n#include \"fallback.h\"  // IWYU pragma: keep\n#include \"flog.h\"\n#include \"future_feature_flags.h\"\n#include \"global_safety.h\"\n#include \"iothread.h\"\n#include \"signal.h\"\n#include \"termsize.h\"\n#include \"topic_monitor.h\"\n#include \"wcstringutil.h\"\n#include \"wildcard.h\"\n#include \"wutil.h\"  // IWYU pragma: keep\n\n// Keep after \"common.h\"\n#ifdef HAVE_SYS_SYSCTL_H\n#include <sys/sysctl.h>  // IWYU pragma: keep\n#endif\n#if defined(__APPLE__)\n#include <mach-o/dyld.h>  // IWYU pragma: keep\n#endif\n\nstruct termios shell_modes;\n\nconst wcstring g_empty_string{};\n\n/// This allows us to notice when we've forked.\nstatic relaxed_atomic_bool_t is_forked_proc{false};\n/// This allows us to bypass the main thread checks\nstatic relaxed_atomic_bool_t thread_asserts_cfg_for_testing{false};\n\nstatic relaxed_atomic_t<wchar_t> ellipsis_char;\nwchar_t get_ellipsis_char() { return ellipsis_char; }\n\nstatic relaxed_atomic_t<const wchar_t *> ellipsis_str;\nconst wchar_t *get_ellipsis_str() { return ellipsis_str; }\n\nstatic relaxed_atomic_t<const wchar_t *> omitted_newline_str;\nconst wchar_t *get_omitted_newline_str() { return omitted_newline_str; }\n\nstatic relaxed_atomic_t<int> omitted_newline_width;\nint get_omitted_newline_width() { return omitted_newline_width; }\n\nstatic relaxed_atomic_t<wchar_t> obfuscation_read_char;\nwchar_t get_obfuscation_read_char() { return obfuscation_read_char; }\n\nbool g_profiling_active = false;\n\nconst wchar_t *program_name;\n\n/// Be able to restore the term's foreground process group.\n/// This is set during startup and not modified after.\nstatic relaxed_atomic_t<pid_t> initial_fg_process_group{-1};\n\n#if defined(OS_IS_CYGWIN) || defined(WSL)\n// MS Windows tty devices do not currently have either a read or write timestamp. Those\n// respective fields of `struct stat` are always the current time. Which means we can't\n// use them. So we assume no external program has written to the terminal behind our\n// back. This makes multiline promptusable. See issue #2859 and\n// https://github.com/Microsoft/BashOnWindows/issues/545\nconst bool has_working_tty_timestamps = false;\n#else\nconst bool has_working_tty_timestamps = true;\n#endif\n\n/// Convert a character to its integer equivalent if it is a valid character for the requested base.\n/// Return the integer value if it is valid else -1.\nlong convert_digit(wchar_t d, int base) {\n    long res = -1;\n    if ((d <= L'9') && (d >= L'0')) {\n        res = d - L'0';\n    } else if ((d <= L'z') && (d >= L'a')) {\n        res = d + 10 - L'a';\n    } else if ((d <= L'Z') && (d >= L'A')) {\n        res = d + 10 - L'A';\n    }\n    if (res >= base) {\n        res = -1;\n    }\n\n    return res;\n}\n\n/// Test whether the char is a valid hex digit as used by the `escape_string_*()` functions.\nstatic bool is_hex_digit(int c) { return std::strchr(\"0123456789ABCDEF\", c) != nullptr; }\n\n/// This is a specialization of `convert_digit()` that only handles base 16 and only uppercase.\nstatic long convert_hex_digit(wchar_t d) {\n    if ((d <= L'9') && (d >= L'0')) {\n        return d - L'0';\n    } else if ((d <= L'Z') && (d >= L'A')) {\n        return 10 + d - L'A';\n    }\n\n    return -1;\n}\n\nbool is_windows_subsystem_for_linux() {\n#if defined(WSL)\n    return true;\n#elif not defined(__linux__)\n    return false;\n#else\n    // We are purposely not using std::call_once as it may invoke locking, which is an unnecessary\n    // overhead since there's no actual race condition here - even if multiple threads call this\n    // routine simultaneously the first time around, we just end up needlessly querying uname(2) one\n    // more time.\n\n    static bool wsl_state = [] {\n        utsname info;\n        uname(&info);\n\n        // Sample utsname.release under WSL, testing for something like `4.4.0-17763-Microsoft`\n        if (std::strstr(info.release, \"Microsoft\") != nullptr) {\n            const char *dash = std::strchr(info.release, '-');\n            if (dash == nullptr || strtod(dash + 1, nullptr) < 17763) {\n                // #5298, #5661: There are acknowledged, published, and (later) fixed issues with\n                // job control under early WSL releases that prevent fish from running correctly,\n                // with unexpected failures when piping. Fish 3.0 nightly builds worked around this\n                // issue with some needlessly complicated code that was later stripped from the\n                // fish 3.0 release, so we just bail. Note that fish 2.0 was also broken, but we\n                // just didn't warn about it.\n\n                // #6038 & 5101bde: It's been requested that there be some sort of way to disable\n                // this check: if the environment variable FISH_NO_WSL_CHECK is present, this test\n                // is bypassed. We intentionally do not include this in the error message because\n                // it'll only allow fish to run but not to actually work. Here be dragons!\n                if (getenv(\"FISH_NO_WSL_CHECK\") == nullptr) {\n                    FLOGF(error,\n                          \"This version of WSL has known bugs that prevent fish from working.\"\n                          \"Please upgrade to Windows 10 1809 (17763) or higher to use fish!\");\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }();\n\n    // Subsequent calls to this function may take place after fork() and before exec() in\n    // postfork.cpp. Make sure we never dynamically allocate any memory in the fast path!\n    return wsl_state;\n#endif\n}\n\n#ifdef HAVE_BACKTRACE_SYMBOLS\n// This function produces a stack backtrace with demangled function & method names. It is based on\n// https://gist.github.com/fmela/591333 but adapted to the style of the fish project.\n[[gnu::noinline]] static wcstring_list_t demangled_backtrace(int max_frames, int skip_levels) {\n    void *callstack[128];\n    const int n_max_frames = sizeof(callstack) / sizeof(callstack[0]);\n    int n_frames = backtrace(callstack, n_max_frames);\n    char **symbols = backtrace_symbols(callstack, n_frames);\n    wchar_t text[1024];\n    wcstring_list_t backtrace_text;\n\n    if (skip_levels + max_frames < n_frames) n_frames = skip_levels + max_frames;\n\n    for (int i = skip_levels; i < n_frames; i++) {\n        Dl_info info;\n        if (dladdr(callstack[i], &info) && info.dli_sname) {\n            char *demangled = nullptr;\n            int status = -1;\n            if (info.dli_sname[0] == '_')\n                demangled = abi::__cxa_demangle(info.dli_sname, nullptr, nullptr, &status);\n            swprintf(text, sizeof(text) / sizeof(wchar_t), L\"%-3d %s + %td\", i - skip_levels,\n                     status == 0                 ? demangled\n                     : info.dli_sname == nullptr ? symbols[i]\n                                                 : info.dli_sname,\n                     static_cast<char *>(callstack[i]) - static_cast<const char *>(info.dli_saddr));\n            free(demangled);\n        } else {\n            swprintf(text, sizeof(text) / sizeof(wchar_t), L\"%-3d %s\", i - skip_levels, symbols[i]);\n        }\n        backtrace_text.push_back(text);\n    }\n    free(symbols);\n    return backtrace_text;\n}\n\n[[gnu::noinline]] void show_stackframe(int frame_count, int skip_levels) {\n    if (frame_count < 1) return;\n\n    wcstring_list_t bt = demangled_backtrace(frame_count, skip_levels + 2);\n    FLOG(error, L\"Backtrace:\\n\" + join_strings(bt, L'\\n') + L'\\n');\n}\n\n#else   // HAVE_BACKTRACE_SYMBOLS\n\n[[gnu::noinline]] void show_stackframe(int, int) {\n    FLOGF(error, L\"Sorry, but your system does not support backtraces\");\n}\n#endif  // HAVE_BACKTRACE_SYMBOLS\n\n/// \\return the smallest pointer in the range [start, start + len] which is aligned to Align.\n/// If there is no such pointer, return \\p start + len.\n/// alignment must be a power of 2 and in range [1, 64].\n/// This is intended to return the end point of the \"unaligned prefix\" of a vectorized loop.\ntemplate <size_t Align>\nstatic inline const char *align_start(const char *start, size_t len) {\n    static_assert(Align >= 1 && Align <= 64, \"Alignment must be in range [1, 64]\");\n    static_assert((Align & (Align - 1)) == 0, \"Alignment must be power of 2\");\n    uintptr_t startu = reinterpret_cast<uintptr_t>(start);\n    // How much do we have to add to start to make it 0 mod Align?\n    // To compute 17 up-aligned by 8, compute its skew 17 % 8, yielding 1,\n    // and then we will add 8 - 1. Of course if we align 16 with the same idea, we will\n    // add 8 instead of 0, so then mod the sum by Align again.\n    // Note all of these mods are optimized to masks.\n    uintptr_t add_which_aligns = Align - (startu % Align);\n    add_which_aligns %= Align;\n    // Add that much but not more than len. If we add 'add_which_aligns' we may overflow the\n    // pointer.\n    return start + std::min(static_cast<size_t>(add_which_aligns), len);\n}\n\n/// \\return the largest pointer in the range [start, start + len] which is aligned to Align.\n/// If there is no such pointer, return \\p start.\n/// This is intended to be the start point of the \"unaligned suffix\" of a vectorized loop.\ntemplate <size_t Align>\nstatic inline const char *align_end(const char *start, size_t len) {\n    static_assert(Align >= 1 && Align <= 64, \"Alignment must be in range [1, 64]\");\n    static_assert((Align & (Align - 1)) == 0, \"Alignment must be power of 2\");\n    // How much do we have to subtract to align it? Its value, mod Align.\n    uintptr_t endu = reinterpret_cast<uintptr_t>(start + len);\n    uintptr_t sub_which_aligns = endu % Align;\n    return start + len - std::min(static_cast<size_t>(sub_which_aligns), len);\n}\n\n/// \\return the count of initial characters in \\p in which are ASCII.\nstatic size_t count_ascii_prefix(const char *in, size_t in_len) {\n    // We'll use aligned reads of this type.\n    using WordType = uint32_t;\n    const char *aligned_start = align_start<alignof(WordType)>(in, in_len);\n    const char *aligned_end = align_end<alignof(WordType)>(in, in_len);\n\n    // Consume the unaligned prefix.\n    for (const char *cursor = in; cursor < aligned_start; cursor++) {\n        if (cursor[0] & 0x80) return &cursor[0] - in;\n    }\n\n    // Consume the aligned middle.\n    for (const char *cursor = aligned_start; cursor < aligned_end; cursor += sizeof(WordType)) {\n        if (*reinterpret_cast<const WordType *>(cursor) & 0x80808080) {\n            if (cursor[0] & 0x80) return &cursor[0] - in;\n            if (cursor[1] & 0x80) return &cursor[1] - in;\n            if (cursor[2] & 0x80) return &cursor[2] - in;\n            return &cursor[3] - in;\n        }\n    }\n\n    // Consume the unaligned suffix.\n    for (const char *cursor = aligned_end; cursor < in + in_len; cursor++) {\n        if (cursor[0] & 0x80) return &cursor[0] - in;\n    }\n    return in_len;\n}\n\n/// Converts the narrow character string \\c in into its wide equivalent, and return it.\n///\n/// The string may contain embedded nulls.\n///\n/// This function encodes illegal character sequences in a reversible way using the private use\n/// area.\nstatic wcstring str2wcs_internal(const char *in, const size_t in_len) {\n    if (in_len == 0) return wcstring();\n    assert(in != nullptr);\n\n    wcstring result;\n    result.reserve(in_len);\n\n    size_t in_pos = 0;\n    mbstate_t state = {};\n    while (in_pos < in_len) {\n        // Append any initial sequence of ascii characters.\n        // Note we do not support character sets which are not supersets of ASCII.\n        size_t ascii_prefix_length = count_ascii_prefix(&in[in_pos], in_len - in_pos);\n        result.insert(result.end(), &in[in_pos], &in[in_pos + ascii_prefix_length]);\n        in_pos += ascii_prefix_length;\n        assert(in_pos <= in_len && \"Position overflowed length\");\n        if (in_pos == in_len) break;\n\n        // We have found a non-ASCII character.\n        bool use_encode_direct = false;\n        size_t ret = 0;\n        wchar_t wc = 0;\n\n        if (false) {\n#if defined(HAVE_BROKEN_MBRTOWC_UTF8)\n        } else if ((in[in_pos] & 0xF8) == 0xF8) {\n            // Protect against broken std::mbrtowc() implementations which attempt to encode UTF-8\n            // sequences longer than four bytes (e.g., OS X Snow Leopard).\n            use_encode_direct = true;\n#endif\n        } else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)\n                   (in[in_pos] & 0xF8) == 0xF0) {\n            // Assume we are in a UTF-16 environment (e.g., Cygwin) using a UTF-8 encoding.\n            // The bits set check will be true for a four byte UTF-8 sequence that requires\n            // two UTF-16 chars. Something that doesn't work with our simple use of std::mbrtowc().\n            use_encode_direct = true;\n        } else {\n            ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);\n            // Determine whether to encode this character with our crazy scheme.\n            if (wc >= ENCODE_DIRECT_BASE && wc < ENCODE_DIRECT_BASE + 256) {\n                use_encode_direct = true;\n            } else if (wc == INTERNAL_SEPARATOR) {\n                use_encode_direct = true;\n            } else if (ret == static_cast<size_t>(-2)) {\n                // Incomplete sequence.\n                use_encode_direct = true;\n            } else if (ret == static_cast<size_t>(-1)) {\n                // Invalid data.\n                use_encode_direct = true;\n            } else if (ret > in_len - in_pos) {\n                // Other error codes? Terrifying, should never happen.\n                use_encode_direct = true;\n            } else if (sizeof(wchar_t) == 2 && wc >= 0xD800 &&  //!OCLINT(constant if expression)\n                       wc <= 0xDFFF) {\n                // If we get a surrogate pair char on a UTF-16 system (e.g., Cygwin) then\n                // it's guaranteed the UTF-8 decoding is wrong so use direct encoding.\n                use_encode_direct = true;\n            }\n        }\n\n        if (use_encode_direct) {\n            wc = ENCODE_DIRECT_BASE + static_cast<unsigned char>(in[in_pos]);\n            result.push_back(wc);\n            in_pos++;\n            std::memset(&state, 0, sizeof state);\n        } else if (ret == 0) {  // embedded null byte!\n            result.push_back(L'\\0');\n            in_pos++;\n            std::memset(&state, 0, sizeof state);\n        } else {  // normal case\n            result.push_back(wc);\n            in_pos += ret;\n        }\n    }\n\n    return result;\n}\n\nwcstring str2wcstring(const char *in, size_t len) { return str2wcs_internal(in, len); }\n\nwcstring str2wcstring(const char *in) { return str2wcs_internal(in, std::strlen(in)); }\n\nwcstring str2wcstring(const std::string &in) {\n    // Handles embedded nulls!\n    return str2wcs_internal(in.data(), in.size());\n}\n\nwcstring str2wcstring(const std::string &in, size_t len) {\n    // Handles embedded nulls!\n    return str2wcs_internal(in.data(), len);\n}\n\nstd::string wcs2string(const wcstring &input) { return wcs2string(input.data(), input.size()); }\n\nstd::string wcs2string(const wchar_t *in, size_t len) {\n    if (len == 0) return std::string{};\n    std::string result;\n    wcs2string_appending(in, len, &result);\n    return result;\n}\n\nvoid wcs2string_appending(const wchar_t *in, size_t len, std::string *receiver) {\n    assert(receiver && \"Null receiver\");\n    receiver->reserve(receiver->size() + len);\n    wcs2string_callback(in, len, [&](const char *buff, size_t bufflen) {\n        receiver->append(buff, bufflen);\n        return true;\n    });\n}\n\n/// Test if the character can be encoded using the current locale.\nstatic bool can_be_encoded(wchar_t wc) {\n    char converted[MB_LEN_MAX];\n    mbstate_t state = {};\n\n    return std::wcrtomb(converted, wc, &state) != static_cast<size_t>(-1);\n}\n\nwcstring format_string(const wchar_t *format, ...) {\n    va_list va;\n    va_start(va, format);\n    wcstring result = vformat_string(format, va);\n    va_end(va);\n    return result;\n}\n\nvoid append_formatv(wcstring &target, const wchar_t *format, va_list va_orig) {\n    const int saved_err = errno;\n    // As far as I know, there is no way to check if a vswprintf-call failed because of a badly\n    // formated string option or because the supplied destination string was to small. In GLIBC,\n    // errno seems to be set to EINVAL either way.\n    //\n    // Because of this, on failure we try to increase the buffer size until the free space is\n    // larger than max_size, at which point it will conclude that the error was probably due to a\n    // badly formated string option, and return an error. Make sure to null terminate string before\n    // that, though.\n    const size_t max_size = (128 * 1024 * 1024);\n    wchar_t static_buff[256];\n    size_t size = 0;\n    wchar_t *buff = nullptr;\n    int status = -1;\n    while (status < 0) {\n        // Reallocate if necessary.\n        if (size == 0) {\n            buff = static_buff;\n            size = sizeof static_buff;\n        } else {\n            size *= 2;\n            if (size >= max_size) {\n                buff[0] = '\\0';\n                break;\n            }\n            buff = static_cast<wchar_t *>(realloc((buff == static_buff ? nullptr : buff), size));\n            assert(buff != nullptr);\n        }\n\n        // Try printing.\n        va_list va;\n        va_copy(va, va_orig);\n        status = std::vswprintf(buff, size / sizeof(wchar_t), format, va);\n        va_end(va);\n    }\n\n    target.append(buff);\n\n    if (buff != static_buff) {\n        free(buff);\n    }\n\n    errno = saved_err;\n}\n\nwcstring vformat_string(const wchar_t *format, va_list va_orig) {\n    wcstring result;\n    append_formatv(result, format, va_orig);\n    return result;\n}\n\nvoid append_format(wcstring &str, const wchar_t *format, ...) {\n    va_list va;\n    va_start(va, format);\n    append_formatv(str, format, va);\n    va_end(va);\n}\n\nconst wchar_t *quote_end(const wchar_t *pos, wchar_t quote) {\n    while (true) {\n        pos++;\n\n        if (!*pos) return nullptr;\n\n        if (*pos == L'\\\\') {\n            pos++;\n            if (!*pos) return nullptr;\n        } else {\n            if (*pos == quote ||\n                // Command substitutions also end a double quoted string.  This is how we\n                // support command substitutions inside double quotes.\n                (quote == L'\"' && *pos == L'$' && *(pos + 1) == L'(')) {\n                return pos;\n            }\n        }\n    }\n    return nullptr;\n}\n\nconst wchar_t *comment_end(const wchar_t *pos) {\n    do {\n        pos++;\n    } while (*pos && *pos != L'\\n');\n    return pos;\n}\n\nvoid fish_setlocale() {\n    // Use various Unicode symbols if they can be encoded using the current locale, else a simple\n    // ASCII char alternative. All of the can_be_encoded() invocations should return the same\n    // true/false value since the code points are in the BMP but we're going to be paranoid. This\n    // is also technically wrong if we're not in a Unicode locale but we expect (or hope)\n    // can_be_encoded() will return false in that case.\n    if (can_be_encoded(L'\\u2026')) {\n        ellipsis_char = L'\\u2026';\n        ellipsis_str = L\"\\u2026\";\n    } else {\n        ellipsis_char = L'$';  // \"horizontal ellipsis\"\n        ellipsis_str = L\"...\";\n    }\n\n    if (is_windows_subsystem_for_linux()) {\n        // neither of \\u23CE and \\u25CF can be displayed in the default fonts on Windows, though\n        // they can be *encoded* just fine. Use alternative glyphs.\n        omitted_newline_str = L\"\\u00b6\";  // \"pilcrow\"\n        omitted_newline_width = 1;\n        obfuscation_read_char = L'\\u2022';  // \"bullet\"\n    } else if (is_console_session()) {\n        omitted_newline_str = L\"^J\";\n        omitted_newline_width = 2;\n        obfuscation_read_char = L'*';\n    } else {\n        if (can_be_encoded(L'\\u23CE')) {\n            omitted_newline_str = L\"\\u23CE\";  // \"return symbol\" (\u23ce)\n            omitted_newline_width = 1;\n        } else {\n            omitted_newline_str = L\"^J\";\n            omitted_newline_width = 2;\n        }\n        obfuscation_read_char = can_be_encoded(L'\\u25CF') ? L'\\u25CF' : L'#';  // \"black circle\"\n    }\n}\n\nlong read_blocked(int fd, void *buf, size_t count) {\n    ssize_t res;\n    do {\n        res = read(fd, buf, count);\n    } while (res < 0 && errno == EINTR);\n    return res;\n}\n\n/// Loop a write request while failure is non-critical. Return -1 and set errno in case of critical\n/// error.\nssize_t write_loop(int fd, const char *buff, size_t count) {\n    size_t out_cum = 0;\n    while (out_cum < count) {\n        ssize_t out = write(fd, &buff[out_cum], count - out_cum);\n        if (out < 0) {\n            if (errno != EAGAIN && errno != EINTR) {\n                return -1;\n            }\n        } else {\n            out_cum += static_cast<size_t>(out);\n        }\n    }\n    return static_cast<ssize_t>(out_cum);\n}\n\nssize_t read_loop(int fd, void *buff, size_t count) {\n    ssize_t result;\n    do {\n        result = read(fd, buff, count);\n    } while (result < 0 && (errno == EAGAIN || errno == EINTR));\n    return result;\n}\n\n/// Hack to not print error messages in the tests. Do not call this from functions in this module\n/// like `debug()`. It is only intended to suppress diagnostic noise from testing things like the\n/// fish parser where we expect a lot of diagnostic messages due to testing error conditions.\nbool should_suppress_stderr_for_tests() {\n    return program_name && !std::wcscmp(program_name, TESTS_PROGRAM_NAME);\n}\n\n// Careful to not negate LLONG_MIN.\nstatic unsigned long long absolute_value(long long x) {\n    if (x >= 0) return static_cast<unsigned long long>(x);\n    x = -(x + 1);\n    return static_cast<unsigned long long>(x) + 1;\n}\n\ntemplate <typename CharT>\nstatic void format_safe_impl(CharT *buff, size_t size, unsigned long long val) {\n    size_t idx = 0;\n    if (val == 0) {\n        buff[idx++] = '0';\n    } else {\n        // Generate the string backwards, then reverse it.\n        while (val != 0) {\n            buff[idx++] = (val % 10) + '0';\n            val /= 10;\n        }\n        std::reverse(buff, buff + idx);\n    }\n    buff[idx++] = '\\0';\n    assert(idx <= size && \"Buffer overflowed\");\n}\n\nvoid format_long_safe(char buff[64], long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_long_safe(wchar_t buff[64], long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_llong_safe(wchar_t buff[64], long long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_ullong_safe(wchar_t buff[64], unsigned long long val) {\n    return format_safe_impl(buff, 64, val);\n}\n\nvoid narrow_string_safe(char buff[64], const wchar_t *s) {\n    size_t idx = 0;\n    for (size_t widx = 0; s[widx] != L'\\0'; widx++) {\n        wchar_t c = s[widx];\n        if (c <= 127) {\n            buff[idx++] = char(c);\n            if (idx + 1 == 64) {\n                break;\n            }\n        }\n    }\n    buff[idx] = '\\0';\n}\n\nwcstring reformat_for_screen(const wcstring &msg, const termsize_t &termsize) {\n    wcstring buff;\n\n    int screen_width = termsize.width;\n\n    if (screen_width) {\n        const wchar_t *start = msg.c_str();\n        const wchar_t *pos = start;\n        int line_width = 0;\n        while (true) {\n            int overflow = 0;\n\n            int tok_width = 0;\n\n            // Tokenize on whitespace, and also calculate the width of the token.\n            while (*pos && (!std::wcschr(L\" \\n\\r\\t\", *pos))) {\n                // Check is token is wider than one line. If so we mark it as an overflow and break\n                // the token.\n                if ((tok_width + fish_wcwidth(*pos)) > (screen_width - 1)) {\n                    overflow = 1;\n                    break;\n                }\n\n                tok_width += fish_wcwidth(*pos);\n                pos++;\n            }\n\n            // If token is zero character long, we don't do anything.\n            if (pos == start) {\n                pos = pos + 1;\n            } else if (overflow) {\n                // In case of overflow, we print a newline, except if we already are at position 0.\n                wcstring token = msg.substr(start - msg.c_str(), pos - start);\n                if (line_width != 0) buff.push_back(L'\\n');\n                buff.append(format_string(L\"%ls-\\n\", token.c_str()));\n                line_width = 0;\n            } else {\n                // Print the token.\n                wcstring token = msg.substr(start - msg.c_str(), pos - start);\n                if ((line_width + (line_width != 0 ? 1 : 0) + tok_width) > screen_width) {\n                    buff.push_back(L'\\n');\n                    line_width = 0;\n                }\n                buff.append(format_string(L\"%ls%ls\", line_width ? L\" \" : L\"\", token.c_str()));\n                line_width += (line_width != 0 ? 1 : 0) + tok_width;\n            }\n\n            // Break on end of string.\n            if (!*pos) {\n                break;\n            }\n\n            start = pos;\n        }\n    } else {\n        buff.append(msg);\n    }\n    buff.push_back(L'\\n');\n    return buff;\n}\n\n/// Escape a string in a fashion suitable for using as a URL. Store the result in out_str.\nstatic void escape_string_url(const wcstring &in, wcstring &out) {\n    const std::string narrow = wcs2string(in);\n    for (auto &c1 : narrow) {\n        // This silliness is so we get the correct result whether chars are signed or unsigned.\n        unsigned int c2 = static_cast<unsigned int>(c1) & 0xFF;\n        if (!(c2 & 0x80) &&\n            (isalnum(c2) || c2 == '/' || c2 == '.' || c2 == '~' || c2 == '-' || c2 == '_')) {\n            // The above characters don't need to be encoded.\n            out.push_back(static_cast<wchar_t>(c2));\n        } else {\n            // All other chars need to have their UTF-8 representation encoded in hex.\n            wchar_t buf[4];\n            swprintf(buf, sizeof buf / sizeof buf[0], L\"%%%02X\", c2);\n            out.append(buf);\n        }\n    }\n}\n\n/// Reverse the effects of `escape_string_url()`. By definition the string has consist of just ASCII\n/// chars.\nstatic bool unescape_string_url(const wchar_t *in, wcstring *out) {\n    std::string result;\n    result.reserve(out->size());\n    for (wchar_t c = *in; c; c = *++in) {\n        if (c > 0x7F) return false;  // invalid character means we can't decode the string\n        if (c == '%') {\n            int c1 = in[1];\n            if (c1 == 0) return false;  // found unexpected end of string\n            if (c1 == '%') {\n                result.push_back('%');\n                in++;\n            } else {\n                int c2 = in[2];\n                if (c2 == 0) return false;  // string ended prematurely\n                long d1 = convert_digit(c1, 16);\n                if (d1 < 0) return false;\n                long d2 = convert_digit(c2, 16);\n                if (d2 < 0) return false;\n                result.push_back(16 * d1 + d2);\n                in += 2;\n            }\n        } else {\n            result.push_back(c);\n        }\n    }\n\n    *out = str2wcstring(result);\n    return true;\n}\n\n/// Escape a string in a fashion suitable for using as a fish var name. Store the result in out_str.\nstatic void escape_string_var(const wcstring &in, wcstring &out) {\n    bool prev_was_hex_encoded = false;\n    const std::string narrow = wcs2string(in);\n    for (auto c1 : narrow) {\n        // This silliness is so we get the correct result whether chars are signed or unsigned.\n        unsigned int c2 = static_cast<unsigned int>(c1) & 0xFF;\n        if (!(c2 & 0x80) && isalnum(c2) && (!prev_was_hex_encoded || !is_hex_digit(c2))) {\n            // ASCII alphanumerics don't need to be encoded.\n            if (prev_was_hex_encoded) {\n                out.push_back(L'_');\n                prev_was_hex_encoded = false;\n            }\n            out.push_back(static_cast<wchar_t>(c2));\n        } else if (c2 == '_') {\n            // Underscores are encoded by doubling them.\n            out.append(L\"__\");\n            prev_was_hex_encoded = false;\n        } else {\n            // All other chars need to have their UTF-8 representation encoded in hex.\n            wchar_t buf[4];\n            swprintf(buf, sizeof buf / sizeof buf[0], L\"_%02X\", c2);\n            out.append(buf);\n            prev_was_hex_encoded = true;\n        }\n    }\n    if (prev_was_hex_encoded) {\n        out.push_back(L'_');\n    }\n}\n\n/// Reverse the effects of `escape_string_var()`. By definition the string has consist of just ASCII\n/// chars.\nstatic bool unescape_string_var(const wchar_t *in, wcstring *out) {\n    std::string result;\n    result.reserve(out->size());\n    bool prev_was_hex_encoded = false;\n    for (wchar_t c = *in; c; c = *++in) {\n        if (c > 0x7F) return false;  // invalid character means we can't decode the string\n        if (c == '_') {\n            int c1 = in[1];\n            if (c1 == 0) {\n                if (prev_was_hex_encoded) break;\n                return false;  // found unexpected escape char at end of string\n            }\n            if (c1 == '_') {\n                result.push_back('_');\n                in++;\n            } else if (is_hex_digit(c1)) {\n                int c2 = in[2];\n                if (c2 == 0) return false;  // string ended prematurely\n                long d1 = convert_hex_digit(c1);\n                if (d1 < 0) return false;\n                long d2 = convert_hex_digit(c2);\n                if (d2 < 0) return false;\n                result.push_back(16 * d1 + d2);\n                in += 2;\n                prev_was_hex_encoded = true;\n            }\n            // No \"else\" clause because if the first char after an underscore is not another\n            // underscore or a valid hex character then the underscore is there to improve\n            // readability after we've encoded a character not valid in a var name.\n        } else {\n            result.push_back(c);\n        }\n    }\n\n    *out = str2wcstring(result);\n    return true;\n}\n\nwcstring escape_string_for_double_quotes(wcstring in) {\n    // We need to escape backslashes, double quotes, and dollars only.\n    wcstring result = std::move(in);\n    size_t idx = result.size();\n    while (idx--) {\n        switch (result[idx]) {\n            case L'\\\\':\n            case L'$':\n            case L'\"':\n                result.insert(idx, 1, L'\\\\');\n                break;\n        }\n    }\n    return result;\n}\n\n/// Escape a string in a fashion suitable for using in fish script. Store the result in out_str.\nstatic void escape_string_script(const wchar_t *orig_in, size_t in_len, wcstring &out,\n                                 escape_flags_t flags) {\n    const wchar_t *in = orig_in;\n    const bool escape_printables = !(flags & ESCAPE_NO_PRINTABLES);\n    const bool no_quoted = static_cast<bool>(flags & ESCAPE_NO_QUOTED);\n    const bool no_tilde = static_cast<bool>(flags & ESCAPE_NO_TILDE);\n    const bool no_qmark = feature_test(features_t::qmark_noglob);\n    const bool symbolic = static_cast<bool>(flags & ESCAPE_SYMBOLIC) && (MB_CUR_MAX > 1);\n    assert((!symbolic || !escape_printables) && \"symbolic implies escape-no-printables\");\n\n    bool need_escape = false;\n    bool need_complex_escape = false;\n\n    if (!no_quoted && in_len == 0) {\n        out.assign(L\"''\");\n        return;\n    }\n\n    for (size_t i = 0; i < in_len; i++) {\n        if ((*in >= ENCODE_DIRECT_BASE) && (*in < ENCODE_DIRECT_BASE + 256)) {\n            int val = *in - ENCODE_DIRECT_BASE;\n            int tmp;\n\n            out += L'\\\\';\n            out += L'X';\n\n            tmp = val / 16;\n            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n\n            tmp = val % 16;\n            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n            need_escape = need_complex_escape = true;\n\n        } else {\n            wchar_t c = *in;\n            switch (c) {\n                case L'\\t': {\n                    if (symbolic)\n                        out += L'\u2409';\n                    else\n                        out += L\"\\\\t\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\n': {\n                    if (symbolic)\n                        out += L'\u2424';\n                    else\n                        out += L\"\\\\n\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\b': {\n                    if (symbolic)\n                        out += L'\u2408';\n                    else\n                        out += L\"\\\\b\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\r': {\n                    if (symbolic)\n                        out += L'\u240d';\n                    else\n                        out += L\"\\\\r\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\x1B': {\n                    if (symbolic)\n                        out += L'\u241b';\n                    else\n                        out += L\"\\\\e\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\x7F': {\n                    if (symbolic)\n                        out += L'\u2421';\n                    else\n                        out += L\"\\\\x7f\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\\\':\n                case L'\\'': {\n                    need_escape = need_complex_escape = true;\n                    if (escape_printables || (c == L'\\\\' && !symbolic)) out += L'\\\\';\n                    out += *in;\n                    break;\n                }\n                case ANY_CHAR: {\n                    // See #1614\n                    out += L'?';\n                    break;\n                }\n                case ANY_STRING: {\n                    out += L'*';\n                    break;\n                }\n                case ANY_STRING_RECURSIVE: {\n                    out += L\"**\";\n                    break;\n                }\n\n                case L'&':\n                case L'$':\n                case L' ':\n                case L'#':\n                case L'<':\n                case L'>':\n                case L'(':\n                case L')':\n                case L'[':\n                case L']':\n                case L'{':\n                case L'}':\n                case L'?':\n                case L'*':\n                case L'|':\n                case L';':\n                case L'\"':\n                case L'%':\n                case L'~': {\n                    bool char_is_normal = (c == L'~' && no_tilde) || (c == L'?' && no_qmark);\n                    if (!char_is_normal) {\n                        need_escape = true;\n                        if (escape_printables) out += L'\\\\';\n                    }\n                    out += *in;\n                    break;\n                }\n\n                default: {\n                    if (*in >= 0 && *in < 32) {\n                        need_escape = need_complex_escape = true;\n\n                        if (symbolic) {\n                            out += L'\\u2400' + *in;\n                            break;\n                        }\n\n                        if (*in < 27 && *in != 0) {\n                            out += L'\\\\';\n                            out += L'c';\n                            out += L'a' + *in - 1;\n                            break;\n                        }\n\n                        int tmp = (*in) % 16;\n                        out += L'\\\\';\n                        out += L'x';\n                        out += ((*in > 15) ? L'1' : L'0');\n                        out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n                    } else {\n                        out += *in;\n                    }\n                    break;\n                }\n            }\n        }\n\n        in++;\n    }\n\n    // Use quoted escaping if possible, since most people find it easier to read.\n    if (!no_quoted && need_escape && !need_complex_escape && escape_printables) {\n        wchar_t single_quote = L'\\'';\n        out.clear();\n        out.reserve(2 + in_len);\n        out.push_back(single_quote);\n        out.append(orig_in, in_len);\n        out.push_back(single_quote);\n    }\n}\n\n/// Escapes a string for use in a regex string. Not safe for use with `eval` as only\n/// characters reserved by PCRE2 are escaped.\n/// \\param in is the raw string to be searched for literally when substituted in a PCRE2 expression.\nstatic wcstring escape_string_pcre2(const wcstring &in) {\n    wcstring out;\n    out.reserve(in.size() * 1.3);  // a wild guess\n\n    for (auto c : in) {\n        switch (c) {\n            case L'.':\n            case L'^':\n            case L'$':\n            case L'*':\n            case L'+':\n            case L'(':\n            case L')':\n            case L'?':\n            case L'[':\n            case L'{':\n            case L'}':\n            case L'\\\\':\n            case L'|':\n            // these two only *need* to be escaped within a character class, and technically it\n            // makes no sense to ever use process substitution output to compose a character class,\n            // but...\n            case L'-':\n            case L']':\n                out.push_back('\\\\');\n                __fallthrough__\n            default:\n                out.push_back(c);\n        }\n    }\n\n    return out;\n}\n\nwcstring escape_string(const wchar_t *in, escape_flags_t flags, escape_string_style_t style) {\n    wcstring result;\n\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            escape_string_script(in, std::wcslen(in), result, flags);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            escape_string_url(in, result);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            escape_string_var(in, result);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            result = escape_string_pcre2(in);\n            break;\n        }\n    }\n\n    return result;\n}\n\nwcstring escape_string(const wcstring &in, escape_flags_t flags, escape_string_style_t style) {\n    wcstring result;\n\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            escape_string_script(in.c_str(), in.size(), result, flags);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            escape_string_url(in, result);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            escape_string_var(in, result);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            result = escape_string_pcre2(in);\n            break;\n        }\n    }\n\n    return result;\n}\n\n/// Helper to return the last character in a string, or none.\nstatic maybe_t<wchar_t> string_last_char(const wcstring &str) {\n    if (str.empty()) return none();\n    return str.back();\n}\n\n/// Given a null terminated string starting with a backslash, read the escape as if it is unquoted,\n/// appending to result. Return the number of characters consumed, or none on error.\nmaybe_t<size_t> read_unquoted_escape(const wchar_t *input, wcstring *result, bool allow_incomplete,\n                                     bool unescape_special) {\n    assert(input[0] == L'\\\\' && \"Not an escape\");\n\n    // Here's the character we'll ultimately append, or none. Note that L'\\0' is a\n    // valid thing to append.\n    maybe_t<wchar_t> result_char_or_none = none();\n\n    bool errored = false;\n    size_t in_pos = 1;  // in_pos always tracks the next character to read (and therefore the number\n                        // of characters read so far)\n\n    // For multibyte \\X sequences.\n    std::string byte_buff;\n    while (true) {\n        const wchar_t c = input[in_pos++];\n        switch (c) {\n                // A null character after a backslash is an error.\n            case L'\\0': {\n                // Adjust in_pos to only include the backslash.\n                assert(in_pos > 0);\n                in_pos--;\n\n                // It's an error, unless we're allowing incomplete escapes.\n                if (!allow_incomplete) errored = true;\n                break;\n            }\n                // Numeric escape sequences. No prefix means octal escape, otherwise hexadecimal.\n            case L'0':\n            case L'1':\n            case L'2':\n            case L'3':\n            case L'4':\n            case L'5':\n            case L'6':\n            case L'7':\n            case L'u':\n            case L'U':\n            case L'x':\n            case L'X': {\n                long long res = 0;\n                size_t chars = 2;\n                int base = 16;\n                bool byte_literal = false;\n                wchar_t max_val = ASCII_MAX;\n\n                switch (c) {\n                    case L'u': {\n                        chars = 4;\n                        max_val = UCS2_MAX;\n                        break;\n                    }\n                    case L'U': {\n                        chars = 8;\n                        max_val = WCHAR_MAX;\n\n                        // Don't exceed the largest Unicode code point - see #1107.\n                        if (0x10FFFF < max_val) max_val = static_cast<wchar_t>(0x10FFFF);\n                        break;\n                    }\n                    case L'x':\n                    case L'X': {\n                        byte_literal = true;\n                        max_val = BYTE_MAX;\n                        break;\n                    }\n                    default: {\n                        base = 8;\n                        chars = 3;\n                        // Note that in_pos currently is just after the first post-backslash\n                        // character; we want to start our escape from there.\n                        assert(in_pos > 0);\n                        in_pos--;\n                        break;\n                    }\n                }\n\n                for (size_t i = 0; i < chars; i++) {\n                    long d = convert_digit(input[in_pos], base);\n                    if (d < 0) {\n                        // If we have no digit, this is a tokenizer error.\n                        if (i == 0) errored = true;\n                        break;\n                    }\n\n                    res = (res * base) + d;\n                    in_pos++;\n                }\n\n                if (!errored && res <= max_val) {\n                    if (byte_literal) {\n                        // Multibyte encodings necessitate that we keep adjacent byte escapes.\n                        // - `\\Xc3\\Xb6` is \"\u00f6\", but only together.\n                        // (this assumes a valid codepoint can't consist of multiple bytes\n                        // that are valid on their own, which is true for UTF-8)\n                        byte_buff.push_back(static_cast<char>(res));\n                        result_char_or_none = none();\n                        if (input[in_pos] == L'\\\\'\n                            && (input[in_pos + 1] == L'X' || input[in_pos + 1] == L'x')) {\n                            in_pos++;\n                            continue;\n                        }\n                    } else {\n                        result_char_or_none = static_cast<wchar_t>(res);\n                    }\n                } else {\n                    errored = true;\n                }\n\n                break;\n            }\n                // \\a means bell (alert).\n            case L'a': {\n                result_char_or_none = L'\\a';\n                break;\n            }\n                // \\b means backspace.\n            case L'b': {\n                result_char_or_none = L'\\b';\n                break;\n            }\n                // \\cX means control sequence X.\n            case L'c': {\n                const wchar_t sequence_char = input[in_pos++];\n                if (sequence_char >= L'a' && sequence_char <= (L'a' + 32)) {\n                    result_char_or_none = sequence_char - L'a' + 1;\n                } else if (sequence_char >= L'A' && sequence_char <= (L'A' + 32)) {\n                    result_char_or_none = sequence_char - L'A' + 1;\n                } else {\n                    errored = true;\n                }\n                break;\n            }\n                // \\x1B means escape.\n            case L'e': {\n                result_char_or_none = L'\\x1B';\n                break;\n            }\n                // \\f means form feed.\n            case L'f': {\n                result_char_or_none = L'\\f';\n                break;\n            }\n                // \\n means newline.\n            case L'n': {\n                result_char_or_none = L'\\n';\n                break;\n            }\n                // \\r means carriage return.\n            case L'r': {\n                result_char_or_none = L'\\r';\n                break;\n            }\n                // \\t means tab.\n            case L't': {\n                result_char_or_none = L'\\t';\n                break;\n            }\n                // \\v means vertical tab.\n            case L'v': {\n                result_char_or_none = L'\\v';\n                break;\n            }\n                // If a backslash is followed by an actual newline, swallow them both.\n            case L'\\n': {\n                result_char_or_none = none();\n                break;\n            }\n            default: {\n                if (unescape_special) result->push_back(INTERNAL_SEPARATOR);\n                result_char_or_none = c;\n                break;\n            }\n        }\n\n        if (errored) return none();\n\n        if (!byte_buff.empty()) {\n            result->append(str2wcstring(byte_buff));\n        }\n\n        break;\n    }\n\n    if (result_char_or_none.has_value()) {\n        result->push_back(*result_char_or_none);\n    }\n\n    return in_pos;\n}\n\n/// Returns the unescaped version of input_str into output_str (by reference). Returns true if\n/// successful. If false, the contents of output_str are unchanged.\nstatic bool unescape_string_internal(const wchar_t *const input, const size_t input_len,\n                                     wcstring *output_str, unescape_flags_t flags) {\n    // Set up result string, which we'll swap with the output on success.\n    wcstring result;\n    result.reserve(input_len);\n\n    const bool unescape_special = static_cast<bool>(flags & UNESCAPE_SPECIAL);\n    const bool allow_incomplete = static_cast<bool>(flags & UNESCAPE_INCOMPLETE);\n    const bool ignore_backslashes = static_cast<bool>(flags & UNESCAPE_NO_BACKSLASHES);\n\n    // The positions of open braces.\n    std::vector<size_t> braces;\n    // The positions of variable expansions or brace \",\"s.\n    // We only read braces as expanders if there's a variable expansion or \",\" in them.\n    std::vector<size_t> vars_or_seps;\n    int brace_count = 0;\n\n    bool errored = false;\n    enum {\n        mode_unquoted,\n        mode_single_quotes,\n        mode_double_quotes,\n    } mode = mode_unquoted;\n\n    for (size_t input_position = 0; input_position < input_len && !errored; input_position++) {\n        const wchar_t c = input[input_position];\n        // Here's the character we'll append to result, or none() to suppress it.\n        maybe_t<wchar_t> to_append_or_none = c;\n        if (mode == mode_unquoted) {\n            switch (c) {\n                case L'\\\\': {\n                    if (!ignore_backslashes) {\n                        // Backslashes (escapes) are complicated and may result in errors, or\n                        // appending INTERNAL_SEPARATORs, so we have to handle them specially.\n                        auto escape_chars = read_unquoted_escape(\n                            input + input_position, &result, allow_incomplete, unescape_special);\n                        if (!escape_chars.has_value()) {\n                            // A none() return indicates an error.\n                            errored = true;\n                        } else {\n                            // Skip over the characters we read, minus one because the outer loop\n                            // will increment it.\n                            assert(*escape_chars > 0);\n                            input_position += *escape_chars - 1;\n                        }\n                        // We've already appended, don't append anything else.\n                        to_append_or_none = none();\n                    }\n                    break;\n                }\n                case L'~': {\n                    if (unescape_special && (input_position == 0)) {\n                        to_append_or_none = HOME_DIRECTORY;\n                    }\n                    break;\n                }\n                case L'%': {\n                    // Note that this only recognizes %self if the string is literally %self.\n                    // %self/foo will NOT match this.\n                    if (unescape_special && input_position == 0 &&\n                        !std::wcscmp(input, PROCESS_EXPAND_SELF_STR)) {\n                        to_append_or_none = PROCESS_EXPAND_SELF;\n                        input_position += PROCESS_EXPAND_SELF_STR_LEN - 1;  // skip over 'self's\n                    }\n                    break;\n                }\n                case L'*': {\n                    if (unescape_special) {\n                        // In general, this is ANY_STRING. But as a hack, if the last appended char\n                        // is ANY_STRING, delete the last char and store ANY_STRING_RECURSIVE to\n                        // reflect the fact that ** is the recursive wildcard.\n                        if (string_last_char(result) == ANY_STRING) {\n                            assert(!result.empty());\n                            result.resize(result.size() - 1);\n                            to_append_or_none = ANY_STRING_RECURSIVE;\n                        } else {\n                            to_append_or_none = ANY_STRING;\n                        }\n                    }\n                    break;\n                }\n                case L'?': {\n                    if (unescape_special && !feature_test(features_t::qmark_noglob)) {\n                        to_append_or_none = ANY_CHAR;\n                    }\n                    break;\n                }\n                case L'$': {\n                    if (unescape_special) {\n                        bool is_cmdsub =\n                            input_position + 1 < input_len && input[input_position + 1] == L'(';\n                        if (!is_cmdsub) {\n                            to_append_or_none = VARIABLE_EXPAND;\n                            vars_or_seps.push_back(input_position);\n                        }\n                    }\n                    break;\n                }\n                case L'{': {\n                    if (unescape_special) {\n                        brace_count++;\n                        to_append_or_none = BRACE_BEGIN;\n                        // We need to store where the brace *ends up* in the output.\n                        braces.push_back(result.size());\n                    }\n                    break;\n                }\n                case L'}': {\n                    if (unescape_special) {\n                        // HACK: The completion machinery sometimes hands us partial tokens.\n                        // We can't parse them properly, but it shouldn't hurt,\n                        // so we don't assert here.\n                        // See #4954.\n                        // assert(brace_count > 0 && \"imbalanced brackets are a tokenizer error, we\n                        // shouldn't be able to get here\");\n                        brace_count--;\n                        to_append_or_none = BRACE_END;\n                        if (!braces.empty()) {\n                            // HACK: To reduce accidental use of brace expansion, treat a brace\n                            // with zero or one items as literal input. See #4632. (The hack is\n                            // doing it here and like this.)\n                            if (vars_or_seps.empty() || vars_or_seps.back() < braces.back()) {\n                                result[braces.back()] = L'{';\n                                // We also need to turn all spaces back.\n                                for (size_t i = braces.back() + 1; i < result.size(); i++) {\n                                    if (result[i] == BRACE_SPACE) result[i] = L' ';\n                                }\n                                to_append_or_none = L'}';\n                            }\n\n                            // Remove all seps inside the current brace pair, so if we have a\n                            // surrounding pair we only get seps inside *that*.\n                            if (!vars_or_seps.empty()) {\n                                while (!vars_or_seps.empty() && vars_or_seps.back() > braces.back())\n                                    vars_or_seps.pop_back();\n                            }\n                            braces.pop_back();\n                        }\n                    }\n                    break;\n                }\n                case L',': {\n                    if (unescape_special && brace_count > 0) {\n                        to_append_or_none = BRACE_SEP;\n                        vars_or_seps.push_back(input_position);\n                    }\n                    break;\n                }\n                case L' ': {\n                    if (unescape_special && brace_count > 0) {\n                        to_append_or_none = BRACE_SPACE;\n                    }\n                    break;\n                }\n                case L'\\'': {\n                    mode = mode_single_quotes;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                case L'\\\"': {\n                    mode = mode_double_quotes;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        } else if (mode == mode_single_quotes) {\n            if (c == L'\\\\') {\n                // A backslash may or may not escape something in single quotes.\n                switch (input[input_position + 1]) {\n                    case '\\\\':\n                    case L'\\'': {\n                        to_append_or_none = input[input_position + 1];\n                        input_position += 1;  // skip over the backslash\n                        break;\n                    }\n                    case L'\\0': {\n                        if (!allow_incomplete) {\n                            errored = true;\n                        } else {\n                            // PCA this line had the following cryptic comment: 'We may ever escape\n                            // a NULL character, but still appending a \\ in case I am wrong.' Not\n                            // sure what it means or the importance of this.\n                            input_position += 1; /* Skip over the backslash */\n                            to_append_or_none = L'\\\\';\n                        }\n                        break;\n                    }\n                    default: {\n                        // Literal backslash that doesn't escape anything! Leave things alone; we'll\n                        // append the backslash itself.\n                        break;\n                    }\n                }\n            } else if (c == L'\\'') {\n                to_append_or_none =\n                    unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                mode = mode_unquoted;\n            }\n        } else if (mode == mode_double_quotes) {\n            switch (c) {\n                case L'\"': {\n                    mode = mode_unquoted;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                case '\\\\': {\n                    switch (input[input_position + 1]) {\n                        case L'\\0': {\n                            if (!allow_incomplete) {\n                                errored = true;\n                            } else {\n                                to_append_or_none = L'\\0';\n                            }\n                            break;\n                        }\n                        case '\\\\':\n                        case L'$':\n                        case '\"': {\n                            to_append_or_none = input[input_position + 1];\n                            input_position += 1; /* Skip over the backslash */\n                            break;\n                        }\n                        case '\\n': {\n                            /* Swallow newline */\n                            to_append_or_none = none();\n                            input_position += 1; /* Skip over the backslash */\n                            break;\n                        }\n                        default: {\n                            /* Literal backslash that doesn't escape anything! Leave things alone;\n                             * we'll append the backslash itself */\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case '$': {\n                    if (unescape_special) {\n                        to_append_or_none = VARIABLE_EXPAND_SINGLE;\n                        vars_or_seps.push_back(input_position);\n                    }\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        }\n\n        // Now maybe append the char.\n        if (to_append_or_none.has_value()) {\n            result.push_back(*to_append_or_none);\n        }\n    }\n\n    // Return the string by reference, and then success.\n    if (!errored) {\n        *output_str = std::move(result);\n    }\n    return !errored;\n}\n\nbool unescape_string_in_place(wcstring *str, unescape_flags_t escape_special) {\n    assert(str != nullptr);\n    wcstring output;\n    bool success = unescape_string_internal(str->c_str(), str->size(), &output, escape_special);\n    if (success) {\n        *str = std::move(output);\n    }\n    return success;\n}\n\nbool unescape_string(const wchar_t *input, size_t len, wcstring *output,\n                     unescape_flags_t escape_special, escape_string_style_t style) {\n    bool success = false;\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            success = unescape_string_internal(input, len, output, escape_special);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            success = unescape_string_url(input, output);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            success = unescape_string_var(input, output);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            // unescaping PCRE2 is not needed/supported, the PCRE2 engine is responsible for that\n            success = false;\n            break;\n        }\n    }\n    if (!success) output->clear();\n    return success;\n}\n\nbool unescape_string(const wchar_t *input, wcstring *output, unescape_flags_t escape_special,\n                     escape_string_style_t style) {\n    return unescape_string(input, std::wcslen(input), output, escape_special, style);\n}\n\nbool unescape_string(const wcstring &input, wcstring *output, unescape_flags_t escape_special,\n                     escape_string_style_t style) {\n    return unescape_string(input.c_str(), input.size(), output, escape_special, style);\n}\n\nwcstring format_size(long long sz) {\n    wcstring result;\n    const wchar_t *sz_name[] = {L\"kB\", L\"MB\", L\"GB\", L\"TB\", L\"PB\", L\"EB\", L\"ZB\", L\"YB\", nullptr};\n\n    if (sz < 0) {\n        result.append(L\"unknown\");\n    } else if (sz < 1) {\n        result.append(_(L\"empty\"));\n    } else if (sz < 1024) {\n        result.append(format_string(L\"%lldB\", sz));\n    } else {\n        int i;\n\n        for (i = 0; sz_name[i]; i++) {\n            if (sz < (1024 * 1024) || !sz_name[i + 1]) {\n                long isz = (static_cast<long>(sz)) / 1024;\n                if (isz > 9)\n                    result.append(format_string(L\"%ld%ls\", isz, sz_name[i]));\n                else\n                    result.append(\n                        format_string(L\"%.1f%ls\", static_cast<double>(sz) / 1024, sz_name[i]));\n                break;\n            }\n            sz /= 1024;\n        }\n    }\n    return result;\n}\n\n/// Crappy function to extract the most significant digit of an unsigned long long value.\nstatic char extract_most_significant_digit(unsigned long long *xp) {\n    unsigned long long place_value = 1;\n    unsigned long long x = *xp;\n    while (x >= 10) {\n        x /= 10;\n        place_value *= 10;\n    }\n    *xp -= (place_value * x);\n    return x + '0';\n}\n\nstatic void append_ull(char *buff, unsigned long long val, size_t *inout_idx, size_t max_len) {\n    size_t idx = *inout_idx;\n    while (val > 0 && idx < max_len) buff[idx++] = extract_most_significant_digit(&val);\n    *inout_idx = idx;\n}\n\nstatic void append_str(char *buff, const char *str, size_t *inout_idx, size_t max_len) {\n    size_t idx = *inout_idx;\n    while (*str && idx < max_len) buff[idx++] = *str++;\n    *inout_idx = idx;\n}\n\nvoid format_size_safe(char buff[128], unsigned long long sz) {\n    const size_t buff_size = 128;\n    const size_t max_len = buff_size - 1;  // need to leave room for a null terminator\n    std::memset(buff, 0, buff_size);\n    size_t idx = 0;\n    const char *const sz_name[] = {\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\", nullptr};\n    if (sz < 1) {\n        strcpy(buff, \"empty\");\n    } else if (sz < 1024) {\n        append_ull(buff, sz, &idx, max_len);\n        append_str(buff, \"B\", &idx, max_len);\n    } else {\n        for (size_t i = 0; sz_name[i]; i++) {\n            if (sz < (1024 * 1024) || !sz_name[i + 1]) {\n                unsigned long long isz = sz / 1024;\n                if (isz > 9) {\n                    append_ull(buff, isz, &idx, max_len);\n                } else {\n                    append_ull(buff, isz, &idx, max_len);\n\n                    // Maybe append a single fraction digit.\n                    unsigned long long remainder = sz % 1024;\n                    if (remainder > 0) {\n                        char tmp[3] = {'.', extract_most_significant_digit(&remainder), 0};\n                        append_str(buff, tmp, &idx, max_len);\n                    }\n                }\n                append_str(buff, sz_name[i], &idx, max_len);\n                break;\n            }\n            sz /= 1024;\n        }\n    }\n}\n\ndouble timef() {\n    struct timeval tv;\n    assert_with_errno(gettimeofday(&tv, nullptr) != -1);\n    return static_cast<timepoint_t>(tv.tv_sec) + 1e-6 * tv.tv_usec;\n}\n\nvoid exit_without_destructors(int code) { _exit(code); }\n\nextern \"C\" {\n[[gnu::noinline]] void debug_thread_error(void) {\n    // Wait for a SIGINT. We can't use sigsuspend() because the signal may be delivered on another\n    // thread.\n    sigchecker_t sigint(topic_t::sighupint);\n    sigint.wait();\n}\n}\n\nvoid set_main_thread() {\n    // Just call thread_id() once to force increment of thread_id.\n    uint64_t tid = thread_id();\n    assert(tid == 1 && \"main thread should have thread ID 1\");\n    (void)tid;\n}\n\nvoid configure_thread_assertions_for_testing() { thread_asserts_cfg_for_testing = true; }\n\nbool is_forked_child() { return is_forked_proc; }\n\nvoid setup_fork_guards() {\n    is_forked_proc = false;\n    static std::once_flag fork_guard_flag;\n    std::call_once(fork_guard_flag,\n                   [] { pthread_atfork(nullptr, nullptr, [] { is_forked_proc = true; }); });\n}\n\nvoid save_term_foreground_process_group() { initial_fg_process_group = tcgetpgrp(STDIN_FILENO); }\n\nvoid restore_term_foreground_process_group_for_exit() {\n    // We wish to restore the tty to the initial owner. There's two ways this can go wrong:\n    //  1. We may steal the tty from someone else (#7060).\n    //  2. The call to tcsetpgrp may deliver SIGSTOP to us, and we will not exit.\n    // Hanging on exit seems worse, so ensure that SIGTTOU is ignored so we do not get SIGSTOP.\n    // Note initial_fg_process_group == 0 is possible with Linux pid namespaces.\n    // This is called during shutdown and from a signal handler. We don't bother to complain on\n    // failure because doing so is unlikely to be noticed.\n    if (initial_fg_process_group > 0 && initial_fg_process_group != getpgrp()) {\n        (void)signal(SIGTTOU, SIG_IGN);\n        (void)tcsetpgrp(STDIN_FILENO, initial_fg_process_group);\n    }\n}\n\nbool is_main_thread() { return thread_id() == 1; }\n\nvoid assert_is_main_thread(const char *who) {\n    if (!likely(is_main_thread()) && !unlikely(thread_asserts_cfg_for_testing)) {\n        FLOGF(error, L\"%s called off of main thread.\", who);\n        FLOGF(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_not_forked_child(const char *who) {\n    if (unlikely(is_forked_child())) {\n        FLOGF(error, L\"%s called in a forked child.\", who);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_background_thread(const char *who) {\n    if (unlikely(is_main_thread()) && !unlikely(thread_asserts_cfg_for_testing)) {\n        FLOGF(error, L\"%s called on the main thread (may block!).\", who);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_locked(std::mutex &mutex, const char *who, const char *caller) {\n    // Note that std::mutex.try_lock() is allowed to return false when the mutex isn't\n    // actually locked; fortunately we are checking the opposite so we're safe.\n    if (unlikely(mutex.try_lock())) {\n        FLOGF(error, L\"%s is not locked when it should be in '%s'\", who, caller);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n        mutex.unlock();\n    }\n}\n\n/// Test if the specified character is in a range that fish uses internally to store special tokens.\n///\n/// NOTE: This is used when tokenizing the input. It is also used when reading input, before\n/// tokenization, to replace such chars with REPLACEMENT_WCHAR if they're not part of a quoted\n/// string. We don't want external input to be able to feed reserved characters into our\n/// lexer/parser or code evaluator.\n//\n// TODO: Actually implement the replacement as documented above.\nbool fish_reserved_codepoint(wchar_t c) {\n    return (c >= RESERVED_CHAR_BASE && c < RESERVED_CHAR_END) ||\n           (c >= ENCODE_DIRECT_BASE && c < ENCODE_DIRECT_END);\n}\n\n/// Reopen stdin, stdout and/or stderr on /dev/null. This is invoked when we find that our tty has\n/// become invalid.\nvoid redirect_tty_output() {\n    struct termios t;\n    int fd = open(\"/dev/null\", O_WRONLY);\n    if (fd == -1) {\n        __fish_assert(\"Could not open /dev/null!\", __FILE__, __LINE__, errno);\n    }\n    if (tcgetattr(STDIN_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDIN_FILENO);\n    if (tcgetattr(STDOUT_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDOUT_FILENO);\n    if (tcgetattr(STDERR_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDERR_FILENO);\n    close(fd);\n}\n\n/// Display a failed assertion message, dump a stack trace if possible, then die.\n[[noreturn]] void __fish_assert(const char *msg, const char *file, size_t line, int error) {\n    if (unlikely(error)) {\n        FLOGF(error, L\"%s:%zu: failed assertion: %s: errno %d (%s)\", file, line, msg, error,\n              std::strerror(error));\n    } else {\n        FLOGF(error, L\"%s:%zu: failed assertion: %s\", file, line, msg);\n    }\n    show_stackframe(99, 1);\n    abort();\n}\n\n/// Test if the given char is valid in a variable name.\nbool valid_var_name_char(wchar_t chr) { return fish_iswalnum(chr) || chr == L'_'; }\n\n/// Test if the given string is a valid variable name.\nbool valid_var_name(const wcstring &str) {\n    // Note do not use c_str(), we want to fail on embedded nul bytes.\n    return !str.empty() && std::all_of(str.begin(), str.end(), valid_var_name_char);\n}\n\nbool valid_var_name(const wchar_t *str) {\n    if (str[0] == L'\\0') return false;\n    for (size_t i = 0; str[i] != L'\\0'; i++) {\n        if (!valid_var_name_char(str[i])) return false;\n    }\n    return true;\n}\n\n/// Test if the string is a valid function name.\nbool valid_func_name(const wcstring &str) {\n    if (str.empty()) return false;\n    if (str.at(0) == L'-') return false;\n    // A function name needs to be a valid path, so no / and no NULL.\n    if (str.find_first_of(L'/') != wcstring::npos) return false;\n    if (str.find_first_of(L'\\0') != wcstring::npos) return false;\n    return true;\n}\n\n/// Return the path to the current executable. This needs to be realpath'd.\nstd::string get_executable_path(const char *argv0) {\n    char buff[PATH_MAX];\n\n#ifdef __APPLE__\n    // On OS X use it's proprietary API to get the path to the executable.\n    // This is basically grabbing exec_path after argc, argv, envp, ...: for us\n    // https://opensource.apple.com/source/adv_cmds/adv_cmds-163/ps/print.c\n    uint32_t buffSize = sizeof buff;\n    if (_NSGetExecutablePath(buff, &buffSize) == 0) return std::string(buff);\n#elif defined(__BSD__) && defined(KERN_PROC_PATHNAME)\n    // BSDs do not have /proc by default, (although it can be mounted as procfs via the Linux\n    // compatibility layer). We can use sysctl instead: per sysctl(3), passing in a process ID of -1\n    // returns the value for the current process.\n    size_t buff_size = sizeof buff;\n#if defined(__NetBSD__)\n    int name[] = {CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_PATHNAME};\n#else\n    int name[] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};\n#endif\n    int result = sysctl(name, sizeof(name) / sizeof(int), buff, &buff_size, nullptr, 0);\n    if (result != 0) {\n        wperror(L\"sysctl KERN_PROC_PATHNAME\");\n    } else {\n        return std::string(buff);\n    }\n#else\n    // On other unixes, fall back to the Linux-ish /proc/ directory\n    ssize_t len;\n    len = readlink(\"/proc/self/exe\", buff, sizeof buff - 1);  // Linux\n    if (len == -1) {\n        len = readlink(\"/proc/curproc/file\", buff, sizeof buff - 1);  // other BSDs\n        if (len == -1) {\n            len = readlink(\"/proc/self/path/a.out\", buff, sizeof buff - 1);  // Solaris\n        }\n    }\n    if (len > 0) {\n        buff[len] = '\\0';\n        // When /proc/self/exe points to a file that was deleted (or overwritten on update!)\n        // then linux adds a \" (deleted)\" suffix.\n        // If that's not a valid path, let's remove that awkward suffix.\n        std::string buffstr{buff};\n        if (access(buff, F_OK)) {\n            auto dellen = const_strlen(\" (deleted)\");\n            if (buffstr.size() > dellen &&\n                buffstr.compare(buffstr.size() - dellen, dellen, \" (deleted)\") == 0) {\n                buffstr = buffstr.substr(0, buffstr.size() - dellen);\n            }\n        }\n        return buffstr;\n    }\n#endif\n\n    // Just return argv0, which probably won't work (i.e. it's not an absolute path or a path\n    // relative to the working directory, but instead something the caller found via $PATH). We'll\n    // eventually fall back to the compile time paths.\n    return std::string(argv0 ? argv0 : \"\");\n}\n\n/// Return a path to a directory where we can store temporary files.\nstd::string get_path_to_tmp_dir() {\n    char *env_tmpdir = getenv(\"TMPDIR\");\n    if (env_tmpdir) {\n        return env_tmpdir;\n    }\n#if defined(_CS_DARWIN_USER_TEMP_DIR)\n    char osx_tmpdir[PATH_MAX];\n    size_t n = confstr(_CS_DARWIN_USER_TEMP_DIR, osx_tmpdir, PATH_MAX);\n    if (0 < n && n <= PATH_MAX) {\n        return osx_tmpdir;\n    } else {\n        return \"/tmp\";\n    }\n#elif defined(P_tmpdir)\n    return P_tmpdir;\n#elif defined(_PATH_TMP)\n    return _PATH_TMP;\n#else\n    return \"/tmp\";\n#endif\n}\n\n// This function attempts to distinguish between a console session (at the actual login vty) and a\n// session within a terminal emulator inside a desktop environment or over SSH. Unfortunately\n// there are few values of $TERM that we can interpret as being exclusively console sessions, and\n// most common operating systems do not use them. The value is cached for the duration of the fish\n// session. We err on the side of assuming it's not a console session. This approach isn't\n// bullet-proof and that's OK.\nbool is_console_session() {\n    static const bool console_session = [] {\n        char tty_name[PATH_MAX];\n        if (ttyname_r(STDIN_FILENO, tty_name, sizeof tty_name) != 0) {\n            return false;\n        }\n        constexpr auto len = const_strlen(\"/dev/tty\");\n        const char *TERM = getenv(\"TERM\");\n        return\n            // Test that the tty matches /dev/(console|dcons|tty[uv\\d])\n            ((strncmp(tty_name, \"/dev/tty\", len) == 0 &&\n              (tty_name[len] == 'u' || tty_name[len] == 'v' || isdigit(tty_name[len]))) ||\n             strcmp(tty_name, \"/dev/dcons\") == 0 || strcmp(tty_name, \"/dev/console\") == 0)\n            // and that $TERM is simple, e.g. `xterm` or `vt100`, not `xterm-something`\n            && (!TERM || !strchr(TERM, '-') || !strcmp(TERM, \"sun-color\"));\n    }();\n    return console_session;\n}\n", "# RUN: %fish -C 'set -g fish %fish' %s\n#\n# Test function, loops, conditionals and some basic elements\n#\n\n# The test driver always starts each test in its own temporary directory, but to make it easier to\n# run this test directly for whatever reason:\nset -g tmpdir (mktemp -d)\n\n# Comments in odd places don't cause problems\nfor i in 1 2 # Comment on same line as command\n# Comment inside loop\n    for j in a b\n\t\t# Double loop\n        echo $i$j\n\tend;\nend\n#CHECK: 1a\n#CHECK: 1b\n#CHECK: 2a\n#CHECK: 2b\n\n# Escaped newlines\necho foo\\ bar\necho foo\\\nbar\necho \"foo\\\nbar\"\necho 'foo\\\nbar'\n#CHECK: foo bar\n#CHECK: foobar\n#CHECK: foobar\n#CHECK: foo\\\n#CHECK: bar\n\nfor i in \\\n    a b c\n    echo $i\nend\n#CHECK: a\n#CHECK: b\n#CHECK: c\n\n\n# Simple function tests\n\nfunction foo\n    echo > $tmpdir/fish_foo.txt $argv\nend\n\nfoo hello\n\ncat $tmpdir/fish_foo.txt |read foo\n\nif test $foo = hello;\n  echo Test 2 pass\nelse\n  echo Test 2 fail\nend\n#CHECK: Test 2 pass\n\nfunction foo\n    printf 'Test %s' $argv[1]; echo ' pass'\nend\n\nfoo 3a\n#CHECK: Test 3a pass\n\nfor i in Test for continue break and switch builtins problems;\n\tswitch $i\n\t\tcase Test\n\t\t\tprintf \"%s \" $i\n\t\tcase \"for\"\n\t\t\tprintf \"%s \" 3b\n\t\tcase \"c*\"\n\t\t\techo pass\n\t\tcase break\n\t\t\tcontinue\n\t\t\techo fail\n\t\tcase and\n\t\t\tbreak\n\t\t\techo fail\n\t\tcase \"*\"\n\t\t\techo fail\n\tend\nend\n#CHECK: Test 3b pass\n\nset -l sta\nif eval true\n\tif eval false\n\t\tset sta fail\n\telse\n\t\tset sta pass\n\tend\nelse\n\tset sta fail\nend\necho Test 4 $sta\n#CHECK: Test 4 pass\n\n# Testing builtin status\n\nfunction test_builtin_status\n\treturn 1\nend\ntest_builtin_status\nif [ $status -eq 1 ]\n\tset sta pass\nelse\n\tset sta fail\nend\necho Test 5 $sta\n#CHECK: Test 5 pass\n\n\nfunction test_builtin_status_clamp_to_255\n    return 300\nend\ntest_builtin_status_clamp_to_255\necho $status\n#CHECK: 255\n\n$fish -c \"exit 300\"\necho $status\n#CHECK: 255\n\n####################\n# echo tests\necho 'abc\\ndef'\n#CHECK: abc\\ndef\necho -e 'abc\\ndef'\n#CHECK: abc\n#CHECK: def\necho -e 'abc\\zdef'\n#CHECK: abc\\zdef\necho -e 'abc\\41def'\necho -e 'abc\\041def'\n#CHECK: abc!def\n#CHECK: abc!def\necho -e 'abc\\121def'\necho -e 'abc\\1212def'\n#CHECK: abcQdef\n#CHECK: abcQ2def\necho -e 'abc\\cdef' # won't output a newline!\n#CHECK: abc\necho ''\necho -\n#CHECK: -\necho -h\n#CHECK: -h\necho -ne '\\376' | display_bytes\n#CHECK: 0000000 376\n#CHECK: 0000001\necho -e 'abc\\x21def'\necho -e 'abc\\x211def'\n#CHECK: abc!def\n#CHECK: abc!1def\n\n# Comments allowed in between lines (#1987)\necho before comment \\\n  # comment\n  after comment\n#CHECK: before comment after comment\n\n# Backslashes are part of comments and do not join lines (#1255)\n# This should execute false, not echo it\necho -n # comment\\\nfalse\n\nfunction always_fails\n    if true\n        return 1\n    end\nend\n\n# Verify $argv set correctly in sourced scripts (#139)\necho 'echo \"source argv {$argv}\"' | source\n#CHECK: source argv {}\necho 'echo \"source argv {$argv}\"' | source -\n#CHECK: source argv {}\necho 'echo \"source argv {$argv}\"' | source - abc\n#CHECK: source argv {abc}\necho 'echo \"source argv {$argv}\"' | source - abc def\n#CHECK: source argv {abc def}\n\nalways_fails\necho $status\n#CHECK: 1\n\n# Test that subsequent cases do not blow away the status from previous ones\nfor val in one two three four\n\tswitch $val\n\tcase one\n\t\t/bin/sh -c 'exit 1'\n\tcase two\n\t\t/bin/sh -c 'exit 2'\n\tcase three\n\t\t/bin/sh -c 'exit 3'\n\tend\n\techo $status\nend\n#CHECK: 1\n#CHECK: 2\n#CHECK: 3\n#CHECK: 0\n\n# Test that the `switch` builtin itself does not blow away status before evaluating a case\nfalse\nswitch one\ncase one\n\techo $status\nend\n#CHECK: 1\n\n#test contains -i\ncontains -i string a b c string d\n#CHECK: 4\ncontains -i string a b c d; or echo nothing\n#CHECK: nothing\ncontains -i -- string a b c string d\n#CHECK: 4\ncontains -i -- -- a b c; or echo nothing\n#CHECK: nothing\ncontains -i -- -- a b c -- v\n#CHECK: 4\n\n# Test if, else, and else if\nif true\n\techo alpha1.1\n\techo alpha1.2\nelse if false\n\techo beta1.1\n\techo beta1.2\nelse if false\n\techo gamma1.1\n\techo gamma1.2\nelse\n\techo delta1.1\n\techo delta1.2\nend\n#CHECK: alpha1.1\n#CHECK: alpha1.2\n\nif false\n\techo alpha2.1\n\techo alpha2.2\nelse if begin ; true ; end\n\techo beta2.1\n\techo beta2.2\nelse if begin ; echo nope2.1; false ; end\n\techo gamma2.1\n\techo gamma2.2\nelse\n\techo delta2.1\n\techo delta2.2\nend\n#CHECK: beta2.1\n#CHECK: beta2.2\n\nif false\n\techo alpha3.1\n\techo alpha3.2\nelse if begin ; echo yep3.1; false ; end\n\techo beta3.1\n\techo beta3.2\nelse if begin ; echo yep3.2; true ; end\n\techo gamma3.1\n\techo gamma3.2\nelse\n\techo delta3.1\n\techo delta3.2\nend\n#CHECK: yep3.1\n#CHECK: yep3.2\n#CHECK: gamma3.1\n#CHECK: gamma3.2\n\nif false\n\techo alpha4.1\n\techo alpha4.2\nelse if begin ; echo yep4.1; false ; end\n\techo beta4.1\n\techo beta4.2\nelse if begin ; echo yep4.2; false ; end\n\techo gamma4.1\n\techo gamma4.2\nelse\n\techo delta4.1\n\techo delta4.2\nend\n#CHECK: yep4.1\n#CHECK: yep4.2\n#CHECK: delta4.1\n#CHECK: delta4.2\n\nif test ! -n \"abc\"\nelse if test -n \"def\"\n\techo \"epsilon5.2\"\nelse if not_a_valid_command but it should be OK because a previous branch was taken\n\techo \"epsilon 5.3\"\nelse if test ! -n \"abc\"\n\techo \"epsilon 5.4\"\nend\n#CHECK: epsilon5.2\n\n# Ensure builtins work\n# https://github.com/fish-shell/fish-shell/issues/359\nif not echo skip1 > /dev/null\n\techo \"zeta 6.1\"\nelse if echo skip2 > /dev/null\n\techo \"zeta 6.2\"\nend\n#CHECK: zeta 6.2\n\necho '###'\n#CHECK: ###\n\n# Ensure 'type' works\n# https://github.com/fish-shell/fish-shell/issues/513\nfunction fish_test_type_zzz\n\ttrue\nend\n# Should succeed\ntype -q fish_test_type_zzz ; echo $status\n#CHECK: 0\n# Should fail\ntype -q -f fish_test_type_zzz ; echo $status\n#CHECK: 1\n\n# ensure that builtins that produce no output can still truncate files\n# (bug PCA almost reintroduced!)\necho abc > $tmpdir/file_truncation_test.txt\ncat $tmpdir/file_truncation_test.txt\necho -n > $tmpdir/file_truncation_test.txt\ncat $tmpdir/file_truncation_test.txt\n#CHECK: abc\n\n# Test events.\n\n\n# This pattern caused a crash; github issue #449\n\nset -g var before\n\nfunction test1 --on-event test\n    set -g var $var:test1\n    functions -e test2\nend\n\nfunction test2 --on-event test\n    # this should not run, as test2 gets removed before it has a chance of running\n    set -g var $var:test2a\nend\nemit test\n\necho $var\n#CHECK: before:test1\n\n\nfunction test3 --on-event test3\n    echo received event test3 with args: $argv\nend\n\nemit test3 foo bar\n#CHECK: received event test3 with args: foo bar\n\n# test empty argument\nemit\n#CHECKERR: emit: expected event name\n\n# Test break and continue\n# This should output Ping once\nfor i in a b c\n    if not contains $i c ; continue ; end\n    echo Ping\nend\n#CHECK: Ping\n\n# This should output Pong not at all\nfor i in a b c\n    if not contains $i c ; break ; end\n    echo Pong\nend\n\n# This should output Foop three times, and Boop not at all\nset i a a a\nwhile contains $i a\n    set -e i[-1]\n    echo Foop\n    continue\n    echo Boop\nend\n#CHECK: Foop\n#CHECK: Foop\n#CHECK: Foop\n\n# This should output Doop once\nset i a a a\nwhile contains $i a\n    set -e i[-1]\n    echo Doop\n    break\n    echo Darp\nend\n#CHECK: Doop\n\n# break and continue may be dynamically invoked.\nset dyn_break break\nset dyn_continue continue\n\nwhile true\n    $dyn_break\n    echo \"I should be unreachable\"\nend\n\nfor foo in 1 2 3\n    $dyn_continue\n    echo \"I should be unreachable\"\nend\n\n# Check that these error correctly.\n# Simplify __fish_print_help, as it's noisy.\nfunction __fish_print_help\n    echo $argv[2..]\nend\n$dyn_break\neval break\n#CHECKERR: break: Not inside of loop\n#CHECKERR: break: Not inside of loop\n$dyn_continue\neval continue\n#CHECKERR: continue: Not inside of loop\n#CHECKERR: continue: Not inside of loop\n\n# Test implicit cd. This should do nothing.\n./\n\n# Test special for loop expansion\n# Here we the name of the variable is derived from another variable\nset var1 var2\nfor $var1 in 1 2 3\n    echo -n $var2\nend\necho\n#CHECK: 123\n\n# Test status -n\neval 'status -n\nstatus -n\nstatus -n'\n#CHECK: 1\n#CHECK: 2\n#CHECK: 3\n\n# Test support for unbalanced blocks\nfunction try_unbalanced_block\n    $fish -c \"echo $argv | source \" 2>&1 | grep \"Missing end\" 1>&2\nend\ntry_unbalanced_block 'begin'\n#CHECKERR: - (line 1): Missing end to balance this begin\ntry_unbalanced_block 'while true'\n#CHECKERR: - (line 1): Missing end to balance this while loop\ntry_unbalanced_block 'for x in 1 2 3'\n#CHECKERR: - (line 1): Missing end to balance this for loop\ntry_unbalanced_block 'switch abc'\n#CHECKERR: - (line 1): Missing end to balance this switch statement\ntry_unbalanced_block 'function anything'\n#CHECKERR: - (line 1): Missing end to balance this function definition\ntry_unbalanced_block 'if false'\n#CHECKERR: - (line 1): Missing end to balance this if statement\n\n# Ensure that quoted keywords work\n'while' false; end\n\"while\" false; end\n\"wh\"'ile' false; \"e\"nd\n\n# BOM checking (see #1518). But only in UTF8 locales.\n# (locale guarded because of musl)\nif command -sq locale; and string match -qi '*utf-8*' -- (locale)\n    echo \\uFEFF\"echo bom_test\" | source\nelse\n    echo \"echo bom_test\" | source\nend\n#CHECK: bom_test\n\n# Comments abutting text (#953)\necho not#a#comment\n#CHECK: not#a#comment\necho is # a # comment\n#CHECK: is\n\n# Test that our builtins can all do --query\ncommand --query cp\necho $status\n#CHECK: 0\n\ntype --query cp\necho $status\n#CHECK: 0\n\njobs --query 0\necho $status\n#CHECK: 1\n\nabbr --query thisshouldnotbeanabbreviationohmygoshitssolongwhywouldanyoneeverusethis\necho $status\n#CHECK: 1\n\nfunctions --query alias\necho $status\n#CHECK: 0\n\nset --query status\necho $status\n#CHECK: 0\n\nbuiltin --query echo\necho $status\n#CHECK: 0\n\n# Check that echo doesn't interpret options *and print them*\n# at the start of quoted args:\necho '-ne \\tart'\n# CHECK: -ne \\tart\necho '-n art'\necho banana\n# CHECK: -n art\n# CHECK: banana\n\n# This used to be a parse error - #7685.\necho (echo hello\\\\)\n# CHECK: hello\\\n\n# This used to be a parse error - #7866.\necho (echo foo;#)\n     )\n# CHECK: foo\necho (echo bar #'\n     )\n# CHECK: bar\necho (#\"\n      echo baz)\n# CHECK: baz\n\n# Make sure we don't match up brackets within comments (#8022).\n$fish -c 'echo f[oo # not valid, no matching ]'\n# CHECKERR: fish: Unexpected end of string, square brackets do not match\n# CHECKERR: echo f[oo # not valid, no matching ]\n# CHECKERR: {{      }}^\n\n# Should fail because $PWD is read-only.\nfor PWD in foo bar\n    true\nend\n# CHECKERR: {{.*}}/basic.fish (line {{\\d+}}): for: PWD: cannot overwrite read-only variable\n# CHECKERR: for PWD in foo bar\n# CHECKERR:     ^~^\n# XXX FIXME carat should point at PWD\n\n$fish -c 'echo \\xtest'\n# CHECKERR: fish: Invalid token '\\xtest'\n# CHECKERR: echo \\xtest\n# CHECKERR:      ^~~~~^\n\n$fish -c 'echo \\utest'\n# CHECKERR: fish: Invalid token '\\utest'\n# CHECKERR: echo \\utest\n# CHECKERR:      ^~~~~^\n\n$fish -c 'echo \\c'\n# CHECKERR: fish: Incomplete escape sequence '\\c'\n# CHECKERR: echo \\c\n# CHECKERR:      ^^\n\n$fish -c 'echo \\C'\n# CHECK: C\n\n$fish -c 'echo \\U'\n# CHECKERR: fish: Incomplete escape sequence '\\U'\n# CHECKERR: echo \\U\n# CHECKERR:      ^^\n\n$fish -c 'echo \\x'\n# CHECKERR: fish: Incomplete escape sequence '\\x'\n# CHECKERR: echo \\x\n# CHECKERR:      ^^\n\nprintf '%s\\n' \"#!/bin/sh\" 'echo $0' > $tmpdir/argv0.sh\nchmod +x $tmpdir/argv0.sh\ncd $tmpdir\n./argv0.sh\n# CHECK: ./argv0.sh\n"], "fixing_code": ["// Various functions, mostly string utilities, that are used by most parts of fish.\n#include \"config.h\"\n\n#ifdef HAVE_BACKTRACE_SYMBOLS\n#include <cxxabi.h>\n#endif\n\n#include <ctype.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <sys/time.h>\n#include <termios.h>\n#include <unistd.h>\n\n#ifdef HAVE_EXECINFO_H\n#include <execinfo.h>\n#endif\n\n#ifdef __linux__\n// Includes for WSL detection\n#include <sys/utsname.h>\n#endif\n\n#include <algorithm>\n#include <csignal>\n#include <cstdlib>\n#include <cstring>\n#include <cwchar>\n#include <memory>\n\n#include \"common.h\"\n#include \"expand.h\"\n#include \"fallback.h\"  // IWYU pragma: keep\n#include \"flog.h\"\n#include \"future_feature_flags.h\"\n#include \"global_safety.h\"\n#include \"iothread.h\"\n#include \"signal.h\"\n#include \"termsize.h\"\n#include \"topic_monitor.h\"\n#include \"wcstringutil.h\"\n#include \"wildcard.h\"\n#include \"wutil.h\"  // IWYU pragma: keep\n\n// Keep after \"common.h\"\n#ifdef HAVE_SYS_SYSCTL_H\n#include <sys/sysctl.h>  // IWYU pragma: keep\n#endif\n#if defined(__APPLE__)\n#include <mach-o/dyld.h>  // IWYU pragma: keep\n#endif\n\nstruct termios shell_modes;\n\nconst wcstring g_empty_string{};\n\n/// This allows us to notice when we've forked.\nstatic relaxed_atomic_bool_t is_forked_proc{false};\n/// This allows us to bypass the main thread checks\nstatic relaxed_atomic_bool_t thread_asserts_cfg_for_testing{false};\n\nstatic relaxed_atomic_t<wchar_t> ellipsis_char;\nwchar_t get_ellipsis_char() { return ellipsis_char; }\n\nstatic relaxed_atomic_t<const wchar_t *> ellipsis_str;\nconst wchar_t *get_ellipsis_str() { return ellipsis_str; }\n\nstatic relaxed_atomic_t<const wchar_t *> omitted_newline_str;\nconst wchar_t *get_omitted_newline_str() { return omitted_newline_str; }\n\nstatic relaxed_atomic_t<int> omitted_newline_width;\nint get_omitted_newline_width() { return omitted_newline_width; }\n\nstatic relaxed_atomic_t<wchar_t> obfuscation_read_char;\nwchar_t get_obfuscation_read_char() { return obfuscation_read_char; }\n\nbool g_profiling_active = false;\n\nconst wchar_t *program_name;\n\n/// Be able to restore the term's foreground process group.\n/// This is set during startup and not modified after.\nstatic relaxed_atomic_t<pid_t> initial_fg_process_group{-1};\n\n#if defined(OS_IS_CYGWIN) || defined(WSL)\n// MS Windows tty devices do not currently have either a read or write timestamp. Those\n// respective fields of `struct stat` are always the current time. Which means we can't\n// use them. So we assume no external program has written to the terminal behind our\n// back. This makes multiline promptusable. See issue #2859 and\n// https://github.com/Microsoft/BashOnWindows/issues/545\nconst bool has_working_tty_timestamps = false;\n#else\nconst bool has_working_tty_timestamps = true;\n#endif\n\n/// Convert a character to its integer equivalent if it is a valid character for the requested base.\n/// Return the integer value if it is valid else -1.\nlong convert_digit(wchar_t d, int base) {\n    long res = -1;\n    if ((d <= L'9') && (d >= L'0')) {\n        res = d - L'0';\n    } else if ((d <= L'z') && (d >= L'a')) {\n        res = d + 10 - L'a';\n    } else if ((d <= L'Z') && (d >= L'A')) {\n        res = d + 10 - L'A';\n    }\n    if (res >= base) {\n        res = -1;\n    }\n\n    return res;\n}\n\n/// Test whether the char is a valid hex digit as used by the `escape_string_*()` functions.\nstatic bool is_hex_digit(int c) { return std::strchr(\"0123456789ABCDEF\", c) != nullptr; }\n\n/// This is a specialization of `convert_digit()` that only handles base 16 and only uppercase.\nstatic long convert_hex_digit(wchar_t d) {\n    if ((d <= L'9') && (d >= L'0')) {\n        return d - L'0';\n    } else if ((d <= L'Z') && (d >= L'A')) {\n        return 10 + d - L'A';\n    }\n\n    return -1;\n}\n\nbool is_windows_subsystem_for_linux() {\n#if defined(WSL)\n    return true;\n#elif not defined(__linux__)\n    return false;\n#else\n    // We are purposely not using std::call_once as it may invoke locking, which is an unnecessary\n    // overhead since there's no actual race condition here - even if multiple threads call this\n    // routine simultaneously the first time around, we just end up needlessly querying uname(2) one\n    // more time.\n\n    static bool wsl_state = [] {\n        utsname info;\n        uname(&info);\n\n        // Sample utsname.release under WSL, testing for something like `4.4.0-17763-Microsoft`\n        if (std::strstr(info.release, \"Microsoft\") != nullptr) {\n            const char *dash = std::strchr(info.release, '-');\n            if (dash == nullptr || strtod(dash + 1, nullptr) < 17763) {\n                // #5298, #5661: There are acknowledged, published, and (later) fixed issues with\n                // job control under early WSL releases that prevent fish from running correctly,\n                // with unexpected failures when piping. Fish 3.0 nightly builds worked around this\n                // issue with some needlessly complicated code that was later stripped from the\n                // fish 3.0 release, so we just bail. Note that fish 2.0 was also broken, but we\n                // just didn't warn about it.\n\n                // #6038 & 5101bde: It's been requested that there be some sort of way to disable\n                // this check: if the environment variable FISH_NO_WSL_CHECK is present, this test\n                // is bypassed. We intentionally do not include this in the error message because\n                // it'll only allow fish to run but not to actually work. Here be dragons!\n                if (getenv(\"FISH_NO_WSL_CHECK\") == nullptr) {\n                    FLOGF(error,\n                          \"This version of WSL has known bugs that prevent fish from working.\"\n                          \"Please upgrade to Windows 10 1809 (17763) or higher to use fish!\");\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }();\n\n    // Subsequent calls to this function may take place after fork() and before exec() in\n    // postfork.cpp. Make sure we never dynamically allocate any memory in the fast path!\n    return wsl_state;\n#endif\n}\n\n#ifdef HAVE_BACKTRACE_SYMBOLS\n// This function produces a stack backtrace with demangled function & method names. It is based on\n// https://gist.github.com/fmela/591333 but adapted to the style of the fish project.\n[[gnu::noinline]] static wcstring_list_t demangled_backtrace(int max_frames, int skip_levels) {\n    void *callstack[128];\n    const int n_max_frames = sizeof(callstack) / sizeof(callstack[0]);\n    int n_frames = backtrace(callstack, n_max_frames);\n    char **symbols = backtrace_symbols(callstack, n_frames);\n    wchar_t text[1024];\n    wcstring_list_t backtrace_text;\n\n    if (skip_levels + max_frames < n_frames) n_frames = skip_levels + max_frames;\n\n    for (int i = skip_levels; i < n_frames; i++) {\n        Dl_info info;\n        if (dladdr(callstack[i], &info) && info.dli_sname) {\n            char *demangled = nullptr;\n            int status = -1;\n            if (info.dli_sname[0] == '_')\n                demangled = abi::__cxa_demangle(info.dli_sname, nullptr, nullptr, &status);\n            swprintf(text, sizeof(text) / sizeof(wchar_t), L\"%-3d %s + %td\", i - skip_levels,\n                     status == 0                 ? demangled\n                     : info.dli_sname == nullptr ? symbols[i]\n                                                 : info.dli_sname,\n                     static_cast<char *>(callstack[i]) - static_cast<const char *>(info.dli_saddr));\n            free(demangled);\n        } else {\n            swprintf(text, sizeof(text) / sizeof(wchar_t), L\"%-3d %s\", i - skip_levels, symbols[i]);\n        }\n        backtrace_text.push_back(text);\n    }\n    free(symbols);\n    return backtrace_text;\n}\n\n[[gnu::noinline]] void show_stackframe(int frame_count, int skip_levels) {\n    if (frame_count < 1) return;\n\n    wcstring_list_t bt = demangled_backtrace(frame_count, skip_levels + 2);\n    FLOG(error, L\"Backtrace:\\n\" + join_strings(bt, L'\\n') + L'\\n');\n}\n\n#else   // HAVE_BACKTRACE_SYMBOLS\n\n[[gnu::noinline]] void show_stackframe(int, int) {\n    FLOGF(error, L\"Sorry, but your system does not support backtraces\");\n}\n#endif  // HAVE_BACKTRACE_SYMBOLS\n\n/// \\return the smallest pointer in the range [start, start + len] which is aligned to Align.\n/// If there is no such pointer, return \\p start + len.\n/// alignment must be a power of 2 and in range [1, 64].\n/// This is intended to return the end point of the \"unaligned prefix\" of a vectorized loop.\ntemplate <size_t Align>\nstatic inline const char *align_start(const char *start, size_t len) {\n    static_assert(Align >= 1 && Align <= 64, \"Alignment must be in range [1, 64]\");\n    static_assert((Align & (Align - 1)) == 0, \"Alignment must be power of 2\");\n    uintptr_t startu = reinterpret_cast<uintptr_t>(start);\n    // How much do we have to add to start to make it 0 mod Align?\n    // To compute 17 up-aligned by 8, compute its skew 17 % 8, yielding 1,\n    // and then we will add 8 - 1. Of course if we align 16 with the same idea, we will\n    // add 8 instead of 0, so then mod the sum by Align again.\n    // Note all of these mods are optimized to masks.\n    uintptr_t add_which_aligns = Align - (startu % Align);\n    add_which_aligns %= Align;\n    // Add that much but not more than len. If we add 'add_which_aligns' we may overflow the\n    // pointer.\n    return start + std::min(static_cast<size_t>(add_which_aligns), len);\n}\n\n/// \\return the largest pointer in the range [start, start + len] which is aligned to Align.\n/// If there is no such pointer, return \\p start.\n/// This is intended to be the start point of the \"unaligned suffix\" of a vectorized loop.\ntemplate <size_t Align>\nstatic inline const char *align_end(const char *start, size_t len) {\n    static_assert(Align >= 1 && Align <= 64, \"Alignment must be in range [1, 64]\");\n    static_assert((Align & (Align - 1)) == 0, \"Alignment must be power of 2\");\n    // How much do we have to subtract to align it? Its value, mod Align.\n    uintptr_t endu = reinterpret_cast<uintptr_t>(start + len);\n    uintptr_t sub_which_aligns = endu % Align;\n    return start + len - std::min(static_cast<size_t>(sub_which_aligns), len);\n}\n\n/// \\return the count of initial characters in \\p in which are ASCII.\nstatic size_t count_ascii_prefix(const char *in, size_t in_len) {\n    // We'll use aligned reads of this type.\n    using WordType = uint32_t;\n    const char *aligned_start = align_start<alignof(WordType)>(in, in_len);\n    const char *aligned_end = align_end<alignof(WordType)>(in, in_len);\n\n    // Consume the unaligned prefix.\n    for (const char *cursor = in; cursor < aligned_start; cursor++) {\n        if (cursor[0] & 0x80) return &cursor[0] - in;\n    }\n\n    // Consume the aligned middle.\n    for (const char *cursor = aligned_start; cursor < aligned_end; cursor += sizeof(WordType)) {\n        if (*reinterpret_cast<const WordType *>(cursor) & 0x80808080) {\n            if (cursor[0] & 0x80) return &cursor[0] - in;\n            if (cursor[1] & 0x80) return &cursor[1] - in;\n            if (cursor[2] & 0x80) return &cursor[2] - in;\n            return &cursor[3] - in;\n        }\n    }\n\n    // Consume the unaligned suffix.\n    for (const char *cursor = aligned_end; cursor < in + in_len; cursor++) {\n        if (cursor[0] & 0x80) return &cursor[0] - in;\n    }\n    return in_len;\n}\n\n/// Converts the narrow character string \\c in into its wide equivalent, and return it.\n///\n/// The string may contain embedded nulls.\n///\n/// This function encodes illegal character sequences in a reversible way using the private use\n/// area.\nstatic wcstring str2wcs_internal(const char *in, const size_t in_len) {\n    if (in_len == 0) return wcstring();\n    assert(in != nullptr);\n\n    wcstring result;\n    result.reserve(in_len);\n\n    size_t in_pos = 0;\n    mbstate_t state = {};\n    while (in_pos < in_len) {\n        // Append any initial sequence of ascii characters.\n        // Note we do not support character sets which are not supersets of ASCII.\n        size_t ascii_prefix_length = count_ascii_prefix(&in[in_pos], in_len - in_pos);\n        result.insert(result.end(), &in[in_pos], &in[in_pos + ascii_prefix_length]);\n        in_pos += ascii_prefix_length;\n        assert(in_pos <= in_len && \"Position overflowed length\");\n        if (in_pos == in_len) break;\n\n        // We have found a non-ASCII character.\n        bool use_encode_direct = false;\n        size_t ret = 0;\n        wchar_t wc = 0;\n\n        if (false) {\n#if defined(HAVE_BROKEN_MBRTOWC_UTF8)\n        } else if ((in[in_pos] & 0xF8) == 0xF8) {\n            // Protect against broken std::mbrtowc() implementations which attempt to encode UTF-8\n            // sequences longer than four bytes (e.g., OS X Snow Leopard).\n            use_encode_direct = true;\n#endif\n        } else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)\n                   (in[in_pos] & 0xF8) == 0xF0) {\n            // Assume we are in a UTF-16 environment (e.g., Cygwin) using a UTF-8 encoding.\n            // The bits set check will be true for a four byte UTF-8 sequence that requires\n            // two UTF-16 chars. Something that doesn't work with our simple use of std::mbrtowc().\n            use_encode_direct = true;\n        } else {\n            ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);\n            // Determine whether to encode this character with our crazy scheme.\n            if (fish_reserved_codepoint(wc)) {\n                use_encode_direct = true;\n            } else if (ret == static_cast<size_t>(-2)) {\n                // Incomplete sequence.\n                use_encode_direct = true;\n            } else if (ret == static_cast<size_t>(-1)) {\n                // Invalid data.\n                use_encode_direct = true;\n            } else if (ret > in_len - in_pos) {\n                // Other error codes? Terrifying, should never happen.\n                use_encode_direct = true;\n            } else if (sizeof(wchar_t) == 2 && wc >= 0xD800 &&  //!OCLINT(constant if expression)\n                       wc <= 0xDFFF) {\n                // If we get a surrogate pair char on a UTF-16 system (e.g., Cygwin) then\n                // it's guaranteed the UTF-8 decoding is wrong so use direct encoding.\n                use_encode_direct = true;\n            }\n        }\n\n        if (use_encode_direct) {\n            wc = ENCODE_DIRECT_BASE + static_cast<unsigned char>(in[in_pos]);\n            result.push_back(wc);\n            in_pos++;\n            std::memset(&state, 0, sizeof state);\n        } else if (ret == 0) {  // embedded null byte!\n            result.push_back(L'\\0');\n            in_pos++;\n            std::memset(&state, 0, sizeof state);\n        } else {  // normal case\n            result.push_back(wc);\n            in_pos += ret;\n        }\n    }\n\n    return result;\n}\n\nwcstring str2wcstring(const char *in, size_t len) { return str2wcs_internal(in, len); }\n\nwcstring str2wcstring(const char *in) { return str2wcs_internal(in, std::strlen(in)); }\n\nwcstring str2wcstring(const std::string &in) {\n    // Handles embedded nulls!\n    return str2wcs_internal(in.data(), in.size());\n}\n\nwcstring str2wcstring(const std::string &in, size_t len) {\n    // Handles embedded nulls!\n    return str2wcs_internal(in.data(), len);\n}\n\nstd::string wcs2string(const wcstring &input) { return wcs2string(input.data(), input.size()); }\n\nstd::string wcs2string(const wchar_t *in, size_t len) {\n    if (len == 0) return std::string{};\n    std::string result;\n    wcs2string_appending(in, len, &result);\n    return result;\n}\n\nvoid wcs2string_appending(const wchar_t *in, size_t len, std::string *receiver) {\n    assert(receiver && \"Null receiver\");\n    receiver->reserve(receiver->size() + len);\n    wcs2string_callback(in, len, [&](const char *buff, size_t bufflen) {\n        receiver->append(buff, bufflen);\n        return true;\n    });\n}\n\n/// Test if the character can be encoded using the current locale.\nstatic bool can_be_encoded(wchar_t wc) {\n    char converted[MB_LEN_MAX];\n    mbstate_t state = {};\n\n    return std::wcrtomb(converted, wc, &state) != static_cast<size_t>(-1);\n}\n\nwcstring format_string(const wchar_t *format, ...) {\n    va_list va;\n    va_start(va, format);\n    wcstring result = vformat_string(format, va);\n    va_end(va);\n    return result;\n}\n\nvoid append_formatv(wcstring &target, const wchar_t *format, va_list va_orig) {\n    const int saved_err = errno;\n    // As far as I know, there is no way to check if a vswprintf-call failed because of a badly\n    // formated string option or because the supplied destination string was to small. In GLIBC,\n    // errno seems to be set to EINVAL either way.\n    //\n    // Because of this, on failure we try to increase the buffer size until the free space is\n    // larger than max_size, at which point it will conclude that the error was probably due to a\n    // badly formated string option, and return an error. Make sure to null terminate string before\n    // that, though.\n    const size_t max_size = (128 * 1024 * 1024);\n    wchar_t static_buff[256];\n    size_t size = 0;\n    wchar_t *buff = nullptr;\n    int status = -1;\n    while (status < 0) {\n        // Reallocate if necessary.\n        if (size == 0) {\n            buff = static_buff;\n            size = sizeof static_buff;\n        } else {\n            size *= 2;\n            if (size >= max_size) {\n                buff[0] = '\\0';\n                break;\n            }\n            buff = static_cast<wchar_t *>(realloc((buff == static_buff ? nullptr : buff), size));\n            assert(buff != nullptr);\n        }\n\n        // Try printing.\n        va_list va;\n        va_copy(va, va_orig);\n        status = std::vswprintf(buff, size / sizeof(wchar_t), format, va);\n        va_end(va);\n    }\n\n    target.append(buff);\n\n    if (buff != static_buff) {\n        free(buff);\n    }\n\n    errno = saved_err;\n}\n\nwcstring vformat_string(const wchar_t *format, va_list va_orig) {\n    wcstring result;\n    append_formatv(result, format, va_orig);\n    return result;\n}\n\nvoid append_format(wcstring &str, const wchar_t *format, ...) {\n    va_list va;\n    va_start(va, format);\n    append_formatv(str, format, va);\n    va_end(va);\n}\n\nconst wchar_t *quote_end(const wchar_t *pos, wchar_t quote) {\n    while (true) {\n        pos++;\n\n        if (!*pos) return nullptr;\n\n        if (*pos == L'\\\\') {\n            pos++;\n            if (!*pos) return nullptr;\n        } else {\n            if (*pos == quote ||\n                // Command substitutions also end a double quoted string.  This is how we\n                // support command substitutions inside double quotes.\n                (quote == L'\"' && *pos == L'$' && *(pos + 1) == L'(')) {\n                return pos;\n            }\n        }\n    }\n    return nullptr;\n}\n\nconst wchar_t *comment_end(const wchar_t *pos) {\n    do {\n        pos++;\n    } while (*pos && *pos != L'\\n');\n    return pos;\n}\n\nvoid fish_setlocale() {\n    // Use various Unicode symbols if they can be encoded using the current locale, else a simple\n    // ASCII char alternative. All of the can_be_encoded() invocations should return the same\n    // true/false value since the code points are in the BMP but we're going to be paranoid. This\n    // is also technically wrong if we're not in a Unicode locale but we expect (or hope)\n    // can_be_encoded() will return false in that case.\n    if (can_be_encoded(L'\\u2026')) {\n        ellipsis_char = L'\\u2026';\n        ellipsis_str = L\"\\u2026\";\n    } else {\n        ellipsis_char = L'$';  // \"horizontal ellipsis\"\n        ellipsis_str = L\"...\";\n    }\n\n    if (is_windows_subsystem_for_linux()) {\n        // neither of \\u23CE and \\u25CF can be displayed in the default fonts on Windows, though\n        // they can be *encoded* just fine. Use alternative glyphs.\n        omitted_newline_str = L\"\\u00b6\";  // \"pilcrow\"\n        omitted_newline_width = 1;\n        obfuscation_read_char = L'\\u2022';  // \"bullet\"\n    } else if (is_console_session()) {\n        omitted_newline_str = L\"^J\";\n        omitted_newline_width = 2;\n        obfuscation_read_char = L'*';\n    } else {\n        if (can_be_encoded(L'\\u23CE')) {\n            omitted_newline_str = L\"\\u23CE\";  // \"return symbol\" (\u23ce)\n            omitted_newline_width = 1;\n        } else {\n            omitted_newline_str = L\"^J\";\n            omitted_newline_width = 2;\n        }\n        obfuscation_read_char = can_be_encoded(L'\\u25CF') ? L'\\u25CF' : L'#';  // \"black circle\"\n    }\n}\n\nlong read_blocked(int fd, void *buf, size_t count) {\n    ssize_t res;\n    do {\n        res = read(fd, buf, count);\n    } while (res < 0 && errno == EINTR);\n    return res;\n}\n\n/// Loop a write request while failure is non-critical. Return -1 and set errno in case of critical\n/// error.\nssize_t write_loop(int fd, const char *buff, size_t count) {\n    size_t out_cum = 0;\n    while (out_cum < count) {\n        ssize_t out = write(fd, &buff[out_cum], count - out_cum);\n        if (out < 0) {\n            if (errno != EAGAIN && errno != EINTR) {\n                return -1;\n            }\n        } else {\n            out_cum += static_cast<size_t>(out);\n        }\n    }\n    return static_cast<ssize_t>(out_cum);\n}\n\nssize_t read_loop(int fd, void *buff, size_t count) {\n    ssize_t result;\n    do {\n        result = read(fd, buff, count);\n    } while (result < 0 && (errno == EAGAIN || errno == EINTR));\n    return result;\n}\n\n/// Hack to not print error messages in the tests. Do not call this from functions in this module\n/// like `debug()`. It is only intended to suppress diagnostic noise from testing things like the\n/// fish parser where we expect a lot of diagnostic messages due to testing error conditions.\nbool should_suppress_stderr_for_tests() {\n    return program_name && !std::wcscmp(program_name, TESTS_PROGRAM_NAME);\n}\n\n// Careful to not negate LLONG_MIN.\nstatic unsigned long long absolute_value(long long x) {\n    if (x >= 0) return static_cast<unsigned long long>(x);\n    x = -(x + 1);\n    return static_cast<unsigned long long>(x) + 1;\n}\n\ntemplate <typename CharT>\nstatic void format_safe_impl(CharT *buff, size_t size, unsigned long long val) {\n    size_t idx = 0;\n    if (val == 0) {\n        buff[idx++] = '0';\n    } else {\n        // Generate the string backwards, then reverse it.\n        while (val != 0) {\n            buff[idx++] = (val % 10) + '0';\n            val /= 10;\n        }\n        std::reverse(buff, buff + idx);\n    }\n    buff[idx++] = '\\0';\n    assert(idx <= size && \"Buffer overflowed\");\n}\n\nvoid format_long_safe(char buff[64], long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_long_safe(wchar_t buff[64], long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_llong_safe(wchar_t buff[64], long long val) {\n    unsigned long long uval = absolute_value(val);\n    if (val >= 0) {\n        format_safe_impl(buff, 64, uval);\n    } else {\n        buff[0] = '-';\n        format_safe_impl(buff + 1, 63, uval);\n    }\n}\n\nvoid format_ullong_safe(wchar_t buff[64], unsigned long long val) {\n    return format_safe_impl(buff, 64, val);\n}\n\nvoid narrow_string_safe(char buff[64], const wchar_t *s) {\n    size_t idx = 0;\n    for (size_t widx = 0; s[widx] != L'\\0'; widx++) {\n        wchar_t c = s[widx];\n        if (c <= 127) {\n            buff[idx++] = char(c);\n            if (idx + 1 == 64) {\n                break;\n            }\n        }\n    }\n    buff[idx] = '\\0';\n}\n\nwcstring reformat_for_screen(const wcstring &msg, const termsize_t &termsize) {\n    wcstring buff;\n\n    int screen_width = termsize.width;\n\n    if (screen_width) {\n        const wchar_t *start = msg.c_str();\n        const wchar_t *pos = start;\n        int line_width = 0;\n        while (true) {\n            int overflow = 0;\n\n            int tok_width = 0;\n\n            // Tokenize on whitespace, and also calculate the width of the token.\n            while (*pos && (!std::wcschr(L\" \\n\\r\\t\", *pos))) {\n                // Check is token is wider than one line. If so we mark it as an overflow and break\n                // the token.\n                if ((tok_width + fish_wcwidth(*pos)) > (screen_width - 1)) {\n                    overflow = 1;\n                    break;\n                }\n\n                tok_width += fish_wcwidth(*pos);\n                pos++;\n            }\n\n            // If token is zero character long, we don't do anything.\n            if (pos == start) {\n                pos = pos + 1;\n            } else if (overflow) {\n                // In case of overflow, we print a newline, except if we already are at position 0.\n                wcstring token = msg.substr(start - msg.c_str(), pos - start);\n                if (line_width != 0) buff.push_back(L'\\n');\n                buff.append(format_string(L\"%ls-\\n\", token.c_str()));\n                line_width = 0;\n            } else {\n                // Print the token.\n                wcstring token = msg.substr(start - msg.c_str(), pos - start);\n                if ((line_width + (line_width != 0 ? 1 : 0) + tok_width) > screen_width) {\n                    buff.push_back(L'\\n');\n                    line_width = 0;\n                }\n                buff.append(format_string(L\"%ls%ls\", line_width ? L\" \" : L\"\", token.c_str()));\n                line_width += (line_width != 0 ? 1 : 0) + tok_width;\n            }\n\n            // Break on end of string.\n            if (!*pos) {\n                break;\n            }\n\n            start = pos;\n        }\n    } else {\n        buff.append(msg);\n    }\n    buff.push_back(L'\\n');\n    return buff;\n}\n\n/// Escape a string in a fashion suitable for using as a URL. Store the result in out_str.\nstatic void escape_string_url(const wcstring &in, wcstring &out) {\n    const std::string narrow = wcs2string(in);\n    for (auto &c1 : narrow) {\n        // This silliness is so we get the correct result whether chars are signed or unsigned.\n        unsigned int c2 = static_cast<unsigned int>(c1) & 0xFF;\n        if (!(c2 & 0x80) &&\n            (isalnum(c2) || c2 == '/' || c2 == '.' || c2 == '~' || c2 == '-' || c2 == '_')) {\n            // The above characters don't need to be encoded.\n            out.push_back(static_cast<wchar_t>(c2));\n        } else {\n            // All other chars need to have their UTF-8 representation encoded in hex.\n            wchar_t buf[4];\n            swprintf(buf, sizeof buf / sizeof buf[0], L\"%%%02X\", c2);\n            out.append(buf);\n        }\n    }\n}\n\n/// Reverse the effects of `escape_string_url()`. By definition the string has consist of just ASCII\n/// chars.\nstatic bool unescape_string_url(const wchar_t *in, wcstring *out) {\n    std::string result;\n    result.reserve(out->size());\n    for (wchar_t c = *in; c; c = *++in) {\n        if (c > 0x7F) return false;  // invalid character means we can't decode the string\n        if (c == '%') {\n            int c1 = in[1];\n            if (c1 == 0) return false;  // found unexpected end of string\n            if (c1 == '%') {\n                result.push_back('%');\n                in++;\n            } else {\n                int c2 = in[2];\n                if (c2 == 0) return false;  // string ended prematurely\n                long d1 = convert_digit(c1, 16);\n                if (d1 < 0) return false;\n                long d2 = convert_digit(c2, 16);\n                if (d2 < 0) return false;\n                result.push_back(16 * d1 + d2);\n                in += 2;\n            }\n        } else {\n            result.push_back(c);\n        }\n    }\n\n    *out = str2wcstring(result);\n    return true;\n}\n\n/// Escape a string in a fashion suitable for using as a fish var name. Store the result in out_str.\nstatic void escape_string_var(const wcstring &in, wcstring &out) {\n    bool prev_was_hex_encoded = false;\n    const std::string narrow = wcs2string(in);\n    for (auto c1 : narrow) {\n        // This silliness is so we get the correct result whether chars are signed or unsigned.\n        unsigned int c2 = static_cast<unsigned int>(c1) & 0xFF;\n        if (!(c2 & 0x80) && isalnum(c2) && (!prev_was_hex_encoded || !is_hex_digit(c2))) {\n            // ASCII alphanumerics don't need to be encoded.\n            if (prev_was_hex_encoded) {\n                out.push_back(L'_');\n                prev_was_hex_encoded = false;\n            }\n            out.push_back(static_cast<wchar_t>(c2));\n        } else if (c2 == '_') {\n            // Underscores are encoded by doubling them.\n            out.append(L\"__\");\n            prev_was_hex_encoded = false;\n        } else {\n            // All other chars need to have their UTF-8 representation encoded in hex.\n            wchar_t buf[4];\n            swprintf(buf, sizeof buf / sizeof buf[0], L\"_%02X\", c2);\n            out.append(buf);\n            prev_was_hex_encoded = true;\n        }\n    }\n    if (prev_was_hex_encoded) {\n        out.push_back(L'_');\n    }\n}\n\n/// Reverse the effects of `escape_string_var()`. By definition the string has consist of just ASCII\n/// chars.\nstatic bool unescape_string_var(const wchar_t *in, wcstring *out) {\n    std::string result;\n    result.reserve(out->size());\n    bool prev_was_hex_encoded = false;\n    for (wchar_t c = *in; c; c = *++in) {\n        if (c > 0x7F) return false;  // invalid character means we can't decode the string\n        if (c == '_') {\n            int c1 = in[1];\n            if (c1 == 0) {\n                if (prev_was_hex_encoded) break;\n                return false;  // found unexpected escape char at end of string\n            }\n            if (c1 == '_') {\n                result.push_back('_');\n                in++;\n            } else if (is_hex_digit(c1)) {\n                int c2 = in[2];\n                if (c2 == 0) return false;  // string ended prematurely\n                long d1 = convert_hex_digit(c1);\n                if (d1 < 0) return false;\n                long d2 = convert_hex_digit(c2);\n                if (d2 < 0) return false;\n                result.push_back(16 * d1 + d2);\n                in += 2;\n                prev_was_hex_encoded = true;\n            }\n            // No \"else\" clause because if the first char after an underscore is not another\n            // underscore or a valid hex character then the underscore is there to improve\n            // readability after we've encoded a character not valid in a var name.\n        } else {\n            result.push_back(c);\n        }\n    }\n\n    *out = str2wcstring(result);\n    return true;\n}\n\nwcstring escape_string_for_double_quotes(wcstring in) {\n    // We need to escape backslashes, double quotes, and dollars only.\n    wcstring result = std::move(in);\n    size_t idx = result.size();\n    while (idx--) {\n        switch (result[idx]) {\n            case L'\\\\':\n            case L'$':\n            case L'\"':\n                result.insert(idx, 1, L'\\\\');\n                break;\n        }\n    }\n    return result;\n}\n\n/// Escape a string in a fashion suitable for using in fish script. Store the result in out_str.\nstatic void escape_string_script(const wchar_t *orig_in, size_t in_len, wcstring &out,\n                                 escape_flags_t flags) {\n    const wchar_t *in = orig_in;\n    const bool escape_printables = !(flags & ESCAPE_NO_PRINTABLES);\n    const bool no_quoted = static_cast<bool>(flags & ESCAPE_NO_QUOTED);\n    const bool no_tilde = static_cast<bool>(flags & ESCAPE_NO_TILDE);\n    const bool no_qmark = feature_test(features_t::qmark_noglob);\n    const bool symbolic = static_cast<bool>(flags & ESCAPE_SYMBOLIC) && (MB_CUR_MAX > 1);\n    assert((!symbolic || !escape_printables) && \"symbolic implies escape-no-printables\");\n\n    bool need_escape = false;\n    bool need_complex_escape = false;\n\n    if (!no_quoted && in_len == 0) {\n        out.assign(L\"''\");\n        return;\n    }\n\n    for (size_t i = 0; i < in_len; i++) {\n        if ((*in >= ENCODE_DIRECT_BASE) && (*in < ENCODE_DIRECT_BASE + 256)) {\n            int val = *in - ENCODE_DIRECT_BASE;\n            int tmp;\n\n            out += L'\\\\';\n            out += L'X';\n\n            tmp = val / 16;\n            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n\n            tmp = val % 16;\n            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n            need_escape = need_complex_escape = true;\n\n        } else {\n            wchar_t c = *in;\n            switch (c) {\n                case L'\\t': {\n                    if (symbolic)\n                        out += L'\u2409';\n                    else\n                        out += L\"\\\\t\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\n': {\n                    if (symbolic)\n                        out += L'\u2424';\n                    else\n                        out += L\"\\\\n\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\b': {\n                    if (symbolic)\n                        out += L'\u2408';\n                    else\n                        out += L\"\\\\b\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\r': {\n                    if (symbolic)\n                        out += L'\u240d';\n                    else\n                        out += L\"\\\\r\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\x1B': {\n                    if (symbolic)\n                        out += L'\u241b';\n                    else\n                        out += L\"\\\\e\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\x7F': {\n                    if (symbolic)\n                        out += L'\u2421';\n                    else\n                        out += L\"\\\\x7f\";\n                    need_escape = need_complex_escape = true;\n                    break;\n                }\n                case L'\\\\':\n                case L'\\'': {\n                    need_escape = need_complex_escape = true;\n                    if (escape_printables || (c == L'\\\\' && !symbolic)) out += L'\\\\';\n                    out += *in;\n                    break;\n                }\n                case ANY_CHAR: {\n                    // See #1614\n                    out += L'?';\n                    break;\n                }\n                case ANY_STRING: {\n                    out += L'*';\n                    break;\n                }\n                case ANY_STRING_RECURSIVE: {\n                    out += L\"**\";\n                    break;\n                }\n\n                case L'&':\n                case L'$':\n                case L' ':\n                case L'#':\n                case L'<':\n                case L'>':\n                case L'(':\n                case L')':\n                case L'[':\n                case L']':\n                case L'{':\n                case L'}':\n                case L'?':\n                case L'*':\n                case L'|':\n                case L';':\n                case L'\"':\n                case L'%':\n                case L'~': {\n                    bool char_is_normal = (c == L'~' && no_tilde) || (c == L'?' && no_qmark);\n                    if (!char_is_normal) {\n                        need_escape = true;\n                        if (escape_printables) out += L'\\\\';\n                    }\n                    out += *in;\n                    break;\n                }\n\n                default: {\n                    if (*in >= 0 && *in < 32) {\n                        need_escape = need_complex_escape = true;\n\n                        if (symbolic) {\n                            out += L'\\u2400' + *in;\n                            break;\n                        }\n\n                        if (*in < 27 && *in != 0) {\n                            out += L'\\\\';\n                            out += L'c';\n                            out += L'a' + *in - 1;\n                            break;\n                        }\n\n                        int tmp = (*in) % 16;\n                        out += L'\\\\';\n                        out += L'x';\n                        out += ((*in > 15) ? L'1' : L'0');\n                        out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;\n                    } else {\n                        out += *in;\n                    }\n                    break;\n                }\n            }\n        }\n\n        in++;\n    }\n\n    // Use quoted escaping if possible, since most people find it easier to read.\n    if (!no_quoted && need_escape && !need_complex_escape && escape_printables) {\n        wchar_t single_quote = L'\\'';\n        out.clear();\n        out.reserve(2 + in_len);\n        out.push_back(single_quote);\n        out.append(orig_in, in_len);\n        out.push_back(single_quote);\n    }\n}\n\n/// Escapes a string for use in a regex string. Not safe for use with `eval` as only\n/// characters reserved by PCRE2 are escaped.\n/// \\param in is the raw string to be searched for literally when substituted in a PCRE2 expression.\nstatic wcstring escape_string_pcre2(const wcstring &in) {\n    wcstring out;\n    out.reserve(in.size() * 1.3);  // a wild guess\n\n    for (auto c : in) {\n        switch (c) {\n            case L'.':\n            case L'^':\n            case L'$':\n            case L'*':\n            case L'+':\n            case L'(':\n            case L')':\n            case L'?':\n            case L'[':\n            case L'{':\n            case L'}':\n            case L'\\\\':\n            case L'|':\n            // these two only *need* to be escaped within a character class, and technically it\n            // makes no sense to ever use process substitution output to compose a character class,\n            // but...\n            case L'-':\n            case L']':\n                out.push_back('\\\\');\n                __fallthrough__\n            default:\n                out.push_back(c);\n        }\n    }\n\n    return out;\n}\n\nwcstring escape_string(const wchar_t *in, escape_flags_t flags, escape_string_style_t style) {\n    wcstring result;\n\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            escape_string_script(in, std::wcslen(in), result, flags);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            escape_string_url(in, result);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            escape_string_var(in, result);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            result = escape_string_pcre2(in);\n            break;\n        }\n    }\n\n    return result;\n}\n\nwcstring escape_string(const wcstring &in, escape_flags_t flags, escape_string_style_t style) {\n    wcstring result;\n\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            escape_string_script(in.c_str(), in.size(), result, flags);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            escape_string_url(in, result);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            escape_string_var(in, result);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            result = escape_string_pcre2(in);\n            break;\n        }\n    }\n\n    return result;\n}\n\n/// Helper to return the last character in a string, or none.\nstatic maybe_t<wchar_t> string_last_char(const wcstring &str) {\n    if (str.empty()) return none();\n    return str.back();\n}\n\n/// Given a null terminated string starting with a backslash, read the escape as if it is unquoted,\n/// appending to result. Return the number of characters consumed, or none on error.\nmaybe_t<size_t> read_unquoted_escape(const wchar_t *input, wcstring *result, bool allow_incomplete,\n                                     bool unescape_special) {\n    assert(input[0] == L'\\\\' && \"Not an escape\");\n\n    // Here's the character we'll ultimately append, or none. Note that L'\\0' is a\n    // valid thing to append.\n    maybe_t<wchar_t> result_char_or_none = none();\n\n    bool errored = false;\n    size_t in_pos = 1;  // in_pos always tracks the next character to read (and therefore the number\n                        // of characters read so far)\n\n    // For multibyte \\X sequences.\n    std::string byte_buff;\n    while (true) {\n        const wchar_t c = input[in_pos++];\n        switch (c) {\n                // A null character after a backslash is an error.\n            case L'\\0': {\n                // Adjust in_pos to only include the backslash.\n                assert(in_pos > 0);\n                in_pos--;\n\n                // It's an error, unless we're allowing incomplete escapes.\n                if (!allow_incomplete) errored = true;\n                break;\n            }\n                // Numeric escape sequences. No prefix means octal escape, otherwise hexadecimal.\n            case L'0':\n            case L'1':\n            case L'2':\n            case L'3':\n            case L'4':\n            case L'5':\n            case L'6':\n            case L'7':\n            case L'u':\n            case L'U':\n            case L'x':\n            case L'X': {\n                long long res = 0;\n                size_t chars = 2;\n                int base = 16;\n                bool byte_literal = false;\n                wchar_t max_val = ASCII_MAX;\n\n                switch (c) {\n                    case L'u': {\n                        chars = 4;\n                        max_val = UCS2_MAX;\n                        break;\n                    }\n                    case L'U': {\n                        chars = 8;\n                        max_val = WCHAR_MAX;\n\n                        // Don't exceed the largest Unicode code point - see #1107.\n                        if (0x10FFFF < max_val) max_val = static_cast<wchar_t>(0x10FFFF);\n                        break;\n                    }\n                    case L'x':\n                    case L'X': {\n                        byte_literal = true;\n                        max_val = BYTE_MAX;\n                        break;\n                    }\n                    default: {\n                        base = 8;\n                        chars = 3;\n                        // Note that in_pos currently is just after the first post-backslash\n                        // character; we want to start our escape from there.\n                        assert(in_pos > 0);\n                        in_pos--;\n                        break;\n                    }\n                }\n\n                for (size_t i = 0; i < chars; i++) {\n                    long d = convert_digit(input[in_pos], base);\n                    if (d < 0) {\n                        // If we have no digit, this is a tokenizer error.\n                        if (i == 0) errored = true;\n                        break;\n                    }\n\n                    res = (res * base) + d;\n                    in_pos++;\n                }\n\n                if (!errored && res <= max_val) {\n                    if (byte_literal) {\n                        // Multibyte encodings necessitate that we keep adjacent byte escapes.\n                        // - `\\Xc3\\Xb6` is \"\u00f6\", but only together.\n                        // (this assumes a valid codepoint can't consist of multiple bytes\n                        // that are valid on their own, which is true for UTF-8)\n                        byte_buff.push_back(static_cast<char>(res));\n                        result_char_or_none = none();\n                        if (input[in_pos] == L'\\\\'\n                            && (input[in_pos + 1] == L'X' || input[in_pos + 1] == L'x')) {\n                            in_pos++;\n                            continue;\n                        }\n                    } else {\n                        result_char_or_none = static_cast<wchar_t>(res);\n                    }\n                } else {\n                    errored = true;\n                }\n\n                break;\n            }\n                // \\a means bell (alert).\n            case L'a': {\n                result_char_or_none = L'\\a';\n                break;\n            }\n                // \\b means backspace.\n            case L'b': {\n                result_char_or_none = L'\\b';\n                break;\n            }\n                // \\cX means control sequence X.\n            case L'c': {\n                const wchar_t sequence_char = input[in_pos++];\n                if (sequence_char >= L'a' && sequence_char <= (L'a' + 32)) {\n                    result_char_or_none = sequence_char - L'a' + 1;\n                } else if (sequence_char >= L'A' && sequence_char <= (L'A' + 32)) {\n                    result_char_or_none = sequence_char - L'A' + 1;\n                } else {\n                    errored = true;\n                }\n                break;\n            }\n                // \\x1B means escape.\n            case L'e': {\n                result_char_or_none = L'\\x1B';\n                break;\n            }\n                // \\f means form feed.\n            case L'f': {\n                result_char_or_none = L'\\f';\n                break;\n            }\n                // \\n means newline.\n            case L'n': {\n                result_char_or_none = L'\\n';\n                break;\n            }\n                // \\r means carriage return.\n            case L'r': {\n                result_char_or_none = L'\\r';\n                break;\n            }\n                // \\t means tab.\n            case L't': {\n                result_char_or_none = L'\\t';\n                break;\n            }\n                // \\v means vertical tab.\n            case L'v': {\n                result_char_or_none = L'\\v';\n                break;\n            }\n                // If a backslash is followed by an actual newline, swallow them both.\n            case L'\\n': {\n                result_char_or_none = none();\n                break;\n            }\n            default: {\n                if (unescape_special) result->push_back(INTERNAL_SEPARATOR);\n                result_char_or_none = c;\n                break;\n            }\n        }\n\n        if (errored) return none();\n\n        if (!byte_buff.empty()) {\n            result->append(str2wcstring(byte_buff));\n        }\n\n        break;\n    }\n\n    if (result_char_or_none.has_value()) {\n        if (fish_reserved_codepoint(*result_char_or_none)) {\n            return none();\n        }\n        result->push_back(*result_char_or_none);\n    }\n\n    return in_pos;\n}\n\n/// Returns the unescaped version of input_str into output_str (by reference). Returns true if\n/// successful. If false, the contents of output_str are unchanged.\nstatic bool unescape_string_internal(const wchar_t *const input, const size_t input_len,\n                                     wcstring *output_str, unescape_flags_t flags) {\n    // Set up result string, which we'll swap with the output on success.\n    wcstring result;\n    result.reserve(input_len);\n\n    const bool unescape_special = static_cast<bool>(flags & UNESCAPE_SPECIAL);\n    const bool allow_incomplete = static_cast<bool>(flags & UNESCAPE_INCOMPLETE);\n    const bool ignore_backslashes = static_cast<bool>(flags & UNESCAPE_NO_BACKSLASHES);\n\n    // The positions of open braces.\n    std::vector<size_t> braces;\n    // The positions of variable expansions or brace \",\"s.\n    // We only read braces as expanders if there's a variable expansion or \",\" in them.\n    std::vector<size_t> vars_or_seps;\n    int brace_count = 0;\n\n    bool errored = false;\n    enum {\n        mode_unquoted,\n        mode_single_quotes,\n        mode_double_quotes,\n    } mode = mode_unquoted;\n\n    for (size_t input_position = 0; input_position < input_len && !errored; input_position++) {\n        const wchar_t c = input[input_position];\n        // Here's the character we'll append to result, or none() to suppress it.\n        maybe_t<wchar_t> to_append_or_none = c;\n        if (mode == mode_unquoted) {\n            switch (c) {\n                case L'\\\\': {\n                    if (!ignore_backslashes) {\n                        // Backslashes (escapes) are complicated and may result in errors, or\n                        // appending INTERNAL_SEPARATORs, so we have to handle them specially.\n                        auto escape_chars = read_unquoted_escape(\n                            input + input_position, &result, allow_incomplete, unescape_special);\n                        if (!escape_chars.has_value()) {\n                            // A none() return indicates an error.\n                            errored = true;\n                        } else {\n                            // Skip over the characters we read, minus one because the outer loop\n                            // will increment it.\n                            assert(*escape_chars > 0);\n                            input_position += *escape_chars - 1;\n                        }\n                        // We've already appended, don't append anything else.\n                        to_append_or_none = none();\n                    }\n                    break;\n                }\n                case L'~': {\n                    if (unescape_special && (input_position == 0)) {\n                        to_append_or_none = HOME_DIRECTORY;\n                    }\n                    break;\n                }\n                case L'%': {\n                    // Note that this only recognizes %self if the string is literally %self.\n                    // %self/foo will NOT match this.\n                    if (unescape_special && input_position == 0 &&\n                        !std::wcscmp(input, PROCESS_EXPAND_SELF_STR)) {\n                        to_append_or_none = PROCESS_EXPAND_SELF;\n                        input_position += PROCESS_EXPAND_SELF_STR_LEN - 1;  // skip over 'self's\n                    }\n                    break;\n                }\n                case L'*': {\n                    if (unescape_special) {\n                        // In general, this is ANY_STRING. But as a hack, if the last appended char\n                        // is ANY_STRING, delete the last char and store ANY_STRING_RECURSIVE to\n                        // reflect the fact that ** is the recursive wildcard.\n                        if (string_last_char(result) == ANY_STRING) {\n                            assert(!result.empty());\n                            result.resize(result.size() - 1);\n                            to_append_or_none = ANY_STRING_RECURSIVE;\n                        } else {\n                            to_append_or_none = ANY_STRING;\n                        }\n                    }\n                    break;\n                }\n                case L'?': {\n                    if (unescape_special && !feature_test(features_t::qmark_noglob)) {\n                        to_append_or_none = ANY_CHAR;\n                    }\n                    break;\n                }\n                case L'$': {\n                    if (unescape_special) {\n                        bool is_cmdsub =\n                            input_position + 1 < input_len && input[input_position + 1] == L'(';\n                        if (!is_cmdsub) {\n                            to_append_or_none = VARIABLE_EXPAND;\n                            vars_or_seps.push_back(input_position);\n                        }\n                    }\n                    break;\n                }\n                case L'{': {\n                    if (unescape_special) {\n                        brace_count++;\n                        to_append_or_none = BRACE_BEGIN;\n                        // We need to store where the brace *ends up* in the output.\n                        braces.push_back(result.size());\n                    }\n                    break;\n                }\n                case L'}': {\n                    if (unescape_special) {\n                        // HACK: The completion machinery sometimes hands us partial tokens.\n                        // We can't parse them properly, but it shouldn't hurt,\n                        // so we don't assert here.\n                        // See #4954.\n                        // assert(brace_count > 0 && \"imbalanced brackets are a tokenizer error, we\n                        // shouldn't be able to get here\");\n                        brace_count--;\n                        to_append_or_none = BRACE_END;\n                        if (!braces.empty()) {\n                            // HACK: To reduce accidental use of brace expansion, treat a brace\n                            // with zero or one items as literal input. See #4632. (The hack is\n                            // doing it here and like this.)\n                            if (vars_or_seps.empty() || vars_or_seps.back() < braces.back()) {\n                                result[braces.back()] = L'{';\n                                // We also need to turn all spaces back.\n                                for (size_t i = braces.back() + 1; i < result.size(); i++) {\n                                    if (result[i] == BRACE_SPACE) result[i] = L' ';\n                                }\n                                to_append_or_none = L'}';\n                            }\n\n                            // Remove all seps inside the current brace pair, so if we have a\n                            // surrounding pair we only get seps inside *that*.\n                            if (!vars_or_seps.empty()) {\n                                while (!vars_or_seps.empty() && vars_or_seps.back() > braces.back())\n                                    vars_or_seps.pop_back();\n                            }\n                            braces.pop_back();\n                        }\n                    }\n                    break;\n                }\n                case L',': {\n                    if (unescape_special && brace_count > 0) {\n                        to_append_or_none = BRACE_SEP;\n                        vars_or_seps.push_back(input_position);\n                    }\n                    break;\n                }\n                case L' ': {\n                    if (unescape_special && brace_count > 0) {\n                        to_append_or_none = BRACE_SPACE;\n                    }\n                    break;\n                }\n                case L'\\'': {\n                    mode = mode_single_quotes;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                case L'\\\"': {\n                    mode = mode_double_quotes;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        } else if (mode == mode_single_quotes) {\n            if (c == L'\\\\') {\n                // A backslash may or may not escape something in single quotes.\n                switch (input[input_position + 1]) {\n                    case '\\\\':\n                    case L'\\'': {\n                        to_append_or_none = input[input_position + 1];\n                        input_position += 1;  // skip over the backslash\n                        break;\n                    }\n                    case L'\\0': {\n                        if (!allow_incomplete) {\n                            errored = true;\n                        } else {\n                            // PCA this line had the following cryptic comment: 'We may ever escape\n                            // a NULL character, but still appending a \\ in case I am wrong.' Not\n                            // sure what it means or the importance of this.\n                            input_position += 1; /* Skip over the backslash */\n                            to_append_or_none = L'\\\\';\n                        }\n                        break;\n                    }\n                    default: {\n                        // Literal backslash that doesn't escape anything! Leave things alone; we'll\n                        // append the backslash itself.\n                        break;\n                    }\n                }\n            } else if (c == L'\\'') {\n                to_append_or_none =\n                    unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                mode = mode_unquoted;\n            }\n        } else if (mode == mode_double_quotes) {\n            switch (c) {\n                case L'\"': {\n                    mode = mode_unquoted;\n                    to_append_or_none =\n                        unescape_special ? maybe_t<wchar_t>(INTERNAL_SEPARATOR) : none();\n                    break;\n                }\n                case '\\\\': {\n                    switch (input[input_position + 1]) {\n                        case L'\\0': {\n                            if (!allow_incomplete) {\n                                errored = true;\n                            } else {\n                                to_append_or_none = L'\\0';\n                            }\n                            break;\n                        }\n                        case '\\\\':\n                        case L'$':\n                        case '\"': {\n                            to_append_or_none = input[input_position + 1];\n                            input_position += 1; /* Skip over the backslash */\n                            break;\n                        }\n                        case '\\n': {\n                            /* Swallow newline */\n                            to_append_or_none = none();\n                            input_position += 1; /* Skip over the backslash */\n                            break;\n                        }\n                        default: {\n                            /* Literal backslash that doesn't escape anything! Leave things alone;\n                             * we'll append the backslash itself */\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case '$': {\n                    if (unescape_special) {\n                        to_append_or_none = VARIABLE_EXPAND_SINGLE;\n                        vars_or_seps.push_back(input_position);\n                    }\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        }\n\n        // Now maybe append the char.\n        if (to_append_or_none.has_value()) {\n            result.push_back(*to_append_or_none);\n        }\n    }\n\n    // Return the string by reference, and then success.\n    if (!errored) {\n        *output_str = std::move(result);\n    }\n    return !errored;\n}\n\nbool unescape_string_in_place(wcstring *str, unescape_flags_t escape_special) {\n    assert(str != nullptr);\n    wcstring output;\n    bool success = unescape_string_internal(str->c_str(), str->size(), &output, escape_special);\n    if (success) {\n        *str = std::move(output);\n    }\n    return success;\n}\n\nbool unescape_string(const wchar_t *input, size_t len, wcstring *output,\n                     unescape_flags_t escape_special, escape_string_style_t style) {\n    bool success = false;\n    switch (style) {\n        case STRING_STYLE_SCRIPT: {\n            success = unescape_string_internal(input, len, output, escape_special);\n            break;\n        }\n        case STRING_STYLE_URL: {\n            success = unescape_string_url(input, output);\n            break;\n        }\n        case STRING_STYLE_VAR: {\n            success = unescape_string_var(input, output);\n            break;\n        }\n        case STRING_STYLE_REGEX: {\n            // unescaping PCRE2 is not needed/supported, the PCRE2 engine is responsible for that\n            success = false;\n            break;\n        }\n    }\n    if (!success) output->clear();\n    return success;\n}\n\nbool unescape_string(const wchar_t *input, wcstring *output, unescape_flags_t escape_special,\n                     escape_string_style_t style) {\n    return unescape_string(input, std::wcslen(input), output, escape_special, style);\n}\n\nbool unescape_string(const wcstring &input, wcstring *output, unescape_flags_t escape_special,\n                     escape_string_style_t style) {\n    return unescape_string(input.c_str(), input.size(), output, escape_special, style);\n}\n\nwcstring format_size(long long sz) {\n    wcstring result;\n    const wchar_t *sz_name[] = {L\"kB\", L\"MB\", L\"GB\", L\"TB\", L\"PB\", L\"EB\", L\"ZB\", L\"YB\", nullptr};\n\n    if (sz < 0) {\n        result.append(L\"unknown\");\n    } else if (sz < 1) {\n        result.append(_(L\"empty\"));\n    } else if (sz < 1024) {\n        result.append(format_string(L\"%lldB\", sz));\n    } else {\n        int i;\n\n        for (i = 0; sz_name[i]; i++) {\n            if (sz < (1024 * 1024) || !sz_name[i + 1]) {\n                long isz = (static_cast<long>(sz)) / 1024;\n                if (isz > 9)\n                    result.append(format_string(L\"%ld%ls\", isz, sz_name[i]));\n                else\n                    result.append(\n                        format_string(L\"%.1f%ls\", static_cast<double>(sz) / 1024, sz_name[i]));\n                break;\n            }\n            sz /= 1024;\n        }\n    }\n    return result;\n}\n\n/// Crappy function to extract the most significant digit of an unsigned long long value.\nstatic char extract_most_significant_digit(unsigned long long *xp) {\n    unsigned long long place_value = 1;\n    unsigned long long x = *xp;\n    while (x >= 10) {\n        x /= 10;\n        place_value *= 10;\n    }\n    *xp -= (place_value * x);\n    return x + '0';\n}\n\nstatic void append_ull(char *buff, unsigned long long val, size_t *inout_idx, size_t max_len) {\n    size_t idx = *inout_idx;\n    while (val > 0 && idx < max_len) buff[idx++] = extract_most_significant_digit(&val);\n    *inout_idx = idx;\n}\n\nstatic void append_str(char *buff, const char *str, size_t *inout_idx, size_t max_len) {\n    size_t idx = *inout_idx;\n    while (*str && idx < max_len) buff[idx++] = *str++;\n    *inout_idx = idx;\n}\n\nvoid format_size_safe(char buff[128], unsigned long long sz) {\n    const size_t buff_size = 128;\n    const size_t max_len = buff_size - 1;  // need to leave room for a null terminator\n    std::memset(buff, 0, buff_size);\n    size_t idx = 0;\n    const char *const sz_name[] = {\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\", nullptr};\n    if (sz < 1) {\n        strcpy(buff, \"empty\");\n    } else if (sz < 1024) {\n        append_ull(buff, sz, &idx, max_len);\n        append_str(buff, \"B\", &idx, max_len);\n    } else {\n        for (size_t i = 0; sz_name[i]; i++) {\n            if (sz < (1024 * 1024) || !sz_name[i + 1]) {\n                unsigned long long isz = sz / 1024;\n                if (isz > 9) {\n                    append_ull(buff, isz, &idx, max_len);\n                } else {\n                    append_ull(buff, isz, &idx, max_len);\n\n                    // Maybe append a single fraction digit.\n                    unsigned long long remainder = sz % 1024;\n                    if (remainder > 0) {\n                        char tmp[3] = {'.', extract_most_significant_digit(&remainder), 0};\n                        append_str(buff, tmp, &idx, max_len);\n                    }\n                }\n                append_str(buff, sz_name[i], &idx, max_len);\n                break;\n            }\n            sz /= 1024;\n        }\n    }\n}\n\ndouble timef() {\n    struct timeval tv;\n    assert_with_errno(gettimeofday(&tv, nullptr) != -1);\n    return static_cast<timepoint_t>(tv.tv_sec) + 1e-6 * tv.tv_usec;\n}\n\nvoid exit_without_destructors(int code) { _exit(code); }\n\nextern \"C\" {\n[[gnu::noinline]] void debug_thread_error(void) {\n    // Wait for a SIGINT. We can't use sigsuspend() because the signal may be delivered on another\n    // thread.\n    sigchecker_t sigint(topic_t::sighupint);\n    sigint.wait();\n}\n}\n\nvoid set_main_thread() {\n    // Just call thread_id() once to force increment of thread_id.\n    uint64_t tid = thread_id();\n    assert(tid == 1 && \"main thread should have thread ID 1\");\n    (void)tid;\n}\n\nvoid configure_thread_assertions_for_testing() { thread_asserts_cfg_for_testing = true; }\n\nbool is_forked_child() { return is_forked_proc; }\n\nvoid setup_fork_guards() {\n    is_forked_proc = false;\n    static std::once_flag fork_guard_flag;\n    std::call_once(fork_guard_flag,\n                   [] { pthread_atfork(nullptr, nullptr, [] { is_forked_proc = true; }); });\n}\n\nvoid save_term_foreground_process_group() { initial_fg_process_group = tcgetpgrp(STDIN_FILENO); }\n\nvoid restore_term_foreground_process_group_for_exit() {\n    // We wish to restore the tty to the initial owner. There's two ways this can go wrong:\n    //  1. We may steal the tty from someone else (#7060).\n    //  2. The call to tcsetpgrp may deliver SIGSTOP to us, and we will not exit.\n    // Hanging on exit seems worse, so ensure that SIGTTOU is ignored so we do not get SIGSTOP.\n    // Note initial_fg_process_group == 0 is possible with Linux pid namespaces.\n    // This is called during shutdown and from a signal handler. We don't bother to complain on\n    // failure because doing so is unlikely to be noticed.\n    if (initial_fg_process_group > 0 && initial_fg_process_group != getpgrp()) {\n        (void)signal(SIGTTOU, SIG_IGN);\n        (void)tcsetpgrp(STDIN_FILENO, initial_fg_process_group);\n    }\n}\n\nbool is_main_thread() { return thread_id() == 1; }\n\nvoid assert_is_main_thread(const char *who) {\n    if (!likely(is_main_thread()) && !unlikely(thread_asserts_cfg_for_testing)) {\n        FLOGF(error, L\"%s called off of main thread.\", who);\n        FLOGF(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_not_forked_child(const char *who) {\n    if (unlikely(is_forked_child())) {\n        FLOGF(error, L\"%s called in a forked child.\", who);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_background_thread(const char *who) {\n    if (unlikely(is_main_thread()) && !unlikely(thread_asserts_cfg_for_testing)) {\n        FLOGF(error, L\"%s called on the main thread (may block!).\", who);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n    }\n}\n\nvoid assert_is_locked(std::mutex &mutex, const char *who, const char *caller) {\n    // Note that std::mutex.try_lock() is allowed to return false when the mutex isn't\n    // actually locked; fortunately we are checking the opposite so we're safe.\n    if (unlikely(mutex.try_lock())) {\n        FLOGF(error, L\"%s is not locked when it should be in '%s'\", who, caller);\n        FLOG(error, L\"Break on debug_thread_error to debug.\");\n        debug_thread_error();\n        mutex.unlock();\n    }\n}\n\n/// Test if the specified character is in a range that fish uses internally to store special tokens.\n///\n/// NOTE: This is used when tokenizing the input. It is also used when reading input, before\n/// tokenization, to replace such chars with REPLACEMENT_WCHAR if they're not part of a quoted\n/// string. We don't want external input to be able to feed reserved characters into our\n/// lexer/parser or code evaluator.\n//\n// TODO: Actually implement the replacement as documented above.\nbool fish_reserved_codepoint(wchar_t c) {\n    return (c >= RESERVED_CHAR_BASE && c < RESERVED_CHAR_END) ||\n           (c >= ENCODE_DIRECT_BASE && c < ENCODE_DIRECT_END);\n}\n\n/// Reopen stdin, stdout and/or stderr on /dev/null. This is invoked when we find that our tty has\n/// become invalid.\nvoid redirect_tty_output() {\n    struct termios t;\n    int fd = open(\"/dev/null\", O_WRONLY);\n    if (fd == -1) {\n        __fish_assert(\"Could not open /dev/null!\", __FILE__, __LINE__, errno);\n    }\n    if (tcgetattr(STDIN_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDIN_FILENO);\n    if (tcgetattr(STDOUT_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDOUT_FILENO);\n    if (tcgetattr(STDERR_FILENO, &t) == -1 && errno == EIO) dup2(fd, STDERR_FILENO);\n    close(fd);\n}\n\n/// Display a failed assertion message, dump a stack trace if possible, then die.\n[[noreturn]] void __fish_assert(const char *msg, const char *file, size_t line, int error) {\n    if (unlikely(error)) {\n        FLOGF(error, L\"%s:%zu: failed assertion: %s: errno %d (%s)\", file, line, msg, error,\n              std::strerror(error));\n    } else {\n        FLOGF(error, L\"%s:%zu: failed assertion: %s\", file, line, msg);\n    }\n    show_stackframe(99, 1);\n    abort();\n}\n\n/// Test if the given char is valid in a variable name.\nbool valid_var_name_char(wchar_t chr) { return fish_iswalnum(chr) || chr == L'_'; }\n\n/// Test if the given string is a valid variable name.\nbool valid_var_name(const wcstring &str) {\n    // Note do not use c_str(), we want to fail on embedded nul bytes.\n    return !str.empty() && std::all_of(str.begin(), str.end(), valid_var_name_char);\n}\n\nbool valid_var_name(const wchar_t *str) {\n    if (str[0] == L'\\0') return false;\n    for (size_t i = 0; str[i] != L'\\0'; i++) {\n        if (!valid_var_name_char(str[i])) return false;\n    }\n    return true;\n}\n\n/// Test if the string is a valid function name.\nbool valid_func_name(const wcstring &str) {\n    if (str.empty()) return false;\n    if (str.at(0) == L'-') return false;\n    // A function name needs to be a valid path, so no / and no NULL.\n    if (str.find_first_of(L'/') != wcstring::npos) return false;\n    if (str.find_first_of(L'\\0') != wcstring::npos) return false;\n    return true;\n}\n\n/// Return the path to the current executable. This needs to be realpath'd.\nstd::string get_executable_path(const char *argv0) {\n    char buff[PATH_MAX];\n\n#ifdef __APPLE__\n    // On OS X use it's proprietary API to get the path to the executable.\n    // This is basically grabbing exec_path after argc, argv, envp, ...: for us\n    // https://opensource.apple.com/source/adv_cmds/adv_cmds-163/ps/print.c\n    uint32_t buffSize = sizeof buff;\n    if (_NSGetExecutablePath(buff, &buffSize) == 0) return std::string(buff);\n#elif defined(__BSD__) && defined(KERN_PROC_PATHNAME)\n    // BSDs do not have /proc by default, (although it can be mounted as procfs via the Linux\n    // compatibility layer). We can use sysctl instead: per sysctl(3), passing in a process ID of -1\n    // returns the value for the current process.\n    size_t buff_size = sizeof buff;\n#if defined(__NetBSD__)\n    int name[] = {CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_PATHNAME};\n#else\n    int name[] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};\n#endif\n    int result = sysctl(name, sizeof(name) / sizeof(int), buff, &buff_size, nullptr, 0);\n    if (result != 0) {\n        wperror(L\"sysctl KERN_PROC_PATHNAME\");\n    } else {\n        return std::string(buff);\n    }\n#else\n    // On other unixes, fall back to the Linux-ish /proc/ directory\n    ssize_t len;\n    len = readlink(\"/proc/self/exe\", buff, sizeof buff - 1);  // Linux\n    if (len == -1) {\n        len = readlink(\"/proc/curproc/file\", buff, sizeof buff - 1);  // other BSDs\n        if (len == -1) {\n            len = readlink(\"/proc/self/path/a.out\", buff, sizeof buff - 1);  // Solaris\n        }\n    }\n    if (len > 0) {\n        buff[len] = '\\0';\n        // When /proc/self/exe points to a file that was deleted (or overwritten on update!)\n        // then linux adds a \" (deleted)\" suffix.\n        // If that's not a valid path, let's remove that awkward suffix.\n        std::string buffstr{buff};\n        if (access(buff, F_OK)) {\n            auto dellen = const_strlen(\" (deleted)\");\n            if (buffstr.size() > dellen &&\n                buffstr.compare(buffstr.size() - dellen, dellen, \" (deleted)\") == 0) {\n                buffstr = buffstr.substr(0, buffstr.size() - dellen);\n            }\n        }\n        return buffstr;\n    }\n#endif\n\n    // Just return argv0, which probably won't work (i.e. it's not an absolute path or a path\n    // relative to the working directory, but instead something the caller found via $PATH). We'll\n    // eventually fall back to the compile time paths.\n    return std::string(argv0 ? argv0 : \"\");\n}\n\n/// Return a path to a directory where we can store temporary files.\nstd::string get_path_to_tmp_dir() {\n    char *env_tmpdir = getenv(\"TMPDIR\");\n    if (env_tmpdir) {\n        return env_tmpdir;\n    }\n#if defined(_CS_DARWIN_USER_TEMP_DIR)\n    char osx_tmpdir[PATH_MAX];\n    size_t n = confstr(_CS_DARWIN_USER_TEMP_DIR, osx_tmpdir, PATH_MAX);\n    if (0 < n && n <= PATH_MAX) {\n        return osx_tmpdir;\n    } else {\n        return \"/tmp\";\n    }\n#elif defined(P_tmpdir)\n    return P_tmpdir;\n#elif defined(_PATH_TMP)\n    return _PATH_TMP;\n#else\n    return \"/tmp\";\n#endif\n}\n\n// This function attempts to distinguish between a console session (at the actual login vty) and a\n// session within a terminal emulator inside a desktop environment or over SSH. Unfortunately\n// there are few values of $TERM that we can interpret as being exclusively console sessions, and\n// most common operating systems do not use them. The value is cached for the duration of the fish\n// session. We err on the side of assuming it's not a console session. This approach isn't\n// bullet-proof and that's OK.\nbool is_console_session() {\n    static const bool console_session = [] {\n        char tty_name[PATH_MAX];\n        if (ttyname_r(STDIN_FILENO, tty_name, sizeof tty_name) != 0) {\n            return false;\n        }\n        constexpr auto len = const_strlen(\"/dev/tty\");\n        const char *TERM = getenv(\"TERM\");\n        return\n            // Test that the tty matches /dev/(console|dcons|tty[uv\\d])\n            ((strncmp(tty_name, \"/dev/tty\", len) == 0 &&\n              (tty_name[len] == 'u' || tty_name[len] == 'v' || isdigit(tty_name[len]))) ||\n             strcmp(tty_name, \"/dev/dcons\") == 0 || strcmp(tty_name, \"/dev/console\") == 0)\n            // and that $TERM is simple, e.g. `xterm` or `vt100`, not `xterm-something`\n            && (!TERM || !strchr(TERM, '-') || !strcmp(TERM, \"sun-color\"));\n    }();\n    return console_session;\n}\n", "# RUN: %fish -C 'set -g fish %fish' %s\n#\n# Test function, loops, conditionals and some basic elements\n#\n\n# The test driver always starts each test in its own temporary directory, but to make it easier to\n# run this test directly for whatever reason:\nset -g tmpdir (mktemp -d)\n\n# Comments in odd places don't cause problems\nfor i in 1 2 # Comment on same line as command\n# Comment inside loop\n    for j in a b\n\t\t# Double loop\n        echo $i$j\n\tend;\nend\n#CHECK: 1a\n#CHECK: 1b\n#CHECK: 2a\n#CHECK: 2b\n\n# Escaped newlines\necho foo\\ bar\necho foo\\\nbar\necho \"foo\\\nbar\"\necho 'foo\\\nbar'\n#CHECK: foo bar\n#CHECK: foobar\n#CHECK: foobar\n#CHECK: foo\\\n#CHECK: bar\n\nfor i in \\\n    a b c\n    echo $i\nend\n#CHECK: a\n#CHECK: b\n#CHECK: c\n\n\n# Simple function tests\n\nfunction foo\n    echo > $tmpdir/fish_foo.txt $argv\nend\n\nfoo hello\n\ncat $tmpdir/fish_foo.txt |read foo\n\nif test $foo = hello;\n  echo Test 2 pass\nelse\n  echo Test 2 fail\nend\n#CHECK: Test 2 pass\n\nfunction foo\n    printf 'Test %s' $argv[1]; echo ' pass'\nend\n\nfoo 3a\n#CHECK: Test 3a pass\n\nfor i in Test for continue break and switch builtins problems;\n\tswitch $i\n\t\tcase Test\n\t\t\tprintf \"%s \" $i\n\t\tcase \"for\"\n\t\t\tprintf \"%s \" 3b\n\t\tcase \"c*\"\n\t\t\techo pass\n\t\tcase break\n\t\t\tcontinue\n\t\t\techo fail\n\t\tcase and\n\t\t\tbreak\n\t\t\techo fail\n\t\tcase \"*\"\n\t\t\techo fail\n\tend\nend\n#CHECK: Test 3b pass\n\nset -l sta\nif eval true\n\tif eval false\n\t\tset sta fail\n\telse\n\t\tset sta pass\n\tend\nelse\n\tset sta fail\nend\necho Test 4 $sta\n#CHECK: Test 4 pass\n\n# Testing builtin status\n\nfunction test_builtin_status\n\treturn 1\nend\ntest_builtin_status\nif [ $status -eq 1 ]\n\tset sta pass\nelse\n\tset sta fail\nend\necho Test 5 $sta\n#CHECK: Test 5 pass\n\n\nfunction test_builtin_status_clamp_to_255\n    return 300\nend\ntest_builtin_status_clamp_to_255\necho $status\n#CHECK: 255\n\n$fish -c \"exit 300\"\necho $status\n#CHECK: 255\n\n####################\n# echo tests\necho 'abc\\ndef'\n#CHECK: abc\\ndef\necho -e 'abc\\ndef'\n#CHECK: abc\n#CHECK: def\necho -e 'abc\\zdef'\n#CHECK: abc\\zdef\necho -e 'abc\\41def'\necho -e 'abc\\041def'\n#CHECK: abc!def\n#CHECK: abc!def\necho -e 'abc\\121def'\necho -e 'abc\\1212def'\n#CHECK: abcQdef\n#CHECK: abcQ2def\necho -e 'abc\\cdef' # won't output a newline!\n#CHECK: abc\necho ''\necho -\n#CHECK: -\necho -h\n#CHECK: -h\necho -ne '\\376' | display_bytes\n#CHECK: 0000000 376\n#CHECK: 0000001\necho -e 'abc\\x21def'\necho -e 'abc\\x211def'\n#CHECK: abc!def\n#CHECK: abc!1def\n\n# Comments allowed in between lines (#1987)\necho before comment \\\n  # comment\n  after comment\n#CHECK: before comment after comment\n\n# Backslashes are part of comments and do not join lines (#1255)\n# This should execute false, not echo it\necho -n # comment\\\nfalse\n\nfunction always_fails\n    if true\n        return 1\n    end\nend\n\n# Verify $argv set correctly in sourced scripts (#139)\necho 'echo \"source argv {$argv}\"' | source\n#CHECK: source argv {}\necho 'echo \"source argv {$argv}\"' | source -\n#CHECK: source argv {}\necho 'echo \"source argv {$argv}\"' | source - abc\n#CHECK: source argv {abc}\necho 'echo \"source argv {$argv}\"' | source - abc def\n#CHECK: source argv {abc def}\n\nalways_fails\necho $status\n#CHECK: 1\n\n# Test that subsequent cases do not blow away the status from previous ones\nfor val in one two three four\n\tswitch $val\n\tcase one\n\t\t/bin/sh -c 'exit 1'\n\tcase two\n\t\t/bin/sh -c 'exit 2'\n\tcase three\n\t\t/bin/sh -c 'exit 3'\n\tend\n\techo $status\nend\n#CHECK: 1\n#CHECK: 2\n#CHECK: 3\n#CHECK: 0\n\n# Test that the `switch` builtin itself does not blow away status before evaluating a case\nfalse\nswitch one\ncase one\n\techo $status\nend\n#CHECK: 1\n\n#test contains -i\ncontains -i string a b c string d\n#CHECK: 4\ncontains -i string a b c d; or echo nothing\n#CHECK: nothing\ncontains -i -- string a b c string d\n#CHECK: 4\ncontains -i -- -- a b c; or echo nothing\n#CHECK: nothing\ncontains -i -- -- a b c -- v\n#CHECK: 4\n\n# Test if, else, and else if\nif true\n\techo alpha1.1\n\techo alpha1.2\nelse if false\n\techo beta1.1\n\techo beta1.2\nelse if false\n\techo gamma1.1\n\techo gamma1.2\nelse\n\techo delta1.1\n\techo delta1.2\nend\n#CHECK: alpha1.1\n#CHECK: alpha1.2\n\nif false\n\techo alpha2.1\n\techo alpha2.2\nelse if begin ; true ; end\n\techo beta2.1\n\techo beta2.2\nelse if begin ; echo nope2.1; false ; end\n\techo gamma2.1\n\techo gamma2.2\nelse\n\techo delta2.1\n\techo delta2.2\nend\n#CHECK: beta2.1\n#CHECK: beta2.2\n\nif false\n\techo alpha3.1\n\techo alpha3.2\nelse if begin ; echo yep3.1; false ; end\n\techo beta3.1\n\techo beta3.2\nelse if begin ; echo yep3.2; true ; end\n\techo gamma3.1\n\techo gamma3.2\nelse\n\techo delta3.1\n\techo delta3.2\nend\n#CHECK: yep3.1\n#CHECK: yep3.2\n#CHECK: gamma3.1\n#CHECK: gamma3.2\n\nif false\n\techo alpha4.1\n\techo alpha4.2\nelse if begin ; echo yep4.1; false ; end\n\techo beta4.1\n\techo beta4.2\nelse if begin ; echo yep4.2; false ; end\n\techo gamma4.1\n\techo gamma4.2\nelse\n\techo delta4.1\n\techo delta4.2\nend\n#CHECK: yep4.1\n#CHECK: yep4.2\n#CHECK: delta4.1\n#CHECK: delta4.2\n\nif test ! -n \"abc\"\nelse if test -n \"def\"\n\techo \"epsilon5.2\"\nelse if not_a_valid_command but it should be OK because a previous branch was taken\n\techo \"epsilon 5.3\"\nelse if test ! -n \"abc\"\n\techo \"epsilon 5.4\"\nend\n#CHECK: epsilon5.2\n\n# Ensure builtins work\n# https://github.com/fish-shell/fish-shell/issues/359\nif not echo skip1 > /dev/null\n\techo \"zeta 6.1\"\nelse if echo skip2 > /dev/null\n\techo \"zeta 6.2\"\nend\n#CHECK: zeta 6.2\n\necho '###'\n#CHECK: ###\n\n# Ensure 'type' works\n# https://github.com/fish-shell/fish-shell/issues/513\nfunction fish_test_type_zzz\n\ttrue\nend\n# Should succeed\ntype -q fish_test_type_zzz ; echo $status\n#CHECK: 0\n# Should fail\ntype -q -f fish_test_type_zzz ; echo $status\n#CHECK: 1\n\n# ensure that builtins that produce no output can still truncate files\n# (bug PCA almost reintroduced!)\necho abc > $tmpdir/file_truncation_test.txt\ncat $tmpdir/file_truncation_test.txt\necho -n > $tmpdir/file_truncation_test.txt\ncat $tmpdir/file_truncation_test.txt\n#CHECK: abc\n\n# Test events.\n\n\n# This pattern caused a crash; github issue #449\n\nset -g var before\n\nfunction test1 --on-event test\n    set -g var $var:test1\n    functions -e test2\nend\n\nfunction test2 --on-event test\n    # this should not run, as test2 gets removed before it has a chance of running\n    set -g var $var:test2a\nend\nemit test\n\necho $var\n#CHECK: before:test1\n\n\nfunction test3 --on-event test3\n    echo received event test3 with args: $argv\nend\n\nemit test3 foo bar\n#CHECK: received event test3 with args: foo bar\n\n# test empty argument\nemit\n#CHECKERR: emit: expected event name\n\n# Test break and continue\n# This should output Ping once\nfor i in a b c\n    if not contains $i c ; continue ; end\n    echo Ping\nend\n#CHECK: Ping\n\n# This should output Pong not at all\nfor i in a b c\n    if not contains $i c ; break ; end\n    echo Pong\nend\n\n# This should output Foop three times, and Boop not at all\nset i a a a\nwhile contains $i a\n    set -e i[-1]\n    echo Foop\n    continue\n    echo Boop\nend\n#CHECK: Foop\n#CHECK: Foop\n#CHECK: Foop\n\n# This should output Doop once\nset i a a a\nwhile contains $i a\n    set -e i[-1]\n    echo Doop\n    break\n    echo Darp\nend\n#CHECK: Doop\n\n# break and continue may be dynamically invoked.\nset dyn_break break\nset dyn_continue continue\n\nwhile true\n    $dyn_break\n    echo \"I should be unreachable\"\nend\n\nfor foo in 1 2 3\n    $dyn_continue\n    echo \"I should be unreachable\"\nend\n\n# Check that these error correctly.\n# Simplify __fish_print_help, as it's noisy.\nfunction __fish_print_help\n    echo $argv[2..]\nend\n$dyn_break\neval break\n#CHECKERR: break: Not inside of loop\n#CHECKERR: break: Not inside of loop\n$dyn_continue\neval continue\n#CHECKERR: continue: Not inside of loop\n#CHECKERR: continue: Not inside of loop\n\n# Test implicit cd. This should do nothing.\n./\n\n# Test special for loop expansion\n# Here we the name of the variable is derived from another variable\nset var1 var2\nfor $var1 in 1 2 3\n    echo -n $var2\nend\necho\n#CHECK: 123\n\n# Test status -n\neval 'status -n\nstatus -n\nstatus -n'\n#CHECK: 1\n#CHECK: 2\n#CHECK: 3\n\n# Test support for unbalanced blocks\nfunction try_unbalanced_block\n    $fish -c \"echo $argv | source \" 2>&1 | grep \"Missing end\" 1>&2\nend\ntry_unbalanced_block 'begin'\n#CHECKERR: - (line 1): Missing end to balance this begin\ntry_unbalanced_block 'while true'\n#CHECKERR: - (line 1): Missing end to balance this while loop\ntry_unbalanced_block 'for x in 1 2 3'\n#CHECKERR: - (line 1): Missing end to balance this for loop\ntry_unbalanced_block 'switch abc'\n#CHECKERR: - (line 1): Missing end to balance this switch statement\ntry_unbalanced_block 'function anything'\n#CHECKERR: - (line 1): Missing end to balance this function definition\ntry_unbalanced_block 'if false'\n#CHECKERR: - (line 1): Missing end to balance this if statement\n\n# Ensure that quoted keywords work\n'while' false; end\n\"while\" false; end\n\"wh\"'ile' false; \"e\"nd\n\n# BOM checking (see #1518). But only in UTF8 locales.\n# (locale guarded because of musl)\nif command -sq locale; and string match -qi '*utf-8*' -- (locale)\n    echo \\uFEFF\"echo bom_test\" | source\nelse\n    echo \"echo bom_test\" | source\nend\n#CHECK: bom_test\n\n# Comments abutting text (#953)\necho not#a#comment\n#CHECK: not#a#comment\necho is # a # comment\n#CHECK: is\n\n# Test that our builtins can all do --query\ncommand --query cp\necho $status\n#CHECK: 0\n\ntype --query cp\necho $status\n#CHECK: 0\n\njobs --query 0\necho $status\n#CHECK: 1\n\nabbr --query thisshouldnotbeanabbreviationohmygoshitssolongwhywouldanyoneeverusethis\necho $status\n#CHECK: 1\n\nfunctions --query alias\necho $status\n#CHECK: 0\n\nset --query status\necho $status\n#CHECK: 0\n\nbuiltin --query echo\necho $status\n#CHECK: 0\n\n# Check that echo doesn't interpret options *and print them*\n# at the start of quoted args:\necho '-ne \\tart'\n# CHECK: -ne \\tart\necho '-n art'\necho banana\n# CHECK: -n art\n# CHECK: banana\n\n# This used to be a parse error - #7685.\necho (echo hello\\\\)\n# CHECK: hello\\\n\n# This used to be a parse error - #7866.\necho (echo foo;#)\n     )\n# CHECK: foo\necho (echo bar #'\n     )\n# CHECK: bar\necho (#\"\n      echo baz)\n# CHECK: baz\n\n# Make sure we don't match up brackets within comments (#8022).\n$fish -c 'echo f[oo # not valid, no matching ]'\n# CHECKERR: fish: Unexpected end of string, square brackets do not match\n# CHECKERR: echo f[oo # not valid, no matching ]\n# CHECKERR: {{      }}^\n\n# Should fail because $PWD is read-only.\nfor PWD in foo bar\n    true\nend\n# CHECKERR: {{.*}}/basic.fish (line {{\\d+}}): for: PWD: cannot overwrite read-only variable\n# CHECKERR: for PWD in foo bar\n# CHECKERR:     ^~^\n# XXX FIXME carat should point at PWD\n\n$fish -c 'echo \\xtest'\n# CHECKERR: fish: Invalid token '\\xtest'\n# CHECKERR: echo \\xtest\n# CHECKERR:      ^~~~~^\n\n$fish -c 'echo \\utest'\n# CHECKERR: fish: Invalid token '\\utest'\n# CHECKERR: echo \\utest\n# CHECKERR:      ^~~~~^\n\n$fish -c 'echo \\c'\n# CHECKERR: fish: Incomplete escape sequence '\\c'\n# CHECKERR: echo \\c\n# CHECKERR:      ^^\n\n$fish -c 'echo \\C'\n# CHECK: C\n\n$fish -c 'echo \\U'\n# CHECKERR: fish: Incomplete escape sequence '\\U'\n# CHECKERR: echo \\U\n# CHECKERR:      ^^\n\n$fish -c 'echo \\x'\n# CHECKERR: fish: Incomplete escape sequence '\\x'\n# CHECKERR: echo \\x\n# CHECKERR:      ^^\n\n$fish -c 'echo \\ufdd2\"fart\"'\n# CHECKERR: fish: Invalid token '\\ufdd2\"fart\"'\n# CHECKERR: echo \\ufdd2\"fart\"\n# CHECKERR: ^~~~~~~~~~~^\n\necho (sh -c 'printf $\\'\\ufdd2foo\\'') | string escape\n# CHECK: \\Xef\\Xb7\\X92foo\n\nprintf '%s\\n' \"#!/bin/sh\" 'echo $0' > $tmpdir/argv0.sh\nchmod +x $tmpdir/argv0.sh\ncd $tmpdir\n./argv0.sh\n# CHECK: ./argv0.sh\n"], "filenames": ["src/common.cpp", "tests/checks/basic.fish"], "buggy_code_start_loc": [338, 589], "buggy_code_end_loc": [1315, 589], "fixing_code_start_loc": [338, 590], "fixing_code_end_loc": [1317, 598], "type": "CWE-436", "message": "fish is a smart and user-friendly command line shell for macOS, Linux, and the rest of the family. fish shell uses certain Unicode non-characters internally for marking wildcards and expansions. It will incorrectly allow these markers to be read on command substitution output, rather than transforming them into a safe internal representation. While this may cause unexpected behavior with direct input (for example, echo \\UFDD2HOME has the same output as echo $HOME), this may become a minor security problem if the output is being fed from an external program into a command substitution where this output may not be expected. This design flaw was introduced in very early versions of fish, predating the version control system, and is thought to be present in every version of fish released in the last 15 years or more, although with different characters. Code execution does not appear to be possible, but denial of service (through large brace expansion) or information disclosure (such as variable expansion) is potentially possible under certain circumstances. fish shell 3.6.2 has been released to correct this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-49284", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-05T00:15:08.737", "lastModified": "2023-12-08T21:15:07.433", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fish is a smart and user-friendly command line shell for macOS, Linux, and the rest of the family. fish shell uses certain Unicode non-characters internally for marking wildcards and expansions. It will incorrectly allow these markers to be read on command substitution output, rather than transforming them into a safe internal representation. While this may cause unexpected behavior with direct input (for example, echo \\UFDD2HOME has the same output as echo $HOME), this may become a minor security problem if the output is being fed from an external program into a command substitution where this output may not be expected. This design flaw was introduced in very early versions of fish, predating the version control system, and is thought to be present in every version of fish released in the last 15 years or more, although with different characters. Code execution does not appear to be possible, but denial of service (through large brace expansion) or information disclosure (such as variable expansion) is potentially possible under certain circumstances. fish shell 3.6.2 has been released to correct this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "fish es un shell de l\u00ednea de comandos inteligente y f\u00e1cil de usar para macOS, Linux y el resto de la familia. fish shell utiliza internamente ciertos caracteres que no son Unicode para marcar comodines y expansiones. Permitir\u00e1 incorrectamente que estos marcadores se lean en la salida de sustituci\u00f3n de comandos, en lugar de transformarlos en una representaci\u00f3n interna segura. Si bien esto puede causar un comportamiento inesperado con la entrada directa (por ejemplo, echo \\UFDD2HOME tiene el mismo resultado que echo $HOME), esto puede convertirse en un problema de seguridad menor si el resultado se env\u00eda desde un programa externo a un comando de sustituci\u00f3n donde este resultado puede que no se espere. Este defecto de dise\u00f1o se introdujo en versiones muy tempranas de Fish, anteriores al sistema de control de versiones, y se cree que est\u00e1 presente en todas las versiones de Fish lanzadas en los \u00faltimos 15 a\u00f1os o m\u00e1s, aunque con caracteres diferentes. La ejecuci\u00f3n del c\u00f3digo no parece posible, pero la denegaci\u00f3n de servicio (mediante una gran expansi\u00f3n de llaves) o la divulgaci\u00f3n de informaci\u00f3n (como la expansi\u00f3n de variables) es potencialmente posible en determinadas circunstancias. Se lanz\u00f3 Fish Shell 3.6.2 para corregir este problema. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fishshell:fish:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.2", "matchCriteriaId": "2274FD09-F6AF-4F35-AAD6-9D48F8045BB7"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/12/08/1", "source": "security-advisories@github.com"}, {"url": "https://github.com/fish-shell/fish-shell/commit/09986f5563e31e2c900a606438f1d60d008f3a14", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/fish-shell/fish-shell/security/advisories/GHSA-2j9r-pm96-wp4f", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/fish-shell/fish-shell/commit/09986f5563e31e2c900a606438f1d60d008f3a14"}}