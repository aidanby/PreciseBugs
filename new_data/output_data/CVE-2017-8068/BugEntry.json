{"buggy_code": ["/*\n *  Copyright (c) 1999-2013 Petko Manolov (petkan@nucleusys.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n *\tChangeLog:\n *\t\t....\tMost of the time spent on reading sources & docs.\n *\t\tv0.2.x\tFirst official release for the Linux kernel.\n *\t\tv0.3.0\tBeutified and structured, some bugs fixed.\n *\t\tv0.3.x\tURBifying bulk requests and bugfixing. First relatively\n *\t\t\tstable release. Still can touch device's registers only\n *\t\t\tfrom top-halves.\n *\t\tv0.4.0\tControl messages remained unurbified are now URBs.\n *\t\t\tNow we can touch the HW at any time.\n *\t\tv0.4.9\tControl urbs again use process context to wait. Argh...\n *\t\t\tSome long standing bugs (enable_net_traffic) fixed.\n *\t\t\tAlso nasty trick about resubmiting control urb from\n *\t\t\tinterrupt context used. Please let me know how it\n *\t\t\tbehaves. Pegasus II support added since this version.\n *\t\t\tTODO: suppressing HCD warnings spewage on disconnect.\n *\t\tv0.4.13\tEthernet address is now set at probe(), not at open()\n *\t\t\ttime as this seems to break dhcpd.\n *\t\tv0.5.0\tbranch to 2.5.x kernels\n *\t\tv0.5.1\tethtool support added\n *\t\tv0.5.5\trx socket buffers are in a pool and the their allocation\n *\t\t\tis out of the interrupt routine.\n *\t\t...\n *\t\tv0.9.3\tsimplified [get|set]_register(s), async update registers\n *\t\t\tlogic revisited, receive skb_pool removed.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include \"pegasus.h\"\n\n/*\n * Version Information\n */\n#define DRIVER_VERSION \"v0.9.3 (2013/04/25)\"\n#define DRIVER_AUTHOR \"Petko Manolov <petkan@nucleusys.com>\"\n#define DRIVER_DESC \"Pegasus/Pegasus II USB Ethernet driver\"\n\nstatic const char driver_name[] = \"pegasus\";\n\n#undef\tPEGASUS_WRITE_EEPROM\n#define\tBMSR_MEDIA\t(BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | \\\n\t\t\tBMSR_100FULL | BMSR_ANEGCAPABLE)\n\nstatic bool loopback;\nstatic bool mii_mode;\nstatic char *devid;\n\nstatic struct usb_eth_dev usb_dev_id[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags)\t\\\n\t{.name = pn, .vendor = vid, .device = pid, .private = flags},\n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\tPEGASUS_DEV(pn, vid, pid, flags)\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{NULL, 0, 0, 0},\n\t{NULL, 0, 0, 0}\n};\n\nstatic struct usb_device_id pegasus_ids[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags) \\\n\t{.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = vid, .idProduct = pid},\n/*\n * The Belkin F8T012xx1 bluetooth adaptor has the same vendor and product\n * IDs as the Belkin F5D5050, so we need to teach the pegasus driver to\n * ignore adaptors belonging to the \"Wireless\" class 0xE0. For this one\n * case anyway, seeing as the pegasus is for \"Wired\" adaptors.\n */\n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\t{.match_flags = (USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_CLASS), \\\n\t.idVendor = vid, .idProduct = pid, .bDeviceClass = dclass},\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{},\n\t{}\n};\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(loopback, bool, 0);\nmodule_param(mii_mode, bool, 0);\nmodule_param(devid, charp, 0);\nMODULE_PARM_DESC(loopback, \"Enable MAC loopback mode (bit 0)\");\nMODULE_PARM_DESC(mii_mode, \"Enable HomePNA mode (bit 0),default=MII mode = 0\");\nMODULE_PARM_DESC(devid, \"The format is: 'DEV_name:VendorID:DeviceID:Flags'\");\n\n/* use ethtool to change the level for any given device */\nstatic int msg_level = -1;\nmodule_param(msg_level, int, 0);\nMODULE_PARM_DESC(msg_level, \"Override default message level\");\n\nMODULE_DEVICE_TABLE(usb, pegasus_ids);\nstatic const struct net_device_ops pegasus_netdev_ops;\n\n/*****/\n\nstatic void async_ctrl_callback(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int update_eth_regs_async(pegasus_t *pegasus)\n{\n\tint ret = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct usb_ctrlrequest *req;\n\n\treq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn ret;\n\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn ret;\n\t}\n\treq->bRequestType = PEGASUS_REQT_WRITE;\n\treq->bRequest = PEGASUS_REQ_SET_REGS;\n\treq->wValue = cpu_to_le16(0);\n\treq->wIndex = cpu_to_le16(EthCtrl0);\n\treq->wLength = cpu_to_le16(3);\n\n\tusb_fill_control_urb(async_urb, pegasus->usb,\n\t\t\t     usb_sndctrlpipe(pegasus->usb, 0), (void *)req,\n\t\t\t     pegasus->eth_regs, 3, async_ctrl_callback, req);\n\n\tret = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_err(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\t}\n\treturn ret;\n}\n\nstatic int __mii_op(pegasus_t *p, __u8 phy, __u8 indx, __u16 *regd, __u8 cmd)\n{\n\tint i;\n\t__u8 data[4] = { phy, 0, 0, indx };\n\t__le16 regdi;\n\tint ret = -ETIMEDOUT;\n\n\tif (cmd & PHY_WRITE) {\n\t\t__le16 *t = (__le16 *) & data[1];\n\t\t*t = cpu_to_le16(*regd);\n\t}\n\tset_register(p, PhyCtrl, 0);\n\tset_registers(p, PhyAddr, sizeof(data), data);\n\tset_register(p, PhyCtrl, (indx | cmd));\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(p, PhyCtrl, 1, data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (data[0] & PHY_DONE)\n\t\t\tbreak;\n\t}\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\tif (cmd & PHY_READ) {\n\t\tret = get_registers(p, PhyData, 2, &regdi);\n\t\t*regd = le16_to_cpu(regdi);\n\t\treturn ret;\n\t}\n\treturn 0;\nfail:\n\tnetif_dbg(p, drv, p->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\n/* Returns non-negative int on success, error on failure */\nstatic int read_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_READ);\n}\n\n/* Returns zero on success, error on failure */\nstatic int write_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_WRITE);\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tu16 res;\n\n\tread_mii_word(pegasus, phy_id, loc, &res);\n\treturn (int)res;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int val)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tu16 data = val;\n\n\twrite_mii_word(pegasus, phy_id, loc, &data);\n}\n\nstatic int read_eprom_word(pegasus_t *pegasus, __u8 index, __u16 *retdata)\n{\n\tint i;\n\t__u8 tmp;\n\t__le16 retdatai;\n\tint ret;\n\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EpromOffset, index);\n\tset_register(pegasus, EpromCtrl, EPROM_READ);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t\tif (ret == -ESHUTDOWN)\n\t\t\tgoto fail;\n\t}\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\n\tret = get_registers(pegasus, EpromData, 2, &retdatai);\n\t*retdata = le16_to_cpu(retdatai);\n\treturn ret;\n\nfail:\n\tnetif_warn(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n\n#ifdef\tPEGASUS_WRITE_EEPROM\nstatic inline void enable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE);\n}\n\nstatic inline void disable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE);\n}\n\nstatic int write_eprom_word(pegasus_t *pegasus, __u8 index, __u16 data)\n{\n\tint i;\n\t__u8 tmp, d[4] = { 0x3f, 0, 0, EPROM_WRITE };\n\tint ret;\n\t__le16 le_data = cpu_to_le16(data);\n\n\tset_registers(pegasus, EpromOffset, 4, d);\n\tenable_eprom_write(pegasus);\n\tset_register(pegasus, EpromOffset, index);\n\tset_registers(pegasus, EpromData, 2, &le_data);\n\tset_register(pegasus, EpromCtrl, EPROM_WRITE);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (ret == -ESHUTDOWN)\n\t\t\tgoto fail;\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t}\n\tdisable_eprom_write(pegasus);\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\n\treturn ret;\n\nfail:\n\tnetif_warn(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n#endif\t\t\t\t/* PEGASUS_WRITE_EEPROM */\n\nstatic inline void get_node_id(pegasus_t *pegasus, __u8 *id)\n{\n\tint i;\n\t__u16 w16;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tread_eprom_word(pegasus, i, &w16);\n\t\t((__le16 *) id)[i] = cpu_to_le16(w16);\n\t}\n}\n\nstatic void set_ethernet_addr(pegasus_t *pegasus)\n{\n\t__u8 node_id[6];\n\n\tif (pegasus->features & PEGASUS_II) {\n\t\tget_registers(pegasus, 0x10, sizeof(node_id), node_id);\n\t} else {\n\t\tget_node_id(pegasus, node_id);\n\t\tset_registers(pegasus, EthID, sizeof(node_id), node_id);\n\t}\n\tmemcpy(pegasus->net->dev_addr, node_id, sizeof(node_id));\n}\n\nstatic inline int reset_mac(pegasus_t *pegasus)\n{\n\t__u8 data = 0x8;\n\tint i;\n\n\tset_register(pegasus, EthCtrl1, data);\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tget_registers(pegasus, EthCtrl1, 1, &data);\n\t\tif (~data & 0x08) {\n\t\t\tif (loopback)\n\t\t\t\tbreak;\n\t\t\tif (mii_mode && (pegasus->features & HAS_HOME_PNA))\n\t\t\t\tset_register(pegasus, Gpio1, 0x34);\n\t\t\telse\n\t\t\t\tset_register(pegasus, Gpio1, 0x26);\n\t\t\tset_register(pegasus, Gpio0, pegasus->features);\n\t\t\tset_register(pegasus, Gpio0, DEFAULT_GPIO_SET);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == REG_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tset_register(pegasus, Gpio0, 0x24);\n\t\tset_register(pegasus, Gpio0, 0x26);\n\t}\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_ELCON) {\n\t\t__u16 auxmode;\n\t\tread_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t}\n\n\treturn 0;\n}\n\nstatic int enable_net_traffic(struct net_device *dev, struct usb_device *usb)\n{\n\t__u16 linkpart;\n\t__u8 data[4];\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tint ret;\n\n\tread_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart);\n\tdata[0] = 0xc8; /* TX & RX enable, append status, no CRC */\n\tdata[1] = 0;\n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL))\n\t\tdata[1] |= 0x20;\t/* set full duplex */\n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF))\n\t\tdata[1] |= 0x10;\t/* set 100 Mbps */\n\tif (mii_mode)\n\t\tdata[1] = 0;\n\tdata[2] = loopback ? 0x09 : 0x01;\n\n\tmemcpy(pegasus->eth_regs, data, sizeof(data));\n\tret = set_registers(pegasus, EthCtrl0, 3, data);\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS2 ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tu16 auxmode;\n\t\tread_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t}\n\n\treturn ret;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint rx_status, count = urb->actual_length;\n\tint status = urb->status;\n\tu8 *buf = urb->transfer_buffer;\n\t__u16 pkt_len;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ETIME:\n\t\tnetif_dbg(pegasus, rx_err, net, \"reset MAC\\n\");\n\t\tpegasus->flags &= ~PEGASUS_RX_BUSY;\n\t\tbreak;\n\tcase -EPIPE:\t\t/* stall, or disconnect from TT */\n\t\t/* FIXME schedule work to clear the halt */\n\t\tnetif_warn(pegasus, rx_err, net, \"no rx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"rx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_dbg(pegasus, rx_err, net, \"RX status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (count < 4)\n\t\tgoto goon;\n\n\trx_status = buf[count - 2];\n\tif (rx_status & 0x1e) {\n\t\tnetif_dbg(pegasus, rx_err, net,\n\t\t\t  \"RX packet error %x\\n\", rx_status);\n\t\tpegasus->stats.rx_errors++;\n\t\tif (rx_status & 0x06)\t/* long or runt\t*/\n\t\t\tpegasus->stats.rx_length_errors++;\n\t\tif (rx_status & 0x08)\n\t\t\tpegasus->stats.rx_crc_errors++;\n\t\tif (rx_status & 0x10)\t/* extra bits\t*/\n\t\t\tpegasus->stats.rx_frame_errors++;\n\t\tgoto goon;\n\t}\n\tif (pegasus->chip == 0x8513) {\n\t\tpkt_len = le32_to_cpu(*(__le32 *)urb->transfer_buffer);\n\t\tpkt_len &= 0x0fff;\n\t\tpegasus->rx_skb->data += 2;\n\t} else {\n\t\tpkt_len = buf[count - 3] << 8;\n\t\tpkt_len += buf[count - 4];\n\t\tpkt_len &= 0xfff;\n\t\tpkt_len -= 4;\n\t}\n\n\t/*\n\t * If the packet is unreasonably long, quietly drop it rather than\n\t * kernel panicing by calling skb_put.\n\t */\n\tif (pkt_len > PEGASUS_MTU)\n\t\tgoto goon;\n\n\t/*\n\t * at this point we are sure pegasus->rx_skb != NULL\n\t * so we go ahead and pass up the packet.\n\t */\n\tskb_put(pegasus->rx_skb, pkt_len);\n\tpegasus->rx_skb->protocol = eth_type_trans(pegasus->rx_skb, net);\n\tnetif_rx(pegasus->rx_skb);\n\tpegasus->stats.rx_packets++;\n\tpegasus->stats.rx_bytes += pkt_len;\n\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net, PEGASUS_MTU,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\n\tif (pegasus->rx_skb == NULL)\n\t\tgoto tl_sched;\ngoon:\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\trx_status = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (rx_status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (rx_status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\tgoto tl_sched;\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n\n\treturn;\n\ntl_sched:\n\ttasklet_schedule(&pegasus->rx_tl);\n}\n\nstatic void rx_fixup(unsigned long data)\n{\n\tpegasus_t *pegasus;\n\tint status;\n\n\tpegasus = (pegasus_t *) data;\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tif (pegasus->flags & PEGASUS_RX_URB_FAIL)\n\t\tif (pegasus->rx_skb)\n\t\t\tgoto try_again;\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_ATOMIC);\n\tif (pegasus->rx_skb == NULL) {\n\t\tnetif_warn(pegasus, rx_err, pegasus->net, \"low on memory\\n\");\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t\treturn;\n\t}\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\ntry_again:\n\tstatus = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase -EPIPE:\n\t\t/* FIXME schedule_work() to clear the tx halt */\n\t\tnetif_stop_queue(net);\n\t\tnetif_warn(pegasus, tx_err, net, \"no tx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"tx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_info(pegasus, tx_err, net, \"TX status %d\\n\", status);\n\t\t/* FALL THROUGH */\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tnetif_trans_update(net); /* prevent tx timeout */\n\tnetif_wake_queue(net);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint res, status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\tnet = pegasus->net;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* some Pegasus-I products report LOTS of data\n\t\t * toggle errors... avoid log spamming\n\t\t */\n\t\tnetif_dbg(pegasus, timer, net, \"intr status %d\\n\", status);\n\t}\n\n\tif (urb->actual_length >= 6) {\n\t\tu8 *d = urb->transfer_buffer;\n\n\t\t/* byte 0 == tx_status1, reg 2B */\n\t\tif (d[0] & (TX_UNDERRUN|EXCESSIVE_COL\n\t\t\t\t\t|LATE_COL|JABBER_TIMEOUT)) {\n\t\t\tpegasus->stats.tx_errors++;\n\t\t\tif (d[0] & TX_UNDERRUN)\n\t\t\t\tpegasus->stats.tx_fifo_errors++;\n\t\t\tif (d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT))\n\t\t\t\tpegasus->stats.tx_aborted_errors++;\n\t\t\tif (d[0] & LATE_COL)\n\t\t\t\tpegasus->stats.tx_window_errors++;\n\t\t}\n\n\t\t/* d[5].LINK_STATUS lies on some adapters.\n\t\t * d[0].NO_CARRIER kicks in only with failed TX.\n\t\t * ... so monitoring with MII may be safest.\n\t\t */\n\n\t\t/* bytes 3-4 == rx_lostpkt, reg 2E/2F */\n\t\tpegasus->stats.rx_missed_errors += ((d[3] & 0x7f) << 8) | d[4];\n\t}\n\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\tif (res)\n\t\tnetif_err(pegasus, timer, net,\n\t\t\t  \"can't resubmit interrupt urb, %d\\n\", res);\n}\n\nstatic void pegasus_tx_timeout(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tnetif_warn(pegasus, timer, net, \"tx timeout\\n\");\n\tusb_unlink_urb(pegasus->tx_urb);\n\tpegasus->stats.tx_errors++;\n}\n\nstatic netdev_tx_t pegasus_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint count = ((skb->len + 2) & 0x3f) ? skb->len + 2 : skb->len + 3;\n\tint res;\n\t__u16 l16 = skb->len;\n\n\tnetif_stop_queue(net);\n\n\t((__le16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);\n\tskb_copy_from_linear_data(skb, pegasus->tx_buff + 2, skb->len);\n\tusb_fill_bulk_urb(pegasus->tx_urb, pegasus->usb,\n\t\t\t  usb_sndbulkpipe(pegasus->usb, 2),\n\t\t\t  pegasus->tx_buff, count,\n\t\t\t  write_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->tx_urb, GFP_ATOMIC))) {\n\t\tnetif_warn(pegasus, tx_err, net, \"fail tx, %d\\n\", res);\n\t\tswitch (res) {\n\t\tcase -EPIPE:\t\t/* stall, or disconnect from TT */\n\t\t\t/* cleanup should already have been scheduled */\n\t\t\tbreak;\n\t\tcase -ENODEV:\t\t/* disconnect() upcoming */\n\t\tcase -EPERM:\n\t\t\tnetif_device_detach(pegasus->net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpegasus->stats.tx_errors++;\n\t\t\tnetif_start_queue(net);\n\t\t}\n\t} else {\n\t\tpegasus->stats.tx_packets++;\n\t\tpegasus->stats.tx_bytes += skb->len;\n\t}\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *pegasus_netdev_stats(struct net_device *dev)\n{\n\treturn &((pegasus_t *) netdev_priv(dev))->stats;\n}\n\nstatic inline void disable_net_traffic(pegasus_t *pegasus)\n{\n\t__le16 tmp = cpu_to_le16(0);\n\n\tset_registers(pegasus, EthCtrl0, sizeof(tmp), &tmp);\n}\n\nstatic inline void get_interrupt_interval(pegasus_t *pegasus)\n{\n\tu16 data;\n\tu8 interval;\n\n\tread_eprom_word(pegasus, 4, &data);\n\tinterval = data >> 8;\n\tif (pegasus->usb->speed != USB_SPEED_HIGH) {\n\t\tif (interval < 0x80) {\n\t\t\tnetif_info(pegasus, timer, pegasus->net,\n\t\t\t\t   \"intr interval changed from %ums to %ums\\n\",\n\t\t\t\t   interval, 0x80);\n\t\t\tinterval = 0x80;\n\t\t\tdata = (data & 0x00FF) | ((u16)interval << 8);\n#ifdef PEGASUS_WRITE_EEPROM\n\t\t\twrite_eprom_word(pegasus, 4, data);\n#endif\n\t\t}\n\t}\n\tpegasus->intr_interval = interval;\n}\n\nstatic void set_carrier(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tu16 tmp;\n\n\tif (read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))\n\t\treturn;\n\n\tif (tmp & BMSR_LSTATUS)\n\t\tnetif_carrier_on(net);\n\telse\n\t\tnetif_carrier_off(net);\n}\n\nstatic void free_all_urbs(pegasus_t *pegasus)\n{\n\tusb_free_urb(pegasus->intr_urb);\n\tusb_free_urb(pegasus->tx_urb);\n\tusb_free_urb(pegasus->rx_urb);\n}\n\nstatic void unlink_all_urbs(pegasus_t *pegasus)\n{\n\tusb_kill_urb(pegasus->intr_urb);\n\tusb_kill_urb(pegasus->tx_urb);\n\tusb_kill_urb(pegasus->rx_urb);\n}\n\nstatic int alloc_urbs(pegasus_t *pegasus)\n{\n\tint res = -ENOMEM;\n\n\tpegasus->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->rx_urb) {\n\t\treturn res;\n\t}\n\tpegasus->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->tx_urb) {\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\tpegasus->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->intr_urb) {\n\t\tusb_free_urb(pegasus->tx_urb);\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int pegasus_open(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res=-ENOMEM;\n\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!pegasus->rx_skb)\n\t\tgoto exit;\n\n\tres = set_registers(pegasus, EthID, 6, net->dev_addr);\n\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed rx_urb, %d\\n\", res);\n\t\tgoto exit;\n\t}\n\n\tusb_fill_int_urb(pegasus->intr_urb, pegasus->usb,\n\t\t\t usb_rcvintpipe(pegasus->usb, 3),\n\t\t\t pegasus->intr_buff, sizeof(pegasus->intr_buff),\n\t\t\t intr_callback, pegasus, pegasus->intr_interval);\n\tif ((res = usb_submit_urb(pegasus->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed intr_urb, %d\\n\", res);\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tgoto exit;\n\t}\n\tres = enable_net_traffic(net, pegasus->usb);\n\tif (res < 0) {\n\t\tnetif_dbg(pegasus, ifup, net,\n\t\t\t  \"can't enable_net_traffic() - %d\\n\", res);\n\t\tres = -EIO;\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t\tgoto exit;\n\t}\n\tset_carrier(net);\n\tnetif_start_queue(net);\n\tnetif_dbg(pegasus, ifup, net, \"open\\n\");\n\tres = 0;\nexit:\n\treturn res;\n}\n\nstatic int pegasus_close(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG))\n\t\tdisable_net_traffic(pegasus);\n\ttasklet_kill(&pegasus->rx_tl);\n\tunlink_all_urbs(pegasus);\n\n\treturn 0;\n}\n\nstatic void pegasus_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(pegasus->usb, info->bus_info, sizeof(info->bus_info));\n}\n\n/* also handles three patterns of some kind in hardware */\n#define\tWOL_SUPPORTED\t(WAKE_MAGIC|WAKE_PHY)\n\nstatic void\npegasus_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = pegasus->wolopts;\n}\n\nstatic int\npegasus_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\tu8\t\treg78 = 0x04;\n\tint\t\tret;\n\n\tif (wol->wolopts & ~WOL_SUPPORTED)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\treg78 |= 0x80;\n\tif (wol->wolopts & WAKE_PHY)\n\t\treg78 |= 0x40;\n\t/* FIXME this 0x10 bit still needs to get set in the chip... */\n\tif (wol->wolopts)\n\t\tpegasus->eth_regs[0] |= 0x10;\n\telse\n\t\tpegasus->eth_regs[0] &= ~0x10;\n\tpegasus->wolopts = wol->wolopts;\n\n\tret = set_register(pegasus, WakeupControl, reg78);\n\tif (!ret)\n\t\tret = device_set_wakeup_enable(&pegasus->usb->dev,\n\t\t\t\t\t\twol->wolopts);\n\treturn ret;\n}\n\nstatic inline void pegasus_reset_wol(struct net_device *dev)\n{\n\tstruct ethtool_wolinfo wol;\n\n\tmemset(&wol, 0, sizeof wol);\n\t(void) pegasus_set_wol(dev, &wol);\n}\n\nstatic int\npegasus_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus;\n\n\tpegasus = netdev_priv(dev);\n\tmii_ethtool_gset(&pegasus->mii, ecmd);\n\treturn 0;\n}\n\nstatic int\npegasus_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_ethtool_sset(&pegasus->mii, ecmd);\n}\n\nstatic int pegasus_nway_reset(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_nway_restart(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_link(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_link_ok(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_msglevel(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn pegasus->msg_enable;\n}\n\nstatic void pegasus_set_msglevel(struct net_device *dev, u32 v)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tpegasus->msg_enable = v;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = pegasus_get_drvinfo,\n\t.get_settings = pegasus_get_settings,\n\t.set_settings = pegasus_set_settings,\n\t.nway_reset = pegasus_nway_reset,\n\t.get_link = pegasus_get_link,\n\t.get_msglevel = pegasus_get_msglevel,\n\t.set_msglevel = pegasus_set_msglevel,\n\t.get_wol = pegasus_get_wol,\n\t.set_wol = pegasus_set_wol,\n};\n\nstatic int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\t__u16 *data = (__u16 *) &rq->ifr_ifru;\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = pegasus->phy;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tread_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);\n\t\tres = 0;\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(pegasus, pegasus->phy, data[1] & 0x1f, &data[2]);\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\treturn res;\n}\n\nstatic void pegasus_set_multicast(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tpegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;\n\t\tnetif_info(pegasus, link, net, \"Promiscuous mode enabled\\n\");\n\t} else if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\n\t\tpegasus->eth_regs[EthCtrl0] |= RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t\tnetif_dbg(pegasus, link, net, \"set allmulti\\n\");\n\t} else {\n\t\tpegasus->eth_regs[EthCtrl0] &= ~RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t}\n\tupdate_eth_regs_async(pegasus);\n}\n\nstatic __u8 mii_phy_probe(pegasus_t *pegasus)\n{\n\tint i;\n\t__u16 tmp;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tread_mii_word(pegasus, i, MII_BMSR, &tmp);\n\t\tif (tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn i;\n\t}\n\n\treturn 0xff;\n}\n\nstatic inline void setup_pegasus_II(pegasus_t *pegasus)\n{\n\t__u8 data = 0xa5;\n\n\tset_register(pegasus, Reg1d, 0);\n\tset_register(pegasus, Reg7b, 1);\n\tmdelay(100);\n\tif ((pegasus->features & HAS_HOME_PNA) && mii_mode)\n\t\tset_register(pegasus, Reg7b, 0);\n\telse\n\t\tset_register(pegasus, Reg7b, 2);\n\n\tset_register(pegasus, 0x83, data);\n\tget_registers(pegasus, 0x83, 1, &data);\n\n\tif (data == 0xa5)\n\t\tpegasus->chip = 0x8513;\n\telse\n\t\tpegasus->chip = 0;\n\n\tset_register(pegasus, 0x80, 0xc0);\n\tset_register(pegasus, 0x83, 0xff);\n\tset_register(pegasus, 0x84, 0x01);\n\n\tif (pegasus->features & HAS_HOME_PNA && mii_mode)\n\t\tset_register(pegasus, Reg81, 6);\n\telse\n\t\tset_register(pegasus, Reg81, 2);\n}\n\n\nstatic int pegasus_count;\nstatic struct workqueue_struct *pegasus_workqueue;\n#define CARRIER_CHECK_DELAY (2 * HZ)\n\nstatic void check_carrier(struct work_struct *work)\n{\n\tpegasus_t *pegasus = container_of(work, pegasus_t, carrier_check.work);\n\tset_carrier(pegasus->net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG)) {\n\t\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\tCARRIER_CHECK_DELAY);\n\t}\n}\n\nstatic int pegasus_blacklisted(struct usb_device *udev)\n{\n\tstruct usb_device_descriptor *udd = &udev->descriptor;\n\n\t/* Special quirk to keep the driver from handling the Belkin Bluetooth\n\t * dongle which happens to have the same ID.\n\t */\n\tif ((udd->idVendor == cpu_to_le16(VENDOR_BELKIN)) &&\n\t    (udd->idProduct == cpu_to_le16(0x0121)) &&\n\t    (udd->bDeviceClass == USB_CLASS_WIRELESS_CONTROLLER) &&\n\t    (udd->bDeviceProtocol == 1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/* we rely on probe() and remove() being serialized so we\n * don't need extra locking on pegasus_count.\n */\nstatic void pegasus_dec_workqueue(void)\n{\n\tpegasus_count--;\n\tif (pegasus_count == 0) {\n\t\tdestroy_workqueue(pegasus_workqueue);\n\t\tpegasus_workqueue = NULL;\n\t}\n}\n\nstatic int pegasus_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct net_device *net;\n\tpegasus_t *pegasus;\n\tint dev_index = id - pegasus_ids;\n\tint res = -ENOMEM;\n\n\tif (pegasus_blacklisted(dev))\n\t\treturn -ENODEV;\n\n\tif (pegasus_count == 0) {\n\t\tpegasus_workqueue = alloc_workqueue(\"pegasus\", WQ_MEM_RECLAIM,\n\t\t\t\t\t\t    0);\n\t\tif (!pegasus_workqueue)\n\t\t\treturn -ENOMEM;\n\t}\n\tpegasus_count++;\n\n\tnet = alloc_etherdev(sizeof(struct pegasus));\n\tif (!net)\n\t\tgoto out;\n\n\tpegasus = netdev_priv(net);\n\tpegasus->dev_index = dev_index;\n\n\tres = alloc_urbs(pegasus);\n\tif (res < 0) {\n\t\tdev_err(&intf->dev, \"can't allocate %s\\n\", \"urbs\");\n\t\tgoto out1;\n\t}\n\n\ttasklet_init(&pegasus->rx_tl, rx_fixup, (unsigned long) pegasus);\n\n\tINIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);\n\n\tpegasus->intf = intf;\n\tpegasus->usb = dev;\n\tpegasus->net = net;\n\n\n\tnet->watchdog_timeo = PEGASUS_TX_TIMEOUT;\n\tnet->netdev_ops = &pegasus_netdev_ops;\n\tnet->ethtool_ops = &ops;\n\tpegasus->mii.dev = net;\n\tpegasus->mii.mdio_read = mdio_read;\n\tpegasus->mii.mdio_write = mdio_write;\n\tpegasus->mii.phy_id_mask = 0x1f;\n\tpegasus->mii.reg_num_mask = 0x1f;\n\tpegasus->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV\n\t\t\t\t| NETIF_MSG_PROBE | NETIF_MSG_LINK);\n\n\tpegasus->features = usb_dev_id[dev_index].private;\n\tget_interrupt_interval(pegasus);\n\tif (reset_mac(pegasus)) {\n\t\tdev_err(&intf->dev, \"can't reset MAC\\n\");\n\t\tres = -EIO;\n\t\tgoto out2;\n\t}\n\tset_ethernet_addr(pegasus);\n\tif (pegasus->features & PEGASUS_II) {\n\t\tdev_info(&intf->dev, \"setup Pegasus II specific registers\\n\");\n\t\tsetup_pegasus_II(pegasus);\n\t}\n\tpegasus->phy = mii_phy_probe(pegasus);\n\tif (pegasus->phy == 0xff) {\n\t\tdev_warn(&intf->dev, \"can't locate MII phy, using default\\n\");\n\t\tpegasus->phy = 1;\n\t}\n\tpegasus->mii.phy_id = pegasus->phy;\n\tusb_set_intfdata(intf, pegasus);\n\tSET_NETDEV_DEV(net, &intf->dev);\n\tpegasus_reset_wol(net);\n\tres = register_netdev(net);\n\tif (res)\n\t\tgoto out3;\n\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\t   CARRIER_CHECK_DELAY);\n\tdev_info(&intf->dev, \"%s, %s, %pM\\n\", net->name,\n\t\t usb_dev_id[dev_index].name, net->dev_addr);\n\treturn 0;\n\nout3:\n\tusb_set_intfdata(intf, NULL);\nout2:\n\tfree_all_urbs(pegasus);\nout1:\n\tfree_netdev(net);\nout:\n\tpegasus_dec_workqueue();\n\treturn res;\n}\n\nstatic void pegasus_disconnect(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (!pegasus) {\n\t\tdev_dbg(&intf->dev, \"unregistering non-bound device?\\n\");\n\t\treturn;\n\t}\n\n\tpegasus->flags |= PEGASUS_UNPLUG;\n\tcancel_delayed_work(&pegasus->carrier_check);\n\tunregister_netdev(pegasus->net);\n\tunlink_all_urbs(pegasus);\n\tfree_all_urbs(pegasus);\n\tif (pegasus->rx_skb != NULL) {\n\t\tdev_kfree_skb(pegasus->rx_skb);\n\t\tpegasus->rx_skb = NULL;\n\t}\n\tfree_netdev(pegasus->net);\n\tpegasus_dec_workqueue();\n}\n\nstatic int pegasus_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_detach(pegasus->net);\n\tcancel_delayed_work(&pegasus->carrier_check);\n\tif (netif_running(pegasus->net)) {\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int pegasus_resume(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_attach(pegasus->net);\n\tif (netif_running(pegasus->net)) {\n\t\tpegasus->rx_urb->status = 0;\n\t\tpegasus->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(pegasus->rx_urb);\n\n\t\tpegasus->intr_urb->status = 0;\n\t\tpegasus->intr_urb->actual_length = 0;\n\t\tintr_callback(pegasus->intr_urb);\n\t}\n\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\t\tCARRIER_CHECK_DELAY);\n\treturn 0;\n}\n\nstatic const struct net_device_ops pegasus_netdev_ops = {\n\t.ndo_open =\t\t\tpegasus_open,\n\t.ndo_stop =\t\t\tpegasus_close,\n\t.ndo_do_ioctl =\t\t\tpegasus_ioctl,\n\t.ndo_start_xmit =\t\tpegasus_start_xmit,\n\t.ndo_set_rx_mode =\t\tpegasus_set_multicast,\n\t.ndo_get_stats =\t\tpegasus_netdev_stats,\n\t.ndo_tx_timeout =\t\tpegasus_tx_timeout,\n\t.ndo_set_mac_address =\t\teth_mac_addr,\n\t.ndo_validate_addr =\t\teth_validate_addr,\n};\n\nstatic struct usb_driver pegasus_driver = {\n\t.name = driver_name,\n\t.probe = pegasus_probe,\n\t.disconnect = pegasus_disconnect,\n\t.id_table = pegasus_ids,\n\t.suspend = pegasus_suspend,\n\t.resume = pegasus_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic void __init parse_id(char *id)\n{\n\tunsigned int vendor_id = 0, device_id = 0, flags = 0, i = 0;\n\tchar *token, *name = NULL;\n\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tname = token;\n\t/* name now points to a null terminated string*/\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tvendor_id = simple_strtoul(token, NULL, 16);\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tdevice_id = simple_strtoul(token, NULL, 16);\n\tflags = simple_strtoul(id, NULL, 16);\n\tpr_info(\"%s: new device %s, vendor ID 0x%04x, device ID 0x%04x, flags: 0x%x\\n\",\n\t\tdriver_name, name, vendor_id, device_id, flags);\n\n\tif (vendor_id > 0x10000 || vendor_id == 0)\n\t\treturn;\n\tif (device_id > 0x10000 || device_id == 0)\n\t\treturn;\n\n\tfor (i = 0; usb_dev_id[i].name; i++);\n\tusb_dev_id[i].name = name;\n\tusb_dev_id[i].vendor = vendor_id;\n\tusb_dev_id[i].device = device_id;\n\tusb_dev_id[i].private = flags;\n\tpegasus_ids[i].match_flags = USB_DEVICE_ID_MATCH_DEVICE;\n\tpegasus_ids[i].idVendor = vendor_id;\n\tpegasus_ids[i].idProduct = device_id;\n}\n\nstatic int __init pegasus_init(void)\n{\n\tpr_info(\"%s: %s, \" DRIVER_DESC \"\\n\", driver_name, DRIVER_VERSION);\n\tif (devid)\n\t\tparse_id(devid);\n\treturn usb_register(&pegasus_driver);\n}\n\nstatic void __exit pegasus_exit(void)\n{\n\tusb_deregister(&pegasus_driver);\n}\n\nmodule_init(pegasus_init);\nmodule_exit(pegasus_exit);\n"], "fixing_code": ["/*\n *  Copyright (c) 1999-2013 Petko Manolov (petkan@nucleusys.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n *\tChangeLog:\n *\t\t....\tMost of the time spent on reading sources & docs.\n *\t\tv0.2.x\tFirst official release for the Linux kernel.\n *\t\tv0.3.0\tBeutified and structured, some bugs fixed.\n *\t\tv0.3.x\tURBifying bulk requests and bugfixing. First relatively\n *\t\t\tstable release. Still can touch device's registers only\n *\t\t\tfrom top-halves.\n *\t\tv0.4.0\tControl messages remained unurbified are now URBs.\n *\t\t\tNow we can touch the HW at any time.\n *\t\tv0.4.9\tControl urbs again use process context to wait. Argh...\n *\t\t\tSome long standing bugs (enable_net_traffic) fixed.\n *\t\t\tAlso nasty trick about resubmiting control urb from\n *\t\t\tinterrupt context used. Please let me know how it\n *\t\t\tbehaves. Pegasus II support added since this version.\n *\t\t\tTODO: suppressing HCD warnings spewage on disconnect.\n *\t\tv0.4.13\tEthernet address is now set at probe(), not at open()\n *\t\t\ttime as this seems to break dhcpd.\n *\t\tv0.5.0\tbranch to 2.5.x kernels\n *\t\tv0.5.1\tethtool support added\n *\t\tv0.5.5\trx socket buffers are in a pool and the their allocation\n *\t\t\tis out of the interrupt routine.\n *\t\t...\n *\t\tv0.9.3\tsimplified [get|set]_register(s), async update registers\n *\t\t\tlogic revisited, receive skb_pool removed.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include \"pegasus.h\"\n\n/*\n * Version Information\n */\n#define DRIVER_VERSION \"v0.9.3 (2013/04/25)\"\n#define DRIVER_AUTHOR \"Petko Manolov <petkan@nucleusys.com>\"\n#define DRIVER_DESC \"Pegasus/Pegasus II USB Ethernet driver\"\n\nstatic const char driver_name[] = \"pegasus\";\n\n#undef\tPEGASUS_WRITE_EEPROM\n#define\tBMSR_MEDIA\t(BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | \\\n\t\t\tBMSR_100FULL | BMSR_ANEGCAPABLE)\n\nstatic bool loopback;\nstatic bool mii_mode;\nstatic char *devid;\n\nstatic struct usb_eth_dev usb_dev_id[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags)\t\\\n\t{.name = pn, .vendor = vid, .device = pid, .private = flags},\n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\tPEGASUS_DEV(pn, vid, pid, flags)\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{NULL, 0, 0, 0},\n\t{NULL, 0, 0, 0}\n};\n\nstatic struct usb_device_id pegasus_ids[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags) \\\n\t{.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = vid, .idProduct = pid},\n/*\n * The Belkin F8T012xx1 bluetooth adaptor has the same vendor and product\n * IDs as the Belkin F5D5050, so we need to teach the pegasus driver to\n * ignore adaptors belonging to the \"Wireless\" class 0xE0. For this one\n * case anyway, seeing as the pegasus is for \"Wired\" adaptors.\n */\n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\t{.match_flags = (USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_CLASS), \\\n\t.idVendor = vid, .idProduct = pid, .bDeviceClass = dclass},\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{},\n\t{}\n};\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(loopback, bool, 0);\nmodule_param(mii_mode, bool, 0);\nmodule_param(devid, charp, 0);\nMODULE_PARM_DESC(loopback, \"Enable MAC loopback mode (bit 0)\");\nMODULE_PARM_DESC(mii_mode, \"Enable HomePNA mode (bit 0),default=MII mode = 0\");\nMODULE_PARM_DESC(devid, \"The format is: 'DEV_name:VendorID:DeviceID:Flags'\");\n\n/* use ethtool to change the level for any given device */\nstatic int msg_level = -1;\nmodule_param(msg_level, int, 0);\nMODULE_PARM_DESC(msg_level, \"Override default message level\");\n\nMODULE_DEVICE_TABLE(usb, pegasus_ids);\nstatic const struct net_device_ops pegasus_netdev_ops;\n\n/*****/\n\nstatic void async_ctrl_callback(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(&data, 1, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, buf, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int update_eth_regs_async(pegasus_t *pegasus)\n{\n\tint ret = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct usb_ctrlrequest *req;\n\n\treq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn ret;\n\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn ret;\n\t}\n\treq->bRequestType = PEGASUS_REQT_WRITE;\n\treq->bRequest = PEGASUS_REQ_SET_REGS;\n\treq->wValue = cpu_to_le16(0);\n\treq->wIndex = cpu_to_le16(EthCtrl0);\n\treq->wLength = cpu_to_le16(3);\n\n\tusb_fill_control_urb(async_urb, pegasus->usb,\n\t\t\t     usb_sndctrlpipe(pegasus->usb, 0), (void *)req,\n\t\t\t     pegasus->eth_regs, 3, async_ctrl_callback, req);\n\n\tret = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_err(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\t}\n\treturn ret;\n}\n\nstatic int __mii_op(pegasus_t *p, __u8 phy, __u8 indx, __u16 *regd, __u8 cmd)\n{\n\tint i;\n\t__u8 data[4] = { phy, 0, 0, indx };\n\t__le16 regdi;\n\tint ret = -ETIMEDOUT;\n\n\tif (cmd & PHY_WRITE) {\n\t\t__le16 *t = (__le16 *) & data[1];\n\t\t*t = cpu_to_le16(*regd);\n\t}\n\tset_register(p, PhyCtrl, 0);\n\tset_registers(p, PhyAddr, sizeof(data), data);\n\tset_register(p, PhyCtrl, (indx | cmd));\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(p, PhyCtrl, 1, data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (data[0] & PHY_DONE)\n\t\t\tbreak;\n\t}\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\tif (cmd & PHY_READ) {\n\t\tret = get_registers(p, PhyData, 2, &regdi);\n\t\t*regd = le16_to_cpu(regdi);\n\t\treturn ret;\n\t}\n\treturn 0;\nfail:\n\tnetif_dbg(p, drv, p->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\n/* Returns non-negative int on success, error on failure */\nstatic int read_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_READ);\n}\n\n/* Returns zero on success, error on failure */\nstatic int write_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_WRITE);\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tu16 res;\n\n\tread_mii_word(pegasus, phy_id, loc, &res);\n\treturn (int)res;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int val)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tu16 data = val;\n\n\twrite_mii_word(pegasus, phy_id, loc, &data);\n}\n\nstatic int read_eprom_word(pegasus_t *pegasus, __u8 index, __u16 *retdata)\n{\n\tint i;\n\t__u8 tmp;\n\t__le16 retdatai;\n\tint ret;\n\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EpromOffset, index);\n\tset_register(pegasus, EpromCtrl, EPROM_READ);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t\tif (ret == -ESHUTDOWN)\n\t\t\tgoto fail;\n\t}\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\n\tret = get_registers(pegasus, EpromData, 2, &retdatai);\n\t*retdata = le16_to_cpu(retdatai);\n\treturn ret;\n\nfail:\n\tnetif_warn(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n\n#ifdef\tPEGASUS_WRITE_EEPROM\nstatic inline void enable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE);\n}\n\nstatic inline void disable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE);\n}\n\nstatic int write_eprom_word(pegasus_t *pegasus, __u8 index, __u16 data)\n{\n\tint i;\n\t__u8 tmp, d[4] = { 0x3f, 0, 0, EPROM_WRITE };\n\tint ret;\n\t__le16 le_data = cpu_to_le16(data);\n\n\tset_registers(pegasus, EpromOffset, 4, d);\n\tenable_eprom_write(pegasus);\n\tset_register(pegasus, EpromOffset, index);\n\tset_registers(pegasus, EpromData, 2, &le_data);\n\tset_register(pegasus, EpromCtrl, EPROM_WRITE);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (ret == -ESHUTDOWN)\n\t\t\tgoto fail;\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t}\n\tdisable_eprom_write(pegasus);\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\n\treturn ret;\n\nfail:\n\tnetif_warn(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n#endif\t\t\t\t/* PEGASUS_WRITE_EEPROM */\n\nstatic inline void get_node_id(pegasus_t *pegasus, __u8 *id)\n{\n\tint i;\n\t__u16 w16;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tread_eprom_word(pegasus, i, &w16);\n\t\t((__le16 *) id)[i] = cpu_to_le16(w16);\n\t}\n}\n\nstatic void set_ethernet_addr(pegasus_t *pegasus)\n{\n\t__u8 node_id[6];\n\n\tif (pegasus->features & PEGASUS_II) {\n\t\tget_registers(pegasus, 0x10, sizeof(node_id), node_id);\n\t} else {\n\t\tget_node_id(pegasus, node_id);\n\t\tset_registers(pegasus, EthID, sizeof(node_id), node_id);\n\t}\n\tmemcpy(pegasus->net->dev_addr, node_id, sizeof(node_id));\n}\n\nstatic inline int reset_mac(pegasus_t *pegasus)\n{\n\t__u8 data = 0x8;\n\tint i;\n\n\tset_register(pegasus, EthCtrl1, data);\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tget_registers(pegasus, EthCtrl1, 1, &data);\n\t\tif (~data & 0x08) {\n\t\t\tif (loopback)\n\t\t\t\tbreak;\n\t\t\tif (mii_mode && (pegasus->features & HAS_HOME_PNA))\n\t\t\t\tset_register(pegasus, Gpio1, 0x34);\n\t\t\telse\n\t\t\t\tset_register(pegasus, Gpio1, 0x26);\n\t\t\tset_register(pegasus, Gpio0, pegasus->features);\n\t\t\tset_register(pegasus, Gpio0, DEFAULT_GPIO_SET);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == REG_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tset_register(pegasus, Gpio0, 0x24);\n\t\tset_register(pegasus, Gpio0, 0x26);\n\t}\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_ELCON) {\n\t\t__u16 auxmode;\n\t\tread_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t}\n\n\treturn 0;\n}\n\nstatic int enable_net_traffic(struct net_device *dev, struct usb_device *usb)\n{\n\t__u16 linkpart;\n\t__u8 data[4];\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tint ret;\n\n\tread_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart);\n\tdata[0] = 0xc8; /* TX & RX enable, append status, no CRC */\n\tdata[1] = 0;\n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL))\n\t\tdata[1] |= 0x20;\t/* set full duplex */\n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF))\n\t\tdata[1] |= 0x10;\t/* set 100 Mbps */\n\tif (mii_mode)\n\t\tdata[1] = 0;\n\tdata[2] = loopback ? 0x09 : 0x01;\n\n\tmemcpy(pegasus->eth_regs, data, sizeof(data));\n\tret = set_registers(pegasus, EthCtrl0, 3, data);\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS2 ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tu16 auxmode;\n\t\tread_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t}\n\n\treturn ret;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint rx_status, count = urb->actual_length;\n\tint status = urb->status;\n\tu8 *buf = urb->transfer_buffer;\n\t__u16 pkt_len;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ETIME:\n\t\tnetif_dbg(pegasus, rx_err, net, \"reset MAC\\n\");\n\t\tpegasus->flags &= ~PEGASUS_RX_BUSY;\n\t\tbreak;\n\tcase -EPIPE:\t\t/* stall, or disconnect from TT */\n\t\t/* FIXME schedule work to clear the halt */\n\t\tnetif_warn(pegasus, rx_err, net, \"no rx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"rx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_dbg(pegasus, rx_err, net, \"RX status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (count < 4)\n\t\tgoto goon;\n\n\trx_status = buf[count - 2];\n\tif (rx_status & 0x1e) {\n\t\tnetif_dbg(pegasus, rx_err, net,\n\t\t\t  \"RX packet error %x\\n\", rx_status);\n\t\tpegasus->stats.rx_errors++;\n\t\tif (rx_status & 0x06)\t/* long or runt\t*/\n\t\t\tpegasus->stats.rx_length_errors++;\n\t\tif (rx_status & 0x08)\n\t\t\tpegasus->stats.rx_crc_errors++;\n\t\tif (rx_status & 0x10)\t/* extra bits\t*/\n\t\t\tpegasus->stats.rx_frame_errors++;\n\t\tgoto goon;\n\t}\n\tif (pegasus->chip == 0x8513) {\n\t\tpkt_len = le32_to_cpu(*(__le32 *)urb->transfer_buffer);\n\t\tpkt_len &= 0x0fff;\n\t\tpegasus->rx_skb->data += 2;\n\t} else {\n\t\tpkt_len = buf[count - 3] << 8;\n\t\tpkt_len += buf[count - 4];\n\t\tpkt_len &= 0xfff;\n\t\tpkt_len -= 4;\n\t}\n\n\t/*\n\t * If the packet is unreasonably long, quietly drop it rather than\n\t * kernel panicing by calling skb_put.\n\t */\n\tif (pkt_len > PEGASUS_MTU)\n\t\tgoto goon;\n\n\t/*\n\t * at this point we are sure pegasus->rx_skb != NULL\n\t * so we go ahead and pass up the packet.\n\t */\n\tskb_put(pegasus->rx_skb, pkt_len);\n\tpegasus->rx_skb->protocol = eth_type_trans(pegasus->rx_skb, net);\n\tnetif_rx(pegasus->rx_skb);\n\tpegasus->stats.rx_packets++;\n\tpegasus->stats.rx_bytes += pkt_len;\n\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net, PEGASUS_MTU,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\n\tif (pegasus->rx_skb == NULL)\n\t\tgoto tl_sched;\ngoon:\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\trx_status = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (rx_status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (rx_status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\tgoto tl_sched;\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n\n\treturn;\n\ntl_sched:\n\ttasklet_schedule(&pegasus->rx_tl);\n}\n\nstatic void rx_fixup(unsigned long data)\n{\n\tpegasus_t *pegasus;\n\tint status;\n\n\tpegasus = (pegasus_t *) data;\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tif (pegasus->flags & PEGASUS_RX_URB_FAIL)\n\t\tif (pegasus->rx_skb)\n\t\t\tgoto try_again;\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_ATOMIC);\n\tif (pegasus->rx_skb == NULL) {\n\t\tnetif_warn(pegasus, rx_err, pegasus->net, \"low on memory\\n\");\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t\treturn;\n\t}\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\ntry_again:\n\tstatus = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase -EPIPE:\n\t\t/* FIXME schedule_work() to clear the tx halt */\n\t\tnetif_stop_queue(net);\n\t\tnetif_warn(pegasus, tx_err, net, \"no tx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"tx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_info(pegasus, tx_err, net, \"TX status %d\\n\", status);\n\t\t/* FALL THROUGH */\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tnetif_trans_update(net); /* prevent tx timeout */\n\tnetif_wake_queue(net);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint res, status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\tnet = pegasus->net;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* some Pegasus-I products report LOTS of data\n\t\t * toggle errors... avoid log spamming\n\t\t */\n\t\tnetif_dbg(pegasus, timer, net, \"intr status %d\\n\", status);\n\t}\n\n\tif (urb->actual_length >= 6) {\n\t\tu8 *d = urb->transfer_buffer;\n\n\t\t/* byte 0 == tx_status1, reg 2B */\n\t\tif (d[0] & (TX_UNDERRUN|EXCESSIVE_COL\n\t\t\t\t\t|LATE_COL|JABBER_TIMEOUT)) {\n\t\t\tpegasus->stats.tx_errors++;\n\t\t\tif (d[0] & TX_UNDERRUN)\n\t\t\t\tpegasus->stats.tx_fifo_errors++;\n\t\t\tif (d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT))\n\t\t\t\tpegasus->stats.tx_aborted_errors++;\n\t\t\tif (d[0] & LATE_COL)\n\t\t\t\tpegasus->stats.tx_window_errors++;\n\t\t}\n\n\t\t/* d[5].LINK_STATUS lies on some adapters.\n\t\t * d[0].NO_CARRIER kicks in only with failed TX.\n\t\t * ... so monitoring with MII may be safest.\n\t\t */\n\n\t\t/* bytes 3-4 == rx_lostpkt, reg 2E/2F */\n\t\tpegasus->stats.rx_missed_errors += ((d[3] & 0x7f) << 8) | d[4];\n\t}\n\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\tif (res)\n\t\tnetif_err(pegasus, timer, net,\n\t\t\t  \"can't resubmit interrupt urb, %d\\n\", res);\n}\n\nstatic void pegasus_tx_timeout(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tnetif_warn(pegasus, timer, net, \"tx timeout\\n\");\n\tusb_unlink_urb(pegasus->tx_urb);\n\tpegasus->stats.tx_errors++;\n}\n\nstatic netdev_tx_t pegasus_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint count = ((skb->len + 2) & 0x3f) ? skb->len + 2 : skb->len + 3;\n\tint res;\n\t__u16 l16 = skb->len;\n\n\tnetif_stop_queue(net);\n\n\t((__le16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);\n\tskb_copy_from_linear_data(skb, pegasus->tx_buff + 2, skb->len);\n\tusb_fill_bulk_urb(pegasus->tx_urb, pegasus->usb,\n\t\t\t  usb_sndbulkpipe(pegasus->usb, 2),\n\t\t\t  pegasus->tx_buff, count,\n\t\t\t  write_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->tx_urb, GFP_ATOMIC))) {\n\t\tnetif_warn(pegasus, tx_err, net, \"fail tx, %d\\n\", res);\n\t\tswitch (res) {\n\t\tcase -EPIPE:\t\t/* stall, or disconnect from TT */\n\t\t\t/* cleanup should already have been scheduled */\n\t\t\tbreak;\n\t\tcase -ENODEV:\t\t/* disconnect() upcoming */\n\t\tcase -EPERM:\n\t\t\tnetif_device_detach(pegasus->net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpegasus->stats.tx_errors++;\n\t\t\tnetif_start_queue(net);\n\t\t}\n\t} else {\n\t\tpegasus->stats.tx_packets++;\n\t\tpegasus->stats.tx_bytes += skb->len;\n\t}\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *pegasus_netdev_stats(struct net_device *dev)\n{\n\treturn &((pegasus_t *) netdev_priv(dev))->stats;\n}\n\nstatic inline void disable_net_traffic(pegasus_t *pegasus)\n{\n\t__le16 tmp = cpu_to_le16(0);\n\n\tset_registers(pegasus, EthCtrl0, sizeof(tmp), &tmp);\n}\n\nstatic inline void get_interrupt_interval(pegasus_t *pegasus)\n{\n\tu16 data;\n\tu8 interval;\n\n\tread_eprom_word(pegasus, 4, &data);\n\tinterval = data >> 8;\n\tif (pegasus->usb->speed != USB_SPEED_HIGH) {\n\t\tif (interval < 0x80) {\n\t\t\tnetif_info(pegasus, timer, pegasus->net,\n\t\t\t\t   \"intr interval changed from %ums to %ums\\n\",\n\t\t\t\t   interval, 0x80);\n\t\t\tinterval = 0x80;\n\t\t\tdata = (data & 0x00FF) | ((u16)interval << 8);\n#ifdef PEGASUS_WRITE_EEPROM\n\t\t\twrite_eprom_word(pegasus, 4, data);\n#endif\n\t\t}\n\t}\n\tpegasus->intr_interval = interval;\n}\n\nstatic void set_carrier(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tu16 tmp;\n\n\tif (read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))\n\t\treturn;\n\n\tif (tmp & BMSR_LSTATUS)\n\t\tnetif_carrier_on(net);\n\telse\n\t\tnetif_carrier_off(net);\n}\n\nstatic void free_all_urbs(pegasus_t *pegasus)\n{\n\tusb_free_urb(pegasus->intr_urb);\n\tusb_free_urb(pegasus->tx_urb);\n\tusb_free_urb(pegasus->rx_urb);\n}\n\nstatic void unlink_all_urbs(pegasus_t *pegasus)\n{\n\tusb_kill_urb(pegasus->intr_urb);\n\tusb_kill_urb(pegasus->tx_urb);\n\tusb_kill_urb(pegasus->rx_urb);\n}\n\nstatic int alloc_urbs(pegasus_t *pegasus)\n{\n\tint res = -ENOMEM;\n\n\tpegasus->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->rx_urb) {\n\t\treturn res;\n\t}\n\tpegasus->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->tx_urb) {\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\tpegasus->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->intr_urb) {\n\t\tusb_free_urb(pegasus->tx_urb);\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int pegasus_open(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res=-ENOMEM;\n\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!pegasus->rx_skb)\n\t\tgoto exit;\n\n\tres = set_registers(pegasus, EthID, 6, net->dev_addr);\n\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed rx_urb, %d\\n\", res);\n\t\tgoto exit;\n\t}\n\n\tusb_fill_int_urb(pegasus->intr_urb, pegasus->usb,\n\t\t\t usb_rcvintpipe(pegasus->usb, 3),\n\t\t\t pegasus->intr_buff, sizeof(pegasus->intr_buff),\n\t\t\t intr_callback, pegasus, pegasus->intr_interval);\n\tif ((res = usb_submit_urb(pegasus->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed intr_urb, %d\\n\", res);\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tgoto exit;\n\t}\n\tres = enable_net_traffic(net, pegasus->usb);\n\tif (res < 0) {\n\t\tnetif_dbg(pegasus, ifup, net,\n\t\t\t  \"can't enable_net_traffic() - %d\\n\", res);\n\t\tres = -EIO;\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t\tgoto exit;\n\t}\n\tset_carrier(net);\n\tnetif_start_queue(net);\n\tnetif_dbg(pegasus, ifup, net, \"open\\n\");\n\tres = 0;\nexit:\n\treturn res;\n}\n\nstatic int pegasus_close(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG))\n\t\tdisable_net_traffic(pegasus);\n\ttasklet_kill(&pegasus->rx_tl);\n\tunlink_all_urbs(pegasus);\n\n\treturn 0;\n}\n\nstatic void pegasus_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(pegasus->usb, info->bus_info, sizeof(info->bus_info));\n}\n\n/* also handles three patterns of some kind in hardware */\n#define\tWOL_SUPPORTED\t(WAKE_MAGIC|WAKE_PHY)\n\nstatic void\npegasus_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = pegasus->wolopts;\n}\n\nstatic int\npegasus_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\tu8\t\treg78 = 0x04;\n\tint\t\tret;\n\n\tif (wol->wolopts & ~WOL_SUPPORTED)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\treg78 |= 0x80;\n\tif (wol->wolopts & WAKE_PHY)\n\t\treg78 |= 0x40;\n\t/* FIXME this 0x10 bit still needs to get set in the chip... */\n\tif (wol->wolopts)\n\t\tpegasus->eth_regs[0] |= 0x10;\n\telse\n\t\tpegasus->eth_regs[0] &= ~0x10;\n\tpegasus->wolopts = wol->wolopts;\n\n\tret = set_register(pegasus, WakeupControl, reg78);\n\tif (!ret)\n\t\tret = device_set_wakeup_enable(&pegasus->usb->dev,\n\t\t\t\t\t\twol->wolopts);\n\treturn ret;\n}\n\nstatic inline void pegasus_reset_wol(struct net_device *dev)\n{\n\tstruct ethtool_wolinfo wol;\n\n\tmemset(&wol, 0, sizeof wol);\n\t(void) pegasus_set_wol(dev, &wol);\n}\n\nstatic int\npegasus_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus;\n\n\tpegasus = netdev_priv(dev);\n\tmii_ethtool_gset(&pegasus->mii, ecmd);\n\treturn 0;\n}\n\nstatic int\npegasus_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_ethtool_sset(&pegasus->mii, ecmd);\n}\n\nstatic int pegasus_nway_reset(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_nway_restart(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_link(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_link_ok(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_msglevel(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn pegasus->msg_enable;\n}\n\nstatic void pegasus_set_msglevel(struct net_device *dev, u32 v)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tpegasus->msg_enable = v;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = pegasus_get_drvinfo,\n\t.get_settings = pegasus_get_settings,\n\t.set_settings = pegasus_set_settings,\n\t.nway_reset = pegasus_nway_reset,\n\t.get_link = pegasus_get_link,\n\t.get_msglevel = pegasus_get_msglevel,\n\t.set_msglevel = pegasus_set_msglevel,\n\t.get_wol = pegasus_get_wol,\n\t.set_wol = pegasus_set_wol,\n};\n\nstatic int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\t__u16 *data = (__u16 *) &rq->ifr_ifru;\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = pegasus->phy;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tread_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);\n\t\tres = 0;\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(pegasus, pegasus->phy, data[1] & 0x1f, &data[2]);\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\treturn res;\n}\n\nstatic void pegasus_set_multicast(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tpegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;\n\t\tnetif_info(pegasus, link, net, \"Promiscuous mode enabled\\n\");\n\t} else if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\n\t\tpegasus->eth_regs[EthCtrl0] |= RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t\tnetif_dbg(pegasus, link, net, \"set allmulti\\n\");\n\t} else {\n\t\tpegasus->eth_regs[EthCtrl0] &= ~RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t}\n\tupdate_eth_regs_async(pegasus);\n}\n\nstatic __u8 mii_phy_probe(pegasus_t *pegasus)\n{\n\tint i;\n\t__u16 tmp;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tread_mii_word(pegasus, i, MII_BMSR, &tmp);\n\t\tif (tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn i;\n\t}\n\n\treturn 0xff;\n}\n\nstatic inline void setup_pegasus_II(pegasus_t *pegasus)\n{\n\t__u8 data = 0xa5;\n\n\tset_register(pegasus, Reg1d, 0);\n\tset_register(pegasus, Reg7b, 1);\n\tmdelay(100);\n\tif ((pegasus->features & HAS_HOME_PNA) && mii_mode)\n\t\tset_register(pegasus, Reg7b, 0);\n\telse\n\t\tset_register(pegasus, Reg7b, 2);\n\n\tset_register(pegasus, 0x83, data);\n\tget_registers(pegasus, 0x83, 1, &data);\n\n\tif (data == 0xa5)\n\t\tpegasus->chip = 0x8513;\n\telse\n\t\tpegasus->chip = 0;\n\n\tset_register(pegasus, 0x80, 0xc0);\n\tset_register(pegasus, 0x83, 0xff);\n\tset_register(pegasus, 0x84, 0x01);\n\n\tif (pegasus->features & HAS_HOME_PNA && mii_mode)\n\t\tset_register(pegasus, Reg81, 6);\n\telse\n\t\tset_register(pegasus, Reg81, 2);\n}\n\n\nstatic int pegasus_count;\nstatic struct workqueue_struct *pegasus_workqueue;\n#define CARRIER_CHECK_DELAY (2 * HZ)\n\nstatic void check_carrier(struct work_struct *work)\n{\n\tpegasus_t *pegasus = container_of(work, pegasus_t, carrier_check.work);\n\tset_carrier(pegasus->net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG)) {\n\t\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\tCARRIER_CHECK_DELAY);\n\t}\n}\n\nstatic int pegasus_blacklisted(struct usb_device *udev)\n{\n\tstruct usb_device_descriptor *udd = &udev->descriptor;\n\n\t/* Special quirk to keep the driver from handling the Belkin Bluetooth\n\t * dongle which happens to have the same ID.\n\t */\n\tif ((udd->idVendor == cpu_to_le16(VENDOR_BELKIN)) &&\n\t    (udd->idProduct == cpu_to_le16(0x0121)) &&\n\t    (udd->bDeviceClass == USB_CLASS_WIRELESS_CONTROLLER) &&\n\t    (udd->bDeviceProtocol == 1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/* we rely on probe() and remove() being serialized so we\n * don't need extra locking on pegasus_count.\n */\nstatic void pegasus_dec_workqueue(void)\n{\n\tpegasus_count--;\n\tif (pegasus_count == 0) {\n\t\tdestroy_workqueue(pegasus_workqueue);\n\t\tpegasus_workqueue = NULL;\n\t}\n}\n\nstatic int pegasus_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct net_device *net;\n\tpegasus_t *pegasus;\n\tint dev_index = id - pegasus_ids;\n\tint res = -ENOMEM;\n\n\tif (pegasus_blacklisted(dev))\n\t\treturn -ENODEV;\n\n\tif (pegasus_count == 0) {\n\t\tpegasus_workqueue = alloc_workqueue(\"pegasus\", WQ_MEM_RECLAIM,\n\t\t\t\t\t\t    0);\n\t\tif (!pegasus_workqueue)\n\t\t\treturn -ENOMEM;\n\t}\n\tpegasus_count++;\n\n\tnet = alloc_etherdev(sizeof(struct pegasus));\n\tif (!net)\n\t\tgoto out;\n\n\tpegasus = netdev_priv(net);\n\tpegasus->dev_index = dev_index;\n\n\tres = alloc_urbs(pegasus);\n\tif (res < 0) {\n\t\tdev_err(&intf->dev, \"can't allocate %s\\n\", \"urbs\");\n\t\tgoto out1;\n\t}\n\n\ttasklet_init(&pegasus->rx_tl, rx_fixup, (unsigned long) pegasus);\n\n\tINIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);\n\n\tpegasus->intf = intf;\n\tpegasus->usb = dev;\n\tpegasus->net = net;\n\n\n\tnet->watchdog_timeo = PEGASUS_TX_TIMEOUT;\n\tnet->netdev_ops = &pegasus_netdev_ops;\n\tnet->ethtool_ops = &ops;\n\tpegasus->mii.dev = net;\n\tpegasus->mii.mdio_read = mdio_read;\n\tpegasus->mii.mdio_write = mdio_write;\n\tpegasus->mii.phy_id_mask = 0x1f;\n\tpegasus->mii.reg_num_mask = 0x1f;\n\tpegasus->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV\n\t\t\t\t| NETIF_MSG_PROBE | NETIF_MSG_LINK);\n\n\tpegasus->features = usb_dev_id[dev_index].private;\n\tget_interrupt_interval(pegasus);\n\tif (reset_mac(pegasus)) {\n\t\tdev_err(&intf->dev, \"can't reset MAC\\n\");\n\t\tres = -EIO;\n\t\tgoto out2;\n\t}\n\tset_ethernet_addr(pegasus);\n\tif (pegasus->features & PEGASUS_II) {\n\t\tdev_info(&intf->dev, \"setup Pegasus II specific registers\\n\");\n\t\tsetup_pegasus_II(pegasus);\n\t}\n\tpegasus->phy = mii_phy_probe(pegasus);\n\tif (pegasus->phy == 0xff) {\n\t\tdev_warn(&intf->dev, \"can't locate MII phy, using default\\n\");\n\t\tpegasus->phy = 1;\n\t}\n\tpegasus->mii.phy_id = pegasus->phy;\n\tusb_set_intfdata(intf, pegasus);\n\tSET_NETDEV_DEV(net, &intf->dev);\n\tpegasus_reset_wol(net);\n\tres = register_netdev(net);\n\tif (res)\n\t\tgoto out3;\n\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\t   CARRIER_CHECK_DELAY);\n\tdev_info(&intf->dev, \"%s, %s, %pM\\n\", net->name,\n\t\t usb_dev_id[dev_index].name, net->dev_addr);\n\treturn 0;\n\nout3:\n\tusb_set_intfdata(intf, NULL);\nout2:\n\tfree_all_urbs(pegasus);\nout1:\n\tfree_netdev(net);\nout:\n\tpegasus_dec_workqueue();\n\treturn res;\n}\n\nstatic void pegasus_disconnect(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (!pegasus) {\n\t\tdev_dbg(&intf->dev, \"unregistering non-bound device?\\n\");\n\t\treturn;\n\t}\n\n\tpegasus->flags |= PEGASUS_UNPLUG;\n\tcancel_delayed_work(&pegasus->carrier_check);\n\tunregister_netdev(pegasus->net);\n\tunlink_all_urbs(pegasus);\n\tfree_all_urbs(pegasus);\n\tif (pegasus->rx_skb != NULL) {\n\t\tdev_kfree_skb(pegasus->rx_skb);\n\t\tpegasus->rx_skb = NULL;\n\t}\n\tfree_netdev(pegasus->net);\n\tpegasus_dec_workqueue();\n}\n\nstatic int pegasus_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_detach(pegasus->net);\n\tcancel_delayed_work(&pegasus->carrier_check);\n\tif (netif_running(pegasus->net)) {\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int pegasus_resume(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_attach(pegasus->net);\n\tif (netif_running(pegasus->net)) {\n\t\tpegasus->rx_urb->status = 0;\n\t\tpegasus->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(pegasus->rx_urb);\n\n\t\tpegasus->intr_urb->status = 0;\n\t\tpegasus->intr_urb->actual_length = 0;\n\t\tintr_callback(pegasus->intr_urb);\n\t}\n\tqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n\t\t\t\tCARRIER_CHECK_DELAY);\n\treturn 0;\n}\n\nstatic const struct net_device_ops pegasus_netdev_ops = {\n\t.ndo_open =\t\t\tpegasus_open,\n\t.ndo_stop =\t\t\tpegasus_close,\n\t.ndo_do_ioctl =\t\t\tpegasus_ioctl,\n\t.ndo_start_xmit =\t\tpegasus_start_xmit,\n\t.ndo_set_rx_mode =\t\tpegasus_set_multicast,\n\t.ndo_get_stats =\t\tpegasus_netdev_stats,\n\t.ndo_tx_timeout =\t\tpegasus_tx_timeout,\n\t.ndo_set_mac_address =\t\teth_mac_addr,\n\t.ndo_validate_addr =\t\teth_validate_addr,\n};\n\nstatic struct usb_driver pegasus_driver = {\n\t.name = driver_name,\n\t.probe = pegasus_probe,\n\t.disconnect = pegasus_disconnect,\n\t.id_table = pegasus_ids,\n\t.suspend = pegasus_suspend,\n\t.resume = pegasus_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic void __init parse_id(char *id)\n{\n\tunsigned int vendor_id = 0, device_id = 0, flags = 0, i = 0;\n\tchar *token, *name = NULL;\n\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tname = token;\n\t/* name now points to a null terminated string*/\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tvendor_id = simple_strtoul(token, NULL, 16);\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tdevice_id = simple_strtoul(token, NULL, 16);\n\tflags = simple_strtoul(id, NULL, 16);\n\tpr_info(\"%s: new device %s, vendor ID 0x%04x, device ID 0x%04x, flags: 0x%x\\n\",\n\t\tdriver_name, name, vendor_id, device_id, flags);\n\n\tif (vendor_id > 0x10000 || vendor_id == 0)\n\t\treturn;\n\tif (device_id > 0x10000 || device_id == 0)\n\t\treturn;\n\n\tfor (i = 0; usb_dev_id[i].name; i++);\n\tusb_dev_id[i].name = name;\n\tusb_dev_id[i].vendor = vendor_id;\n\tusb_dev_id[i].device = device_id;\n\tusb_dev_id[i].private = flags;\n\tpegasus_ids[i].match_flags = USB_DEVICE_ID_MATCH_DEVICE;\n\tpegasus_ids[i].idVendor = vendor_id;\n\tpegasus_ids[i].idProduct = device_id;\n}\n\nstatic int __init pegasus_init(void)\n{\n\tpr_info(\"%s: %s, \" DRIVER_DESC \"\\n\", driver_name, DRIVER_VERSION);\n\tif (devid)\n\t\tparse_id(devid);\n\treturn usb_register(&pegasus_driver);\n}\n\nstatic void __exit pegasus_exit(void)\n{\n\tusb_deregister(&pegasus_driver);\n}\n\nmodule_init(pegasus_init);\nmodule_exit(pegasus_exit);\n"], "filenames": ["drivers/net/usb/pegasus.c"], "buggy_code_start_loc": [128], "buggy_code_end_loc": [162], "fixing_code_start_loc": [129], "fixing_code_end_loc": [184], "type": "CWE-119", "message": "drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8068", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.473", "lastModified": "2017-04-27T16:51:53.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/net/usb/pegasus.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.11 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98000", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/98008", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5593523f968bc86d42a035c6df47d5e0979b5ace", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace"}}