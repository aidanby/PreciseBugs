{"buggy_code": ["#!/usr/bin/env python3\n#\n# Copyright (C) 2018-2020 Ycarus (Yannick Chabanois) <ycarus@zugaina.org> for OpenMPTCProuter\n#\n# This is free software, licensed under the GNU General Public License v3.0.\n# See /LICENSE for more information.\n#\n\nimport json\nimport base64\nimport secrets\nimport uuid\nimport configparser\nimport argparse\nimport subprocess\nimport os\nimport sys\nimport socket\nimport re\nimport hashlib\nimport pathlib\nimport psutil\nimport time\nimport uuid\nfrom pprint import pprint\nfrom datetime import datetime, timedelta\nfrom tempfile import mkstemp\nfrom typing import List, Optional\nfrom shutil import move\nfrom enum import Enum\nfrom os import path\nimport logging\nimport uvicorn\nimport jwt\nfrom jwt import PyJWTError\nfrom netaddr import *\nfrom netjsonconfig import OpenWrt\nfrom fastapi import Depends, FastAPI, HTTPException, Security, Query, Request\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, OAuth2\nfrom passlib.context import CryptContext\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom fastapi.openapi.docs import get_swagger_ui_html\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.openapi.models import SecurityBase as SecurityBaseModel\nfrom fastapi.responses import StreamingResponse, FileResponse\nfrom pydantic import BaseModel, ValidationError # pylint: disable=E0611\nfrom starlette.status import HTTP_403_FORBIDDEN\nfrom starlette.responses import RedirectResponse, Response, JSONResponse\n#from starlette.requests import Request\nimport netifaces\n\nLOG = logging.getLogger('api')\nLOG.setLevel(logging.ERROR)\n#LOG.setLevel(logging.DEBUG)\n\n# Generate a random secret key\nSECRET_KEY = uuid.uuid4().hex\nJWT_SECRET_KEY = uuid.uuid4().hex\nPERMANENT_SESSION_LIFETIME = timedelta(hours=24)\nACCESS_TOKEN_EXPIRE_MINUTES = 1440\nALGORITHM = \"HS256\"\n\n# Get main net interface\nFILE = open('/etc/shorewall/params.net', \"r\")\nREAD = FILE.read()\nIFACE = None\nfor line in READ.splitlines():\n    if 'NET_IFACE=' in line:\n        IFACE = line.split('=', 1)[1]\nFILE.close()\n\n# Get ipv6 net interface\nFILE = open('/etc/shorewall6/params.net', \"r\")\nREAD = FILE.read()\nIFACE6 = None\nfor line in READ.splitlines():\n    if 'NET_IFACE=' in line:\n        IFACE6 = line.split('=', 1)[1]\nFILE.close()\n\n# Get interface rx/tx\ndef get_bytes(t, iface='eth0'):\n    if path.exists('/sys/class/net/' + iface + '/statistics/' + t + '_bytes'):\n        with open('/sys/class/net/' + iface + '/statistics/' + t + '_bytes', 'r') as f:\n            data = f.read()\n        return int(data)\n    return 0\n\ndef get_bytes_ss(port):\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        ss_socket.settimeout(1)\n        ss_socket.sendto('ping'.encode(), (\"127.0.0.1\", 8839))\n        ss_recv = ss_socket.recv(1024)\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks stats timeout (\" + str(err) + \")\")\n        return 0\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks stats error (\" + str(err) + \")\")\n        return 0\n    json_txt = ss_recv.decode(\"utf-8\").replace('stat: ', '')\n    result = json.loads(json_txt)\n    if str(port) in result:\n        return result[str(port)]\n    return 0\n\ndef get_bytes_v2ray(t,user):\n    if t == \"tx\":\n        side=\"downlink\"\n    else:\n        side=\"uplink\"\n    try:\n        data = subprocess.check_output('/usr/bin/v2ctl api --server=127.0.0.1:10085 StatsService.GetStats ' + \"'\" + 'name: \"user>>>' + user + '>>>traffic>>>' + side + '\"' + \"'\" + ' 2>/dev/null | grep value | cut -d: -f2 | tr -d \" \"', shell = True)\n    except:\n        return 0\n    if data.decode(\"utf-8\") != '':\n        return int(data.decode(\"utf-8\"))\n    else:\n        return 0\n\ndef checkIfProcessRunning(processName):\n    for proc in psutil.process_iter():\n        try:\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False;\n\ndef file_as_bytes(file):\n    with file:\n        return file.read()\n\ndef get_username_from_userid(userid):\n    if userid == 0:\n        return 'openmptcprouter'\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'get_username'}\n    for user in data['users'][0]:\n        if 'userid' in data['users'][0][user] and int(data['users'][0][user]['userid']) == userid:\n            return user\n    return ''\n\ndef check_username_serial(username, serial):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'check_serial'}\n    if 'serial_enforce' not in data or data['serial_enforce'] == False:\n        return True\n    if 'serial' not in data['users'][0][username]:\n        data['users'][0][username]['serial'] = serial\n        if data:\n            with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n                json.dump(data, outfile, indent=4)\n        return True\n    if data['users'][0][username]['serial'] == serial:\n        return True\n    if 'serial_error' not in data['users'][0][username]:\n        data['users'][0][username]['serial_error'] = 1\n    else:\n        data['users'][0][username]['serial_error'] = int(data['users'][0][username]['serial_error']) + 1\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for check_username_serial\")\n    return False\n\ndef set_global_param(key, value):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'global_param'}\n    data[key] = value\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for set_global_param\")\n\ndef modif_config_user(user, changes):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    content['users'][0][user].update(changes)\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for modif_config_user\")\n\n\ndef add_ss_user(port, key, userid=0, ip=''):\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    data = json.loads(content)\n    if ip == '' and 'port_key' in data:\n        if port is None or port == '' or port == 0 or port == 'None':\n            port = int(max(data['port_key'], key=int)) + 1\n        data['port_key'][str(port)] = key\n    else:\n        if 'port_conf' not in data:\n            data['port_conf'] = {}\n        if 'port_key' in data:\n            for old_port in data['port_key']:\n                data['port_conf'][old_port] = {'key': data['port_key'][old_port]}\n            del data['port_key']\n        if port == '' or port == \"None\" or port is None or port == 0:\n            port = int(max(data['port_conf'], key=int)) + 1\n        if ip != '':\n            data['port_conf'][str(port)] = {'key': key, 'local_address': ip, 'userid': userid}\n        else:\n            data['port_conf'][str(port)] = {'key': key, 'userid': userid}\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        if ip != '':\n            data = 'add: {\"server_port\": ' + str(port) + ', \"key\": \"' + key + '\", \"local_addr\": \"' + ip + '\"}'\n        else:\n            data = 'add: {\"server_port\": ' + str(port) + ', \"key\": \"' + key + '\"}'\n        ss_socket.settimeout(1)\n        ss_socket.sendto(data.encode(), (\"127.0.0.1\", 8839))\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks add timeout (\" + str(err) + \")\")\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks add error (\" + str(err) + \")\")\n    return port\n\ndef remove_ss_user(port):\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    data = json.loads(content)\n    if 'port_key' in data:\n        del data['port_key'][str(port)]\n    else:\n        del data['port_conf'][str(port)]\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        data = 'remove: {\"server_port\": ' + str(port) + '}'\n        ss_socket.settimeout(1)\n        ss_socket.sendto(data.encode(), (\"127.0.0.1\", 8839))\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks remove timeout (\" + str(err) + \")\")\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks remove error (\" + str(err) + \")\")\n\ndef v2ray_add_user(user, restart=1):\n    v2rayuuid = str(uuid.uuid1())\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == 'omrin-tunnel':\n                inbounds['settings']['clients'].append({'id': v2rayuuid, 'level': 0, 'alterId': 0, 'email': user})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n    return v2rayuuid\n\ndef v2ray_del_user(user, restart=1):\n    v2rayuuid = str(uuid.uuid1())\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == 'omrin-tunnel':\n                for v2rayuser in inbounds['settings']['clients']:\n                    if v2rayuser['email'] == user:\n                        inbounds['settings']['clients'].remove(v2rayuser)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_add_outbound(tag,ip, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        data['outbounds'].append({'protocol': 'freedom', 'settings': { 'userLevel': 0 }, 'tag': tag, 'sendThrough': ip})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_del_outbound(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for outbounds in data['outbounds']:\n            if outbounds['tag'] == tag:\n                data['outbounds'].remove(outbounds)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_add_routing(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        data['routing']['rules'].append({'type': 'field', 'inboundTag': ( 'omrintunnel' ), 'outboundTag': tag})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_del_routing(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for rules in data['routing']['rules']:\n            if rules['outboundTag'] == tag:\n                data['routing']['rules'].remove(rules)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\n\ndef add_gre_tunnels():\n    nbip = 0\n    allips = []\n    for intf in netifaces.interfaces():\n        addrs = netifaces.ifaddresses(intf)\n        try:\n            ipv4_addr_list = addrs[netifaces.AF_INET]\n            for ip_info in ipv4_addr_list:\n                addr = ip_info['addr']\n                if not IPAddress(addr).is_private() and not IPAddress(addr).is_reserved():\n                    allips.append(addr)\n                    nbip = nbip + 1\n        except Exception as exception:\n            pass\n\n    if nbip > 1:\n        nbgre = 0\n        nbip = 0\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/snat', 'rb'))).hexdigest()\n        for intf in netifaces.interfaces():\n            addrs = netifaces.ifaddresses(intf)\n            try:\n                ipv4_addr_list = addrs[netifaces.AF_INET]\n                for ip_info in ipv4_addr_list:\n                    addr = ip_info['addr']\n                    if not IPAddress(addr).is_private() and not IPAddress(addr).is_reserved():\n                        netmask = ip_info['netmask']\n                        ip = IPNetwork('10.255.249.0/24')\n                        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n                            content = json.load(f)\n                        for user in content['users'][0]:\n                            if user != \"admin\":\n                                subnets = ip.subnet(30)\n                                network = list(subnets)[nbgre]\n                                nbgre = nbgre + 1\n                                userid = 0\n                                username = user\n                                iface = intf.split(':')[0]\n                                if 'userid' in content['users'][0][user]:\n                                    userid = content['users'][0][user]['userid']\n                                if 'username' in content['users'][0][user]:\n                                    username = content['users'][0][user]['username']\n                                gre_intf = 'gre-user' + str(userid) + '-ip' + str(nbip)\n                                with open('/etc/openmptcprouter-vps-admin/intf/' + gre_intf, 'w') as n:\n                                    n.write('INTF=' + str(intf.split(':')[0]) + \"\\n\")\n                                    n.write('INTFADDR=' + str(addr) + \"\\n\")\n                                    n.write('INTFNETMASK=' + str(netmask) + \"\\n\")\n                                    n.write('NETWORK=' + str(network) + \"\\n\")\n                                    n.write('LOCALIP=' + str(list(network)[1]) + \"\\n\")\n                                    n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n                                    n.write('NETMASK=255.255.255.252' + \"\\n\")\n                                    n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n                                    n.write('USERNAME=' + str(username) + \"\\n\")\n                                    n.write('USERID=' + str(userid) + \"\\n\")\n                                fd, tmpfile = mkstemp()\n                                with open('/etc/shorewall/snat', 'r') as h, open(tmpfile, 'a+') as n:\n                                    for line in h:\n                                        if not '# OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) in line:\n                                            n.write(line)\n                                    n.write('SNAT(' + str(addr) + ')\t' + str(network) + '\t' + str(iface) + ' # OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) + \"\\n\")\n                                    n.write('SNAT(' + str(list(network)[1]) + ')\t-\t' + gre_intf + ' # OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) + \"\\n\")\n                                os.close(fd)\n                                move(tmpfile, '/etc/shorewall/snat')\n                                #fd, tmpfile = mkstemp()\n                                #with open('/etc/shorewall/interfaces', 'r') as h, open(tmpfile, 'a+') as n:\n                                #    for line in h:\n                                #        if not 'gre-user' + str(userid) + '-ip' + str(nbip) in line:\n                                #            n.write(line)\n                                #    n.write('vpn\tgre-user' + str(userid) + '-ip' + str(nbip) + '\tnosmurfs,tcpflags' + \"\\n\")\n                                #os.close(fd)\n                                #move(tmpfile, '/etc/shorewall/interfaces')\n                                if str(iface) != IFACE:\n                                    fd, tmpfile = mkstemp()\n                                    with open('/etc/shorewall/interfaces', 'r') as h, open(tmpfile, 'a+') as n:\n                                        for line in h:\n                                            if not str(iface) in line:\n                                                n.write(line)\n                                        n.write('net\t' + str(iface) + '\tdhcp,nosmurfs,tcpflags,routefilter,sourceroute=0' + \"\\n\")\n                                    os.close(fd)\n                                    move(tmpfile, '/etc/shorewall/interfaces')\n                                user_gre_tunnels = {}\n                                if 'gre_tunnels' in content['users'][0][user]:\n                                    user_gre_tunnels = content['users'][0][user]['gre_tunnels']\n                                if not gre_intf in user_gre_tunnels or user_gre_tunnels[gre_intf]['public_ip'] != str(addr):\n                                    with open('/etc/shadowsocks-libev/manager.json') as g:\n                                        contentss = g.read()\n                                    contentss = re.sub(\",\\s*}\", \"}\", contentss) # pylint: disable=W1401\n                                    datass = json.loads(contentss)\n                                    ss_port = content['users'][0][user]['shadowsocks_port']\n                                    if 'port_key' in datass:\n                                        ss_key = datass['port_key'][str(ss_port)]\n                                    if 'port_conf' in datass:\n                                        ss_key = datass['port_conf'][str(ss_port)]['key']\n                                    if gre_intf not in user_gre_tunnels:\n                                        user_gre_tunnels[gre_intf] = {}\n                                    user_gre_tunnels[gre_intf] = {'shadowsocks_port': str(add_ss_user('', ss_key, userid, str(addr))), 'local_ip': str(list(network)[1]), 'remote_ip': str(list(network)[2]), 'public_ip': str(addr)}\n                                    #user_gre_tunnels[gre_intf] = {'local_ip': str(list(network)[1]), 'remote_ip': str(list(network)[2]), 'public_ip': str(addr)}\n                                    modif_config_user(user, {'gre_tunnels': user_gre_tunnels})\n                        nbip = nbip + 1\n            except Exception as exception:\n                pass\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/snat', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall\")\n            os.system(\"systemctl -q restart shadowsocks-libev-manager@manager\")\n    set_global_param('allips', allips)\n\nadd_gre_tunnels()\n\n\ndef add_glorytun_tcp(userid):\n    port = '650{:02d}'.format(userid)\n    ip = IPNetwork('10.255.255.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/glorytun-tcp/tun0', 'r') as f, \\\n          open('/etc/glorytun-tcp/tun' + str(userid), 'w') as n:\n        for line in f:\n            if 'PORT' in line:\n                n.write('PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=tun' + str(userid) + \"\\n\")\n            elif (not 'LOCALIP' in line\n                  and not 'REMOTEIP' in line\n                  and not 'BROADCASTIP' in line\n                  and not line == \"\\n\"):\n                n.write(line)\n        n.write(\"\\n\" + 'LOCALIP=' + str(list(network)[1]) + \"\\n\")\n        n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n        n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n    glorytun_tcp_key = secrets.token_hex(32)\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'w') as f:\n        f.write(glorytun_tcp_key.upper())\n    os.system(\"systemctl -q enable glorytun-tcp@tun\" + str(userid))\n    os.system(\"systemctl -q restart glorytun-tcp@tun\" + str(userid))\n\ndef remove_glorytun_tcp(userid):\n    os.system(\"systemctl -q disable glorytun-tcp@tun\" + str(userid))\n    os.system(\"systemctl -q stop glorytun-tcp@tun\" + str(userid))\n    os.remove('/etc/glorytun-tcp/tun' + str(userid) + '.key')\n    os.remove('/etc/glorytun-tcp/tun' + str(userid))\n\ndef add_glorytun_udp(userid):\n    port = '650{:02d}'.format(userid)\n    ip = IPNetwork('10.255.254.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/glorytun-udp/tun0', 'r') as f, \\\n          open('/etc/glorytun-udp/tun' + str(userid), 'w') as n:\n        for line in f:\n            if 'BIND_PORT' in line:\n                n.write('BIND_PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=tun' + str(userid) + \"\\n\")\n            elif (not 'LOCALIP' in line\n                  and not 'REMOTEIP' in line\n                  and not 'BROADCASTIP' in line\n                  and not line == \"\\n\"):\n                n.write(line)\n        n.write(\"\\n\" + 'LOCALIP=' + str(list(network)[1]) + \"\\n\")\n        n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n        n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'r') as f, \\\n          open('/etc/glorytun-udp/tun' + str(userid) + '.key', 'w') as n:\n        for line in f:\n            n.write(line)\n    os.system(\"systemctl -q enable glorytun-udp@tun\" + str(userid))\n    os.system(\"systemctl -q restart glorytun-udp@tun\" + str(userid))\n\ndef remove_glorytun_udp(userid):\n    os.system(\"systemctl -q disable glorytun-udp@tun\" + str(userid))\n    os.system(\"systemctl -q stop glorytun-udp@tun\" + str(userid))\n    os.remove('/etc/glorytun-udp/tun' + str(userid) + '.key')\n    os.remove('/etc/glorytun-udp/tun' + str(userid))\n\n\ndef add_dsvpn(userid):\n    port = '654{:02d}'.format(userid)\n    ip = IPNetwork('10.255.251.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/dsvpn/dsvpn0', 'r') as f, open('/etc/dsvpn/dsvpn' + str(userid), 'w') as n:\n        for line in f:\n            if 'PORT' in line:\n                n.write('PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=dsvpn' + str(userid) + \"\\n\")\n            elif 'LOCALTUNIP' in line:\n                n.write('LOCALTUNIP=' + str(list(network)[1]) + \"\\n\")\n            elif 'REMOTETUNIP' in line:\n                n.write('REMOTETUNIP=' + str(list(network)[2]) + \"\\n\")\n            else:\n                n.write(line)\n    dsvpn_key = secrets.token_hex(32)\n    with open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'w') as f:\n        f.write(dsvpn_key.upper())\n    os.system(\"systemctl -q enable dsvpn@dsvpn\" + str(userid))\n    os.system(\"systemctl -q restart dsvpn@dsvpn\" + str(userid))\n\ndef remove_dsvpn(userid):\n    os.system(\"systemctl -q disable dsvpn@dsvpn\" + str(userid))\n    os.system(\"systemctl -q stop dsvpn@dsvpn\" + str(userid))\n    os.remove('/etc/dsvpn/dsvpn' + str(userid))\n    os.remove('/etc/dsvpn/dsvpn' + str(userid) + '.key')\n\n\ndef ordered(obj):\n    if isinstance(obj, dict):\n        return sorted((k, ordered(v)) for k, v in obj.items())\n    if isinstance(obj, list):\n        return sorted(ordered(x) for x in obj)\n    else:\n        return obj\n\ndef v2ray_add_port(user, port, proto, name, destip, destport):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    tag = user.username + '_redir_' + proto + '_' + str(port)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            LOG.debug(inbounds)\n            if inbounds['tag'] == tag:\n                exist = 1\n        if exist == 0:\n            inbounds = {'tag': user.username + '_redir_' + proto + '_' + str(port), 'port': int(port), 'protocol': 'dokodemo-door', 'settings': {'network': proto, 'port': int(destport), 'address': destip}}\n            data['inbounds'].append(inbounds)\n            routing = {'type': 'field','inboundTag': [user.username + '_redir_' + proto + '_' + str(port)], 'outboundTag': 'OMRLan'}\n            data['routing']['rules'].append(routing)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart v2ray\")\n\n\ndef v2ray_del_port(username, port, proto, name):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    tag = user.username + '_redir_' + proto + '_' + str(port)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == tag:\n                data['inbounds'].remove(inbounds)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef shorewall_add_port(user, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip='', vpn='default'):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/rules', 'r') as f, \\\n          open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '' and dest_ip == '':\n                if (fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto in line):\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip == '':\n                    comment = ' to ' + source_dip\n                if dest_ip == '':\n                    comment = comment + ' from ' + dest_ip\n                if (fwtype == 'ACCEPT' and not '# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment in line):\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n        if source_dip == '' and dest_ip == '':\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\tnet\t\t$FW\t\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n        else:\n            net = 'net'\n            comment = ''\n            if source_dip != '':\n                comment = ' to ' + source_dip\n            if dest_ip != '':\n                comment = comment + ' from ' + dest_ip\n                net = 'net:' + dest_ip\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\t' + net + '\t\t$FW\t\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment + \"\\n\")\n            elif fwtype == 'DNAT' and vpn != 'default':\n                n.write('DNAT\t\t' + net + '\t\tvpn:' + vpn + '\t' + proto + '\t' + port + '\t-\t' + source_dip +  '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n                #n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR' + '\t' + proto + '\t' + port + '\t-\t' + source_dip +  '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n\ndef shorewall_del_port(username, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '' and dest_ip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip != '':\n                    comment = ' to ' + source_dip\n                if dest_ip != '':\n                    comment = comment + ' from ' + dest_ip\n                if fwtype == 'ACCEPT' and not '# OMR ' + username + ' open ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n\ndef shorewall6_add_port(user, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip == '':\n                    comment = ' to ' + source_dip\n                if dest_ip == '':\n                    comment = comment + ' from ' + dest_ip\n                if fwtype == 'ACCEPT' and not port + '# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n        if source_dip == '':\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\tnet\t\t$FW\t\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n        else:\n            net = 'net'\n            comment = ''\n            if source_dip == '':\n                comment = ' to ' + source_dip\n            if dest_ip == '':\n                comment = comment + ' from ' + dest_ip\n                net = 'net:' + dest_ip\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\t' + net + '\t\t$FW\t\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment+  \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n\ndef shorewall6_del_port(username, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                if fwtype == 'ACCEPT' and not '# OMR ' + username + ' open ' + name + ' port ' + proto + ' to ' + source_dip in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + username + ' redirect ' + name + ' port ' + proto + ' to ' + source_dip in line:\n                    n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n\ndef set_lastchange(sync=0):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'lastchange'}\n    data[\"lastchange\"] = time.time() + sync\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for set_last_change\")\n\n\nwith open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n    omr_config_data = json.load(f)\n    if 'debug' in omr_config_data and omr_config_data['debug']:\n        LOG.setLevel(logging.DEBUG)\n\nfake_users_db = omr_config_data['users'][0]\n\ndef verify_password(plain_password, user_password):\n    if plain_password == user_password:\n        LOG.debug(\"password true\")\n        return True\n    return False\n\ndef get_password_hash(password):\n    return password\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        LOG.debug(\"user doesn't exist\")\n        return False\n    if not verify_password(password, user.user_password):\n        LOG.debug(\"wrong password\")\n        return False\n    return user\n\nclass Token(BaseModel):\n    access_token: str = None\n    token_type: str = None\n\n\nclass TokenData(BaseModel):\n    username: str = None\n\nclass User(BaseModel):\n    username: str\n    vpn: str = None\n    vpn_port: int = None\n    vpn_client_ip: str = None\n    permissions: str = 'rw'\n    shadowsocks_port: int = None\n    disabled: bool = 'false'\n    userid: int = None\n\n\nclass UserInDB(User):\n    user_password: str\n\n# Add support for auth before seeing doc\nclass OAuth2PasswordBearerCookie(OAuth2):\n    def __init__(\n            self,\n            tokenUrl: str,\n            scheme_name: str = None,\n            scopes: dict = None,\n            auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        header_authorization: str = request.headers.get(\"Authorization\")\n        cookie_authorization: str = request.cookies.get(\"Authorization\")\n\n        header_scheme, header_param = get_authorization_scheme_param(\n            header_authorization\n        )\n        cookie_scheme, cookie_param = get_authorization_scheme_param(\n            cookie_authorization\n        )\n\n        if header_scheme.lower() == \"bearer\":\n            authorization = True\n            scheme = header_scheme\n            param = header_param\n\n        elif cookie_scheme.lower() == \"bearer\":\n            authorization = True\n            scheme = cookie_scheme\n            param = cookie_param\n\n        else:\n            authorization = False\n\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return param\n\nclass BasicAuth(SecurityBase):\n    def __init__(self, scheme_name: str = None, auto_error: bool = True):\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.model = SecurityBaseModel(type=\"http\")\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"basic\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return param\n\nbasic_auth = BasicAuth(auto_error=False)\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\noauth2_scheme = OAuth2PasswordBearerCookie(tokenUrl=\"/token\")\n\napp = FastAPI(docs_url=None, redoc_url=None, openapi_url=None, title=\"OpenMPTCProuter Server API\")\n\n\ndef create_access_token(*, data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=60)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=HTTP_403_FORBIDDEN,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            LOG.debug(\"get_current_user: Username not found\")\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except PyJWTError:\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n# Show something at homepage\n@app.get(\"/\")\nasync def homepage():\n    return \"Welcome to OpenMPTCProuter Server part\"\n\n# Provide a method to create access tokens. The create_jwt()\n# function is used to actually generate the token\n@app.post('/token', response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n    if not user:\n        LOG.debug(\"Incorrect username or password\")\n        raise HTTPException(status_code=400, detail=\"Incorrect username or password\")\n\n    # Identity can be any data that is json serializable\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": form_data.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/logout\")\nasync def route_logout_and_remove_cookie():\n    response = RedirectResponse(url=\"/\")\n    response.delete_cookie(\"Authorization\")\n    return response\n\n\n# Login for doc\n@app.get(\"/login_basic\")\nasync def login_basic(auth: BasicAuth = Depends(basic_auth)):\n    if not auth:\n        response = Response(headers={\"WWW-Authenticate\": \"Basic\"}, status_code=401)\n        return response\n\n    try:\n        decoded = base64.b64decode(auth).decode(\"ascii\")\n        username, _, password = decoded.partition(\":\")\n        user = authenticate_user(fake_users_db, username, password)\n        if not user:\n            raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n\n        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token = create_access_token(\n            data={\"sub\": username}, expires_delta=access_token_expires\n        )\n\n        token = jsonable_encoder(access_token)\n\n        response = RedirectResponse(url=\"/docs\")\n        response.set_cookie(\n            \"Authorization\",\n            value=f\"Bearer {token}\",\n            httponly=True,\n            max_age=1800,\n            expires=1800,\n        )\n        return response\n\n    except:\n        response = Response(headers={\"WWW-Authenticate\": \"Basic\"}, status_code=401)\n        return response\n\n\n@app.get(\"/openapi.json\")\nasync def get_open_api_endpoint(current_user: User = Depends(get_current_active_user)):\n    return JSONResponse(get_openapi(title=\"FastAPI\", version=1, routes=app.routes))\n\n\n@app.get(\"/docs\")\nasync def get_documentation(current_user: User = Depends(get_current_active_user)):\n    return get_swagger_ui_html(openapi_url=\"/openapi.json\", title=\"docs\")\n\n# Get Client IP\n@app.get('/clienthost')\nasync def status(request: Request):\n    client_host = request.client.host\n    return {\"client_host\": client_host}\n\n# Get VPS status\n@app.get('/status', summary=\"Get current server load average, uptime and release\")\nasync def status(userid: Optional[int] = Query(None), serial: Optional[str] = Query(None), current_user: User = Depends(get_current_user)):\n    LOG.debug('Get status...')\n    if not current_user.permissions == \"admin\":\n        userid = current_user.userid\n    if userid is None:\n        userid = 0\n    username = get_username_from_userid(userid)\n    if not current_user.permissions == \"admin\" and serial is not None:\n        if not check_username_serial(username, serial):\n            return {'error': 'False serial number'}\n    vps_loadavg = os.popen(\"cat /proc/loadavg | awk '{print $1\\\" \\\"$2\\\" \\\"$3}'\").read().rstrip()\n    vps_uptime = os.popen(\"cat /proc/uptime | awk '{print $1}'\").read().rstrip()\n    vps_hostname = socket.gethostname()\n    vps_current_time = time.time()\n    vps_kernel = os.popen('uname -r').read().rstrip()\n    vps_omr_version = os.popen(\"grep -s 'OpenMPTCProuter VPS' /etc/* | awk '{print $4}'\").read().rstrip()\n    mptcp_enabled = os.popen('sysctl -n net.mptcp.mptcp_enabled').read().rstrip()\n    shadowsocks_port = current_user.shadowsocks_port\n    if not shadowsocks_port == None:\n        ss_traffic = get_bytes_ss(current_user.shadowsocks_port)\n    else:\n        ss_traffic = 0\n    v2ray_tx = 0\n    v2ray_rx = 0\n    if os.path.isfile('/etc/v2ray/v2ray-server.json') and checkIfProcessRunning('v2ray'):\n        v2ray_tx = get_bytes_v2ray('tx',username)\n        v2ray_rx = get_bytes_v2ray('rx',username)\n    vpn = 'glorytun_tcp'\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    if 'vpn' in omr_config_data['users'][0][username]:\n        vpn = omr_config_data['users'][0][username]['vpn']\n    vpn_traffic_rx = 0\n    vpn_traffic_tx = 0\n    if vpn == 'glorytun_tcp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-tun' + str(userid))\n    elif vpn == 'glorytun_udp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-udp-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-udp-tun' + str(userid))\n    elif vpn == 'mlvpn':\n        vpn_traffic_rx = get_bytes('rx', 'mlvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'mlvpn' + str(userid))\n    elif vpn == 'dsvpn':\n        vpn_traffic_rx = get_bytes('rx', 'dsvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'dsvpn' + str(userid))\n    elif vpn == 'openvpn':\n        vpn_traffic_rx = get_bytes('rx', 'tun0')\n        vpn_traffic_tx = get_bytes('tx', 'tun0')\n    elif vpn == 'openvpn_bonding':\n        vpn_traffic_rx = get_bytes('rx', 'omr-bonding')\n        vpn_traffic_tx = get_bytes('tx', 'omr-bonding')\n    LOG.debug('Get status: done')\n    if IFACE:\n        return {'vps': {'time': vps_current_time, 'loadavg': vps_loadavg, 'uptime': vps_uptime, 'mptcp': mptcp_enabled, 'hostname': vps_hostname, 'kernel': vps_kernel, 'omr_version': vps_omr_version}, 'network': {'tx': get_bytes('tx', IFACE), 'rx': get_bytes('rx', IFACE)}, 'shadowsocks': {'traffic': ss_traffic}, 'vpn': {'tx': vpn_traffic_tx, 'rx': vpn_traffic_rx}, 'v2ray': {'tx': v2ray_tx, 'rx': v2ray_rx}}\n    else:\n        return {'error': 'No iface defined', 'route': 'status'}\n\n# Get VPS config\n@app.get('/config', summary=\"Get full server configuration for current user\")\nasync def config(userid: Optional[int] = Query(None), serial: Optional[str] = Query(None), current_user: User = Depends(get_current_user)):\n    LOG.debug('Get config...')\n    if not current_user.permissions == \"admin\":\n        userid = current_user.userid\n    if userid is None:\n        userid = 0\n    username = get_username_from_userid(userid)\n    if not current_user.permissions == \"admin\" and serial is not None:\n        if not check_username_serial(username, serial):\n            return {'error': 'False serial number'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    LOG.debug('Get config... shadowsocks')\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        data = {'port_key': '', 'server_port': 65101, 'method': 'chacha20'}\n    #shadowsocks_port = data[\"server_port\"]\n    shadowsocks_port = current_user.shadowsocks_port\n    if shadowsocks_port is not None:\n        if 'port_key' in data:\n            shadowsocks_key = data[\"port_key\"][str(shadowsocks_port)]\n        else:\n            shadowsocks_key = data[\"port_conf\"][str(shadowsocks_port)][\"key\"]\n    else:\n        shadowsocks_key = ''\n    shadowsocks_method = data[\"method\"]\n    if 'fast_open' in data:\n        shadowsocks_fast_open = data[\"fast_open\"]\n    else:\n        shadowsocks_fast_open = False\n    if 'reuse_port' in data:\n        shadowsocks_reuse_port = data[\"reuse_port\"]\n    else:\n        shadowsocks_reuse_port = False\n    if 'no_delay' in data:\n        shadowsocks_no_delay = data[\"no_delay\"]\n    else:\n        shadowsocks_no_delay = False\n    if 'mptcp' in data:\n        shadowsocks_mptcp = data[\"mptcp\"]\n    else:\n        shadowsocks_mptcp = False\n    if 'ebpf' in data:\n        shadowsocks_ebpf = data[\"ebpf\"]\n    else:\n        shadowsocks_ebpf = False\n    if \"plugin\" in data:\n        shadowsocks_obfs = True\n        if 'v2ray' in data[\"plugin\"]:\n            shadowsocks_obfs_plugin = 'v2ray'\n        else:\n            shadowsocks_obfs_plugin = 'obfs'\n        if 'tls' in data[\"plugin_opts\"]:\n            shadowsocks_obfs_type = 'tls'\n        else:\n            shadowsocks_obfs_type = 'http'\n    else:\n        shadowsocks_obfs = False\n        shadowsocks_obfs_plugin = ''\n        shadowsocks_obfs_type = ''\n    shadowsocks_port = current_user.shadowsocks_port\n    if not shadowsocks_port == None:\n        ss_traffic = get_bytes_ss(current_user.shadowsocks_port)\n    else:\n        ss_traffic = 0\n\n    LOG.debug('Get config... glorytun')\n    if os.path.isfile('/etc/glorytun-tcp/tun' + str(userid) +'.key'):\n        glorytun_key = open('/etc/glorytun-tcp/tun' + str(userid) + '.key').readline().rstrip()\n    else:\n        glorytun_key = ''\n    glorytun_port = '65001'\n    glorytun_chacha = False\n    glorytun_tcp_host_ip = ''\n    glorytun_tcp_client_ip = ''\n    glorytun_udp_host_ip = ''\n    glorytun_udp_client_ip = ''\n    if os.path.isfile('/etc/glorytun-tcp/tun' + str(userid)):\n        with open('/etc/glorytun-tcp/tun' + str(userid), \"r\") as glorytun_file:\n            for line in glorytun_file:\n                if 'PORT=' in line:\n                    glorytun_port = line.replace(line[:5], '').rstrip()\n                if 'LOCALIP=' in line:\n                    glorytun_tcp_host_ip = line.replace(line[:8], '').rstrip()\n                if 'REMOTEIP=' in line:\n                    glorytun_tcp_client_ip = line.replace(line[:9], '').rstrip()\n                if 'chacha' in line:\n                    glorytun_chacha = True\n    if userid == 0 and glorytun_tcp_host_ip == '':\n        if 'glorytun_tcp_type' in omr_config_data:\n            if omr_config_data['glorytun_tcp_type'] == 'static':\n                glorytun_tcp_host_ip = '10.255.255.1'\n                glorytun_tcp_client_ip = '10.255.255.2'\n            else:\n                glorytun_tcp_host_ip = 'dhcp'\n                glorytun_tcp_client_ip = 'dhcp'\n        else:\n            glorytun_tcp_host_ip = '10.255.255.1'\n            glorytun_tcp_client_ip = '10.255.255.2'\n    if os.path.isfile('/etc/glorytun-udp/tun' + str(userid)):\n        with open('/etc/glorytun-udp/tun' + str(userid), \"r\") as glorytun_file:\n            for line in glorytun_file:\n                if 'LOCALIP=' in line:\n                    glorytun_udp_host_ip = line.replace(line[:8], '').rstrip()\n                if 'REMOTEIP=' in line:\n                    glorytun_udp_client_ip = line.replace(line[:9], '').rstrip()\n\n    if userid == 0 and glorytun_udp_host_ip == '':\n        if 'glorytun_udp_type' in omr_config_data:\n            if omr_config_data['glorytun_udp_type'] == 'static':\n                glorytun_udp_host_ip = '10.255.254.1'\n                glorytun_udp_client_ip = '10.255.254.2'\n            else:\n                glorytun_udp_host_ip = 'dhcp'\n                glorytun_udp_client_ip = 'dhcp'\n        else:\n            glorytun_udp_host_ip = '10.255.254.1'\n            glorytun_udp_client_ip = '10.255.254.2'\n    available_vpn = [\"glorytun_tcp\", \"glorytun_udp\"]\n    LOG.debug('Get config... dsvpn')\n    if os.path.isfile('/etc/dsvpn/dsvpn' + str(userid) + '.key'):\n        dsvpn_key = open('/etc/dsvpn/dsvpn' + str(userid) + '.key').readline().rstrip()\n        available_vpn.append(\"dsvpn\")\n    else:\n        dsvpn_key = ''\n    dsvpn_port = '65401'\n    dsvpn_host_ip = ''\n    dsvpn_client_ip = ''\n    if os.path.isfile('/etc/dsvpn/dsvpn' + str(userid)):\n        with open('/etc/dsvpn/dsvpn' + str(userid), \"r\") as dsvpn_file:\n            for line in dsvpn_file:\n                if 'PORT=' in line:\n                    dsvpn_port = line.replace(line[:5], '').rstrip()\n                if 'LOCALTUNIP=' in line:\n                    dsvpn_host_ip = line.replace(line[:11], '').rstrip()\n                if 'REMOTETUNIP=' in line:\n                    dsvpn_client_ip = line.replace(line[:12], '').rstrip()\n\n    if userid == 0 and dsvpn_host_ip == '':\n        dsvpn_host_ip = '10.255.251.1'\n        dsvpn_client_ip = '10.255.251.2'\n\n    LOG.debug('Get config... iperf3')\n    if os.path.isfile('/etc/iperf3/public.pem'):\n        with open('/etc/iperf3/public.pem', \"rb\") as iperfkey_file:\n            iperf_keyb = base64.b64encode(iperfkey_file.read())\n            iperf3_key = iperf_keyb.decode('utf-8')\n    else:\n        iperf3_key = ''\n\n    if os.path.isfile('/etc/pihole/setupVars.conf'):\n        pihole = True\n    else:\n        pihole = False\n\n    LOG.debug('Get config... openvpn')\n    #if os.path.isfile('/etc/openvpn/server/static.key'):\n    #    with open('/etc/openvpn/server/static.key',\"rb\") as ovpnkey_file:\n    #        openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n    #        openvpn_key = openvpn_keyb.decode('utf-8')\n    #    available_vpn.append(\"openvpn\")\n    #else:\n    #    openvpn_key = ''\n    openvpn_key = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/private/' + username + '.key'):\n        with open('/etc/openvpn/ca/pki/private/' + username + '.key', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_key = openvpn_keyb.decode('utf-8')\n    else:\n        openvpn_client_key = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/issued/' + username + '.crt'):\n        with open('/etc/openvpn/ca/pki/issued/' + username + '.crt', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_crt = openvpn_keyb.decode('utf-8')\n        available_vpn.append(\"openvpn\")\n    else:\n        openvpn_client_crt = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/ca.crt'):\n        with open('/etc/openvpn/ca/pki/ca.crt', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_ca = openvpn_keyb.decode('utf-8')\n    else:\n        openvpn_client_ca = ''\n    openvpn_port = '65301'\n    openvpn_cipher = 'AES-256-CBC'\n    if os.path.isfile('/etc/openvpn/openvpn-tun0.conf'):\n        with open('/etc/openvpn/openvpn-tun0.conf', \"r\") as openvpn_file:\n            for line in openvpn_file:\n                if 'port ' in line:\n                    openvpn_port = line.replace(line[:5], '').rstrip()\n                if 'cipher ' in line:\n                    openvpn_cipher = line.replace(line[:7], '').rstrip()\n    openvpn_host_ip = '10.255.252.1'\n    #openvpn_client_ip = '10.255.252.2'\n    openvpn_client_ip = 'dhcp'\n\n    if os.path.isfile('/etc/openvpn/bonding1.conf'):\n        available_vpn.append(\"openvpn_bonding\")\n\n    LOG.debug('Get config... mlvpn')\n    if os.path.isfile('/etc/mlvpn/mlvpn0.conf'):\n        mlvpn_config = configparser.ConfigParser()\n        mlvpn_config.read_file(open(r'/etc/mlvpn/mlvpn0.conf'))\n        mlvpn_key = mlvpn_config.get('general', 'password').strip('\"')\n        mlvpn_timeout = mlvpn_config.get('general', 'timeout')\n        mlvpn_reorder_buffer_size = mlvpn_config.get('general', 'reorder_buffer_size')\n        mlvpn_loss_tolerence = mlvpn_config.get('general', 'loss_tolerence')\n        if mlvpn_config.has_option('general', 'cleartext_data'):\n            mlvpn_cleartext_data = mlvpn_config.get('general', 'cleartext_data')\n        else:\n            mlvpn_cleartext_data = ''\n        available_vpn.append(\"mlvpn\")\n    else:\n        mlvpn_key = ''\n        mlvpn_timeout = ''\n        mlvpn_reorder_buffer_size = ''\n        mlvpn_loss_tolerence = ''\n        mlvpn_cleartext_data = ''\n    mlvpn_host_ip = '10.255.253.1'\n    mlvpn_client_ip = '10.255.253.2'\n\n    LOG.debug('Get config... wireguard')\n    if os.path.isfile('/etc/wireguard/vpn-server-public.key'):\n        with open('/etc/wireguard/vpn-server-public.key', \"rb\") as wgkey_file:\n            wireguard_key = wgkey_file.read()\n    else:\n        wireguard_key = ''\n    wireguard_host_ip = '10.255.247.1'\n    wireguard_port = '65311'\n\n    gre_tunnel = False\n    gre_tunnel_conf = []\n#    for tunnel in pathlib.Path('/etc/openmptcprouter-vps-admin/intf').glob('gre-user' + str(userid) + '-ip*'):\n#        gre_tunnel = True\n#        with open(tunnel, \"r\") as tunnel_conf:\n#            for line in tunnel_conf:\n#                if 'LOCALIP=' in line:\n#                    gre_tunnel_localip = line.replace(line[:8], '').rstrip()\n#                if 'REMOTEIP=' in line:\n#                    gre_tunnel_remoteip = line.replace(line[:9], '').rstrip()\n#                if 'NETMASK=' in line:\n#                    gre_tunnel_netmask = line.replace(line[:8], '').rstrip()\n#                if 'INTFADDR=' in line:\n#                    gre_tunnel_intfaddr = line.replace(line[:9], '').rstrip()\n#        gre_tunnel_conf.append(\"{'local_ip': '\" + gre_tunnel_localip + \"', 'remote_ip': '\" + gre_tunnel_remoteip + \"', 'netmask': '\" + gre_tunnel_netmask + \"', 'public_ip': '\" + gre_tunnel_intfaddr + \"'}\")\n\n    if 'gre_tunnels' in omr_config_data['users'][0][username]:\n        gre_tunnel = True\n        gre_tunnel_conf = omr_config_data['users'][0][username]['gre_tunnels']\n\n    if 'vpnremoteip' in omr_config_data['users'][0][username]:\n        vpn_remote_ip = omr_config_data['users'][0][username]['vpnremoteip']\n    else:\n        vpn_remote_ip = ''\n    if 'vpnlocalip' in omr_config_data['users'][0][username]:\n        vpn_local_ip = omr_config_data['users'][0][username]['vpnlocalip']\n    else:\n        vpn_local_ip = ''\n\n    v2ray = False\n    v2ray_conf = []\n    v2ray_tx = 0\n    v2ray_rx = 0\n    if os.path.isfile('/etc/v2ray/v2ray-server.json'):\n        v2ray = True\n        if not 'v2ray' in omr_config_data['users'][0][username]:\n            v2ray_key = os.popen('jq -r .inbounds[0].settings.clients[0].id /etc/v2ray/v2ray-server.json').read().rstrip()\n            v2ray_port = os.popen('jq -r .inbounds[0].port /etc/v2ray/v2ray-server.json').read().rstrip()\n            v2ray_conf = { 'key': v2ray_key, 'port': v2ray_port}\n            modif_config_user(username, {'v2ray': v2ray_conf})\n        else:\n            v2ray_conf = omr_config_data['users'][0][username]['v2ray']\n        if checkIfProcessRunning('v2ray'):\n            v2ray_tx = get_bytes_v2ray('tx',username)\n            v2ray_rx = get_bytes_v2ray('rx',username)\n\n    LOG.debug('Get config... mptcp')\n    mptcp_enabled = os.popen('sysctl -n net.mptcp.mptcp_enabled').read().rstrip()\n    mptcp_checksum = os.popen('sysctl -n net.mptcp.mptcp_checksum').read().rstrip()\n    mptcp_path_manager = os.popen('sysctl -n  net.mptcp.mptcp_path_manager').read().rstrip()\n    mptcp_scheduler = os.popen('sysctl -n net.mptcp.mptcp_scheduler').read().rstrip()\n    mptcp_syn_retries = os.popen('sysctl -n net.mptcp.mptcp_syn_retries').read().rstrip()\n\n    congestion_control = os.popen('sysctl -n net.ipv4.tcp_congestion_control').read().rstrip()\n\n    LOG.debug('Get config... ipv6')\n    if 'ipv6_network' in omr_config_data:\n        ipv6_network = omr_config_data['ipv6_network']\n    else:\n        ipv6_network = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\"').read().rstrip()\n    #ipv6_addr = os.popen('wget -6 -qO- -T 2 ipv6.openmptcprouter.com').read().rstrip()\n    if 'ipv6_addr' in omr_config_data:\n        ipv6_addr = omr_config_data['ipv6_addr']\n    else:\n        ipv6_addr = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\" | cut -d/ -f1').read().rstrip()\n    #ipv4_addr = os.popen('wget -4 -qO- -T 1 https://ip.openmptcprouter.com').read().rstrip()\n    LOG.debug('get server IPv4')\n    if 'ipv4' in omr_config_data:\n        ipv4_addr = omr_config_data['ipv4']\n    elif 'internet' in omr_config_data and not omr_config_data['internet']:\n        ipv4_addr = os.popen('ip -4 addr show ' + IFACE +' | grep -oP \"(?<=inet ).*(?= scope global)\" | cut -d/ -f1').read().rstrip()\n    else:\n        ipv4_addr = os.popen(\"dig -4 TXT +timeout=2 +tries=1 +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'\\\"' '{ print $2}'\").read().rstrip()\n        if ipv4_addr == '':\n            ipv4_addr = os.popen('wget -4 -qO- -T 1 http://ip.openmptcprouter.com').read().rstrip()\n        if ipv4_addr == '':\n            ipv4_addr = os.popen('wget -4 -qO- -T 1 http://ifconfig.co').read().rstrip()\n        if ipv4_addr != '':\n            set_global_param('ipv4', ipv4_addr)\n    #ipv4_addr = \"\"\n\n    test_aes = os.popen('cat /proc/cpuinfo | grep aes').read().rstrip()\n    if test_aes == '':\n        vps_aes = False\n    else:\n        vps_aes = True\n    vps_kernel = os.popen('uname -r').read().rstrip()\n    vps_machine = os.popen('uname -m').read().rstrip()\n    vps_omr_version = os.popen(\"grep -s 'OpenMPTCProuter VPS' /etc/* | awk '{print $4}'\").read().rstrip()\n    vps_loadavg = os.popen(\"cat /proc/loadavg | awk '{print $1\" \"$2\" \"$3}'\").read().rstrip()\n    vps_uptime = os.popen(\"cat /proc/uptime | awk '{print $1}'\").read().rstrip()\n    LOG.debug('get hostname')\n    if 'hostname' in omr_config_data:\n        vps_domain = omr_config_data['hostname']\n    elif 'internet' in omr_config_data and not omr_config_data['internet']:\n        vps_domain = ''\n    else:\n        vps_domain = os.popen('wget -4 -qO- -T 1 http://hostname.openmptcprouter.com').read().rstrip()\n        if vps_domain != '':\n            set_global_param('hostname', vps_domain)\n    #vps_domain = os.popen('dig -4 +short +times=3 +tries=1 -x ' + ipv4_addr + \" | sed 's/\\.$//'\").read().rstrip()\n    user_permissions = current_user.permissions\n\n    internet = True\n    if 'internet' in omr_config_data and not omr_config_data['internet']:\n        internet = False\n\n    localip6 = ''\n    remoteip6 = ''\n    ula = ''\n    if userid == 0:\n        if os.path.isfile('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid)):\n            with open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), \"r\") as omr6in4_file:\n                for line in omr6in4_file:\n                    if 'LOCALIP6=' in line:\n                        localip6 = line.replace(line[:9], '').rstrip()\n                    if 'REMOTEIP6=' in line:\n                        remoteip6 = line.replace(line[:10], '').rstrip()\n                    if 'ULA=' in line:\n                        ula = line.replace(line[:4], '').rstrip()\n    else:\n        locaip6 = 'fe80::a00:1'\n        remoteip6 = 'fe80::a00:2'\n\n    proxy = 'shadowsocks'\n    if 'proxy' in omr_config_data['users'][0][username]:\n        proxy = omr_config_data['users'][0][username]['proxy']\n\n    vpn = 'glorytun_tcp'\n    if 'vpn' in omr_config_data['users'][0][username]:\n        vpn = omr_config_data['users'][0][username]['vpn']\n\n    vpn_traffic_rx = 0\n    vpn_traffic_tx = 0\n    if vpn == 'glorytun_tcp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-tun' + str(userid))\n    elif vpn == 'glorytun_udp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-udp-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-udp-tun' + str(userid))\n    elif vpn == 'mlvpn':\n        vpn_traffic_rx = get_bytes('rx', 'mlvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'mlvpn' + str(userid))\n    elif vpn == 'dsvpn':\n        vpn_traffic_rx = get_bytes('rx', 'dsvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'dsvpn' + str(userid))\n    elif vpn == 'openvpn':\n        vpn_traffic_rx = get_bytes('rx', 'tun0')\n        vpn_traffic_tx = get_bytes('tx', 'tun0')\n    elif vpn == 'openvpn_bonding':\n        vpn_traffic_rx = get_bytes('rx', 'omr-bonding')\n        vpn_traffic_tx = get_bytes('tx', 'omr-bonding')\n\n    #vpn = current_user.vpn\n    available_proxy = [\"shadowsocks\", \"v2ray\"]\n    if user_permissions == 'ro':\n        del available_vpn\n        available_vpn = [vpn]\n        del available_proxy\n        available_proxy = [proxy]\n\n    alllanips = []\n    client2client = False\n    if 'client2client' in omr_config_data and omr_config_data['client2client']:\n        client2client = True\n        for users in omr_config_data['users'][0]:\n            if 'lanips' in omr_config_data['users'][0][users] and users != username and omr_config_data['users'][0][users]['lanips'][0] not in alllanips:\n                alllanips.append(omr_config_data['users'][0][users]['lanips'][0])\n\n    shorewall_redirect = \"enable\"\n    with open('/etc/shorewall/rules', 'r') as f:\n        for line in f:\n            if '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999' in line:\n                shorewall_redirect = \"disable\"\n    LOG.debug('Get config: done')\n    return {'vps': {'kernel': vps_kernel, 'machine': vps_machine, 'omr_version': vps_omr_version, 'loadavg': vps_loadavg, 'uptime': vps_uptime, 'aes': vps_aes}, 'shadowsocks': {'traffic': ss_traffic, 'key': shadowsocks_key, 'port': shadowsocks_port, 'method': shadowsocks_method, 'fast_open': shadowsocks_fast_open, 'reuse_port': shadowsocks_reuse_port, 'no_delay': shadowsocks_no_delay, 'mptcp': shadowsocks_mptcp, 'ebpf': shadowsocks_ebpf, 'obfs': shadowsocks_obfs, 'obfs_plugin': shadowsocks_obfs_plugin, 'obfs_type': shadowsocks_obfs_type}, 'glorytun': {'key': glorytun_key, 'udp': {'host_ip': glorytun_udp_host_ip, 'client_ip': glorytun_udp_client_ip}, 'tcp': {'host_ip': glorytun_tcp_host_ip, 'client_ip': glorytun_tcp_client_ip}, 'port': glorytun_port, 'chacha': glorytun_chacha}, 'dsvpn': {'key': dsvpn_key, 'host_ip': dsvpn_host_ip, 'client_ip': dsvpn_client_ip, 'port': dsvpn_port}, 'openvpn': {'key': openvpn_key, 'client_key': openvpn_client_key, 'client_crt': openvpn_client_crt, 'client_ca': openvpn_client_ca, 'host_ip': openvpn_host_ip, 'client_ip': openvpn_client_ip, 'port': openvpn_port, 'cipher': openvpn_cipher},'wireguard': {'key': wireguard_key, 'host_ip': wireguard_host_ip, 'port': wireguard_port}, 'mlvpn': {'key': mlvpn_key, 'host_ip': mlvpn_host_ip, 'client_ip': mlvpn_client_ip,'timeout': mlvpn_timeout,'reorder_buffer_size': mlvpn_reorder_buffer_size,'loss_tolerence': mlvpn_loss_tolerence,'cleartext_data': mlvpn_cleartext_data}, 'shorewall': {'redirect_ports': shorewall_redirect}, 'mptcp': {'enabled': mptcp_enabled, 'checksum': mptcp_checksum, 'path_manager': mptcp_path_manager, 'scheduler': mptcp_scheduler, 'syn_retries': mptcp_syn_retries}, 'network': {'congestion_control': congestion_control, 'ipv6_network': ipv6_network, 'ipv6': ipv6_addr, 'ipv4': ipv4_addr, 'domain': vps_domain, 'internet': internet}, 'vpn': {'available': available_vpn, 'current': vpn, 'remoteip': vpn_remote_ip, 'localip': vpn_local_ip, 'rx': vpn_traffic_rx, 'tx': vpn_traffic_tx}, 'iperf': {'user': 'openmptcprouter', 'password': 'openmptcprouter', 'key': iperf3_key}, 'pihole': {'state': pihole}, 'user': {'name': username, 'permission': user_permissions}, 'ip6in4': {'localip': localip6, 'remoteip': remoteip6, 'ula': ula}, 'client2client': {'enabled': client2client, 'lanips': alllanips}, 'gre_tunnel': {'enabled': gre_tunnel, 'config': gre_tunnel_conf}, 'v2ray': {'enabled': v2ray, 'config': v2ray_conf, 'tx': v2ray_tx, 'rx': v2ray_rx}, 'proxy': {'available': available_proxy, 'current': proxy}}\n\n# Set shadowsocks config\nclass OBFSPLUGIN(str, Enum):\n    v2ray = \"v2ray\"\n    obfs = \"obfs\"\n\nclass OBFSTYPE(str, Enum):\n    tls = \"tls\"\n    http = \"http\"\n\n\nclass ShadowsocksConfigparams(BaseModel):\n    port: int = Query(..., gt=0, lt=65535)\n    method: str\n    fast_open: bool\n    reuse_port: bool\n    no_delay: bool\n    mptcp: bool = Query(True, title=\"Enable/Disable MPTCP support\")\n    obfs: bool = Query(False, title=\"Enable/Disable obfuscation support\")\n    obfs_plugin: OBFSPLUGIN = Query(\"v2ray\", title=\"Choose obfuscation plugin\")\n    obfs_type: OBFSTYPE = Query(\"tls\", title=\"Choose obfuscation method\")\n    key: str\n\n@app.post('/shadowsocks', summary=\"Modify Shadowsocks-libev configuration\")\ndef shadowsocks(*, params: ShadowsocksConfigparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shadowsocks'}\n    ipv6_network = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\"').read().rstrip()\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/manager.json', 'rb'))).hexdigest()\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        data = {'timeout': 600, 'verbose': 0, 'prefer_ipv6': False}\n    #key = data[\"key\"]\n    if 'timeout' in data:\n        timeout = data[\"timeout\"]\n    if 'verbose' in data:\n        verbose = data[\"verbose\"]\n    else:\n        verbose = 0\n    prefer_ipv6 = data[\"prefer_ipv6\"]\n    port = params.port\n    method = params.method\n    fast_open = params.fast_open\n    reuse_port = params.reuse_port\n    no_delay = params.no_delay\n    mptcp = params.mptcp\n    obfs = params.obfs\n    obfs_plugin = params.obfs_plugin\n    obfs_type = params.obfs_type\n    ebpf = 0\n    key = params.key\n    if 'port_key' in data:\n        portkey = data[\"port_key\"]\n        portkey[str(port)] = key\n    if 'port_conf' in data:\n        portconf = data[\"port_conf\"]\n        portconf[str(port)]['key'] = key\n    modif_config_user(current_user.username, {'shadowsocks_port': port})\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n\n    #ipv4_addr = os.popen('wget -4 -qO- -T 2 http://ip.openmptcprouter.com').read().rstrip()\n    if 'hostname' in omr_config_data:\n        vps_domain = omr_config_data['hostname']\n    else:\n        vps_domain = os.popen('wget -4 -qO- -T 1 http://hostname.openmptcprouter.com').read().rstrip()\n        if vps_domain != '':\n            set_global_param('hostname', vps_domain)\n\n    if port is None or method is None or fast_open is None or reuse_port is None or no_delay is None or key is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shadowsocks'}\n    if 'port_key' in data:\n        if ipv6_network == '':\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n        else:\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n    else:\n        if ipv6_network == '':\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n        else:\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as outfile:\n        json.dump(shadowsocks_config, outfile, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/manager.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl restart shadowsocks-libev-manager@manager.service\")\n        #for x in range(1, os.cpu_count()):\n        #    os.system(\"systemctl restart shadowsocks-libev-manager@manager\" + str(x) + \".service\")\n        shorewall_add_port(current_user, str(port), 'tcp', 'shadowsocks')\n        shorewall_add_port(current_user, str(port), 'udp', 'shadowsocks')\n        set_lastchange()\n        return {'result': 'done', 'reason': 'changes applied', 'route': 'shadowsocks'}\n    else:\n        return {'result': 'done', 'reason': 'no changes', 'route': 'shadowsocks'}\n\n# Set shorewall config\nclass IPPROTO(str, Enum):\n    ipv4 = \"ipv4\"\n    ipv6 = \"ipv6\"\n\nclass ShorewallAllparams(BaseModel):\n    redirect_ports: str = Query(..., title=\"Port or ports range\")\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP to apply changes\")\n\n@app.post('/shorewall', summary=\"Redirect all ports from Server to router\")\ndef shorewall(*, params: ShorewallAllparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewall'}\n    state = params.redirect_ports\n    if state is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewall'}\n    if params.ipproto == 'ipv4':\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/shorewall/rules', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write('#' + line)\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write('#' + line)\n                else:\n                    n.write(line)\n        os.close(fd)\n        move(tmpfile, '/etc/shorewall/rules')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall\")\n    else:\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write('#' + line)\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write('#' + line)\n                else:\n                    n.write(line)\n        os.close(fd)\n        move(tmpfile, '/etc/shorewall6/rules')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall6\")\n    # Need to do the same for IPv6...\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass ShorewallListparams(BaseModel):\n    name: str\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP to list\")\n\n@app.post('/shorewalllist', summary=\"Display all OpenMPTCProuter rules in Shorewall config\")\ndef shorewall_list(*, params: ShorewallListparams, current_user: User = Depends(get_current_user)):\n    name = params.name\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewalllist'}\n    fwlist = []\n    if params.ipproto == 'ipv4':\n        with open('/etc/shorewall/rules', 'r') as f:\n            for line in f:\n                if '# OMR ' + current_user.username + ' ' + name in line:\n                    fwlist.append(line)\n    else:\n        with open('/etc/shorewall6/rules', 'r') as f:\n            for line in f:\n                if '# OMR ' + current_user.username + ' ' + name in line:\n                    fwlist.append(line)\n    return {'list': fwlist}\n\nclass Shorewallparams(BaseModel):\n    name: str\n    port: str\n    proto: str\n    fwtype: str\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP for changes\")\n    source_dip: str = \"\"\n    source_ip: str = \"\"\n\n@app.post('/shorewallopen', summary=\"Redirect a port from Server to Router\")\ndef shorewall_open(*, params: Shorewallparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewallopen'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    fwtype = params.fwtype\n    source_dip = params.source_dip\n    source_ip = params.source_ip\n    vpn = \"default\"\n    username = current_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewallopen'}\n    #proxy = 'shadowsocks'\n    #if 'proxy' in omr_config_data['users'][0][username]:\n    #    proxy = omr_config_data['users'][0][username]['proxy']\n    #if proxy == 'v2ray':\n    #    v2ray_add_port(current_user, str(port), proto, name)\n    #    fwtype = 'ACCEPT'\n    if params.ipproto == 'ipv4':\n        if 'gre_tunnels' in omr_config_data['users'][0][current_user.username]:\n            for tunnel in omr_config_data['users'][0][current_user.username]['gre_tunnels']:\n                if omr_config_data['users'][0][current_user.username]['gre_tunnels'][tunnel]['public_ip'] == source_dip:\n                    vpn = omr_config_data['users'][0][current_user.username]['gre_tunnels'][tunnel]['remote_ip']\n        shorewall_add_port(current_user, str(port), proto, name, fwtype, source_dip, source_ip, vpn)\n    else:\n        shorewall6_add_port(current_user, str(port), proto, name, fwtype, source_dip, source_ip)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n@app.post('/shorewallclose', summary=\"Remove a redirected port\")\ndef shorewall_close(*, params: Shorewallparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewallclose'}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    fwtype = params.fwtype\n    source_dip = params.source_dip\n    source_ip = params.source_ip\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewallclose'}\n    #v2ray_del_port(current_user.username, str(port), proto, name)\n    if params.ipproto == 'ipv4':\n        shorewall_del_port(current_user.username, str(port), proto, name, 'DNAT', source_dip, source_ip)\n        shorewall_del_port(current_user.username, str(port), proto, name, 'ACCEPT', source_dip, source_ip)\n    else:\n        shorewall6_del_port(current_user.username, str(port), proto, name, 'DNAT', source_dip, source_ip)\n        shorewall6_del_port(current_user.username, str(port), proto, name, 'ACCEPT', source_dip, source_ip)\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'shorewallclose'}\n\nclass V2rayconfig(BaseModel):\n    userid: str\n\n@app.post('/v2ray', summary=\"Set v2ray settings\")\ndef v2ray(*, params: V2rayconfig, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        v2ray_config = json.load(f)\n    v2ruserid = params.userid\n    for inbounds in v2ray_config['inbounds']:\n        if inbounds['tag'] == 'omrin-tunnel':\n            inbounds['settings']['clients'][0]['id'] = v2ruserid\n    with open('/etc/v2ray/v2ray-server.json', 'w') as outfile:\n        json.dump(v2ray_config, outfile, indent=4)\n    username = current_user.username\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    v2ray_key = os.popen('jq -r .inbounds[0].settings.clients[0].id /etc/v2ray/v2ray-server.json').read().rstrip()\n    v2ray_port = os.popen('jq -r .inbounds[0].port /etc/v2ray/v2ray-server.json').read().rstrip()\n    v2ray_conf = { 'key': v2ray_key, 'port': v2ray_port}\n    modif_config_user(username, {'v2ray': v2ray_conf})\n    if initial_md5 != final_md5:\n        os.system(\"systemctl restart v2ray\")\n        set_lastchange()\n        return {'result': 'done', 'reason': 'changes applied', 'route': 'v2ray'}\n    else:\n        return {'result': 'done', 'reason': 'no changes', 'route': 'v2ray'}\n\n\nclass V2rayparams(BaseModel):\n    name: str\n    port: str\n    proto: str\n    destip: str\n    destport: str\n\n@app.post('/v2rayredirect', summary=\"Redirect a port from Server to Router with V2Ray\")\ndef v2ray_redirect(*, params: V2rayparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    destip = params.destip\n    destport = params.destport\n    username = current_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'v2rayredirect'}\n    v2ray_add_port(current_user, port, proto, name, destip, destport)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n@app.post('/v2rayunredirect', summary=\"Remove a redirected port from Server to Router with V2Ray\")\ndef v2ray_unredirect(*, params: V2rayparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    username = curent_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'v2rayunredirect'}\n    v2ray_del_port(current_user, port, proto, name)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n# Set MPTCP config\nclass MPTCPparams(BaseModel):\n    checksum: str\n    path_manager: str\n    scheduler: str\n    syn_retries: int\n    congestion_control: str\n\n@app.post('/mptcp', summary=\"Modify MPTCP configuration of the server\")\ndef mptcp(*, params: MPTCPparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'mptcp'}\n    checksum = params.checksum\n    path_manager = params.path_manager\n    scheduler = params.scheduler\n    syn_retries = params.syn_retries\n    congestion_control = params.congestion_control\n    if not checksum or not path_manager or not scheduler or not syn_retries or not congestion_control:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'mptcp'}\n    os.system('sysctl -qw net.mptcp.mptcp_checksum=' + checksum)\n    os.system('sysctl -qw net.mptcp.mptcp_path_manager=' + path_manager)\n    os.system('sysctl -qw net.mptcp.mptcp_scheduler=' + scheduler)\n    os.system('sysctl -qw net.mptcp.mptcp_syn_retries=' + str(syn_retries))\n    os.system('sysctl -qw net.ipv4.tcp_congestion_control=' + congestion_control)\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass VPN(str, Enum):\n    openvpn = \"openvpn\"\n    openvpnbonding = \"openvpn_bonding\"\n    glorytuntcp = \"glorytun_tcp\"\n    glorytunudp = \"glorytun_udp\"\n    dsvpn = \"dsvpn\"\n    mlvpn = \"mlvpn\"\n    none = \"none\"\n\nclass Vpn(BaseModel):\n    vpn: VPN\n\n# Set global VPN config\n@app.post('/vpn', summary=\"Set VPN used by the current user\")\ndef vpn(*, vpnconfig: Vpn, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'vpn'}\n    vpn = vpnconfig.vpn\n    if not vpn:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'vpn'}\n    os.system('echo ' + vpn + ' > /etc/openmptcprouter-vps-admin/current-vpn')\n    modif_config_user(current_user.username, {'vpn': vpn})\n    current_user.vpn = vpn\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass PROXY(str, Enum):\n    v2ray = \"v2ray\"\n    shadowsockslibev = \"shadowsocks\"\n    none = \"none\"\n\nclass Proxy(BaseModel):\n    proxy: PROXY\n\n# Set global Proxy config\n@app.post('/proxy', summary=\"Set Proxy used by the current user\")\ndef proxy(*, proxyconfig: Proxy, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'proxy'}\n    proxy = proxyconfig.proxy\n    if not proxy:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'proxy'}\n    os.system('echo ' + proxy + ' > /etc/openmptcprouter-vps-admin/current-proxy')\n    modif_config_user(current_user.username, {'proxy': proxy})\n    #current_user.proxy = proxy\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\n\nclass GlorytunConfig(BaseModel):\n    key: str\n    port: int = Query(..., gt=0, lt=65535, title=\"Glorytun TCP and UDP port\")\n    chacha: bool = Query(True, title=\"Enable of disable chacha20, if disable AEGIS is used\")\n\n# Set Glorytun config\n@app.post('/glorytun', summary=\"Modify Glorytun configuration\")\ndef glorytun(*, glorytunconfig: GlorytunConfig, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'glorytun'}\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    key = glorytunconfig.key\n    port = glorytunconfig.port\n    chacha = glorytunconfig.chacha\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-tcp/tun' + str(userid), 'rb'))).hexdigest()\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'w') as outfile:\n        outfile.write(key)\n    with open('/etc/glorytun-udp/tun' + str(userid) + '.key', 'w') as outfile:\n        outfile.write(key)\n    fd, tmpfile = mkstemp()\n    with open('/etc/glorytun-tcp/tun' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'PORT=' in line:\n                n.write('PORT=' + str(port) + '\\n')\n            elif 'OPTIONS=' in line:\n                if chacha:\n                    n.write('OPTIONS=\"chacha20 retry count -1 const 5000000 timeout 90000 keepalive count 5 idle 10 interval 2 buffer-size 65536 multiqueue\"\\n')\n                else:\n                    n.write('OPTIONS=\"retry count -1 const 5000000 timeout 90000 keepalive count 5 idle 10 interval 2 buffer-size 65536 multiqueue\"\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/glorytun-tcp/tun' + str(userid))\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-tcp/tun' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart glorytun-tcp@tun\" + str(userid))\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-udp/tun' + str(userid), 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/glorytun-udp/tun' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'BIND_PORT=' in line:\n                n.write('BIND_PORT=' + str(port) + '\\n')\n            elif 'OPTIONS=' in line:\n                if chacha:\n                    n.write('OPTIONS=\"chacha persist\"\\n')\n                else:\n                    n.write('OPTIONS=\"persist\"\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/glorytun-udp/tun' + str(userid))\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-udp/tun' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart glorytun-udp@tun\" + str(userid))\n    shorewall_add_port(current_user, str(port), 'tcp', 'glorytun')\n    shorewall_add_port(current_user, str(port), 'udp', 'glorytun')\n    set_lastchange()\n    return {'result': 'done'}\n\n# Set A Dead Simple VPN config\nclass DSVPN(BaseModel):\n    key: str\n    port: int = Query(..., gt=0, lt=65535)\n\n@app.post('/dsvpn', summary=\"Modify DSVPN configuration\")\ndef dsvpn(*, params: DSVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'dsvpn'}\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    key = params.key\n    port = params.port\n    if not key or port is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'dsvpn'}\n\n    fd, tmpfile = mkstemp()\n    with open('/etc/dsvpn/dsvpn' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'PORT=' in line:\n                n.write('PORT=' + str(port) + '\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/dsvpn/dsvpn' + str(userid))\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'rb'))).hexdigest()\n    with open('/etc/dsvpn/dsvpn.key', 'w') as outfile:\n        outfile.write(key)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart dsvpn-server@dsvpn\" + str(userid))\n    shorewall_add_port(current_user, str(port), 'tcp', 'dsvpn')\n    set_lastchange()\n    return {'result': 'done'}\n\n# Set MLVPN config\nclass MLVPN(BaseModel):\n    timeout: int\n    reorder_buffer_size: int\n    loss_tolerence: int\n    cleartext_data: int\n    password: str\n\n@app.post('/mlvpn', summary=\"Modify MLVPN configuration\")\ndef mlvpn(*, params: MLVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'mlvpn'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/mlvpn/mlvpn0.conf', 'rb'))).hexdigest()\n    mlvpn_config = configparser.ConfigParser()\n    mlvpn_config.read_file(open(r'/etc/mlvpn/mlvpn0.conf'))\n    mlvpn_config.set('general', 'password', '\"' + params.password + '\"')\n    mlvpn_config.set('general', 'timeout',str(params.timeout))\n    mlvpn_config.set('general', 'reorder_buffer_size',str(params.reorder_buffer_size))\n    mlvpn_config.set('general', 'loss_tolerence',str(params.loss_tolerence))\n    mlvpn_config.set('general', 'cleartext_data',str(params.cleartext_data))\n    with open('/etc/mlvpn/mlvpn0.conf','w') as mlvpn_file:\n        mlvpn_config.write(mlvpn_file)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/mlvpn/mlvpn0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart mlvpn@mlvpn0\")\n        set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'mlvpn'}\n\n\n# Set OpenVPN config\nclass OpenVPN(BaseModel):\n    port: int = Query(..., gt=0, lt=65535)\n    cipher: str = \"AES-256-CBC\"\n\n@app.post('/openvpn', summary=\"Modify OpenVPN TCP configuration\")\ndef openvpn(*, params: OpenVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'openvpn'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/openvpn/tun0', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'cipher ' in line:\n                n.write('cipher ' + params.cipher + '\\n')\n            elif 'port ' in line:\n                n.write('port ' + str(params.port) + '\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/openvpn/tun0')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0', 'rb'))).hexdigest()\n\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart openvpn@tun0\")\n        shorewall_add_port(current_user, str(port), 'tcp', 'openvpn')\n        set_lastchange()\n    return {'result': 'done'}\n\n# Set WireGuard config\nclass WireGuardPeer(BaseModel):\n    ip: str\n    key: str\n\nclass WireGuard(BaseModel):\n    peers: List[WireGuardPeer] = []\n\n@app.post('/wireguard', summary=\"Modify Wireguard configuration\")\ndef wireguard(*, params: WireGuard, current_user: User = Depends(get_current_user)):\n    if not os.path.isfile('/etc/wireguard/wg0.conf'):\n        return {'result': 'error', 'reason': 'Wireguard config not found', 'route': 'wireguard'}\n    wg_config = configparser.ConfigParser(strict=False)\n    wg_config.read_file(open(r'/etc/wireguard/wg0.conf'))\n    wg_port = wg_config.get('Interface', 'ListenPort')\n    wg_key = wg_config.get('Interface', 'PrivateKey')\n\n    fd, tmpfile = mkstemp()\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/wireguard/wg0.conf', 'rb'))).hexdigest()\n    with open(tmpfile, 'a+') as n:\n        n.write('[Interface]\\n')\n        n.write('ListenPort = ' + wg_port + '\\n')\n        n.write('PrivateKey = ' + wg_key + '\\n')\n        for peer in params.peers:\n            n.write('\\n')\n            n.write('[Peer]\\n')\n            n.write('PublicKey  = ' + peer.key + '\\n')\n            n.write('AllowedIPs = ' + peer.ip + '\\n')\n    move(tmpfile, '/etc/wireguard/wg0.conf')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/wireguard/wg0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"wg setconf wg0 /etc/wireguard/wg0.conf\")\n        shorewall_add_port(current_user, str(wg_port), 'udp', 'wireguard')\n        set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'wireguard'}\n\n\nclass Wanips(BaseModel):\n    ips: str\n\n# Set WANIP\n@app.post('/wan', summary=\"Set WAN IPs\")\ndef wan(*, wanips: Wanips, current_user: User = Depends(get_current_user)):\n    ips = wanips.ips\n    if not ips:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'wan'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/local.acl', 'rb'))).hexdigest()\n    with open('/etc/shadowsocks-libev/local.acl', 'w') as outfile:\n        outfile.write('[white_list]\\n')\n        outfile.write(ips)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/local.acl', 'rb'))).hexdigest()\n    #modif_config_user(current_user.username,{'wanips': wanip})\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'wan'}\n\nclass Lanips(BaseModel):\n    lanips: List[str] = []\n\n# Set user lan config\n@app.post('/lan', summary=\"Set current user LAN IPs\")\ndef lan(*, lanconfig: Lanips, current_user: User = Depends(get_current_user)):\n    lanips = lanconfig.lanips\n    if not lanips:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'lan'}\n    modif_config_user(current_user.username, {'lanips': lanips})\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        omr_config_data = json.load(f)\n    client2client = False\n    if 'client2client' in omr_config_data:\n        client2client = omr_config_data[\"client2client\"]\n    if client2client == True:\n        with open('/etc/openvpn/ccd/' + current_user.username, 'w') as outfile:\n            for lan in lanips:\n                ip = IPNetwork(lan)\n                outfile.write('iroute ' + str(ip.network) + ' ' + str(ip.netmask) + \"\\n\")\n                #outfile.write('route ' + str(ip.network) + ' ' + str(ip.netmask) + \"\\n\")\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/openvpn/tun0.conf', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if not 'push \"route ' + str(ip.network) + ' ' + str(ip.netmask) + '\"' in line:\n                    n.write(line)\n            n.write('push \"route ' + str(ip.network) + ' ' + str(ip.netmask) + '\"' + \"\\n\")\n        os.close(fd)\n        move(tmpfile, '/etc/openvpn/tun0.conf')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q restart openvpn@tun0\")\n            set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'lan'}\n\nclass VPNips(BaseModel):\n    remoteip: str = Query(..., regex='^(10(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){3}|((172\\.(1[6-9]|2[0-9]|3[01]))|192\\.168)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){2})$')\n    localip: str = Query(..., regex='^(10(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){3}|((172\\.(1[6-9]|2[0-9]|3[01]))|192\\.168)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){2})$')\n    remoteip6: Optional[str] = Query(None, regex='(?:^|(?<=\\s))(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\\s|$)')\n    localip6: Optional[str] = Query(None, regex='(?:^|(?<=\\s))(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\\s|$)')\n    ula: Optional[str] = None\n\n# Set user vpn IPs\n@app.post('/vpnips', summary=\"Set current user VPN IPs\")\ndef vpnips(*, vpnconfig: VPNips, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'vpnips'}\n    remoteip = vpnconfig.remoteip\n    localip = vpnconfig.localip\n    remoteip6 = vpnconfig.remoteip6\n    localip6 = vpnconfig.localip6\n    ula = vpnconfig.ula\n    if not remoteip or not localip:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'vpnips'}\n    modif_config_user(current_user.username, {'vpnremoteip': remoteip})\n    modif_config_user(current_user.username, {'vpnlocalip': localip})\n    if ula:\n        modif_config_user(current_user.username, {'ula': ula})\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    if os.path.isfile('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid)):\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'rb'))).hexdigest()\n    else:\n        initial_md5 = ''\n    with open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'w+') as n:\n        n.write('LOCALIP=' + localip + \"\\n\")\n        n.write('REMOTEIP=' + remoteip + \"\\n\")\n        if localip6:\n            n.write('LOCALIP6=' + localip6 + \"\\n\")\n        else:\n            n.write('LOCALIP6=fe80::a0' + hex(userid)[2:] + ':1/126' + \"\\n\")\n        if remoteip6:\n            n.write('REMOTEIP6=' + remoteip6 + \"\\n\")\n        else:\n            n.write('REMOTEIP6=fe80::a0' + hex(userid)[2:] + ':2/126' + \"\\n\")\n        if ula:\n            n.write('ULA=' + ula + \"\\n\")\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart omr6in4@user\" + str(userid))\n        set_lastchange()\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/params.vpn', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/params.vpn', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not ('OMR_ADDR_USER' + str(userid) +'=' in line and not userid == 0) and not ('OMR_ADDR=' in line and userid == 0):\n                n.write(line)\n        if not userid == 0:\n            n.write('OMR_ADDR_USER' + str(userid) + '=' + remoteip + '\\n')\n        elif userid == 0:\n            n.write('OMR_ADDR=' + remoteip + '\\n')\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/params.vpn')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/params.vpn', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n        set_lastchange()\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/params.vpn', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/params.vpn', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not ('OMR_ADDR_USER' + str(userid) +'=' in line and not userid == 0) and not ('OMR_ADDR=' in line and userid == 0):\n                n.write(line)\n        if  not userid == 0:\n            n.write('OMR_ADDR_USER' + str(userid) + '=fe80::a0' + hex(userid)[2:] + ':2/126' + '\\n')\n        elif userid == 0:\n            n.write('OMR_ADDR=fe80::a0' + hex(userid)[2:] + ':2/126' + '\\n')\n\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/params.vpn')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/params.vpn', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n        set_lastchange()\n\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'vpnips'}\n\n# Update VPS\n@app.get('/update', summary=\"Update VPS script\")\ndef update(current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'update'}\n    LOG.debug(\"Update VPS...\")\n    os.system(\"systemctl stop omr\")\n    os.system(\"wget -O - http://www.openmptcprouter.com/server/debian10-x86_64.sh | sh &\")\n    LOG.debug(\"Update VPS... done\")\n    os.system(\"/sbin/reboot\")\n    return {'result': 'done', 'route': 'update'}\n\n# Backup\nclass Backupfile(BaseModel):\n    data: str = Query(..., title=\"OpenMPTCProuter backup file in tar.gz encoded in base64\")\n\n@app.post('/backuppost', summary=\"Send current user router backup file\")\ndef backuppost(*, backupfile: Backupfile, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'backuppost'}\n    backup_file = backupfile.data\n    if not backup_file:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'backuppost'}\n    with open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz', 'wb') as f:\n        f.write(base64.b64decode(backup_file))\n    return {'result': 'done', 'route': 'backuppost'}\n\n@app.get('/backupget', summary=\"Get current user router backup file\")\ndef send_backup(current_user: User = Depends(get_current_user)):\n    with open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz', \"rb\") as backup_file:\n        file_base64 = base64.b64encode(backup_file.read())\n        file_base64utf = file_base64.decode('utf-8')\n    return {'data': file_base64utf}\n\n@app.get('/backuplist', summary=\"List available current user backup\")\ndef list_backup(current_user: User = Depends(get_current_user)):\n    if os.path.isfile('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'):\n        modiftime = os.path.getmtime('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz')\n        return {'backup': True, 'modif': modiftime}\n    else:\n        return {'backup': False}\n\n@app.get('/backupshow', summary=\"Show current user backup\")\ndef show_backup(current_user: User = Depends(get_current_user)):\n    if os.path.isfile('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'):\n        router = OpenWrt(native=open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'))\n        return {'backup': True, 'data': router}\n    else:\n        return {'backup': False}\n\n@app.post('/backupedit', summary=\"Modify current user backup\")\ndef edit_backup(params, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'backupedit'}\n    o = OpenWrt(params)\n    o.write(current_user.username + '-backup', path='/var/opt/openmptcprouter/')\n    return {'result': 'done'}\n\n#class VPN(str, Enum):\n#    openvpn = \"openvpn\"\n#    glorytuntcp = \"glorytun_tcp\"\n#    glorytunudp = \"glorytun_udp\"\n#    dsvpn = \"dsvpn\"\n\nclass permissions(str, Enum):\n    ro = \"ro\"\n    rw = \"rw\"\n    admin = \"admin\"\n\nclass NewUser(BaseModel):\n    username: str = Query(..., title=\"Username\")\n    permission: permissions = Query(\"ro\", title=\"permission of the user\")\n    vpn: VPN = Query(\"openvpn\", title=\"default VPN for the user\")\n    shadowsocks_port: Optional[int] = Query(None, gt=0, lt=65535, title=\"Shadowsocks port\")\n    userid: Optional[int] = Query(None, title=\"User ID\")\n    ips: Optional[List[str]] = Query(None, title=\"Public exit IP\")\n#    userid: int = Query(0, title=\"User ID\",description=\"User ID is used to create port of each VPN and shadowsocks\",gt=0,le=99)\n\n@app.post('/add_user', summary=\"Add a new user\")\ndef add_user(*, params: NewUser, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'add_user'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    userid = params.userid\n    if userid is None or userid == 0:\n        userid = 2\n        for users in content['users'][0]:\n            if 'userid' in content['users'][0][users]:\n                if int(content['users'][0][users]['userid']) > userid:\n                    userid = int(content['users'][0][users]['userid'])\n        userid = userid + 1\n    if params.ips is None:\n        publicips = []\n    else:\n        publicips = params.ips\n    user_key = secrets.token_hex(32)\n    user_json = json.loads('{\"'+ params.username + '\": {\"username\":\"'+ params.username +'\",\"permissions\":\"'+params.permission+'\",\"user_password\": \"'+user_key.upper()+'\",\"disabled\":\"false\",\"userid\":\"' + str(userid) + '\",\"public_ips\":'+ json.dumps(publicips) +'}}')\n#    shadowsocks_port = params.shadowsocks_port\n#    if params.shadowsocks_port is None:\n#    shadowsocks_port = '651{:02d}'.format(userid)\n    shadowsocks_port = params.shadowsocks_port\n    shadowsocks_key = base64.urlsafe_b64encode(secrets.token_hex(16).encode())\n    if not publicips:\n        shadowsocks_port = add_ss_user(str(shadowsocks_port), shadowsocks_key.decode('utf-8'), userid)\n    else:\n        for publicip in publicips:\n            shadowsocks_port = add_ss_user(str(shadowsocks_port), shadowsocks_key.decode('utf-8'), userid, publicip)\n            shadowsocks_port = shadowsocks_port + 1\n    user_json[params.username].update({\"shadowsocks_port\": shadowsocks_port})\n    if params.vpn is not None:\n        user_json[params.username].update({\"vpn\": params.vpn})\n    content['users'][0].update(user_json)\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for add_user\")\n    # Create VPNs configuration\n    os.system('cd /etc/openvpn/ca && EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full \"' + params.username + '\" nopass')\n    add_glorytun_tcp(userid)\n    add_glorytun_udp(userid)\n    add_dsvpn(userid)\n\n    set_lastchange(30)\n    os.execv(__file__, sys.argv)\n\nclass RemoveUser(BaseModel):\n    username: str\n\n@app.post('/remove_user', summary=\"Remove an user\")\ndef remove_user(*, params: RemoveUser, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'remove_user'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    shadowsocks_port = content['users'][0][params.username]['shadowsocks_port']\n    userid = int(content['users'][0][params.username]['userid'])\n    del content['users'][0][params.username]\n    remove_ss_user(str(shadowsocks_port))\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for remover_user\")\n    os.system('cd /etc/openvpn/ca && ./easyrsa --batch revoke ' + params.username)\n    os.system('cd /etc/openvpn/ca && ./easyrsa gen-crl')\n    os.system(\"systemctl -q restart openvpn@tun0\")\n    remove_glorytun_tcp(userid)\n    remove_glorytun_udp(userid)\n    remove_dsvpn(userid)\n\n    set_lastchange(30)\n    os.execv(__file__, sys.argv)\n\nclass ClienttoClient(BaseModel):\n    enable: bool = False\n\n@app.post('/client2client', summary=\"Enable client 2 client communications\")\ndef client2client(*, params: ClienttoClient, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'client2client'}\n    set_global_param('client2client', params.enable)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/openvpn/tun0.conf', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not 'client-to-client' in line:\n                n.write(line)\n        if params.enable == True:\n            n.write('client-to-client' + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/openvpn/tun0.conf')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart openvpn@tun0\")\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/policy', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/policy', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not line == 'vpn\t\tvpn\t\tDROP\\n' and not line == '# THE FOLLOWING POLICY MUST BE LAST\\n' and not line == 'all\t\tall\t\tREJECT\t\tinfo\\n':\n                n.write(line)\n        if params.enable == False:\n            n.write('vpn\t\tvpn\t\tDROP\\n')\n        n.write('# THE FOLLOWING POLICY MUST BE LAST\\n')\n        n.write('all\t\tall\t\tREJECT\t\tinfo\\n')\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/policy')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/policy', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n    return {'result': 'done'}\n\nclass SerialEnforce(BaseModel):\n    enable: bool = False\n\n@app.post('/serialenforce', summary=\"Enable client serial number control\")\ndef serialenforce(*, params: SerialEnforce, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'serialenforce'}\n    set_global_param('serial_enforce', params.enable)\n    return {'result': 'done'}\n\n@app.get('/list_users', summary=\"List all users\")\nasync def list_users(current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'list_users'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    return content['users'][0]\n\n@app.get('/speedtest', summary=\"Test speed from the server\")\nasync def list_users(current_user: User = Depends(get_current_user)):\n    return FileResponse('/usr/share/omr-server/speedtest/test.img')\n\n\n\ndef main(omrport: int, omrhost: str):\n    LOG.debug(\"Main OMR-Admin launch\")\n    uvicorn.run(app, host=omrhost, port=omrport, log_level='error', ssl_certfile='/etc/openmptcprouter-vps-admin/cert.pem', ssl_keyfile='/etc/openmptcprouter-vps-admin/key.pem', ssl_version=5)\n\nif __name__ == '__main__':\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        omr_config_data = json.load(f)\n    omrport = 65500\n    if 'port' in omr_config_data:\n        omrport = omr_config_data[\"port\"]\n    omrhost = '0.0.0.0'\n    if 'host' in omr_config_data:\n        omrhost = omr_config_data[\"host\"]\n    parser = argparse.ArgumentParser(description=\"OpenMPTCProuter Server API\")\n    parser.add_argument(\"--port\", type=int, help=\"Listening port\", default=omrport)\n    parser.add_argument(\"--host\", type=str, help=\"Listening host\", default=omrhost)\n    args = parser.parse_args()\n    main(args.port, args.host)\n"], "fixing_code": ["#!/usr/bin/env python3\n#\n# Copyright (C) 2018-2020 Ycarus (Yannick Chabanois) <ycarus@zugaina.org> for OpenMPTCProuter\n#\n# This is free software, licensed under the GNU General Public License v3.0.\n# See /LICENSE for more information.\n#\n\nimport json\nimport base64\nimport secrets\nimport uuid\nimport configparser\nimport argparse\nimport subprocess\nimport os\nimport sys\nimport socket\nimport re\nimport hashlib\nimport pathlib\nimport psutil\nimport time\nimport uuid\nfrom pprint import pprint\nfrom datetime import datetime, timedelta\nfrom tempfile import mkstemp\nfrom typing import List, Optional\nfrom shutil import move\nfrom enum import Enum\nfrom os import path\nimport logging\nimport uvicorn\nimport jwt\nfrom jwt import PyJWTError\nfrom netaddr import *\nfrom netjsonconfig import OpenWrt\nfrom fastapi import Depends, FastAPI, HTTPException, Security, Query, Request\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, OAuth2\nfrom passlib.context import CryptContext\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom fastapi.openapi.docs import get_swagger_ui_html\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.openapi.models import SecurityBase as SecurityBaseModel\nfrom fastapi.responses import StreamingResponse, FileResponse\nfrom pydantic import BaseModel, ValidationError # pylint: disable=E0611\nfrom starlette.status import HTTP_403_FORBIDDEN\nfrom starlette.responses import RedirectResponse, Response, JSONResponse\n#from starlette.requests import Request\nimport netifaces\n\nLOG = logging.getLogger('api')\nLOG.setLevel(logging.ERROR)\n#LOG.setLevel(logging.DEBUG)\n\n# Generate a random secret key\nSECRET_KEY = uuid.uuid4().hex\nJWT_SECRET_KEY = uuid.uuid4().hex\nPERMANENT_SESSION_LIFETIME = timedelta(hours=24)\nACCESS_TOKEN_EXPIRE_MINUTES = 1440\nALGORITHM = \"HS256\"\n\n# Get main net interface\nFILE = open('/etc/shorewall/params.net', \"r\")\nREAD = FILE.read()\nIFACE = None\nfor line in READ.splitlines():\n    if 'NET_IFACE=' in line:\n        IFACE = line.split('=', 1)[1]\nFILE.close()\n\n# Get ipv6 net interface\nFILE = open('/etc/shorewall6/params.net', \"r\")\nREAD = FILE.read()\nIFACE6 = None\nfor line in READ.splitlines():\n    if 'NET_IFACE=' in line:\n        IFACE6 = line.split('=', 1)[1]\nFILE.close()\n\n# Get interface rx/tx\ndef get_bytes(t, iface='eth0'):\n    if path.exists('/sys/class/net/' + iface + '/statistics/' + t + '_bytes'):\n        with open('/sys/class/net/' + iface + '/statistics/' + t + '_bytes', 'r') as f:\n            data = f.read()\n        return int(data)\n    return 0\n\ndef get_bytes_ss(port):\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        ss_socket.settimeout(1)\n        ss_socket.sendto('ping'.encode(), (\"127.0.0.1\", 8839))\n        ss_recv = ss_socket.recv(1024)\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks stats timeout (\" + str(err) + \")\")\n        return 0\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks stats error (\" + str(err) + \")\")\n        return 0\n    json_txt = ss_recv.decode(\"utf-8\").replace('stat: ', '')\n    result = json.loads(json_txt)\n    if str(port) in result:\n        return result[str(port)]\n    return 0\n\ndef get_bytes_v2ray(t,user):\n    if t == \"tx\":\n        side=\"downlink\"\n    else:\n        side=\"uplink\"\n    try:\n        data = subprocess.check_output('/usr/bin/v2ctl api --server=127.0.0.1:10085 StatsService.GetStats ' + \"'\" + 'name: \"user>>>' + user + '>>>traffic>>>' + side + '\"' + \"'\" + ' 2>/dev/null | grep value | cut -d: -f2 | tr -d \" \"', shell = True)\n    except:\n        return 0\n    if data.decode(\"utf-8\") != '':\n        return int(data.decode(\"utf-8\"))\n    else:\n        return 0\n\ndef checkIfProcessRunning(processName):\n    for proc in psutil.process_iter():\n        try:\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False;\n\ndef file_as_bytes(file):\n    with file:\n        return file.read()\n\ndef get_username_from_userid(userid):\n    if userid == 0:\n        return 'openmptcprouter'\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'get_username'}\n    for user in data['users'][0]:\n        if 'userid' in data['users'][0][user] and int(data['users'][0][user]['userid']) == userid:\n            return user\n    return ''\n\ndef check_username_serial(username, serial):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'check_serial'}\n    if 'serial_enforce' not in data or data['serial_enforce'] == False:\n        return True\n    if 'serial' not in data['users'][0][username]:\n        data['users'][0][username]['serial'] = serial\n        if data:\n            with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n                json.dump(data, outfile, indent=4)\n        return True\n    if data['users'][0][username]['serial'] == serial:\n        return True\n    if 'serial_error' not in data['users'][0][username]:\n        data['users'][0][username]['serial_error'] = 1\n    else:\n        data['users'][0][username]['serial_error'] = int(data['users'][0][username]['serial_error']) + 1\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for check_username_serial\")\n    return False\n\ndef set_global_param(key, value):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'global_param'}\n    data[key] = value\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for set_global_param\")\n\ndef modif_config_user(user, changes):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    content['users'][0][user].update(changes)\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for modif_config_user\")\n\n\ndef add_ss_user(port, key, userid=0, ip=''):\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    data = json.loads(content)\n    if ip == '' and 'port_key' in data:\n        if port is None or port == '' or port == 0 or port == 'None':\n            port = int(max(data['port_key'], key=int)) + 1\n        data['port_key'][str(port)] = key\n    else:\n        if 'port_conf' not in data:\n            data['port_conf'] = {}\n        if 'port_key' in data:\n            for old_port in data['port_key']:\n                data['port_conf'][old_port] = {'key': data['port_key'][old_port]}\n            del data['port_key']\n        if port == '' or port == \"None\" or port is None or port == 0:\n            port = int(max(data['port_conf'], key=int)) + 1\n        if ip != '':\n            data['port_conf'][str(port)] = {'key': key, 'local_address': ip, 'userid': userid}\n        else:\n            data['port_conf'][str(port)] = {'key': key, 'userid': userid}\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        if ip != '':\n            data = 'add: {\"server_port\": ' + str(port) + ', \"key\": \"' + key + '\", \"local_addr\": \"' + ip + '\"}'\n        else:\n            data = 'add: {\"server_port\": ' + str(port) + ', \"key\": \"' + key + '\"}'\n        ss_socket.settimeout(1)\n        ss_socket.sendto(data.encode(), (\"127.0.0.1\", 8839))\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks add timeout (\" + str(err) + \")\")\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks add error (\" + str(err) + \")\")\n    return port\n\ndef remove_ss_user(port):\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    data = json.loads(content)\n    if 'port_key' in data:\n        del data['port_key'][str(port)]\n    else:\n        del data['port_conf'][str(port)]\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    try:\n        ss_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        data = 'remove: {\"server_port\": ' + str(port) + '}'\n        ss_socket.settimeout(1)\n        ss_socket.sendto(data.encode(), (\"127.0.0.1\", 8839))\n    except socket.timeout as err:\n        LOG.debug(\"Shadowsocks remove timeout (\" + str(err) + \")\")\n    except socket.error as err:\n        LOG.debug(\"Shadowsocks remove error (\" + str(err) + \")\")\n\ndef v2ray_add_user(user, restart=1):\n    v2rayuuid = str(uuid.uuid1())\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == 'omrin-tunnel':\n                inbounds['settings']['clients'].append({'id': v2rayuuid, 'level': 0, 'alterId': 0, 'email': user})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n    return v2rayuuid\n\ndef v2ray_del_user(user, restart=1):\n    v2rayuuid = str(uuid.uuid1())\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == 'omrin-tunnel':\n                for v2rayuser in inbounds['settings']['clients']:\n                    if v2rayuser['email'] == user:\n                        inbounds['settings']['clients'].remove(v2rayuser)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_add_outbound(tag,ip, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        data['outbounds'].append({'protocol': 'freedom', 'settings': { 'userLevel': 0 }, 'tag': tag, 'sendThrough': ip})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_del_outbound(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for outbounds in data['outbounds']:\n            if outbounds['tag'] == tag:\n                data['outbounds'].remove(outbounds)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_add_routing(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        data['routing']['rules'].append({'type': 'field', 'inboundTag': ( 'omrintunnel' ), 'outboundTag': tag})\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef v2ray_del_routing(tag, restart=1):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        for rules in data['routing']['rules']:\n            if rules['outboundTag'] == tag:\n                data['routing']['rules'].remove(rules)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5 and restart == 1:\n        os.system(\"systemctl -q restart v2ray\")\n\n\ndef add_gre_tunnels():\n    nbip = 0\n    allips = []\n    for intf in netifaces.interfaces():\n        addrs = netifaces.ifaddresses(intf)\n        try:\n            ipv4_addr_list = addrs[netifaces.AF_INET]\n            for ip_info in ipv4_addr_list:\n                addr = ip_info['addr']\n                if not IPAddress(addr).is_private() and not IPAddress(addr).is_reserved():\n                    allips.append(addr)\n                    nbip = nbip + 1\n        except Exception as exception:\n            pass\n\n    if nbip > 1:\n        nbgre = 0\n        nbip = 0\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/snat', 'rb'))).hexdigest()\n        for intf in netifaces.interfaces():\n            addrs = netifaces.ifaddresses(intf)\n            try:\n                ipv4_addr_list = addrs[netifaces.AF_INET]\n                for ip_info in ipv4_addr_list:\n                    addr = ip_info['addr']\n                    if not IPAddress(addr).is_private() and not IPAddress(addr).is_reserved():\n                        netmask = ip_info['netmask']\n                        ip = IPNetwork('10.255.249.0/24')\n                        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n                            content = json.load(f)\n                        for user in content['users'][0]:\n                            if user != \"admin\":\n                                subnets = ip.subnet(30)\n                                network = list(subnets)[nbgre]\n                                nbgre = nbgre + 1\n                                userid = 0\n                                username = user\n                                iface = intf.split(':')[0]\n                                if 'userid' in content['users'][0][user]:\n                                    userid = content['users'][0][user]['userid']\n                                if 'username' in content['users'][0][user]:\n                                    username = content['users'][0][user]['username']\n                                gre_intf = 'gre-user' + str(userid) + '-ip' + str(nbip)\n                                with open('/etc/openmptcprouter-vps-admin/intf/' + gre_intf, 'w') as n:\n                                    n.write('INTF=' + str(intf.split(':')[0]) + \"\\n\")\n                                    n.write('INTFADDR=' + str(addr) + \"\\n\")\n                                    n.write('INTFNETMASK=' + str(netmask) + \"\\n\")\n                                    n.write('NETWORK=' + str(network) + \"\\n\")\n                                    n.write('LOCALIP=' + str(list(network)[1]) + \"\\n\")\n                                    n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n                                    n.write('NETMASK=255.255.255.252' + \"\\n\")\n                                    n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n                                    n.write('USERNAME=' + str(username) + \"\\n\")\n                                    n.write('USERID=' + str(userid) + \"\\n\")\n                                fd, tmpfile = mkstemp()\n                                with open('/etc/shorewall/snat', 'r') as h, open(tmpfile, 'a+') as n:\n                                    for line in h:\n                                        if not '# OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) in line:\n                                            n.write(line)\n                                    n.write('SNAT(' + str(addr) + ')\t' + str(network) + '\t' + str(iface) + ' # OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) + \"\\n\")\n                                    n.write('SNAT(' + str(list(network)[1]) + ')\t-\t' + gre_intf + ' # OMR GRE for public IP ' + str(addr) + ' for user ' + str(user) + \"\\n\")\n                                os.close(fd)\n                                move(tmpfile, '/etc/shorewall/snat')\n                                #fd, tmpfile = mkstemp()\n                                #with open('/etc/shorewall/interfaces', 'r') as h, open(tmpfile, 'a+') as n:\n                                #    for line in h:\n                                #        if not 'gre-user' + str(userid) + '-ip' + str(nbip) in line:\n                                #            n.write(line)\n                                #    n.write('vpn\tgre-user' + str(userid) + '-ip' + str(nbip) + '\tnosmurfs,tcpflags' + \"\\n\")\n                                #os.close(fd)\n                                #move(tmpfile, '/etc/shorewall/interfaces')\n                                if str(iface) != IFACE:\n                                    fd, tmpfile = mkstemp()\n                                    with open('/etc/shorewall/interfaces', 'r') as h, open(tmpfile, 'a+') as n:\n                                        for line in h:\n                                            if not str(iface) in line:\n                                                n.write(line)\n                                        n.write('net\t' + str(iface) + '\tdhcp,nosmurfs,tcpflags,routefilter,sourceroute=0' + \"\\n\")\n                                    os.close(fd)\n                                    move(tmpfile, '/etc/shorewall/interfaces')\n                                user_gre_tunnels = {}\n                                if 'gre_tunnels' in content['users'][0][user]:\n                                    user_gre_tunnels = content['users'][0][user]['gre_tunnels']\n                                if not gre_intf in user_gre_tunnels or user_gre_tunnels[gre_intf]['public_ip'] != str(addr):\n                                    with open('/etc/shadowsocks-libev/manager.json') as g:\n                                        contentss = g.read()\n                                    contentss = re.sub(\",\\s*}\", \"}\", contentss) # pylint: disable=W1401\n                                    datass = json.loads(contentss)\n                                    ss_port = content['users'][0][user]['shadowsocks_port']\n                                    if 'port_key' in datass:\n                                        ss_key = datass['port_key'][str(ss_port)]\n                                    if 'port_conf' in datass:\n                                        ss_key = datass['port_conf'][str(ss_port)]['key']\n                                    if gre_intf not in user_gre_tunnels:\n                                        user_gre_tunnels[gre_intf] = {}\n                                    user_gre_tunnels[gre_intf] = {'shadowsocks_port': str(add_ss_user('', ss_key, userid, str(addr))), 'local_ip': str(list(network)[1]), 'remote_ip': str(list(network)[2]), 'public_ip': str(addr)}\n                                    #user_gre_tunnels[gre_intf] = {'local_ip': str(list(network)[1]), 'remote_ip': str(list(network)[2]), 'public_ip': str(addr)}\n                                    modif_config_user(user, {'gre_tunnels': user_gre_tunnels})\n                        nbip = nbip + 1\n            except Exception as exception:\n                pass\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/snat', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall\")\n            os.system(\"systemctl -q restart shadowsocks-libev-manager@manager\")\n    set_global_param('allips', allips)\n\nadd_gre_tunnels()\n\n\ndef add_glorytun_tcp(userid):\n    port = '650{:02d}'.format(userid)\n    ip = IPNetwork('10.255.255.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/glorytun-tcp/tun0', 'r') as f, \\\n          open('/etc/glorytun-tcp/tun' + str(userid), 'w') as n:\n        for line in f:\n            if 'PORT' in line:\n                n.write('PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=tun' + str(userid) + \"\\n\")\n            elif (not 'LOCALIP' in line\n                  and not 'REMOTEIP' in line\n                  and not 'BROADCASTIP' in line\n                  and not line == \"\\n\"):\n                n.write(line)\n        n.write(\"\\n\" + 'LOCALIP=' + str(list(network)[1]) + \"\\n\")\n        n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n        n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n    glorytun_tcp_key = secrets.token_hex(32)\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'w') as f:\n        f.write(glorytun_tcp_key.upper())\n    os.system(\"systemctl -q enable glorytun-tcp@tun\" + str(userid))\n    os.system(\"systemctl -q restart glorytun-tcp@tun\" + str(userid))\n\ndef remove_glorytun_tcp(userid):\n    os.system(\"systemctl -q disable glorytun-tcp@tun\" + str(userid))\n    os.system(\"systemctl -q stop glorytun-tcp@tun\" + str(userid))\n    os.remove('/etc/glorytun-tcp/tun' + str(userid) + '.key')\n    os.remove('/etc/glorytun-tcp/tun' + str(userid))\n\ndef add_glorytun_udp(userid):\n    port = '650{:02d}'.format(userid)\n    ip = IPNetwork('10.255.254.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/glorytun-udp/tun0', 'r') as f, \\\n          open('/etc/glorytun-udp/tun' + str(userid), 'w') as n:\n        for line in f:\n            if 'BIND_PORT' in line:\n                n.write('BIND_PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=tun' + str(userid) + \"\\n\")\n            elif (not 'LOCALIP' in line\n                  and not 'REMOTEIP' in line\n                  and not 'BROADCASTIP' in line\n                  and not line == \"\\n\"):\n                n.write(line)\n        n.write(\"\\n\" + 'LOCALIP=' + str(list(network)[1]) + \"\\n\")\n        n.write('REMOTEIP=' + str(list(network)[2]) + \"\\n\")\n        n.write('BROADCASTIP=' + str(network.broadcast) + \"\\n\")\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'r') as f, \\\n          open('/etc/glorytun-udp/tun' + str(userid) + '.key', 'w') as n:\n        for line in f:\n            n.write(line)\n    os.system(\"systemctl -q enable glorytun-udp@tun\" + str(userid))\n    os.system(\"systemctl -q restart glorytun-udp@tun\" + str(userid))\n\ndef remove_glorytun_udp(userid):\n    os.system(\"systemctl -q disable glorytun-udp@tun\" + str(userid))\n    os.system(\"systemctl -q stop glorytun-udp@tun\" + str(userid))\n    os.remove('/etc/glorytun-udp/tun' + str(userid) + '.key')\n    os.remove('/etc/glorytun-udp/tun' + str(userid))\n\n\ndef add_dsvpn(userid):\n    port = '654{:02d}'.format(userid)\n    ip = IPNetwork('10.255.251.0/24')\n    subnets = ip.subnet(30)\n    network = list(subnets)[userid]\n    with open('/etc/dsvpn/dsvpn0', 'r') as f, open('/etc/dsvpn/dsvpn' + str(userid), 'w') as n:\n        for line in f:\n            if 'PORT' in line:\n                n.write('PORT=' + port + \"\\n\")\n            elif 'DEV' in line:\n                n.write('DEV=dsvpn' + str(userid) + \"\\n\")\n            elif 'LOCALTUNIP' in line:\n                n.write('LOCALTUNIP=' + str(list(network)[1]) + \"\\n\")\n            elif 'REMOTETUNIP' in line:\n                n.write('REMOTETUNIP=' + str(list(network)[2]) + \"\\n\")\n            else:\n                n.write(line)\n    dsvpn_key = secrets.token_hex(32)\n    with open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'w') as f:\n        f.write(dsvpn_key.upper())\n    os.system(\"systemctl -q enable dsvpn@dsvpn\" + str(userid))\n    os.system(\"systemctl -q restart dsvpn@dsvpn\" + str(userid))\n\ndef remove_dsvpn(userid):\n    os.system(\"systemctl -q disable dsvpn@dsvpn\" + str(userid))\n    os.system(\"systemctl -q stop dsvpn@dsvpn\" + str(userid))\n    os.remove('/etc/dsvpn/dsvpn' + str(userid))\n    os.remove('/etc/dsvpn/dsvpn' + str(userid) + '.key')\n\n\ndef ordered(obj):\n    if isinstance(obj, dict):\n        return sorted((k, ordered(v)) for k, v in obj.items())\n    if isinstance(obj, list):\n        return sorted(ordered(x) for x in obj)\n    else:\n        return obj\n\ndef v2ray_add_port(user, port, proto, name, destip, destport):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    tag = user.username + '_redir_' + proto + '_' + str(port)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            LOG.debug(inbounds)\n            if inbounds['tag'] == tag:\n                exist = 1\n        if exist == 0:\n            inbounds = {'tag': user.username + '_redir_' + proto + '_' + str(port), 'port': int(port), 'protocol': 'dokodemo-door', 'settings': {'network': proto, 'port': int(destport), 'address': destip}}\n            data['inbounds'].append(inbounds)\n            routing = {'type': 'field','inboundTag': [user.username + '_redir_' + proto + '_' + str(port)], 'outboundTag': 'OMRLan'}\n            data['routing']['rules'].append(routing)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart v2ray\")\n\n\ndef v2ray_del_port(username, port, proto, name):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    tag = user.username + '_redir_' + proto + '_' + str(port)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        data = json.load(f)\n        exist = 0\n        for inbounds in data['inbounds']:\n            if inbounds['tag'] == tag:\n                data['inbounds'].remove(inbounds)\n    with open('/etc/v2ray/v2ray-server.json', 'w') as f:\n        json.dump(data, f, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart v2ray\")\n\ndef shorewall_add_port(user, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip='', vpn='default'):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/rules', 'r') as f, \\\n          open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '' and dest_ip == '':\n                if (fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto in line):\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip == '':\n                    comment = ' to ' + source_dip\n                if dest_ip == '':\n                    comment = comment + ' from ' + dest_ip\n                if (fwtype == 'ACCEPT' and not '# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment in line):\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n        if source_dip == '' and dest_ip == '':\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\tnet\t\t$FW\t\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n        else:\n            net = 'net'\n            comment = ''\n            if source_dip != '':\n                comment = ' to ' + source_dip\n            if dest_ip != '':\n                comment = comment + ' from ' + dest_ip\n                net = 'net:' + dest_ip\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\t' + net + '\t\t$FW\t\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment + \"\\n\")\n            elif fwtype == 'DNAT' and vpn != 'default':\n                n.write('DNAT\t\t' + net + '\t\tvpn:' + vpn + '\t' + proto + '\t' + port + '\t-\t' + source_dip +  '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n                #n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR' + '\t' + proto + '\t' + port + '\t-\t' + source_dip +  '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n\ndef shorewall_del_port(username, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '' and dest_ip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip != '':\n                    comment = ' to ' + source_dip\n                if dest_ip != '':\n                    comment = comment + ' from ' + dest_ip\n                if fwtype == 'ACCEPT' and not '# OMR ' + username + ' open ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n\ndef shorewall6_add_port(user, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    userid = user.userid\n    if userid is None:\n        userid = 0\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                comment = ''\n                if source_dip == '':\n                    comment = ' to ' + source_dip\n                if dest_ip == '':\n                    comment = comment + ' from ' + dest_ip\n                if fwtype == 'ACCEPT' and not port + '# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment in line:\n                    n.write(line)\n        if source_dip == '':\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\tnet\t\t$FW\t\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\tnet\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + \"\\n\")\n        else:\n            net = 'net'\n            comment = ''\n            if source_dip == '':\n                comment = ' to ' + source_dip\n            if dest_ip == '':\n                comment = comment + ' from ' + dest_ip\n                net = 'net:' + dest_ip\n            if fwtype == 'ACCEPT':\n                n.write('ACCEPT\t\t' + net + '\t\t$FW\t\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' open ' + name + ' port ' + proto + comment+  \"\\n\")\n            elif fwtype == 'DNAT' and userid == 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment +  \"\\n\")\n            elif fwtype == 'DNAT' and userid != 0:\n                n.write('DNAT\t\t' + net + '\t\tvpn:$OMR_ADDR_USER' + str(userid) + '\t' + proto + '\t' + port +  '\t-\t' + source_dip + '\t# OMR ' + user.username + ' redirect ' + name + ' port ' + proto + comment + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n\ndef shorewall6_del_port(username, port, proto, name, fwtype='ACCEPT', source_dip='', dest_ip=''):\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if source_dip == '':\n                if fwtype == 'ACCEPT' and not port + '\t# OMR open ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' open ' + name + ' port ' + proto in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not port + '\t# OMR redirect ' + name + ' port ' + proto in line and not port + '\t# OMR ' + username + ' redirect ' + name + ' port ' + proto in line:\n                    n.write(line)\n            else:\n                if fwtype == 'ACCEPT' and not '# OMR ' + username + ' open ' + name + ' port ' + proto + ' to ' + source_dip in line:\n                    n.write(line)\n                elif fwtype == 'DNAT' and not '# OMR ' + username + ' redirect ' + name + ' port ' + proto + ' to ' + source_dip in line:\n                    n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/rules')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n\ndef set_lastchange(sync=0):\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        return {'error': 'Config file not readable', 'route': 'lastchange'}\n    data[\"lastchange\"] = time.time() + sync\n    if data:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as outfile:\n            json.dump(data, outfile, indent=4)\n    else:\n        LOG.debug(\"Empty data for set_last_change\")\n\n\nwith open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n    omr_config_data = json.load(f)\n    if 'debug' in omr_config_data and omr_config_data['debug']:\n        LOG.setLevel(logging.DEBUG)\n\nfake_users_db = omr_config_data['users'][0]\n\ndef verify_password(plain_password, user_password):\n    if secrets.compare_digest(plain_password,user_password):\n        LOG.debug(\"password true\")\n        return True\n    return False\n\ndef get_password_hash(password):\n    return password\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        LOG.debug(\"user doesn't exist\")\n        return False\n    if not verify_password(password, user.user_password):\n        LOG.debug(\"wrong password\")\n        return False\n    return user\n\nclass Token(BaseModel):\n    access_token: str = None\n    token_type: str = None\n\n\nclass TokenData(BaseModel):\n    username: str = None\n\nclass User(BaseModel):\n    username: str\n    vpn: str = None\n    vpn_port: int = None\n    vpn_client_ip: str = None\n    permissions: str = 'rw'\n    shadowsocks_port: int = None\n    disabled: bool = 'false'\n    userid: int = None\n\n\nclass UserInDB(User):\n    user_password: str\n\n# Add support for auth before seeing doc\nclass OAuth2PasswordBearerCookie(OAuth2):\n    def __init__(\n            self,\n            tokenUrl: str,\n            scheme_name: str = None,\n            scopes: dict = None,\n            auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        header_authorization: str = request.headers.get(\"Authorization\")\n        cookie_authorization: str = request.cookies.get(\"Authorization\")\n\n        header_scheme, header_param = get_authorization_scheme_param(\n            header_authorization\n        )\n        cookie_scheme, cookie_param = get_authorization_scheme_param(\n            cookie_authorization\n        )\n\n        if header_scheme.lower() == \"bearer\":\n            authorization = True\n            scheme = header_scheme\n            param = header_param\n\n        elif cookie_scheme.lower() == \"bearer\":\n            authorization = True\n            scheme = cookie_scheme\n            param = cookie_param\n\n        else:\n            authorization = False\n\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return param\n\nclass BasicAuth(SecurityBase):\n    def __init__(self, scheme_name: str = None, auto_error: bool = True):\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.model = SecurityBaseModel(type=\"http\")\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"basic\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return param\n\nbasic_auth = BasicAuth(auto_error=False)\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\noauth2_scheme = OAuth2PasswordBearerCookie(tokenUrl=\"/token\")\n\napp = FastAPI(docs_url=None, redoc_url=None, openapi_url=None, title=\"OpenMPTCProuter Server API\")\n\n\ndef create_access_token(*, data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=60)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=HTTP_403_FORBIDDEN,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            LOG.debug(\"get_current_user: Username not found\")\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except PyJWTError:\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n# Show something at homepage\n@app.get(\"/\")\nasync def homepage():\n    return \"Welcome to OpenMPTCProuter Server part\"\n\n# Provide a method to create access tokens. The create_jwt()\n# function is used to actually generate the token\n@app.post('/token', response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n    if not user:\n        LOG.debug(\"Incorrect username or password\")\n        raise HTTPException(status_code=400, detail=\"Incorrect username or password\")\n\n    # Identity can be any data that is json serializable\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": form_data.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/logout\")\nasync def route_logout_and_remove_cookie():\n    response = RedirectResponse(url=\"/\")\n    response.delete_cookie(\"Authorization\")\n    return response\n\n\n# Login for doc\n@app.get(\"/login_basic\")\nasync def login_basic(auth: BasicAuth = Depends(basic_auth)):\n    if not auth:\n        response = Response(headers={\"WWW-Authenticate\": \"Basic\"}, status_code=401)\n        return response\n\n    try:\n        decoded = base64.b64decode(auth).decode(\"ascii\")\n        username, _, password = decoded.partition(\":\")\n        user = authenticate_user(fake_users_db, username, password)\n        if not user:\n            raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n\n        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token = create_access_token(\n            data={\"sub\": username}, expires_delta=access_token_expires\n        )\n\n        token = jsonable_encoder(access_token)\n\n        response = RedirectResponse(url=\"/docs\")\n        response.set_cookie(\n            \"Authorization\",\n            value=f\"Bearer {token}\",\n            httponly=True,\n            max_age=1800,\n            expires=1800,\n        )\n        return response\n\n    except:\n        response = Response(headers={\"WWW-Authenticate\": \"Basic\"}, status_code=401)\n        return response\n\n\n@app.get(\"/openapi.json\")\nasync def get_open_api_endpoint(current_user: User = Depends(get_current_active_user)):\n    return JSONResponse(get_openapi(title=\"FastAPI\", version=1, routes=app.routes))\n\n\n@app.get(\"/docs\")\nasync def get_documentation(current_user: User = Depends(get_current_active_user)):\n    return get_swagger_ui_html(openapi_url=\"/openapi.json\", title=\"docs\")\n\n# Get Client IP\n@app.get('/clienthost')\nasync def status(request: Request):\n    client_host = request.client.host\n    return {\"client_host\": client_host}\n\n# Get VPS status\n@app.get('/status', summary=\"Get current server load average, uptime and release\")\nasync def status(userid: Optional[int] = Query(None), serial: Optional[str] = Query(None), current_user: User = Depends(get_current_user)):\n    LOG.debug('Get status...')\n    if not current_user.permissions == \"admin\":\n        userid = current_user.userid\n    if userid is None:\n        userid = 0\n    username = get_username_from_userid(userid)\n    if not current_user.permissions == \"admin\" and serial is not None:\n        if not check_username_serial(username, serial):\n            return {'error': 'False serial number'}\n    vps_loadavg = os.popen(\"cat /proc/loadavg | awk '{print $1\\\" \\\"$2\\\" \\\"$3}'\").read().rstrip()\n    vps_uptime = os.popen(\"cat /proc/uptime | awk '{print $1}'\").read().rstrip()\n    vps_hostname = socket.gethostname()\n    vps_current_time = time.time()\n    vps_kernel = os.popen('uname -r').read().rstrip()\n    vps_omr_version = os.popen(\"grep -s 'OpenMPTCProuter VPS' /etc/* | awk '{print $4}'\").read().rstrip()\n    mptcp_enabled = os.popen('sysctl -n net.mptcp.mptcp_enabled').read().rstrip()\n    shadowsocks_port = current_user.shadowsocks_port\n    if not shadowsocks_port == None:\n        ss_traffic = get_bytes_ss(current_user.shadowsocks_port)\n    else:\n        ss_traffic = 0\n    v2ray_tx = 0\n    v2ray_rx = 0\n    if os.path.isfile('/etc/v2ray/v2ray-server.json') and checkIfProcessRunning('v2ray'):\n        v2ray_tx = get_bytes_v2ray('tx',username)\n        v2ray_rx = get_bytes_v2ray('rx',username)\n    vpn = 'glorytun_tcp'\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    if 'vpn' in omr_config_data['users'][0][username]:\n        vpn = omr_config_data['users'][0][username]['vpn']\n    vpn_traffic_rx = 0\n    vpn_traffic_tx = 0\n    if vpn == 'glorytun_tcp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-tun' + str(userid))\n    elif vpn == 'glorytun_udp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-udp-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-udp-tun' + str(userid))\n    elif vpn == 'mlvpn':\n        vpn_traffic_rx = get_bytes('rx', 'mlvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'mlvpn' + str(userid))\n    elif vpn == 'dsvpn':\n        vpn_traffic_rx = get_bytes('rx', 'dsvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'dsvpn' + str(userid))\n    elif vpn == 'openvpn':\n        vpn_traffic_rx = get_bytes('rx', 'tun0')\n        vpn_traffic_tx = get_bytes('tx', 'tun0')\n    elif vpn == 'openvpn_bonding':\n        vpn_traffic_rx = get_bytes('rx', 'omr-bonding')\n        vpn_traffic_tx = get_bytes('tx', 'omr-bonding')\n    LOG.debug('Get status: done')\n    if IFACE:\n        return {'vps': {'time': vps_current_time, 'loadavg': vps_loadavg, 'uptime': vps_uptime, 'mptcp': mptcp_enabled, 'hostname': vps_hostname, 'kernel': vps_kernel, 'omr_version': vps_omr_version}, 'network': {'tx': get_bytes('tx', IFACE), 'rx': get_bytes('rx', IFACE)}, 'shadowsocks': {'traffic': ss_traffic}, 'vpn': {'tx': vpn_traffic_tx, 'rx': vpn_traffic_rx}, 'v2ray': {'tx': v2ray_tx, 'rx': v2ray_rx}}\n    else:\n        return {'error': 'No iface defined', 'route': 'status'}\n\n# Get VPS config\n@app.get('/config', summary=\"Get full server configuration for current user\")\nasync def config(userid: Optional[int] = Query(None), serial: Optional[str] = Query(None), current_user: User = Depends(get_current_user)):\n    LOG.debug('Get config...')\n    if not current_user.permissions == \"admin\":\n        userid = current_user.userid\n    if userid is None:\n        userid = 0\n    username = get_username_from_userid(userid)\n    if not current_user.permissions == \"admin\" and serial is not None:\n        if not check_username_serial(username, serial):\n            return {'error': 'False serial number'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    LOG.debug('Get config... shadowsocks')\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        data = {'port_key': '', 'server_port': 65101, 'method': 'chacha20'}\n    #shadowsocks_port = data[\"server_port\"]\n    shadowsocks_port = current_user.shadowsocks_port\n    if shadowsocks_port is not None:\n        if 'port_key' in data:\n            shadowsocks_key = data[\"port_key\"][str(shadowsocks_port)]\n        else:\n            shadowsocks_key = data[\"port_conf\"][str(shadowsocks_port)][\"key\"]\n    else:\n        shadowsocks_key = ''\n    shadowsocks_method = data[\"method\"]\n    if 'fast_open' in data:\n        shadowsocks_fast_open = data[\"fast_open\"]\n    else:\n        shadowsocks_fast_open = False\n    if 'reuse_port' in data:\n        shadowsocks_reuse_port = data[\"reuse_port\"]\n    else:\n        shadowsocks_reuse_port = False\n    if 'no_delay' in data:\n        shadowsocks_no_delay = data[\"no_delay\"]\n    else:\n        shadowsocks_no_delay = False\n    if 'mptcp' in data:\n        shadowsocks_mptcp = data[\"mptcp\"]\n    else:\n        shadowsocks_mptcp = False\n    if 'ebpf' in data:\n        shadowsocks_ebpf = data[\"ebpf\"]\n    else:\n        shadowsocks_ebpf = False\n    if \"plugin\" in data:\n        shadowsocks_obfs = True\n        if 'v2ray' in data[\"plugin\"]:\n            shadowsocks_obfs_plugin = 'v2ray'\n        else:\n            shadowsocks_obfs_plugin = 'obfs'\n        if 'tls' in data[\"plugin_opts\"]:\n            shadowsocks_obfs_type = 'tls'\n        else:\n            shadowsocks_obfs_type = 'http'\n    else:\n        shadowsocks_obfs = False\n        shadowsocks_obfs_plugin = ''\n        shadowsocks_obfs_type = ''\n    shadowsocks_port = current_user.shadowsocks_port\n    if not shadowsocks_port == None:\n        ss_traffic = get_bytes_ss(current_user.shadowsocks_port)\n    else:\n        ss_traffic = 0\n\n    LOG.debug('Get config... glorytun')\n    if os.path.isfile('/etc/glorytun-tcp/tun' + str(userid) +'.key'):\n        glorytun_key = open('/etc/glorytun-tcp/tun' + str(userid) + '.key').readline().rstrip()\n    else:\n        glorytun_key = ''\n    glorytun_port = '65001'\n    glorytun_chacha = False\n    glorytun_tcp_host_ip = ''\n    glorytun_tcp_client_ip = ''\n    glorytun_udp_host_ip = ''\n    glorytun_udp_client_ip = ''\n    if os.path.isfile('/etc/glorytun-tcp/tun' + str(userid)):\n        with open('/etc/glorytun-tcp/tun' + str(userid), \"r\") as glorytun_file:\n            for line in glorytun_file:\n                if 'PORT=' in line:\n                    glorytun_port = line.replace(line[:5], '').rstrip()\n                if 'LOCALIP=' in line:\n                    glorytun_tcp_host_ip = line.replace(line[:8], '').rstrip()\n                if 'REMOTEIP=' in line:\n                    glorytun_tcp_client_ip = line.replace(line[:9], '').rstrip()\n                if 'chacha' in line:\n                    glorytun_chacha = True\n    if userid == 0 and glorytun_tcp_host_ip == '':\n        if 'glorytun_tcp_type' in omr_config_data:\n            if omr_config_data['glorytun_tcp_type'] == 'static':\n                glorytun_tcp_host_ip = '10.255.255.1'\n                glorytun_tcp_client_ip = '10.255.255.2'\n            else:\n                glorytun_tcp_host_ip = 'dhcp'\n                glorytun_tcp_client_ip = 'dhcp'\n        else:\n            glorytun_tcp_host_ip = '10.255.255.1'\n            glorytun_tcp_client_ip = '10.255.255.2'\n    if os.path.isfile('/etc/glorytun-udp/tun' + str(userid)):\n        with open('/etc/glorytun-udp/tun' + str(userid), \"r\") as glorytun_file:\n            for line in glorytun_file:\n                if 'LOCALIP=' in line:\n                    glorytun_udp_host_ip = line.replace(line[:8], '').rstrip()\n                if 'REMOTEIP=' in line:\n                    glorytun_udp_client_ip = line.replace(line[:9], '').rstrip()\n\n    if userid == 0 and glorytun_udp_host_ip == '':\n        if 'glorytun_udp_type' in omr_config_data:\n            if omr_config_data['glorytun_udp_type'] == 'static':\n                glorytun_udp_host_ip = '10.255.254.1'\n                glorytun_udp_client_ip = '10.255.254.2'\n            else:\n                glorytun_udp_host_ip = 'dhcp'\n                glorytun_udp_client_ip = 'dhcp'\n        else:\n            glorytun_udp_host_ip = '10.255.254.1'\n            glorytun_udp_client_ip = '10.255.254.2'\n    available_vpn = [\"glorytun_tcp\", \"glorytun_udp\"]\n    LOG.debug('Get config... dsvpn')\n    if os.path.isfile('/etc/dsvpn/dsvpn' + str(userid) + '.key'):\n        dsvpn_key = open('/etc/dsvpn/dsvpn' + str(userid) + '.key').readline().rstrip()\n        available_vpn.append(\"dsvpn\")\n    else:\n        dsvpn_key = ''\n    dsvpn_port = '65401'\n    dsvpn_host_ip = ''\n    dsvpn_client_ip = ''\n    if os.path.isfile('/etc/dsvpn/dsvpn' + str(userid)):\n        with open('/etc/dsvpn/dsvpn' + str(userid), \"r\") as dsvpn_file:\n            for line in dsvpn_file:\n                if 'PORT=' in line:\n                    dsvpn_port = line.replace(line[:5], '').rstrip()\n                if 'LOCALTUNIP=' in line:\n                    dsvpn_host_ip = line.replace(line[:11], '').rstrip()\n                if 'REMOTETUNIP=' in line:\n                    dsvpn_client_ip = line.replace(line[:12], '').rstrip()\n\n    if userid == 0 and dsvpn_host_ip == '':\n        dsvpn_host_ip = '10.255.251.1'\n        dsvpn_client_ip = '10.255.251.2'\n\n    LOG.debug('Get config... iperf3')\n    if os.path.isfile('/etc/iperf3/public.pem'):\n        with open('/etc/iperf3/public.pem', \"rb\") as iperfkey_file:\n            iperf_keyb = base64.b64encode(iperfkey_file.read())\n            iperf3_key = iperf_keyb.decode('utf-8')\n    else:\n        iperf3_key = ''\n\n    if os.path.isfile('/etc/pihole/setupVars.conf'):\n        pihole = True\n    else:\n        pihole = False\n\n    LOG.debug('Get config... openvpn')\n    #if os.path.isfile('/etc/openvpn/server/static.key'):\n    #    with open('/etc/openvpn/server/static.key',\"rb\") as ovpnkey_file:\n    #        openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n    #        openvpn_key = openvpn_keyb.decode('utf-8')\n    #    available_vpn.append(\"openvpn\")\n    #else:\n    #    openvpn_key = ''\n    openvpn_key = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/private/' + username + '.key'):\n        with open('/etc/openvpn/ca/pki/private/' + username + '.key', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_key = openvpn_keyb.decode('utf-8')\n    else:\n        openvpn_client_key = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/issued/' + username + '.crt'):\n        with open('/etc/openvpn/ca/pki/issued/' + username + '.crt', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_crt = openvpn_keyb.decode('utf-8')\n        available_vpn.append(\"openvpn\")\n    else:\n        openvpn_client_crt = ''\n    if os.path.isfile('/etc/openvpn/ca/pki/ca.crt'):\n        with open('/etc/openvpn/ca/pki/ca.crt', \"rb\") as ovpnkey_file:\n            openvpn_keyb = base64.b64encode(ovpnkey_file.read())\n            openvpn_client_ca = openvpn_keyb.decode('utf-8')\n    else:\n        openvpn_client_ca = ''\n    openvpn_port = '65301'\n    openvpn_cipher = 'AES-256-CBC'\n    if os.path.isfile('/etc/openvpn/openvpn-tun0.conf'):\n        with open('/etc/openvpn/openvpn-tun0.conf', \"r\") as openvpn_file:\n            for line in openvpn_file:\n                if 'port ' in line:\n                    openvpn_port = line.replace(line[:5], '').rstrip()\n                if 'cipher ' in line:\n                    openvpn_cipher = line.replace(line[:7], '').rstrip()\n    openvpn_host_ip = '10.255.252.1'\n    #openvpn_client_ip = '10.255.252.2'\n    openvpn_client_ip = 'dhcp'\n\n    if os.path.isfile('/etc/openvpn/bonding1.conf'):\n        available_vpn.append(\"openvpn_bonding\")\n\n    LOG.debug('Get config... mlvpn')\n    if os.path.isfile('/etc/mlvpn/mlvpn0.conf'):\n        mlvpn_config = configparser.ConfigParser()\n        mlvpn_config.read_file(open(r'/etc/mlvpn/mlvpn0.conf'))\n        mlvpn_key = mlvpn_config.get('general', 'password').strip('\"')\n        mlvpn_timeout = mlvpn_config.get('general', 'timeout')\n        mlvpn_reorder_buffer_size = mlvpn_config.get('general', 'reorder_buffer_size')\n        mlvpn_loss_tolerence = mlvpn_config.get('general', 'loss_tolerence')\n        if mlvpn_config.has_option('general', 'cleartext_data'):\n            mlvpn_cleartext_data = mlvpn_config.get('general', 'cleartext_data')\n        else:\n            mlvpn_cleartext_data = ''\n        available_vpn.append(\"mlvpn\")\n    else:\n        mlvpn_key = ''\n        mlvpn_timeout = ''\n        mlvpn_reorder_buffer_size = ''\n        mlvpn_loss_tolerence = ''\n        mlvpn_cleartext_data = ''\n    mlvpn_host_ip = '10.255.253.1'\n    mlvpn_client_ip = '10.255.253.2'\n\n    LOG.debug('Get config... wireguard')\n    if os.path.isfile('/etc/wireguard/vpn-server-public.key'):\n        with open('/etc/wireguard/vpn-server-public.key', \"rb\") as wgkey_file:\n            wireguard_key = wgkey_file.read()\n    else:\n        wireguard_key = ''\n    wireguard_host_ip = '10.255.247.1'\n    wireguard_port = '65311'\n\n    gre_tunnel = False\n    gre_tunnel_conf = []\n#    for tunnel in pathlib.Path('/etc/openmptcprouter-vps-admin/intf').glob('gre-user' + str(userid) + '-ip*'):\n#        gre_tunnel = True\n#        with open(tunnel, \"r\") as tunnel_conf:\n#            for line in tunnel_conf:\n#                if 'LOCALIP=' in line:\n#                    gre_tunnel_localip = line.replace(line[:8], '').rstrip()\n#                if 'REMOTEIP=' in line:\n#                    gre_tunnel_remoteip = line.replace(line[:9], '').rstrip()\n#                if 'NETMASK=' in line:\n#                    gre_tunnel_netmask = line.replace(line[:8], '').rstrip()\n#                if 'INTFADDR=' in line:\n#                    gre_tunnel_intfaddr = line.replace(line[:9], '').rstrip()\n#        gre_tunnel_conf.append(\"{'local_ip': '\" + gre_tunnel_localip + \"', 'remote_ip': '\" + gre_tunnel_remoteip + \"', 'netmask': '\" + gre_tunnel_netmask + \"', 'public_ip': '\" + gre_tunnel_intfaddr + \"'}\")\n\n    if 'gre_tunnels' in omr_config_data['users'][0][username]:\n        gre_tunnel = True\n        gre_tunnel_conf = omr_config_data['users'][0][username]['gre_tunnels']\n\n    if 'vpnremoteip' in omr_config_data['users'][0][username]:\n        vpn_remote_ip = omr_config_data['users'][0][username]['vpnremoteip']\n    else:\n        vpn_remote_ip = ''\n    if 'vpnlocalip' in omr_config_data['users'][0][username]:\n        vpn_local_ip = omr_config_data['users'][0][username]['vpnlocalip']\n    else:\n        vpn_local_ip = ''\n\n    v2ray = False\n    v2ray_conf = []\n    v2ray_tx = 0\n    v2ray_rx = 0\n    if os.path.isfile('/etc/v2ray/v2ray-server.json'):\n        v2ray = True\n        if not 'v2ray' in omr_config_data['users'][0][username]:\n            v2ray_key = os.popen('jq -r .inbounds[0].settings.clients[0].id /etc/v2ray/v2ray-server.json').read().rstrip()\n            v2ray_port = os.popen('jq -r .inbounds[0].port /etc/v2ray/v2ray-server.json').read().rstrip()\n            v2ray_conf = { 'key': v2ray_key, 'port': v2ray_port}\n            modif_config_user(username, {'v2ray': v2ray_conf})\n        else:\n            v2ray_conf = omr_config_data['users'][0][username]['v2ray']\n        if checkIfProcessRunning('v2ray'):\n            v2ray_tx = get_bytes_v2ray('tx',username)\n            v2ray_rx = get_bytes_v2ray('rx',username)\n\n    LOG.debug('Get config... mptcp')\n    mptcp_enabled = os.popen('sysctl -n net.mptcp.mptcp_enabled').read().rstrip()\n    mptcp_checksum = os.popen('sysctl -n net.mptcp.mptcp_checksum').read().rstrip()\n    mptcp_path_manager = os.popen('sysctl -n  net.mptcp.mptcp_path_manager').read().rstrip()\n    mptcp_scheduler = os.popen('sysctl -n net.mptcp.mptcp_scheduler').read().rstrip()\n    mptcp_syn_retries = os.popen('sysctl -n net.mptcp.mptcp_syn_retries').read().rstrip()\n\n    congestion_control = os.popen('sysctl -n net.ipv4.tcp_congestion_control').read().rstrip()\n\n    LOG.debug('Get config... ipv6')\n    if 'ipv6_network' in omr_config_data:\n        ipv6_network = omr_config_data['ipv6_network']\n    else:\n        ipv6_network = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\"').read().rstrip()\n    #ipv6_addr = os.popen('wget -6 -qO- -T 2 ipv6.openmptcprouter.com').read().rstrip()\n    if 'ipv6_addr' in omr_config_data:\n        ipv6_addr = omr_config_data['ipv6_addr']\n    else:\n        ipv6_addr = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\" | cut -d/ -f1').read().rstrip()\n    #ipv4_addr = os.popen('wget -4 -qO- -T 1 https://ip.openmptcprouter.com').read().rstrip()\n    LOG.debug('get server IPv4')\n    if 'ipv4' in omr_config_data:\n        ipv4_addr = omr_config_data['ipv4']\n    elif 'internet' in omr_config_data and not omr_config_data['internet']:\n        ipv4_addr = os.popen('ip -4 addr show ' + IFACE +' | grep -oP \"(?<=inet ).*(?= scope global)\" | cut -d/ -f1').read().rstrip()\n    else:\n        ipv4_addr = os.popen(\"dig -4 TXT +timeout=2 +tries=1 +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'\\\"' '{ print $2}'\").read().rstrip()\n        if ipv4_addr == '':\n            ipv4_addr = os.popen('wget -4 -qO- -T 1 http://ip.openmptcprouter.com').read().rstrip()\n        if ipv4_addr == '':\n            ipv4_addr = os.popen('wget -4 -qO- -T 1 http://ifconfig.co').read().rstrip()\n        if ipv4_addr != '':\n            set_global_param('ipv4', ipv4_addr)\n    #ipv4_addr = \"\"\n\n    test_aes = os.popen('cat /proc/cpuinfo | grep aes').read().rstrip()\n    if test_aes == '':\n        vps_aes = False\n    else:\n        vps_aes = True\n    vps_kernel = os.popen('uname -r').read().rstrip()\n    vps_machine = os.popen('uname -m').read().rstrip()\n    vps_omr_version = os.popen(\"grep -s 'OpenMPTCProuter VPS' /etc/* | awk '{print $4}'\").read().rstrip()\n    vps_loadavg = os.popen(\"cat /proc/loadavg | awk '{print $1\" \"$2\" \"$3}'\").read().rstrip()\n    vps_uptime = os.popen(\"cat /proc/uptime | awk '{print $1}'\").read().rstrip()\n    LOG.debug('get hostname')\n    if 'hostname' in omr_config_data:\n        vps_domain = omr_config_data['hostname']\n    elif 'internet' in omr_config_data and not omr_config_data['internet']:\n        vps_domain = ''\n    else:\n        vps_domain = os.popen('wget -4 -qO- -T 1 http://hostname.openmptcprouter.com').read().rstrip()\n        if vps_domain != '':\n            set_global_param('hostname', vps_domain)\n    #vps_domain = os.popen('dig -4 +short +times=3 +tries=1 -x ' + ipv4_addr + \" | sed 's/\\.$//'\").read().rstrip()\n    user_permissions = current_user.permissions\n\n    internet = True\n    if 'internet' in omr_config_data and not omr_config_data['internet']:\n        internet = False\n\n    localip6 = ''\n    remoteip6 = ''\n    ula = ''\n    if userid == 0:\n        if os.path.isfile('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid)):\n            with open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), \"r\") as omr6in4_file:\n                for line in omr6in4_file:\n                    if 'LOCALIP6=' in line:\n                        localip6 = line.replace(line[:9], '').rstrip()\n                    if 'REMOTEIP6=' in line:\n                        remoteip6 = line.replace(line[:10], '').rstrip()\n                    if 'ULA=' in line:\n                        ula = line.replace(line[:4], '').rstrip()\n    else:\n        locaip6 = 'fe80::a00:1'\n        remoteip6 = 'fe80::a00:2'\n\n    proxy = 'shadowsocks'\n    if 'proxy' in omr_config_data['users'][0][username]:\n        proxy = omr_config_data['users'][0][username]['proxy']\n\n    vpn = 'glorytun_tcp'\n    if 'vpn' in omr_config_data['users'][0][username]:\n        vpn = omr_config_data['users'][0][username]['vpn']\n\n    vpn_traffic_rx = 0\n    vpn_traffic_tx = 0\n    if vpn == 'glorytun_tcp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-tun' + str(userid))\n    elif vpn == 'glorytun_udp':\n        vpn_traffic_rx = get_bytes('rx', 'gt-udp-tun' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'gt-udp-tun' + str(userid))\n    elif vpn == 'mlvpn':\n        vpn_traffic_rx = get_bytes('rx', 'mlvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'mlvpn' + str(userid))\n    elif vpn == 'dsvpn':\n        vpn_traffic_rx = get_bytes('rx', 'dsvpn' + str(userid))\n        vpn_traffic_tx = get_bytes('tx', 'dsvpn' + str(userid))\n    elif vpn == 'openvpn':\n        vpn_traffic_rx = get_bytes('rx', 'tun0')\n        vpn_traffic_tx = get_bytes('tx', 'tun0')\n    elif vpn == 'openvpn_bonding':\n        vpn_traffic_rx = get_bytes('rx', 'omr-bonding')\n        vpn_traffic_tx = get_bytes('tx', 'omr-bonding')\n\n    #vpn = current_user.vpn\n    available_proxy = [\"shadowsocks\", \"v2ray\"]\n    if user_permissions == 'ro':\n        del available_vpn\n        available_vpn = [vpn]\n        del available_proxy\n        available_proxy = [proxy]\n\n    alllanips = []\n    client2client = False\n    if 'client2client' in omr_config_data and omr_config_data['client2client']:\n        client2client = True\n        for users in omr_config_data['users'][0]:\n            if 'lanips' in omr_config_data['users'][0][users] and users != username and omr_config_data['users'][0][users]['lanips'][0] not in alllanips:\n                alllanips.append(omr_config_data['users'][0][users]['lanips'][0])\n\n    shorewall_redirect = \"enable\"\n    with open('/etc/shorewall/rules', 'r') as f:\n        for line in f:\n            if '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999' in line:\n                shorewall_redirect = \"disable\"\n    LOG.debug('Get config: done')\n    return {'vps': {'kernel': vps_kernel, 'machine': vps_machine, 'omr_version': vps_omr_version, 'loadavg': vps_loadavg, 'uptime': vps_uptime, 'aes': vps_aes}, 'shadowsocks': {'traffic': ss_traffic, 'key': shadowsocks_key, 'port': shadowsocks_port, 'method': shadowsocks_method, 'fast_open': shadowsocks_fast_open, 'reuse_port': shadowsocks_reuse_port, 'no_delay': shadowsocks_no_delay, 'mptcp': shadowsocks_mptcp, 'ebpf': shadowsocks_ebpf, 'obfs': shadowsocks_obfs, 'obfs_plugin': shadowsocks_obfs_plugin, 'obfs_type': shadowsocks_obfs_type}, 'glorytun': {'key': glorytun_key, 'udp': {'host_ip': glorytun_udp_host_ip, 'client_ip': glorytun_udp_client_ip}, 'tcp': {'host_ip': glorytun_tcp_host_ip, 'client_ip': glorytun_tcp_client_ip}, 'port': glorytun_port, 'chacha': glorytun_chacha}, 'dsvpn': {'key': dsvpn_key, 'host_ip': dsvpn_host_ip, 'client_ip': dsvpn_client_ip, 'port': dsvpn_port}, 'openvpn': {'key': openvpn_key, 'client_key': openvpn_client_key, 'client_crt': openvpn_client_crt, 'client_ca': openvpn_client_ca, 'host_ip': openvpn_host_ip, 'client_ip': openvpn_client_ip, 'port': openvpn_port, 'cipher': openvpn_cipher},'wireguard': {'key': wireguard_key, 'host_ip': wireguard_host_ip, 'port': wireguard_port}, 'mlvpn': {'key': mlvpn_key, 'host_ip': mlvpn_host_ip, 'client_ip': mlvpn_client_ip,'timeout': mlvpn_timeout,'reorder_buffer_size': mlvpn_reorder_buffer_size,'loss_tolerence': mlvpn_loss_tolerence,'cleartext_data': mlvpn_cleartext_data}, 'shorewall': {'redirect_ports': shorewall_redirect}, 'mptcp': {'enabled': mptcp_enabled, 'checksum': mptcp_checksum, 'path_manager': mptcp_path_manager, 'scheduler': mptcp_scheduler, 'syn_retries': mptcp_syn_retries}, 'network': {'congestion_control': congestion_control, 'ipv6_network': ipv6_network, 'ipv6': ipv6_addr, 'ipv4': ipv4_addr, 'domain': vps_domain, 'internet': internet}, 'vpn': {'available': available_vpn, 'current': vpn, 'remoteip': vpn_remote_ip, 'localip': vpn_local_ip, 'rx': vpn_traffic_rx, 'tx': vpn_traffic_tx}, 'iperf': {'user': 'openmptcprouter', 'password': 'openmptcprouter', 'key': iperf3_key}, 'pihole': {'state': pihole}, 'user': {'name': username, 'permission': user_permissions}, 'ip6in4': {'localip': localip6, 'remoteip': remoteip6, 'ula': ula}, 'client2client': {'enabled': client2client, 'lanips': alllanips}, 'gre_tunnel': {'enabled': gre_tunnel, 'config': gre_tunnel_conf}, 'v2ray': {'enabled': v2ray, 'config': v2ray_conf, 'tx': v2ray_tx, 'rx': v2ray_rx}, 'proxy': {'available': available_proxy, 'current': proxy}}\n\n# Set shadowsocks config\nclass OBFSPLUGIN(str, Enum):\n    v2ray = \"v2ray\"\n    obfs = \"obfs\"\n\nclass OBFSTYPE(str, Enum):\n    tls = \"tls\"\n    http = \"http\"\n\n\nclass ShadowsocksConfigparams(BaseModel):\n    port: int = Query(..., gt=0, lt=65535)\n    method: str\n    fast_open: bool\n    reuse_port: bool\n    no_delay: bool\n    mptcp: bool = Query(True, title=\"Enable/Disable MPTCP support\")\n    obfs: bool = Query(False, title=\"Enable/Disable obfuscation support\")\n    obfs_plugin: OBFSPLUGIN = Query(\"v2ray\", title=\"Choose obfuscation plugin\")\n    obfs_type: OBFSTYPE = Query(\"tls\", title=\"Choose obfuscation method\")\n    key: str\n\n@app.post('/shadowsocks', summary=\"Modify Shadowsocks-libev configuration\")\ndef shadowsocks(*, params: ShadowsocksConfigparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shadowsocks'}\n    ipv6_network = os.popen('ip -6 addr show ' + IFACE6 +' | grep -oP \"(?<=inet6 ).*(?= scope global)\"').read().rstrip()\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/manager.json', 'rb'))).hexdigest()\n    with open('/etc/shadowsocks-libev/manager.json') as f:\n        content = f.read()\n    content = re.sub(\",\\s*}\", \"}\", content) # pylint: disable=W1401\n    try:\n        data = json.loads(content)\n    except ValueError as e:\n        data = {'timeout': 600, 'verbose': 0, 'prefer_ipv6': False}\n    #key = data[\"key\"]\n    if 'timeout' in data:\n        timeout = data[\"timeout\"]\n    if 'verbose' in data:\n        verbose = data[\"verbose\"]\n    else:\n        verbose = 0\n    prefer_ipv6 = data[\"prefer_ipv6\"]\n    port = params.port\n    method = params.method\n    fast_open = params.fast_open\n    reuse_port = params.reuse_port\n    no_delay = params.no_delay\n    mptcp = params.mptcp\n    obfs = params.obfs\n    obfs_plugin = params.obfs_plugin\n    obfs_type = params.obfs_type\n    ebpf = 0\n    key = params.key\n    if 'port_key' in data:\n        portkey = data[\"port_key\"]\n        portkey[str(port)] = key\n    if 'port_conf' in data:\n        portconf = data[\"port_conf\"]\n        portconf[str(port)]['key'] = key\n    modif_config_user(current_user.username, {'shadowsocks_port': port})\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n\n    #ipv4_addr = os.popen('wget -4 -qO- -T 2 http://ip.openmptcprouter.com').read().rstrip()\n    if 'hostname' in omr_config_data:\n        vps_domain = omr_config_data['hostname']\n    else:\n        vps_domain = os.popen('wget -4 -qO- -T 1 http://hostname.openmptcprouter.com').read().rstrip()\n        if vps_domain != '':\n            set_global_param('hostname', vps_domain)\n\n    if port is None or method is None or fast_open is None or reuse_port is None or no_delay is None or key is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shadowsocks'}\n    if 'port_key' in data:\n        if ipv6_network == '':\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': '0.0.0.0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n        else:\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '::0', 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_key': portkey, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n    else:\n        if ipv6_network == '':\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': '0.0.0.0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n        else:\n            if obfs:\n                if obfs_plugin == \"v2ray\":\n                    if obfs_type == \"tls\":\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls'}\n                        else:\n                            shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server;tls;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': '::0', 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/v2ray-plugin', 'plugin_opts': 'server'}\n                else:\n                    if obfs_type == 'tls':\n                        if vps_domain == '':\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400'}\n                        else:\n                            shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=tls;mptcp;fast-open;t=400;host=' + vps_domain}\n                    else:\n                        shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl', 'plugin': '/usr/local/bin/obfs-server', 'plugin_opts': 'obfs=http;mptcp;fast-open;t=400'}\n            else:\n                shadowsocks_config = {'server': ('[::0]', '0.0.0.0'), 'port_conf': portconf, 'local_port': 1081, 'mode': 'tcp_and_udp', 'timeout': timeout, 'method': method, 'verbose': verbose, 'ipv6_first': True, 'prefer_ipv6': prefer_ipv6, 'fast_open': fast_open, 'no_delay': no_delay, 'reuse_port': reuse_port, 'mptcp': mptcp, 'ebpf': ebpf, 'acl': '/etc/shadowsocks-libev/local.acl'}\n\n    with open('/etc/shadowsocks-libev/manager.json', 'w') as outfile:\n        json.dump(shadowsocks_config, outfile, indent=4)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/manager.json', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl restart shadowsocks-libev-manager@manager.service\")\n        #for x in range(1, os.cpu_count()):\n        #    os.system(\"systemctl restart shadowsocks-libev-manager@manager\" + str(x) + \".service\")\n        shorewall_add_port(current_user, str(port), 'tcp', 'shadowsocks')\n        shorewall_add_port(current_user, str(port), 'udp', 'shadowsocks')\n        set_lastchange()\n        return {'result': 'done', 'reason': 'changes applied', 'route': 'shadowsocks'}\n    else:\n        return {'result': 'done', 'reason': 'no changes', 'route': 'shadowsocks'}\n\n# Set shorewall config\nclass IPPROTO(str, Enum):\n    ipv4 = \"ipv4\"\n    ipv6 = \"ipv6\"\n\nclass ShorewallAllparams(BaseModel):\n    redirect_ports: str = Query(..., title=\"Port or ports range\")\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP to apply changes\")\n\n@app.post('/shorewall', summary=\"Redirect all ports from Server to router\")\ndef shorewall(*, params: ShorewallAllparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewall'}\n    state = params.redirect_ports\n    if state is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewall'}\n    if params.ipproto == 'ipv4':\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/shorewall/rules', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write('#' + line)\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write('#' + line)\n                else:\n                    n.write(line)\n        os.close(fd)\n        move(tmpfile, '/etc/shorewall/rules')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/rules', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall\")\n    else:\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/shorewall6/rules', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'enable' and line == '#DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write(line.replace(line[:1], ''))\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\ttcp\t1-64999\\n':\n                    n.write('#' + line)\n                elif state == 'disable' and line == 'DNAT\t\tnet\t\tvpn:$OMR_ADDR\tudp\t1-64999\\n':\n                    n.write('#' + line)\n                else:\n                    n.write(line)\n        os.close(fd)\n        move(tmpfile, '/etc/shorewall6/rules')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/rules', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q reload shorewall6\")\n    # Need to do the same for IPv6...\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass ShorewallListparams(BaseModel):\n    name: str\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP to list\")\n\n@app.post('/shorewalllist', summary=\"Display all OpenMPTCProuter rules in Shorewall config\")\ndef shorewall_list(*, params: ShorewallListparams, current_user: User = Depends(get_current_user)):\n    name = params.name\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewalllist'}\n    fwlist = []\n    if params.ipproto == 'ipv4':\n        with open('/etc/shorewall/rules', 'r') as f:\n            for line in f:\n                if '# OMR ' + current_user.username + ' ' + name in line:\n                    fwlist.append(line)\n    else:\n        with open('/etc/shorewall6/rules', 'r') as f:\n            for line in f:\n                if '# OMR ' + current_user.username + ' ' + name in line:\n                    fwlist.append(line)\n    return {'list': fwlist}\n\nclass Shorewallparams(BaseModel):\n    name: str\n    port: str\n    proto: str\n    fwtype: str\n    ipproto: IPPROTO = Query(\"ipv4\", title=\"Protocol IP for changes\")\n    source_dip: str = \"\"\n    source_ip: str = \"\"\n\n@app.post('/shorewallopen', summary=\"Redirect a port from Server to Router\")\ndef shorewall_open(*, params: Shorewallparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewallopen'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    fwtype = params.fwtype\n    source_dip = params.source_dip\n    source_ip = params.source_ip\n    vpn = \"default\"\n    username = current_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewallopen'}\n    #proxy = 'shadowsocks'\n    #if 'proxy' in omr_config_data['users'][0][username]:\n    #    proxy = omr_config_data['users'][0][username]['proxy']\n    #if proxy == 'v2ray':\n    #    v2ray_add_port(current_user, str(port), proto, name)\n    #    fwtype = 'ACCEPT'\n    if params.ipproto == 'ipv4':\n        if 'gre_tunnels' in omr_config_data['users'][0][current_user.username]:\n            for tunnel in omr_config_data['users'][0][current_user.username]['gre_tunnels']:\n                if omr_config_data['users'][0][current_user.username]['gre_tunnels'][tunnel]['public_ip'] == source_dip:\n                    vpn = omr_config_data['users'][0][current_user.username]['gre_tunnels'][tunnel]['remote_ip']\n        shorewall_add_port(current_user, str(port), proto, name, fwtype, source_dip, source_ip, vpn)\n    else:\n        shorewall6_add_port(current_user, str(port), proto, name, fwtype, source_dip, source_ip)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n@app.post('/shorewallclose', summary=\"Remove a redirected port\")\ndef shorewall_close(*, params: Shorewallparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'shorewallclose'}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    fwtype = params.fwtype\n    source_dip = params.source_dip\n    source_ip = params.source_ip\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'shorewallclose'}\n    #v2ray_del_port(current_user.username, str(port), proto, name)\n    if params.ipproto == 'ipv4':\n        shorewall_del_port(current_user.username, str(port), proto, name, 'DNAT', source_dip, source_ip)\n        shorewall_del_port(current_user.username, str(port), proto, name, 'ACCEPT', source_dip, source_ip)\n    else:\n        shorewall6_del_port(current_user.username, str(port), proto, name, 'DNAT', source_dip, source_ip)\n        shorewall6_del_port(current_user.username, str(port), proto, name, 'ACCEPT', source_dip, source_ip)\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'shorewallclose'}\n\nclass V2rayconfig(BaseModel):\n    userid: str\n\n@app.post('/v2ray', summary=\"Set v2ray settings\")\ndef v2ray(*, params: V2rayconfig, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    with open('/etc/v2ray/v2ray-server.json') as f:\n        v2ray_config = json.load(f)\n    v2ruserid = params.userid\n    for inbounds in v2ray_config['inbounds']:\n        if inbounds['tag'] == 'omrin-tunnel':\n            inbounds['settings']['clients'][0]['id'] = v2ruserid\n    with open('/etc/v2ray/v2ray-server.json', 'w') as outfile:\n        json.dump(v2ray_config, outfile, indent=4)\n    username = current_user.username\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/v2ray/v2ray-server.json', 'rb'))).hexdigest()\n    v2ray_key = os.popen('jq -r .inbounds[0].settings.clients[0].id /etc/v2ray/v2ray-server.json').read().rstrip()\n    v2ray_port = os.popen('jq -r .inbounds[0].port /etc/v2ray/v2ray-server.json').read().rstrip()\n    v2ray_conf = { 'key': v2ray_key, 'port': v2ray_port}\n    modif_config_user(username, {'v2ray': v2ray_conf})\n    if initial_md5 != final_md5:\n        os.system(\"systemctl restart v2ray\")\n        set_lastchange()\n        return {'result': 'done', 'reason': 'changes applied', 'route': 'v2ray'}\n    else:\n        return {'result': 'done', 'reason': 'no changes', 'route': 'v2ray'}\n\n\nclass V2rayparams(BaseModel):\n    name: str\n    port: str\n    proto: str\n    destip: str\n    destport: str\n\n@app.post('/v2rayredirect', summary=\"Redirect a port from Server to Router with V2Ray\")\ndef v2ray_redirect(*, params: V2rayparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    destip = params.destip\n    destport = params.destport\n    username = current_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'v2rayredirect'}\n    v2ray_add_port(current_user, port, proto, name, destip, destport)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n@app.post('/v2rayunredirect', summary=\"Remove a redirected port from Server to Router with V2Ray\")\ndef v2ray_unredirect(*, params: V2rayparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'v2rayredirect'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        try:\n            omr_config_data = json.load(f)\n        except ValueError as e:\n            omr_config_data = {}\n    name = params.name\n    port = params.port\n    proto = params.proto\n    username = curent_user.username\n    if name is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'v2rayunredirect'}\n    v2ray_del_port(current_user, port, proto, name)\n    return {'result': 'done', 'reason': 'changes applied'}\n\n# Set MPTCP config\nclass MPTCPparams(BaseModel):\n    checksum: str\n    path_manager: str\n    scheduler: str\n    syn_retries: int\n    congestion_control: str\n\n@app.post('/mptcp', summary=\"Modify MPTCP configuration of the server\")\ndef mptcp(*, params: MPTCPparams, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'mptcp'}\n    checksum = params.checksum\n    path_manager = params.path_manager\n    scheduler = params.scheduler\n    syn_retries = params.syn_retries\n    congestion_control = params.congestion_control\n    if not checksum or not path_manager or not scheduler or not syn_retries or not congestion_control:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'mptcp'}\n    os.system('sysctl -qw net.mptcp.mptcp_checksum=' + checksum)\n    os.system('sysctl -qw net.mptcp.mptcp_path_manager=' + path_manager)\n    os.system('sysctl -qw net.mptcp.mptcp_scheduler=' + scheduler)\n    os.system('sysctl -qw net.mptcp.mptcp_syn_retries=' + str(syn_retries))\n    os.system('sysctl -qw net.ipv4.tcp_congestion_control=' + congestion_control)\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass VPN(str, Enum):\n    openvpn = \"openvpn\"\n    openvpnbonding = \"openvpn_bonding\"\n    glorytuntcp = \"glorytun_tcp\"\n    glorytunudp = \"glorytun_udp\"\n    dsvpn = \"dsvpn\"\n    mlvpn = \"mlvpn\"\n    none = \"none\"\n\nclass Vpn(BaseModel):\n    vpn: VPN\n\n# Set global VPN config\n@app.post('/vpn', summary=\"Set VPN used by the current user\")\ndef vpn(*, vpnconfig: Vpn, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'vpn'}\n    vpn = vpnconfig.vpn\n    if not vpn:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'vpn'}\n    os.system('echo ' + vpn + ' > /etc/openmptcprouter-vps-admin/current-vpn')\n    modif_config_user(current_user.username, {'vpn': vpn})\n    current_user.vpn = vpn\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\nclass PROXY(str, Enum):\n    v2ray = \"v2ray\"\n    shadowsockslibev = \"shadowsocks\"\n    none = \"none\"\n\nclass Proxy(BaseModel):\n    proxy: PROXY\n\n# Set global Proxy config\n@app.post('/proxy', summary=\"Set Proxy used by the current user\")\ndef proxy(*, proxyconfig: Proxy, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'proxy'}\n    proxy = proxyconfig.proxy\n    if not proxy:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'proxy'}\n    os.system('echo ' + proxy + ' > /etc/openmptcprouter-vps-admin/current-proxy')\n    modif_config_user(current_user.username, {'proxy': proxy})\n    #current_user.proxy = proxy\n    set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied'}\n\n\nclass GlorytunConfig(BaseModel):\n    key: str\n    port: int = Query(..., gt=0, lt=65535, title=\"Glorytun TCP and UDP port\")\n    chacha: bool = Query(True, title=\"Enable of disable chacha20, if disable AEGIS is used\")\n\n# Set Glorytun config\n@app.post('/glorytun', summary=\"Modify Glorytun configuration\")\ndef glorytun(*, glorytunconfig: GlorytunConfig, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'glorytun'}\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    key = glorytunconfig.key\n    port = glorytunconfig.port\n    chacha = glorytunconfig.chacha\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-tcp/tun' + str(userid), 'rb'))).hexdigest()\n    with open('/etc/glorytun-tcp/tun' + str(userid) + '.key', 'w') as outfile:\n        outfile.write(key)\n    with open('/etc/glorytun-udp/tun' + str(userid) + '.key', 'w') as outfile:\n        outfile.write(key)\n    fd, tmpfile = mkstemp()\n    with open('/etc/glorytun-tcp/tun' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'PORT=' in line:\n                n.write('PORT=' + str(port) + '\\n')\n            elif 'OPTIONS=' in line:\n                if chacha:\n                    n.write('OPTIONS=\"chacha20 retry count -1 const 5000000 timeout 90000 keepalive count 5 idle 10 interval 2 buffer-size 65536 multiqueue\"\\n')\n                else:\n                    n.write('OPTIONS=\"retry count -1 const 5000000 timeout 90000 keepalive count 5 idle 10 interval 2 buffer-size 65536 multiqueue\"\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/glorytun-tcp/tun' + str(userid))\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-tcp/tun' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart glorytun-tcp@tun\" + str(userid))\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-udp/tun' + str(userid), 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/glorytun-udp/tun' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'BIND_PORT=' in line:\n                n.write('BIND_PORT=' + str(port) + '\\n')\n            elif 'OPTIONS=' in line:\n                if chacha:\n                    n.write('OPTIONS=\"chacha persist\"\\n')\n                else:\n                    n.write('OPTIONS=\"persist\"\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/glorytun-udp/tun' + str(userid))\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/glorytun-udp/tun' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart glorytun-udp@tun\" + str(userid))\n    shorewall_add_port(current_user, str(port), 'tcp', 'glorytun')\n    shorewall_add_port(current_user, str(port), 'udp', 'glorytun')\n    set_lastchange()\n    return {'result': 'done'}\n\n# Set A Dead Simple VPN config\nclass DSVPN(BaseModel):\n    key: str\n    port: int = Query(..., gt=0, lt=65535)\n\n@app.post('/dsvpn', summary=\"Modify DSVPN configuration\")\ndef dsvpn(*, params: DSVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'dsvpn'}\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    key = params.key\n    port = params.port\n    if not key or port is None:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'dsvpn'}\n\n    fd, tmpfile = mkstemp()\n    with open('/etc/dsvpn/dsvpn' + str(userid), 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'PORT=' in line:\n                n.write('PORT=' + str(port) + '\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/dsvpn/dsvpn' + str(userid))\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'rb'))).hexdigest()\n    with open('/etc/dsvpn/dsvpn.key', 'w') as outfile:\n        outfile.write(key)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/dsvpn/dsvpn' + str(userid) + '.key', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart dsvpn-server@dsvpn\" + str(userid))\n    shorewall_add_port(current_user, str(port), 'tcp', 'dsvpn')\n    set_lastchange()\n    return {'result': 'done'}\n\n# Set MLVPN config\nclass MLVPN(BaseModel):\n    timeout: int\n    reorder_buffer_size: int\n    loss_tolerence: int\n    cleartext_data: int\n    password: str\n\n@app.post('/mlvpn', summary=\"Modify MLVPN configuration\")\ndef mlvpn(*, params: MLVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'mlvpn'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/mlvpn/mlvpn0.conf', 'rb'))).hexdigest()\n    mlvpn_config = configparser.ConfigParser()\n    mlvpn_config.read_file(open(r'/etc/mlvpn/mlvpn0.conf'))\n    mlvpn_config.set('general', 'password', '\"' + params.password + '\"')\n    mlvpn_config.set('general', 'timeout',str(params.timeout))\n    mlvpn_config.set('general', 'reorder_buffer_size',str(params.reorder_buffer_size))\n    mlvpn_config.set('general', 'loss_tolerence',str(params.loss_tolerence))\n    mlvpn_config.set('general', 'cleartext_data',str(params.cleartext_data))\n    with open('/etc/mlvpn/mlvpn0.conf','w') as mlvpn_file:\n        mlvpn_config.write(mlvpn_file)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/mlvpn/mlvpn0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart mlvpn@mlvpn0\")\n        set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'mlvpn'}\n\n\n# Set OpenVPN config\nclass OpenVPN(BaseModel):\n    port: int = Query(..., gt=0, lt=65535)\n    cipher: str = \"AES-256-CBC\"\n\n@app.post('/openvpn', summary=\"Modify OpenVPN TCP configuration\")\ndef openvpn(*, params: OpenVPN, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        set_lastchange(10)\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'openvpn'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/openvpn/tun0', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if 'cipher ' in line:\n                n.write('cipher ' + params.cipher + '\\n')\n            elif 'port ' in line:\n                n.write('port ' + str(params.port) + '\\n')\n            else:\n                n.write(line)\n    os.close(fd)\n    move(tmpfile, '/etc/openvpn/tun0')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0', 'rb'))).hexdigest()\n\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart openvpn@tun0\")\n        shorewall_add_port(current_user, str(port), 'tcp', 'openvpn')\n        set_lastchange()\n    return {'result': 'done'}\n\n# Set WireGuard config\nclass WireGuardPeer(BaseModel):\n    ip: str\n    key: str\n\nclass WireGuard(BaseModel):\n    peers: List[WireGuardPeer] = []\n\n@app.post('/wireguard', summary=\"Modify Wireguard configuration\")\ndef wireguard(*, params: WireGuard, current_user: User = Depends(get_current_user)):\n    if not os.path.isfile('/etc/wireguard/wg0.conf'):\n        return {'result': 'error', 'reason': 'Wireguard config not found', 'route': 'wireguard'}\n    wg_config = configparser.ConfigParser(strict=False)\n    wg_config.read_file(open(r'/etc/wireguard/wg0.conf'))\n    wg_port = wg_config.get('Interface', 'ListenPort')\n    wg_key = wg_config.get('Interface', 'PrivateKey')\n\n    fd, tmpfile = mkstemp()\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/wireguard/wg0.conf', 'rb'))).hexdigest()\n    with open(tmpfile, 'a+') as n:\n        n.write('[Interface]\\n')\n        n.write('ListenPort = ' + wg_port + '\\n')\n        n.write('PrivateKey = ' + wg_key + '\\n')\n        for peer in params.peers:\n            n.write('\\n')\n            n.write('[Peer]\\n')\n            n.write('PublicKey  = ' + peer.key + '\\n')\n            n.write('AllowedIPs = ' + peer.ip + '\\n')\n    move(tmpfile, '/etc/wireguard/wg0.conf')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/wireguard/wg0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"wg setconf wg0 /etc/wireguard/wg0.conf\")\n        shorewall_add_port(current_user, str(wg_port), 'udp', 'wireguard')\n        set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'wireguard'}\n\n\nclass Wanips(BaseModel):\n    ips: str\n\n# Set WANIP\n@app.post('/wan', summary=\"Set WAN IPs\")\ndef wan(*, wanips: Wanips, current_user: User = Depends(get_current_user)):\n    ips = wanips.ips\n    if not ips:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'wan'}\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/local.acl', 'rb'))).hexdigest()\n    with open('/etc/shadowsocks-libev/local.acl', 'w') as outfile:\n        outfile.write('[white_list]\\n')\n        outfile.write(ips)\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shadowsocks-libev/local.acl', 'rb'))).hexdigest()\n    #modif_config_user(current_user.username,{'wanips': wanip})\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'wan'}\n\nclass Lanips(BaseModel):\n    lanips: List[str] = []\n\n# Set user lan config\n@app.post('/lan', summary=\"Set current user LAN IPs\")\ndef lan(*, lanconfig: Lanips, current_user: User = Depends(get_current_user)):\n    lanips = lanconfig.lanips\n    if not lanips:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'lan'}\n    modif_config_user(current_user.username, {'lanips': lanips})\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        omr_config_data = json.load(f)\n    client2client = False\n    if 'client2client' in omr_config_data:\n        client2client = omr_config_data[\"client2client\"]\n    if client2client == True:\n        with open('/etc/openvpn/ccd/' + current_user.username, 'w') as outfile:\n            for lan in lanips:\n                ip = IPNetwork(lan)\n                outfile.write('iroute ' + str(ip.network) + ' ' + str(ip.netmask) + \"\\n\")\n                #outfile.write('route ' + str(ip.network) + ' ' + str(ip.netmask) + \"\\n\")\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n        fd, tmpfile = mkstemp()\n        with open('/etc/openvpn/tun0.conf', 'r') as f, open(tmpfile, 'a+') as n:\n            for line in f:\n                if not 'push \"route ' + str(ip.network) + ' ' + str(ip.netmask) + '\"' in line:\n                    n.write(line)\n            n.write('push \"route ' + str(ip.network) + ' ' + str(ip.netmask) + '\"' + \"\\n\")\n        os.close(fd)\n        move(tmpfile, '/etc/openvpn/tun0.conf')\n        final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n        if initial_md5 != final_md5:\n            os.system(\"systemctl -q restart openvpn@tun0\")\n            set_lastchange()\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'lan'}\n\nclass VPNips(BaseModel):\n    remoteip: str = Query(..., regex='^(10(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){3}|((172\\.(1[6-9]|2[0-9]|3[01]))|192\\.168)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){2})$')\n    localip: str = Query(..., regex='^(10(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){3}|((172\\.(1[6-9]|2[0-9]|3[01]))|192\\.168)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{1,2}|[0-9]{1,2})){2})$')\n    remoteip6: Optional[str] = Query(None, regex='(?:^|(?<=\\s))(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\\s|$)')\n    localip6: Optional[str] = Query(None, regex='(?:^|(?<=\\s))(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\\s|$)')\n    ula: Optional[str] = None\n\n# Set user vpn IPs\n@app.post('/vpnips', summary=\"Set current user VPN IPs\")\ndef vpnips(*, vpnconfig: VPNips, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'vpnips'}\n    remoteip = vpnconfig.remoteip\n    localip = vpnconfig.localip\n    remoteip6 = vpnconfig.remoteip6\n    localip6 = vpnconfig.localip6\n    ula = vpnconfig.ula\n    if not remoteip or not localip:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'vpnips'}\n    modif_config_user(current_user.username, {'vpnremoteip': remoteip})\n    modif_config_user(current_user.username, {'vpnlocalip': localip})\n    if ula:\n        modif_config_user(current_user.username, {'ula': ula})\n    userid = current_user.userid\n    if userid is None:\n        userid = 0\n    if os.path.isfile('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid)):\n        initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'rb'))).hexdigest()\n    else:\n        initial_md5 = ''\n    with open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'w+') as n:\n        n.write('LOCALIP=' + localip + \"\\n\")\n        n.write('REMOTEIP=' + remoteip + \"\\n\")\n        if localip6:\n            n.write('LOCALIP6=' + localip6 + \"\\n\")\n        else:\n            n.write('LOCALIP6=fe80::a0' + hex(userid)[2:] + ':1/126' + \"\\n\")\n        if remoteip6:\n            n.write('REMOTEIP6=' + remoteip6 + \"\\n\")\n        else:\n            n.write('REMOTEIP6=fe80::a0' + hex(userid)[2:] + ':2/126' + \"\\n\")\n        if ula:\n            n.write('ULA=' + ula + \"\\n\")\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openmptcprouter-vps-admin/omr-6in4/user' + str(userid), 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart omr6in4@user\" + str(userid))\n        set_lastchange()\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/params.vpn', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/params.vpn', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not ('OMR_ADDR_USER' + str(userid) +'=' in line and not userid == 0) and not ('OMR_ADDR=' in line and userid == 0):\n                n.write(line)\n        if not userid == 0:\n            n.write('OMR_ADDR_USER' + str(userid) + '=' + remoteip + '\\n')\n        elif userid == 0:\n            n.write('OMR_ADDR=' + remoteip + '\\n')\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/params.vpn')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/params.vpn', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n        set_lastchange()\n\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/params.vpn', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall6/params.vpn', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not ('OMR_ADDR_USER' + str(userid) +'=' in line and not userid == 0) and not ('OMR_ADDR=' in line and userid == 0):\n                n.write(line)\n        if  not userid == 0:\n            n.write('OMR_ADDR_USER' + str(userid) + '=fe80::a0' + hex(userid)[2:] + ':2/126' + '\\n')\n        elif userid == 0:\n            n.write('OMR_ADDR=fe80::a0' + hex(userid)[2:] + ':2/126' + '\\n')\n\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall6/params.vpn')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall6/params.vpn', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall6\")\n        set_lastchange()\n\n    return {'result': 'done', 'reason': 'changes applied', 'route': 'vpnips'}\n\n# Update VPS\n@app.get('/update', summary=\"Update VPS script\")\ndef update(current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'update'}\n    LOG.debug(\"Update VPS...\")\n    os.system(\"systemctl stop omr\")\n    os.system(\"wget -O - http://www.openmptcprouter.com/server/debian10-x86_64.sh | sh &\")\n    LOG.debug(\"Update VPS... done\")\n    os.system(\"/sbin/reboot\")\n    return {'result': 'done', 'route': 'update'}\n\n# Backup\nclass Backupfile(BaseModel):\n    data: str = Query(..., title=\"OpenMPTCProuter backup file in tar.gz encoded in base64\")\n\n@app.post('/backuppost', summary=\"Send current user router backup file\")\ndef backuppost(*, backupfile: Backupfile, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'backuppost'}\n    backup_file = backupfile.data\n    if not backup_file:\n        return {'result': 'error', 'reason': 'Invalid parameters', 'route': 'backuppost'}\n    with open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz', 'wb') as f:\n        f.write(base64.b64decode(backup_file))\n    return {'result': 'done', 'route': 'backuppost'}\n\n@app.get('/backupget', summary=\"Get current user router backup file\")\ndef send_backup(current_user: User = Depends(get_current_user)):\n    with open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz', \"rb\") as backup_file:\n        file_base64 = base64.b64encode(backup_file.read())\n        file_base64utf = file_base64.decode('utf-8')\n    return {'data': file_base64utf}\n\n@app.get('/backuplist', summary=\"List available current user backup\")\ndef list_backup(current_user: User = Depends(get_current_user)):\n    if os.path.isfile('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'):\n        modiftime = os.path.getmtime('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz')\n        return {'backup': True, 'modif': modiftime}\n    else:\n        return {'backup': False}\n\n@app.get('/backupshow', summary=\"Show current user backup\")\ndef show_backup(current_user: User = Depends(get_current_user)):\n    if os.path.isfile('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'):\n        router = OpenWrt(native=open('/var/opt/openmptcprouter/' + current_user.username + '-backup.tar.gz'))\n        return {'backup': True, 'data': router}\n    else:\n        return {'backup': False}\n\n@app.post('/backupedit', summary=\"Modify current user backup\")\ndef edit_backup(params, current_user: User = Depends(get_current_user)):\n    if current_user.permissions == \"ro\":\n        return {'result': 'permission', 'reason': 'Read only user', 'route': 'backupedit'}\n    o = OpenWrt(params)\n    o.write(current_user.username + '-backup', path='/var/opt/openmptcprouter/')\n    return {'result': 'done'}\n\n#class VPN(str, Enum):\n#    openvpn = \"openvpn\"\n#    glorytuntcp = \"glorytun_tcp\"\n#    glorytunudp = \"glorytun_udp\"\n#    dsvpn = \"dsvpn\"\n\nclass permissions(str, Enum):\n    ro = \"ro\"\n    rw = \"rw\"\n    admin = \"admin\"\n\nclass NewUser(BaseModel):\n    username: str = Query(..., title=\"Username\")\n    permission: permissions = Query(\"ro\", title=\"permission of the user\")\n    vpn: VPN = Query(\"openvpn\", title=\"default VPN for the user\")\n    shadowsocks_port: Optional[int] = Query(None, gt=0, lt=65535, title=\"Shadowsocks port\")\n    userid: Optional[int] = Query(None, title=\"User ID\")\n    ips: Optional[List[str]] = Query(None, title=\"Public exit IP\")\n#    userid: int = Query(0, title=\"User ID\",description=\"User ID is used to create port of each VPN and shadowsocks\",gt=0,le=99)\n\n@app.post('/add_user', summary=\"Add a new user\")\ndef add_user(*, params: NewUser, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'add_user'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    userid = params.userid\n    if userid is None or userid == 0:\n        userid = 2\n        for users in content['users'][0]:\n            if 'userid' in content['users'][0][users]:\n                if int(content['users'][0][users]['userid']) > userid:\n                    userid = int(content['users'][0][users]['userid'])\n        userid = userid + 1\n    if params.ips is None:\n        publicips = []\n    else:\n        publicips = params.ips\n    user_key = secrets.token_hex(32)\n    user_json = json.loads('{\"'+ params.username + '\": {\"username\":\"'+ params.username +'\",\"permissions\":\"'+params.permission+'\",\"user_password\": \"'+user_key.upper()+'\",\"disabled\":\"false\",\"userid\":\"' + str(userid) + '\",\"public_ips\":'+ json.dumps(publicips) +'}}')\n#    shadowsocks_port = params.shadowsocks_port\n#    if params.shadowsocks_port is None:\n#    shadowsocks_port = '651{:02d}'.format(userid)\n    shadowsocks_port = params.shadowsocks_port\n    shadowsocks_key = base64.urlsafe_b64encode(secrets.token_hex(16).encode())\n    if not publicips:\n        shadowsocks_port = add_ss_user(str(shadowsocks_port), shadowsocks_key.decode('utf-8'), userid)\n    else:\n        for publicip in publicips:\n            shadowsocks_port = add_ss_user(str(shadowsocks_port), shadowsocks_key.decode('utf-8'), userid, publicip)\n            shadowsocks_port = shadowsocks_port + 1\n    user_json[params.username].update({\"shadowsocks_port\": shadowsocks_port})\n    if params.vpn is not None:\n        user_json[params.username].update({\"vpn\": params.vpn})\n    content['users'][0].update(user_json)\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for add_user\")\n    # Create VPNs configuration\n    os.system('cd /etc/openvpn/ca && EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full \"' + params.username + '\" nopass')\n    add_glorytun_tcp(userid)\n    add_glorytun_udp(userid)\n    add_dsvpn(userid)\n\n    set_lastchange(30)\n    os.execv(__file__, sys.argv)\n\nclass RemoveUser(BaseModel):\n    username: str\n\n@app.post('/remove_user', summary=\"Remove an user\")\ndef remove_user(*, params: RemoveUser, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'remove_user'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    shadowsocks_port = content['users'][0][params.username]['shadowsocks_port']\n    userid = int(content['users'][0][params.username]['userid'])\n    del content['users'][0][params.username]\n    remove_ss_user(str(shadowsocks_port))\n    if content:\n        with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json', 'w') as f:\n            json.dump(content, f, indent=4)\n    else:\n        LOG.debug(\"Empty data for remover_user\")\n    os.system('cd /etc/openvpn/ca && ./easyrsa --batch revoke ' + params.username)\n    os.system('cd /etc/openvpn/ca && ./easyrsa gen-crl')\n    os.system(\"systemctl -q restart openvpn@tun0\")\n    remove_glorytun_tcp(userid)\n    remove_glorytun_udp(userid)\n    remove_dsvpn(userid)\n\n    set_lastchange(30)\n    os.execv(__file__, sys.argv)\n\nclass ClienttoClient(BaseModel):\n    enable: bool = False\n\n@app.post('/client2client', summary=\"Enable client 2 client communications\")\ndef client2client(*, params: ClienttoClient, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'client2client'}\n    set_global_param('client2client', params.enable)\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/openvpn/tun0.conf', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not 'client-to-client' in line:\n                n.write(line)\n        if params.enable == True:\n            n.write('client-to-client' + \"\\n\")\n    os.close(fd)\n    move(tmpfile, '/etc/openvpn/tun0.conf')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/openvpn/tun0.conf', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q restart openvpn@tun0\")\n    initial_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/policy', 'rb'))).hexdigest()\n    fd, tmpfile = mkstemp()\n    with open('/etc/shorewall/policy', 'r') as f, open(tmpfile, 'a+') as n:\n        for line in f:\n            if not line == 'vpn\t\tvpn\t\tDROP\\n' and not line == '# THE FOLLOWING POLICY MUST BE LAST\\n' and not line == 'all\t\tall\t\tREJECT\t\tinfo\\n':\n                n.write(line)\n        if params.enable == False:\n            n.write('vpn\t\tvpn\t\tDROP\\n')\n        n.write('# THE FOLLOWING POLICY MUST BE LAST\\n')\n        n.write('all\t\tall\t\tREJECT\t\tinfo\\n')\n    os.close(fd)\n    move(tmpfile, '/etc/shorewall/policy')\n    final_md5 = hashlib.md5(file_as_bytes(open('/etc/shorewall/policy', 'rb'))).hexdigest()\n    if initial_md5 != final_md5:\n        os.system(\"systemctl -q reload shorewall\")\n    return {'result': 'done'}\n\nclass SerialEnforce(BaseModel):\n    enable: bool = False\n\n@app.post('/serialenforce', summary=\"Enable client serial number control\")\ndef serialenforce(*, params: SerialEnforce, current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'serialenforce'}\n    set_global_param('serial_enforce', params.enable)\n    return {'result': 'done'}\n\n@app.get('/list_users', summary=\"List all users\")\nasync def list_users(current_user: User = Depends(get_current_user)):\n    if not current_user.permissions == \"admin\":\n        return {'result': 'permission', 'reason': 'Need admin user', 'route': 'list_users'}\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        content = json.load(f)\n    return content['users'][0]\n\n@app.get('/speedtest', summary=\"Test speed from the server\")\nasync def list_users(current_user: User = Depends(get_current_user)):\n    return FileResponse('/usr/share/omr-server/speedtest/test.img')\n\n\n\ndef main(omrport: int, omrhost: str):\n    LOG.debug(\"Main OMR-Admin launch\")\n    uvicorn.run(app, host=omrhost, port=omrport, log_level='error', ssl_certfile='/etc/openmptcprouter-vps-admin/cert.pem', ssl_keyfile='/etc/openmptcprouter-vps-admin/key.pem', ssl_version=5)\n\nif __name__ == '__main__':\n    with open('/etc/openmptcprouter-vps-admin/omr-admin-config.json') as f:\n        omr_config_data = json.load(f)\n    omrport = 65500\n    if 'port' in omr_config_data:\n        omrport = omr_config_data[\"port\"]\n    omrhost = '0.0.0.0'\n    if 'host' in omr_config_data:\n        omrhost = omr_config_data[\"host\"]\n    parser = argparse.ArgumentParser(description=\"OpenMPTCProuter Server API\")\n    parser.add_argument(\"--port\", type=int, help=\"Listening port\", default=omrport)\n    parser.add_argument(\"--host\", type=str, help=\"Listening host\", default=omrhost)\n    args = parser.parse_args()\n    main(args.port, args.host)\n"], "filenames": ["omr-admin.py"], "buggy_code_start_loc": [779], "buggy_code_end_loc": [780], "fixing_code_start_loc": [779], "fixing_code_end_loc": [780], "type": "CWE-287", "message": "omr-admin.py in openmptcprouter-vps-admin 0.57.3 and earlier compares the user provided password with the original password in a length dependent manner, which allows remote attackers to guess the password via a timing attack.", "other": {"cve": {"id": "CVE-2021-31245", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-06T13:15:12.607", "lastModified": "2021-05-13T19:13:43.927", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "omr-admin.py in openmptcprouter-vps-admin 0.57.3 and earlier compares the user provided password with the original password in a length dependent manner, which allows remote attackers to guess the password via a timing attack."}, {"lang": "es", "value": "omr-admin.py en openmptcprouter-vps-admin versiones 0.57.3 y anteriores compara la contrase\u00f1a proporcionada por el usuario con la contrase\u00f1a original de una manera dependiente de la longitud, lo cual permite a atacantes remotos adivinar la contrase\u00f1a por medio de un ataque de sincronizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openmptcprouter:openmptcprouter:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.57.3", "matchCriteriaId": "36EFDA32-B68E-4E5A-9CB9-275FB3565E7E"}]}]}], "references": [{"url": "https://github.com/Ysurac/openmptcprouter-vps-admin", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Ysurac/openmptcprouter-vps-admin/commit/a01cbc8c3d3b8bb7720bf3ff234671b4c0e1859c#diff-b89ee68e63302a732d4bde35eb04a205b06f1611147e139642356f173195ab80", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://medium.com/d3crypt/timing-attack-on-openmptcprouter-vps-admin-authentication-cve-2021-31245-12dd92303e1", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.openmptcprouter.com/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Ysurac/openmptcprouter-vps-admin/commit/a01cbc8c3d3b8bb7720bf3ff234671b4c0e1859c#diff-b89ee68e63302a732d4bde35eb04a205b06f1611147e139642356f173195ab80"}}