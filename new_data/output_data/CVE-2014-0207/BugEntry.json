{"buggy_code": ["/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: cdf.c,v 1.54 2014/02/25 20:52:02 christos Exp $\")\n#endif\n\n#include <assert.h>\n#ifdef CDF_DEBUG\n#include <err.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#ifndef EFTYPE\n#define EFTYPE EINVAL\n#endif\n\n#include \"cdf.h\"\n\n#ifdef CDF_DEBUG\n#define DPRINTF(a) printf a, fflush(stdout)\n#else\n#define DPRINTF(a)\n#endif\n\nstatic union {\n\tchar s[4];\n\tuint32_t u;\n} cdf_bo;\n\n#define NEED_SWAP\t(cdf_bo.u == (uint32_t)0x01020304)\n\n#define CDF_TOLE8(x)\t((uint64_t)(NEED_SWAP ? _cdf_tole8(x) : (uint64_t)(x)))\n#define CDF_TOLE4(x)\t((uint32_t)(NEED_SWAP ? _cdf_tole4(x) : (uint32_t)(x)))\n#define CDF_TOLE2(x)\t((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))\n#define CDF_GETUINT32(x, y)\tcdf_getuint32(x, y)\n\n\n/*\n * swap a short\n */\nstatic uint16_t\n_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nstatic uint32_t\n_cdf_tole4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nstatic uint64_t\n_cdf_tole8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n\treturn rv;\n}\n\n/*\n * grab a uint32_t from a possibly unaligned address, and return it in\n * the native host order.\n */\nstatic uint32_t\ncdf_getuint32(const uint8_t *p, size_t offs)\n{\n\tuint32_t rv;\n\t(void)memcpy(&rv, p + offs * sizeof(uint32_t), sizeof(rv));\n\treturn CDF_TOLE4(rv);\n}\n\n#define CDF_UNPACK(a)\t\\\n    (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)\n#define CDF_UNPACKA(a)\t\\\n    (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)\n\nuint16_t\ncdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}\n\nuint32_t\ncdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}\n\nuint64_t\ncdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}\n\nvoid\ncdf_swap_header(cdf_header_t *h)\n{\n\tsize_t i;\n\n\th->h_magic = CDF_TOLE8(h->h_magic);\n\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n\th->h_revision = CDF_TOLE2(h->h_revision);\n\th->h_version = CDF_TOLE2(h->h_version);\n\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n\th->h_min_size_standard_stream =\n\t    CDF_TOLE4(h->h_min_size_standard_stream);\n\th->h_secid_first_sector_in_short_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_short_sat);\n\th->h_num_sectors_in_short_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n\th->h_secid_first_sector_in_master_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_master_sat);\n\th->h_num_sectors_in_master_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\th->h_master_sat[i] = CDF_TOLE4((uint32_t)h->h_master_sat[i]);\n}\n\nvoid\ncdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}\n\nvoid\ncdf_swap_dir(cdf_directory_t *d)\n{\n\td->d_namelen = CDF_TOLE2(d->d_namelen);\n\td->d_left_child = CDF_TOLE4((uint32_t)d->d_left_child);\n\td->d_right_child = CDF_TOLE4((uint32_t)d->d_right_child);\n\td->d_storage = CDF_TOLE4((uint32_t)d->d_storage);\n\td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);\n\td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);\n\td->d_flags = CDF_TOLE4(d->d_flags);\n\td->d_created = CDF_TOLE8((uint64_t)d->d_created);\n\td->d_modified = CDF_TOLE8((uint64_t)d->d_modified);\n\td->d_stream_first_sector = CDF_TOLE4((uint32_t)d->d_stream_first_sector);\n\td->d_size = CDF_TOLE4(d->d_size);\n}\n\nvoid\ncdf_swap_class(cdf_classid_t *d)\n{\n\td->cl_dword = CDF_TOLE4(d->cl_dword);\n\td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);\n\td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);\n}\n\nvoid\ncdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}\n\nstatic int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nstatic ssize_t\ncdf_read(const cdf_info_t *info, off_t off, void *buf, size_t len)\n{\n\tsize_t siz = (size_t)off + len;\n\n\tif ((off_t)(off + len) != (off_t)siz) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (info->i_buf != NULL && info->i_len >= siz) {\n\t\t(void)memcpy(buf, &info->i_buf[off], len);\n\t\treturn (ssize_t)len;\n\t}\n\n\tif (info->i_fd == -1)\n\t\treturn -1;\n\n\tif (pread(info->i_fd, buf, len, off) != (ssize_t)len)\n\t\treturn -1;\n\n\treturn (ssize_t)len;\n}\n\nint\ncdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nssize_t\ncdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos = CDF_SEC_POS(h, id);\n\tassert(ss == len);\n\treturn cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);\n}\n\nssize_t\ncdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}\n\n/*\n * Read the sector allocation table.\n */\nint\ncdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)\n{\n\tsize_t i, j, k;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t *msa, mid, sec;\n\tsize_t nsatpersec = (ss / sizeof(mid)) - 1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\n#define CDF_SEC_LIMIT (UINT32_MAX / (4 * ss))\n\tif ((nsatpersec > 0 &&\n\t    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||\n\t    i > CDF_SEC_LIMIT) {\n\t\tDPRINTF((\"Number of sectors in master SAT too big %u %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", h->h_num_sectors_in_master_sat, i));\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tsat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i;\n\tDPRINTF((\"sat_len = %\" SIZE_T_FORMAT \"u ss = %\" SIZE_T_FORMAT \"u\\n\",\n\t    sat->sat_len, ss));\n\tif ((sat->sat_tab = CAST(cdf_secid_t *, calloc(sat->sat_len, ss)))\n\t    == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] < 0)\n\t\t\tbreak;\n\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t    h->h_master_sat[i]) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading sector %d\", h->h_master_sat[i]));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((msa = CAST(cdf_secid_t *, calloc(1, ss))) == NULL)\n\t\tgoto out1;\n\n\tmid = h->h_secid_first_sector_in_master_sat;\n\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n\t\tif (mid < 0)\n\t\t\tgoto out;\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Reading master sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out2;\n\t\t}\n\t\tif (cdf_read_sector(info, msa, 0, ss, h, mid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading master sector %d\", mid));\n\t\t\tgoto out2;\n\t\t}\n\t\tfor (k = 0; k < nsatpersec; k++, i++) {\n\t\t\tsec = CDF_TOLE4((uint32_t)msa[k]);\n\t\t\tif (sec < 0)\n\t\t\t\tgoto out;\n\t\t\tif (i >= sat->sat_len) {\n\t\t\t    DPRINTF((\"Out of bounds reading MSA %\" SIZE_T_FORMAT\n\t\t\t\t\"u >= %\" SIZE_T_FORMAT \"u\", i, sat->sat_len));\n\t\t\t    errno = EFTYPE;\n\t\t\t    goto out2;\n\t\t\t}\n\t\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t\t    sec) != (ssize_t)ss) {\n\t\t\t\tDPRINTF((\"Reading sector %d\",\n\t\t\t\t    CDF_TOLE4(msa[k])));\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\t\tmid = CDF_TOLE4((uint32_t)msa[nsatpersec]);\n\t}\nout:\n\tsat->sat_len = i;\n\tfree(msa);\n\treturn 0;\nout2:\n\tfree(msa);\nout1:\n\tfree(sat->sat_tab);\n\treturn -1;\n}\n\nsize_t\ncdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n\n\tDPRINTF((\"Chain:\"));\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}\n\nint\ncdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = len;\n\n\tif (scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != (ssize_t)ss) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\t/* Last sector might be truncated */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n\nint\ncdf_read_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\n\tif (len < h->h_min_size_standard_stream && sst->sst_tab != NULL)\n\t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,\n\t\t    scn);\n\telse\n\t\treturn cdf_read_long_sector_chain(info, h, sat, sid, len, scn);\n}\n\nint\ncdf_read_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n\tchar *buf;\n\tcdf_secid_t sid = h->h_secid_first_directory;\n\n\tns = cdf_count_chain(sat, sid, ss);\n\tif (ns == (size_t)-1)\n\t\treturn -1;\n\n\tnd = ss / CDF_DIRECTORY_SIZE;\n\n\tdir->dir_len = ns * nd;\n\tdir->dir_tab = CAST(cdf_directory_t *,\n\t    calloc(dir->dir_len, sizeof(dir->dir_tab[0])));\n\tif (dir->dir_tab == NULL)\n\t\treturn -1;\n\n\tif ((buf = CAST(char *, malloc(ss))) == NULL) {\n\t\tfree(dir->dir_tab);\n\t\treturn -1;\n\t}\n\n\tfor (j = i = 0; i < ns; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read dir loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, buf, 0, ss, h, sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading directory sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < nd; j++) {\n\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (NEED_SWAP)\n\t\tfor (i = 0; i < dir->dir_len; i++)\n\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n\tfree(buf);\n\treturn 0;\nout:\n\tfree(dir->dir_tab);\n\tfree(buf);\n\treturn -1;\n}\n\n\nint\ncdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\n\tssat->sat_len = cdf_count_chain(sat, sid, CDF_SEC_SIZE(h));\n\tif (ssat->sat_len == (size_t)-1)\n\t\treturn -1;\n\n\tssat->sat_tab = CAST(cdf_secid_t *, calloc(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    ssat->sat_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}\n\nstatic int\ncdf_namecmp(const char *d, const uint16_t *s, size_t l)\n{\n\tfor (; l--; d++, s++)\n\t\tif (*d != CDF_TOLE2(*s))\n\t\t\treturn (unsigned char)*d - CDF_TOLE2(*s);\n\treturn 0;\n}\n\nint\ncdf_read_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tstatic const char name[] = \"\\05SummaryInformation\";\n\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, sizeof(name))\n\t\t    == 0)\n\t\t\tbreak;\n\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find summary information section\\n\"));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}\n\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nint\ncdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)\n{\n\treturn snprintf(buf, buflen, \"%.8x-%.4x-%.4x-%.2x%.2x-\"\n\t    \"%.2x%.2x%.2x%.2x%.2x%.2x\", id->cl_dword, id->cl_word[0],\n\t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],\n\t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],\n\t    id->cl_six[5]);\n}\n\nstatic const struct {\n\tuint32_t v;\n\tconst char *n;\n} vn[] = {\n\t{ CDF_PROPERTY_CODE_PAGE, \"Code page\" },\n\t{ CDF_PROPERTY_TITLE, \"Title\" },\n\t{ CDF_PROPERTY_SUBJECT, \"Subject\" },\n\t{ CDF_PROPERTY_AUTHOR, \"Author\" },\n\t{ CDF_PROPERTY_KEYWORDS, \"Keywords\" },\n\t{ CDF_PROPERTY_COMMENTS, \"Comments\" },\n\t{ CDF_PROPERTY_TEMPLATE, \"Template\" },\n\t{ CDF_PROPERTY_LAST_SAVED_BY, \"Last Saved By\" },\n\t{ CDF_PROPERTY_REVISION_NUMBER, \"Revision Number\" },\n\t{ CDF_PROPERTY_TOTAL_EDITING_TIME, \"Total Editing Time\" },\n\t{ CDF_PROPERTY_LAST_PRINTED, \"Last Printed\" },\n\t{ CDF_PROPERTY_CREATE_TIME, \"Create Time/Date\" },\n\t{ CDF_PROPERTY_LAST_SAVED_TIME, \"Last Saved Time/Date\" },\n\t{ CDF_PROPERTY_NUMBER_OF_PAGES, \"Number of Pages\" },\n\t{ CDF_PROPERTY_NUMBER_OF_WORDS, \"Number of Words\" },\n\t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, \"Number of Characters\" },\n\t{ CDF_PROPERTY_THUMBNAIL, \"Thumbnail\" },\n\t{ CDF_PROPERTY_NAME_OF_APPLICATION, \"Name of Creating Application\" },\n\t{ CDF_PROPERTY_SECURITY, \"Security\" },\n\t{ CDF_PROPERTY_LOCALE_ID, \"Locale ID\" },\n};\n\nint\ncdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"0x%x\", p);\n}\n\nint\ncdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)\n{\n\tint len = 0;\n\tint days, hours, mins, secs;\n\n\tts /= CDF_TIME_PREC;\n\tsecs = (int)(ts % 60);\n\tts /= 60;\n\tmins = (int)(ts % 60);\n\tts /= 60;\n\thours = (int)(ts % 24);\n\tts /= 24;\n\tdays = (int)ts;\n\n\tif (days) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%dd+\", days);\n\t\tif ((size_t)len >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tif (days || hours) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", hours);\n\t\tif ((size_t)len >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", mins);\n\tif ((size_t)len >= bufsiz)\n\t\treturn len;\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d\", secs);\n\treturn len;\n}\n\n\n#ifdef CDF_DEBUG\nvoid\ncdf_dump_header(const cdf_header_t *h)\n{\n\tsize_t i;\n\n#define DUMP(a, b) (void)fprintf(stderr, \"%40.40s = \" a \"\\n\", # b, h->h_ ## b)\n#define DUMP2(a, b) (void)fprintf(stderr, \"%40.40s = \" a \" (\" a \")\\n\", # b, \\\n    h->h_ ## b, 1 << h->h_ ## b)\n\tDUMP(\"%d\", revision);\n\tDUMP(\"%d\", version);\n\tDUMP(\"0x%x\", byte_order);\n\tDUMP2(\"%d\", sec_size_p2);\n\tDUMP2(\"%d\", short_sec_size_p2);\n\tDUMP(\"%d\", num_sectors_in_sat);\n\tDUMP(\"%d\", secid_first_directory);\n\tDUMP(\"%d\", min_size_standard_stream);\n\tDUMP(\"%d\", secid_first_sector_in_short_sat);\n\tDUMP(\"%d\", num_sectors_in_short_sat);\n\tDUMP(\"%d\", secid_first_sector_in_master_sat);\n\tDUMP(\"%d\", num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\t\t(void)fprintf(stderr, \"%35.35s[%.3zu] = %d\\n\",\n\t\t    \"master_sat\", i, h->h_master_sat[i]);\n\t}\n}\n\nvoid\ncdf_dump_sat(const char *prefix, const cdf_sat_t *sat, size_t size)\n{\n\tsize_t i, j, s = size / sizeof(cdf_secid_t);\n\n\tfor (i = 0; i < sat->sat_len; i++) {\n\t\t(void)fprintf(stderr, \"%s[%\" SIZE_T_FORMAT \"u]:\\n%.6\"\n\t\t    SIZE_T_FORMAT \"u: \", prefix, i, i * s);\n\t\tfor (j = 0; j < s; j++) {\n\t\t\t(void)fprintf(stderr, \"%5d, \",\n\t\t\t    CDF_TOLE4(sat->sat_tab[s * i + j]));\n\t\t\tif ((j + 1) % 10 == 0)\n\t\t\t\t(void)fprintf(stderr, \"\\n%.6\" SIZE_T_FORMAT\n\t\t\t\t    \"u: \", i * s + j + 1);\n\t\t}\n\t\t(void)fprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\ncdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}\n\nvoid\ncdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}\n\nvoid\ncdf_dump_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tcdf_stream_t scn;\n\tstruct timespec ts;\n\n\tstatic const char *types[] = { \"empty\", \"user storage\",\n\t    \"user stream\", \"lockbytes\", \"property\", \"root storage\" };\n\n\tfor (i = 0; i < dir->dir_len; i++) {\n\t\tchar buf[26];\n\t\td = &dir->dir_tab[i];\n\t\tfor (j = 0; j < sizeof(name); j++)\n\t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);\n\t\t(void)fprintf(stderr, \"Directory %\" SIZE_T_FORMAT \"u: %s\\n\",\n\t\t    i, name);\n\t\tif (d->d_type < __arraycount(types))\n\t\t\t(void)fprintf(stderr, \"Type: %s\\n\", types[d->d_type]);\n\t\telse\n\t\t\t(void)fprintf(stderr, \"Type: %d\\n\", d->d_type);\n\t\t(void)fprintf(stderr, \"Color: %s\\n\",\n\t\t    d->d_color ? \"black\" : \"red\");\n\t\t(void)fprintf(stderr, \"Left child: %d\\n\", d->d_left_child);\n\t\t(void)fprintf(stderr, \"Right child: %d\\n\", d->d_right_child);\n\t\t(void)fprintf(stderr, \"Flags: 0x%x\\n\", d->d_flags);\n\t\tcdf_timestamp_to_timespec(&ts, d->d_created);\n\t\t(void)fprintf(stderr, \"Created %s\", cdf_ctime(&ts.tv_sec, buf));\n\t\tcdf_timestamp_to_timespec(&ts, d->d_modified);\n\t\t(void)fprintf(stderr, \"Modified %s\",\n\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t(void)fprintf(stderr, \"Stream %d\\n\", d->d_stream_first_sector);\n\t\t(void)fprintf(stderr, \"Size %d\\n\", d->d_size);\n\t\tswitch (d->d_type) {\n\t\tcase CDF_DIR_TYPE_USER_STORAGE:\n\t\t\t(void)fprintf(stderr, \"Storage: %d\\n\", d->d_storage);\n\t\t\tbreak;\n\t\tcase CDF_DIR_TYPE_USER_STREAM:\n\t\t\tif (sst == NULL)\n\t\t\t\tbreak;\n\t\t\tif (cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {\n\t\t\t\twarn(\"Can't read stream for %s at %d len %d\",\n\t\t\t\t    name, d->d_stream_first_sector, d->d_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcdf_dump_stream(h, &scn);\n\t\t\tfree(scn.sst_tab);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\nvoid\ncdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n{\n\tcdf_timestamp_t tp;\n\tstruct timespec ts;\n\tchar buf[64];\n\tsize_t i, j;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n\t\t(void)fprintf(stderr, \"%\" SIZE_T_FORMAT \"u) %s: \", i, buf);\n\t\tswitch (info[i].pi_type) {\n\t\tcase CDF_NULL:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\t(void)fprintf(stderr, \"signed 16 [%hd]\\n\",\n\t\t\t    info[i].pi_s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\t(void)fprintf(stderr, \"signed 32 [%d]\\n\",\n\t\t\t    info[i].pi_s32);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED32:\n\t\t\t(void)fprintf(stderr, \"unsigned 32 [%u]\\n\",\n\t\t\t    info[i].pi_u32);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\t(void)fprintf(stderr, \"float [%g]\\n\",\n\t\t\t    info[i].pi_f);\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\t(void)fprintf(stderr, \"double [%g]\\n\",\n\t\t\t    info[i].pi_d);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\t\t(void)fprintf(stderr, \"string %u [%.*s]\\n\",\n\t\t\t    info[i].pi_str.s_len,\n\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\t(void)fprintf(stderr, \"string %u [\",\n\t\t\t    info[i].pi_str.s_len);\n\t\t\tfor (j = 0; j < info[i].pi_str.s_len - 1; j++)\n\t\t\t    (void)fputc(info[i].pi_str.s_buf[j << 1], stderr);\n\t\t\t(void)fprintf(stderr, \"]\\n\");\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\ttp = info[i].pi_tp;\n\t\t\tif (tp < 1000000000000000LL) {\n\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\\n\", buf);\n\t\t\t} else {\n\t\t\t\tchar buf[26];\n\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\",\n\t\t\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\t(void)fprintf(stderr, \"CLIPBOARD %u\\n\", info[i].pi_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    info[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\ncdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tchar buf[128];\n\tcdf_summary_info_header_t ssi;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\n\t(void)&h;\n\tif (cdf_unpack_summary_info(sst, h, &ssi, &info, &count) == -1)\n\t\treturn;\n\t(void)fprintf(stderr, \"Endian: %x\\n\", ssi.si_byte_order);\n\t(void)fprintf(stderr, \"Os Version %d.%d\\n\", ssi.si_os_version & 0xff,\n\t\tssi.si_os_version >> 8);\n\t(void)fprintf(stderr, \"Os %d\\n\", ssi.si_os);\n\tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);\n\t(void)fprintf(stderr, \"Class %s\\n\", buf);\n\t(void)fprintf(stderr, \"Count %d\\n\", ssi.si_count);\n\tcdf_dump_property_info(info, count);\n\tfree(info);\n}\n\n#endif\n\n#ifdef TEST\nint\nmain(int argc, char *argv[])\n{\n\tint i;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tcdf_info_t info;\n\n\tif (argc < 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s <filename>\\n\", getprogname());\n\t\treturn -1;\n\t}\n\n\tinfo.i_buf = NULL;\n\tinfo.i_len = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif ((info.i_fd = open(argv[1], O_RDONLY)) == -1)\n\t\t\terr(1, \"Cannot open `%s'\", argv[1]);\n\n\t\tif (cdf_read_header(&info, &h) == -1)\n\t\t\terr(1, \"Cannot read header\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_header(&h);\n#endif\n\n\t\tif (cdf_read_sat(&info, &h, &sat) == -1)\n\t\t\terr(1, \"Cannot read sat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_ssat(&info, &h, &sat, &ssat) == -1)\n\t\t\terr(1, \"Cannot read ssat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_dir(&info, &h, &sat, &dir) == -1)\n\t\t\terr(1, \"Cannot read dir\");\n\n\t\tif (cdf_read_short_stream(&info, &h, &sat, &dir, &sst) == -1)\n\t\t\terr(1, \"Cannot read short stream\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_stream(&h, &sst);\n#endif\n\n#ifdef CDF_DEBUG\n\t\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n\n\n\t\tif (cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t\t    &scn) == -1)\n\t\t\terr(1, \"Cannot read summary info\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_summary_info(&h, &scn);\n#endif\n\n\t\t(void)close(info.i_fd);\n\t}\n\n\treturn 0;\n}\n#endif\n", "/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readcdf.c,v 1.39 2014/02/27 23:26:18 christos Exp $\")\n#endif\n\n#include <assert.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n#include \"cdf.h\"\n#include \"magic.h\"\n\n#define NOTMIME(ms) (((ms)->flags & MAGIC_MIME) == 0)\n\nstatic const struct nv {\n\tconst char *pattern;\n\tconst char *mime;\n} app2mime[] =  {\n\t{ \"Word\",\t\t\t\"msword\",\t\t},\n\t{ \"Excel\",\t\t\t\"vnd.ms-excel\",\t\t},\n\t{ \"Powerpoint\",\t\t\t\"vnd.ms-powerpoint\",\t},\n\t{ \"Crystal Reports\",\t\t\"x-rpt\",\t\t},\n\t{ \"Advanced Installer\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"InstallShield\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"Microsoft Patch Compiler\",\t\"vnd.ms-msi\",\t\t},\n\t{ \"NAnt\",\t\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"Windows Installer\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n}, name2mime[] = {\n\t{ \"WordDocument\",\t\t\"msword\",\t\t},\n\t{ \"PowerPoint\",\t\t\t\"vnd.ms-powerpoint\",\t},\n\t{ \"DigitalSignature\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n}, name2desc[] = {\n\t{ \"WordDocument\",\t\t\"Microsoft Office Word\",},\n\t{ \"PowerPoint\",\t\t\t\"Microsoft PowerPoint\",\t},\n\t{ \"DigitalSignature\",\t\t\"Microsoft Installer\",\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n};\n\nstatic const struct cv {\n\tuint64_t clsid[2];\n\tconst char *mime;\n} clsid2mime[] = {\n\t{\n\t\t{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },\n\t\t\"x-msi\",\n\t}\n}, clsid2desc[] = {\n\t{\n\t\t{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },\n\t\t\"MSI Installer\",\n\t},\n};\n\nprivate const char *\ncdf_clsid_to_mime(const uint64_t clsid[2], const struct cv *cv)\n{\n\tsize_t i;\n\tfor (i = 0; cv[i].mime != NULL; i++) {\n\t\tif (clsid[0] == cv[i].clsid[0] && clsid[1] == cv[i].clsid[1])\n\t\t\treturn cv[i].mime;\n\t}\n\treturn NULL;\n}\n\nprivate const char *\ncdf_app_to_mime(const char *vbuf, const struct nv *nv)\n{\n\tsize_t i;\n\tconst char *rv = NULL;\n\tchar *old_lc_ctype;\n\n\told_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tassert(old_lc_ctype != NULL);\n\told_lc_ctype = strdup(old_lc_ctype);\n\tassert(old_lc_ctype != NULL);\n\t(void)setlocale(LC_CTYPE, \"C\");\n\tfor (i = 0; nv[i].pattern != NULL; i++)\n\t\tif (strcasestr(vbuf, nv[i].pattern) != NULL) {\n\t\t\trv = nv[i].mime;\n\t\t\tbreak;\n\t\t}\n\t(void)setlocale(LC_CTYPE, old_lc_ctype);\n\tfree(old_lc_ctype);\n\treturn rv;\n}\n\nprivate int\ncdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const uint64_t clsid[2])\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms))\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}\n\nprivate int\ncdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const uint64_t clsid[2])\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n\t\tif (str)\n                        if (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\treturn -2;\n        }\n\n        m = cdf_file_property_info(ms, info, count, clsid);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}\n\n#ifdef notdef\nprivate char *\nformat_clsid(char *buf, size_t len, const uint64_t uuid[2]) {\n\tsnprintf(buf, len, \"%.8\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" \n\t    PRIx64 \"-%.12\" PRIx64,\n\t    (uuid[0] >> 32) & (uint64_t)0x000000000ffffffffLLU,\n\t    (uuid[0] >> 16) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[0] >>  0) & (uint64_t)0x0000000000000ffffLLU, \n\t    (uuid[1] >> 48) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[1] >>  0) & (uint64_t)0x0000fffffffffffffLLU);\n\treturn buf;\n}\n#endif\n\nprotected int\nfile_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n        cdf_info_t info;\n        cdf_header_t h;\n        cdf_sat_t sat, ssat;\n        cdf_stream_t sst, scn;\n        cdf_dir_t dir;\n        int i;\n        const char *expn = \"\";\n        const char *corrupt = \"corrupt: \";\n\n        info.i_fd = fd;\n        info.i_buf = buf;\n        info.i_len = nbytes;\n        if (ms->flags & MAGIC_APPLE)\n                return 0;\n        if (cdf_read_header(&info, &h) == -1)\n                return 0;\n#ifdef CDF_DEBUG\n        cdf_dump_header(&h);\n#endif\n\n        if ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n                expn = \"Can't read SAT\";\n                goto out0;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n                expn = \"Can't read SSAT\";\n                goto out1;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n                expn = \"Can't read directory\";\n                goto out2;\n        }\n\n        const cdf_directory_t *root_storage;\n        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n                expn = \"Cannot read short stream\";\n                goto out3;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n        if ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n            &scn)) == -1) {\n                if (errno == ESRCH) {\n                        corrupt = expn;\n                        expn = \"No summary info\";\n                } else {\n                        expn = \"Cannot read summary info\";\n                }\n                goto out4;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_summary_info(&h, &scn);\n#endif\n        if ((i = cdf_file_summary_info(ms, &h, &scn,\n\t    root_storage->d_storage_uuid)) < 0)\n                expn = \"Can't expand summary_info\";\n\n\tif (i == 0) {\n\t\tconst char *str = NULL;\n\t\tcdf_directory_t *d;\n\t\tchar name[__arraycount(d->d_name)];\n\t\tsize_t j, k;\n\n\t\tfor (j = 0; str == NULL && j < dir.dir_len; j++) {\n\t\t\td = &dir.dir_tab[j];\n\t\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\t\tname[k] = (char)cdf_tole2(d->d_name[k]);\n\t\t\tstr = cdf_app_to_mime(name,\n\t\t\t    NOTMIME(ms) ? name2desc : name2mime);\n\t\t}\n\t\tif (NOTMIME(ms)) {\n\t\t\tif (str != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (str == NULL)\n\t\t\t\tstr = \"vnd.ms-office\";\n\t\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t}\n        free(scn.sst_tab);\nout4:\n        free(sst.sst_tab);\nout3:\n        free(dir.dir_tab);\nout2:\n        free(ssat.sat_tab);\nout1:\n        free(sat.sat_tab);\nout0:\n\tif (i == -1) {\n\t    if (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t    return -1;\n\t\tif (*expn)\n\t\t    if (file_printf(ms, \", %s%s\", corrupt, expn) == -1)\n\t\t\treturn -1;\n\t    } else {\n\t\tif (file_printf(ms, \"application/CDFV2-corrupt\") == -1)\n\t\t    return -1;\n\t    }\n\t    i = 1;\n\t}\n        return i;\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: cdf.c,v 1.55 2014/02/27 23:26:17 christos Exp $\")\n#endif\n\n#include <assert.h>\n#ifdef CDF_DEBUG\n#include <err.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#ifndef EFTYPE\n#define EFTYPE EINVAL\n#endif\n\n#include \"cdf.h\"\n\n#ifdef CDF_DEBUG\n#define DPRINTF(a) printf a, fflush(stdout)\n#else\n#define DPRINTF(a)\n#endif\n\nstatic union {\n\tchar s[4];\n\tuint32_t u;\n} cdf_bo;\n\n#define NEED_SWAP\t(cdf_bo.u == (uint32_t)0x01020304)\n\n#define CDF_TOLE8(x)\t((uint64_t)(NEED_SWAP ? _cdf_tole8(x) : (uint64_t)(x)))\n#define CDF_TOLE4(x)\t((uint32_t)(NEED_SWAP ? _cdf_tole4(x) : (uint32_t)(x)))\n#define CDF_TOLE2(x)\t((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))\n#define CDF_GETUINT32(x, y)\tcdf_getuint32(x, y)\n\n\n/*\n * swap a short\n */\nstatic uint16_t\n_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nstatic uint32_t\n_cdf_tole4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nstatic uint64_t\n_cdf_tole8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n\treturn rv;\n}\n\n/*\n * grab a uint32_t from a possibly unaligned address, and return it in\n * the native host order.\n */\nstatic uint32_t\ncdf_getuint32(const uint8_t *p, size_t offs)\n{\n\tuint32_t rv;\n\t(void)memcpy(&rv, p + offs * sizeof(uint32_t), sizeof(rv));\n\treturn CDF_TOLE4(rv);\n}\n\n#define CDF_UNPACK(a)\t\\\n    (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)\n#define CDF_UNPACKA(a)\t\\\n    (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)\n\nuint16_t\ncdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}\n\nuint32_t\ncdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}\n\nuint64_t\ncdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}\n\nvoid\ncdf_swap_header(cdf_header_t *h)\n{\n\tsize_t i;\n\n\th->h_magic = CDF_TOLE8(h->h_magic);\n\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n\th->h_revision = CDF_TOLE2(h->h_revision);\n\th->h_version = CDF_TOLE2(h->h_version);\n\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n\th->h_min_size_standard_stream =\n\t    CDF_TOLE4(h->h_min_size_standard_stream);\n\th->h_secid_first_sector_in_short_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_short_sat);\n\th->h_num_sectors_in_short_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n\th->h_secid_first_sector_in_master_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_master_sat);\n\th->h_num_sectors_in_master_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\th->h_master_sat[i] = CDF_TOLE4((uint32_t)h->h_master_sat[i]);\n}\n\nvoid\ncdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}\n\nvoid\ncdf_swap_dir(cdf_directory_t *d)\n{\n\td->d_namelen = CDF_TOLE2(d->d_namelen);\n\td->d_left_child = CDF_TOLE4((uint32_t)d->d_left_child);\n\td->d_right_child = CDF_TOLE4((uint32_t)d->d_right_child);\n\td->d_storage = CDF_TOLE4((uint32_t)d->d_storage);\n\td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);\n\td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);\n\td->d_flags = CDF_TOLE4(d->d_flags);\n\td->d_created = CDF_TOLE8((uint64_t)d->d_created);\n\td->d_modified = CDF_TOLE8((uint64_t)d->d_modified);\n\td->d_stream_first_sector = CDF_TOLE4((uint32_t)d->d_stream_first_sector);\n\td->d_size = CDF_TOLE4(d->d_size);\n}\n\nvoid\ncdf_swap_class(cdf_classid_t *d)\n{\n\td->cl_dword = CDF_TOLE4(d->cl_dword);\n\td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);\n\td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);\n}\n\nvoid\ncdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}\n\nstatic int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nstatic ssize_t\ncdf_read(const cdf_info_t *info, off_t off, void *buf, size_t len)\n{\n\tsize_t siz = (size_t)off + len;\n\n\tif ((off_t)(off + len) != (off_t)siz) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (info->i_buf != NULL && info->i_len >= siz) {\n\t\t(void)memcpy(buf, &info->i_buf[off], len);\n\t\treturn (ssize_t)len;\n\t}\n\n\tif (info->i_fd == -1)\n\t\treturn -1;\n\n\tif (pread(info->i_fd, buf, len, off) != (ssize_t)len)\n\t\treturn -1;\n\n\treturn (ssize_t)len;\n}\n\nint\ncdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nssize_t\ncdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos = CDF_SEC_POS(h, id);\n\tassert(ss == len);\n\treturn cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);\n}\n\nssize_t\ncdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}\n\n/*\n * Read the sector allocation table.\n */\nint\ncdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)\n{\n\tsize_t i, j, k;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t *msa, mid, sec;\n\tsize_t nsatpersec = (ss / sizeof(mid)) - 1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\n#define CDF_SEC_LIMIT (UINT32_MAX / (4 * ss))\n\tif ((nsatpersec > 0 &&\n\t    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||\n\t    i > CDF_SEC_LIMIT) {\n\t\tDPRINTF((\"Number of sectors in master SAT too big %u %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", h->h_num_sectors_in_master_sat, i));\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tsat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i;\n\tDPRINTF((\"sat_len = %\" SIZE_T_FORMAT \"u ss = %\" SIZE_T_FORMAT \"u\\n\",\n\t    sat->sat_len, ss));\n\tif ((sat->sat_tab = CAST(cdf_secid_t *, calloc(sat->sat_len, ss)))\n\t    == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] < 0)\n\t\t\tbreak;\n\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t    h->h_master_sat[i]) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading sector %d\", h->h_master_sat[i]));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((msa = CAST(cdf_secid_t *, calloc(1, ss))) == NULL)\n\t\tgoto out1;\n\n\tmid = h->h_secid_first_sector_in_master_sat;\n\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n\t\tif (mid < 0)\n\t\t\tgoto out;\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Reading master sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out2;\n\t\t}\n\t\tif (cdf_read_sector(info, msa, 0, ss, h, mid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading master sector %d\", mid));\n\t\t\tgoto out2;\n\t\t}\n\t\tfor (k = 0; k < nsatpersec; k++, i++) {\n\t\t\tsec = CDF_TOLE4((uint32_t)msa[k]);\n\t\t\tif (sec < 0)\n\t\t\t\tgoto out;\n\t\t\tif (i >= sat->sat_len) {\n\t\t\t    DPRINTF((\"Out of bounds reading MSA %\" SIZE_T_FORMAT\n\t\t\t\t\"u >= %\" SIZE_T_FORMAT \"u\", i, sat->sat_len));\n\t\t\t    errno = EFTYPE;\n\t\t\t    goto out2;\n\t\t\t}\n\t\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t\t    sec) != (ssize_t)ss) {\n\t\t\t\tDPRINTF((\"Reading sector %d\",\n\t\t\t\t    CDF_TOLE4(msa[k])));\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\t\tmid = CDF_TOLE4((uint32_t)msa[nsatpersec]);\n\t}\nout:\n\tsat->sat_len = i;\n\tfree(msa);\n\treturn 0;\nout2:\n\tfree(msa);\nout1:\n\tfree(sat->sat_tab);\n\treturn -1;\n}\n\nsize_t\ncdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n\n\tDPRINTF((\"Chain:\"));\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}\n\nint\ncdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = len;\n\n\tif (scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != (ssize_t)ss) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\t/* Last sector might be truncated */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n\nint\ncdf_read_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\n\tif (len < h->h_min_size_standard_stream && sst->sst_tab != NULL)\n\t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,\n\t\t    scn);\n\telse\n\t\treturn cdf_read_long_sector_chain(info, h, sat, sid, len, scn);\n}\n\nint\ncdf_read_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n\tchar *buf;\n\tcdf_secid_t sid = h->h_secid_first_directory;\n\n\tns = cdf_count_chain(sat, sid, ss);\n\tif (ns == (size_t)-1)\n\t\treturn -1;\n\n\tnd = ss / CDF_DIRECTORY_SIZE;\n\n\tdir->dir_len = ns * nd;\n\tdir->dir_tab = CAST(cdf_directory_t *,\n\t    calloc(dir->dir_len, sizeof(dir->dir_tab[0])));\n\tif (dir->dir_tab == NULL)\n\t\treturn -1;\n\n\tif ((buf = CAST(char *, malloc(ss))) == NULL) {\n\t\tfree(dir->dir_tab);\n\t\treturn -1;\n\t}\n\n\tfor (j = i = 0; i < ns; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read dir loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, buf, 0, ss, h, sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading directory sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < nd; j++) {\n\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (NEED_SWAP)\n\t\tfor (i = 0; i < dir->dir_len; i++)\n\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n\tfree(buf);\n\treturn 0;\nout:\n\tfree(dir->dir_tab);\n\tfree(buf);\n\treturn -1;\n}\n\n\nint\ncdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\n\tssat->sat_len = cdf_count_chain(sat, sid, CDF_SEC_SIZE(h));\n\tif (ssat->sat_len == (size_t)-1)\n\t\treturn -1;\n\n\tssat->sat_tab = CAST(cdf_secid_t *, calloc(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    ssat->sat_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}\n\nstatic int\ncdf_namecmp(const char *d, const uint16_t *s, size_t l)\n{\n\tfor (; l--; d++, s++)\n\t\tif (*d != CDF_TOLE2(*s))\n\t\t\treturn (unsigned char)*d - CDF_TOLE2(*s);\n\treturn 0;\n}\n\nint\ncdf_read_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tstatic const char name[] = \"\\05SummaryInformation\";\n\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, sizeof(name))\n\t\t    == 0)\n\t\t\tbreak;\n\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find summary information section\\n\"));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}\n\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nint\ncdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)\n{\n\treturn snprintf(buf, buflen, \"%.8x-%.4x-%.4x-%.2x%.2x-\"\n\t    \"%.2x%.2x%.2x%.2x%.2x%.2x\", id->cl_dword, id->cl_word[0],\n\t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],\n\t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],\n\t    id->cl_six[5]);\n}\n\nstatic const struct {\n\tuint32_t v;\n\tconst char *n;\n} vn[] = {\n\t{ CDF_PROPERTY_CODE_PAGE, \"Code page\" },\n\t{ CDF_PROPERTY_TITLE, \"Title\" },\n\t{ CDF_PROPERTY_SUBJECT, \"Subject\" },\n\t{ CDF_PROPERTY_AUTHOR, \"Author\" },\n\t{ CDF_PROPERTY_KEYWORDS, \"Keywords\" },\n\t{ CDF_PROPERTY_COMMENTS, \"Comments\" },\n\t{ CDF_PROPERTY_TEMPLATE, \"Template\" },\n\t{ CDF_PROPERTY_LAST_SAVED_BY, \"Last Saved By\" },\n\t{ CDF_PROPERTY_REVISION_NUMBER, \"Revision Number\" },\n\t{ CDF_PROPERTY_TOTAL_EDITING_TIME, \"Total Editing Time\" },\n\t{ CDF_PROPERTY_LAST_PRINTED, \"Last Printed\" },\n\t{ CDF_PROPERTY_CREATE_TIME, \"Create Time/Date\" },\n\t{ CDF_PROPERTY_LAST_SAVED_TIME, \"Last Saved Time/Date\" },\n\t{ CDF_PROPERTY_NUMBER_OF_PAGES, \"Number of Pages\" },\n\t{ CDF_PROPERTY_NUMBER_OF_WORDS, \"Number of Words\" },\n\t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, \"Number of Characters\" },\n\t{ CDF_PROPERTY_THUMBNAIL, \"Thumbnail\" },\n\t{ CDF_PROPERTY_NAME_OF_APPLICATION, \"Name of Creating Application\" },\n\t{ CDF_PROPERTY_SECURITY, \"Security\" },\n\t{ CDF_PROPERTY_LOCALE_ID, \"Locale ID\" },\n};\n\nint\ncdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"0x%x\", p);\n}\n\nint\ncdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)\n{\n\tint len = 0;\n\tint days, hours, mins, secs;\n\n\tts /= CDF_TIME_PREC;\n\tsecs = (int)(ts % 60);\n\tts /= 60;\n\tmins = (int)(ts % 60);\n\tts /= 60;\n\thours = (int)(ts % 24);\n\tts /= 24;\n\tdays = (int)ts;\n\n\tif (days) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%dd+\", days);\n\t\tif ((size_t)len >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tif (days || hours) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", hours);\n\t\tif ((size_t)len >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", mins);\n\tif ((size_t)len >= bufsiz)\n\t\treturn len;\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d\", secs);\n\treturn len;\n}\n\n\n#ifdef CDF_DEBUG\nvoid\ncdf_dump_header(const cdf_header_t *h)\n{\n\tsize_t i;\n\n#define DUMP(a, b) (void)fprintf(stderr, \"%40.40s = \" a \"\\n\", # b, h->h_ ## b)\n#define DUMP2(a, b) (void)fprintf(stderr, \"%40.40s = \" a \" (\" a \")\\n\", # b, \\\n    h->h_ ## b, 1 << h->h_ ## b)\n\tDUMP(\"%d\", revision);\n\tDUMP(\"%d\", version);\n\tDUMP(\"0x%x\", byte_order);\n\tDUMP2(\"%d\", sec_size_p2);\n\tDUMP2(\"%d\", short_sec_size_p2);\n\tDUMP(\"%d\", num_sectors_in_sat);\n\tDUMP(\"%d\", secid_first_directory);\n\tDUMP(\"%d\", min_size_standard_stream);\n\tDUMP(\"%d\", secid_first_sector_in_short_sat);\n\tDUMP(\"%d\", num_sectors_in_short_sat);\n\tDUMP(\"%d\", secid_first_sector_in_master_sat);\n\tDUMP(\"%d\", num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\t\t(void)fprintf(stderr, \"%35.35s[%.3zu] = %d\\n\",\n\t\t    \"master_sat\", i, h->h_master_sat[i]);\n\t}\n}\n\nvoid\ncdf_dump_sat(const char *prefix, const cdf_sat_t *sat, size_t size)\n{\n\tsize_t i, j, s = size / sizeof(cdf_secid_t);\n\n\tfor (i = 0; i < sat->sat_len; i++) {\n\t\t(void)fprintf(stderr, \"%s[%\" SIZE_T_FORMAT \"u]:\\n%.6\"\n\t\t    SIZE_T_FORMAT \"u: \", prefix, i, i * s);\n\t\tfor (j = 0; j < s; j++) {\n\t\t\t(void)fprintf(stderr, \"%5d, \",\n\t\t\t    CDF_TOLE4(sat->sat_tab[s * i + j]));\n\t\t\tif ((j + 1) % 10 == 0)\n\t\t\t\t(void)fprintf(stderr, \"\\n%.6\" SIZE_T_FORMAT\n\t\t\t\t    \"u: \", i * s + j + 1);\n\t\t}\n\t\t(void)fprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\ncdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}\n\nvoid\ncdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}\n\nvoid\ncdf_dump_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tcdf_stream_t scn;\n\tstruct timespec ts;\n\n\tstatic const char *types[] = { \"empty\", \"user storage\",\n\t    \"user stream\", \"lockbytes\", \"property\", \"root storage\" };\n\n\tfor (i = 0; i < dir->dir_len; i++) {\n\t\tchar buf[26];\n\t\td = &dir->dir_tab[i];\n\t\tfor (j = 0; j < sizeof(name); j++)\n\t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);\n\t\t(void)fprintf(stderr, \"Directory %\" SIZE_T_FORMAT \"u: %s\\n\",\n\t\t    i, name);\n\t\tif (d->d_type < __arraycount(types))\n\t\t\t(void)fprintf(stderr, \"Type: %s\\n\", types[d->d_type]);\n\t\telse\n\t\t\t(void)fprintf(stderr, \"Type: %d\\n\", d->d_type);\n\t\t(void)fprintf(stderr, \"Color: %s\\n\",\n\t\t    d->d_color ? \"black\" : \"red\");\n\t\t(void)fprintf(stderr, \"Left child: %d\\n\", d->d_left_child);\n\t\t(void)fprintf(stderr, \"Right child: %d\\n\", d->d_right_child);\n\t\t(void)fprintf(stderr, \"Flags: 0x%x\\n\", d->d_flags);\n\t\tcdf_timestamp_to_timespec(&ts, d->d_created);\n\t\t(void)fprintf(stderr, \"Created %s\", cdf_ctime(&ts.tv_sec, buf));\n\t\tcdf_timestamp_to_timespec(&ts, d->d_modified);\n\t\t(void)fprintf(stderr, \"Modified %s\",\n\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t(void)fprintf(stderr, \"Stream %d\\n\", d->d_stream_first_sector);\n\t\t(void)fprintf(stderr, \"Size %d\\n\", d->d_size);\n\t\tswitch (d->d_type) {\n\t\tcase CDF_DIR_TYPE_USER_STORAGE:\n\t\t\t(void)fprintf(stderr, \"Storage: %d\\n\", d->d_storage);\n\t\t\tbreak;\n\t\tcase CDF_DIR_TYPE_USER_STREAM:\n\t\t\tif (sst == NULL)\n\t\t\t\tbreak;\n\t\t\tif (cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {\n\t\t\t\twarn(\"Can't read stream for %s at %d len %d\",\n\t\t\t\t    name, d->d_stream_first_sector, d->d_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcdf_dump_stream(h, &scn);\n\t\t\tfree(scn.sst_tab);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\nvoid\ncdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n{\n\tcdf_timestamp_t tp;\n\tstruct timespec ts;\n\tchar buf[64];\n\tsize_t i, j;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n\t\t(void)fprintf(stderr, \"%\" SIZE_T_FORMAT \"u) %s: \", i, buf);\n\t\tswitch (info[i].pi_type) {\n\t\tcase CDF_NULL:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\t(void)fprintf(stderr, \"signed 16 [%hd]\\n\",\n\t\t\t    info[i].pi_s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\t(void)fprintf(stderr, \"signed 32 [%d]\\n\",\n\t\t\t    info[i].pi_s32);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED32:\n\t\t\t(void)fprintf(stderr, \"unsigned 32 [%u]\\n\",\n\t\t\t    info[i].pi_u32);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\t(void)fprintf(stderr, \"float [%g]\\n\",\n\t\t\t    info[i].pi_f);\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\t(void)fprintf(stderr, \"double [%g]\\n\",\n\t\t\t    info[i].pi_d);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\t\t(void)fprintf(stderr, \"string %u [%.*s]\\n\",\n\t\t\t    info[i].pi_str.s_len,\n\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\t(void)fprintf(stderr, \"string %u [\",\n\t\t\t    info[i].pi_str.s_len);\n\t\t\tfor (j = 0; j < info[i].pi_str.s_len - 1; j++)\n\t\t\t    (void)fputc(info[i].pi_str.s_buf[j << 1], stderr);\n\t\t\t(void)fprintf(stderr, \"]\\n\");\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\ttp = info[i].pi_tp;\n\t\t\tif (tp < 1000000000000000LL) {\n\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\\n\", buf);\n\t\t\t} else {\n\t\t\t\tchar buf[26];\n\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\",\n\t\t\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\t(void)fprintf(stderr, \"CLIPBOARD %u\\n\", info[i].pi_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    info[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\ncdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tchar buf[128];\n\tcdf_summary_info_header_t ssi;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\n\t(void)&h;\n\tif (cdf_unpack_summary_info(sst, h, &ssi, &info, &count) == -1)\n\t\treturn;\n\t(void)fprintf(stderr, \"Endian: %x\\n\", ssi.si_byte_order);\n\t(void)fprintf(stderr, \"Os Version %d.%d\\n\", ssi.si_os_version & 0xff,\n\t\tssi.si_os_version >> 8);\n\t(void)fprintf(stderr, \"Os %d\\n\", ssi.si_os);\n\tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);\n\t(void)fprintf(stderr, \"Class %s\\n\", buf);\n\t(void)fprintf(stderr, \"Count %d\\n\", ssi.si_count);\n\tcdf_dump_property_info(info, count);\n\tfree(info);\n}\n\n#endif\n\n#ifdef TEST\nint\nmain(int argc, char *argv[])\n{\n\tint i;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tcdf_info_t info;\n\n\tif (argc < 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s <filename>\\n\", getprogname());\n\t\treturn -1;\n\t}\n\n\tinfo.i_buf = NULL;\n\tinfo.i_len = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif ((info.i_fd = open(argv[1], O_RDONLY)) == -1)\n\t\t\terr(1, \"Cannot open `%s'\", argv[1]);\n\n\t\tif (cdf_read_header(&info, &h) == -1)\n\t\t\terr(1, \"Cannot read header\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_header(&h);\n#endif\n\n\t\tif (cdf_read_sat(&info, &h, &sat) == -1)\n\t\t\terr(1, \"Cannot read sat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_ssat(&info, &h, &sat, &ssat) == -1)\n\t\t\terr(1, \"Cannot read ssat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_dir(&info, &h, &sat, &dir) == -1)\n\t\t\terr(1, \"Cannot read dir\");\n\n\t\tif (cdf_read_short_stream(&info, &h, &sat, &dir, &sst) == -1)\n\t\t\terr(1, \"Cannot read short stream\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_stream(&h, &sst);\n#endif\n\n#ifdef CDF_DEBUG\n\t\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n\n\n\t\tif (cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t\t    &scn) == -1)\n\t\t\terr(1, \"Cannot read summary info\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_summary_info(&h, &scn);\n#endif\n\n\t\t(void)close(info.i_fd);\n\t}\n\n\treturn 0;\n}\n#endif\n", "/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readcdf.c,v 1.40 2014/03/06 15:23:33 christos Exp $\")\n#endif\n\n#include <assert.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n#include \"cdf.h\"\n#include \"magic.h\"\n\n#define NOTMIME(ms) (((ms)->flags & MAGIC_MIME) == 0)\n\nstatic const struct nv {\n\tconst char *pattern;\n\tconst char *mime;\n} app2mime[] =  {\n\t{ \"Word\",\t\t\t\"msword\",\t\t},\n\t{ \"Excel\",\t\t\t\"vnd.ms-excel\",\t\t},\n\t{ \"Powerpoint\",\t\t\t\"vnd.ms-powerpoint\",\t},\n\t{ \"Crystal Reports\",\t\t\"x-rpt\",\t\t},\n\t{ \"Advanced Installer\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"InstallShield\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"Microsoft Patch Compiler\",\t\"vnd.ms-msi\",\t\t},\n\t{ \"NAnt\",\t\t\t\"vnd.ms-msi\",\t\t},\n\t{ \"Windows Installer\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n}, name2mime[] = {\n\t{ \"WordDocument\",\t\t\"msword\",\t\t},\n\t{ \"PowerPoint\",\t\t\t\"vnd.ms-powerpoint\",\t},\n\t{ \"DigitalSignature\",\t\t\"vnd.ms-msi\",\t\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n}, name2desc[] = {\n\t{ \"WordDocument\",\t\t\"Microsoft Office Word\",},\n\t{ \"PowerPoint\",\t\t\t\"Microsoft PowerPoint\",\t},\n\t{ \"DigitalSignature\",\t\t\"Microsoft Installer\",\t},\n\t{ NULL,\t\t\t\tNULL,\t\t\t},\n};\n\nstatic const struct cv {\n\tuint64_t clsid[2];\n\tconst char *mime;\n} clsid2mime[] = {\n\t{\n\t\t{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },\n\t\t\"x-msi\",\n\t}\n}, clsid2desc[] = {\n\t{\n\t\t{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },\n\t\t\"MSI Installer\",\n\t},\n};\n\nprivate const char *\ncdf_clsid_to_mime(const uint64_t clsid[2], const struct cv *cv)\n{\n\tsize_t i;\n\tfor (i = 0; cv[i].mime != NULL; i++) {\n\t\tif (clsid[0] == cv[i].clsid[0] && clsid[1] == cv[i].clsid[1])\n\t\t\treturn cv[i].mime;\n\t}\n\treturn NULL;\n}\n\nprivate const char *\ncdf_app_to_mime(const char *vbuf, const struct nv *nv)\n{\n\tsize_t i;\n\tconst char *rv = NULL;\n\tchar *old_lc_ctype;\n\n\told_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tassert(old_lc_ctype != NULL);\n\told_lc_ctype = strdup(old_lc_ctype);\n\tassert(old_lc_ctype != NULL);\n\t(void)setlocale(LC_CTYPE, \"C\");\n\tfor (i = 0; nv[i].pattern != NULL; i++)\n\t\tif (strcasestr(vbuf, nv[i].pattern) != NULL) {\n\t\t\trv = nv[i].mime;\n\t\t\tbreak;\n\t\t}\n\t(void)setlocale(LC_CTYPE, old_lc_ctype);\n\tfree(old_lc_ctype);\n\treturn rv;\n}\n\nprivate int\ncdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const cdf_directory_t *root_storage)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms) && root_storage)\n\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}\n\nprivate int\ncdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n        m = cdf_file_property_info(ms, info, count, root_storage);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}\n\n#ifdef notdef\nprivate char *\nformat_clsid(char *buf, size_t len, const uint64_t uuid[2]) {\n\tsnprintf(buf, len, \"%.8\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" \n\t    PRIx64 \"-%.12\" PRIx64,\n\t    (uuid[0] >> 32) & (uint64_t)0x000000000ffffffffLLU,\n\t    (uuid[0] >> 16) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[0] >>  0) & (uint64_t)0x0000000000000ffffLLU, \n\t    (uuid[1] >> 48) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[1] >>  0) & (uint64_t)0x0000fffffffffffffLLU);\n\treturn buf;\n}\n#endif\n\nprotected int\nfile_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n        cdf_info_t info;\n        cdf_header_t h;\n        cdf_sat_t sat, ssat;\n        cdf_stream_t sst, scn;\n        cdf_dir_t dir;\n        int i;\n        const char *expn = \"\";\n        const char *corrupt = \"corrupt: \";\n\n        info.i_fd = fd;\n        info.i_buf = buf;\n        info.i_len = nbytes;\n        if (ms->flags & MAGIC_APPLE)\n                return 0;\n        if (cdf_read_header(&info, &h) == -1)\n                return 0;\n#ifdef CDF_DEBUG\n        cdf_dump_header(&h);\n#endif\n\n        if ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n                expn = \"Can't read SAT\";\n                goto out0;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n                expn = \"Can't read SSAT\";\n                goto out1;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n                expn = \"Can't read directory\";\n                goto out2;\n        }\n\n        const cdf_directory_t *root_storage;\n        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n                expn = \"Cannot read short stream\";\n                goto out3;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n        if ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n            &scn)) == -1) {\n                if (errno == ESRCH) {\n                        corrupt = expn;\n                        expn = \"No summary info\";\n                } else {\n                        expn = \"Cannot read summary info\";\n                }\n                goto out4;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_summary_info(&h, &scn);\n#endif\n        if ((i = cdf_file_summary_info(ms, &h, &scn, root_storage)) < 0)\n            expn = \"Can't expand summary_info\";\n\n\tif (i == 0) {\n\t\tconst char *str = NULL;\n\t\tcdf_directory_t *d;\n\t\tchar name[__arraycount(d->d_name)];\n\t\tsize_t j, k;\n\n\t\tfor (j = 0; str == NULL && j < dir.dir_len; j++) {\n\t\t\td = &dir.dir_tab[j];\n\t\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\t\tname[k] = (char)cdf_tole2(d->d_name[k]);\n\t\t\tstr = cdf_app_to_mime(name,\n\t\t\t    NOTMIME(ms) ? name2desc : name2mime);\n\t\t}\n\t\tif (NOTMIME(ms)) {\n\t\t\tif (str != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (str == NULL)\n\t\t\t\tstr = \"vnd.ms-office\";\n\t\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t}\n        free(scn.sst_tab);\nout4:\n        free(sst.sst_tab);\nout3:\n        free(dir.dir_tab);\nout2:\n        free(ssat.sat_tab);\nout1:\n        free(sat.sat_tab);\nout0:\n\tif (i == -1) {\n\t    if (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t    return -1;\n\t\tif (*expn)\n\t\t    if (file_printf(ms, \", %s%s\", corrupt, expn) == -1)\n\t\t\treturn -1;\n\t    } else {\n\t\tif (file_printf(ms, \"application/CDFV2-corrupt\") == -1)\n\t\t    return -1;\n\t    }\n\t    i = 1;\n\t}\n        return i;\n}\n"], "filenames": ["src/cdf.c", "src/readcdf.c"], "buggy_code_start_loc": [38, 29], "buggy_code_end_loc": [359, 387], "fixing_code_start_loc": [38, 29], "fixing_code_end_loc": [359, 388], "type": "CWE-119", "message": "The cdf_read_short_sector function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted CDF file.", "other": {"cve": {"id": "CVE-2014-0207", "sourceIdentifier": "secalert@redhat.com", "published": "2014-07-09T11:07:01.243", "lastModified": "2022-09-28T20:39:46.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The cdf_read_short_sector function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted CDF file."}, {"lang": "es", "value": "La funci\u00f3n cdf_read_short_sector en cdf.c en file anterior a 5.19, utilizado en el componente Fileinfo en PHP anterior a 5.4.30 y 5.5.x anterior a 5.5.14, permite a atacantes remotos causar una denegaci\u00f3n de servicio (fallo de aserci\u00f3n y cierre de aplicaci\u00f3n) a trav\u00e9s de un fichero CDF manipulado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19", "matchCriteriaId": "BE954D26-5D85-426F-ADF5-94177F88C21C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.29", "matchCriteriaId": "388E0CDF-737F-437E-B4D9-1001E0651387"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndExcluding": "5.4.30", "matchCriteriaId": "AD052020-AA37-4F49-A0FE-EA99616C12C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.0", "versionEndExcluding": "5.5.14", "matchCriteriaId": "4ADC6057-9D35-4D87-B15D-F6F52A283464"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.apple.com/archives/security-announce/2015/Apr/msg00001.html", "source": "secalert@redhat.com", "tags": ["Broken Link", "Mailing List"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-09/msg00046.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=141017844705317&w=2", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "http://mx.gw.com/pipermail/file/2014/001553.html", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1765.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1766.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://support.apple.com/kb/HT6443", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2974", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3021", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjan2015-2370101.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.php.net/ChangeLog-5.php", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/68243", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.php.net/bug.php?id=67326", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1091842", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://support.apple.com/HT204659", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391"}}