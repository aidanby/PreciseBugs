{"buggy_code": ["#!/bin/env python\nfrom flask import Flask\nfrom flask import flash,request,send_file,send_from_directory,redirect,render_template, abort\n\nfrom werkzeug.utils import secure_filename\nfrom ipaddress import ip_address, ip_network\nimport urllib.request\n\nimport os\nimport random\n\nimport hooker\n\nhooker.EVENTS.append(\"pre_process\",\n  help=\"Before any processing of the URL alias starts. Useful for UA filters, blacklists, etc\")\nhooker.EVENTS.append(\"pre_file\",\n  help=\"Before the alias resolves to a file\")\nhooker.EVENTS.append(\"pre_response\",\n  help=\"Before the created request is sent\")\n\nimport wormnest.db_handler as db_handler\nimport wormnest.utils as utils\n\n'''\nTo run the App:\npython3 app.py\n'''\napp = Flask(__name__)\n\nCONFIG = utils.parse_config()\n\napp.config['UPLOAD_FOLDER'] = CONFIG['SRV_DIR']\nprint(CONFIG['IP_WHITELIST'])\n# sys.exit(10)\n\ndef get_random_alias(length=None):\n  assert CONFIG['ALIAS_DIGITS_MIN'] <= CONFIG['ALIAS_DIGITS_MAX']\n  if length == None:\n    length = random.randint(CONFIG['ALIAS_DIGITS_MIN'], CONFIG['ALIAS_DIGITS_MAX'])\n  return utils.randomword(length)\n\n\ndef redirect_away():\n  return redirect(CONFIG['REDIRECT_URL'], code=302)\n\ndef abort_404():\n  return abort(404)\n\nbehaviours = {\n  'abort' : abort_404,\n  'redir' : redirect_away,\n}\n\ndefault_miss = behaviours.get(CONFIG['MISS'],'abort')\non_expired = behaviours.get(CONFIG['EXPIRE'],'abort')\nblacklisted = behaviours.get(CONFIG['BLACKLISTED'],'abort')\n\n\n@app.after_request\ndef add_header(response):\n  response.headers['Cache-Control'] = 'no-store'\n  del response.headers['Expires']\n  response.headers['Server'] = CONFIG['SERVER_HEADER']\n  response.headers['X-Content-Type-Options'] = \"nosniff\"\n  del response.headers['Date']\n\n  return response\n\n\n@app.route('/%s/' % CONFIG['MANAGE_URL_DIR'])\ndef show_manage():\n  return render_template(\n    \"manage_help.html\",\n    manage_url = request.base_url\n    )\n\n@app.route('/%s/load_defaults' % CONFIG['MANAGE_URL_DIR'])\ndef load_defaults():\n  add_url_template = \"http://127.0.0.1:{port}/{man}/add?path={path}&alias={alias}&unchecked=True\"\n  try:\n    if CONFIG['DEFAULT_PATHS_FILE']:\n      print(\"[+] Importing defaults from '{}'\".format(CONFIG['DEFAULT_PATHS_FILE']))\n      import json\n      with open(CONFIG['DEFAULT_PATHS_FILE']) as url_defaults:\n        defaults_url_dict = json.load(url_defaults)\n        for path, url_params in defaults_url_dict.items():\n          print(path, url_params)\n          alias = url_params['alias']\n          filename = url_params.get('filename',None)\n          print (filename)\n          if filename:\n            add_url_template += '&filename={filename}'\n          urllib.request.urlopen(add_url_template.format(\n              port=CONFIG['PORT'],\n              man=CONFIG['MANAGE_URL_DIR'],\n              path=path,\n              alias=alias,\n              filename=filename,\n              )\n            )\n    return \"<pre>{}</pre>\".format(\n      json.dumps(defaults_url_dict, indent=2)\n      )\n  except Exception as e:\n    return render_template(\"custom_error.html\",error_msg=str(e))\n\n@app.route(\n  '/%s/list/' % CONFIG['MANAGE_URL_DIR'],\n  defaults={'req_path': ''}\n  )\n\n@app.route('/%s/list/<path:req_path>' % CONFIG['MANAGE_URL_DIR'])\ndef dir_listing(req_path):\n  '''\n  Found here:\nhttps://stackoverflow.com/questions/23718236/python-flask-browsing-through-directory-with-files\n  '''\n  # Joining the base and the requested path\n  abs_path = os.path.join(CONFIG['SRV_DIR'], req_path)\n\n  # Return 404 if path doesn't exist\n  if not os.path.exists(abs_path):\n    return abort(404)\n\n  # Check if path is a file and serve\n  if os.path.isfile(abs_path):\n    return send_file(abs_path)\n\n  # Show directory contents\n  files = os.listdir(abs_path)\n  full_paths = []\n  for f in files:\n    full_paths.append(\n      (f, os.path.join(request.base_url, f))\n    )\n  # print (full_paths)\n  add_url_link = \"%s%s/add\" % (request.url_root, CONFIG['MANAGE_URL_DIR'])\n  return render_template('file.html',\n    files=full_paths,\n    add_url=add_url_link\n    )\n\n\n@app.route('/%s/add' % CONFIG['MANAGE_URL_DIR'])\ndef add_url():\n\n  path = request.args.get(\"path\")\n  expires = request.args.get(\"clicks\", -1)\n  alias = request.args.get(\"alias\", get_random_alias())\n  attach_name = request.args.get(\"filename\")\n  mimetype = request.args.get(\"mime\", None)\n  unchecked_path = request.args.get(\"unchecked\", False)\n  if not request.args:\n    return render_template(\n      'add_help.html', \n    )\n  try:\n    original_filename = path.split('/')[-1]\n    original_extension = original_filename.split('.')[-1]\n  except Exception as e:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"The 'path' variable does not validate\"\n      )\n\n  if original_filename == original_extension:\n    # If they are the same, there is no extension\n    original_extension = ''\n  else:\n    original_extension = '.' + original_extension\n\n  if not attach_name:\n\n    if not CONFIG['DEFAULT_FILENAME']:\n      # The filename is the path's filename\n      attach_name = original_filename\n    else:\n      attach_name = CONFIG['DEFAULT_FILENAME']\n      if CONFIG['USE_ORIGINAL_EXTENSION']:\n        attach_name += original_extension\n\n  path = os.path.join(CONFIG['SRV_DIR'], path)\n  if not os.path.isfile(path) and not unchecked_path:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"The path '{}' is NOT a file\".format(path)\n      )\n\n  try:\n    if expires is not None: \n      int(expires)\n  except:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"Parameter 'clicks' must be positive Integer\"\n      )\n  try:\n    db_handler.add_url(\n      path, alias, expires,\n      attachment = attach_name,\n      mimetype = mimetype\n      )\n  except Exception as e:\n    print (e)\n    err =  \"Error adding alias '{}'' for path '{}'\".format(alias, path)\n    return render_template(\n      'custom_error.html', \n      error_msg=err\n      )\n  full_link = request.url_root + alias\n  return render_template(\n      'added_alias.html', \n      alias=alias,\n      path=path,\n      clicks=expires,\n      link=full_link\n      )\n\n@app.route('/%s/del' % CONFIG['MANAGE_URL_DIR'], methods=[\"GET\", \"POST\"])\ndef del_url():\n  alias = request.args.get(\"alias\", None) \n  if alias is None:\n    alias = request.form.get(\"alias\", None)\n    if alias is None:\n      return render_template(\n        'del_help.html'\n        )\n  try:\n    deleted = db_handler.del_url(alias)\n  except KeyError:\n    deleted = False\n  return \"Deleted '/%s'\" % alias if deleted else \"NOT deleted\"\n\n@app.route('/%s/config' % CONFIG['MANAGE_URL_DIR'])\ndef show_config(path=None):\n    return render_template('show_config.html', entries=CONFIG)\n    \n@app.route('/%s/show' % CONFIG['MANAGE_URL_DIR'])\ndef show_all(path=None):\n  entries = db_handler.get_all(path)\n  return render_template(\n        'show.html',  # Fix show.html to contain mimetypes\n        entries = entries\n        )\n\n@app.route(\n  '/%s/upload' % CONFIG['MANAGE_URL_DIR'],\n  methods=['POST', 'GET']\n  )\ndef file_upload():\n  if request.method == 'POST':\n    # check if the post request has the file part\n    if 'file' not in request.files:\n      return render_template(\n          'upload_page.html',\n          manage_url = CONFIG['MANAGE_URL_DIR'],\n          message = \"No file submitted\"\n        )\n    file = request.files['file']\n    # if user does not select file, browser also\n    # submit a empty part without filename\n    if file.filename == '':\n      return render_template(\n            'upload_page.html',\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            message = \"No filename submitted\"\n          )\n    if file:\n      filename = request.form.get('filename', file.filename)\n      filename = secure_filename(filename)\n      try:\n        file.save(\n          os.path.join(\n            app.config['UPLOAD_FOLDER'],\n            filename\n            )\n          )\n      except IsADirectoryError:\n        return render_template(\n              'upload_page.html',\n              manage_url = CONFIG['MANAGE_URL_DIR'],\n              message = \"Filename exists\"\n            )\n\n      if request.form.get(\"create_alias\",\n        default = False,\n        type = bool):\n        alias_name = request.form.get(\"alias\", default=None)\n        deliver_filename = request.form.get(\"deliver_filename\", default=None)\n        return redirect(\n          \"/{manage_url}/add?path={filepath}{alias}{filename}\".format(\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            filepath = filename,\n                                                alias=\"\" if not alias_name else \"&alias=%s\" % alias_name,\n                  filename=\"\" if not deliver_filename else \"&filename=%s\" % deliver_filename,\n                                            )\n          )\n      return render_template(\n            'upload_page.html',\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            message = \"File '{}' uploaded successfully!\".format(filename)\n          )\n  return render_template(\n        'upload_page.html',\n        manage_url = CONFIG['MANAGE_URL_DIR'],\n      )\n\n#  Default behaviour - Serve all non \"/manage\" paths\n@app.route('/<path:url_alias>', methods=['POST', 'GET'])\n@app.route('/', defaults={'url_alias': ''}, methods=['POST', 'GET'])\ndef resolve_url(url_alias):\n  ret_response = None\n  # check if whitelisted/blacklisted ip\n  remote_host = ip_address(request.remote_addr)\n  if utils.is_listed(CONFIG['IP_BLACKLIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  if not utils.is_listed(CONFIG['IP_WHITELIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  if utils.is_geolocation_listed(CONFIG['GEOLOCATION_BLACKLIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  # Run \"pre_process\" hook checks\n  hook_ret = hooker.EVENTS[\"pre_process\"](\n    request=request,\n    url_alias=url_alias,\n  )\n  #  In case the hook changed the original request\n  url_alias = request.path[1:]  # Remove the '/'\n  print(\"[*] %s\" % url_alias)\n  try:\n    behaviour = hook_ret.popitem()[1]\n    # Get the behavior from the list and generate its response:\n    if behaviour is not None:\n      ret_response = behaviours.get(behaviour, abort_404)()\n      return hook_n_respond(request, ret_response)\n  except KeyError:\n    pass\n\n  # Check if URL Alias exists\n  try:\n    alias_db_obj = db_handler.get_path(url_alias)\n  except KeyError:\n    # Non-existent\n    ret_response = default_miss()\n    return hook_n_respond(request, ret_response)\n  except utils.LinkExpired:\n    # Existent and expired\n    ret_response = on_expired()\n    return hook_n_respond(request, ret_response)\n\n  path = alias_db_obj.path\n  # Run the hooks for iconic filenames\n  hook_ret = hooker.EVENTS[\"pre_file\"](\n    filename=path,\n    request=request,\n    )\n  try:\n    iconic_fd = hook_ret.popitem()[1]\n  except KeyError:\n    iconic_fd = None\n\n  if iconic_fd:\n    print(\n      \"[+] Filename '{}' HOOKED! A Custom file is served!\".format(\n        alias_db_obj.path\n        )\n      )\n  # If it succeds the returned fd will be served \n    ret_fd = iconic_fd\n    ret_response = send_file(\n        filename_or_fp = ret_fd,\n        as_attachment = True,\n        attachment_filename = alias_db_obj.attachment,\n        mimetype = alias_db_obj.mimetype,\n      )\n    return hook_n_respond(request, ret_response)\n\n  # Else the file file system is checked for real files\n  print(path, os.path.isfile(path))\n  if not os.path.isfile(path):    \n    # If doensn't exist, 'miss' behaviour is triggered\n    ret_response = default_miss()\n    return hook_n_respond(request, ret_response)\n\n  ret_fd = open(path,'rb')\n  # hook_ret = hooker.EVENTS[\"post_file\"](\n  #   filename=path,\n  #   request=request,\n  #   fd=ret_fd\n  #   )\n\n  ret_response = send_file(\n      filename_or_fp = ret_fd,\n      as_attachment = True,\n      attachment_filename = alias_db_obj.attachment,\n      mimetype = alias_db_obj.mimetype,\n    )\n\n  return hook_n_respond(request, ret_response)\n\n\ndef hook_n_respond(request, response):\n  hook_ret = hooker.EVENTS[\"pre_response\"](\n    request=request,\n    response=response\n    )\n  try:\n    ret_response_final = hook_ret.popitem()[1]\n  except KeyError:\n    ret_response_final = response\n  return ret_response_final\n\n\ndef main(*args, **kwargs):\n\n  utils.log_spawn(CONFIG['LOG_SPAWN_FILE'], CONFIG['MANAGE_URL_DIR'], CONFIG['PORT'])\n  app.run(\n    host=CONFIG['IP'],\n    port=CONFIG['PORT'],\n    debug=os.getenv(\"DEBUG\", False)\n  )\n\nif __name__==\"__main__\":\n  main()\n"], "fixing_code": ["#!/bin/env python\nfrom flask import Flask\nfrom flask import flash,request,send_file,send_from_directory,redirect,render_template, abort, safe_join\n\nfrom werkzeug.utils import secure_filename\nfrom ipaddress import ip_address, ip_network\nimport urllib.request\n\nimport os\nimport random\n\nimport hooker\n\nhooker.EVENTS.append(\"pre_process\",\n  help=\"Before any processing of the URL alias starts. Useful for UA filters, blacklists, etc\")\nhooker.EVENTS.append(\"pre_file\",\n  help=\"Before the alias resolves to a file\")\nhooker.EVENTS.append(\"pre_response\",\n  help=\"Before the created request is sent\")\n\nimport wormnest.db_handler as db_handler\nimport wormnest.utils as utils\n\n'''\nTo run the App:\npython3 app.py\n'''\napp = Flask(__name__)\n\nCONFIG = utils.parse_config()\n\napp.config['UPLOAD_FOLDER'] = CONFIG['SRV_DIR']\nprint(CONFIG['IP_WHITELIST'])\n# sys.exit(10)\n\ndef get_random_alias(length=None):\n  assert CONFIG['ALIAS_DIGITS_MIN'] <= CONFIG['ALIAS_DIGITS_MAX']\n  if length == None:\n    length = random.randint(CONFIG['ALIAS_DIGITS_MIN'], CONFIG['ALIAS_DIGITS_MAX'])\n  return utils.randomword(length)\n\n\ndef redirect_away():\n  return redirect(CONFIG['REDIRECT_URL'], code=302)\n\ndef abort_404():\n  return abort(404)\n\nbehaviours = {\n  'abort' : abort_404,\n  'redir' : redirect_away,\n}\n\ndefault_miss = behaviours.get(CONFIG['MISS'],'abort')\non_expired = behaviours.get(CONFIG['EXPIRE'],'abort')\nblacklisted = behaviours.get(CONFIG['BLACKLISTED'],'abort')\n\n\n@app.after_request\ndef add_header(response):\n  response.headers['Cache-Control'] = 'no-store'\n  del response.headers['Expires']\n  response.headers['Server'] = CONFIG['SERVER_HEADER']\n  response.headers['X-Content-Type-Options'] = \"nosniff\"\n  del response.headers['Date']\n\n  return response\n\n\n@app.route('/%s/' % CONFIG['MANAGE_URL_DIR'])\ndef show_manage():\n  return render_template(\n    \"manage_help.html\",\n    manage_url = request.base_url\n    )\n\n@app.route('/%s/load_defaults' % CONFIG['MANAGE_URL_DIR'])\ndef load_defaults():\n  add_url_template = \"http://127.0.0.1:{port}/{man}/add?path={path}&alias={alias}&unchecked=True\"\n  try:\n    if CONFIG['DEFAULT_PATHS_FILE']:\n      print(\"[+] Importing defaults from '{}'\".format(CONFIG['DEFAULT_PATHS_FILE']))\n      import json\n      with open(CONFIG['DEFAULT_PATHS_FILE']) as url_defaults:\n        defaults_url_dict = json.load(url_defaults)\n        for path, url_params in defaults_url_dict.items():\n          print(path, url_params)\n          alias = url_params['alias']\n          filename = url_params.get('filename',None)\n          print (filename)\n          if filename:\n            add_url_template += '&filename={filename}'\n          urllib.request.urlopen(add_url_template.format(\n              port=CONFIG['PORT'],\n              man=CONFIG['MANAGE_URL_DIR'],\n              path=path,\n              alias=alias,\n              filename=filename,\n              )\n            )\n    return \"<pre>{}</pre>\".format(\n      json.dumps(defaults_url_dict, indent=2)\n      )\n  except Exception as e:\n    return render_template(\"custom_error.html\",error_msg=str(e))\n\n@app.route(\n  '/%s/list/' % CONFIG['MANAGE_URL_DIR'],\n  defaults={'req_path': ''}\n  )\n\n@app.route('/%s/list/<path:req_path>' % CONFIG['MANAGE_URL_DIR'])\ndef dir_listing(req_path):\n  '''\n  Found here:\nhttps://stackoverflow.com/questions/23718236/python-flask-browsing-through-directory-with-files\n  '''\n  # Joining the base and the requested path\n  abs_path = safe_join(CONFIG['SRV_DIR'], req_path)\n\n  # Return 404 if path doesn't exist\n  if not os.path.exists(abs_path):\n    return abort(404)\n\n  # Check if path is a file and serve\n  if os.path.isfile(abs_path):\n    return send_file(abs_path)\n\n  # Show directory contents\n  files = os.listdir(abs_path)\n  full_paths = []\n  for f in files:\n    full_paths.append(\n      (f, os.path.join(request.base_url, f))\n    )\n  # print (full_paths)\n  add_url_link = \"%s%s/add\" % (request.url_root, CONFIG['MANAGE_URL_DIR'])\n  return render_template('file.html',\n    files=full_paths,\n    add_url=add_url_link\n    )\n\n\n@app.route('/%s/add' % CONFIG['MANAGE_URL_DIR'])\ndef add_url():\n\n  path = request.args.get(\"path\")\n  expires = request.args.get(\"clicks\", -1)\n  alias = request.args.get(\"alias\", get_random_alias())\n  attach_name = request.args.get(\"filename\")\n  mimetype = request.args.get(\"mime\", None)\n  unchecked_path = request.args.get(\"unchecked\", False)\n  if not request.args:\n    return render_template(\n      'add_help.html', \n    )\n  try:\n    original_filename = path.split('/')[-1]\n    original_extension = original_filename.split('.')[-1]\n  except Exception as e:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"The 'path' variable does not validate\"\n      )\n\n  if original_filename == original_extension:\n    # If they are the same, there is no extension\n    original_extension = ''\n  else:\n    original_extension = '.' + original_extension\n\n  if not attach_name:\n\n    if not CONFIG['DEFAULT_FILENAME']:\n      # The filename is the path's filename\n      attach_name = original_filename\n    else:\n      attach_name = CONFIG['DEFAULT_FILENAME']\n      if CONFIG['USE_ORIGINAL_EXTENSION']:\n        attach_name += original_extension\n\n  path = os.path.join(CONFIG['SRV_DIR'], path)\n  if not os.path.isfile(path) and not unchecked_path:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"The path '{}' is NOT a file\".format(path)\n      )\n\n  try:\n    if expires is not None: \n      int(expires)\n  except:\n    return render_template(\n      'custom_error.html', \n      error_msg=\"Parameter 'clicks' must be positive Integer\"\n      )\n  try:\n    db_handler.add_url(\n      path, alias, expires,\n      attachment = attach_name,\n      mimetype = mimetype\n      )\n  except Exception as e:\n    print (e)\n    err =  \"Error adding alias '{}'' for path '{}'\".format(alias, path)\n    return render_template(\n      'custom_error.html', \n      error_msg=err\n      )\n  full_link = request.url_root + alias\n  return render_template(\n      'added_alias.html', \n      alias=alias,\n      path=path,\n      clicks=expires,\n      link=full_link\n      )\n\n@app.route('/%s/del' % CONFIG['MANAGE_URL_DIR'], methods=[\"GET\", \"POST\"])\ndef del_url():\n  alias = request.args.get(\"alias\", None) \n  if alias is None:\n    alias = request.form.get(\"alias\", None)\n    if alias is None:\n      return render_template(\n        'del_help.html'\n        )\n  try:\n    deleted = db_handler.del_url(alias)\n  except KeyError:\n    deleted = False\n  return \"Deleted '/%s'\" % alias if deleted else \"NOT deleted\"\n\n@app.route('/%s/config' % CONFIG['MANAGE_URL_DIR'])\ndef show_config(path=None):\n    return render_template('show_config.html', entries=CONFIG)\n    \n@app.route('/%s/show' % CONFIG['MANAGE_URL_DIR'])\ndef show_all(path=None):\n  entries = db_handler.get_all(path)\n  return render_template(\n        'show.html',  # Fix show.html to contain mimetypes\n        entries = entries\n        )\n\n@app.route(\n  '/%s/upload' % CONFIG['MANAGE_URL_DIR'],\n  methods=['POST', 'GET']\n  )\ndef file_upload():\n  if request.method == 'POST':\n    # check if the post request has the file part\n    if 'file' not in request.files:\n      return render_template(\n          'upload_page.html',\n          manage_url = CONFIG['MANAGE_URL_DIR'],\n          message = \"No file submitted\"\n        )\n    file = request.files['file']\n    # if user does not select file, browser also\n    # submit a empty part without filename\n    if file.filename == '':\n      return render_template(\n            'upload_page.html',\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            message = \"No filename submitted\"\n          )\n    if file:\n      filename = request.form.get('filename', file.filename)\n      filename = secure_filename(filename)\n      try:\n        file.save(\n          os.path.join(\n            app.config['UPLOAD_FOLDER'],\n            filename\n            )\n          )\n      except IsADirectoryError:\n        return render_template(\n              'upload_page.html',\n              manage_url = CONFIG['MANAGE_URL_DIR'],\n              message = \"Filename exists\"\n            )\n\n      if request.form.get(\"create_alias\",\n        default = False,\n        type = bool):\n        alias_name = request.form.get(\"alias\", default=None)\n        deliver_filename = request.form.get(\"deliver_filename\", default=None)\n        return redirect(\n          \"/{manage_url}/add?path={filepath}{alias}{filename}\".format(\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            filepath = filename,\n                                                alias=\"\" if not alias_name else \"&alias=%s\" % alias_name,\n                  filename=\"\" if not deliver_filename else \"&filename=%s\" % deliver_filename,\n                                            )\n          )\n      return render_template(\n            'upload_page.html',\n            manage_url = CONFIG['MANAGE_URL_DIR'],\n            message = \"File '{}' uploaded successfully!\".format(filename)\n          )\n  return render_template(\n        'upload_page.html',\n        manage_url = CONFIG['MANAGE_URL_DIR'],\n      )\n\n#  Default behaviour - Serve all non \"/manage\" paths\n@app.route('/<path:url_alias>', methods=['POST', 'GET'])\n@app.route('/', defaults={'url_alias': ''}, methods=['POST', 'GET'])\ndef resolve_url(url_alias):\n  ret_response = None\n  # check if whitelisted/blacklisted ip\n  remote_host = ip_address(request.remote_addr)\n  if utils.is_listed(CONFIG['IP_BLACKLIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  if not utils.is_listed(CONFIG['IP_WHITELIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  if utils.is_geolocation_listed(CONFIG['GEOLOCATION_BLACKLIST'], remote_host):\n    ret_response = blacklisted()\n    return hook_n_respond(request, ret_response)\n\n  # Run \"pre_process\" hook checks\n  hook_ret = hooker.EVENTS[\"pre_process\"](\n    request=request,\n    url_alias=url_alias,\n  )\n  #  In case the hook changed the original request\n  url_alias = request.path[1:]  # Remove the '/'\n  print(\"[*] %s\" % url_alias)\n  try:\n    behaviour = hook_ret.popitem()[1]\n    # Get the behavior from the list and generate its response:\n    if behaviour is not None:\n      ret_response = behaviours.get(behaviour, abort_404)()\n      return hook_n_respond(request, ret_response)\n  except KeyError:\n    pass\n\n  # Check if URL Alias exists\n  try:\n    alias_db_obj = db_handler.get_path(url_alias)\n  except KeyError:\n    # Non-existent\n    ret_response = default_miss()\n    return hook_n_respond(request, ret_response)\n  except utils.LinkExpired:\n    # Existent and expired\n    ret_response = on_expired()\n    return hook_n_respond(request, ret_response)\n\n  path = alias_db_obj.path\n  # Run the hooks for iconic filenames\n  hook_ret = hooker.EVENTS[\"pre_file\"](\n    filename=path,\n    request=request,\n    )\n  try:\n    iconic_fd = hook_ret.popitem()[1]\n  except KeyError:\n    iconic_fd = None\n\n  if iconic_fd:\n    print(\n      \"[+] Filename '{}' HOOKED! A Custom file is served!\".format(\n        alias_db_obj.path\n        )\n      )\n  # If it succeds the returned fd will be served \n    ret_fd = iconic_fd\n    ret_response = send_file(\n        filename_or_fp = ret_fd,\n        as_attachment = True,\n        attachment_filename = alias_db_obj.attachment,\n        mimetype = alias_db_obj.mimetype,\n      )\n    return hook_n_respond(request, ret_response)\n\n  # Else the file file system is checked for real files\n  print(path, os.path.isfile(path))\n  if not os.path.isfile(path):    \n    # If doensn't exist, 'miss' behaviour is triggered\n    ret_response = default_miss()\n    return hook_n_respond(request, ret_response)\n\n  ret_fd = open(path,'rb')\n  # hook_ret = hooker.EVENTS[\"post_file\"](\n  #   filename=path,\n  #   request=request,\n  #   fd=ret_fd\n  #   )\n\n  ret_response = send_file(\n      filename_or_fp = ret_fd,\n      as_attachment = True,\n      attachment_filename = alias_db_obj.attachment,\n      mimetype = alias_db_obj.mimetype,\n    )\n\n  return hook_n_respond(request, ret_response)\n\n\ndef hook_n_respond(request, response):\n  hook_ret = hooker.EVENTS[\"pre_response\"](\n    request=request,\n    response=response\n    )\n  try:\n    ret_response_final = hook_ret.popitem()[1]\n  except KeyError:\n    ret_response_final = response\n  return ret_response_final\n\n\ndef main(*args, **kwargs):\n\n  utils.log_spawn(CONFIG['LOG_SPAWN_FILE'], CONFIG['MANAGE_URL_DIR'], CONFIG['PORT'])\n  app.run(\n    host=CONFIG['IP'],\n    port=CONFIG['PORT'],\n    debug=os.getenv(\"DEBUG\", False)\n  )\n\nif __name__==\"__main__\":\n  main()\n"], "filenames": ["app.py"], "buggy_code_start_loc": [3], "buggy_code_end_loc": [120], "fixing_code_start_loc": [3], "fixing_code_end_loc": [120], "type": "CWE-22", "message": "The operatorequals/wormnest repository through 0.4.7 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely.", "other": {"cve": {"id": "CVE-2022-31502", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-11T01:15:08.083", "lastModified": "2022-07-15T12:09:40.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The operatorequals/wormnest repository through 0.4.7 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely."}, {"lang": "es", "value": "El repositorio operatorequals/wormnest versiones hasta 0.4.7, en GitHub, permite un salto de ruta absoluto porque la funci\u00f3n send_file de Flask es usada de forma no segura"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wormnest_project:wormnest:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.7", "matchCriteriaId": "55DE4788-AF76-4775-85A5-735114998211"}]}]}], "references": [{"url": "https://github.com/github/securitylab/issues/669#issuecomment-1117265726", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/operatorequals/wormnest/commit/2dfe96fc2570586ac487b399ac20d41b3c114861", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/operatorequals/wormnest/commit/2dfe96fc2570586ac487b399ac20d41b3c114861"}}