{"buggy_code": ["/* radare - LGPL - Copyright 2014-2022 - Fedor Sakharov, pancake */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include <r_util.h>\n\n#include \"../arch/msp430/msp430_disas.h\"\n\nstatic int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tint ret;\n\tstruct msp430_cmd cmd;\n\n\tmemset (&cmd, 0, sizeof (cmd));\n\t//op->id = ???;\n\top->size = -1;\n\top->nopcode = 1;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->family = R_ANAL_OP_FAMILY_CPU;\n\n\tret = op->size = msp430_decode_command (buf, len, &cmd);\n\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\tif (ret < 1) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t} else if (ret > 0) {\n\t\t\tif (cmd.operands[0]) {\n\t\t\t\top->mnemonic = r_str_newf (\"%s %s\",cmd.instr, cmd.operands);\n\t\t\t} else {\n\t\t\t\top->mnemonic = strdup (cmd.instr);\n\t\t\t}\n\t\t}\n\t\t{ // if (a->syntax != R_ASM_SYNTAX_ATT)\n\t\t\tchar *ba = op->mnemonic;\n\t\t\tr_str_replace_ch (ba, '#', 0, 1);\n\t\t\t// r_str_replace_ch (ba, \"$\", \"$$\", 1);\n\t\t\tr_str_replace_ch (ba, '&', 0, 1);\n\t\t\tr_str_replace_ch (ba, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\top->addr = addr;\n\n\tswitch (cmd.type) {\n\tcase MSP430_ONEOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_RRA:\n\t\tcase MSP430_RRC:\n\t\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\t\tbreak;\n\t\tcase MSP430_PUSH:\n\t\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t\tbreak;\n\t\tcase MSP430_CALL:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->fail = addr + op->size;\n\t\t\top->jump = r_read_at_le16 (buf, 2);\n\t\t\tbreak;\n\t\tcase MSP430_RETI:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MSP430_TWOOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_BIT:\n\t\tcase MSP430_BIC:\n\t\tcase MSP430_BIS:\n\t\tcase MSP430_MOV:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tif ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {\n\t\t\t\t// Emulated branch instruction, moves source operand to PC register.\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_DADD:\n\t\tcase MSP430_ADDC:\n\t\tcase MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;\n\t\tcase MSP430_SUBC:\n\t\tcase MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;\n\t\tcase MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;\n\t\tcase MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;\n\t\tcase MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;\n\t\t}\n\t\tbreak;\n\tcase MSP430_JUMP:\n\t\tif (cmd.jmp_cond == MSP430_JMP) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t}\n\t\top->jump = addr + cmd.jmp_addr;\n\t\top->fail = addr + 2;\n\t\tbreak;\n\tcase MSP430_INV:\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t// this is the \"new\" ABI, the old was reverse order\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\n\t\t\"gpr\tpc\t.16 0 0\\n\" // same as r0\n\t\t\"gpr\tsp\t.16 2 0\\n\" // same as r1\n\t\t\"flg\tsr\t.16 4 0\\n\" // same as r2\n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t// between is SCG1 SCG0 OSOFF CPUOFF GIE\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nRAnalPlugin r_anal_plugin_msp430 = {\n\t.name = \"msp430\",\n\t.desc = \"TI MSP430 code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"msp430\",\n\t.bits = 16,\n\t.op = msp430_op,\n\t.set_reg_profile = &set_reg_profile,\n};\n", "/* radare - LGPL - Copyright 2008-2022 - nibble, pancake, alvaro_fe */\n\n#define R_LOG_ORIGIN \"elf\"\n#include <r_types.h>\n#include <r_util.h>\n#include \"elf.h\"\n\n#define MIPS_PLT_OFFSET 0x20\n#define RISCV_PLT_OFFSET 0x20\n#define LOONGARCH_PLT_OFFSET 0x20\n\n#define RISCV_PLT_ENTRY_SIZE 0x10\n#define LOONGARCH_PLT_ENTRY_SIZE 0x10\n#define X86_PLT_ENTRY_SIZE 0x10\n\n#define SPARC_OFFSET_PLT_ENTRY_FROM_GOT_ADDR -0x6\n#define X86_OFFSET_PLT_ENTRY_FROM_GOT_ADDR -0x6\n\n#define ELF_PAGE_MASK 0xFFFFFFFFFFFFF000LL\n#define ELF_PAGE_SIZE 12\n\n#define R_ELF_NO_RELRO 0\n#define R_ELF_PART_RELRO 1\n#define R_ELF_FULL_RELRO 2\n\n#define MAX_REL_RELA_SZ (sizeof (Elf_(Rel)) > sizeof (Elf_(Rela))? sizeof (Elf_(Rel)): sizeof (Elf_(Rela)))\n\n#define READ8(x, i) r_read_ble8((x) + (i)); (i) += 1\n#define READ16(x, i) r_read_ble16((x) + (i), bin->endian); (i) += 2\n#define READ32(x, i) r_read_ble32((x) + (i), bin->endian); (i) += 4\n#define READ64(x, i) r_read_ble64((x) + (i), bin->endian); (i) += 8\n\n#define BREAD8(x, i) r_buf_read_ble8_at (x, i); (i) += 1\n#define BREAD16(x, i) r_buf_read_ble16_at (x, i, bin->endian); (i) += 2\n#define BREAD32(x, i) r_buf_read_ble32_at (x, i, bin->endian); (i) += 4\n#define BREAD64(x, i) r_buf_read_ble64_at (x, i, bin->endian); (i) += 8\n\n#define NUMENTRIES_ROUNDUP(sectionsize, entrysize) (((sectionsize) + (entrysize)-1) / (entrysize))\n#define COMPUTE_PLTGOT_POSITION(rel, pltgot_addr, n_initial_unused_entries) \\\n\t((rel->rva - pltgot_addr - n_initial_unused_entries * R_BIN_ELF_WORDSIZE) / R_BIN_ELF_WORDSIZE)\n\n#define GROWTH_FACTOR (1.5)\n\n#define round_up(a) ((((a) + (4) - (1)) / (4)) * (4))\n\n#define EF_MIPS_ABI_O32\t\t0x00001000  /* O32 ABI.  */\n#define EF_MIPS_ABI_O64\t\t0x00002000  /* O32 extended for 64 bit.  */\n#define EF_MIPS_ABI\t\t\t0x0000f000\n\nstatic inline bool is_elfclass64(Elf_(Ehdr) *h) {\n\treturn h->e_ident[EI_CLASS] == ELFCLASS64;\n}\n\nstatic bool is_mips_o32(Elf_(Ehdr) *h) {\n\tif (h->e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\tif ((h->e_flags & EF_MIPS_ABI2) != 0) {\n\t\treturn false;\n\t}\n\tif (((h->e_flags & EF_MIPS_ABI) != 0) &&\n\t\t((h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool is_mips_n32(Elf_(Ehdr) *h) {\n\tif (h->e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\tif (((h->e_flags & EF_MIPS_ABI2) == 0) ||\n\t\t((h->e_flags & EF_MIPS_ABI) != 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nenum {\n\tX86,\n\tX86_64,\n\tARM,\n\tAARCH64,\n\tRCE,\n\tARCH_LEN\n};\n\ntypedef struct reginfo {\n\tut32 regsize;\n\tut32 regdelta;\n} reginfo_t;\n\nstatic reginfo_t reginf[ARCH_LEN] = {\n\t{ 160, 0x5c },\n\t{ 216, 0x84 },\n\t{ 72, 0x5c },\n\t{ 272, 0x84 },\n\t{ 272, 0x84 }\n};\n\nstatic inline int __strnlen(const char *str, int len) {\n\tint l = 0;\n\twhile (IS_PRINTABLE (*str) && --len) {\n\t\tif (((ut8)*str) == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tl++;\n\t}\n\treturn l + 1;\n}\n\nstatic bool is_bin_etrel(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type == ET_REL;\n}\n\nstatic bool __is_valid_ident(ELFOBJ *bin) {\n\treturn !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||\n\t\t!strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);\n}\n\nstatic bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (bin->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (bin->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (bin->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (bin->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n\tsdb_set (bin->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);\n\tbin->ehdr.e_machine = READ16 (ehdr, i);\n\tbin->ehdr.e_version = READ32 (ehdr, i);\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i);\n\tbin->ehdr.e_phoff = READ64 (ehdr, i);\n\tbin->ehdr.e_shoff = READ64 (ehdr, i);\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i);\n\tbin->ehdr.e_phoff = READ32 (ehdr, i);\n\tbin->ehdr.e_shoff = READ32 (ehdr, i);\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i);\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_shnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i);\n\treturn true;\n\t// [Outdated] Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}\n\nut64 Elf_(r_bin_elf_get_phnum)(ELFOBJ *obj) {\n\tr_return_val_if_fail (obj, 0);\n\tut64 num = obj->ehdr.e_phnum & UT16_MAX;\n\tif (obj->ehdr.e_phnum == 0xffff) {\n\t\tut32 shnum = obj->ehdr.e_shnum;\n\t\t// sh_info member of the initial entry in section header table.\n\t\tif (shnum > 0) {\n\t\t\tut32 shoff = obj->ehdr.e_shoff;\n\t\t\tElf_(Shdr) shdr = {0};\n\t\t\t(void)r_buf_read_at (obj->b, shoff, (ut8 *)&shdr, sizeof (shdr));\n\t\t\tnum = shdr.sh_info;\n\t\t\tif ((int)(shdr.sh_info) < 1) {\n\t\t\t\treturn UT16_MAX;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nstatic bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t//\tbin->phdr[i].p_flags |= 1; tiny.elf needs this somehow :? LOAD0 is always +x for linux?\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\t/* Here is the where all the fun starts.\n\t * Linux kernel since 2005 calculates phdr offset wrongly\n\t * adding it to the load address (va of the LOAD0).\n\t * See `fs/binfmt_elf.c` file this line:\n\t *    NEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\t * So after the first read, we fix the address and read it again\n\t */\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\n\treturn true;\n}\n\nstatic int init_phdr(ELFOBJ *bin) {\n\tut32 phdr_size;\n\n\tr_return_val_if_fail (bin && !bin->phdr, false);\n\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (!UT32_MUL (&phdr_size, (ut32)bin->ehdr.e_phnum, sizeof (Elf_(Phdr)))) {\n\t\treturn false;\n\t}\n\tif (!phdr_size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > (ut32)bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff + phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tif (!(bin->phdr = R_NEWS0 (Elf_(Phdr), phnum))) {\n\t\tr_sys_perror (\"malloc (phdr)\");\n\t\treturn false;\n\t}\n\n\tbool linux_kern_hack = false;\n\t/* Enable this hack only for the X86 64bit ELFs */\n\tconst int _128K = 1024 * 128;\n\tif (r_buf_size (bin->b) > _128K && (bin->ehdr.e_machine == EM_X86_64 || bin->ehdr.e_machine == EM_386)) {\n\t\tlinux_kern_hack = true;\n\t}\n\tif (!read_phdr (bin, linux_kern_hack)) {\n\t\treturn false;\n\t}\n\n\tsdb_num_set (bin->kv, \"elf_phdr.offset\", bin->ehdr.e_phoff, 0);\n\tsdb_num_set (bin->kv, \"elf_phdr.size\", sizeof (Elf_(Phdr)), 0);\n\tsdb_set (bin->kv, \"elf_p_type.cparse\", \"enum elf_p_type {PT_NULL=0,PT_LOAD=1,PT_DYNAMIC=2,\"\n\t\t\"PT_INTERP=3,PT_NOTE=4,PT_SHLIB=5,PT_PHDR=6,PT_LOOS=0x60000000,\"\n\t\t\"PT_HIOS=0x6fffffff,PT_LOPROC=0x70000000,PT_HIPROC=0x7fffffff};\",\n\t\t0);\n\tsdb_set (bin->kv, \"elf_p_flags.cparse\", \"enum elf_p_flags {PF_None=0,PF_Exec=1,\"\n\t\t\t\"PF_Write=2,PF_Write_Exec=3,PF_Read=4,PF_Read_Exec=5,PF_Read_Write=6,\"\n\t\t\t\"PF_Read_Write_Exec=7};\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags\"\n\t\t\t\" offset vaddr paddr filesz memsz align\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr\"\n\t\t\t\" filesz memsz (elf_p_flags)flags align\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_p_type.cparse`; td `k bin/cur/info/elf_p_flags.cparse`\n\t// > pf `k bin/cur/info/elf_phdr.format` @ `k bin/cur/info/elf_phdr.offset`\n}\n\nstatic int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tsize_t i, j, len;\n\n\tr_return_val_if_fail (bin && !bin->shdr, false);\n\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = R_NEWS0 (Elf_(Shdr), bin->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_flags = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_addr = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_offset = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_size = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_addralign = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_entsize = R_BIN_ELF_READWORD (shdr, j);\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}\n\nstatic bool is_shidx_valid(ELFOBJ *bin, Elf_(Half) value) {\n\treturn value < bin->ehdr.e_shnum && !R_BETWEEN (SHN_LORESERVE, value, SHN_HIRESERVE);\n}\n\nstatic int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\n\t/* sh_size must be lower than UT32_MAX and not equal to zero, to avoid bugs on malloc() */\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\n\treturn true;\n}\n\nstatic Elf_(Phdr) *get_dynamic_segment(ELFOBJ *bin) {\n\tint i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\tif (bin->phdr[i].p_filesz > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->phdr[i].p_offset > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->phdr[i].p_offset + sizeof (Elf_(Dyn)) > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn &bin->phdr[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void init_dynamic_section_sdb(ELFOBJ *bin, Elf_(Addr) strtabaddr, size_t strsize) {\n\tint r = Elf_(r_bin_elf_has_relro) (bin);\n\tswitch (r) {\n\tcase R_ELF_FULL_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"full\", 0);\n\t\tbreak;\n\tcase R_ELF_PART_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"partial\", 0);\n\t\tbreak;\n\tdefault:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"no\", 0);\n\t\tbreak;\n\t}\n\tsdb_num_set (bin->kv, \"elf_strtab.offset\", strtabaddr, 0);\n\tsdb_num_set (bin->kv, \"elf_strtab.size\", strsize, 0);\n}\n\nstatic void set_default_value_dynamic_info(ELFOBJ *bin) {\n\tbin->dyn_info.dt_pltrelsz = 0;\n\tbin->dyn_info.dt_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_hash = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_strtab = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_symtab = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_rela = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_relasz = 0;\n\tbin->dyn_info.dt_relaent = 0;\n\tbin->dyn_info.dt_strsz = 0;\n\tbin->dyn_info.dt_syment = 0;\n\tbin->dyn_info.dt_rel = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_relsz = 0;\n\tbin->dyn_info.dt_relent = 0;\n\tbin->dyn_info.dt_pltrel = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_jmprel = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_mips_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_bind_now = false;\n\tbin->dyn_info.dt_flags = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_flags_1 = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_rpath = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_runpath = R_BIN_ELF_XWORD_MAX;\n\tr_vector_init(&bin->dyn_info.dt_needed, sizeof (Elf_(Off)), NULL, NULL);\n}\n\nstatic size_t get_maximum_number_of_dynamic_entries(ut64 dyn_size) {\n\treturn dyn_size / sizeof (Elf_(Dyn));\n}\n\nstatic bool fill_dynamic_entry(ELFOBJ *bin, ut64 entry_offset, Elf_(Dyn) *d) {\n\tut8 sdyn[sizeof (Elf_(Dyn))] = {0};\n\tint j = 0;\n\tint len = r_buf_read_at (bin->b, entry_offset, sdyn, sizeof (Elf_(Dyn)));\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\td->d_tag = R_BIN_ELF_READWORD (sdyn, j);\n\td->d_un.d_ptr = R_BIN_ELF_READWORD (sdyn, j);\n\n\treturn true;\n}\n\nstatic void fill_dynamic_entries(ELFOBJ *bin, ut64 loaded_offset, ut64 dyn_size) {\n\tElf_(Dyn) d = {0};\n\tsize_t i;\n\tsize_t number_of_entries = get_maximum_number_of_dynamic_entries(dyn_size);\n\n\tfor (i = 0; i < number_of_entries; i++) {\n\t\tut64 entry_offset = loaded_offset + i * sizeof (Elf_(Dyn));\n\t\tif (!fill_dynamic_entry (bin, entry_offset, &d)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (d.d_tag) {\n\t\tcase DT_NULL:\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tbin->dyn_info.dt_pltrelsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tbin->dyn_info.dt_pltgot = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_HASH:\n\t\t\tbin->dyn_info.dt_hash = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_STRTAB:\n\t\t\tbin->dyn_info.dt_strtab = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_SYMTAB:\n\t\t\tbin->dyn_info.dt_symtab = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\tbin->dyn_info.dt_rela = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\tbin->dyn_info.dt_relasz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELAENT:\n\t\t\tbin->dyn_info.dt_relaent = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_STRSZ:\n\t\t\tbin->dyn_info.dt_strsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_SYMENT:\n\t\t\tbin->dyn_info.dt_syment = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_REL:\n\t\t\tbin->dyn_info.dt_rel = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\tbin->dyn_info.dt_relsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELENT:\n\t\t\tbin->dyn_info.dt_relent = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTREL:\n\t\t\tbin->dyn_info.dt_pltrel = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\tbin->dyn_info.dt_jmprel = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_MIPS_PLTGOT:\n\t\t\tbin->dyn_info.dt_mips_pltgot = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_BIND_NOW:\n\t\t\tbin->dyn_info.dt_bind_now = true;\n\t\t\tbreak;\n\t\tcase DT_FLAGS:\n\t\t\tbin->dyn_info.dt_flags = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_FLAGS_1:\n\t\t\tbin->dyn_info.dt_flags_1 = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RPATH:\n\t\t\tbin->dyn_info.dt_rpath = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RUNPATH:\n\t\t\tbin->dyn_info.dt_runpath = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_NEEDED:\n\t\t\tr_vector_push (&bin->dyn_info.dt_needed, &d.d_un.d_val);\n\t\t\tbreak;\n\t\tcase DT_INIT:\n\t\tcase DT_FINI:\n\t\tcase DT_DEBUG:\n\t\tcase DT_INIT_ARRAY:\n\t\tcase DT_FINI_ARRAY:\n\t\tcase DT_INIT_ARRAYSZ:\n\t\tcase DT_FINI_ARRAYSZ:\n\t\tcase DT_PREINIT_ARRAY:\n\t\tcase DT_PREINIT_ARRAYSZ:\n\t\tcase DT_SONAME:\n\t\tcase DT_GNU_HASH:\n\t\t\t// common dynamic entries in ELF, but we don't need to\n\t\t\t// do anything with them.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((d.d_tag >= DT_VERSYM) && (d.d_tag <= DT_VERNEEDNUM)) {\n\t\t\t\tbin->version_info[DT_VERSIONTAGIDX (d.d_tag)] = d.d_un.d_val;\n\t\t\t} else {\n\t\t\t\tR_LOG_DEBUG (\"Dynamic tag %\" PFMT64d \" not handled\", (ut64) d.d_tag);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (d.d_tag == DT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int init_dynamic_section(ELFOBJ *bin) {\n\tut64 strtabaddr = 0;\n\tchar *strtab = NULL;\n\tsize_t strsize = 0;\n\tint r;\n\tut64 dyn_size = 0, loaded_offset;\n\tset_default_value_dynamic_info(bin);\n\n\tr_return_val_if_fail (bin, false);\n\tif (!bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\n\tElf_(Phdr) *dyn_phdr = get_dynamic_segment (bin);\n\tif (!dyn_phdr) {\n\t\treturn false;\n\t}\n\n\tdyn_size = dyn_phdr->p_filesz;\n\tloaded_offset = Elf_(r_bin_elf_v2p_new) (bin, dyn_phdr->p_vaddr);\n\tif (loaded_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tif (!dyn_size || loaded_offset + dyn_size > bin->size) {\n\t\treturn false;\n\t}\n\n\tfill_dynamic_entries (bin, loaded_offset, dyn_size);\n\n\tif (bin->dyn_info.dt_strtab != R_BIN_ELF_ADDR_MAX) {\n\t\tstrtabaddr = Elf_(r_bin_elf_v2p_new) (bin, bin->dyn_info.dt_strtab);\n\t}\n\n\tif (bin->dyn_info.dt_strsz > 0) {\n\t\tstrsize = bin->dyn_info.dt_strsz;\n\t}\n\n\tif (strtabaddr == UT64_MAX || strtabaddr > bin->size || strsize > ST32_MAX || !strsize || strsize > bin->size || strtabaddr + strsize > bin->size) {\n\t\tif (!strtabaddr) {\n\t\t\tR_LOG_DEBUG (\"DT_STRTAB not found or invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\tstrtab = (char *)calloc (1, strsize + 1);\n\tif (!strtab) {\n\t\treturn false;\n\t}\n\tr = r_buf_read_at (bin->b, strtabaddr, (ut8 *)strtab, strsize);\n\tif (r < 1) {\n\t\tfree (strtab);\n\t\treturn false;\n\t}\n\n\tbin->strtab = strtab;\n\tbin->strtab_size = strsize;\n\tinit_dynamic_section_sdb (bin, strtabaddr, strsize);\n\treturn true;\n}\n\nstatic RBinElfSection* get_section_by_name(ELFOBJ *bin, const char *section_name) {\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strncmp (bin->g_sections[i].name, section_name, ELF_STRING_LENGTH - 1)) {\n\t\t\t\treturn &bin->g_sections[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tif (!flags) {\n\t\treturn \"none\";\n\t}\n\tstatic char buff[32];\n\tbuff[0] = 0;\n\tif (flags & VER_FLG_BASE) {\n\t\tstrcpy (buff, \"BASE \");\n\t}\n\tif (flags & VER_FLG_WEAK) {\n\t\tif (flags & VER_FLG_BASE) {\n\t\t\tstrcat (buff, \"| \");\n\t\t}\n\t\tstrcat (buff, \"WEAK \");\n\t}\n\tif (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)) {\n\t\tstrcat (buff, \"| <unknown>\");\n\t}\n\treturn buff;\n}\n\nstatic Sdb *store_versioninfo_gnu_versym(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tsize_t i;\n\tconst ut64 num_entries = sz / sizeof (Elf_(Versym));\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n\tut8 *edata = (ut8*) calloc (R_MAX (1, num_entries), 2 * sizeof (ut8));\n\tif (!edata) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut16 *data = (ut16 *)calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!data) {\n\t\tfree (edata);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut64 off = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]);\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tr_buf_read_at (bin->b, off, edata, sizeof (ut16) * num_entries);\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", num_entries, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\tfor (i = num_entries; i--;) {\n\t\tdata[i] = r_read_ble16 (&edata[i * sizeof (ut16)], bin->endian);\n\t}\n\tR_FREE (edata);\n\tchar *tmp_val = NULL;\n\tfor (i = 0; i < num_entries; i += 4) {\n\t\tsize_t j;\n\t\tint check_def;\n\t\tchar key[32] = {0};\n\n\t\tfor (j = 0; (j < 4) && (i + j) < num_entries; j++) {\n\t\t\tint k;\n\t\t\tsnprintf (key, sizeof (key), \"entry%d\", (int)(i + j));\n\t\t\tswitch (data[i + j]) {\n\t\t\tcase 0:\n\t\t\t\tsdb_set (sdb, key, \"0 (*local*)\", 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tsdb_set (sdb, key, \"1 (*global*)\", 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfree (tmp_val);\n\t\t\t\ttmp_val = r_str_newf (\"%x \", data[i+j] & 0x7FFF);\n\t\t\t\tcheck_def = true;\n\t\t\t\tif (bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]) {\n\t\t\t\t\tElf_(Verneed) vn;\n\t\t\t\t\tut8 svn[sizeof (Elf_(Verneed))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tElf_(Vernaux) vna;\n\t\t\t\t\t\tut8 svna[sizeof (Elf_(Vernaux))] = {0};\n\t\t\t\t\t\tut64 a_off;\n\t\t\t\t\t\tif (offset > bin->size || offset + sizeof (vn) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svn, sizeof (svn)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verneed for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvn.vn_version = READ16 (svn, k);\n\t\t\t\t\t\tvn.vn_cnt = READ16 (svn, k);\n\t\t\t\t\t\tvn.vn_file = READ32 (svn, k);\n\t\t\t\t\t\tvn.vn_aux = READ32 (svn, k);\n\t\t\t\t\t\tvn.vn_next = READ32 (svn, k);\n\t\t\t\t\t\ta_off = offset + vn.vn_aux;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (a_off > bin->size || a_off + sizeof (vna) > bin->size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, a_off, svna, sizeof (svna)) < 0) {\n\t\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Vernaux for Versym\");\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\t\tvna.vna_hash = READ32 (svna, k);\n\t\t\t\t\t\t\tvna.vna_flags = READ16 (svna, k);\n\t\t\t\t\t\t\tvna.vna_other = READ16 (svna, k);\n\t\t\t\t\t\t\tvna.vna_name = READ32 (svna, k);\n\t\t\t\t\t\t\tvna.vna_next = READ32 (svna, k);\n\t\t\t\t\t\t\ta_off += vna.vna_next;\n\t\t\t\t\t\t} while (vna.vna_other != data[i + j] && vna.vna_next != 0);\n\n\t\t\t\t\t\tif (vna.vna_other == data[i + j]) {\n\t\t\t\t\t\t\tif (vna.vna_name > bin->strtab_size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchar *val = r_str_newf (\"%s(%s)\", tmp_val, bin->strtab + vna.vna_name);\n\t\t\t\t\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\t\t\t\t\tfree (val);\n\t\t\t\t\t\t\tcheck_def = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += vn.vn_next;\n\t\t\t\t\t} while (vn.vn_next);\n\t\t\t\t}\n\n\t\t\t\tut64 vinfoaddr = bin->version_info[DT_VERSIONTAGIDX (DT_VERDEF)];\n\t\t\t\tif (check_def && data[i + j] != 0x8001 && vinfoaddr) {\n\t\t\t\t\tElf_(Verdef) vd;\n\t\t\t\t\tut8 svd[sizeof (Elf_(Verdef))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, vinfoaddr);\n\t\t\t\t\tif (offset > bin->size || offset + sizeof (vd) > bin->size) {\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svd, sizeof (svd)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verdef for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvd.vd_version = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_flags = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_ndx = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_cnt = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_hash = READ32 (svd, k);\n\t\t\t\t\t\tvd.vd_aux = READ32 (svd, k);\n\t\t\t\t\t\tvd.vd_next = READ32 (svd, k);\n\t\t\t\t\t\toffset += vd.vd_next;\n\t\t\t\t\t} while (vd.vd_ndx != (data[i + j] & 0x7FFF) && vd.vd_next != 0);\n\n\t\t\t\t\tif (vd.vd_ndx == (data[i + j] & 0x7FFF)) {\n\t\t\t\t\t\tElf_(Verdaux) vda;\n\t\t\t\t\t\tut8 svda[sizeof (Elf_(Verdaux))] = {0};\n\t\t\t\t\t\tut64 off_vda = offset - vd.vd_next + vd.vd_aux;\n\t\t\t\t\t\tif (off_vda > bin->size || off_vda + sizeof (vda) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, off_vda, svda, sizeof (svda)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verdaux for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvda.vda_name = READ32 (svda, k);\n\t\t\t\t\t\tvda.vda_next = READ32 (svda, k);\n\t\t\t\t\t\tif (vda.vda_name > bin->strtab_size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = bin->strtab + vda.vda_name;\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tchar *fname = r_str_newf (\"%s(%s%-*s)\", tmp_val, name, (int)(12 - strlen (name)),\")\");\n\t\t\t\t\t\t\tsdb_set (sdb, key, fname, 0);\n\t\t\t\t\t\t\tfree (fname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tR_FREE (tmp_val);\n\t}\nbeach:\n\tR_FREE (tmp_val);\n\tfree (data);\n\treturn sdb;\n}\n\nstatic Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tut32 cnt;\n\tsize_t i;\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (shdr->sh_size < sizeof (Elf_(Verdef)) || shdr->sh_size < sizeof (Elf_(Verdaux))) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n\tif (!defs) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\tfree (defs);\n\t\treturn false;\n\t}\n\tsize_t shsize = shdr->sh_size;\n\tif (shdr->sh_size > bin->size) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)shdr->sh_size, (int)bin->size);\n\t\t}\n\t\tif (bin->size > shdr->sh_offset) {\n\t\t\tshsize = bin->size - shdr->sh_offset;\n\t\t} else {\n\t\t\tshsize = bin->size;\n\t\t}\n\t}\n\tend = (char *)defs + shsize; //& shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; cnt < shdr->sh_info && i < shdr->sh_size; cnt++) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tif (vstart + sizeof (*verdef) > end) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j);\n\t\tverdef->vd_flags = READ16 (dfs, j);\n\t\tverdef->vd_ndx = READ16 (dfs, j);\n\t\tverdef->vd_cnt = READ16 (dfs, j);\n\t\tverdef->vd_hash = READ32 (dfs, j);\n\t\tverdef->vd_aux = READ32 (dfs, j);\n\t\tverdef->vd_next = READ32 (dfs, j);\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j);\n\t\taux.vda_next = READ32 (vstart, j);\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; j++) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tif (shdr->sh_size - vstart_off < aux.vda_next) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k);\n\t\t\taux.vda_next = READ32 (vstart, k);\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%u\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next || shdr->sh_size - i < verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tut64 i;\n\tint cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory for Elf_(Verneed)\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 1) {\n\t\tgoto beach;\n\t}\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; cnt++) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j);\n\t\tvvn.vn_cnt = READ16 (vstart, j);\n\t\tvvn.vn_file = READ32 (vstart, j);\n\t\tvvn.vn_aux = READ32 (vstart, j);\n\t\tvvn.vn_next = READ32 (vstart, j);\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tut32 vn_cnt = entry->vn_cnt;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; j++) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) *aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k);\n\t\t\tvaux.vna_flags = READ16 (vstart, k);\n\t\t\tvaux.vna_other = READ16 (vstart, k);\n\t\t\tvaux.vna_name = READ32 (vstart, k);\n\t\t\tvaux.vna_next = READ32 (vstart, k);\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n#if 1\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof (name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n#else\n\t\t\tchar *key = r_str_newf (\"vernaux%d\", j);\n\t\t\tchar *val = r_str_newf (\"%d,%s\", isum, get_ver_flags (aux->vna_flags));\n\t\t\tsdb_set (sdb_version, key, val, 0);\n\t\t\tfree (key);\n\t\t\tfree (val);\n#endif\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tR_LOG_DEBUG (\"Invalid vn_next at 0x%08\" PFMT64x, (ut64)shdr->sh_offset);\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo(ELFOBJ *bin) {\n\tSdb *sdb_versioninfo = NULL;\n\tint num_verdef = 0;\n\tint num_verneed = 0;\n\tint num_versym = 0;\n\tsize_t i;\n\n\tif (!bin || !bin->shdr) {\n\t\treturn NULL;\n\t}\n\tif (!(sdb_versioninfo = sdb_new0 ())) {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tSdb *sdb = NULL;\n\t\tchar key[32] = {0};\n\t\tint size = bin->shdr[i].sh_size;\n\n\t\tif (size - (i * sizeof (Elf_(Shdr)) > bin->size)) {\n\t\t\tsize = bin->size - (i*sizeof (Elf_(Shdr)));\n\t\t}\n\t\tint left = size - (i * sizeof (Elf_(Shdr)));\n\t\tleft = R_MIN (left, bin->shdr[i].sh_size);\n\t\tif (left < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bin->shdr[i].sh_type) {\n\t\tcase SHT_GNU_verdef:\n\t\t\tsdb = store_versioninfo_gnu_verdef (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verdef%d\", num_verdef++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_verneed:\n\t\t\tsdb = store_versioninfo_gnu_verneed (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verneed%d\", num_verneed++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_versym:\n\t\t\tsdb = store_versioninfo_gnu_versym (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"versym%d\", num_versym++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sdb_versioninfo;\n}\n\nstatic bool init_dynstr(ELFOBJ *bin) {\n\tint i, r;\n\tconst char *section_name = NULL;\n\tif (!bin || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (!bin->shstrtab) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_name > bin->shstrtab_size) {\n\t\t\treturn false;\n\t\t}\n\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\tif (bin->shdr[i].sh_type == SHT_STRTAB && !strcmp (section_name, \".dynstr\")) {\n\t\t\tif (!(bin->dynstr = (char*) calloc (bin->shdr[i].sh_size + 1, sizeof (char)))) {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate memory for dynamic strings\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size < bin->shdr[i].sh_size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset, (ut8*)bin->dynstr, bin->shdr[i].sh_size);\n\t\t\tif (r < 1) {\n\t\t\t\tR_FREE (bin->dynstr);\n\t\t\t\tbin->dynstr_size = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->dynstr_size = bin->shdr[i].sh_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic HtUP *rel_cache_new(RBinElfReloc *relocs, ut32 reloc_num) {\n\tif (!relocs || reloc_num == 0) {\n\t\treturn NULL;\n\t}\n\tconst int htsize = R_MIN (reloc_num, 1024);\n\tHtUP *rel_cache = ht_up_new_size (htsize, NULL, NULL, NULL);\n\tif (rel_cache) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < reloc_num; i++) {\n\t\t\tRBinElfReloc *tmp = relocs + i;\n\t\t\tht_up_insert (rel_cache, tmp->sym, tmp);\n\t\t}\n\t}\n\treturn rel_cache;\n}\n\nstatic bool elf_init(ELFOBJ *bin) {\n\t/* bin is not an ELF */\n\tif (!init_ehdr (bin)) {\n\t\treturn false;\n\t}\n\tif (!init_phdr (bin) && !is_bin_etrel (bin)) {\n\t\tR_LOG_DEBUG (\"Cannot initialize program headers\");\n\t}\n\tif (bin->ehdr.e_type != ET_CORE) {\n\t\tif (!init_shdr (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize section headers\");\n\t\t}\n\t\tif (!init_strtab (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize strings table\");\n\t\t}\n\t\tif (!init_dynstr (bin) && !is_bin_etrel (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize dynamic strings\");\n\t\t}\n\t\tbin->baddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tif (!init_dynamic_section (bin) && !Elf_(r_bin_elf_is_static) (bin) && !is_bin_etrel (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize dynamic section\");\n\t\t}\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->symbols_by_ord_size = 0;\n\tbin->symbols_by_ord = NULL;\n\tbin->g_sections = Elf_(r_bin_elf_get_sections) (bin);\n\tbin->boffset = Elf_(r_bin_elf_get_boffset) (bin);\n\tbin->g_relocs = Elf_(r_bin_elf_get_relocs) (bin);\n\tbin->rel_cache = rel_cache_new (bin->g_relocs, bin->g_reloc_num);\n\tsdb_ns_set (bin->kv, \"versioninfo\", store_versioninfo (bin));\n\treturn true;\n}\n\nut64 Elf_(r_bin_elf_get_section_offset)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->offset: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr_end)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva + section->size: UT64_MAX;\n}\n\nstatic ut64 get_got_entry(ELFOBJ *bin, RBinElfReloc *rel) {\n\tif (!rel->rva) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 p_sym_got_addr = Elf_(r_bin_elf_v2p_new) (bin, rel->rva);\n\tut64 addr = R_BIN_ELF_BREADWORD (bin->b, p_sym_got_addr);\n\n\treturn (!addr || addr == R_BIN_ELF_WORD_MAX) ? UT64_MAX : addr;\n}\n\nstatic bool is_thumb_symbol(ut64 plt_addr) {\n\treturn plt_addr & 1;\n}\n\nstatic ut64 get_import_addr_arm(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION (rel, got_addr, 0x3);\n\n\tswitch (rel->type) {\n\tcase R_ARM_JUMP_SLOT:\n\t\tplt_addr += pos * 12 + 20;\n\t\tif (is_thumb_symbol (plt_addr)) {\n\t\t\tplt_addr--;\n\t\t}\n\t\treturn plt_addr;\n\tcase R_AARCH64_RELATIVE:\n\t\tR_LOG_WARN (\"Unsupported relocation type for imports %d\", rel->type);\n\t\treturn UT64_MAX;\n\tcase R_AARCH64_IRELATIVE:\n\t\tif (rel->addend > plt_addr) { // start\n\t\t\treturn (plt_addr + pos * 16 + 32) + rel->addend;\n\t\t}\n\t\t// same as fallback to JUMP_SLOT\n\t\treturn plt_addr + pos * 16 + 32;\n\tcase R_AARCH64_JUMP_SLOT:\n\t\treturn plt_addr + pos * 16 + 32;\n\tdefault:\n\t\tR_LOG_WARN (\"Unsupported relocation type for imports %d\", rel->type);\n\t\treturn UT64_MAX;\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_import_addr_mips(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 jmprel_addr = bin->dyn_info.dt_jmprel;\n\tut64 got_addr = bin->dyn_info.dt_mips_pltgot;\n\n\tif (jmprel_addr == R_BIN_ELF_ADDR_MAX || got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\n\tut8 buf[1024];\n\tut64 plt_addr = jmprel_addr + bin->dyn_info.dt_pltrelsz;\n\tut64 p_plt_addr = Elf_(r_bin_elf_v2p_new) (bin, plt_addr);\n\tint res = r_buf_read_at (bin->b, p_plt_addr, buf, sizeof (buf));\n\tif (res != sizeof (buf)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tconst ut8 *base = r_mem_mem_aligned (buf, sizeof (buf), (const ut8 *)\"\\x3c\\x0f\\x00\", 3, 4);\n\tplt_addr += base? (int)(size_t) (base - buf):  MIPS_PLT_OFFSET + 8; // HARDCODED HACK\n\tplt_addr += pos * 16;\n\n\treturn plt_addr;\n}\n\nstatic size_t get_size_rel_mode(Elf_(Xword) mode) {\n\treturn mode == DT_RELA? sizeof (Elf_(Rela)): sizeof (Elf_(Rel));\n}\n\nstatic ut64 get_num_relocs_dynamic_plt(ELFOBJ *bin) {\n\tif (bin->dyn_info.dt_pltrelsz) {\n\t\tconst ut64 size = bin->dyn_info.dt_pltrelsz;\n\t\tconst ut64 relsize = get_size_rel_mode (bin->dyn_info.dt_pltrel);\n\t\treturn size / relsize;\n\t}\n\treturn 0;\n}\n\nstatic ut64 get_import_addr_riscv(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\treturn plt_addr + RISCV_PLT_OFFSET + pos * RISCV_PLT_ENTRY_SIZE;\n}\n\nstatic ut64 get_import_addr_loongarch(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\treturn plt_addr + LOONGARCH_PLT_OFFSET + pos * LOONGARCH_PLT_ENTRY_SIZE;\n}\nstatic ut64 get_import_addr_sparc(ELFOBJ *bin, RBinElfReloc *rel) {\n\tif (rel->type != R_SPARC_JMP_SLOT) {\n\t\tR_LOG_DEBUG (\"Unknown sparc reloc type %d\", rel->type);\n\t\treturn UT64_MAX;\n\t}\n\tut64 tmp = get_got_entry (bin, rel);\n\n\treturn (tmp == UT64_MAX) ? UT64_MAX : tmp + SPARC_OFFSET_PLT_ENTRY_FROM_GOT_ADDR;\n}\n\nstatic ut64 get_import_addr_ppc(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 plt_addr = bin->dyn_info.dt_pltgot;\n\tif (plt_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut64 p_plt_addr = Elf_(r_bin_elf_v2p_new) (bin, plt_addr);\n\tif (p_plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 base = r_buf_read_ble32_at (bin->b, p_plt_addr, bin->endian);\n\tif (base == UT32_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 nrel = get_num_relocs_dynamic_plt (bin);\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, plt_addr, 0x0);\n\n\tif (bin->endian) {\n\t\tbase -= (nrel * 16);\n\t\tbase += (pos * 16);\n\t\treturn base;\n\t}\n\n\tbase -= (nrel * 12) + 20;\n\tbase += (pos * 8);\n\treturn base;\n}\n\nstatic ut64 get_import_addr_x86_manual(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 got_offset = Elf_(r_bin_elf_v2p_new) (bin, got_addr);\n\tif (got_offset == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\t//XXX HACK ALERT!!!! full relro?? try to fix it\n\t//will there always be .plt.got, what would happen if is .got.plt?\n\tRBinElfSection *s = get_section_by_name (bin, \".plt.got\");\n\tif (Elf_(r_bin_elf_has_relro) (bin) < R_ELF_PART_RELRO || !s) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut8 buf[sizeof (Elf_(Addr))] = {0};\n\n\tut64 plt_addr = s->offset;\n\tut64 plt_sym_addr;\n\n\twhile (plt_addr + 2 + 4 < s->offset + s->size) {\n\t\t/*we try to locate the plt entry that correspond with the relocation\n\t\t  since got does not point back to .plt. In this case it has the following\n\t\t  form\n\t\t  ff253a152000   JMP QWORD [RIP + 0x20153A]\n\t\t  6690\t\t     NOP\n\t\t  ----\n\t\t  ff25ec9f0408   JMP DWORD [reloc.puts_236]\n\t\t  plt_addr + 2 to remove jmp opcode and get the imm reading 4\n\t\t  and if RIP (plt_addr + 6) + imm == rel->offset\n\t\t  return plt_addr, that will be our sym addr\n\t\t  perhaps this hack doesn't work on 32 bits\n\t\t  */\n\t\tint res = r_buf_read_at (bin->b, plt_addr + 2, buf, sizeof (ut32));\n\t\tif (res < 0) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\n\t\tsize_t i = 0;\n\t\tplt_sym_addr = R_BIN_ELF_READWORD (buf, i);\n\n\t\t//relative address\n\t\tif ((plt_addr + 6 + Elf_(r_bin_elf_v2p) (bin, plt_sym_addr)) == rel->rva) {\n\t\t\treturn plt_addr;\n\t\t}\n\t\tif (plt_sym_addr == rel->rva) {\n\t\t\treturn plt_addr;\n\t\t}\n\t\tplt_addr += 8;\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_import_addr_x86(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 tmp = get_got_entry (bin, rel);\n\tif (tmp == UT64_MAX) {\n\t\treturn get_import_addr_x86_manual (bin, rel);\n\t}\n\n\tRBinElfSection *pltsec_section = get_section_by_name (bin, \".plt.sec\");\n\tif (pltsec_section) {\n\t\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\t\tut64 pos = COMPUTE_PLTGOT_POSITION (rel, got_addr, 0x3);\n\t\treturn pltsec_section->rva + pos * X86_PLT_ENTRY_SIZE;\n\t}\n\n\treturn tmp + X86_OFFSET_PLT_ENTRY_FROM_GOT_ADDR;\n}\n\nstatic ut64 get_import_addr(ELFOBJ *bin, int sym) {\n\tif ((!bin->shdr || !bin->strtab) && !bin->phdr) {\n\t\treturn UT64_MAX;\n\t}\n\n\tif (!bin->rel_cache) {\n\t\treturn UT64_MAX;\n\t}\n\n\t// lookup the right rel/rela entry\n\tRBinElfReloc *rel = ht_up_find (bin->rel_cache, sym, NULL);\n\tif (!rel) {\n\t\treturn UT64_MAX;\n\t}\n\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn get_import_addr_arm (bin, rel);\n\tcase EM_MIPS: // MIPS32 BIG ENDIAN relocs\n\t\treturn get_import_addr_mips (bin, rel);\n\tcase EM_VAX:\n\t\t// as beautiful as riscv <3\n\t\treturn get_import_addr_riscv (bin, rel);\n\tcase EM_RISCV:\n\t\treturn get_import_addr_riscv (bin, rel);\n\tcase EM_SPARC:\n\tcase EM_SPARCV9:\n\tcase EM_SPARC32PLUS:\n\t\treturn get_import_addr_sparc (bin, rel);\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn get_import_addr_ppc (bin, rel);\n\tcase EM_386:\n\tcase EM_X86_64:\n\t\treturn get_import_addr_x86 (bin, rel);\n\tcase EM_LOONGARCH:\n\t\treturn get_import_addr_loongarch(bin, rel);\n\tdefault:\n\t\teprintf (\"Unsupported relocs type %\" PFMT64u \" for arch %d\\n\",\n\t\t\t\t(ut64) rel->type, bin->ehdr.e_machine);\n\t\treturn UT64_MAX;\n\t}\n}\n\nint Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, 0);\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Elf_(r_bin_elf_has_relro)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, R_ELF_NO_RELRO);\n\tbool haveBindNow = false;\n\tbool haveGnuRelro = false;\n\n\tif (bin->dyn_info.dt_bind_now) {\n\t\thaveBindNow = true;\n\t} else if (bin->dyn_info.dt_flags != R_BIN_ELF_XWORD_MAX && bin->dyn_info.dt_flags != R_BIN_ELF_XWORD_MAX) {\n\t\thaveBindNow = bin->dyn_info.dt_flags_1 & DF_1_NOW;\n\t}\n\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_RELRO) {\n\t\t\t\thaveGnuRelro = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (haveGnuRelro) {\n\t\tif (haveBindNow) {\n\t\t\treturn R_ELF_FULL_RELRO;\n\t\t}\n\t\treturn R_ELF_PART_RELRO;\n\t}\n\treturn R_ELF_NO_RELRO;\n}\n\n/*\nTo compute the base address, one determines the memory\naddress associated with the lowest p_vaddr value for a\nPT_LOAD segment. One then obtains the base address by\ntruncating the memory address to the nearest multiple\nof the maximum page size\n*/\n\nut64 Elf_(r_bin_elf_get_baddr)(ELFOBJ *bin) {\n\tut64 tmp, base = UT64_MAX;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp = (ut64)bin->phdr[i].p_vaddr & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (base == UT64_MAX && is_bin_etrel (bin)) {\n\t\t//we return our own base address for ET_REL type\n\t\t//we act as a loader for ELF\n\t\treturn 0x08000000;\n\t}\n\treturn base == UT64_MAX? 0: base;\n}\n\nut64 Elf_(r_bin_elf_get_boffset)(ELFOBJ *bin) {\n\tut64 tmp, base = UT64_MAX;\n\tr_return_val_if_fail (bin, 0);\n\n\tif (!bin->phdr) {\n\t\treturn 0; // TODO: should return ut64.max\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\ttmp = (ut64)bin->phdr[i].p_offset & ELF_PAGE_MASK;\n\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\tif (tmp < base) {\n\t\t\t\tbase = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn base == UT64_MAX? 0: base;\n}\n\nut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[128];\n\tif (!bin || entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n\t\tR_LOG_ERROR (\"read (init_offset)\");\n\t\treturn 0;\n\t}\n\tif (buf[0] == 0x68) { // push // x86 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf + 1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_fini_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tif (entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut8 buf[512];\n\tif (r_buf_read_at (bin->b, entry + 11, buf, sizeof (buf)) == -1) {\n\t\tR_LOG_ERROR (\"read (get_fini)\");\n\t\treturn 0;\n\t}\n\tif (*buf == 0x68) { // push // x86/32 only\n\t\tmemmove (buf, buf + 1, 4);\n\t\tut64 addr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_entry_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = bin->ehdr.e_entry;\n\tif (!entry) {\n\t\tif (!Elf_(r_bin_elf_is_executable) (bin)) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init.text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\treturn Elf_(r_bin_elf_get_section_offset)(bin, \".init\");\n\t}\n\treturn Elf_(r_bin_elf_v2p) (bin, entry);\n}\n\nstatic ut64 getmainsymbol(ELFOBJ *bin) {\n\tstruct r_bin_elf_symbol_t *symbol = Elf_(r_bin_elf_get_symbols) (bin);\n\tif (symbol) {\n\t\tsize_t i;\n\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\tif (!strcmp (symbol[i].name, \"main\")) {\n\t\t\t\treturn symbol[i].offset;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_main_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tif (entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut8 buf[256];\n\tif (entry > bin->size || (entry + sizeof (buf)) > bin->size) {\n\t\treturn UT64_MAX;\n\t}\n\t// unnecessary to read 512 bytes imho\n\tif (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {\n\t\tR_LOG_ERROR (\"read (main)\");\n\t\treturn UT64_MAX;\n\t}\n\t// ARM64\n\tif (buf[0x18 + 3] == 0x58 && buf[0x2f] == 0x00) {\n\t\tut32 entry_vaddr = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tut32 main_addr = r_read_le32 (&buf[0x30]);\n\t\tif ((main_addr >> 16) == (entry_vaddr >> 16)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, main_addr);\n\t\t}\n\t}\n\n\t// TODO: Use arch to identify arch before memcmp's\n\n\t// ARM Glibc\n\tif (entry & 1) {\n\t\tint delta = 0;\n\t\t/* thumb entry points */\n\t\tif (!memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x02\\xbc\\x6a\\x46\", 11)) {\n\t\t\t/* newer versions of gcc use push/pop */\n\t\t\tdelta = 0x28;\n\t\t} else if (!memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x5d\\xf8\\x04\\x1b\", 11)) {\n\t\t\t/* older versions of gcc (4.5.x) use ldr/str */\n\t\t\tdelta = 0x30;\n\t\t}\n\t\tif (delta) {\n\t\t\tut64 pa = Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[delta-1]) & ~1);\n\t\t\tif (pa < r_buf_size (bin->b)) {\n\t\t\t\treturn pa;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* non-thumb entry points */\n\t\tif (!memcmp (buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x34]) & ~1);\n\t\t}\n\t\tif (!memcmp (buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x30]) & ~1);\n\t\t}\n\t}\n\n\t// MIPS\n\t/* get .got, calculate offset of main symbol */\n\tif (!memcmp (buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\n\t\t/*\n\t\t    assuming the startup code looks like\n\t\t        got = gp-0x7ff0\n\t\t        got[index__libc_start_main] ( got[index_main] );\n\n\t\t    looking for the instruction generating the first argument to find main\n\t\t        lw a0, offset(gp)\n\t\t*/\n\n\t\tut64 got_offset;\n\t\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) != -1 ||\n\t\t    (got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) != -1)\n\t\t{\n\t\t\tconst ut64 gp = got_offset + 0x7ff0;\n\t\t\tsize_t i, len = sizeof (buf) / sizeof (buf[0]);\n\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\tconst ut32 instr = r_read_le32 (&buf[i]);\n\t\t\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\t\t\tr_buf_read_at (bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\t// X86-CGC\n\tif (buf[0] == 0xe8 && !memcmp (buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\tsize_t SIZEOF_CALL = 5;\n\t\tut64 rel_addr = (ut64)((int)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24)));\n\t\tut64 addr = Elf_(r_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\t\taddr += rel_addr;\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32*)(buf + 0x30);\n\t\tut64 vmain = Elf_(r_bin_elf_p2v) (bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp (buf, \"\\x31\\xed\\x49\\x89\", 4)) {// linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof (ut32)] = {0};\n\t\t\tmaddr = entry + 0x24 + r_read_le32 (buf + 0x20);\n\t\t\tif (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {\n\t\t\t\tR_LOG_ERROR (\"read (maddr) 2\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)r_read_le32 (&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (bin->phdr) {\n\t\t\t\tbaddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\t// X86-NONPIE\n#if R_BIN_ELF64\n\tif (!memcmp (buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn r_read_le32 (&buf[157]) + entry + 156 + 5;\n\t}\n\tif (!memcmp (buf+29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)r_read_le32 (&buf[29 + 3]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)r_read_le32 (&buf[23 + 1]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#endif\n\t/* linux64 pie main -- probably buggy in some cases */\n\tint bo = 29; // Begin offset may vary depending on the entry prelude\n\t// endbr64 - fedora bins have this\n\tif (buf[0] == 0xf3 && buf[1] == 0x0f && buf[2] == 0x1e && buf[3] == 0xfa) {\n\t\t// Change begin offset if binary starts with 'endbr64'\n\t\tbo = 33;\n\t}\n\tif (buf[bo] == 0x48) {\n\t\tut8 ch = buf[bo + 1];\n\t\tif (ch == 0x8d) { // lea rdi, qword [rip-0x21c4]\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tst32 maindelta = (st32)r_read_le32 (p);\n\t\t\tut64 vmain = (ut64)(entry + bo + maindelta) + 7;\n\t\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\t\tif ((vmain >> 16) == (ventry >> 16)) {\n\t\t\t\treturn (ut64)vmain;\n\t\t\t}\n\t\t} else if (ch == 0xc7) { // mov rdi, 0xADDR\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\treturn (ut64)(ut32)r_read_le32 (p);\n\t\t}\n\t}\n\n\t/* find sym.main if possible */\n\t{\n\t\tut64 m = getmainsymbol (bin);\n\t\tif (m != UT64_MAX) {\n\t\t\treturn m;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nbool Elf_(r_bin_elf_get_stripped)(ELFOBJ *bin) {\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strcmp (bin->g_sections[i].name, \".gnu_debugdata\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar *Elf_(r_bin_elf_intrp)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin || !bin->phdr) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\tut64 addr = bin->phdr[i].p_offset;\n\t\t\tint sz = bin->phdr[i].p_filesz;\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_addr\", addr, 0);\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_size\", sz, 0);\n\t\t\tif (sz < 1 || sz > r_buf_size (bin->b)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tchar *str = malloc (sz + 1);\n\t\t\tif (!str) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, addr, (ut8*)str, sz) < 1) {\n\t\t\t\tR_LOG_ERROR (\"read (main)\");\n\t\t\t\tfree (str);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstr[sz] = 0;\n\t\t\tsdb_set (bin->kv, \"elf_header.intrp\", str, 0);\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nbool Elf_(r_bin_elf_is_static)(ELFOBJ *bin) {\n\tsize_t i;\n\tif (!bin->phdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP ||\n\t\t\tbin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_data_encoding)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_DATA]) {\n\tcase ELFDATANONE: return strdup (\"none\");\n\tcase ELFDATA2LSB: return strdup (\"2's complement, little endian\");\n\tcase ELFDATA2MSB: return strdup (\"2's complement, big endian\");\n\tdefault: return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_DATA]);\n\t}\n}\n\nint Elf_(r_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_arch)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARC:\n\tcase EM_ARC_A5:\n\t\treturn strdup (\"arc\");\n\tcase EM_AVR: return strdup (\"avr\");\n\tcase EM_BA2_NON_STANDARD:\n\tcase EM_BA2: return strdup (\"ba2\");\n\tcase EM_CRIS: return strdup (\"cris\");\n\tcase EM_68K: return strdup (\"m68k\");\n\tcase EM_MIPS:\n\tcase EM_MIPS_RS3_LE:\n\tcase EM_MIPS_X:\n\t\treturn strdup (\"mips\");\n\tcase EM_MCST_ELBRUS:\n\t\treturn strdup (\"elbrus\");\n\tcase EM_TRICORE:\n\t\treturn strdup (\"tricore\");\n\tcase EM_RCE:\n\t\treturn strdup (\"mcore\");\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn strdup (\"arm\");\n\tcase EM_QDSP6: // EM_HEXAGON\n\t\treturn strdup (\"hexagon\");\n\tcase EM_BLACKFIN:\n\t\treturn strdup (\"blackfin\");\n\tcase EM_SPARC:\n\tcase EM_SPARC32PLUS:\n\tcase EM_SPARCV9:\n\t\treturn strdup (\"sparc\");\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn strdup (\"ppc\");\n\tcase EM_PARISC:\n\t\treturn strdup (\"hppa\");\n\tcase EM_PROPELLER:\n\t\treturn strdup (\"propeller\");\n\tcase EM_MICROBLAZE:\n\t\treturn strdup (\"microblaze.gnu\");\n\tcase EM_RISCV:\n\t\treturn strdup (\"riscv\");\n\tcase EM_VAX:\n\t\treturn strdup (\"vax\");\n\tcase EM_XTENSA:\n\t\treturn strdup (\"xtensa\");\n\tcase EM_LANAI:\n\t\treturn strdup (\"lanai\");\n\tcase EM_VIDEOCORE3:\n\tcase EM_VIDEOCORE4:\n\t\treturn strdup (\"vc4\");\n\tcase EM_MSP430:\n\t\treturn strdup (\"msp430\");\n\tcase EM_SH:\n\t\treturn strdup (\"sh\");\n\tcase EM_V800:\n\t\treturn strdup (\"v850\");\n\tcase EM_V850:\n\t\treturn strdup (\"v850\");\n\tcase EM_IA_64:\n\t\treturn strdup (\"ia64\");\n\tcase EM_S390:\n\t\treturn strdup (\"s390\");\n\tcase EM_KVX:\n\t\treturn strdup(\"kvx\");\n\tcase EM_LOONGARCH:\n\t\treturn strdup (\"loongarch\");\n\tdefault: return strdup (\"x86\");\n\t}\n}\nchar* Elf_(r_bin_elf_get_abi)(ELFOBJ *bin) {\n\tElf_(Ehdr)* ehdr = (Elf_(Ehdr) *) &bin->ehdr;\n\n\tif (ehdr->e_machine == EM_MIPS) {\n\t\tif (is_elfclass64 (ehdr)) {\n\t\t\treturn strdup (\"n64\");\n\t\t}\n\t\tif (is_mips_n32 (ehdr)) {\n\t\t\treturn strdup (\"n32\");\n\t\t}\n\t\tif (is_mips_o32 (ehdr)) {\n\t\t\treturn strdup (\"o32\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar* Elf_(r_bin_elf_get_cpu)(ELFOBJ *bin) {\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:        return strdup (\"mips1\");\n\t\tcase EF_MIPS_ARCH_2:        return strdup (\"mips2\");\n\t\tcase EF_MIPS_ARCH_3:        return strdup (\"mips3\");\n\t\tcase EF_MIPS_ARCH_4:        return strdup (\"mips4\");\n\t\tcase EF_MIPS_ARCH_5:        return strdup (\"mips5\");\n\t\tcase EF_MIPS_ARCH_32:       return strdup (\"mips32\");\n\t\tcase EF_MIPS_ARCH_64:       return strdup (\"mips64\");\n\t\tcase EF_MIPS_ARCH_32R2:     return strdup (\"mips32r2\");\n\t\tcase EF_MIPS_ARCH_64R2:     return strdup (\"mips64r2\");\n\t\tdefault :                   return strdup (\" Unknown mips ISA\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar* Elf_(r_bin_elf_get_head_flag)(ELFOBJ *bin) {\n\tchar *head_flag = NULL;\n\tchar *str = Elf_(r_bin_elf_get_cpu) (bin);\n\tif (str) {\n\t\thead_flag = r_str_append (head_flag, str);\n\t\tfree (str);\n\t}\n\tstr = Elf_(r_bin_elf_get_abi) (bin);\n\tif (str) {\n\t\thead_flag = r_str_appendf (head_flag, \" %s\", str);\n\t\tfree (str);\n\t}\n\tif (R_STR_ISEMPTY (head_flag)) {\n\t\thead_flag = r_str_append (head_flag, \"unknown_flag\");\n\t}\n\treturn head_flag;\n}\n\n// http://www.sco.com/developers/gabi/latest/ch4.eheader.html\n\nchar* Elf_(r_bin_elf_get_machine_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_NONE:          return strdup (\"No machine\");\n\tcase EM_M32:           return strdup (\"AT&T WE 32100\");\n\tcase EM_SPARC:         return strdup (\"SUN SPARC\");\n\tcase EM_386:           return strdup (\"Intel 80386\");\n\tcase EM_68K:           return strdup (\"Motorola m68k family\");\n\tcase EM_88K:           return strdup (\"Motorola m88k family\");\n\tcase EM_860:           return strdup (\"Intel 80860\");\n\tcase EM_MIPS:          return strdup (\"MIPS R3000\");\n\tcase EM_S370:          return strdup (\"IBM System/370\");\n\tcase EM_MIPS_RS3_LE:   return strdup (\"MIPS R3000 little-endian\");\n\tcase EM_PARISC:        return strdup (\"HPPA\");\n\tcase EM_VPP500:        return strdup (\"Fujitsu VPP500\");\n\tcase EM_SPARC32PLUS:   return strdup (\"Sun's \\\"v8plus\\\"\");\n\tcase EM_960:           return strdup (\"Intel 80960\");\n\tcase EM_PPC:           return strdup (\"PowerPC\");\n\tcase EM_PPC64:         return strdup (\"PowerPC 64-bit\");\n\tcase EM_S390:          return strdup (\"IBM S390\");\n\tcase EM_V800:          return strdup (\"NEC V800 series\");\n\tcase EM_FR20:          return strdup (\"Fujitsu FR20\");\n\tcase EM_RH32:          return strdup (\"TRW RH-32\");\n\tcase EM_RCE:           return strdup (\"Motorola RCE\");\n\tcase EM_ARM:           return strdup (\"ARM\");\n\tcase EM_BLACKFIN:      return strdup (\"Analog Devices Blackfin\");\n\tcase EM_FAKE_ALPHA:    return strdup (\"Digital Alpha\");\n\tcase EM_SH:            return strdup (\"Hitachi SH\");\n\tcase EM_SPARCV9:       return strdup (\"SPARC v9 64-bit\");\n\tcase EM_TRICORE:       return strdup (\"Siemens Tricore\");\n\tcase EM_ARC:           return strdup (\"Argonaut RISC Core\");\n\tcase EM_H8_300:        return strdup (\"Hitachi H8/300\");\n\tcase EM_H8_300H:       return strdup (\"Hitachi H8/300H\");\n\tcase EM_H8S:           return strdup (\"Hitachi H8S\");\n\tcase EM_H8_500:        return strdup (\"Hitachi H8/500\");\n\tcase EM_IA_64:         return strdup (\"Intel Merced\");\n\tcase EM_MIPS_X:        return strdup (\"Stanford MIPS-X\");\n\tcase EM_COLDFIRE:      return strdup (\"Motorola Coldfire\");\n\tcase EM_68HC12:        return strdup (\"Motorola M68HC12\");\n\tcase EM_MMA:           return strdup (\"Fujitsu MMA Multimedia Accelerator\");\n\tcase EM_PCP:           return strdup (\"Siemens PCP\");\n\tcase EM_NCPU:          return strdup (\"Sony nCPU embeeded RISC\");\n\tcase EM_NDR1:          return strdup (\"Denso NDR1 microprocessor\");\n\tcase EM_STARCORE:      return strdup (\"Motorola Start*Core processor\");\n\tcase EM_ME16:          return strdup (\"Toyota ME16 processor\");\n\tcase EM_ST100:         return strdup (\"STMicroelectronic ST100 processor\");\n\tcase EM_TINYJ:         return strdup (\"Advanced Logic Corp. Tinyj emb.fam\");\n\tcase EM_X86_64:        return strdup (\"AMD x86-64 architecture\");\n\tcase EM_LANAI:         return strdup (\"32bit LANAI architecture\");\n\tcase EM_PDSP:          return strdup (\"Sony DSP Processor\");\n\tcase EM_PDP10:         return strdup (\"Digital Equipment Corp. PDP-10\");\n\tcase EM_PDP11:         return strdup (\"Digital Equipment Corp. PDP-11\");\n\tcase EM_FX66:          return strdup (\"Siemens FX66 microcontroller\");\n\tcase EM_ST9PLUS:       return strdup (\"STMicroelectronics ST9+ 8/16 mc\");\n\tcase EM_ST7:           return strdup (\"STmicroelectronics ST7 8 bit mc\");\n\tcase EM_68HC16:        return strdup (\"Motorola MC68HC16 microcontroller\");\n\tcase EM_68HC11:        return strdup (\"Motorola MC68HC11 microcontroller\");\n\tcase EM_68HC08:        return strdup (\"Motorola MC68HC08 microcontroller\");\n\tcase EM_68HC05:        return strdup (\"Motorola MC68HC05 microcontroller\");\n\tcase EM_SVX:           return strdup (\"Silicon Graphics SVx\");\n\tcase EM_ST19:          return strdup (\"STMicroelectronics ST19 8 bit mc\");\n\tcase EM_VAX:           return strdup (\"Digital VAX\");\n\tcase EM_CRIS:          return strdup (\"Axis Communications 32-bit embedded processor\");\n\tcase EM_JAVELIN:       return strdup (\"Infineon Technologies 32-bit embedded processor\");\n\tcase EM_FIREPATH:      return strdup (\"Element 14 64-bit DSP Processor\");\n\tcase EM_ZSP:           return strdup (\"LSI Logic 16-bit DSP Processor\");\n\tcase EM_MMIX:          return strdup (\"Donald Knuth's educational 64-bit processor\");\n\tcase EM_HUANY:         return strdup (\"Harvard University machine-independent object files\");\n\tcase EM_PRISM:         return strdup (\"SiTera Prism\");\n\tcase EM_AVR:           return strdup (\"Atmel AVR 8-bit microcontroller\");\n\tcase EM_FR30:          return strdup (\"Fujitsu FR30\");\n\tcase EM_D10V:          return strdup (\"Mitsubishi D10V\");\n\tcase EM_D30V:          return strdup (\"Mitsubishi D30V\");\n\tcase EM_V850:          return strdup (\"NEC v850\");\n\tcase EM_M32R:          return strdup (\"Mitsubishi M32R\");\n\tcase EM_MN10300:       return strdup (\"Matsushita MN10300\");\n\tcase EM_MN10200:       return strdup (\"Matsushita MN10200\");\n\tcase EM_PJ:            return strdup (\"picoJava\");\n\tcase EM_OPENRISC:      return strdup (\"OpenRISC 32-bit embedded processor\");\n\tcase EM_ARC_A5:        return strdup (\"ARC Cores Tangent-A5\");\n\tcase EM_XTENSA:        return strdup (\"Tensilica Xtensa Architecture\");\n\tcase EM_AARCH64:       return strdup (\"ARM aarch64\");\n\tcase EM_PROPELLER:     return strdup (\"Parallax Propeller\");\n\tcase EM_MICROBLAZE:    return strdup (\"Xilinx MicroBlaze\");\n\tcase EM_RISCV:         return strdup (\"RISC V\");\n\tcase EM_VIDEOCORE3:    return strdup (\"VideoCore III\");\n\tcase EM_VIDEOCORE4:    return strdup (\"VideoCore IV\");\n\tcase EM_LATTICEMICO32: return strdup (\"RISC processor for Lattice FPGA architecture\");\n\tcase EM_SE_C17:        return strdup (\"Seiko Epson C17 family\");\n\tcase EM_TI_C6000:      return strdup (\"The Texas Instruments TMS320C6000 DSP family\");\n\tcase EM_TI_C2000:      return strdup (\"The Texas Instruments TMS320C2000 DSP family\");\n\tcase EM_TI_C5500:      return strdup (\"The Texas Instruments TMS320C55x DSP family\");\n\tcase EM_TI_ARP32:      return strdup (\"Texas Instruments Application Specific RISC Processor, 32bit fetch\");\n\tcase EM_TI_PRU:        return strdup (\"Texas Instruments Programmable Realtime Unit\");\n\tcase EM_MMDSP_PLUS:    return strdup (\"STMicroelectronics 64bit VLIW Data Signal Processor\");\n\tcase EM_CYPRESS_M8C:   return strdup (\"Cypress M8C microprocessor\");\n\tcase EM_R32C:          return strdup (\"Renesas R32C series microprocessors\");\n\tcase EM_TRIMEDIA:      return strdup (\"NXP Semiconductors TriMedia architecture family\");\n\tcase EM_QDSP6:         return strdup (\"QUALCOMM DSP6 Processor\");  // Nonstandard\n\tcase EM_8051:          return strdup (\"Intel 8051 and variants\");\n\tcase EM_STXP7X:        return strdup (\"STMicroelectronics STxP7x family of configurable and extensible RISC processors\");\n\tcase EM_NDS32:         return strdup (\"Andes Technology compact code size embedded RISC processor family\");\n\tcase EM_ECOG1:         return strdup (\"Cyan Technology eCOG1X family\");\n\t// case EM_ECOG1X:        return strdup (\"Cyan Technology eCOG1X family\");  // Nonstandard\n\tcase EM_MAXQ30:        return strdup (\"Dallas Semiconductor MAXQ30 Core Micro-controllers\");\n\tcase EM_XIMO16:        return strdup (\"New Japan Radio (NJR) 16-bit DSP Processor\");\n\tcase EM_MANIK:         return strdup (\"M2000 Reconfigurable RISC Microprocessor\");\n\tcase EM_CRAYNV2:       return strdup (\"Cray Inc. NV2 vector architecture\");\n\tcase EM_RX:            return strdup (\"Renesas RX family\");\n\tcase EM_METAG:         return strdup (\"Imagination Technologies META processor architecture\");\n\tcase EM_MCST_ELBRUS:   return strdup (\"MCST Elbrus general purpose hardware architecture\");\n\tcase EM_ECOG16:        return strdup (\"Cyan Technology eCOG16 family\");\n\tcase EM_CR16:          return strdup (\"National Semiconductor CompactRISC CR16 16-bit microprocessor\");\n\tcase EM_ETPU:          return strdup (\"Freescale Extended Time Processing Unit\");\n\tcase EM_SLE9X:         return strdup (\"Infineon Technologies SLE9X core\");\n\tcase EM_L10M:          return strdup (\"Intel L10M\");\n\tcase EM_K10M:          return strdup (\"Intel K10M\");\n\t// case EM_AARCH64:       return strdup (\"ARM 64-bit architecture (AARCH64)\");  // Nonstandard\n\tcase EM_AVR32:         return strdup (\"Atmel Corporation 32-bit microprocessor family\");\n\tcase EM_STM8:          return strdup (\"STMicroeletronics STM8 8-bit microcontroller\");\n\tcase EM_TILE64:        return strdup (\"Tilera TILE64 multicore architecture family\");\n\tcase EM_TILEPRO:       return strdup (\"Tilera TILEPro multicore architecture family\");\n\t// case EM_MICROBLAZE:    return strdup (\"Xilinx MicroBlaze 32-bit RISC soft processor core\");  // Nonstandard\n\tcase EM_CUDA:          return strdup (\"NVIDIA CUDA architecture\");\n\tcase EM_TILEGX:        return strdup (\"Tilera TILE-Gx multicore architecture family\");\n\tcase EM_CLOUDSHIELD:   return strdup (\"CloudShield architecture family\");\n\tcase EM_COREA_1ST:     return strdup (\"KIPO-KAIST Core-A 1st generation processor family\");\n\tcase EM_COREA_2ND:     return strdup (\"KIPO-KAIST Core-A 2nd generation processor family\");\n\tcase EM_ARC_COMPACT2:  return strdup (\"Synopsys ARCompact V2\");\n\tcase EM_OPEN8:         return strdup (\"Open8 8-bit RISC soft processor core\");\n\tcase EM_RL78:          return strdup (\"Renesas RL78 family\");\n\tcase EM_VIDEOCORE5:    return strdup (\"Broadcom VideoCore V processor\");\n\tcase EM_78KOR:         return strdup (\"Renesas 78KOR family\");\n\t// case EM_56800EX:       return strdup (\"Freescale 56800EX Digital Signal Controller (DSC)\");  // Nonstandard\n\tcase EM_BA1:           return strdup (\"Beyond BA1 CPU architecture\");\n\tcase EM_BA2_NON_STANDARD:\n\tcase EM_BA2:           return strdup (\"Beyond BA2 CPU architecture\");\n\tcase EM_XCORE:         return strdup (\"XMOS xCORE processor family\");\n\tcase EM_MCHP_PIC:      return strdup (\"Microchip 8-bit PIC(r) family\");\n\tcase EM_INTEL205:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL206:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL207:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL208:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL209:      return strdup (\"Reserved by Intel\");\n\tcase EM_KM32:          return strdup (\"KM211 KM32 32-bit processor\");\n\tcase EM_KMX32:         return strdup (\"KM211 KMX32 32-bit processor\");\n\tcase EM_KMX16:         return strdup (\"KM211 KMX16 16-bit processor\");\n\tcase EM_KMX8:          return strdup (\"KM211 KMX8 8-bit processor\");\n\tcase EM_KVARC:         return strdup (\"KM211 KVARC processor\");\n\tcase EM_CDP:           return strdup (\"Paneve CDP architecture family\");\n\tcase EM_COGE:          return strdup (\"Cognitive Smart Memory Processor\");\n\tcase EM_COOL:          return strdup (\"Bluechip Systems CoolEngine\");\n\tcase EM_NORC:          return strdup (\"Nanoradio Optimized RISC\");\n\tcase EM_CSR_KALIMBA:   return strdup (\"CSR Kalimba architecture family\");\n\tcase EM_Z80:           return strdup (\"Zilog Z80\");\n\tcase EM_VISIUM:        return strdup (\"Controls and Data Services VISIUMcore processor\");\n\tcase EM_FT32:          return strdup (\"FTDI Chip FT32 high performance 32-bit RISC architecture\");\n\tcase EM_MOXIE:         return strdup (\"Moxie processor family\");\n\tcase EM_AMDGPU:        return strdup (\"AMD GPU architecture\");\n\tcase EM_LOONGARCH:     return strdup (\"Loongson Loongarch\");\n\n\tdefault:             return r_str_newf (\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tut32 e_type = (ut32)bin->ehdr.e_type; // cast to avoid warn in iphone-gcc, must be ut16\n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}\n\nchar* Elf_(r_bin_elf_get_elf_class)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASSNONE: return strdup (\"none\");\n\tcase ELFCLASS32:   return strdup (\"ELF32\");\n\tcase ELFCLASS64:   return strdup (\"ELF64\");\n\tdefault:           return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n\t}\n}\n\nint Elf_(r_bin_elf_get_bits)(ELFOBJ *bin) {\n\t/* Hack for ARCompact */\n\tif (bin->ehdr.e_machine == EM_ARC_A5) {\n\t\treturn 16;\n\t}\n\t/* Hack for Ps2 */\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tif (bin->ehdr.e_type == ET_EXEC) {\n\t\t\tint i;\n\t\t\tbool haveInterp = false;\n\t\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\t\t\thaveInterp = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!haveInterp && mipsType == EF_MIPS_ARCH_3) {\n\t\t\t\t// Playstation2 Hack\n\t\t\t\treturn 64;\n\t\t\t}\n\t\t}\n\t\t// TODO: show this specific asm.cpu somewhere in bininfo (mips1, mips2, mips3, mips32r2, ...)\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:\n\t\tcase EF_MIPS_ARCH_2:\n\t\tcase EF_MIPS_ARCH_3:\n\t\tcase EF_MIPS_ARCH_4:\n\t\tcase EF_MIPS_ARCH_5:\n\t\tcase EF_MIPS_ARCH_32:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64:\n\t\t\treturn 64;\n\t\tcase EF_MIPS_ARCH_32R2:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64R2:\n\t\t\treturn 64;\n\t\t\tbreak;\n\t\t}\n\t\treturn 32;\n\t}\n\t/* Hack for Thumb */\n\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\tif (bin->ehdr.e_type != ET_EXEC) {\n\t\t\tstruct r_bin_elf_symbol_t *symbol;\n\t\t\tif ((symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\t\t\tut64 paddr = symbol[i].offset;\n\t\t\t\t\tif (paddr & 1) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\t\tif (entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t}\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:   return 32;\n\tcase ELFCLASS64:   return 64;\n\tcase ELFCLASSNONE:\n\tdefault:           return 32; // defaults\n\t}\n}\n\nstatic inline int noodle(ELFOBJ *bin, const char *s) {\n\tif (r_buf_size (bin->b) >= 64)  {\n\t\tut8 tmp[64] = {0};\n\t\tif (r_buf_read_at (bin->b, r_buf_size (bin->b) - 64, tmp, 64) == 64) {\n\t\t\treturn (bool)r_mem_mem (tmp, 64, (const ut8 *)s, strlen (s));\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic inline bool needle(ELFOBJ *bin, const char *s) {\n\tif (bin->shstrtab) {\n\t\tut32 len = bin->shstrtab_size;\n\t\tif (len > 4096) {\n\t\t\tlen = 4096; // avoid slow loading .. can be buggy?\n\t\t}\n\t\treturn (bool)r_mem_mem ((const ut8*)bin->shstrtab, len,\n\t\t\t\t(const ut8*)s, strlen (s));\n\t}\n\treturn false;\n}\n\n// TODO: must return const char * all those strings must be const char os[LINUX] or so\nchar* Elf_(r_bin_elf_get_osabi_name)(ELFOBJ *bin) {\n\tsize_t i;\n\tsize_t num = bin->ehdr.e_shnum;\n\tconst char *section_name = NULL;\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX: return strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS: return strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD: return strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX: return strdup(\"hpux\");\n\t}\n\n\tif (bin->shdr && bin->shstrtab) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->shdr[i].sh_type == SHT_NOTE && bin->shdr[i].sh_name < bin->shstrtab_size) {\n\t\t\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\t\t\tif (!strcmp (section_name, \".note.openbsd.ident\")) {\n\t\t\t\t\treturn strdup (\"openbsd\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.minix.ident\")) {\n\t\t\t\t\treturn strdup (\"minix\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.netbsd.ident\")) {\n\t\t\t\t\treturn strdup (\"netbsd\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.android.ident\")) {\n\t\t\t\t\treturn strdup (\"android\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* Hack to identify OS */\n\tif (needle (bin, \"freebsd\")) {\n\t\treturn strdup (\"freebsd\");\n\t}\n\tif (noodle (bin, \"BEOS:APP_VERSION\")) {\n\t\treturn strdup (\"beos\");\n\t}\n\tif (needle (bin, \"GNU\")) {\n\t\treturn strdup (\"linux\");\n\t}\n\treturn strdup (\"linux\");\n}\n\nut8 *Elf_(r_bin_elf_grab_regstate)(ELFOBJ *bin, int *len) {\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tint num = bin->ehdr.e_phnum;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->phdr[i].p_type != PT_NOTE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint elf_nhdr_size = (bits == 64) ? sizeof (Elf64_Nhdr) : sizeof (Elf32_Nhdr);\n\t\t\tvoid *elf_nhdr = calloc (elf_nhdr_size, 1);\n\t\t\tbool regs_found = false;\n\t\t\tut64 offset = 0;\n\n\t\t\twhile (!regs_found) {\n\t\t\t\tut32 n_descsz, n_namesz, n_type;\n\t\t\t\tint ret;\n\t\t\t\tret = r_buf_read_at (bin->b, bin->phdr[i].p_offset + offset, elf_nhdr, elf_nhdr_size);\n\t\t\t\tif (ret != elf_nhdr_size) {\n\t\t\t\t\tR_LOG_DEBUG (\"Cannot read NOTES hdr from CORE file\");\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\tn_descsz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf64_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t} else {\n\t\t\t\t\tn_descsz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf32_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t}\n\t\t\t\tif (n_type == NT_PRSTATUS) {\n\t\t\t\t\tregs_found = true;\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t} else {\n\t\t\t\t\toffset += elf_nhdr_size + n_descsz + n_namesz;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint regdelta = 0;\n\t\t\tint regsize = 0;\n\t\t\tswitch (bin->ehdr.e_machine) {\n\t\t\t\tcase EM_AARCH64:\n\t\t\t\t\tregsize = reginf[AARCH64].regsize;\n\t\t\t\t\tregdelta = reginf[AARCH64].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_ARM:\n\t\t\t\t\tregsize = reginf[ARM].regsize;\n\t\t\t\t\tregdelta = reginf[ARM].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_386:\n\t\t\t\t\tregsize = reginf[X86].regsize;\n\t\t\t\t\tregdelta = reginf[X86].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_X86_64:\n\t\t\t\t\tregsize = reginf[X86_64].regsize;\n\t\t\t\t\tregdelta = reginf[X86_64].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 *buf = malloc (regsize);\n\t\t\tif (r_buf_read_at (bin->b, bin->phdr[i].p_offset + offset + regdelta, buf, regsize) != regsize) {\n\t\t\t\tfree (buf);\n\t\t\t\tR_LOG_DEBUG (\"Cannot read register state from CORE file\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\t*len = regsize;\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\t}\n\tR_LOG_DEBUG (\"Cannot find NOTE section.\");\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_is_big_endian)(ELFOBJ *bin) {\n\treturn (bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB);\n}\n\n/* XXX Init dt_strtab? */\nchar *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tElf_(Xword) val;\n\n\tif (!bin->phdr || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dyn_info.dt_rpath != R_BIN_ELF_XWORD_MAX)  {\n\t\tval = bin->dyn_info.dt_rpath;\n\t} else if (bin->dyn_info.dt_runpath != R_BIN_ELF_XWORD_MAX) {\n\t\tval = bin->dyn_info.dt_runpath;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tif (val > bin->strtab_size) {\n\t\treturn NULL;\n\t}\n\n\treturn r_str_ndup (bin->strtab + val, ELF_STRING_LENGTH);\n}\n\nstatic bool has_valid_section_header(ELFOBJ *bin, size_t pos) {\n\treturn bin->g_sections[pos].info < bin->ehdr.e_shnum && bin->shdr;\n}\n\nstatic void fix_rva_and_offset_relocable_file(ELFOBJ *bin, RBinElfReloc *r, size_t pos) {\n\tif (has_valid_section_header (bin, pos)) {\n\t\tsize_t idx = bin->g_sections[pos].info;\n\t\tif (idx < bin->ehdr.e_shnum) {\n\t\t\tut64 pa = bin->shdr[idx].sh_offset + r->offset;\n\t\t\tr->offset = pa;\n\t\t\tr->rva = Elf_(r_bin_elf_p2v) (bin, pa);\n\t\t} else {\n\t\t\teprintf (\"fix_rva_and_offset_reloc..: invalid index\\n\");\n\t\t}\n\t} else {\n\t\tr->rva = r->offset;\n\t}\n}\n\nstatic void fix_rva_and_offset_exec_file(ELFOBJ *bin, RBinElfReloc *r) {\n\tr->rva = r->offset;\n\tr->offset = Elf_(r_bin_elf_v2p) (bin, r->offset);\n}\n\nstatic void fix_rva_and_offset(ELFOBJ *bin, RBinElfReloc *r, size_t pos) {\n\tif (is_bin_etrel (bin)) {\n\t\tfix_rva_and_offset_relocable_file (bin, r, pos);\n\t} else {\n\t\tfix_rva_and_offset_exec_file (bin, r);\n\t}\n}\n\nstatic bool read_reloc(ELFOBJ *bin, RBinElfReloc *r, Elf_(Xword) rel_mode, ut64 vaddr) {\n\tut64 offset = Elf_(r_bin_elf_v2p_new) (bin, vaddr);\n\tif (offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tsize_t size_struct = get_size_rel_mode (rel_mode);\n\n\tut8 buf[sizeof (Elf_(Rela))] = {0};\n\tint res = r_buf_read_at (bin->b, offset, buf, size_struct);\n\tif (res != size_struct) {\n\t\treturn false;\n\t}\n\n\tsize_t i = 0;\n\tElf_(Rela) reloc_info;\n\n\treloc_info.r_offset = R_BIN_ELF_READWORD (buf, i);\n\treloc_info.r_info = R_BIN_ELF_READWORD (buf, i);\n\n\tif (rel_mode == DT_RELA) {\n\t\treloc_info.r_addend = R_BIN_ELF_READWORD (buf, i);\n\t\tr->addend = reloc_info.r_addend;\n\t}\n\n\tr->mode = rel_mode;\n\tr->last = 0;\n\tr->offset = reloc_info.r_offset;\n\tr->sym = ELF_R_SYM (reloc_info.r_info);\n\tr->type = ELF_R_TYPE (reloc_info.r_info);\n\n\treturn true;\n}\n\nstatic size_t get_num_relocs_dynamic(ELFOBJ *bin) {\n\tsize_t res = 0;\n\n\tif (bin->dyn_info.dt_relaent) {\n\t\tres += bin->dyn_info.dt_relasz / bin->dyn_info.dt_relaent;\n\t}\n\n\tif (bin->dyn_info.dt_relent) {\n\t\tres += bin->dyn_info.dt_relsz / bin->dyn_info.dt_relent;\n\t}\n\n\treturn res + get_num_relocs_dynamic_plt (bin);\n}\n\nstatic bool sectionIsValid(ELFOBJ *bin, RBinElfSection *sect) {\n\treturn (sect->offset + sect->size <= bin->size);\n}\n\nstatic Elf_(Xword) get_section_mode(ELFOBJ *bin, size_t pos) {\n\tif (r_str_startswith (bin->g_sections[pos].name, \".rela.\")) {\n\t\treturn DT_RELA;\n\t}\n\tif (r_str_startswith (bin->g_sections[pos].name, \".rel.\")) {\n\t\treturn DT_REL;\n\t}\n\treturn 0;\n}\n\nstatic bool is_reloc_section(Elf_(Xword) rel_mode) {\n\treturn rel_mode == DT_REL || rel_mode == DT_RELA;\n}\n\nstatic size_t get_num_relocs_sections(ELFOBJ *bin) {\n\tsize_t i, size, ret = 0;\n\tElf_(Xword) rel_mode;\n\n\tif (!bin->g_sections) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!sectionIsValid (bin, &bin->g_sections[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\trel_mode = get_section_mode (bin, i);\n\t\tif (!is_reloc_section (rel_mode)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsize = get_size_rel_mode (rel_mode);\n\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t}\n\n\treturn ret;\n}\n\nstatic size_t get_num_relocs_approx(ELFOBJ *bin) {\n\tsize_t total = get_num_relocs_dynamic (bin) + get_num_relocs_sections (bin);\n\tif (total > bin->size) {\n\t\treturn bin->size / 2;\n\t}\n\treturn total;\n}\n\nstatic size_t populate_relocs_record_from_dynamic(ELFOBJ *bin, RBinElfReloc *relocs, size_t pos, size_t num_relocs) {\n\tsize_t offset;\n\tsize_t size = get_size_rel_mode (bin->dyn_info.dt_pltrel);\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_pltrelsz && pos < num_relocs; offset += size, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, bin->dyn_info.dt_pltrel, bin->dyn_info.dt_jmprel + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_relasz && pos < num_relocs; offset += bin->dyn_info.dt_relaent, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, DT_RELA, bin->dyn_info.dt_rela + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_relsz && pos < num_relocs; offset += bin->dyn_info.dt_relent, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, DT_REL, bin->dyn_info.dt_rel + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\treturn pos;\n}\n\nstatic size_t get_next_not_analysed_offset(ELFOBJ *bin, size_t section_vaddr, size_t offset) {\n\tsize_t gvaddr = section_vaddr + offset;\n\n\tif (bin->dyn_info.dt_rela != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_rela <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_rela + bin->dyn_info.dt_relasz) {\n\t\treturn bin->dyn_info.dt_rela + bin->dyn_info.dt_relasz - section_vaddr;\n\t}\n\n\tif (bin->dyn_info.dt_rel != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_rel <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_rel + bin->dyn_info.dt_relsz) {\n\t\treturn bin->dyn_info.dt_rel + bin->dyn_info.dt_relsz - section_vaddr;\n\t}\n\n\tif (bin->dyn_info.dt_jmprel != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_jmprel <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_jmprel + bin->dyn_info.dt_pltrelsz) {\n\t\treturn bin->dyn_info.dt_jmprel + bin->dyn_info.dt_pltrelsz - section_vaddr;\n\t}\n\n\treturn offset;\n}\n\nstatic size_t populate_relocs_record_from_section(ELFOBJ *bin, RBinElfReloc *relocs, size_t pos, size_t num_relocs) {\n\tsize_t size, i, j;\n\tElf_(Xword) rel_mode;\n\n\tif (!bin->g_sections) {\n\t\treturn pos;\n\t}\n\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\trel_mode = get_section_mode (bin, i);\n\n\t\tif (!is_reloc_section (rel_mode) || bin->g_sections[i].size > bin->size || bin->g_sections[i].offset > bin->size) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = get_size_rel_mode (rel_mode);\n\n\t\tfor (j = get_next_not_analysed_offset (bin, bin->g_sections[i].rva, 0);\n\t\t\tj < bin->g_sections[i].size && pos < num_relocs;\n\t\t\tj = get_next_not_analysed_offset (bin, bin->g_sections[i].rva, j + size)) {\n\n\t\t\tif (!read_reloc (bin, relocs + pos, rel_mode, bin->g_sections[i].rva + j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfix_rva_and_offset (bin, relocs + pos, i);\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn pos;\n}\n\nstatic RBinElfReloc *populate_relocs_record(ELFOBJ *bin) {\n\tsize_t i = 0;\n\tsize_t num_relocs = get_num_relocs_approx (bin);\n\tRBinElfReloc *relocs = R_NEWS0 (RBinElfReloc, num_relocs + 1);\n\tif (!relocs) {\n\t\t// In case we can't allocate enough memory for all the claimed\n\t\t// relocation entries, try to parse only the ones specified in\n\t\t// the dynamic segment.\n\t\tnum_relocs = get_num_relocs_dynamic (bin);\n\t\trelocs = R_NEWS0 (RBinElfReloc, num_relocs + 1);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\ti = populate_relocs_record_from_dynamic (bin, relocs, i, num_relocs);\n\ti = populate_relocs_record_from_section (bin, relocs, i, num_relocs);\n\trelocs[i].last = 1;\n\n\tbin->g_reloc_num = i;\n\treturn relocs;\n}\n\nRBinElfReloc* Elf_(r_bin_elf_get_relocs) (ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\n\tif (!bin->g_relocs) {\n\t\tbin->g_relocs = populate_relocs_record (bin);\n\t}\n\treturn bin->g_relocs;\n}\n\nRBinElfLib* Elf_(r_bin_elf_get_libs)(ELFOBJ *bin) {\n\tRBinElfLib *ret = NULL;\n\tElf_(Off) *it = NULL;\n\tsize_t k = 0;\n\n\tif (!bin || !bin->phdr || !bin->strtab || *(bin->strtab+1) == '0') {\n\t\treturn NULL;\n\t}\n\n\tr_vector_foreach(&bin->dyn_info.dt_needed, it) {\n\t\tElf_(Off) val = *it;\n\n\t\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\t\tif (!r) {\n\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r;\n\t\tif (val > bin->strtab_size) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrncpy (ret[k].name, bin->strtab + val, ELF_STRING_LENGTH);\n\t\tret[k].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\tret[k].last = 0;\n\t\tif (ret[k].name[0]) {\n\t\t\tk++;\n\t\t}\n\t}\n\n\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\tif (!r) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret = r;\n\tret[k].last = 1;\n\treturn ret;\n}\n\nstatic void create_section_from_phdr(ELFOBJ *bin, RBinElfSection *ret, size_t *i, const char *name, ut64 addr, ut64 sz) {\n\tr_return_if_fail (bin && ret && i);\n\tif (!addr || addr == UT64_MAX) {\n\t\treturn;\n\t}\n\tret[*i].offset = Elf_(r_bin_elf_v2p_new) (bin, addr);\n\tret[*i].rva = addr;\n\tret[*i].size = sz;\n\tr_str_ncpy (ret[*i].name, name, R_ARRAY_SIZE (ret[*i].name) - 1);\n\tret[*i].last = 0;\n\t*i = *i + 1;\n}\n\nstatic RBinElfSection *get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tsize_t num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tr_return_val_if_fail (bin && bin->phdr, NULL);\n\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\tif (bin->dyn_info.dt_rel != R_BIN_ELF_ADDR_MAX) {\n\t\treldyn = bin->dyn_info.dt_rel;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_rela != R_BIN_ELF_ADDR_MAX) {\n\t\trelva = bin->dyn_info.dt_rela;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_relsz) {\n\t\treldynsz = bin->dyn_info.dt_relsz;\n\t}\n\tif (bin->dyn_info.dt_relasz) {\n\t\trelasz = bin->dyn_info.dt_relasz;\n\t}\n\tif (bin->dyn_info.dt_pltgot != R_BIN_ELF_ADDR_MAX) {\n\t\tpltgotva = bin->dyn_info.dt_pltgot;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_pltrelsz) {\n\t\tpltgotsz = bin->dyn_info.dt_pltrelsz;\n\t}\n\tif (bin->dyn_info.dt_jmprel != R_BIN_ELF_ADDR_MAX) {\n\t\trelava = bin->dyn_info.dt_jmprel;\n\t\tnum_sections++;\n\t}\n\n\tret = calloc (num_sections + 1, sizeof (RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i = 0;\n\tcreate_section_from_phdr (bin, ret, &i, \".rel.dyn\", reldyn, reldynsz);\n\tcreate_section_from_phdr (bin, ret, &i, \".rela.plt\", relava, pltgotsz);\n\tcreate_section_from_phdr (bin, ret, &i, \".rel.plt\", relva, relasz);\n\tcreate_section_from_phdr (bin, ret, &i, \".got.plt\", pltgotva, pltgotsz);\n\tret[i].last = 1;\n\n\treturn ret;\n}\n\nRBinElfSection* Elf_(r_bin_elf_get_sections)(ELFOBJ *bin) {\n\tRBinElfSection *ret = NULL;\n\tchar unknown_s[32], invalid_s[32];\n\tint i, nidx, unknown_c=0, invalid_c=0;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\tif (!bin->shdr && bin->phdr) {\n\t\t//we don't give up search in phdr section\n\t\treturn get_sections_from_phdr (bin);\n\t}\n\tif (!bin->shdr) {\n\t\treturn NULL;\n\t}\n\tut32 count = bin->ehdr.e_shnum;\n\tif (!(ret = calloc ((count + 1), sizeof (RBinElfSection)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tret[i].offset = bin->shdr[i].sh_offset;\n\t\tret[i].size = bin->shdr[i].sh_size;\n\t\tret[i].align = bin->shdr[i].sh_addralign;\n\t\tret[i].flags = bin->shdr[i].sh_flags;\n\t\tret[i].link = bin->shdr[i].sh_link;\n\t\tret[i].info = bin->shdr[i].sh_info;\n\t\tret[i].type = bin->shdr[i].sh_type;\n\t\tif (is_bin_etrel (bin)) {\n\t\t\tret[i].rva = bin->baddr + bin->shdr[i].sh_offset;\n\t\t} else {\n\t\t\tret[i].rva = bin->shdr[i].sh_addr;\n\t\t}\n\n\t\tconst int SHNAME = (int)bin->shdr[i].sh_name;\n\t\tconst int SHSIZE = (int)bin->shstrtab_size;\n\t\tnidx = SHNAME;\n\t\tif (nidx < 0 || !bin->shstrtab_section || !bin->shstrtab_size || nidx > bin->shstrtab_size) {\n\t\t\tsnprintf (invalid_s, sizeof (invalid_s), \"invalid%d\", invalid_c);\n\t\t\tstrncpy (ret[i].name, invalid_s, sizeof (ret[i].name) - 1);\n\t\t\tinvalid_c++;\n\t\t} else if (bin->shstrtab && (SHNAME > 0) && (SHNAME < SHSIZE)) {\n\t\t\tstrncpy (ret[i].name, &bin->shstrtab[SHNAME], sizeof (ret[i].name) - 1);\n\t\t} else if (bin->shdr[i].sh_type == SHT_NULL) {\n\t\t\t//to follow the same behaviour as readelf\n\t\t\tret[i].name[0] = '\\0';\n\t\t} else {\n\t\t\tsnprintf (unknown_s, sizeof (unknown_s), \"unknown%d\", unknown_c);\n\t\t\tstrncpy (ret[i].name, unknown_s, sizeof (ret[i].name) - 1);\n\t\t\tunknown_c++;\n\t\t}\n\t\tret[i].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nstatic bool is_special_arm_symbol(ELFOBJ *bin, Elf_(Sym) *sym, const char *name) {\n\tif (name[0] != '$') {\n\t\treturn false;\n\t}\n\tswitch (name[1]) {\n\tcase 'a':\n\tcase 't':\n\tcase 'd':\n\tcase 'x':\n\t\treturn (name[2] == '\\0' || name[2] == '.') &&\n\t\t\tELF_ST_TYPE (sym->st_info) == STT_NOTYPE &&\n\t\t\tELF_ST_BIND (sym->st_info) == STB_LOCAL &&\n\t\t\tELF_ST_VISIBILITY (sym->st_info) == STV_DEFAULT;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_special_symbol(ELFOBJ *bin, Elf_(Sym) *sym, const char *name) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn is_special_arm_symbol (bin, sym, name);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char *bind2str(Elf_(Sym) *sym) {\n\tswitch (ELF_ST_BIND (sym->st_info)) {\n\tcase STB_LOCAL:  return R_BIN_BIND_LOCAL_STR;\n\tcase STB_GLOBAL: return R_BIN_BIND_GLOBAL_STR;\n\tcase STB_WEAK:   return R_BIN_BIND_WEAK_STR;\n\tcase STB_NUM:    return R_BIN_BIND_NUM_STR;\n\tcase STB_LOOS:   return R_BIN_BIND_LOOS_STR;\n\tcase STB_HIOS:   return R_BIN_BIND_HIOS_STR;\n\tcase STB_LOPROC: return R_BIN_BIND_LOPROC_STR;\n\tcase STB_HIPROC: return R_BIN_BIND_HIPROC_STR;\n\tdefault:         return R_BIN_BIND_UNKNOWN_STR;\n\t}\n}\n\nstatic const char *type2str(ELFOBJ *bin, struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\tif (bin && ret && is_special_symbol (bin, sym, ret->name)) {\n\t\treturn R_BIN_TYPE_SPECIAL_SYM_STR;\n\t}\n\tswitch (ELF_ST_TYPE (sym->st_info)) {\n\tcase STT_NOTYPE: return R_BIN_TYPE_NOTYPE_STR;\n\tcase STT_OBJECT: return R_BIN_TYPE_OBJECT_STR;\n\tcase STT_FUNC: return R_BIN_TYPE_FUNC_STR;\n\tcase STT_SECTION: return R_BIN_TYPE_SECTION_STR;\n\tcase STT_FILE: return R_BIN_TYPE_FILE_STR;\n\tcase STT_COMMON: return R_BIN_TYPE_COMMON_STR;\n\tcase STT_TLS: return R_BIN_TYPE_TLS_STR;\n\tcase STT_NUM: return R_BIN_TYPE_NUM_STR;\n\tcase STT_LOOS: return R_BIN_TYPE_LOOS_STR;\n\tcase STT_HIOS: return R_BIN_TYPE_HIOS_STR;\n\tcase STT_LOPROC: return R_BIN_TYPE_LOPROC_STR;\n\tcase STT_HIPROC: return R_BIN_TYPE_HIPROC_STR;\n\tdefault: return R_BIN_TYPE_UNKNOWN_STR;\n\t}\n}\n\nstatic void fill_symbol_bind_and_type(ELFOBJ *bin, struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\tret->bind = bind2str (sym);\n\tret->type = type2str (bin, ret, sym);\n}\n\nstatic RBinElfSymbol* get_symbols_from_phdr(ELFOBJ *bin, int type) {\n\tElf_(Sym) *sym = NULL;\n\tElf_(Addr) addr_sym_table = 0;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tRBinElfSymbol *ret = NULL;\n\tint i, r, tsize, nsym, ret_ctr;\n\tut64 toffset = 0, tmp_offset;\n\tut32 size, sym_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dyn_info.dt_symtab == R_BIN_ELF_ADDR_MAX || !bin->dyn_info.dt_syment) {\n\t\treturn NULL;\n\t}\n\n\taddr_sym_table = Elf_(r_bin_elf_v2p) (bin, bin->dyn_info.dt_symtab);\n\tsym_size = bin->dyn_info.dt_syment;\n\tif (!sym_size) {\n\t\tgoto beach;\n\t}\n\n\t//since ELF doesn't specify the symbol table size we may read until the end of the buffer\n\tnsym = (bin->size - addr_sym_table) / sym_size;\n\tif (!UT32_MUL (&size, nsym, sizeof (Elf_ (Sym)))) {\n\t\tgoto beach;\n\t}\n\tif (size < 1) {\n\t\tgoto beach;\n\t}\n\tif (addr_sym_table > bin->size || addr_sym_table + size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (nsym < 1) {\n\t\treturn NULL;\n\t}\n\t// we reserve room for 4096 and grow as needed.\n\tsize_t capacity1 = 4096;\n\tsize_t capacity2 = 4096;\n\tsym = (Elf_(Sym)*) calloc (capacity1, sym_size);\n\tret = (RBinElfSymbol *) calloc (capacity2, sizeof (struct r_bin_elf_symbol_t));\n\tif (!sym || !ret) {\n\t\tgoto beach;\n\t}\n\tfor (i = 1, ret_ctr = 0; i < nsym; i++) {\n\t\tif (i >= capacity1) { // maybe grow\n\t\t\t// You take what you want, but you eat what you take.\n\t\t\tElf_(Sym)* temp_sym = (Elf_(Sym)*) realloc (sym, (size_t)(capacity1 * GROWTH_FACTOR) * sym_size);\n\t\t\tif (!temp_sym) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsym = temp_sym;\n\t\t\tcapacity1 = (size_t)(capacity1 * GROWTH_FACTOR);\n\t\t}\n\t\tif (ret_ctr >= capacity2) { // maybe grow\n\t\t\tRBinElfSymbol *temp_ret = realloc (ret, (size_t)(capacity2 * GROWTH_FACTOR) * sizeof (struct r_bin_elf_symbol_t));\n\t\t\tif (!temp_ret) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = temp_ret;\n\t\t\tcapacity2 = (size_t)(capacity2 * GROWTH_FACTOR);\n\t\t}\n\t\t// read in one entry\n\t\tr = r_buf_read_at (bin->b, addr_sym_table + i * sizeof (Elf_ (Sym)), s, sizeof (Elf_ (Sym)));\n\t\tif (r < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint j = 0;\n#if R_BIN_ELF64\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n\t\tsym[i].st_value = READ64 (s, j);\n\t\tsym[i].st_size = READ64 (s, j);\n#else\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_value = READ32 (s, j);\n\t\tsym[i].st_size = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n#endif\n\t\tbool is_sht_null = false;\n\t\tbool is_vaddr = false;\n\t\t// zero symbol is always empty\n\t\t// Examine entry and maybe store\n\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && sym[i].st_shndx == SHT_NULL) {\n\t\t\tif (sym[i].st_value) {\n\t\t\t\ttoffset = sym[i].st_value;\n\t\t\t} else if ((toffset = get_import_addr (bin, i)) == -1){\n\t\t\t\ttoffset = 0;\n\t\t\t}\n\t\t\ttsize = 16;\n\t\t} else if (type == R_BIN_ELF_ALL_SYMBOLS) {\n\t\t\ttsize = sym[i].st_size;\n\t\t\ttoffset = (ut64) sym[i].st_value;\n\t\t\tis_sht_null = sym[i].st_shndx == SHT_NULL;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t// since we don't know the size of the sym table in this case,\n\t\t// let's stop at the first invalid entry\n\t\tif (!strcmp (bind2str (&sym[i]), R_BIN_BIND_UNKNOWN_STR) ||\n\t\t    !strcmp (type2str (NULL, NULL, &sym[i]), R_BIN_TYPE_UNKNOWN_STR)) {\n\t\t\tgoto done;\n\t\t}\n\t\ttmp_offset = Elf_(r_bin_elf_v2p_new) (bin, toffset);\n\t\tif (tmp_offset == UT64_MAX) {\n\t\t\ttmp_offset = toffset;\n\t\t\tis_vaddr = true;\n\t\t}\n\t\tif (sym[i].st_name + 2 > bin->strtab_size) {\n\t\t\t// Since we are reading beyond the symbol table what's happening\n\t\t\t// is that some entry is trying to dereference the strtab beyond its capacity\n\t\t\t// is not a symbol so is the end\n\t\t\tgoto done;\n\t\t}\n\t\tret[ret_ctr].offset = tmp_offset;\n\t\tret[ret_ctr].size = tsize;\n\t\t{\n\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\tint st_name = sym[i].st_name;\n\t\t\tint maxsize = R_MIN (bin->size, bin->strtab_size);\n\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tconst int len = __strnlen (bin->strtab + st_name, rest);\n\t\t\t\tmemcpy (ret[ret_ctr].name, &bin->strtab[st_name], len);\n\t\t\t}\n\t\t}\n\t\tret[ret_ctr].ordinal = i;\n\t\tret[ret_ctr].in_shdr = false;\n\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\tfill_symbol_bind_and_type (bin, &ret[ret_ctr], &sym[i]);\n\t\tret[ret_ctr].is_sht_null = is_sht_null;\n\t\tret[ret_ctr].is_vaddr = is_vaddr;\n\t\tret[ret_ctr].last = 0;\n\t\tret_ctr++;\n\t}\ndone:\n\t// Size everything down to only what is used\n\t{\n\t\tnsym = i > 0? i: 1;\n\t\tElf_(Sym) *temp_sym = (Elf_(Sym) *)realloc (sym, (size_t)(nsym * GROWTH_FACTOR) * sym_size);\n\t\tif (!temp_sym) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsym = temp_sym;\n\t}\n\t{\n\t\tret_ctr = ret_ctr > 0? ret_ctr: 1;\n\t\tRBinElfSymbol *p = (RBinElfSymbol *)realloc (ret, (ret_ctr + 1) * sizeof (RBinElfSymbol));\n\t\tif (!p) {\n\t\t\tgoto beach;\n\t\t}\n\t\tret = p;\n\t}\n\tret[ret_ctr].last = 1;\n\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && !bin->imports_by_ord_size) {\n\t\tbin->imports_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->imports_by_ord = (RBinImport * *) calloc (ret_ctr + 1, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t} else if (type == R_BIN_ELF_ALL_SYMBOLS && !bin->symbols_by_ord_size && ret_ctr) {\n\t\tbin->symbols_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->symbols_by_ord = (RBinSymbol **) calloc (ret_ctr + 1, sizeof (RBinSymbol*));\n\t\t} else {\n\t\t\tbin->symbols_by_ord = NULL;\n\t\t}\n\t}\n\tfree (sym);\n\treturn ret;\nbeach:\n\tfree (sym);\n\tfree (ret);\n\treturn NULL;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_symbols)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_symbols) {\n\t\treturn bin->phdr_symbols;\n\t}\n\tbin->phdr_symbols = get_symbols_from_phdr (bin, R_BIN_ELF_ALL_SYMBOLS);\n\treturn bin->phdr_symbols;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tif (!bin->phdr_imports) {\n\t\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORT_SYMBOLS);\n\t}\n\treturn bin->phdr_imports;\n}\n\nstatic RBinElfSymbol *Elf_(get_phdr_symbols)(ELFOBJ *bin, int type) {\n\treturn (type != R_BIN_ELF_IMPORT_SYMBOLS)\n\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n}\n\nstatic int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {\n\tint count = 0;\n\tint result = -1;\n\tRBinElfSymbol *ret = *sym;\n\tRBinElfSymbol *phdr_symbols = Elf_(get_phdr_symbols) (bin, type);\n\tRBinElfSymbol *tmp, *p;\n\tHtUP *phd_offset_map = ht_up_new0 ();\n\tHtUP *phd_ordinal_map = ht_up_new0 ();\n\tif (phdr_symbols) {\n\t\tRBinElfSymbol *d = ret;\n\t\twhile (!d->last) {\n\t\t\tht_up_insert (phd_offset_map, d->offset, d);\n\t\t\tht_up_insert (phd_ordinal_map, d->ordinal, d);\n\t\t\td++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\t/* find match in phdr */\n\t\t\td = ht_up_find (phd_offset_map, p->offset, NULL);\n\t\t\tif (!d) {\n\t\t\t\td = ht_up_find (phd_ordinal_map, p->ordinal, NULL);\n\t\t\t}\n\t\t\tif (d) {\n\t\t\t\tp->in_shdr = true;\n\t\t\t\tif (*p->name && *d->name && r_str_startswith (d->name, \"$\")) {\n\t\t\t\t\tstrcpy (d->name, p->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\tif (!p->in_shdr) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t/*Take those symbols that are not present in the shdr but yes in phdr*/\n\t\t/*This should only should happen with fucked up binaries*/\n\t\tif (count > 0) {\n\t\t\t/*what happens if a shdr says it has only one symbol? we should look anyway into phdr*/\n\t\t\ttmp = (RBinElfSymbol*)realloc (ret, (nsym + count + 1) * sizeof (RBinElfSymbol));\n\t\t\tif (!tmp) {\n\t\t\t\tresult = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tret = tmp;\n\t\t\tret[nsym--].last = 0;\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (!p->in_shdr) {\n\t\t\t\t\tmemcpy (&ret[++nsym], p, sizeof (RBinElfSymbol));\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret[nsym + 1].last = 1;\n\t\t}\n\t\t*sym = ret;\n\t\tresult = nsym + 1;\n\t\tgoto done;\n\t}\n\tresult = nsym;\ndone:\n\tht_up_free (phd_offset_map);\n\tht_up_free (phd_ordinal_map);\n\treturn result;\n}\n\nstatic bool is_section_local_sym(ELFOBJ *bin, Elf_(Sym) *sym) {\n\tif (sym->st_name != 0) {\n\t\treturn false;\n\t}\n\tif (ELF_ST_TYPE (sym->st_info) != STT_SECTION) {\n\t\treturn false;\n\t}\n\tif (ELF_ST_BIND (sym->st_info) != STB_LOCAL) {\n\t\treturn false;\n\t}\n\tif (!is_shidx_valid (bin, sym->st_shndx)) {\n\t\treturn false;\n\t}\n\tElf_(Word) sh_name = bin->shdr[sym->st_shndx].sh_name;\n\treturn bin->shstrtab && sh_name < bin->shstrtab_size;\n}\n\nstatic void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {\n\tif (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {\n\t\treturn;\n\t}\n\tr_bin_symbol_free (eobj->symbols_by_ord[ord]);\n\teobj->symbols_by_ord[ord] = ptr;\n}\n\nstatic void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bin);\n\tRBinSymbol *ptr = *sym;\n\tint len = strlen (ptr->name);\n\tif (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {\n\t\tswitch (ptr->name[1]) {\n\t\tcase 'a' : //arm\n\t\t\tptr->bits = 32;\n\t\t\tbreak;\n\t\tcase 't': //thumb\n\t\t\tptr->bits = 16;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': //data\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto arm_symbol;\n\t\t}\n\t} else {\narm_symbol:\n\t\tptr->bits = bin_bits;\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->paddr != UT64_MAX) {\n\t\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\t\tptr->vaddr--;\n\t\t\t\t\tptr->bits = 16;\n\t\t\t\t}\n\t\t\t\tif (ptr->paddr & 1) {\n\t\t\t\t\tptr->paddr--;\n\t\t\t\t\tptr->bits = 16;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nRBinSymbol *Elf_(_r_bin_elf_convert_symbol)(struct Elf_(r_bin_elf_obj_t) *bin,\n\t\t\t\t\t  struct r_bin_elf_symbol_t *symbol,\n\t\t\t\t\t  const char *namefmt) {\n\tut64 paddr, vaddr;\n\tRBinSymbol *ptr = NULL;\n\tif (symbol->is_vaddr) {\n\t\tpaddr = UT64_MAX;\n\t\tvaddr = symbol->offset;\n\t} else {\n\t\tpaddr = symbol->offset;\n\t\tvaddr = Elf_(r_bin_elf_p2v_new) (bin, paddr);\n\t}\n\n\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\treturn NULL;\n\t}\n\tptr->name = symbol->name[0] ? r_str_newf (namefmt, &symbol->name[0]) : strdup (\"\");\n\tptr->forwarder = \"NONE\";\n\tptr->bind = symbol->bind;\n\tptr->type = symbol->type;\n\tptr->is_imported = symbol->is_imported;\n\tptr->paddr = paddr;\n\tptr->vaddr = vaddr;\n\tptr->size = symbol->size;\n\tptr->ordinal = symbol->ordinal;\n\t// detect thumb\n\tif (bin->ehdr.e_machine == EM_ARM && *ptr->name) {\n\t\t_set_arm_thumb_bits (bin, &ptr);\n\t}\n\n\treturn ptr;\n}\n\nstatic ut32 hashRBinElfSymbol(const void *obj) {\n\tconst RBinElfSymbol *symbol = (const RBinElfSymbol *)obj;\n\tif (!symbol || !*symbol->name) {\n\t\treturn 0;\n\t}\n\tint hash = sdb_hash (symbol->name);\n\thash ^= sdb_hash (symbol->type);\n\thash ^= (symbol->offset >> 32);\n\thash ^= (symbol->offset & 0xffffffff);\n\treturn hash;\n}\n\nstatic int cmp_RBinElfSymbol(const RBinElfSymbol *a, const RBinElfSymbol *b) {\n\tif (a->offset != b->offset) {\n\t\treturn 1;\n\t}\n\tint result = strcmp (a->name, b->name);\n\tif (result != 0) {\n\t\treturn result;\n\t}\n\treturn strcmp (a->type, b->type);\n}\n\nstatic RBinElfSymbol* parse_gnu_debugdata(ELFOBJ *bin, size_t *ret_size) {\n\tif (ret_size) {\n\t\t*ret_size = 0;\n\t}\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strcmp (bin->g_sections[i].name, \".gnu_debugdata\")) {\n\t\t\t\tut64 addr = bin->g_sections[i].offset;\n\t\t\t\tut64 size = bin->g_sections[i].size;\n\t\t\t\tif (size < 10) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut8 *data = malloc (size + 1);\n\t\t\t\tif (r_buf_read_at (bin->b, addr, data, size) == -1) {\n\t\t\t\t\teprintf (\"Cannot read%c\\n\", 10);\n\t\t\t\t}\n\t\t\t\tsize_t osize;\n\t\t\t\tut8 *odata = r_sys_unxz (data, size, &osize);\n\t\t\t\tif (odata) {\n\t\t\t\t\tRBuffer *newelf = r_buf_new_with_pointers (odata, osize, false);\n\t\t\t\t\tELFOBJ* newobj = Elf_(r_bin_elf_new_buf) (newelf, false);\n\t\t\t\t\tRBinElfSymbol *symbol = NULL;\n\t\t\t\t\tif (newobj) {\n\t\t\t\t\t\tsymbol = Elf_(r_bin_elf_get_symbols) (newobj);\n\t\t\t\t\t\tnewobj->g_symbols = NULL;\n\t\t\t\t\t\tElf_(r_bin_elf_free)(newobj);\n\t\t\t\t\t}\n\t\t\t\t\tr_buf_free (newelf);\n\t\t\t\t\tfree (odata);\n\t\t\t\t\tif (ret_size) {\n\t\t\t\t\t\t*ret_size = i;\n\t\t\t\t\t}\n\t\t\t\t\tfree (data);\n\t\t\t\t\treturn symbol;\n\t\t\t\t}\n\t\t\t\tfree (data);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// TODO: return RList<RBinSymbol*> .. or run a callback with that symbol constructed, so we don't have to do it twice\nstatic RBinElfSymbol* Elf_(_r_bin_elf_get_symbols_imports)(ELFOBJ *bin, int type) {\n\tut32 shdr_size;\n\tint tsize, nsym, ret_ctr = 0, i, j, r, k, newsize;\n\tut64 toffset;\n\tut32 size = 0;\n\tRBinElfSymbol *ret = NULL, *import_ret = NULL;\n\tRBinSymbol *import_sym_ptr = NULL;\n\tsize_t ret_size = 0, prev_ret_size = 0, import_ret_ctr = 0;\n\tElf_(Shdr) *strtab_section = NULL;\n\tElf_(Sym) *sym = NULL;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tchar *strtab = NULL;\n\tHtPP *symbol_map = NULL;\n\tHtPPOptions symbol_map_options = {\n\t\t.cmp = (HtPPListComparator)cmp_RBinElfSymbol,\n\t\t.hashfn = hashRBinElfSymbol,\n\t\t.dupkey = NULL,\n\t\t.calcsizeK = NULL,\n\t\t.calcsizeV = NULL,\n\t\t.freefn = NULL,\n\t\t.elem_size = sizeof (HtPPKv),\n\t};\n\n\tif (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {\n\t\treturn Elf_(get_phdr_symbols) (bin, type);\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn NULL;\n\t}\n\tif (shdr_size + 8 > bin->size) {\n\t\treturn NULL;\n\t}\n\tRBinElfSymbol *dbgsyms = parse_gnu_debugdata (bin, &ret_size);\n\tif (dbgsyms) {\n\t\tret = dbgsyms;\n\t\tret_ctr = ret_size;\n\t} else {\n\t\tret_ctr = 0;\n\t\tret_size = 0;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (((type & R_BIN_ELF_SYMTAB_SYMBOLS) && bin->shdr[i].sh_type == SHT_SYMTAB) ||\n\t\t\t((type & R_BIN_ELF_DYNSYM_SYMBOLS) && bin->shdr[i].sh_type == SHT_DYNSYM)) {\n\t\t\tif (bin->shdr[i].sh_link < 1) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// hack to avoid asan cry\n\t\t\tif ((bin->shdr[i].sh_link * sizeof (Elf_(Shdr))) >= shdr_size) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrtab_section = &bin->shdr[bin->shdr[i].sh_link];\n\t\t\tif (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {\n\t\t\t\tR_LOG_ERROR (\"size (syms strtab)\");\n\t\t\t\tfree (ret);\n\t\t\t\tfree (strtab);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!strtab) {\n\t\t\t\tif (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {\n\t\t\t\t\tR_LOG_ERROR (\"malloc (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (strtab_section->sh_offset > bin->size ||\n\t\t\t\t\t\tstrtab_section->sh_offset + strtab_section->sh_size > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, strtab_section->sh_offset,\n\t\t\t\t\t\t\t(ut8*)strtab, strtab_section->sh_size) == -1) {\n\t\t\t\t\tR_LOG_ERROR (\"read (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewsize = 1 + bin->shdr[i].sh_size;\n\t\t\tif (newsize < 0 || newsize > bin->size) {\n\t\t\t\tR_LOG_ERROR (\"invalid shdr %d size\", i);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));\n\t\t\tif (nsym < 0) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\t{\n\t\t\t\tut64 sh_begin = bin->shdr[i].sh_offset;\n\t\t\t\tut64 sh_end = sh_begin + bin->shdr[i].sh_size;\n\t\t\t\tif (sh_begin > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (sh_end > bin->size) {\n\t\t\t\t\tst64 newshsize = bin->size - sh_begin;\n\t\t\t\t\tnsym = (int)(newshsize / sizeof (Elf_(Sym)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {\n\t\t\t\tR_LOG_ERROR (\"calloc (syms)\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (size < 1 || size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (j = 0; j < nsym; j++) {\n\t\t\t\tint k = 0;\n\t\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));\n\t\t\t\tif (r < 1) {\n\t\t\t\t\tR_LOG_ERROR (\"read (sym)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n#if R_BIN_ELF64\n\t\t\t\tsym[j].st_name = READ32 (s, k);\n\t\t\t\tsym[j].st_info = READ8 (s, k);\n\t\t\t\tsym[j].st_other = READ8 (s, k);\n\t\t\t\tsym[j].st_shndx = READ16 (s, k);\n\t\t\t\tsym[j].st_value = READ64 (s, k);\n\t\t\t\tsym[j].st_size = READ64 (s, k);\n#else\n\t\t\t\tsym[j].st_name = READ32 (s, k);\n\t\t\t\tsym[j].st_value = READ32 (s, k);\n\t\t\t\tsym[j].st_size = READ32 (s, k);\n\t\t\t\tsym[j].st_info = READ8 (s, k);\n\t\t\t\tsym[j].st_other = READ8 (s, k);\n\t\t\t\tsym[j].st_shndx = READ16 (s, k);\n#endif\n\t\t\t}\n\t\t\tvoid *rett = realloc (ret, (ret_size + nsym) * sizeof (RBinElfSymbol));\n\t\t\tif (!rett) {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d symbols.\", (int)(nsym + ret_size));\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = rett;\n\t\t\tmemset (ret + ret_size, 0, nsym * sizeof (RBinElfSymbol));\n\t\t\tprev_ret_size = ret_size;\n\t\t\tret_size += nsym;\n\t\t\tsymbol_map = ht_pp_new_opt (&symbol_map_options);\n\t\t\tfor (k = 0; k < prev_ret_size; k++) {\n\t\t\t\tif (ret[k].name[0]) {\n\t\t\t\t\tht_pp_insert (symbol_map, ret + k, ret + k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k < nsym; k++) {\n\t\t\t\tbool is_sht_null = false;\n\t\t\t\tbool is_vaddr = false;\n\t\t\t\tbool is_imported = false;\n\t\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\t\t\t\tif (sym[k].st_value) {\n\t\t\t\t\t\ttoffset = sym[k].st_value;\n\t\t\t\t\t} else if ((toffset = get_import_addr (bin, k)) == -1) {\n\t\t\t\t\t\ttoffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttsize = 16;\n\t\t\t\t\tis_imported = sym[k].st_shndx == STN_UNDEF;\n\t\t\t\t} else {\n\t\t\t\t\ttsize = sym[k].st_size;\n\t\t\t\t\ttoffset = (ut64)sym[k].st_value;\n\t\t\t\t\tis_sht_null = sym[k].st_shndx == SHT_NULL;\n\t\t\t\t}\n\t\t\t\tif (is_bin_etrel (bin)) {\n\t\t\t\t\tif (sym[k].st_shndx < bin->ehdr.e_shnum) {\n\t\t\t\t\t\tret[ret_ctr].offset = sym[k].st_value + bin->shdr[sym[k].st_shndx].sh_offset;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret[ret_ctr].offset = Elf_(r_bin_elf_v2p_new) (bin, toffset);\n\t\t\t\t\tif (ret[ret_ctr].offset == UT64_MAX) {\n\t\t\t\t\t\tret[ret_ctr].offset = toffset;\n\t\t\t\t\t\tis_vaddr = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].size = tsize;\n\t\t\t\tif (sym[k].st_name + 1 > strtab_section->sh_size) {\n\t\t\t\t\tR_LOG_DEBUG (\"index out of strtab range (%\"PFMT64d\" / %\"PFMT64d\")\\n\",\n\t\t\t\t\t\t(ut64)sym[k].st_name, (ut64)strtab_section->sh_size);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint st_name = sym[k].st_name;\n\t\t\t\t\tint maxsize = R_MIN (r_buf_size (bin->b), strtab_section->sh_size);\n\t\t\t\t\tif (is_section_local_sym (bin, &sym[k])) {\n\t\t\t\t\t\tconst char *shname = &bin->shstrtab[bin->shdr[sym[k].st_shndx].sh_name];\n\t\t\t\t\t\tr_str_ncpy (ret[ret_ctr].name, shname, ELF_STRING_LENGTH - 1);\n\t\t\t\t\t} else if (st_name <= 0 || st_name >= maxsize) {\n\t\t\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (ret[ret_ctr].name, &strtab[st_name], ELF_STRING_LENGTH - 1);\n\t\t\t\t\t\tret[ret_ctr].type = type2str (bin, &ret[ret_ctr], &sym[k]);\n\n\t\t\t\t\t\tif (ht_pp_find (symbol_map, &ret[ret_ctr], NULL)) {\n\t\t\t\t\t\t\tmemset (ret + ret_ctr, 0, sizeof (RBinElfSymbol));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].ordinal = k;\n\t\t\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\t\tfill_symbol_bind_and_type (bin, &ret[ret_ctr], &sym[k]);\n\t\t\t\tret[ret_ctr].is_sht_null = is_sht_null;\n\t\t\t\tret[ret_ctr].is_vaddr = is_vaddr;\n\t\t\t\tret[ret_ctr].last = 0;\n\t\t\t\tret[ret_ctr].is_imported = is_imported;\n\t\t\t\tret_ctr++;\n\t\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && is_imported) {\n\t\t\t\t\timport_ret_ctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_FREE (strtab);\n\t\t\tR_FREE (sym);\n\t\t\tht_pp_free (symbol_map);\n\t\t\tsymbol_map = NULL;\n\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!ret) {\n\t\treturn Elf_(get_phdr_symbols) (bin, type);\n\t}\n\tret[ret_ctr].last = 1; // ugly dirty hack :D\n\tint max = -1;\n\tRBinElfSymbol *aux = NULL;\n\tnsym = Elf_(fix_symbols) (bin, ret_ctr, type, &ret);\n\tif (nsym == -1) {\n\t\tgoto beach;\n\t}\n\n\t// Elf_(fix_symbols) may find additional symbols, some of which could be\n\t// imported symbols. Let's reserve additional space for them.\n\tr_warn_if_fail (nsym >= ret_ctr);\n\timport_ret_ctr += nsym - ret_ctr;\n\n\taux = ret;\n\twhile (!aux->last) {\n\t\tif ((int)aux->ordinal > max) {\n\t\t\tmax = aux->ordinal;\n\t\t}\n\t\taux++;\n\t}\n\tnsym = max;\n\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\tR_FREE (bin->imports_by_ord);\n\t\tbin->imports_by_ord_size = nsym + 1;\n\t\tbin->imports_by_ord = (RBinImport**)calloc (R_MAX (1, nsym + 1), sizeof (RBinImport*));\n\t\tR_FREE (bin->symbols_by_ord);\n\t\tbin->symbols_by_ord_size = nsym + 1;\n\t\tbin->symbols_by_ord = (RBinSymbol**)calloc (R_MAX (1, nsym + 1), sizeof (RBinSymbol*));\n\t\timport_ret = calloc (import_ret_ctr + 1, sizeof (RBinElfSymbol));\n\t\tif (!import_ret) {\n\t\t\tR_LOG_DEBUG (\"Cannot allocate %d symbols\", nsym);\n\t\t\tgoto beach;\n\t\t}\n\t\timport_ret_ctr = 0;\n\t\ti = -1;\n\t\twhile (!ret[++i].last) {\n\t\t\tif (!(import_sym_ptr = Elf_(_r_bin_elf_convert_symbol) (bin, &ret[i], \"%s\"))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsetsymord (bin, import_sym_ptr->ordinal, import_sym_ptr);\n\t\t\tif (ret[i].is_imported) {\n\t\t\t\tmemcpy (&import_ret[import_ret_ctr], &ret[i], sizeof (RBinElfSymbol));\n\t\t\t\t++import_ret_ctr;\n\t\t\t}\n\t\t}\n\t\timport_ret[import_ret_ctr].last = 1;\n\t\tR_FREE (ret);\n\t\treturn import_ret;\n\t}\n\treturn ret;\nbeach:\n\tfree (ret);\n\tfree (sym);\n\tfree (strtab);\n\tht_pp_free (symbol_map);\n\treturn NULL;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_symbols)(ELFOBJ *bin) {\n\tif (!bin->g_symbols) {\n\t\tbin->g_symbols = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_ALL_SYMBOLS);\n\t}\n\treturn bin->g_symbols;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_imports)(ELFOBJ *bin) {\n\tif (!bin->g_imports) {\n\t\tbin->g_imports = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_IMPORT_SYMBOLS);\n\t}\n\treturn bin->g_imports;\n}\n\nRBinElfField* Elf_(r_bin_elf_get_fields)(ELFOBJ *bin) {\n\tRBinElfField *ret = NULL;\n\tint i = 0, j;\n\tif (!bin || !(ret = calloc ((bin->ehdr.e_phnum + 3 + 1), sizeof (RBinElfField)))) {\n\t\treturn NULL;\n\t}\n\tstrncpy (ret[i].name, \"ehdr\", ELF_STRING_LENGTH);\n\tret[i].offset = 0;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"shoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_shoff;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"phoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_phoff;\n\tret[i++].last = 0;\n\tfor (j = 0; bin->phdr && j < bin->ehdr.e_phnum; i++, j++) {\n\t\tsnprintf (ret[i].name, ELF_STRING_LENGTH, \"phdr_%i\", j);\n\t\tret[i].offset = bin->phdr[j].p_offset;\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nvoid Elf_(r_bin_elf_free)(ELFOBJ* bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\tfree (bin->phdr);\n\tfree (bin->shdr);\n\tfree (bin->strtab);\n\tfree (bin->shstrtab);\n\tfree (bin->dynstr);\n\tr_vector_fini (&bin->dyn_info.dt_needed);\n\t//free (bin->strtab_section);\n\tsize_t i;\n\tif (bin->imports_by_ord) {\n\t\tfor (i = 0; i<bin->imports_by_ord_size; i++) {\n\t\t\tfree (bin->imports_by_ord[i]);\n\t\t}\n\t\tfree (bin->imports_by_ord);\n\t}\n\tif (bin->symbols_by_ord) {\n\t\tfor (i = 0; i<bin->symbols_by_ord_size; i++) {\n\t\t\tr_bin_symbol_free (bin->symbols_by_ord[i]);\n\t\t}\n\t\tfree (bin->symbols_by_ord);\n\t}\n\tr_buf_free (bin->b);\n\tif (bin->g_symbols != bin->phdr_symbols) {\n\t\tR_FREE (bin->phdr_symbols);\n\t}\n\tif (bin->g_imports != bin->phdr_imports) {\n\t\tR_FREE (bin->phdr_imports);\n\t}\n\tR_FREE (bin->g_sections);\n\tR_FREE (bin->g_symbols);\n\tR_FREE (bin->g_imports);\n\tR_FREE (bin->g_relocs);\n\tht_up_free (bin->rel_cache);\n\tbin->rel_cache = NULL;\n\tsdb_free (bin->kv);\n\tfree (bin);\n}\n\nELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tif (bin) {\n\t\tbin->kv = sdb_new0 ();\n\t\tbin->size = r_buf_size (buf);\n\t\tbin->verbose = verbose;\n\t\tbin->b = r_buf_ref (buf);\n\t\tif (!elf_init (bin)) {\n\t\t\tElf_(r_bin_elf_free) (bin);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn bin;\n}\n\nstatic int is_in_pphdr(Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_offset && addr < p->p_offset + p->p_filesz;\n}\n\nstatic int is_in_vphdr(Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_vaddr && addr < p->p_vaddr + p->p_filesz;\n}\n\n/* Deprecated temporarily. Use r_bin_elf_p2v_new in new code for now. */\nut64 Elf_(r_bin_elf_p2v) (ELFOBJ *bin, ut64 paddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn paddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\tif (!p->p_vaddr && !p->p_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn paddr;\n}\n\n/* Deprecated temporarily. Use r_bin_elf_v2p_new in new code for now. */\nut64 Elf_(r_bin_elf_v2p)(ELFOBJ *bin, ut64 vaddr) {\n\tr_return_val_if_fail (bin, 0); // UT64_MAX or vaddr?\n\t// r_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn vaddr;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\tif (!p->p_offset && !p->p_vaddr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn vaddr;\n}\n\n/* converts a physical address to the virtual address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_p2v_new) (ELFOBJ *bin, ut64 paddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\n/* converts a virtual address to the relative physical address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_v2p_new) (ELFOBJ *bin, ut64 vaddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic bool get_nt_file_maps(ELFOBJ *bin, RList *core_maps) {\n\tut16 ph, ph_num = bin->ehdr.e_phnum;\n\n\tfor (ph = 0; ph < ph_num; ph++) {\n\t\tElf_(Phdr) *p = &bin->phdr[ph];\n\t\tif (p->p_type == PT_NOTE) {\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint elf_nhdr_size = (bits == 64) ? sizeof (Elf64_Nhdr) : sizeof (Elf32_Nhdr);\n\t\t\tint size_of = (bits == 64) ? sizeof (ut64) : sizeof (ut32);\n\t\t\tvoid *elf_nhdr = calloc (elf_nhdr_size, 1);\n\t\t\tut64 offset = 0;\n\t\t\tbool found = false;\n\n\t\t\twhile (!found) {\n\t\t\t\tint ret;\n\t\t\t\tut32 n_descsz, n_namesz, n_type;\n\t\t\t\tret = r_buf_read_at (bin->b,\n\t\t\t\t\t\tbin->phdr[ph].p_offset + offset,\n\t\t\t\t\t\telf_nhdr, elf_nhdr_size);\n\t\t\t\tif (ret != elf_nhdr_size) {\n\t\t\t\t\teprintf (\"Cannot read more NOTES header from CORE\\n\");\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\tn_descsz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf64_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t} else {\n\t\t\t\t\tn_descsz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf32_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t}\n\n\t\t\t\tif (n_type == NT_FILE) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\toffset += elf_nhdr_size + n_namesz;\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t} else {\n\t\t\t\t\toffset += elf_nhdr_size + n_descsz + n_namesz;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 i = bin->phdr[ph].p_offset + offset;\n\t\t\tut64 n_maps;\n\t\t\tif (bits == 64) {\n\t\t\t\tn_maps = BREAD64 (bin->b, i);\n\t\t\t\t(void)BREAD64 (bin->b, i);\n\t\t\t} else {\n\t\t\t\tn_maps = BREAD32 (bin->b, i);\n\t\t\t\t(void)BREAD32 (bin->b, i);\n\t\t\t}\n\t\t\tut64 jump = ((size_of * 3) * n_maps) + i;\n\t\t\tint len_str = 0;\n\t\t\twhile (n_maps > 0) {\n\t\t\t\tut64 addr;\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\taddr = BREAD64 (bin->b, i);\n\t\t\t\t} else {\n\t\t\t\t\taddr = BREAD32 (bin->b, i);\n\t\t\t\t}\n\t\t\t\tif (addr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar str[512] = {0};\n\t\t\t\tr_buf_read_at (bin->b, jump + len_str, (ut8*)str, sizeof (str) - 1);\n\t\t\t\tstr[sizeof (str) - 1] = 0; // null terminate string\n\t\t\t\tRListIter *iter;\n\t\t\t\tRBinMap *p;\n\t\t\t\tr_list_foreach (core_maps, iter, p) {\n\t\t\t\t\tif (p->addr == addr) {\n\t\t\t\t\t\tp->file = strdup (str);\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tlen_str += strlen (str) + 1;\n\t\t\t\tn_maps--;\n\t\t\t\ti += (size_of * 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\treturn false;\n}\n\nstatic void r_bin_elf_map_free(RBinMap *map) {\n\tif (map) {\n\t\tfree (map->file);\n\t\tfree (map);\n\t}\n}\n\nRList *Elf_(r_bin_elf_get_maps)(ELFOBJ *bin) {\n\tut16 ph, ph_num = bin->ehdr.e_phnum; //Skip PT_NOTE\n\tif (!bin->phdr) {\n\t\treturn NULL;\n\t}\n\tRList *maps = r_list_newf ((RListFree)r_bin_elf_map_free);\n\tfor (ph = 0; ph < ph_num; ph++) {\n\t\tElf_(Phdr) *p = &bin->phdr[ph];\n\t\tif (p->p_type == PT_LOAD) {\n\t\t\tRBinMap *map = R_NEW0 (RBinMap);\n\t\t\tif (map) {\n\t\t\t\tmap->addr = p->p_vaddr;\n\t\t\t\tmap->size = p->p_memsz;\n\t\t\t\tmap->perms = p->p_flags;\n\t\t\t\tmap->offset = p->p_offset;\n\t\t\t\tmap->file = NULL;\n\t\t\t\tr_list_append (maps, map);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!r_list_empty (maps)) {\n\t\tif (!get_nt_file_maps (bin, maps)) {\n\t\t\teprintf (\"Could not retrieve the names of all maps from NT_FILE\\n\");\n\t\t}\n\t}\n\n\treturn maps;\n}\n\nchar *Elf_(r_bin_elf_compiler)(ELFOBJ *bin) {\n\tRBinElfSection *section = get_section_by_name (bin, \".comment\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tut64 off = section->offset;\n\tut32 sz = R_MIN (section->size, 128);\n\tif (sz < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (sz + 1);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, off, (ut8*)buf, sz) < 1) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tbuf[sz] = 0;\n\tconst size_t buflen = strlen (buf);\n\tchar *nullbyte = buf + buflen;\n\tif (buflen != sz && nullbyte[1] && buflen < sz) {\n\t\tnullbyte[0] = ' ';\n\t}\n\tbuf[sz] = 0;\n\tr_str_trim (buf);\n\tchar * res = r_str_escape (buf);\n\tfree (buf);\n\treturn res;\n}\n\nbool Elf_(r_bin_elf_is_executable)(ELFOBJ *bin) {\n\tconst int t = bin->ehdr.e_type;\n\treturn t == ET_EXEC || t == ET_DYN;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2014-2022 - Fedor Sakharov, pancake */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include <r_util.h>\n\n#include \"../arch/msp430/msp430_disas.h\"\n\nstatic int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tstruct msp430_cmd cmd = {0};\n\top->size = -1;\n\top->nopcode = 1;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->family = R_ANAL_OP_FAMILY_CPU;\n\n\tint ret = op->size = msp430_decode_command (buf, len, &cmd);\n\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\tif (ret < 1) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t} else if (ret > 0) {\n\t\t\tif (cmd.operands[0]) {\n\t\t\t\top->mnemonic = r_str_newf (\"%s %s\",cmd.instr, cmd.operands);\n\t\t\t} else {\n\t\t\t\top->mnemonic = strdup (cmd.instr);\n\t\t\t}\n\t\t}\n\t\t{ // if (a->syntax != R_ASM_SYNTAX_ATT)\n\t\t\tchar *ba = op->mnemonic;\n\t\t\tr_str_replace_ch (ba, '#', 0, 1);\n\t\t\t// r_str_replace_ch (ba, \"$\", \"$$\", 1);\n\t\t\tr_str_replace_ch (ba, '&', 0, 1);\n\t\t\tr_str_replace_ch (ba, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\top->addr = addr;\n\n\tswitch (cmd.type) {\n\tcase MSP430_ONEOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_RRA:\n\t\tcase MSP430_RRC:\n\t\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\t\tbreak;\n\t\tcase MSP430_PUSH:\n\t\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t\tbreak;\n\t\tcase MSP430_CALL:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->fail = addr + op->size;\n\t\t\tif (len > 4) {\n\t\t\t\top->jump = r_read_at_le16 (buf, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_RETI:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MSP430_TWOOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_BIT:\n\t\tcase MSP430_BIC:\n\t\tcase MSP430_BIS:\n\t\tcase MSP430_MOV:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tif ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {\n\t\t\t\t// Emulated branch instruction, moves source operand to PC register.\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_DADD:\n\t\tcase MSP430_ADDC:\n\t\tcase MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;\n\t\tcase MSP430_SUBC:\n\t\tcase MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;\n\t\tcase MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;\n\t\tcase MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;\n\t\tcase MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;\n\t\t}\n\t\tbreak;\n\tcase MSP430_JUMP:\n\t\tif (cmd.jmp_cond == MSP430_JMP) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t}\n\t\top->jump = addr + cmd.jmp_addr;\n\t\top->fail = addr + 2;\n\t\tbreak;\n\tcase MSP430_INV:\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"=SN\tr0\\n\"\n\t\t// this is the \"new\" ABI, the old was reverse order\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\n\t\t\"gpr\tpc\t.16 0 0\\n\" // same as r0\n\t\t\"gpr\tsp\t.16 2 0\\n\" // same as r1\n\t\t\"flg\tsr\t.16 4 0\\n\" // same as r2\n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t// between is SCG1 SCG0 OSOFF CPUOFF GIE\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nRAnalPlugin r_anal_plugin_msp430 = {\n\t.name = \"msp430\",\n\t.desc = \"TI MSP430 code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"msp430\",\n\t.bits = 16,\n\t.op = msp430_op,\n\t.set_reg_profile = &set_reg_profile,\n};\n", "/* radare - LGPL - Copyright 2008-2022 - nibble, pancake, alvaro_fe */\n\n#define R_LOG_ORIGIN \"elf\"\n#include <r_types.h>\n#include <r_util.h>\n#include \"elf.h\"\n\n#define MIPS_PLT_OFFSET 0x20\n#define RISCV_PLT_OFFSET 0x20\n#define LOONGARCH_PLT_OFFSET 0x20\n\n#define RISCV_PLT_ENTRY_SIZE 0x10\n#define LOONGARCH_PLT_ENTRY_SIZE 0x10\n#define X86_PLT_ENTRY_SIZE 0x10\n\n#define SPARC_OFFSET_PLT_ENTRY_FROM_GOT_ADDR -0x6\n#define X86_OFFSET_PLT_ENTRY_FROM_GOT_ADDR -0x6\n\n#define ELF_PAGE_MASK 0xFFFFFFFFFFFFF000LL\n#define ELF_PAGE_SIZE 12\n\n#define R_ELF_NO_RELRO 0\n#define R_ELF_PART_RELRO 1\n#define R_ELF_FULL_RELRO 2\n\n#define MAX_REL_RELA_SZ (sizeof (Elf_(Rel)) > sizeof (Elf_(Rela))? sizeof (Elf_(Rel)): sizeof (Elf_(Rela)))\n\n#define READ8(x, i) r_read_ble8((x) + (i)); (i) += 1\n#define READ16(x, i) r_read_ble16((x) + (i), bin->endian); (i) += 2\n#define READ32(x, i) r_read_ble32((x) + (i), bin->endian); (i) += 4\n#define READ64(x, i) r_read_ble64((x) + (i), bin->endian); (i) += 8\n\n#define BREAD8(x, i) r_buf_read_ble8_at (x, i); (i) += 1\n#define BREAD16(x, i) r_buf_read_ble16_at (x, i, bin->endian); (i) += 2\n#define BREAD32(x, i) r_buf_read_ble32_at (x, i, bin->endian); (i) += 4\n#define BREAD64(x, i) r_buf_read_ble64_at (x, i, bin->endian); (i) += 8\n\n#define NUMENTRIES_ROUNDUP(sectionsize, entrysize) (((sectionsize) + (entrysize)-1) / (entrysize))\n#define COMPUTE_PLTGOT_POSITION(rel, pltgot_addr, n_initial_unused_entries) \\\n\t((rel->rva - pltgot_addr - n_initial_unused_entries * R_BIN_ELF_WORDSIZE) / R_BIN_ELF_WORDSIZE)\n\n#define GROWTH_FACTOR (1.5)\n\n#define round_up(a) ((((a) + (4) - (1)) / (4)) * (4))\n\n#define EF_MIPS_ABI_O32\t\t0x00001000  /* O32 ABI.  */\n#define EF_MIPS_ABI_O64\t\t0x00002000  /* O32 extended for 64 bit.  */\n#define EF_MIPS_ABI\t\t\t0x0000f000\n\nstatic inline bool is_elfclass64(Elf_(Ehdr) *h) {\n\treturn h->e_ident[EI_CLASS] == ELFCLASS64;\n}\n\nstatic bool is_mips_o32(Elf_(Ehdr) *h) {\n\tif (h->e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\tif ((h->e_flags & EF_MIPS_ABI2) != 0) {\n\t\treturn false;\n\t}\n\tif (((h->e_flags & EF_MIPS_ABI) != 0) &&\n\t\t((h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool is_mips_n32(Elf_(Ehdr) *h) {\n\tif (h->e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\tif (((h->e_flags & EF_MIPS_ABI2) == 0) ||\n\t\t((h->e_flags & EF_MIPS_ABI) != 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nenum {\n\tX86,\n\tX86_64,\n\tARM,\n\tAARCH64,\n\tRCE,\n\tARCH_LEN\n};\n\ntypedef struct reginfo {\n\tut32 regsize;\n\tut32 regdelta;\n} reginfo_t;\n\nstatic reginfo_t reginf[ARCH_LEN] = {\n\t{ 160, 0x5c },\n\t{ 216, 0x84 },\n\t{ 72, 0x5c },\n\t{ 272, 0x84 },\n\t{ 272, 0x84 }\n};\n\nstatic inline int __strnlen(const char *str, int len) {\n\tint l = 0;\n\twhile (IS_PRINTABLE (*str) && --len) {\n\t\tif (((ut8)*str) == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tl++;\n\t}\n\treturn l + 1;\n}\n\nstatic bool is_bin_etrel(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type == ET_REL;\n}\n\nstatic bool __is_valid_ident(ELFOBJ *bin) {\n\treturn !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||\n\t\t!strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);\n}\n\nstatic bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (bin->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (bin->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (bin->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (bin->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n\tsdb_set (bin->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);\n\tbin->ehdr.e_machine = READ16 (ehdr, i);\n\tbin->ehdr.e_version = READ32 (ehdr, i);\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i);\n\tbin->ehdr.e_phoff = READ64 (ehdr, i);\n\tbin->ehdr.e_shoff = READ64 (ehdr, i);\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i);\n\tbin->ehdr.e_phoff = READ32 (ehdr, i);\n\tbin->ehdr.e_shoff = READ32 (ehdr, i);\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i);\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_shnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i);\n\treturn true;\n\t// [Outdated] Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}\n\nut64 Elf_(r_bin_elf_get_phnum)(ELFOBJ *obj) {\n\tr_return_val_if_fail (obj, 0);\n\tut64 num = obj->ehdr.e_phnum & UT16_MAX;\n\tif (obj->ehdr.e_phnum == 0xffff) {\n\t\tut32 shnum = obj->ehdr.e_shnum;\n\t\t// sh_info member of the initial entry in section header table.\n\t\tif (shnum > 0) {\n\t\t\tut32 shoff = obj->ehdr.e_shoff;\n\t\t\tElf_(Shdr) shdr = {0};\n\t\t\t(void)r_buf_read_at (obj->b, shoff, (ut8 *)&shdr, sizeof (shdr));\n\t\t\tnum = shdr.sh_info;\n\t\t\tif ((int)(shdr.sh_info) < 1) {\n\t\t\t\treturn UT16_MAX;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nstatic bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_DEBUG (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t//\tbin->phdr[i].p_flags |= 1; tiny.elf needs this somehow :? LOAD0 is always +x for linux?\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\t/* Here is the where all the fun starts.\n\t * Linux kernel since 2005 calculates phdr offset wrongly\n\t * adding it to the load address (va of the LOAD0).\n\t * See `fs/binfmt_elf.c` file this line:\n\t *    NEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\t * So after the first read, we fix the address and read it again\n\t */\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\n\treturn true;\n}\n\nstatic int init_phdr(ELFOBJ *bin) {\n\tut32 phdr_size;\n\n\tr_return_val_if_fail (bin && !bin->phdr, false);\n\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (!UT32_MUL (&phdr_size, (ut32)bin->ehdr.e_phnum, sizeof (Elf_(Phdr)))) {\n\t\treturn false;\n\t}\n\tif (!phdr_size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > (ut32)bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff + phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tif (!(bin->phdr = R_NEWS0 (Elf_(Phdr), phnum))) {\n\t\tr_sys_perror (\"malloc (phdr)\");\n\t\treturn false;\n\t}\n\n\tbool linux_kern_hack = false;\n\t/* Enable this hack only for the X86 64bit ELFs */\n\tconst int _128K = 1024 * 128;\n\tif (r_buf_size (bin->b) > _128K && (bin->ehdr.e_machine == EM_X86_64 || bin->ehdr.e_machine == EM_386)) {\n\t\tlinux_kern_hack = true;\n\t}\n\tif (!read_phdr (bin, linux_kern_hack)) {\n\t\treturn false;\n\t}\n\n\tsdb_num_set (bin->kv, \"elf_phdr.offset\", bin->ehdr.e_phoff, 0);\n\tsdb_num_set (bin->kv, \"elf_phdr.size\", sizeof (Elf_(Phdr)), 0);\n\tsdb_set (bin->kv, \"elf_p_type.cparse\", \"enum elf_p_type {PT_NULL=0,PT_LOAD=1,PT_DYNAMIC=2,\"\n\t\t\"PT_INTERP=3,PT_NOTE=4,PT_SHLIB=5,PT_PHDR=6,PT_LOOS=0x60000000,\"\n\t\t\"PT_HIOS=0x6fffffff,PT_LOPROC=0x70000000,PT_HIPROC=0x7fffffff};\",\n\t\t0);\n\tsdb_set (bin->kv, \"elf_p_flags.cparse\", \"enum elf_p_flags {PF_None=0,PF_Exec=1,\"\n\t\t\t\"PF_Write=2,PF_Write_Exec=3,PF_Read=4,PF_Read_Exec=5,PF_Read_Write=6,\"\n\t\t\t\"PF_Read_Write_Exec=7};\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags\"\n\t\t\t\" offset vaddr paddr filesz memsz align\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr\"\n\t\t\t\" filesz memsz (elf_p_flags)flags align\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_p_type.cparse`; td `k bin/cur/info/elf_p_flags.cparse`\n\t// > pf `k bin/cur/info/elf_phdr.format` @ `k bin/cur/info/elf_phdr.offset`\n}\n\nstatic int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tsize_t i, j, len;\n\n\tr_return_val_if_fail (bin && !bin->shdr, false);\n\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = R_NEWS0 (Elf_(Shdr), bin->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_flags = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_addr = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_offset = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_size = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_addralign = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_entsize = R_BIN_ELF_READWORD (shdr, j);\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}\n\nstatic bool is_shidx_valid(ELFOBJ *bin, Elf_(Half) value) {\n\treturn value < bin->ehdr.e_shnum && !R_BETWEEN (SHN_LORESERVE, value, SHN_HIRESERVE);\n}\n\nstatic int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\n\t/* sh_size must be lower than UT32_MAX and not equal to zero, to avoid bugs on malloc() */\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_DEBUG (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\n\treturn true;\n}\n\nstatic Elf_(Phdr) *get_dynamic_segment(ELFOBJ *bin) {\n\tint i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\tif (bin->phdr[i].p_filesz > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->phdr[i].p_offset > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->phdr[i].p_offset + sizeof (Elf_(Dyn)) > bin->size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn &bin->phdr[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void init_dynamic_section_sdb(ELFOBJ *bin, Elf_(Addr) strtabaddr, size_t strsize) {\n\tint r = Elf_(r_bin_elf_has_relro) (bin);\n\tswitch (r) {\n\tcase R_ELF_FULL_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"full\", 0);\n\t\tbreak;\n\tcase R_ELF_PART_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"partial\", 0);\n\t\tbreak;\n\tdefault:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"no\", 0);\n\t\tbreak;\n\t}\n\tsdb_num_set (bin->kv, \"elf_strtab.offset\", strtabaddr, 0);\n\tsdb_num_set (bin->kv, \"elf_strtab.size\", strsize, 0);\n}\n\nstatic void set_default_value_dynamic_info(ELFOBJ *bin) {\n\tbin->dyn_info.dt_pltrelsz = 0;\n\tbin->dyn_info.dt_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_hash = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_strtab = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_symtab = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_rela = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_relasz = 0;\n\tbin->dyn_info.dt_relaent = 0;\n\tbin->dyn_info.dt_strsz = 0;\n\tbin->dyn_info.dt_syment = 0;\n\tbin->dyn_info.dt_rel = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_relsz = 0;\n\tbin->dyn_info.dt_relent = 0;\n\tbin->dyn_info.dt_pltrel = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_jmprel = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_mips_pltgot = R_BIN_ELF_ADDR_MAX;\n\tbin->dyn_info.dt_bind_now = false;\n\tbin->dyn_info.dt_flags = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_flags_1 = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_rpath = R_BIN_ELF_XWORD_MAX;\n\tbin->dyn_info.dt_runpath = R_BIN_ELF_XWORD_MAX;\n\tr_vector_init(&bin->dyn_info.dt_needed, sizeof (Elf_(Off)), NULL, NULL);\n}\n\nstatic size_t get_maximum_number_of_dynamic_entries(ut64 dyn_size) {\n\treturn dyn_size / sizeof (Elf_(Dyn));\n}\n\nstatic bool fill_dynamic_entry(ELFOBJ *bin, ut64 entry_offset, Elf_(Dyn) *d) {\n\tut8 sdyn[sizeof (Elf_(Dyn))] = {0};\n\tint j = 0;\n\tint len = r_buf_read_at (bin->b, entry_offset, sdyn, sizeof (Elf_(Dyn)));\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\td->d_tag = R_BIN_ELF_READWORD (sdyn, j);\n\td->d_un.d_ptr = R_BIN_ELF_READWORD (sdyn, j);\n\n\treturn true;\n}\n\nstatic void fill_dynamic_entries(ELFOBJ *bin, ut64 loaded_offset, ut64 dyn_size) {\n\tElf_(Dyn) d = {0};\n\tsize_t i;\n\tsize_t number_of_entries = get_maximum_number_of_dynamic_entries(dyn_size);\n\n\tfor (i = 0; i < number_of_entries; i++) {\n\t\tut64 entry_offset = loaded_offset + i * sizeof (Elf_(Dyn));\n\t\tif (!fill_dynamic_entry (bin, entry_offset, &d)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (d.d_tag) {\n\t\tcase DT_NULL:\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tbin->dyn_info.dt_pltrelsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tbin->dyn_info.dt_pltgot = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_HASH:\n\t\t\tbin->dyn_info.dt_hash = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_STRTAB:\n\t\t\tbin->dyn_info.dt_strtab = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_SYMTAB:\n\t\t\tbin->dyn_info.dt_symtab = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\tbin->dyn_info.dt_rela = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\tbin->dyn_info.dt_relasz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELAENT:\n\t\t\tbin->dyn_info.dt_relaent = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_STRSZ:\n\t\t\tbin->dyn_info.dt_strsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_SYMENT:\n\t\t\tbin->dyn_info.dt_syment = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_REL:\n\t\t\tbin->dyn_info.dt_rel = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\tbin->dyn_info.dt_relsz = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELENT:\n\t\t\tbin->dyn_info.dt_relent = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTREL:\n\t\t\tbin->dyn_info.dt_pltrel = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\tbin->dyn_info.dt_jmprel = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_MIPS_PLTGOT:\n\t\t\tbin->dyn_info.dt_mips_pltgot = d.d_un.d_ptr;\n\t\t\tbreak;\n\t\tcase DT_BIND_NOW:\n\t\t\tbin->dyn_info.dt_bind_now = true;\n\t\t\tbreak;\n\t\tcase DT_FLAGS:\n\t\t\tbin->dyn_info.dt_flags = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_FLAGS_1:\n\t\t\tbin->dyn_info.dt_flags_1 = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RPATH:\n\t\t\tbin->dyn_info.dt_rpath = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RUNPATH:\n\t\t\tbin->dyn_info.dt_runpath = d.d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_NEEDED:\n\t\t\tr_vector_push (&bin->dyn_info.dt_needed, &d.d_un.d_val);\n\t\t\tbreak;\n\t\tcase DT_INIT:\n\t\tcase DT_FINI:\n\t\tcase DT_DEBUG:\n\t\tcase DT_INIT_ARRAY:\n\t\tcase DT_FINI_ARRAY:\n\t\tcase DT_INIT_ARRAYSZ:\n\t\tcase DT_FINI_ARRAYSZ:\n\t\tcase DT_PREINIT_ARRAY:\n\t\tcase DT_PREINIT_ARRAYSZ:\n\t\tcase DT_SONAME:\n\t\tcase DT_GNU_HASH:\n\t\t\t// common dynamic entries in ELF, but we don't need to\n\t\t\t// do anything with them.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((d.d_tag >= DT_VERSYM) && (d.d_tag <= DT_VERNEEDNUM)) {\n\t\t\t\tbin->version_info[DT_VERSIONTAGIDX (d.d_tag)] = d.d_un.d_val;\n\t\t\t} else {\n\t\t\t\tR_LOG_DEBUG (\"Dynamic tag %\" PFMT64d \" not handled\", (ut64) d.d_tag);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (d.d_tag == DT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int init_dynamic_section(ELFOBJ *bin) {\n\tut64 strtabaddr = 0;\n\tchar *strtab = NULL;\n\tsize_t strsize = 0;\n\tint r;\n\tut64 dyn_size = 0, loaded_offset;\n\tset_default_value_dynamic_info(bin);\n\n\tr_return_val_if_fail (bin, false);\n\tif (!bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\n\tElf_(Phdr) *dyn_phdr = get_dynamic_segment (bin);\n\tif (!dyn_phdr) {\n\t\treturn false;\n\t}\n\n\tdyn_size = dyn_phdr->p_filesz;\n\tloaded_offset = Elf_(r_bin_elf_v2p_new) (bin, dyn_phdr->p_vaddr);\n\tif (loaded_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tif (!dyn_size || loaded_offset + dyn_size > bin->size) {\n\t\treturn false;\n\t}\n\n\tfill_dynamic_entries (bin, loaded_offset, dyn_size);\n\n\tif (bin->dyn_info.dt_strtab != R_BIN_ELF_ADDR_MAX) {\n\t\tstrtabaddr = Elf_(r_bin_elf_v2p_new) (bin, bin->dyn_info.dt_strtab);\n\t}\n\n\tif (bin->dyn_info.dt_strsz > 0) {\n\t\tstrsize = bin->dyn_info.dt_strsz;\n\t}\n\n\tif (strtabaddr == UT64_MAX || strtabaddr > bin->size || strsize > ST32_MAX || !strsize || strsize > bin->size || strtabaddr + strsize > bin->size) {\n\t\tif (!strtabaddr) {\n\t\t\tR_LOG_DEBUG (\"DT_STRTAB not found or invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\tstrtab = (char *)calloc (1, strsize + 1);\n\tif (!strtab) {\n\t\treturn false;\n\t}\n\tr = r_buf_read_at (bin->b, strtabaddr, (ut8 *)strtab, strsize);\n\tif (r < 1) {\n\t\tfree (strtab);\n\t\treturn false;\n\t}\n\n\tbin->strtab = strtab;\n\tbin->strtab_size = strsize;\n\tinit_dynamic_section_sdb (bin, strtabaddr, strsize);\n\treturn true;\n}\n\nstatic RBinElfSection* get_section_by_name(ELFOBJ *bin, const char *section_name) {\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strncmp (bin->g_sections[i].name, section_name, ELF_STRING_LENGTH - 1)) {\n\t\t\t\treturn &bin->g_sections[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tif (!flags) {\n\t\treturn \"none\";\n\t}\n\tstatic char buff[32];\n\tbuff[0] = 0;\n\tif (flags & VER_FLG_BASE) {\n\t\tstrcpy (buff, \"BASE \");\n\t}\n\tif (flags & VER_FLG_WEAK) {\n\t\tif (flags & VER_FLG_BASE) {\n\t\t\tstrcat (buff, \"| \");\n\t\t}\n\t\tstrcat (buff, \"WEAK \");\n\t}\n\tif (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)) {\n\t\tstrcat (buff, \"| <unknown>\");\n\t}\n\treturn buff;\n}\n\nstatic Sdb *store_versioninfo_gnu_versym(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tsize_t i;\n\tconst ut64 num_entries = sz / sizeof (Elf_(Versym));\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n\tut8 *edata = (ut8*) calloc (R_MAX (1, num_entries), 2 * sizeof (ut8));\n\tif (!edata) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut16 *data = (ut16 *)calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!data) {\n\t\tfree (edata);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut64 off = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]);\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tr_buf_read_at (bin->b, off, edata, sizeof (ut16) * num_entries);\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", num_entries, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\tfor (i = num_entries; i--;) {\n\t\tdata[i] = r_read_ble16 (&edata[i * sizeof (ut16)], bin->endian);\n\t}\n\tR_FREE (edata);\n\tchar *tmp_val = NULL;\n\tfor (i = 0; i < num_entries; i += 4) {\n\t\tsize_t j;\n\t\tint check_def;\n\t\tchar key[32] = {0};\n\n\t\tfor (j = 0; (j < 4) && (i + j) < num_entries; j++) {\n\t\t\tint k;\n\t\t\tsnprintf (key, sizeof (key), \"entry%d\", (int)(i + j));\n\t\t\tswitch (data[i + j]) {\n\t\t\tcase 0:\n\t\t\t\tsdb_set (sdb, key, \"0 (*local*)\", 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tsdb_set (sdb, key, \"1 (*global*)\", 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfree (tmp_val);\n\t\t\t\ttmp_val = r_str_newf (\"%x \", data[i+j] & 0x7FFF);\n\t\t\t\tcheck_def = true;\n\t\t\t\tif (bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]) {\n\t\t\t\t\tElf_(Verneed) vn;\n\t\t\t\t\tut8 svn[sizeof (Elf_(Verneed))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tElf_(Vernaux) vna;\n\t\t\t\t\t\tut8 svna[sizeof (Elf_(Vernaux))] = {0};\n\t\t\t\t\t\tut64 a_off;\n\t\t\t\t\t\tif (offset > bin->size || offset + sizeof (vn) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svn, sizeof (svn)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verneed for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvn.vn_version = READ16 (svn, k);\n\t\t\t\t\t\tvn.vn_cnt = READ16 (svn, k);\n\t\t\t\t\t\tvn.vn_file = READ32 (svn, k);\n\t\t\t\t\t\tvn.vn_aux = READ32 (svn, k);\n\t\t\t\t\t\tvn.vn_next = READ32 (svn, k);\n\t\t\t\t\t\ta_off = offset + vn.vn_aux;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (a_off > bin->size || a_off + sizeof (vna) > bin->size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, a_off, svna, sizeof (svna)) < 0) {\n\t\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Vernaux for Versym\");\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\t\tvna.vna_hash = READ32 (svna, k);\n\t\t\t\t\t\t\tvna.vna_flags = READ16 (svna, k);\n\t\t\t\t\t\t\tvna.vna_other = READ16 (svna, k);\n\t\t\t\t\t\t\tvna.vna_name = READ32 (svna, k);\n\t\t\t\t\t\t\tvna.vna_next = READ32 (svna, k);\n\t\t\t\t\t\t\ta_off += vna.vna_next;\n\t\t\t\t\t\t} while (vna.vna_other != data[i + j] && vna.vna_next != 0);\n\n\t\t\t\t\t\tif (vna.vna_other == data[i + j]) {\n\t\t\t\t\t\t\tif (vna.vna_name > bin->strtab_size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchar *val = r_str_newf (\"%s(%s)\", tmp_val, bin->strtab + vna.vna_name);\n\t\t\t\t\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\t\t\t\t\tfree (val);\n\t\t\t\t\t\t\tcheck_def = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += vn.vn_next;\n\t\t\t\t\t} while (vn.vn_next);\n\t\t\t\t}\n\n\t\t\t\tut64 vinfoaddr = bin->version_info[DT_VERSIONTAGIDX (DT_VERDEF)];\n\t\t\t\tif (check_def && data[i + j] != 0x8001 && vinfoaddr) {\n\t\t\t\t\tElf_(Verdef) vd;\n\t\t\t\t\tut8 svd[sizeof (Elf_(Verdef))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, vinfoaddr);\n\t\t\t\t\tif (offset > bin->size || offset + sizeof (vd) > bin->size) {\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svd, sizeof (svd)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verdef for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvd.vd_version = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_flags = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_ndx = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_cnt = READ16 (svd, k);\n\t\t\t\t\t\tvd.vd_hash = READ32 (svd, k);\n\t\t\t\t\t\tvd.vd_aux = READ32 (svd, k);\n\t\t\t\t\t\tvd.vd_next = READ32 (svd, k);\n\t\t\t\t\t\toffset += vd.vd_next;\n\t\t\t\t\t} while (vd.vd_ndx != (data[i + j] & 0x7FFF) && vd.vd_next != 0);\n\n\t\t\t\t\tif (vd.vd_ndx == (data[i + j] & 0x7FFF)) {\n\t\t\t\t\t\tElf_(Verdaux) vda;\n\t\t\t\t\t\tut8 svda[sizeof (Elf_(Verdaux))] = {0};\n\t\t\t\t\t\tut64 off_vda = offset - vd.vd_next + vd.vd_aux;\n\t\t\t\t\t\tif (off_vda > bin->size || off_vda + sizeof (vda) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, off_vda, svda, sizeof (svda)) < 0) {\n\t\t\t\t\t\t\tR_LOG_DEBUG (\"Cannot read Verdaux for Versym\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvda.vda_name = READ32 (svda, k);\n\t\t\t\t\t\tvda.vda_next = READ32 (svda, k);\n\t\t\t\t\t\tif (vda.vda_name > bin->strtab_size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = bin->strtab + vda.vda_name;\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tchar *fname = r_str_newf (\"%s(%s%-*s)\", tmp_val, name, (int)(12 - strlen (name)),\")\");\n\t\t\t\t\t\t\tsdb_set (sdb, key, fname, 0);\n\t\t\t\t\t\t\tfree (fname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tR_FREE (tmp_val);\n\t}\nbeach:\n\tR_FREE (tmp_val);\n\tfree (data);\n\treturn sdb;\n}\n\nstatic Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tut32 cnt;\n\tsize_t i;\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (shdr->sh_size < sizeof (Elf_(Verdef)) || shdr->sh_size < sizeof (Elf_(Verdaux))) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n\tif (!defs) {\n\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\tfree (defs);\n\t\treturn false;\n\t}\n\tsize_t shsize = shdr->sh_size;\n\tif (shdr->sh_size > bin->size) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)shdr->sh_size, (int)bin->size);\n\t\t}\n\t\tif (bin->size > shdr->sh_offset) {\n\t\t\tshsize = bin->size - shdr->sh_offset;\n\t\t} else {\n\t\t\tshsize = bin->size;\n\t\t}\n\t}\n\tend = (char *)defs + shsize; //& shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; cnt < shdr->sh_info && i < shdr->sh_size; cnt++) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tif (vstart + sizeof (*verdef) > end) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j);\n\t\tverdef->vd_flags = READ16 (dfs, j);\n\t\tverdef->vd_ndx = READ16 (dfs, j);\n\t\tverdef->vd_cnt = READ16 (dfs, j);\n\t\tverdef->vd_hash = READ32 (dfs, j);\n\t\tverdef->vd_aux = READ32 (dfs, j);\n\t\tverdef->vd_next = READ32 (dfs, j);\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j);\n\t\taux.vda_next = READ32 (vstart, j);\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; j++) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tif (shdr->sh_size - vstart_off < aux.vda_next) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k);\n\t\t\taux.vda_next = READ32 (vstart, k);\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%u\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next || shdr->sh_size - i < verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tut64 i;\n\tint cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory for Elf_(Verneed)\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 1) {\n\t\tgoto beach;\n\t}\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; cnt++) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j);\n\t\tvvn.vn_cnt = READ16 (vstart, j);\n\t\tvvn.vn_file = READ32 (vstart, j);\n\t\tvvn.vn_aux = READ32 (vstart, j);\n\t\tvvn.vn_next = READ32 (vstart, j);\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tut32 vn_cnt = entry->vn_cnt;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; j++) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) *aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k);\n\t\t\tvaux.vna_flags = READ16 (vstart, k);\n\t\t\tvaux.vna_other = READ16 (vstart, k);\n\t\t\tvaux.vna_name = READ32 (vstart, k);\n\t\t\tvaux.vna_next = READ32 (vstart, k);\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n#if 1\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof (name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n#else\n\t\t\tchar *key = r_str_newf (\"vernaux%d\", j);\n\t\t\tchar *val = r_str_newf (\"%d,%s\", isum, get_ver_flags (aux->vna_flags));\n\t\t\tsdb_set (sdb_version, key, val, 0);\n\t\t\tfree (key);\n\t\t\tfree (val);\n#endif\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tR_LOG_DEBUG (\"Invalid vn_next at 0x%08\" PFMT64x, (ut64)shdr->sh_offset);\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo(ELFOBJ *bin) {\n\tSdb *sdb_versioninfo = NULL;\n\tint num_verdef = 0;\n\tint num_verneed = 0;\n\tint num_versym = 0;\n\tsize_t i;\n\n\tif (!bin || !bin->shdr) {\n\t\treturn NULL;\n\t}\n\tif (!(sdb_versioninfo = sdb_new0 ())) {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tSdb *sdb = NULL;\n\t\tchar key[32] = {0};\n\t\tint size = bin->shdr[i].sh_size;\n\n\t\tif (size - (i * sizeof (Elf_(Shdr)) > bin->size)) {\n\t\t\tsize = bin->size - (i*sizeof (Elf_(Shdr)));\n\t\t}\n\t\tint left = size - (i * sizeof (Elf_(Shdr)));\n\t\tleft = R_MIN (left, bin->shdr[i].sh_size);\n\t\tif (left < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bin->shdr[i].sh_type) {\n\t\tcase SHT_GNU_verdef:\n\t\t\tsdb = store_versioninfo_gnu_verdef (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verdef%d\", num_verdef++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_verneed:\n\t\t\tsdb = store_versioninfo_gnu_verneed (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verneed%d\", num_verneed++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_versym:\n\t\t\tsdb = store_versioninfo_gnu_versym (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"versym%d\", num_versym++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sdb_versioninfo;\n}\n\nstatic bool init_dynstr(ELFOBJ *bin) {\n\tint i, r;\n\tconst char *section_name = NULL;\n\tif (!bin || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (!bin->shstrtab) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_name > bin->shstrtab_size) {\n\t\t\treturn false;\n\t\t}\n\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\tif (bin->shdr[i].sh_type == SHT_STRTAB && !strcmp (section_name, \".dynstr\")) {\n\t\t\tif (!(bin->dynstr = (char*) calloc (bin->shdr[i].sh_size + 1, sizeof (char)))) {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate memory for dynamic strings\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size < bin->shdr[i].sh_size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset, (ut8*)bin->dynstr, bin->shdr[i].sh_size);\n\t\t\tif (r < 1) {\n\t\t\t\tR_FREE (bin->dynstr);\n\t\t\t\tbin->dynstr_size = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->dynstr_size = bin->shdr[i].sh_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic HtUP *rel_cache_new(RBinElfReloc *relocs, ut32 reloc_num) {\n\tif (!relocs || reloc_num == 0) {\n\t\treturn NULL;\n\t}\n\tconst int htsize = R_MIN (reloc_num, 1024);\n\tHtUP *rel_cache = ht_up_new_size (htsize, NULL, NULL, NULL);\n\tif (rel_cache) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < reloc_num; i++) {\n\t\t\tRBinElfReloc *tmp = relocs + i;\n\t\t\tht_up_insert (rel_cache, tmp->sym, tmp);\n\t\t}\n\t}\n\treturn rel_cache;\n}\n\nstatic bool elf_init(ELFOBJ *bin) {\n\t/* bin is not an ELF */\n\tif (!init_ehdr (bin)) {\n\t\treturn false;\n\t}\n\tif (!init_phdr (bin) && !is_bin_etrel (bin)) {\n\t\tR_LOG_DEBUG (\"Cannot initialize program headers\");\n\t}\n\tif (bin->ehdr.e_type != ET_CORE) {\n\t\tif (!init_shdr (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize section headers\");\n\t\t}\n\t\tif (!init_strtab (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize strings table\");\n\t\t}\n\t\tif (!init_dynstr (bin) && !is_bin_etrel (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize dynamic strings\");\n\t\t}\n\t\tbin->baddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tif (!init_dynamic_section (bin) && !Elf_(r_bin_elf_is_static) (bin) && !is_bin_etrel (bin)) {\n\t\t\tR_LOG_DEBUG (\"Cannot initialize dynamic section\");\n\t\t}\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->symbols_by_ord_size = 0;\n\tbin->symbols_by_ord = NULL;\n\tbin->g_sections = Elf_(r_bin_elf_get_sections) (bin);\n\tbin->boffset = Elf_(r_bin_elf_get_boffset) (bin);\n\tbin->g_relocs = Elf_(r_bin_elf_get_relocs) (bin);\n\tbin->rel_cache = rel_cache_new (bin->g_relocs, bin->g_reloc_num);\n\tsdb_ns_set (bin->kv, \"versioninfo\", store_versioninfo (bin));\n\treturn true;\n}\n\nut64 Elf_(r_bin_elf_get_section_offset)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->offset: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr_end)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva + section->size: UT64_MAX;\n}\n\nstatic ut64 get_got_entry(ELFOBJ *bin, RBinElfReloc *rel) {\n\tif (!rel->rva) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 p_sym_got_addr = Elf_(r_bin_elf_v2p_new) (bin, rel->rva);\n\tut64 addr = R_BIN_ELF_BREADWORD (bin->b, p_sym_got_addr);\n\n\treturn (!addr || addr == R_BIN_ELF_WORD_MAX) ? UT64_MAX : addr;\n}\n\nstatic bool is_thumb_symbol(ut64 plt_addr) {\n\treturn plt_addr & 1;\n}\n\nstatic ut64 get_import_addr_arm(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION (rel, got_addr, 0x3);\n\n\tswitch (rel->type) {\n\tcase R_ARM_JUMP_SLOT:\n\t\tplt_addr += pos * 12 + 20;\n\t\tif (is_thumb_symbol (plt_addr)) {\n\t\t\tplt_addr--;\n\t\t}\n\t\treturn plt_addr;\n\tcase R_AARCH64_RELATIVE:\n\t\tR_LOG_WARN (\"Unsupported relocation type for imports %d\", rel->type);\n\t\treturn UT64_MAX;\n\tcase R_AARCH64_IRELATIVE:\n\t\tif (rel->addend > plt_addr) { // start\n\t\t\treturn (plt_addr + pos * 16 + 32) + rel->addend;\n\t\t}\n\t\t// same as fallback to JUMP_SLOT\n\t\treturn plt_addr + pos * 16 + 32;\n\tcase R_AARCH64_JUMP_SLOT:\n\t\treturn plt_addr + pos * 16 + 32;\n\tdefault:\n\t\tR_LOG_WARN (\"Unsupported relocation type for imports %d\", rel->type);\n\t\treturn UT64_MAX;\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_import_addr_mips(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 jmprel_addr = bin->dyn_info.dt_jmprel;\n\tut64 got_addr = bin->dyn_info.dt_mips_pltgot;\n\n\tif (jmprel_addr == R_BIN_ELF_ADDR_MAX || got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\n\tut8 buf[1024];\n\tut64 plt_addr = jmprel_addr + bin->dyn_info.dt_pltrelsz;\n\tut64 p_plt_addr = Elf_(r_bin_elf_v2p_new) (bin, plt_addr);\n\tint res = r_buf_read_at (bin->b, p_plt_addr, buf, sizeof (buf));\n\tif (res != sizeof (buf)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tconst ut8 *base = r_mem_mem_aligned (buf, sizeof (buf), (const ut8 *)\"\\x3c\\x0f\\x00\", 3, 4);\n\tplt_addr += base? (int)(size_t) (base - buf):  MIPS_PLT_OFFSET + 8; // HARDCODED HACK\n\tplt_addr += pos * 16;\n\n\treturn plt_addr;\n}\n\nstatic size_t get_size_rel_mode(Elf_(Xword) mode) {\n\treturn mode == DT_RELA? sizeof (Elf_(Rela)): sizeof (Elf_(Rel));\n}\n\nstatic ut64 get_num_relocs_dynamic_plt(ELFOBJ *bin) {\n\tif (bin->dyn_info.dt_pltrelsz) {\n\t\tconst ut64 size = bin->dyn_info.dt_pltrelsz;\n\t\tconst ut64 relsize = get_size_rel_mode (bin->dyn_info.dt_pltrel);\n\t\treturn size / relsize;\n\t}\n\treturn 0;\n}\n\nstatic ut64 get_import_addr_riscv(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\treturn plt_addr + RISCV_PLT_OFFSET + pos * RISCV_PLT_ENTRY_SIZE;\n}\n\nstatic ut64 get_import_addr_loongarch(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 plt_addr = get_got_entry (bin, rel);\n\tif (plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, got_addr, 0x2);\n\treturn plt_addr + LOONGARCH_PLT_OFFSET + pos * LOONGARCH_PLT_ENTRY_SIZE;\n}\nstatic ut64 get_import_addr_sparc(ELFOBJ *bin, RBinElfReloc *rel) {\n\tif (rel->type != R_SPARC_JMP_SLOT) {\n\t\tR_LOG_DEBUG (\"Unknown sparc reloc type %d\", rel->type);\n\t\treturn UT64_MAX;\n\t}\n\tut64 tmp = get_got_entry (bin, rel);\n\n\treturn (tmp == UT64_MAX) ? UT64_MAX : tmp + SPARC_OFFSET_PLT_ENTRY_FROM_GOT_ADDR;\n}\n\nstatic ut64 get_import_addr_ppc(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 plt_addr = bin->dyn_info.dt_pltgot;\n\tif (plt_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut64 p_plt_addr = Elf_(r_bin_elf_v2p_new) (bin, plt_addr);\n\tif (p_plt_addr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 base = r_buf_read_ble32_at (bin->b, p_plt_addr, bin->endian);\n\tif (base == UT32_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 nrel = get_num_relocs_dynamic_plt (bin);\n\tut64 pos = COMPUTE_PLTGOT_POSITION(rel, plt_addr, 0x0);\n\n\tif (bin->endian) {\n\t\tbase -= (nrel * 16);\n\t\tbase += (pos * 16);\n\t\treturn base;\n\t}\n\n\tbase -= (nrel * 12) + 20;\n\tbase += (pos * 8);\n\treturn base;\n}\n\nstatic ut64 get_import_addr_x86_manual(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\tif (got_addr == R_BIN_ELF_ADDR_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 got_offset = Elf_(r_bin_elf_v2p_new) (bin, got_addr);\n\tif (got_offset == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\t//XXX HACK ALERT!!!! full relro?? try to fix it\n\t//will there always be .plt.got, what would happen if is .got.plt?\n\tRBinElfSection *s = get_section_by_name (bin, \".plt.got\");\n\tif (Elf_(r_bin_elf_has_relro) (bin) < R_ELF_PART_RELRO || !s) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut8 buf[sizeof (Elf_(Addr))] = {0};\n\n\tut64 plt_addr = s->offset;\n\tut64 plt_sym_addr;\n\n\twhile (plt_addr + 2 + 4 < s->offset + s->size) {\n\t\t/*we try to locate the plt entry that correspond with the relocation\n\t\t  since got does not point back to .plt. In this case it has the following\n\t\t  form\n\t\t  ff253a152000   JMP QWORD [RIP + 0x20153A]\n\t\t  6690\t\t     NOP\n\t\t  ----\n\t\t  ff25ec9f0408   JMP DWORD [reloc.puts_236]\n\t\t  plt_addr + 2 to remove jmp opcode and get the imm reading 4\n\t\t  and if RIP (plt_addr + 6) + imm == rel->offset\n\t\t  return plt_addr, that will be our sym addr\n\t\t  perhaps this hack doesn't work on 32 bits\n\t\t  */\n\t\tint res = r_buf_read_at (bin->b, plt_addr + 2, buf, sizeof (ut32));\n\t\tif (res < 0) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\n\t\tsize_t i = 0;\n\t\tplt_sym_addr = R_BIN_ELF_READWORD (buf, i);\n\n\t\t//relative address\n\t\tif ((plt_addr + 6 + Elf_(r_bin_elf_v2p) (bin, plt_sym_addr)) == rel->rva) {\n\t\t\treturn plt_addr;\n\t\t}\n\t\tif (plt_sym_addr == rel->rva) {\n\t\t\treturn plt_addr;\n\t\t}\n\t\tplt_addr += 8;\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_import_addr_x86(ELFOBJ *bin, RBinElfReloc *rel) {\n\tut64 tmp = get_got_entry (bin, rel);\n\tif (tmp == UT64_MAX) {\n\t\treturn get_import_addr_x86_manual (bin, rel);\n\t}\n\n\tRBinElfSection *pltsec_section = get_section_by_name (bin, \".plt.sec\");\n\tif (pltsec_section) {\n\t\tut64 got_addr = bin->dyn_info.dt_pltgot;\n\t\tut64 pos = COMPUTE_PLTGOT_POSITION (rel, got_addr, 0x3);\n\t\treturn pltsec_section->rva + pos * X86_PLT_ENTRY_SIZE;\n\t}\n\n\treturn tmp + X86_OFFSET_PLT_ENTRY_FROM_GOT_ADDR;\n}\n\nstatic ut64 get_import_addr(ELFOBJ *bin, int sym) {\n\tif ((!bin->shdr || !bin->strtab) && !bin->phdr) {\n\t\treturn UT64_MAX;\n\t}\n\n\tif (!bin->rel_cache) {\n\t\treturn UT64_MAX;\n\t}\n\n\t// lookup the right rel/rela entry\n\tRBinElfReloc *rel = ht_up_find (bin->rel_cache, sym, NULL);\n\tif (!rel) {\n\t\treturn UT64_MAX;\n\t}\n\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn get_import_addr_arm (bin, rel);\n\tcase EM_MIPS: // MIPS32 BIG ENDIAN relocs\n\t\treturn get_import_addr_mips (bin, rel);\n\tcase EM_VAX:\n\t\t// as beautiful as riscv <3\n\t\treturn get_import_addr_riscv (bin, rel);\n\tcase EM_RISCV:\n\t\treturn get_import_addr_riscv (bin, rel);\n\tcase EM_SPARC:\n\tcase EM_SPARCV9:\n\tcase EM_SPARC32PLUS:\n\t\treturn get_import_addr_sparc (bin, rel);\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn get_import_addr_ppc (bin, rel);\n\tcase EM_386:\n\tcase EM_X86_64:\n\t\treturn get_import_addr_x86 (bin, rel);\n\tcase EM_LOONGARCH:\n\t\treturn get_import_addr_loongarch(bin, rel);\n\tdefault:\n\t\teprintf (\"Unsupported relocs type %\" PFMT64u \" for arch %d\\n\",\n\t\t\t\t(ut64) rel->type, bin->ehdr.e_machine);\n\t\treturn UT64_MAX;\n\t}\n}\n\nint Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, 0);\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Elf_(r_bin_elf_has_relro)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, R_ELF_NO_RELRO);\n\tbool haveBindNow = false;\n\tbool haveGnuRelro = false;\n\n\tif (bin->dyn_info.dt_bind_now) {\n\t\thaveBindNow = true;\n\t} else if (bin->dyn_info.dt_flags != R_BIN_ELF_XWORD_MAX && bin->dyn_info.dt_flags != R_BIN_ELF_XWORD_MAX) {\n\t\thaveBindNow = bin->dyn_info.dt_flags_1 & DF_1_NOW;\n\t}\n\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_RELRO) {\n\t\t\t\thaveGnuRelro = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (haveGnuRelro) {\n\t\tif (haveBindNow) {\n\t\t\treturn R_ELF_FULL_RELRO;\n\t\t}\n\t\treturn R_ELF_PART_RELRO;\n\t}\n\treturn R_ELF_NO_RELRO;\n}\n\n/*\nTo compute the base address, one determines the memory\naddress associated with the lowest p_vaddr value for a\nPT_LOAD segment. One then obtains the base address by\ntruncating the memory address to the nearest multiple\nof the maximum page size\n*/\n\nut64 Elf_(r_bin_elf_get_baddr)(ELFOBJ *bin) {\n\tut64 tmp, base = UT64_MAX;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp = (ut64)bin->phdr[i].p_vaddr & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (base == UT64_MAX && is_bin_etrel (bin)) {\n\t\t//we return our own base address for ET_REL type\n\t\t//we act as a loader for ELF\n\t\treturn 0x08000000;\n\t}\n\treturn base == UT64_MAX? 0: base;\n}\n\nut64 Elf_(r_bin_elf_get_boffset)(ELFOBJ *bin) {\n\tut64 tmp, base = UT64_MAX;\n\tr_return_val_if_fail (bin, 0);\n\n\tif (!bin->phdr) {\n\t\treturn 0; // TODO: should return ut64.max\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\ttmp = (ut64)bin->phdr[i].p_offset & ELF_PAGE_MASK;\n\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\tif (tmp < base) {\n\t\t\t\tbase = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn base == UT64_MAX? 0: base;\n}\n\nut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[128];\n\tif (!bin || entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n\t\tR_LOG_DEBUG (\"read (init_offset)\");\n\t\treturn 0;\n\t}\n\tif (buf[0] == 0x68) { // push // x86 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf + 1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_fini_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tif (entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut8 buf[512];\n\tif (r_buf_read_at (bin->b, entry + 11, buf, sizeof (buf)) == -1) {\n\t\tR_LOG_ERROR (\"read (get_fini)\");\n\t\treturn 0;\n\t}\n\tif (*buf == 0x68) { // push // x86/32 only\n\t\tmemmove (buf, buf + 1, 4);\n\t\tut64 addr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_entry_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = bin->ehdr.e_entry;\n\tif (!entry) {\n\t\tif (!Elf_(r_bin_elf_is_executable) (bin)) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init.text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\treturn Elf_(r_bin_elf_get_section_offset)(bin, \".init\");\n\t}\n\treturn Elf_(r_bin_elf_v2p) (bin, entry);\n}\n\nstatic ut64 getmainsymbol(ELFOBJ *bin) {\n\tstruct r_bin_elf_symbol_t *symbol = Elf_(r_bin_elf_get_symbols) (bin);\n\tif (symbol) {\n\t\tsize_t i;\n\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\tif (!strcmp (symbol[i].name, \"main\")) {\n\t\t\t\treturn symbol[i].offset;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_main_offset)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tif (entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tut8 buf[256];\n\tif (entry > bin->size || (entry + sizeof (buf)) > bin->size) {\n\t\treturn UT64_MAX;\n\t}\n\t// unnecessary to read 512 bytes imho\n\tif (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {\n\t\tR_LOG_ERROR (\"read (main)\");\n\t\treturn UT64_MAX;\n\t}\n\t// ARM64\n\tif (buf[0x18 + 3] == 0x58 && buf[0x2f] == 0x00) {\n\t\tut32 entry_vaddr = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tut32 main_addr = r_read_le32 (&buf[0x30]);\n\t\tif ((main_addr >> 16) == (entry_vaddr >> 16)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, main_addr);\n\t\t}\n\t}\n\n\t// TODO: Use arch to identify arch before memcmp's\n\n\t// ARM Glibc\n\tif (entry & 1) {\n\t\tint delta = 0;\n\t\t/* thumb entry points */\n\t\tif (!memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x02\\xbc\\x6a\\x46\", 11)) {\n\t\t\t/* newer versions of gcc use push/pop */\n\t\t\tdelta = 0x28;\n\t\t} else if (!memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x5d\\xf8\\x04\\x1b\", 11)) {\n\t\t\t/* older versions of gcc (4.5.x) use ldr/str */\n\t\t\tdelta = 0x30;\n\t\t}\n\t\tif (delta) {\n\t\t\tut64 pa = Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[delta-1]) & ~1);\n\t\t\tif (pa < r_buf_size (bin->b)) {\n\t\t\t\treturn pa;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* non-thumb entry points */\n\t\tif (!memcmp (buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x34]) & ~1);\n\t\t}\n\t\tif (!memcmp (buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x30]) & ~1);\n\t\t}\n\t}\n\n\t// MIPS\n\t/* get .got, calculate offset of main symbol */\n\tif (!memcmp (buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\n\t\t/*\n\t\t    assuming the startup code looks like\n\t\t        got = gp-0x7ff0\n\t\t        got[index__libc_start_main] ( got[index_main] );\n\n\t\t    looking for the instruction generating the first argument to find main\n\t\t        lw a0, offset(gp)\n\t\t*/\n\n\t\tut64 got_offset;\n\t\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) != -1 ||\n\t\t    (got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) != -1)\n\t\t{\n\t\t\tconst ut64 gp = got_offset + 0x7ff0;\n\t\t\tsize_t i, len = sizeof (buf) / sizeof (buf[0]);\n\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\tconst ut32 instr = r_read_le32 (&buf[i]);\n\t\t\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\t\t\tr_buf_read_at (bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\t// X86-CGC\n\tif (buf[0] == 0xe8 && !memcmp (buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\tsize_t SIZEOF_CALL = 5;\n\t\tut64 rel_addr = (ut64)((int)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24)));\n\t\tut64 addr = Elf_(r_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\t\taddr += rel_addr;\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32*)(buf + 0x30);\n\t\tut64 vmain = Elf_(r_bin_elf_p2v) (bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp (buf, \"\\x31\\xed\\x49\\x89\", 4)) {// linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof (ut32)] = {0};\n\t\t\tmaddr = entry + 0x24 + r_read_le32 (buf + 0x20);\n\t\t\tif (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {\n\t\t\t\tR_LOG_ERROR (\"read (maddr) 2\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)r_read_le32 (&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (bin->phdr) {\n\t\t\t\tbaddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\t// X86-NONPIE\n#if R_BIN_ELF64\n\tif (!memcmp (buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn r_read_le32 (&buf[157]) + entry + 156 + 5;\n\t}\n\tif (!memcmp (buf+29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)r_read_le32 (&buf[29 + 3]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)r_read_le32 (&buf[23 + 1]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#endif\n\t/* linux64 pie main -- probably buggy in some cases */\n\tint bo = 29; // Begin offset may vary depending on the entry prelude\n\t// endbr64 - fedora bins have this\n\tif (buf[0] == 0xf3 && buf[1] == 0x0f && buf[2] == 0x1e && buf[3] == 0xfa) {\n\t\t// Change begin offset if binary starts with 'endbr64'\n\t\tbo = 33;\n\t}\n\tif (buf[bo] == 0x48) {\n\t\tut8 ch = buf[bo + 1];\n\t\tif (ch == 0x8d) { // lea rdi, qword [rip-0x21c4]\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tst32 maindelta = (st32)r_read_le32 (p);\n\t\t\tut64 vmain = (ut64)(entry + bo + maindelta) + 7;\n\t\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\t\tif ((vmain >> 16) == (ventry >> 16)) {\n\t\t\t\treturn (ut64)vmain;\n\t\t\t}\n\t\t} else if (ch == 0xc7) { // mov rdi, 0xADDR\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\treturn (ut64)(ut32)r_read_le32 (p);\n\t\t}\n\t}\n\n\t/* find sym.main if possible */\n\t{\n\t\tut64 m = getmainsymbol (bin);\n\t\tif (m != UT64_MAX) {\n\t\t\treturn m;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nbool Elf_(r_bin_elf_get_stripped)(ELFOBJ *bin) {\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strcmp (bin->g_sections[i].name, \".gnu_debugdata\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar *Elf_(r_bin_elf_intrp)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin || !bin->phdr) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\tut64 addr = bin->phdr[i].p_offset;\n\t\t\tint sz = bin->phdr[i].p_filesz;\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_addr\", addr, 0);\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_size\", sz, 0);\n\t\t\tif (sz < 1 || sz > r_buf_size (bin->b)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tchar *str = malloc (sz + 1);\n\t\t\tif (!str) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, addr, (ut8*)str, sz) < 1) {\n\t\t\t\tR_LOG_ERROR (\"read (main)\");\n\t\t\t\tfree (str);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstr[sz] = 0;\n\t\t\tsdb_set (bin->kv, \"elf_header.intrp\", str, 0);\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nbool Elf_(r_bin_elf_is_static)(ELFOBJ *bin) {\n\tsize_t i;\n\tif (!bin->phdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP ||\n\t\t\tbin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_data_encoding)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_DATA]) {\n\tcase ELFDATANONE: return strdup (\"none\");\n\tcase ELFDATA2LSB: return strdup (\"2's complement, little endian\");\n\tcase ELFDATA2MSB: return strdup (\"2's complement, big endian\");\n\tdefault: return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_DATA]);\n\t}\n}\n\nint Elf_(r_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_arch)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARC:\n\tcase EM_ARC_A5:\n\t\treturn strdup (\"arc\");\n\tcase EM_AVR: return strdup (\"avr\");\n\tcase EM_BA2_NON_STANDARD:\n\tcase EM_BA2: return strdup (\"ba2\");\n\tcase EM_CRIS: return strdup (\"cris\");\n\tcase EM_68K: return strdup (\"m68k\");\n\tcase EM_MIPS:\n\tcase EM_MIPS_RS3_LE:\n\tcase EM_MIPS_X:\n\t\treturn strdup (\"mips\");\n\tcase EM_MCST_ELBRUS:\n\t\treturn strdup (\"elbrus\");\n\tcase EM_TRICORE:\n\t\treturn strdup (\"tricore\");\n\tcase EM_RCE:\n\t\treturn strdup (\"mcore\");\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn strdup (\"arm\");\n\tcase EM_QDSP6: // EM_HEXAGON\n\t\treturn strdup (\"hexagon\");\n\tcase EM_BLACKFIN:\n\t\treturn strdup (\"blackfin\");\n\tcase EM_SPARC:\n\tcase EM_SPARC32PLUS:\n\tcase EM_SPARCV9:\n\t\treturn strdup (\"sparc\");\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn strdup (\"ppc\");\n\tcase EM_PARISC:\n\t\treturn strdup (\"hppa\");\n\tcase EM_PROPELLER:\n\t\treturn strdup (\"propeller\");\n\tcase EM_MICROBLAZE:\n\t\treturn strdup (\"microblaze.gnu\");\n\tcase EM_RISCV:\n\t\treturn strdup (\"riscv\");\n\tcase EM_VAX:\n\t\treturn strdup (\"vax\");\n\tcase EM_XTENSA:\n\t\treturn strdup (\"xtensa\");\n\tcase EM_LANAI:\n\t\treturn strdup (\"lanai\");\n\tcase EM_VIDEOCORE3:\n\tcase EM_VIDEOCORE4:\n\t\treturn strdup (\"vc4\");\n\tcase EM_MSP430:\n\t\treturn strdup (\"msp430\");\n\tcase EM_SH:\n\t\treturn strdup (\"sh\");\n\tcase EM_V800:\n\t\treturn strdup (\"v850\");\n\tcase EM_V850:\n\t\treturn strdup (\"v850\");\n\tcase EM_IA_64:\n\t\treturn strdup (\"ia64\");\n\tcase EM_S390:\n\t\treturn strdup (\"s390\");\n\tcase EM_KVX:\n\t\treturn strdup(\"kvx\");\n\tcase EM_LOONGARCH:\n\t\treturn strdup (\"loongarch\");\n\tdefault: return strdup (\"x86\");\n\t}\n}\nchar* Elf_(r_bin_elf_get_abi)(ELFOBJ *bin) {\n\tElf_(Ehdr)* ehdr = (Elf_(Ehdr) *) &bin->ehdr;\n\n\tif (ehdr->e_machine == EM_MIPS) {\n\t\tif (is_elfclass64 (ehdr)) {\n\t\t\treturn strdup (\"n64\");\n\t\t}\n\t\tif (is_mips_n32 (ehdr)) {\n\t\t\treturn strdup (\"n32\");\n\t\t}\n\t\tif (is_mips_o32 (ehdr)) {\n\t\t\treturn strdup (\"o32\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar* Elf_(r_bin_elf_get_cpu)(ELFOBJ *bin) {\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:        return strdup (\"mips1\");\n\t\tcase EF_MIPS_ARCH_2:        return strdup (\"mips2\");\n\t\tcase EF_MIPS_ARCH_3:        return strdup (\"mips3\");\n\t\tcase EF_MIPS_ARCH_4:        return strdup (\"mips4\");\n\t\tcase EF_MIPS_ARCH_5:        return strdup (\"mips5\");\n\t\tcase EF_MIPS_ARCH_32:       return strdup (\"mips32\");\n\t\tcase EF_MIPS_ARCH_64:       return strdup (\"mips64\");\n\t\tcase EF_MIPS_ARCH_32R2:     return strdup (\"mips32r2\");\n\t\tcase EF_MIPS_ARCH_64R2:     return strdup (\"mips64r2\");\n\t\tdefault :                   return strdup (\" Unknown mips ISA\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar* Elf_(r_bin_elf_get_head_flag)(ELFOBJ *bin) {\n\tchar *head_flag = NULL;\n\tchar *str = Elf_(r_bin_elf_get_cpu) (bin);\n\tif (str) {\n\t\thead_flag = r_str_append (head_flag, str);\n\t\tfree (str);\n\t}\n\tstr = Elf_(r_bin_elf_get_abi) (bin);\n\tif (str) {\n\t\thead_flag = r_str_appendf (head_flag, \" %s\", str);\n\t\tfree (str);\n\t}\n\tif (R_STR_ISEMPTY (head_flag)) {\n\t\thead_flag = r_str_append (head_flag, \"unknown_flag\");\n\t}\n\treturn head_flag;\n}\n\n// http://www.sco.com/developers/gabi/latest/ch4.eheader.html\n\nchar* Elf_(r_bin_elf_get_machine_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_NONE:          return strdup (\"No machine\");\n\tcase EM_M32:           return strdup (\"AT&T WE 32100\");\n\tcase EM_SPARC:         return strdup (\"SUN SPARC\");\n\tcase EM_386:           return strdup (\"Intel 80386\");\n\tcase EM_68K:           return strdup (\"Motorola m68k family\");\n\tcase EM_88K:           return strdup (\"Motorola m88k family\");\n\tcase EM_860:           return strdup (\"Intel 80860\");\n\tcase EM_MIPS:          return strdup (\"MIPS R3000\");\n\tcase EM_S370:          return strdup (\"IBM System/370\");\n\tcase EM_MIPS_RS3_LE:   return strdup (\"MIPS R3000 little-endian\");\n\tcase EM_PARISC:        return strdup (\"HPPA\");\n\tcase EM_VPP500:        return strdup (\"Fujitsu VPP500\");\n\tcase EM_SPARC32PLUS:   return strdup (\"Sun's \\\"v8plus\\\"\");\n\tcase EM_960:           return strdup (\"Intel 80960\");\n\tcase EM_PPC:           return strdup (\"PowerPC\");\n\tcase EM_PPC64:         return strdup (\"PowerPC 64-bit\");\n\tcase EM_S390:          return strdup (\"IBM S390\");\n\tcase EM_V800:          return strdup (\"NEC V800 series\");\n\tcase EM_FR20:          return strdup (\"Fujitsu FR20\");\n\tcase EM_RH32:          return strdup (\"TRW RH-32\");\n\tcase EM_RCE:           return strdup (\"Motorola RCE\");\n\tcase EM_ARM:           return strdup (\"ARM\");\n\tcase EM_BLACKFIN:      return strdup (\"Analog Devices Blackfin\");\n\tcase EM_FAKE_ALPHA:    return strdup (\"Digital Alpha\");\n\tcase EM_SH:            return strdup (\"Hitachi SH\");\n\tcase EM_SPARCV9:       return strdup (\"SPARC v9 64-bit\");\n\tcase EM_TRICORE:       return strdup (\"Siemens Tricore\");\n\tcase EM_ARC:           return strdup (\"Argonaut RISC Core\");\n\tcase EM_H8_300:        return strdup (\"Hitachi H8/300\");\n\tcase EM_H8_300H:       return strdup (\"Hitachi H8/300H\");\n\tcase EM_H8S:           return strdup (\"Hitachi H8S\");\n\tcase EM_H8_500:        return strdup (\"Hitachi H8/500\");\n\tcase EM_IA_64:         return strdup (\"Intel Merced\");\n\tcase EM_MIPS_X:        return strdup (\"Stanford MIPS-X\");\n\tcase EM_COLDFIRE:      return strdup (\"Motorola Coldfire\");\n\tcase EM_68HC12:        return strdup (\"Motorola M68HC12\");\n\tcase EM_MMA:           return strdup (\"Fujitsu MMA Multimedia Accelerator\");\n\tcase EM_PCP:           return strdup (\"Siemens PCP\");\n\tcase EM_NCPU:          return strdup (\"Sony nCPU embeeded RISC\");\n\tcase EM_NDR1:          return strdup (\"Denso NDR1 microprocessor\");\n\tcase EM_STARCORE:      return strdup (\"Motorola Start*Core processor\");\n\tcase EM_ME16:          return strdup (\"Toyota ME16 processor\");\n\tcase EM_ST100:         return strdup (\"STMicroelectronic ST100 processor\");\n\tcase EM_TINYJ:         return strdup (\"Advanced Logic Corp. Tinyj emb.fam\");\n\tcase EM_X86_64:        return strdup (\"AMD x86-64 architecture\");\n\tcase EM_LANAI:         return strdup (\"32bit LANAI architecture\");\n\tcase EM_PDSP:          return strdup (\"Sony DSP Processor\");\n\tcase EM_PDP10:         return strdup (\"Digital Equipment Corp. PDP-10\");\n\tcase EM_PDP11:         return strdup (\"Digital Equipment Corp. PDP-11\");\n\tcase EM_FX66:          return strdup (\"Siemens FX66 microcontroller\");\n\tcase EM_ST9PLUS:       return strdup (\"STMicroelectronics ST9+ 8/16 mc\");\n\tcase EM_ST7:           return strdup (\"STmicroelectronics ST7 8 bit mc\");\n\tcase EM_68HC16:        return strdup (\"Motorola MC68HC16 microcontroller\");\n\tcase EM_68HC11:        return strdup (\"Motorola MC68HC11 microcontroller\");\n\tcase EM_68HC08:        return strdup (\"Motorola MC68HC08 microcontroller\");\n\tcase EM_68HC05:        return strdup (\"Motorola MC68HC05 microcontroller\");\n\tcase EM_SVX:           return strdup (\"Silicon Graphics SVx\");\n\tcase EM_ST19:          return strdup (\"STMicroelectronics ST19 8 bit mc\");\n\tcase EM_VAX:           return strdup (\"Digital VAX\");\n\tcase EM_CRIS:          return strdup (\"Axis Communications 32-bit embedded processor\");\n\tcase EM_JAVELIN:       return strdup (\"Infineon Technologies 32-bit embedded processor\");\n\tcase EM_FIREPATH:      return strdup (\"Element 14 64-bit DSP Processor\");\n\tcase EM_ZSP:           return strdup (\"LSI Logic 16-bit DSP Processor\");\n\tcase EM_MMIX:          return strdup (\"Donald Knuth's educational 64-bit processor\");\n\tcase EM_HUANY:         return strdup (\"Harvard University machine-independent object files\");\n\tcase EM_PRISM:         return strdup (\"SiTera Prism\");\n\tcase EM_AVR:           return strdup (\"Atmel AVR 8-bit microcontroller\");\n\tcase EM_FR30:          return strdup (\"Fujitsu FR30\");\n\tcase EM_D10V:          return strdup (\"Mitsubishi D10V\");\n\tcase EM_D30V:          return strdup (\"Mitsubishi D30V\");\n\tcase EM_V850:          return strdup (\"NEC v850\");\n\tcase EM_M32R:          return strdup (\"Mitsubishi M32R\");\n\tcase EM_MN10300:       return strdup (\"Matsushita MN10300\");\n\tcase EM_MN10200:       return strdup (\"Matsushita MN10200\");\n\tcase EM_PJ:            return strdup (\"picoJava\");\n\tcase EM_OPENRISC:      return strdup (\"OpenRISC 32-bit embedded processor\");\n\tcase EM_ARC_A5:        return strdup (\"ARC Cores Tangent-A5\");\n\tcase EM_XTENSA:        return strdup (\"Tensilica Xtensa Architecture\");\n\tcase EM_AARCH64:       return strdup (\"ARM aarch64\");\n\tcase EM_PROPELLER:     return strdup (\"Parallax Propeller\");\n\tcase EM_MICROBLAZE:    return strdup (\"Xilinx MicroBlaze\");\n\tcase EM_RISCV:         return strdup (\"RISC V\");\n\tcase EM_VIDEOCORE3:    return strdup (\"VideoCore III\");\n\tcase EM_VIDEOCORE4:    return strdup (\"VideoCore IV\");\n\tcase EM_LATTICEMICO32: return strdup (\"RISC processor for Lattice FPGA architecture\");\n\tcase EM_SE_C17:        return strdup (\"Seiko Epson C17 family\");\n\tcase EM_TI_C6000:      return strdup (\"The Texas Instruments TMS320C6000 DSP family\");\n\tcase EM_TI_C2000:      return strdup (\"The Texas Instruments TMS320C2000 DSP family\");\n\tcase EM_TI_C5500:      return strdup (\"The Texas Instruments TMS320C55x DSP family\");\n\tcase EM_TI_ARP32:      return strdup (\"Texas Instruments Application Specific RISC Processor, 32bit fetch\");\n\tcase EM_TI_PRU:        return strdup (\"Texas Instruments Programmable Realtime Unit\");\n\tcase EM_MMDSP_PLUS:    return strdup (\"STMicroelectronics 64bit VLIW Data Signal Processor\");\n\tcase EM_CYPRESS_M8C:   return strdup (\"Cypress M8C microprocessor\");\n\tcase EM_R32C:          return strdup (\"Renesas R32C series microprocessors\");\n\tcase EM_TRIMEDIA:      return strdup (\"NXP Semiconductors TriMedia architecture family\");\n\tcase EM_QDSP6:         return strdup (\"QUALCOMM DSP6 Processor\");  // Nonstandard\n\tcase EM_8051:          return strdup (\"Intel 8051 and variants\");\n\tcase EM_STXP7X:        return strdup (\"STMicroelectronics STxP7x family of configurable and extensible RISC processors\");\n\tcase EM_NDS32:         return strdup (\"Andes Technology compact code size embedded RISC processor family\");\n\tcase EM_ECOG1:         return strdup (\"Cyan Technology eCOG1X family\");\n\t// case EM_ECOG1X:        return strdup (\"Cyan Technology eCOG1X family\");  // Nonstandard\n\tcase EM_MAXQ30:        return strdup (\"Dallas Semiconductor MAXQ30 Core Micro-controllers\");\n\tcase EM_XIMO16:        return strdup (\"New Japan Radio (NJR) 16-bit DSP Processor\");\n\tcase EM_MANIK:         return strdup (\"M2000 Reconfigurable RISC Microprocessor\");\n\tcase EM_CRAYNV2:       return strdup (\"Cray Inc. NV2 vector architecture\");\n\tcase EM_RX:            return strdup (\"Renesas RX family\");\n\tcase EM_METAG:         return strdup (\"Imagination Technologies META processor architecture\");\n\tcase EM_MCST_ELBRUS:   return strdup (\"MCST Elbrus general purpose hardware architecture\");\n\tcase EM_ECOG16:        return strdup (\"Cyan Technology eCOG16 family\");\n\tcase EM_CR16:          return strdup (\"National Semiconductor CompactRISC CR16 16-bit microprocessor\");\n\tcase EM_ETPU:          return strdup (\"Freescale Extended Time Processing Unit\");\n\tcase EM_SLE9X:         return strdup (\"Infineon Technologies SLE9X core\");\n\tcase EM_L10M:          return strdup (\"Intel L10M\");\n\tcase EM_K10M:          return strdup (\"Intel K10M\");\n\t// case EM_AARCH64:       return strdup (\"ARM 64-bit architecture (AARCH64)\");  // Nonstandard\n\tcase EM_AVR32:         return strdup (\"Atmel Corporation 32-bit microprocessor family\");\n\tcase EM_STM8:          return strdup (\"STMicroeletronics STM8 8-bit microcontroller\");\n\tcase EM_TILE64:        return strdup (\"Tilera TILE64 multicore architecture family\");\n\tcase EM_TILEPRO:       return strdup (\"Tilera TILEPro multicore architecture family\");\n\t// case EM_MICROBLAZE:    return strdup (\"Xilinx MicroBlaze 32-bit RISC soft processor core\");  // Nonstandard\n\tcase EM_CUDA:          return strdup (\"NVIDIA CUDA architecture\");\n\tcase EM_TILEGX:        return strdup (\"Tilera TILE-Gx multicore architecture family\");\n\tcase EM_CLOUDSHIELD:   return strdup (\"CloudShield architecture family\");\n\tcase EM_COREA_1ST:     return strdup (\"KIPO-KAIST Core-A 1st generation processor family\");\n\tcase EM_COREA_2ND:     return strdup (\"KIPO-KAIST Core-A 2nd generation processor family\");\n\tcase EM_ARC_COMPACT2:  return strdup (\"Synopsys ARCompact V2\");\n\tcase EM_OPEN8:         return strdup (\"Open8 8-bit RISC soft processor core\");\n\tcase EM_RL78:          return strdup (\"Renesas RL78 family\");\n\tcase EM_VIDEOCORE5:    return strdup (\"Broadcom VideoCore V processor\");\n\tcase EM_78KOR:         return strdup (\"Renesas 78KOR family\");\n\t// case EM_56800EX:       return strdup (\"Freescale 56800EX Digital Signal Controller (DSC)\");  // Nonstandard\n\tcase EM_BA1:           return strdup (\"Beyond BA1 CPU architecture\");\n\tcase EM_BA2_NON_STANDARD:\n\tcase EM_BA2:           return strdup (\"Beyond BA2 CPU architecture\");\n\tcase EM_XCORE:         return strdup (\"XMOS xCORE processor family\");\n\tcase EM_MCHP_PIC:      return strdup (\"Microchip 8-bit PIC(r) family\");\n\tcase EM_INTEL205:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL206:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL207:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL208:      return strdup (\"Reserved by Intel\");\n\tcase EM_INTEL209:      return strdup (\"Reserved by Intel\");\n\tcase EM_KM32:          return strdup (\"KM211 KM32 32-bit processor\");\n\tcase EM_KMX32:         return strdup (\"KM211 KMX32 32-bit processor\");\n\tcase EM_KMX16:         return strdup (\"KM211 KMX16 16-bit processor\");\n\tcase EM_KMX8:          return strdup (\"KM211 KMX8 8-bit processor\");\n\tcase EM_KVARC:         return strdup (\"KM211 KVARC processor\");\n\tcase EM_CDP:           return strdup (\"Paneve CDP architecture family\");\n\tcase EM_COGE:          return strdup (\"Cognitive Smart Memory Processor\");\n\tcase EM_COOL:          return strdup (\"Bluechip Systems CoolEngine\");\n\tcase EM_NORC:          return strdup (\"Nanoradio Optimized RISC\");\n\tcase EM_CSR_KALIMBA:   return strdup (\"CSR Kalimba architecture family\");\n\tcase EM_Z80:           return strdup (\"Zilog Z80\");\n\tcase EM_VISIUM:        return strdup (\"Controls and Data Services VISIUMcore processor\");\n\tcase EM_FT32:          return strdup (\"FTDI Chip FT32 high performance 32-bit RISC architecture\");\n\tcase EM_MOXIE:         return strdup (\"Moxie processor family\");\n\tcase EM_AMDGPU:        return strdup (\"AMD GPU architecture\");\n\tcase EM_LOONGARCH:     return strdup (\"Loongson Loongarch\");\n\n\tdefault:             return r_str_newf (\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tut32 e_type = (ut32)bin->ehdr.e_type; // cast to avoid warn in iphone-gcc, must be ut16\n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}\n\nchar* Elf_(r_bin_elf_get_elf_class)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASSNONE: return strdup (\"none\");\n\tcase ELFCLASS32:   return strdup (\"ELF32\");\n\tcase ELFCLASS64:   return strdup (\"ELF64\");\n\tdefault:           return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n\t}\n}\n\nint Elf_(r_bin_elf_get_bits)(ELFOBJ *bin) {\n\t/* Hack for ARCompact */\n\tif (bin->ehdr.e_machine == EM_ARC_A5) {\n\t\treturn 16;\n\t}\n\t/* Hack for Ps2 */\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tif (bin->ehdr.e_type == ET_EXEC) {\n\t\t\tint i;\n\t\t\tbool haveInterp = false;\n\t\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\t\t\thaveInterp = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!haveInterp && mipsType == EF_MIPS_ARCH_3) {\n\t\t\t\t// Playstation2 Hack\n\t\t\t\treturn 64;\n\t\t\t}\n\t\t}\n\t\t// TODO: show this specific asm.cpu somewhere in bininfo (mips1, mips2, mips3, mips32r2, ...)\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:\n\t\tcase EF_MIPS_ARCH_2:\n\t\tcase EF_MIPS_ARCH_3:\n\t\tcase EF_MIPS_ARCH_4:\n\t\tcase EF_MIPS_ARCH_5:\n\t\tcase EF_MIPS_ARCH_32:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64:\n\t\t\treturn 64;\n\t\tcase EF_MIPS_ARCH_32R2:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64R2:\n\t\t\treturn 64;\n\t\t\tbreak;\n\t\t}\n\t\treturn 32;\n\t}\n\t/* Hack for Thumb */\n\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\tif (bin->ehdr.e_type != ET_EXEC) {\n\t\t\tstruct r_bin_elf_symbol_t *symbol;\n\t\t\tif ((symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\t\t\tut64 paddr = symbol[i].offset;\n\t\t\t\t\tif (paddr & 1) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\t\tif (entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t}\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:   return 32;\n\tcase ELFCLASS64:   return 64;\n\tcase ELFCLASSNONE:\n\tdefault:           return 32; // defaults\n\t}\n}\n\nstatic inline int noodle(ELFOBJ *bin, const char *s) {\n\tif (r_buf_size (bin->b) >= 64)  {\n\t\tut8 tmp[64] = {0};\n\t\tif (r_buf_read_at (bin->b, r_buf_size (bin->b) - 64, tmp, 64) == 64) {\n\t\t\treturn (bool)r_mem_mem (tmp, 64, (const ut8 *)s, strlen (s));\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic inline bool needle(ELFOBJ *bin, const char *s) {\n\tif (bin->shstrtab) {\n\t\tut32 len = bin->shstrtab_size;\n\t\tif (len > 4096) {\n\t\t\tlen = 4096; // avoid slow loading .. can be buggy?\n\t\t}\n\t\treturn (bool)r_mem_mem ((const ut8*)bin->shstrtab, len,\n\t\t\t\t(const ut8*)s, strlen (s));\n\t}\n\treturn false;\n}\n\n// TODO: must return const char * all those strings must be const char os[LINUX] or so\nchar* Elf_(r_bin_elf_get_osabi_name)(ELFOBJ *bin) {\n\tsize_t i;\n\tsize_t num = bin->ehdr.e_shnum;\n\tconst char *section_name = NULL;\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX: return strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS: return strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD: return strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX: return strdup(\"hpux\");\n\t}\n\n\tif (bin->shdr && bin->shstrtab) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->shdr[i].sh_type == SHT_NOTE && bin->shdr[i].sh_name < bin->shstrtab_size) {\n\t\t\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\t\t\tif (!strcmp (section_name, \".note.openbsd.ident\")) {\n\t\t\t\t\treturn strdup (\"openbsd\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.minix.ident\")) {\n\t\t\t\t\treturn strdup (\"minix\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.netbsd.ident\")) {\n\t\t\t\t\treturn strdup (\"netbsd\");\n\t\t\t\t}\n\t\t\t\tif (!strcmp (section_name, \".note.android.ident\")) {\n\t\t\t\t\treturn strdup (\"android\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* Hack to identify OS */\n\tif (needle (bin, \"freebsd\")) {\n\t\treturn strdup (\"freebsd\");\n\t}\n\tif (noodle (bin, \"BEOS:APP_VERSION\")) {\n\t\treturn strdup (\"beos\");\n\t}\n\tif (needle (bin, \"GNU\")) {\n\t\treturn strdup (\"linux\");\n\t}\n\treturn strdup (\"linux\");\n}\n\nut8 *Elf_(r_bin_elf_grab_regstate)(ELFOBJ *bin, int *len) {\n\tif (bin->phdr) {\n\t\tsize_t i;\n\t\tint num = bin->ehdr.e_phnum;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->phdr[i].p_type != PT_NOTE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint elf_nhdr_size = (bits == 64) ? sizeof (Elf64_Nhdr) : sizeof (Elf32_Nhdr);\n\t\t\tvoid *elf_nhdr = calloc (elf_nhdr_size, 1);\n\t\t\tbool regs_found = false;\n\t\t\tut64 offset = 0;\n\n\t\t\twhile (!regs_found) {\n\t\t\t\tut32 n_descsz, n_namesz, n_type;\n\t\t\t\tint ret;\n\t\t\t\tret = r_buf_read_at (bin->b, bin->phdr[i].p_offset + offset, elf_nhdr, elf_nhdr_size);\n\t\t\t\tif (ret != elf_nhdr_size) {\n\t\t\t\t\tR_LOG_DEBUG (\"Cannot read NOTES hdr from CORE file\");\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\tn_descsz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf64_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t} else {\n\t\t\t\t\tn_descsz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf32_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t}\n\t\t\t\tif (n_type == NT_PRSTATUS) {\n\t\t\t\t\tregs_found = true;\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t} else {\n\t\t\t\t\toffset += elf_nhdr_size + n_descsz + n_namesz;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint regdelta = 0;\n\t\t\tint regsize = 0;\n\t\t\tswitch (bin->ehdr.e_machine) {\n\t\t\t\tcase EM_AARCH64:\n\t\t\t\t\tregsize = reginf[AARCH64].regsize;\n\t\t\t\t\tregdelta = reginf[AARCH64].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_ARM:\n\t\t\t\t\tregsize = reginf[ARM].regsize;\n\t\t\t\t\tregdelta = reginf[ARM].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_386:\n\t\t\t\t\tregsize = reginf[X86].regsize;\n\t\t\t\t\tregdelta = reginf[X86].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EM_X86_64:\n\t\t\t\t\tregsize = reginf[X86_64].regsize;\n\t\t\t\t\tregdelta = reginf[X86_64].regdelta;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 *buf = malloc (regsize);\n\t\t\tif (r_buf_read_at (bin->b, bin->phdr[i].p_offset + offset + regdelta, buf, regsize) != regsize) {\n\t\t\t\tfree (buf);\n\t\t\t\tR_LOG_DEBUG (\"Cannot read register state from CORE file\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\t*len = regsize;\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\t}\n\tR_LOG_DEBUG (\"Cannot find NOTE section.\");\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_is_big_endian)(ELFOBJ *bin) {\n\treturn (bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB);\n}\n\n/* XXX Init dt_strtab? */\nchar *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tElf_(Xword) val;\n\n\tif (!bin->phdr || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dyn_info.dt_rpath != R_BIN_ELF_XWORD_MAX)  {\n\t\tval = bin->dyn_info.dt_rpath;\n\t} else if (bin->dyn_info.dt_runpath != R_BIN_ELF_XWORD_MAX) {\n\t\tval = bin->dyn_info.dt_runpath;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tif (val > bin->strtab_size) {\n\t\treturn NULL;\n\t}\n\n\treturn r_str_ndup (bin->strtab + val, ELF_STRING_LENGTH);\n}\n\nstatic bool has_valid_section_header(ELFOBJ *bin, size_t pos) {\n\treturn bin->g_sections[pos].info < bin->ehdr.e_shnum && bin->shdr;\n}\n\nstatic void fix_rva_and_offset_relocable_file(ELFOBJ *bin, RBinElfReloc *r, size_t pos) {\n\tif (has_valid_section_header (bin, pos)) {\n\t\tsize_t idx = bin->g_sections[pos].info;\n\t\tif (idx < bin->ehdr.e_shnum) {\n\t\t\tut64 pa = bin->shdr[idx].sh_offset + r->offset;\n\t\t\tr->offset = pa;\n\t\t\tr->rva = Elf_(r_bin_elf_p2v) (bin, pa);\n\t\t} else {\n\t\t\teprintf (\"fix_rva_and_offset_reloc..: invalid index\\n\");\n\t\t}\n\t} else {\n\t\tr->rva = r->offset;\n\t}\n}\n\nstatic void fix_rva_and_offset_exec_file(ELFOBJ *bin, RBinElfReloc *r) {\n\tr->rva = r->offset;\n\tr->offset = Elf_(r_bin_elf_v2p) (bin, r->offset);\n}\n\nstatic void fix_rva_and_offset(ELFOBJ *bin, RBinElfReloc *r, size_t pos) {\n\tif (is_bin_etrel (bin)) {\n\t\tfix_rva_and_offset_relocable_file (bin, r, pos);\n\t} else {\n\t\tfix_rva_and_offset_exec_file (bin, r);\n\t}\n}\n\nstatic bool read_reloc(ELFOBJ *bin, RBinElfReloc *r, Elf_(Xword) rel_mode, ut64 vaddr) {\n\tut64 offset = Elf_(r_bin_elf_v2p_new) (bin, vaddr);\n\tif (offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tsize_t size_struct = get_size_rel_mode (rel_mode);\n\n\tut8 buf[sizeof (Elf_(Rela))] = {0};\n\tint res = r_buf_read_at (bin->b, offset, buf, size_struct);\n\tif (res != size_struct) {\n\t\treturn false;\n\t}\n\n\tsize_t i = 0;\n\tElf_(Rela) reloc_info;\n\n\treloc_info.r_offset = R_BIN_ELF_READWORD (buf, i);\n\treloc_info.r_info = R_BIN_ELF_READWORD (buf, i);\n\n\tif (rel_mode == DT_RELA) {\n\t\treloc_info.r_addend = R_BIN_ELF_READWORD (buf, i);\n\t\tr->addend = reloc_info.r_addend;\n\t}\n\n\tr->mode = rel_mode;\n\tr->last = 0;\n\tr->offset = reloc_info.r_offset;\n\tr->sym = ELF_R_SYM (reloc_info.r_info);\n\tr->type = ELF_R_TYPE (reloc_info.r_info);\n\n\treturn true;\n}\n\nstatic size_t get_num_relocs_dynamic(ELFOBJ *bin) {\n\tsize_t res = 0;\n\n\tif (bin->dyn_info.dt_relaent) {\n\t\tres += bin->dyn_info.dt_relasz / bin->dyn_info.dt_relaent;\n\t}\n\n\tif (bin->dyn_info.dt_relent) {\n\t\tres += bin->dyn_info.dt_relsz / bin->dyn_info.dt_relent;\n\t}\n\n\treturn res + get_num_relocs_dynamic_plt (bin);\n}\n\nstatic bool sectionIsValid(ELFOBJ *bin, RBinElfSection *sect) {\n\treturn (sect->offset + sect->size <= bin->size);\n}\n\nstatic Elf_(Xword) get_section_mode(ELFOBJ *bin, size_t pos) {\n\tif (r_str_startswith (bin->g_sections[pos].name, \".rela.\")) {\n\t\treturn DT_RELA;\n\t}\n\tif (r_str_startswith (bin->g_sections[pos].name, \".rel.\")) {\n\t\treturn DT_REL;\n\t}\n\treturn 0;\n}\n\nstatic bool is_reloc_section(Elf_(Xword) rel_mode) {\n\treturn rel_mode == DT_REL || rel_mode == DT_RELA;\n}\n\nstatic size_t get_num_relocs_sections(ELFOBJ *bin) {\n\tsize_t i, size, ret = 0;\n\tElf_(Xword) rel_mode;\n\n\tif (!bin->g_sections) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!sectionIsValid (bin, &bin->g_sections[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\trel_mode = get_section_mode (bin, i);\n\t\tif (!is_reloc_section (rel_mode)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsize = get_size_rel_mode (rel_mode);\n\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t}\n\n\treturn ret;\n}\n\nstatic size_t get_num_relocs_approx(ELFOBJ *bin) {\n\tsize_t total = get_num_relocs_dynamic (bin) + get_num_relocs_sections (bin);\n\tif (total > bin->size) {\n\t\treturn bin->size / 2;\n\t}\n\treturn total;\n}\n\nstatic size_t populate_relocs_record_from_dynamic(ELFOBJ *bin, RBinElfReloc *relocs, size_t pos, size_t num_relocs) {\n\tsize_t offset;\n\tsize_t size = get_size_rel_mode (bin->dyn_info.dt_pltrel);\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_pltrelsz && pos < num_relocs; offset += size, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, bin->dyn_info.dt_pltrel, bin->dyn_info.dt_jmprel + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_relasz && pos < num_relocs; offset += bin->dyn_info.dt_relaent, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, DT_RELA, bin->dyn_info.dt_rela + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\tfor (offset = 0; offset < bin->dyn_info.dt_relsz && pos < num_relocs; offset += bin->dyn_info.dt_relent, pos++) {\n\t\tif (!read_reloc (bin, relocs + pos, DT_REL, bin->dyn_info.dt_rel + offset)) {\n\t\t\tbreak;\n\t\t}\n\t\tfix_rva_and_offset_exec_file (bin, relocs + pos);\n\t}\n\n\treturn pos;\n}\n\nstatic size_t get_next_not_analysed_offset(ELFOBJ *bin, size_t section_vaddr, size_t offset) {\n\tsize_t gvaddr = section_vaddr + offset;\n\n\tif (bin->dyn_info.dt_rela != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_rela <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_rela + bin->dyn_info.dt_relasz) {\n\t\treturn bin->dyn_info.dt_rela + bin->dyn_info.dt_relasz - section_vaddr;\n\t}\n\n\tif (bin->dyn_info.dt_rel != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_rel <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_rel + bin->dyn_info.dt_relsz) {\n\t\treturn bin->dyn_info.dt_rel + bin->dyn_info.dt_relsz - section_vaddr;\n\t}\n\n\tif (bin->dyn_info.dt_jmprel != R_BIN_ELF_ADDR_MAX && bin->dyn_info.dt_jmprel <= gvaddr\n\t\t&& gvaddr < bin->dyn_info.dt_jmprel + bin->dyn_info.dt_pltrelsz) {\n\t\treturn bin->dyn_info.dt_jmprel + bin->dyn_info.dt_pltrelsz - section_vaddr;\n\t}\n\n\treturn offset;\n}\n\nstatic size_t populate_relocs_record_from_section(ELFOBJ *bin, RBinElfReloc *relocs, size_t pos, size_t num_relocs) {\n\tsize_t size, i, j;\n\tElf_(Xword) rel_mode;\n\n\tif (!bin->g_sections) {\n\t\treturn pos;\n\t}\n\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\trel_mode = get_section_mode (bin, i);\n\n\t\tif (!is_reloc_section (rel_mode) || bin->g_sections[i].size > bin->size || bin->g_sections[i].offset > bin->size) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = get_size_rel_mode (rel_mode);\n\n\t\tfor (j = get_next_not_analysed_offset (bin, bin->g_sections[i].rva, 0);\n\t\t\tj < bin->g_sections[i].size && pos < num_relocs;\n\t\t\tj = get_next_not_analysed_offset (bin, bin->g_sections[i].rva, j + size)) {\n\n\t\t\tif (!read_reloc (bin, relocs + pos, rel_mode, bin->g_sections[i].rva + j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfix_rva_and_offset (bin, relocs + pos, i);\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn pos;\n}\n\nstatic RBinElfReloc *populate_relocs_record(ELFOBJ *bin) {\n\tsize_t i = 0;\n\tsize_t num_relocs = get_num_relocs_approx (bin);\n\tRBinElfReloc *relocs = R_NEWS0 (RBinElfReloc, num_relocs + 1);\n\tif (!relocs) {\n\t\t// In case we can't allocate enough memory for all the claimed\n\t\t// relocation entries, try to parse only the ones specified in\n\t\t// the dynamic segment.\n\t\tnum_relocs = get_num_relocs_dynamic (bin);\n\t\trelocs = R_NEWS0 (RBinElfReloc, num_relocs + 1);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\ti = populate_relocs_record_from_dynamic (bin, relocs, i, num_relocs);\n\ti = populate_relocs_record_from_section (bin, relocs, i, num_relocs);\n\trelocs[i].last = 1;\n\n\tbin->g_reloc_num = i;\n\treturn relocs;\n}\n\nRBinElfReloc* Elf_(r_bin_elf_get_relocs) (ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\n\tif (!bin->g_relocs) {\n\t\tbin->g_relocs = populate_relocs_record (bin);\n\t}\n\treturn bin->g_relocs;\n}\n\nRBinElfLib* Elf_(r_bin_elf_get_libs)(ELFOBJ *bin) {\n\tRBinElfLib *ret = NULL;\n\tElf_(Off) *it = NULL;\n\tsize_t k = 0;\n\n\tif (!bin || !bin->phdr || !bin->strtab || *(bin->strtab+1) == '0') {\n\t\treturn NULL;\n\t}\n\n\tr_vector_foreach(&bin->dyn_info.dt_needed, it) {\n\t\tElf_(Off) val = *it;\n\n\t\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\t\tif (!r) {\n\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r;\n\t\tif (val > bin->strtab_size) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrncpy (ret[k].name, bin->strtab + val, ELF_STRING_LENGTH);\n\t\tret[k].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\tret[k].last = 0;\n\t\tif (ret[k].name[0]) {\n\t\t\tk++;\n\t\t}\n\t}\n\n\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\tif (!r) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret = r;\n\tret[k].last = 1;\n\treturn ret;\n}\n\nstatic void create_section_from_phdr(ELFOBJ *bin, RBinElfSection *ret, size_t *i, const char *name, ut64 addr, ut64 sz) {\n\tr_return_if_fail (bin && ret && i);\n\tif (!addr || addr == UT64_MAX) {\n\t\treturn;\n\t}\n\tret[*i].offset = Elf_(r_bin_elf_v2p_new) (bin, addr);\n\tret[*i].rva = addr;\n\tret[*i].size = sz;\n\tr_str_ncpy (ret[*i].name, name, R_ARRAY_SIZE (ret[*i].name) - 1);\n\tret[*i].last = 0;\n\t*i = *i + 1;\n}\n\nstatic RBinElfSection *get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tsize_t num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tr_return_val_if_fail (bin && bin->phdr, NULL);\n\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\tif (bin->dyn_info.dt_rel != R_BIN_ELF_ADDR_MAX) {\n\t\treldyn = bin->dyn_info.dt_rel;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_rela != R_BIN_ELF_ADDR_MAX) {\n\t\trelva = bin->dyn_info.dt_rela;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_relsz) {\n\t\treldynsz = bin->dyn_info.dt_relsz;\n\t}\n\tif (bin->dyn_info.dt_relasz) {\n\t\trelasz = bin->dyn_info.dt_relasz;\n\t}\n\tif (bin->dyn_info.dt_pltgot != R_BIN_ELF_ADDR_MAX) {\n\t\tpltgotva = bin->dyn_info.dt_pltgot;\n\t\tnum_sections++;\n\t}\n\tif (bin->dyn_info.dt_pltrelsz) {\n\t\tpltgotsz = bin->dyn_info.dt_pltrelsz;\n\t}\n\tif (bin->dyn_info.dt_jmprel != R_BIN_ELF_ADDR_MAX) {\n\t\trelava = bin->dyn_info.dt_jmprel;\n\t\tnum_sections++;\n\t}\n\n\tret = calloc (num_sections + 1, sizeof (RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i = 0;\n\tcreate_section_from_phdr (bin, ret, &i, \".rel.dyn\", reldyn, reldynsz);\n\tcreate_section_from_phdr (bin, ret, &i, \".rela.plt\", relava, pltgotsz);\n\tcreate_section_from_phdr (bin, ret, &i, \".rel.plt\", relva, relasz);\n\tcreate_section_from_phdr (bin, ret, &i, \".got.plt\", pltgotva, pltgotsz);\n\tret[i].last = 1;\n\n\treturn ret;\n}\n\nRBinElfSection* Elf_(r_bin_elf_get_sections)(ELFOBJ *bin) {\n\tRBinElfSection *ret = NULL;\n\tchar unknown_s[32], invalid_s[32];\n\tint i, nidx, unknown_c=0, invalid_c=0;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\tif (!bin->shdr && bin->phdr) {\n\t\t//we don't give up search in phdr section\n\t\treturn get_sections_from_phdr (bin);\n\t}\n\tif (!bin->shdr) {\n\t\treturn NULL;\n\t}\n\tut32 count = bin->ehdr.e_shnum;\n\tif (!(ret = calloc ((count + 1), sizeof (RBinElfSection)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tret[i].offset = bin->shdr[i].sh_offset;\n\t\tret[i].size = bin->shdr[i].sh_size;\n\t\tret[i].align = bin->shdr[i].sh_addralign;\n\t\tret[i].flags = bin->shdr[i].sh_flags;\n\t\tret[i].link = bin->shdr[i].sh_link;\n\t\tret[i].info = bin->shdr[i].sh_info;\n\t\tret[i].type = bin->shdr[i].sh_type;\n\t\tif (is_bin_etrel (bin)) {\n\t\t\tret[i].rva = bin->baddr + bin->shdr[i].sh_offset;\n\t\t} else {\n\t\t\tret[i].rva = bin->shdr[i].sh_addr;\n\t\t}\n\n\t\tconst int SHNAME = (int)bin->shdr[i].sh_name;\n\t\tconst int SHSIZE = (int)bin->shstrtab_size;\n\t\tnidx = SHNAME;\n\t\tif (nidx < 0 || !bin->shstrtab_section || !bin->shstrtab_size || nidx > bin->shstrtab_size) {\n\t\t\tsnprintf (invalid_s, sizeof (invalid_s), \"invalid%d\", invalid_c);\n\t\t\tstrncpy (ret[i].name, invalid_s, sizeof (ret[i].name) - 1);\n\t\t\tinvalid_c++;\n\t\t} else if (bin->shstrtab && (SHNAME > 0) && (SHNAME < SHSIZE)) {\n\t\t\tstrncpy (ret[i].name, &bin->shstrtab[SHNAME], sizeof (ret[i].name) - 1);\n\t\t} else if (bin->shdr[i].sh_type == SHT_NULL) {\n\t\t\t//to follow the same behaviour as readelf\n\t\t\tret[i].name[0] = '\\0';\n\t\t} else {\n\t\t\tsnprintf (unknown_s, sizeof (unknown_s), \"unknown%d\", unknown_c);\n\t\t\tstrncpy (ret[i].name, unknown_s, sizeof (ret[i].name) - 1);\n\t\t\tunknown_c++;\n\t\t}\n\t\tret[i].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nstatic bool is_special_arm_symbol(ELFOBJ *bin, Elf_(Sym) *sym, const char *name) {\n\tif (name[0] != '$') {\n\t\treturn false;\n\t}\n\tswitch (name[1]) {\n\tcase 'a':\n\tcase 't':\n\tcase 'd':\n\tcase 'x':\n\t\treturn (name[2] == '\\0' || name[2] == '.') &&\n\t\t\tELF_ST_TYPE (sym->st_info) == STT_NOTYPE &&\n\t\t\tELF_ST_BIND (sym->st_info) == STB_LOCAL &&\n\t\t\tELF_ST_VISIBILITY (sym->st_info) == STV_DEFAULT;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_special_symbol(ELFOBJ *bin, Elf_(Sym) *sym, const char *name) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn is_special_arm_symbol (bin, sym, name);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char *bind2str(Elf_(Sym) *sym) {\n\tswitch (ELF_ST_BIND (sym->st_info)) {\n\tcase STB_LOCAL:  return R_BIN_BIND_LOCAL_STR;\n\tcase STB_GLOBAL: return R_BIN_BIND_GLOBAL_STR;\n\tcase STB_WEAK:   return R_BIN_BIND_WEAK_STR;\n\tcase STB_NUM:    return R_BIN_BIND_NUM_STR;\n\tcase STB_LOOS:   return R_BIN_BIND_LOOS_STR;\n\tcase STB_HIOS:   return R_BIN_BIND_HIOS_STR;\n\tcase STB_LOPROC: return R_BIN_BIND_LOPROC_STR;\n\tcase STB_HIPROC: return R_BIN_BIND_HIPROC_STR;\n\tdefault:         return R_BIN_BIND_UNKNOWN_STR;\n\t}\n}\n\nstatic const char *type2str(ELFOBJ *bin, struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\tif (bin && ret && is_special_symbol (bin, sym, ret->name)) {\n\t\treturn R_BIN_TYPE_SPECIAL_SYM_STR;\n\t}\n\tswitch (ELF_ST_TYPE (sym->st_info)) {\n\tcase STT_NOTYPE: return R_BIN_TYPE_NOTYPE_STR;\n\tcase STT_OBJECT: return R_BIN_TYPE_OBJECT_STR;\n\tcase STT_FUNC: return R_BIN_TYPE_FUNC_STR;\n\tcase STT_SECTION: return R_BIN_TYPE_SECTION_STR;\n\tcase STT_FILE: return R_BIN_TYPE_FILE_STR;\n\tcase STT_COMMON: return R_BIN_TYPE_COMMON_STR;\n\tcase STT_TLS: return R_BIN_TYPE_TLS_STR;\n\tcase STT_NUM: return R_BIN_TYPE_NUM_STR;\n\tcase STT_LOOS: return R_BIN_TYPE_LOOS_STR;\n\tcase STT_HIOS: return R_BIN_TYPE_HIOS_STR;\n\tcase STT_LOPROC: return R_BIN_TYPE_LOPROC_STR;\n\tcase STT_HIPROC: return R_BIN_TYPE_HIPROC_STR;\n\tdefault: return R_BIN_TYPE_UNKNOWN_STR;\n\t}\n}\n\nstatic void fill_symbol_bind_and_type(ELFOBJ *bin, struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\tret->bind = bind2str (sym);\n\tret->type = type2str (bin, ret, sym);\n}\n\nstatic RBinElfSymbol* get_symbols_from_phdr(ELFOBJ *bin, int type) {\n\tElf_(Sym) *sym = NULL;\n\tElf_(Addr) addr_sym_table = 0;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tRBinElfSymbol *ret = NULL;\n\tint i, r, tsize, nsym, ret_ctr;\n\tut64 toffset = 0, tmp_offset;\n\tut32 size, sym_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dyn_info.dt_symtab == R_BIN_ELF_ADDR_MAX || !bin->dyn_info.dt_syment) {\n\t\treturn NULL;\n\t}\n\n\taddr_sym_table = Elf_(r_bin_elf_v2p) (bin, bin->dyn_info.dt_symtab);\n\tsym_size = bin->dyn_info.dt_syment;\n\tif (!sym_size) {\n\t\tgoto beach;\n\t}\n\n\t//since ELF doesn't specify the symbol table size we may read until the end of the buffer\n\tnsym = (bin->size - addr_sym_table) / sym_size;\n\tif (!UT32_MUL (&size, nsym, sizeof (Elf_ (Sym)))) {\n\t\tgoto beach;\n\t}\n\tif (size < 1) {\n\t\tgoto beach;\n\t}\n\tif (addr_sym_table > bin->size || addr_sym_table + size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (nsym < 1) {\n\t\treturn NULL;\n\t}\n\t// we reserve room for 4096 and grow as needed.\n\tsize_t capacity1 = 4096;\n\tsize_t capacity2 = 4096;\n\tsym = (Elf_(Sym)*) calloc (capacity1, sym_size);\n\tret = (RBinElfSymbol *) calloc (capacity2, sizeof (struct r_bin_elf_symbol_t));\n\tif (!sym || !ret) {\n\t\tgoto beach;\n\t}\n\tfor (i = 1, ret_ctr = 0; i < nsym; i++) {\n\t\tif (i >= capacity1) { // maybe grow\n\t\t\t// You take what you want, but you eat what you take.\n\t\t\tElf_(Sym)* temp_sym = (Elf_(Sym)*) realloc (sym, (size_t)(capacity1 * GROWTH_FACTOR) * sym_size);\n\t\t\tif (!temp_sym) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsym = temp_sym;\n\t\t\tcapacity1 = (size_t)(capacity1 * GROWTH_FACTOR);\n\t\t}\n\t\tif (ret_ctr >= capacity2) { // maybe grow\n\t\t\tRBinElfSymbol *temp_ret = realloc (ret, (size_t)(capacity2 * GROWTH_FACTOR) * sizeof (struct r_bin_elf_symbol_t));\n\t\t\tif (!temp_ret) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = temp_ret;\n\t\t\tcapacity2 = (size_t)(capacity2 * GROWTH_FACTOR);\n\t\t}\n\t\t// read in one entry\n\t\tr = r_buf_read_at (bin->b, addr_sym_table + i * sizeof (Elf_ (Sym)), s, sizeof (Elf_ (Sym)));\n\t\tif (r < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint j = 0;\n#if R_BIN_ELF64\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n\t\tsym[i].st_value = READ64 (s, j);\n\t\tsym[i].st_size = READ64 (s, j);\n#else\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_value = READ32 (s, j);\n\t\tsym[i].st_size = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n#endif\n\t\tbool is_sht_null = false;\n\t\tbool is_vaddr = false;\n\t\t// zero symbol is always empty\n\t\t// Examine entry and maybe store\n\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && sym[i].st_shndx == SHT_NULL) {\n\t\t\tif (sym[i].st_value) {\n\t\t\t\ttoffset = sym[i].st_value;\n\t\t\t} else if ((toffset = get_import_addr (bin, i)) == -1){\n\t\t\t\ttoffset = 0;\n\t\t\t}\n\t\t\ttsize = 16;\n\t\t} else if (type == R_BIN_ELF_ALL_SYMBOLS) {\n\t\t\ttsize = sym[i].st_size;\n\t\t\ttoffset = (ut64) sym[i].st_value;\n\t\t\tis_sht_null = sym[i].st_shndx == SHT_NULL;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t// since we don't know the size of the sym table in this case,\n\t\t// let's stop at the first invalid entry\n\t\tif (!strcmp (bind2str (&sym[i]), R_BIN_BIND_UNKNOWN_STR) ||\n\t\t    !strcmp (type2str (NULL, NULL, &sym[i]), R_BIN_TYPE_UNKNOWN_STR)) {\n\t\t\tgoto done;\n\t\t}\n\t\ttmp_offset = Elf_(r_bin_elf_v2p_new) (bin, toffset);\n\t\tif (tmp_offset == UT64_MAX) {\n\t\t\ttmp_offset = toffset;\n\t\t\tis_vaddr = true;\n\t\t}\n\t\tif (sym[i].st_name + 2 > bin->strtab_size) {\n\t\t\t// Since we are reading beyond the symbol table what's happening\n\t\t\t// is that some entry is trying to dereference the strtab beyond its capacity\n\t\t\t// is not a symbol so is the end\n\t\t\tgoto done;\n\t\t}\n\t\tret[ret_ctr].offset = tmp_offset;\n\t\tret[ret_ctr].size = tsize;\n\t\t{\n\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\tint st_name = sym[i].st_name;\n\t\t\tint maxsize = R_MIN (bin->size, bin->strtab_size);\n\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tconst int len = __strnlen (bin->strtab + st_name, rest);\n\t\t\t\tmemcpy (ret[ret_ctr].name, &bin->strtab[st_name], len);\n\t\t\t}\n\t\t}\n\t\tret[ret_ctr].ordinal = i;\n\t\tret[ret_ctr].in_shdr = false;\n\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\tfill_symbol_bind_and_type (bin, &ret[ret_ctr], &sym[i]);\n\t\tret[ret_ctr].is_sht_null = is_sht_null;\n\t\tret[ret_ctr].is_vaddr = is_vaddr;\n\t\tret[ret_ctr].last = 0;\n\t\tret_ctr++;\n\t}\ndone:\n\t// Size everything down to only what is used\n\t{\n\t\tnsym = i > 0? i: 1;\n\t\tElf_(Sym) *temp_sym = (Elf_(Sym) *)realloc (sym, (size_t)(nsym * GROWTH_FACTOR) * sym_size);\n\t\tif (!temp_sym) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsym = temp_sym;\n\t}\n\t{\n\t\tret_ctr = ret_ctr > 0? ret_ctr: 1;\n\t\tRBinElfSymbol *p = (RBinElfSymbol *)realloc (ret, (ret_ctr + 1) * sizeof (RBinElfSymbol));\n\t\tif (!p) {\n\t\t\tgoto beach;\n\t\t}\n\t\tret = p;\n\t}\n\tret[ret_ctr].last = 1;\n\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && !bin->imports_by_ord_size) {\n\t\tbin->imports_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->imports_by_ord = (RBinImport * *) calloc (ret_ctr + 1, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t} else if (type == R_BIN_ELF_ALL_SYMBOLS && !bin->symbols_by_ord_size && ret_ctr) {\n\t\tbin->symbols_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->symbols_by_ord = (RBinSymbol **) calloc (ret_ctr + 1, sizeof (RBinSymbol*));\n\t\t} else {\n\t\t\tbin->symbols_by_ord = NULL;\n\t\t}\n\t}\n\tfree (sym);\n\treturn ret;\nbeach:\n\tfree (sym);\n\tfree (ret);\n\treturn NULL;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_symbols)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_symbols) {\n\t\treturn bin->phdr_symbols;\n\t}\n\tbin->phdr_symbols = get_symbols_from_phdr (bin, R_BIN_ELF_ALL_SYMBOLS);\n\treturn bin->phdr_symbols;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tif (!bin->phdr_imports) {\n\t\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORT_SYMBOLS);\n\t}\n\treturn bin->phdr_imports;\n}\n\nstatic RBinElfSymbol *Elf_(get_phdr_symbols)(ELFOBJ *bin, int type) {\n\treturn (type != R_BIN_ELF_IMPORT_SYMBOLS)\n\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n}\n\nstatic int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {\n\tint count = 0;\n\tint result = -1;\n\tRBinElfSymbol *ret = *sym;\n\tRBinElfSymbol *phdr_symbols = Elf_(get_phdr_symbols) (bin, type);\n\tRBinElfSymbol *tmp, *p;\n\tHtUP *phd_offset_map = ht_up_new0 ();\n\tHtUP *phd_ordinal_map = ht_up_new0 ();\n\tif (phdr_symbols) {\n\t\tRBinElfSymbol *d = ret;\n\t\twhile (!d->last) {\n\t\t\tht_up_insert (phd_offset_map, d->offset, d);\n\t\t\tht_up_insert (phd_ordinal_map, d->ordinal, d);\n\t\t\td++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\t/* find match in phdr */\n\t\t\td = ht_up_find (phd_offset_map, p->offset, NULL);\n\t\t\tif (!d) {\n\t\t\t\td = ht_up_find (phd_ordinal_map, p->ordinal, NULL);\n\t\t\t}\n\t\t\tif (d) {\n\t\t\t\tp->in_shdr = true;\n\t\t\t\tif (*p->name && *d->name && r_str_startswith (d->name, \"$\")) {\n\t\t\t\t\tstrcpy (d->name, p->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\tif (!p->in_shdr) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t/*Take those symbols that are not present in the shdr but yes in phdr*/\n\t\t/*This should only should happen with fucked up binaries*/\n\t\tif (count > 0) {\n\t\t\t/*what happens if a shdr says it has only one symbol? we should look anyway into phdr*/\n\t\t\ttmp = (RBinElfSymbol*)realloc (ret, (nsym + count + 1) * sizeof (RBinElfSymbol));\n\t\t\tif (!tmp) {\n\t\t\t\tresult = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tret = tmp;\n\t\t\tret[nsym--].last = 0;\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (!p->in_shdr) {\n\t\t\t\t\tmemcpy (&ret[++nsym], p, sizeof (RBinElfSymbol));\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret[nsym + 1].last = 1;\n\t\t}\n\t\t*sym = ret;\n\t\tresult = nsym + 1;\n\t\tgoto done;\n\t}\n\tresult = nsym;\ndone:\n\tht_up_free (phd_offset_map);\n\tht_up_free (phd_ordinal_map);\n\treturn result;\n}\n\nstatic bool is_section_local_sym(ELFOBJ *bin, Elf_(Sym) *sym) {\n\tif (sym->st_name != 0) {\n\t\treturn false;\n\t}\n\tif (ELF_ST_TYPE (sym->st_info) != STT_SECTION) {\n\t\treturn false;\n\t}\n\tif (ELF_ST_BIND (sym->st_info) != STB_LOCAL) {\n\t\treturn false;\n\t}\n\tif (!is_shidx_valid (bin, sym->st_shndx)) {\n\t\treturn false;\n\t}\n\tElf_(Word) sh_name = bin->shdr[sym->st_shndx].sh_name;\n\treturn bin->shstrtab && sh_name < bin->shstrtab_size;\n}\n\nstatic void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {\n\tif (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {\n\t\treturn;\n\t}\n\tr_bin_symbol_free (eobj->symbols_by_ord[ord]);\n\teobj->symbols_by_ord[ord] = ptr;\n}\n\nstatic void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bin);\n\tRBinSymbol *ptr = *sym;\n\tint len = strlen (ptr->name);\n\tif (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {\n\t\tswitch (ptr->name[1]) {\n\t\tcase 'a' : //arm\n\t\t\tptr->bits = 32;\n\t\t\tbreak;\n\t\tcase 't': //thumb\n\t\t\tptr->bits = 16;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': //data\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto arm_symbol;\n\t\t}\n\t} else {\narm_symbol:\n\t\tptr->bits = bin_bits;\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->paddr != UT64_MAX) {\n\t\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\t\tptr->vaddr--;\n\t\t\t\t\tptr->bits = 16;\n\t\t\t\t}\n\t\t\t\tif (ptr->paddr & 1) {\n\t\t\t\t\tptr->paddr--;\n\t\t\t\t\tptr->bits = 16;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nRBinSymbol *Elf_(_r_bin_elf_convert_symbol)(struct Elf_(r_bin_elf_obj_t) *bin,\n\t\t\t\t\t  struct r_bin_elf_symbol_t *symbol,\n\t\t\t\t\t  const char *namefmt) {\n\tut64 paddr, vaddr;\n\tRBinSymbol *ptr = NULL;\n\tif (symbol->is_vaddr) {\n\t\tpaddr = UT64_MAX;\n\t\tvaddr = symbol->offset;\n\t} else {\n\t\tpaddr = symbol->offset;\n\t\tvaddr = Elf_(r_bin_elf_p2v_new) (bin, paddr);\n\t}\n\n\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\treturn NULL;\n\t}\n\tptr->name = symbol->name[0] ? r_str_newf (namefmt, &symbol->name[0]) : strdup (\"\");\n\tptr->forwarder = \"NONE\";\n\tptr->bind = symbol->bind;\n\tptr->type = symbol->type;\n\tptr->is_imported = symbol->is_imported;\n\tptr->paddr = paddr;\n\tptr->vaddr = vaddr;\n\tptr->size = symbol->size;\n\tptr->ordinal = symbol->ordinal;\n\t// detect thumb\n\tif (bin->ehdr.e_machine == EM_ARM && *ptr->name) {\n\t\t_set_arm_thumb_bits (bin, &ptr);\n\t}\n\n\treturn ptr;\n}\n\nstatic ut32 hashRBinElfSymbol(const void *obj) {\n\tconst RBinElfSymbol *symbol = (const RBinElfSymbol *)obj;\n\tif (!symbol || !*symbol->name) {\n\t\treturn 0;\n\t}\n\tint hash = sdb_hash (symbol->name);\n\thash ^= sdb_hash (symbol->type);\n\thash ^= (symbol->offset >> 32);\n\thash ^= (symbol->offset & 0xffffffff);\n\treturn hash;\n}\n\nstatic int cmp_RBinElfSymbol(const RBinElfSymbol *a, const RBinElfSymbol *b) {\n\tif (a->offset != b->offset) {\n\t\treturn 1;\n\t}\n\tint result = strcmp (a->name, b->name);\n\tif (result != 0) {\n\t\treturn result;\n\t}\n\treturn strcmp (a->type, b->type);\n}\n\nstatic RBinElfSymbol* parse_gnu_debugdata(ELFOBJ *bin, size_t *ret_size) {\n\tif (ret_size) {\n\t\t*ret_size = 0;\n\t}\n\tif (bin->g_sections) {\n\t\tsize_t i;\n\t\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\t\tif (!strcmp (bin->g_sections[i].name, \".gnu_debugdata\")) {\n\t\t\t\tut64 addr = bin->g_sections[i].offset;\n\t\t\t\tut64 size = bin->g_sections[i].size;\n\t\t\t\tif (size < 10) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut8 *data = malloc (size + 1);\n\t\t\t\tif (r_buf_read_at (bin->b, addr, data, size) == -1) {\n\t\t\t\t\teprintf (\"Cannot read%c\\n\", 10);\n\t\t\t\t}\n\t\t\t\tsize_t osize;\n\t\t\t\tut8 *odata = r_sys_unxz (data, size, &osize);\n\t\t\t\tif (odata) {\n\t\t\t\t\tRBuffer *newelf = r_buf_new_with_pointers (odata, osize, false);\n\t\t\t\t\tELFOBJ* newobj = Elf_(r_bin_elf_new_buf) (newelf, false);\n\t\t\t\t\tRBinElfSymbol *symbol = NULL;\n\t\t\t\t\tif (newobj) {\n\t\t\t\t\t\tsymbol = Elf_(r_bin_elf_get_symbols) (newobj);\n\t\t\t\t\t\tnewobj->g_symbols = NULL;\n\t\t\t\t\t\tElf_(r_bin_elf_free)(newobj);\n\t\t\t\t\t}\n\t\t\t\t\tr_buf_free (newelf);\n\t\t\t\t\tfree (odata);\n\t\t\t\t\tif (ret_size) {\n\t\t\t\t\t\t*ret_size = i;\n\t\t\t\t\t}\n\t\t\t\t\tfree (data);\n\t\t\t\t\treturn symbol;\n\t\t\t\t}\n\t\t\t\tfree (data);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// TODO: return RList<RBinSymbol*> .. or run a callback with that symbol constructed, so we don't have to do it twice\nstatic RBinElfSymbol* Elf_(_r_bin_elf_get_symbols_imports)(ELFOBJ *bin, int type) {\n\tut32 shdr_size;\n\tint tsize, nsym, ret_ctr = 0, i, j, r, k, newsize;\n\tut64 toffset;\n\tut32 size = 0;\n\tRBinElfSymbol *ret = NULL, *import_ret = NULL;\n\tRBinSymbol *import_sym_ptr = NULL;\n\tsize_t ret_size = 0, prev_ret_size = 0, import_ret_ctr = 0;\n\tElf_(Shdr) *strtab_section = NULL;\n\tElf_(Sym) *sym = NULL;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tchar *strtab = NULL;\n\tHtPP *symbol_map = NULL;\n\tHtPPOptions symbol_map_options = {\n\t\t.cmp = (HtPPListComparator)cmp_RBinElfSymbol,\n\t\t.hashfn = hashRBinElfSymbol,\n\t\t.dupkey = NULL,\n\t\t.calcsizeK = NULL,\n\t\t.calcsizeV = NULL,\n\t\t.freefn = NULL,\n\t\t.elem_size = sizeof (HtPPKv),\n\t};\n\n\tif (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {\n\t\treturn Elf_(get_phdr_symbols) (bin, type);\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn NULL;\n\t}\n\tif (shdr_size + 8 > bin->size) {\n\t\treturn NULL;\n\t}\n\tRBinElfSymbol *dbgsyms = parse_gnu_debugdata (bin, &ret_size);\n\tif (dbgsyms) {\n\t\tret = dbgsyms;\n\t\tret_ctr = ret_size;\n\t} else {\n\t\tret_ctr = 0;\n\t\tret_size = 0;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (((type & R_BIN_ELF_SYMTAB_SYMBOLS) && bin->shdr[i].sh_type == SHT_SYMTAB) ||\n\t\t\t((type & R_BIN_ELF_DYNSYM_SYMBOLS) && bin->shdr[i].sh_type == SHT_DYNSYM)) {\n\t\t\tif (bin->shdr[i].sh_link < 1) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// hack to avoid asan cry\n\t\t\tif ((bin->shdr[i].sh_link * sizeof (Elf_(Shdr))) >= shdr_size) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrtab_section = &bin->shdr[bin->shdr[i].sh_link];\n\t\t\tif (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {\n\t\t\t\tR_LOG_ERROR (\"size (syms strtab)\");\n\t\t\t\tfree (ret);\n\t\t\t\tfree (strtab);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!strtab) {\n\t\t\t\tif (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {\n\t\t\t\t\tR_LOG_ERROR (\"malloc (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (strtab_section->sh_offset > bin->size ||\n\t\t\t\t\t\tstrtab_section->sh_offset + strtab_section->sh_size > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, strtab_section->sh_offset,\n\t\t\t\t\t\t\t(ut8*)strtab, strtab_section->sh_size) == -1) {\n\t\t\t\t\tR_LOG_ERROR (\"read (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewsize = 1 + bin->shdr[i].sh_size;\n\t\t\tif (newsize < 0 || newsize > bin->size) {\n\t\t\t\tR_LOG_ERROR (\"invalid shdr %d size\", i);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));\n\t\t\tif (nsym < 0) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\t{\n\t\t\t\tut64 sh_begin = bin->shdr[i].sh_offset;\n\t\t\t\tut64 sh_end = sh_begin + bin->shdr[i].sh_size;\n\t\t\t\tif (sh_begin > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (sh_end > bin->size) {\n\t\t\t\t\tst64 newshsize = bin->size - sh_begin;\n\t\t\t\t\tnsym = (int)(newshsize / sizeof (Elf_(Sym)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {\n\t\t\t\tR_LOG_ERROR (\"calloc (syms)\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (size < 1 || size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (j = 0; j < nsym; j++) {\n\t\t\t\tint k = 0;\n\t\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));\n\t\t\t\tif (r < 1) {\n\t\t\t\t\tR_LOG_ERROR (\"read (sym)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n#if R_BIN_ELF64\n\t\t\t\tsym[j].st_name = READ32 (s, k);\n\t\t\t\tsym[j].st_info = READ8 (s, k);\n\t\t\t\tsym[j].st_other = READ8 (s, k);\n\t\t\t\tsym[j].st_shndx = READ16 (s, k);\n\t\t\t\tsym[j].st_value = READ64 (s, k);\n\t\t\t\tsym[j].st_size = READ64 (s, k);\n#else\n\t\t\t\tsym[j].st_name = READ32 (s, k);\n\t\t\t\tsym[j].st_value = READ32 (s, k);\n\t\t\t\tsym[j].st_size = READ32 (s, k);\n\t\t\t\tsym[j].st_info = READ8 (s, k);\n\t\t\t\tsym[j].st_other = READ8 (s, k);\n\t\t\t\tsym[j].st_shndx = READ16 (s, k);\n#endif\n\t\t\t}\n\t\t\tvoid *rett = realloc (ret, (ret_size + nsym) * sizeof (RBinElfSymbol));\n\t\t\tif (!rett) {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d symbols.\", (int)(nsym + ret_size));\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = rett;\n\t\t\tmemset (ret + ret_size, 0, nsym * sizeof (RBinElfSymbol));\n\t\t\tprev_ret_size = ret_size;\n\t\t\tret_size += nsym;\n\t\t\tsymbol_map = ht_pp_new_opt (&symbol_map_options);\n\t\t\tfor (k = 0; k < prev_ret_size; k++) {\n\t\t\t\tif (ret[k].name[0]) {\n\t\t\t\t\tht_pp_insert (symbol_map, ret + k, ret + k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k < nsym; k++) {\n\t\t\t\tbool is_sht_null = false;\n\t\t\t\tbool is_vaddr = false;\n\t\t\t\tbool is_imported = false;\n\t\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\t\t\t\tif (sym[k].st_value) {\n\t\t\t\t\t\ttoffset = sym[k].st_value;\n\t\t\t\t\t} else if ((toffset = get_import_addr (bin, k)) == -1) {\n\t\t\t\t\t\ttoffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttsize = 16;\n\t\t\t\t\tis_imported = sym[k].st_shndx == STN_UNDEF;\n\t\t\t\t} else {\n\t\t\t\t\ttsize = sym[k].st_size;\n\t\t\t\t\ttoffset = (ut64)sym[k].st_value;\n\t\t\t\t\tis_sht_null = sym[k].st_shndx == SHT_NULL;\n\t\t\t\t}\n\t\t\t\tif (is_bin_etrel (bin)) {\n\t\t\t\t\tif (sym[k].st_shndx < bin->ehdr.e_shnum) {\n\t\t\t\t\t\tret[ret_ctr].offset = sym[k].st_value + bin->shdr[sym[k].st_shndx].sh_offset;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret[ret_ctr].offset = Elf_(r_bin_elf_v2p_new) (bin, toffset);\n\t\t\t\t\tif (ret[ret_ctr].offset == UT64_MAX) {\n\t\t\t\t\t\tret[ret_ctr].offset = toffset;\n\t\t\t\t\t\tis_vaddr = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].size = tsize;\n\t\t\t\tif (sym[k].st_name + 1 > strtab_section->sh_size) {\n\t\t\t\t\tR_LOG_DEBUG (\"index out of strtab range (%\"PFMT64d\" / %\"PFMT64d\")\\n\",\n\t\t\t\t\t\t(ut64)sym[k].st_name, (ut64)strtab_section->sh_size);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint st_name = sym[k].st_name;\n\t\t\t\t\tint maxsize = R_MIN (r_buf_size (bin->b), strtab_section->sh_size);\n\t\t\t\t\tif (is_section_local_sym (bin, &sym[k])) {\n\t\t\t\t\t\tconst char *shname = &bin->shstrtab[bin->shdr[sym[k].st_shndx].sh_name];\n\t\t\t\t\t\tr_str_ncpy (ret[ret_ctr].name, shname, ELF_STRING_LENGTH - 1);\n\t\t\t\t\t} else if (st_name <= 0 || st_name >= maxsize) {\n\t\t\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (ret[ret_ctr].name, &strtab[st_name], ELF_STRING_LENGTH - 1);\n\t\t\t\t\t\tret[ret_ctr].type = type2str (bin, &ret[ret_ctr], &sym[k]);\n\n\t\t\t\t\t\tif (ht_pp_find (symbol_map, &ret[ret_ctr], NULL)) {\n\t\t\t\t\t\t\tmemset (ret + ret_ctr, 0, sizeof (RBinElfSymbol));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].ordinal = k;\n\t\t\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\t\tfill_symbol_bind_and_type (bin, &ret[ret_ctr], &sym[k]);\n\t\t\t\tret[ret_ctr].is_sht_null = is_sht_null;\n\t\t\t\tret[ret_ctr].is_vaddr = is_vaddr;\n\t\t\t\tret[ret_ctr].last = 0;\n\t\t\t\tret[ret_ctr].is_imported = is_imported;\n\t\t\t\tret_ctr++;\n\t\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS && is_imported) {\n\t\t\t\t\timport_ret_ctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_FREE (strtab);\n\t\t\tR_FREE (sym);\n\t\t\tht_pp_free (symbol_map);\n\t\t\tsymbol_map = NULL;\n\t\t\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!ret) {\n\t\treturn Elf_(get_phdr_symbols) (bin, type);\n\t}\n\tret[ret_ctr].last = 1; // ugly dirty hack :D\n\tint max = -1;\n\tRBinElfSymbol *aux = NULL;\n\tnsym = Elf_(fix_symbols) (bin, ret_ctr, type, &ret);\n\tif (nsym == -1) {\n\t\tgoto beach;\n\t}\n\n\t// Elf_(fix_symbols) may find additional symbols, some of which could be\n\t// imported symbols. Let's reserve additional space for them.\n\tr_warn_if_fail (nsym >= ret_ctr);\n\timport_ret_ctr += nsym - ret_ctr;\n\n\taux = ret;\n\twhile (!aux->last) {\n\t\tif ((int)aux->ordinal > max) {\n\t\t\tmax = aux->ordinal;\n\t\t}\n\t\taux++;\n\t}\n\tnsym = max;\n\tif (type == R_BIN_ELF_IMPORT_SYMBOLS) {\n\t\tR_FREE (bin->imports_by_ord);\n\t\tbin->imports_by_ord_size = nsym + 1;\n\t\tbin->imports_by_ord = (RBinImport**)calloc (R_MAX (1, nsym + 1), sizeof (RBinImport*));\n\t\tR_FREE (bin->symbols_by_ord);\n\t\tbin->symbols_by_ord_size = nsym + 1;\n\t\tbin->symbols_by_ord = (RBinSymbol**)calloc (R_MAX (1, nsym + 1), sizeof (RBinSymbol*));\n\t\timport_ret = calloc (import_ret_ctr + 1, sizeof (RBinElfSymbol));\n\t\tif (!import_ret) {\n\t\t\tR_LOG_DEBUG (\"Cannot allocate %d symbols\", nsym);\n\t\t\tgoto beach;\n\t\t}\n\t\timport_ret_ctr = 0;\n\t\ti = -1;\n\t\twhile (!ret[++i].last) {\n\t\t\tif (!(import_sym_ptr = Elf_(_r_bin_elf_convert_symbol) (bin, &ret[i], \"%s\"))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsetsymord (bin, import_sym_ptr->ordinal, import_sym_ptr);\n\t\t\tif (ret[i].is_imported) {\n\t\t\t\tmemcpy (&import_ret[import_ret_ctr], &ret[i], sizeof (RBinElfSymbol));\n\t\t\t\t++import_ret_ctr;\n\t\t\t}\n\t\t}\n\t\timport_ret[import_ret_ctr].last = 1;\n\t\tR_FREE (ret);\n\t\treturn import_ret;\n\t}\n\treturn ret;\nbeach:\n\tfree (ret);\n\tfree (sym);\n\tfree (strtab);\n\tht_pp_free (symbol_map);\n\treturn NULL;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_symbols)(ELFOBJ *bin) {\n\tif (!bin->g_symbols) {\n\t\tbin->g_symbols = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_ALL_SYMBOLS);\n\t}\n\treturn bin->g_symbols;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_imports)(ELFOBJ *bin) {\n\tif (!bin->g_imports) {\n\t\tbin->g_imports = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_IMPORT_SYMBOLS);\n\t}\n\treturn bin->g_imports;\n}\n\nRBinElfField* Elf_(r_bin_elf_get_fields)(ELFOBJ *bin) {\n\tRBinElfField *ret = NULL;\n\tint i = 0, j;\n\tif (!bin || !(ret = calloc ((bin->ehdr.e_phnum + 3 + 1), sizeof (RBinElfField)))) {\n\t\treturn NULL;\n\t}\n\tstrncpy (ret[i].name, \"ehdr\", ELF_STRING_LENGTH);\n\tret[i].offset = 0;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"shoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_shoff;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"phoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_phoff;\n\tret[i++].last = 0;\n\tfor (j = 0; bin->phdr && j < bin->ehdr.e_phnum; i++, j++) {\n\t\tsnprintf (ret[i].name, ELF_STRING_LENGTH, \"phdr_%i\", j);\n\t\tret[i].offset = bin->phdr[j].p_offset;\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nvoid Elf_(r_bin_elf_free)(ELFOBJ* bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\tfree (bin->phdr);\n\tfree (bin->shdr);\n\tfree (bin->strtab);\n\tfree (bin->shstrtab);\n\tfree (bin->dynstr);\n\tr_vector_fini (&bin->dyn_info.dt_needed);\n\t//free (bin->strtab_section);\n\tsize_t i;\n\tif (bin->imports_by_ord) {\n\t\tfor (i = 0; i<bin->imports_by_ord_size; i++) {\n\t\t\tfree (bin->imports_by_ord[i]);\n\t\t}\n\t\tfree (bin->imports_by_ord);\n\t}\n\tif (bin->symbols_by_ord) {\n\t\tfor (i = 0; i<bin->symbols_by_ord_size; i++) {\n\t\t\tr_bin_symbol_free (bin->symbols_by_ord[i]);\n\t\t}\n\t\tfree (bin->symbols_by_ord);\n\t}\n\tr_buf_free (bin->b);\n\tif (bin->g_symbols != bin->phdr_symbols) {\n\t\tR_FREE (bin->phdr_symbols);\n\t}\n\tif (bin->g_imports != bin->phdr_imports) {\n\t\tR_FREE (bin->phdr_imports);\n\t}\n\tR_FREE (bin->g_sections);\n\tR_FREE (bin->g_symbols);\n\tR_FREE (bin->g_imports);\n\tR_FREE (bin->g_relocs);\n\tht_up_free (bin->rel_cache);\n\tbin->rel_cache = NULL;\n\tsdb_free (bin->kv);\n\tfree (bin);\n}\n\nELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tif (bin) {\n\t\tbin->kv = sdb_new0 ();\n\t\tbin->size = r_buf_size (buf);\n\t\tbin->verbose = verbose;\n\t\tbin->b = r_buf_ref (buf);\n\t\tif (!elf_init (bin)) {\n\t\t\tElf_(r_bin_elf_free) (bin);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn bin;\n}\n\nstatic int is_in_pphdr(Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_offset && addr < p->p_offset + p->p_filesz;\n}\n\nstatic int is_in_vphdr(Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_vaddr && addr < p->p_vaddr + p->p_filesz;\n}\n\n/* Deprecated temporarily. Use r_bin_elf_p2v_new in new code for now. */\nut64 Elf_(r_bin_elf_p2v) (ELFOBJ *bin, ut64 paddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn paddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\tif (!p->p_vaddr && !p->p_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn paddr;\n}\n\n/* Deprecated temporarily. Use r_bin_elf_v2p_new in new code for now. */\nut64 Elf_(r_bin_elf_v2p)(ELFOBJ *bin, ut64 vaddr) {\n\tr_return_val_if_fail (bin, 0); // UT64_MAX or vaddr?\n\t// r_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn vaddr;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\tif (!p->p_offset && !p->p_vaddr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn vaddr;\n}\n\n/* converts a physical address to the virtual address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_p2v_new) (ELFOBJ *bin, ut64 paddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\n/* converts a virtual address to the relative physical address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_v2p_new) (ELFOBJ *bin, ut64 vaddr) {\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, UT64_MAX);\n\tif (!bin->phdr) {\n\t\tif (is_bin_etrel (bin)) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic bool get_nt_file_maps(ELFOBJ *bin, RList *core_maps) {\n\tut16 ph, ph_num = bin->ehdr.e_phnum;\n\n\tfor (ph = 0; ph < ph_num; ph++) {\n\t\tElf_(Phdr) *p = &bin->phdr[ph];\n\t\tif (p->p_type == PT_NOTE) {\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint elf_nhdr_size = (bits == 64) ? sizeof (Elf64_Nhdr) : sizeof (Elf32_Nhdr);\n\t\t\tint size_of = (bits == 64) ? sizeof (ut64) : sizeof (ut32);\n\t\t\tvoid *elf_nhdr = calloc (elf_nhdr_size, 1);\n\t\t\tut64 offset = 0;\n\t\t\tbool found = false;\n\n\t\t\twhile (!found) {\n\t\t\t\tint ret;\n\t\t\t\tut32 n_descsz, n_namesz, n_type;\n\t\t\t\tret = r_buf_read_at (bin->b,\n\t\t\t\t\t\tbin->phdr[ph].p_offset + offset,\n\t\t\t\t\t\telf_nhdr, elf_nhdr_size);\n\t\t\t\tif (ret != elf_nhdr_size) {\n\t\t\t\t\teprintf (\"Cannot read more NOTES header from CORE\\n\");\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\tn_descsz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf64_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf64_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t} else {\n\t\t\t\t\tn_descsz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_descsz);\n\t\t\t\t\tn_namesz = round_up (((Elf32_Nhdr *)elf_nhdr)->n_namesz);\n\t\t\t\t\tn_type = ((Elf32_Nhdr *)elf_nhdr)->n_type;\n\t\t\t\t}\n\n\t\t\t\tif (n_type == NT_FILE) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\toffset += elf_nhdr_size + n_namesz;\n\t\t\t\t\tfree (elf_nhdr);\n\t\t\t\t} else {\n\t\t\t\t\toffset += elf_nhdr_size + n_descsz + n_namesz;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 i = bin->phdr[ph].p_offset + offset;\n\t\t\tut64 n_maps;\n\t\t\tif (bits == 64) {\n\t\t\t\tn_maps = BREAD64 (bin->b, i);\n\t\t\t\t(void)BREAD64 (bin->b, i);\n\t\t\t} else {\n\t\t\t\tn_maps = BREAD32 (bin->b, i);\n\t\t\t\t(void)BREAD32 (bin->b, i);\n\t\t\t}\n\t\t\tut64 jump = ((size_of * 3) * n_maps) + i;\n\t\t\tint len_str = 0;\n\t\t\twhile (n_maps > 0) {\n\t\t\t\tut64 addr;\n\t\t\t\tif (bits == 64) {\n\t\t\t\t\taddr = BREAD64 (bin->b, i);\n\t\t\t\t} else {\n\t\t\t\t\taddr = BREAD32 (bin->b, i);\n\t\t\t\t}\n\t\t\t\tif (addr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar str[512] = {0};\n\t\t\t\tr_buf_read_at (bin->b, jump + len_str, (ut8*)str, sizeof (str) - 1);\n\t\t\t\tstr[sizeof (str) - 1] = 0; // null terminate string\n\t\t\t\tRListIter *iter;\n\t\t\t\tRBinMap *p;\n\t\t\t\tr_list_foreach (core_maps, iter, p) {\n\t\t\t\t\tif (p->addr == addr) {\n\t\t\t\t\t\tp->file = strdup (str);\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tlen_str += strlen (str) + 1;\n\t\t\t\tn_maps--;\n\t\t\t\ti += (size_of * 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\treturn false;\n}\n\nstatic void r_bin_elf_map_free(RBinMap *map) {\n\tif (map) {\n\t\tfree (map->file);\n\t\tfree (map);\n\t}\n}\n\nRList *Elf_(r_bin_elf_get_maps)(ELFOBJ *bin) {\n\tut16 ph, ph_num = bin->ehdr.e_phnum; //Skip PT_NOTE\n\tif (!bin->phdr) {\n\t\treturn NULL;\n\t}\n\tRList *maps = r_list_newf ((RListFree)r_bin_elf_map_free);\n\tfor (ph = 0; ph < ph_num; ph++) {\n\t\tElf_(Phdr) *p = &bin->phdr[ph];\n\t\tif (p->p_type == PT_LOAD) {\n\t\t\tRBinMap *map = R_NEW0 (RBinMap);\n\t\t\tif (map) {\n\t\t\t\tmap->addr = p->p_vaddr;\n\t\t\t\tmap->size = p->p_memsz;\n\t\t\t\tmap->perms = p->p_flags;\n\t\t\t\tmap->offset = p->p_offset;\n\t\t\t\tmap->file = NULL;\n\t\t\t\tr_list_append (maps, map);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!r_list_empty (maps)) {\n\t\tif (!get_nt_file_maps (bin, maps)) {\n\t\t\teprintf (\"Could not retrieve the names of all maps from NT_FILE\\n\");\n\t\t}\n\t}\n\n\treturn maps;\n}\n\nchar *Elf_(r_bin_elf_compiler)(ELFOBJ *bin) {\n\tRBinElfSection *section = get_section_by_name (bin, \".comment\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tut64 off = section->offset;\n\tut32 sz = R_MIN (section->size, 128);\n\tif (sz < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (sz + 1);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, off, (ut8*)buf, sz) < 1) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tbuf[sz] = 0;\n\tconst size_t buflen = strlen (buf);\n\tchar *nullbyte = buf + buflen;\n\tif (buflen != sz && nullbyte[1] && buflen < sz) {\n\t\tnullbyte[0] = ' ';\n\t}\n\tbuf[sz] = 0;\n\tr_str_trim (buf);\n\tchar * res = r_str_escape (buf);\n\tfree (buf);\n\treturn res;\n}\n\nbool Elf_(r_bin_elf_is_executable)(ELFOBJ *bin) {\n\tconst int t = bin->ehdr.e_type;\n\treturn t == ET_EXEC || t == ET_DYN;\n}\n"], "filenames": ["libr/anal/p/anal_msp430.c", "libr/bin/format/elf/elf.c"], "buggy_code_start_loc": [13, 127], "buggy_code_end_loc": [113, 1802], "fixing_code_start_loc": [13, 127], "fixing_code_end_loc": [113, 1802], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.", "other": {"cve": {"id": "CVE-2022-1714", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-13T15:15:08.733", "lastModified": "2022-05-23T18:35:39.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.7.0. El bug causa que el programa lea datos m\u00e1s all\u00e1 del final del b\u00fafer previsto. Normalmente, esto puede permitir a atacantes leer informaci\u00f3n confidencial de otras ubicaciones de memoria o causar un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1c22055b-b015-47a8-a57b-4982978751d0", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e"}}