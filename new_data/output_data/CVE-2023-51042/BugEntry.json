{"buggy_code": ["/*\n * Copyright 2008 Jerome Glisse.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *    Jerome Glisse <glisse@freedesktop.org>\n */\n\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/sync_file.h>\n#include <linux/dma-buf.h>\n\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_syncobj.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"amdgpu_cs.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_trace.h\"\n#include \"amdgpu_gmc.h\"\n#include \"amdgpu_gem.h\"\n#include \"amdgpu_ras.h\"\n\nstatic int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p,\n\t\t\t\t struct amdgpu_device *adev,\n\t\t\t\t struct drm_file *filp,\n\t\t\t\t union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = filp->driver_priv;\n\n\tif (cs->in.num_chunks == 0)\n\t\treturn -EINVAL;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->adev = adev;\n\tp->filp = filp;\n\n\tp->ctx = amdgpu_ctx_get(fpriv, cs->in.ctx_id);\n\tif (!p->ctx)\n\t\treturn -EINVAL;\n\n\tif (atomic_read(&p->ctx->guilty)) {\n\t\tamdgpu_ctx_put(p->ctx);\n\t\treturn -ECANCELED;\n\t}\n\n\tamdgpu_sync_create(&p->sync);\n\treturn 0;\n}\n\nstatic int amdgpu_cs_job_idx(struct amdgpu_cs_parser *p,\n\t\t\t     struct drm_amdgpu_cs_chunk_ib *chunk_ib)\n{\n\tstruct drm_sched_entity *entity;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_get_entity(p->ctx, chunk_ib->ip_type,\n\t\t\t\t  chunk_ib->ip_instance,\n\t\t\t\t  chunk_ib->ring, &entity);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Abort if there is no run queue associated with this entity.\n\t * Possibly because of disabled HW IP.\n\t */\n\tif (entity->rq == NULL)\n\t\treturn -EINVAL;\n\n\t/* Check if we can add this IB to some existing job */\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tif (p->entities[i] == entity)\n\t\t\treturn i;\n\n\t/* If not increase the gang size if possible */\n\tif (i == AMDGPU_CS_GANG_SIZE)\n\t\treturn -EINVAL;\n\n\tp->entities[i] = entity;\n\tp->gang_size = i + 1;\n\treturn i;\n}\n\nstatic int amdgpu_cs_p1_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct drm_amdgpu_cs_chunk_ib *chunk_ib,\n\t\t\t   unsigned int *num_ibs)\n{\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (num_ibs[r] >= amdgpu_ring_max_ibs(chunk_ib->ip_type))\n\t\treturn -EINVAL;\n\n\t++(num_ibs[r]);\n\tp->gang_leader_idx = r;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p1_user_fence(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_cs_chunk_fence *data,\n\t\t\t\t   uint32_t *offset)\n{\n\tstruct drm_gem_object *gobj;\n\tstruct amdgpu_bo *bo;\n\tunsigned long size;\n\tint r;\n\n\tgobj = drm_gem_object_lookup(p->filp, data->handle);\n\tif (gobj == NULL)\n\t\treturn -EINVAL;\n\n\tbo = amdgpu_bo_ref(gem_to_amdgpu_bo(gobj));\n\tp->uf_entry.priority = 0;\n\tp->uf_entry.tv.bo = &bo->tbo;\n\tdrm_gem_object_put(gobj);\n\n\tsize = amdgpu_bo_size(bo);\n\tif (size != PAGE_SIZE || (data->offset + 8) > size) {\n\t\tr = -EINVAL;\n\t\tgoto error_unref;\n\t}\n\n\tif (amdgpu_ttm_tt_get_usermm(bo->tbo.ttm)) {\n\t\tr = -EINVAL;\n\t\tgoto error_unref;\n\t}\n\n\t*offset = data->offset;\n\n\treturn 0;\n\nerror_unref:\n\tamdgpu_bo_unref(&bo);\n\treturn r;\n}\n\nstatic int amdgpu_cs_p1_bo_handles(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_bo_list_in *data)\n{\n\tstruct drm_amdgpu_bo_list_entry *info;\n\tint r;\n\n\tr = amdgpu_bo_create_list_entry_array(data, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_bo_list_create(p->adev, p->filp, info, data->bo_number,\n\t\t\t\t  &p->bo_list);\n\tif (r)\n\t\tgoto error_free;\n\n\tkvfree(info);\n\treturn 0;\n\nerror_free:\n\tkvfree(info);\n\n\treturn r;\n}\n\n/* Copy the data from userspace and go over it the first time */\nstatic int amdgpu_cs_pass1(struct amdgpu_cs_parser *p,\n\t\t\t   union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_ibs[AMDGPU_CS_GANG_SIZE] = { };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tuint64_t *chunk_array_user;\n\tuint64_t *chunk_array;\n\tuint32_t uf_offset = 0;\n\tsize_t size;\n\tint ret;\n\tint i;\n\n\tchunk_array = kvmalloc_array(cs->in.num_chunks, sizeof(uint64_t),\n\t\t\t\t     GFP_KERNEL);\n\tif (!chunk_array)\n\t\treturn -ENOMEM;\n\n\t/* get chunks */\n\tchunk_array_user = u64_to_user_ptr(cs->in.chunks);\n\tif (copy_from_user(chunk_array, chunk_array_user,\n\t\t\t   sizeof(uint64_t)*cs->in.num_chunks)) {\n\t\tret = -EFAULT;\n\t\tgoto free_chunk;\n\t}\n\n\tp->nchunks = cs->in.num_chunks;\n\tp->chunks = kvmalloc_array(p->nchunks, sizeof(struct amdgpu_cs_chunk),\n\t\t\t    GFP_KERNEL);\n\tif (!p->chunks) {\n\t\tret = -ENOMEM;\n\t\tgoto free_chunk;\n\t}\n\n\tfor (i = 0; i < p->nchunks; i++) {\n\t\tstruct drm_amdgpu_cs_chunk __user **chunk_ptr = NULL;\n\t\tstruct drm_amdgpu_cs_chunk user_chunk;\n\t\tuint32_t __user *cdata;\n\n\t\tchunk_ptr = u64_to_user_ptr(chunk_array[i]);\n\t\tif (copy_from_user(&user_chunk, chunk_ptr,\n\t\t\t\t       sizeof(struct drm_amdgpu_cs_chunk))) {\n\t\t\tret = -EFAULT;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tp->chunks[i].chunk_id = user_chunk.chunk_id;\n\t\tp->chunks[i].length_dw = user_chunk.length_dw;\n\n\t\tsize = p->chunks[i].length_dw;\n\t\tcdata = u64_to_user_ptr(user_chunk.chunk_data);\n\n\t\tp->chunks[i].kdata = kvmalloc_array(size, sizeof(uint32_t),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (p->chunks[i].kdata == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tsize *= sizeof(uint32_t);\n\t\tif (copy_from_user(p->chunks[i].kdata, cdata, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\n\t\t/* Assume the worst on the following checks */\n\t\tret = -EINVAL;\n\t\tswitch (p->chunks[i].chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_ib))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_ib(p, p->chunks[i].kdata, num_ibs);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_FENCE:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_fence))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_user_fence(p, p->chunks[i].kdata,\n\t\t\t\t\t\t      &uf_offset);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_BO_HANDLES:\n\t\t\tif (size < sizeof(struct drm_amdgpu_bo_list_in))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_bo_handles(p, p->chunks[i].kdata);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t}\n\n\tif (!p->gang_size) {\n\t\tret = -EINVAL;\n\t\tgoto free_partial_kdata;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tret = amdgpu_job_alloc(p->adev, vm, p->entities[i], vm,\n\t\t\t\t       num_ibs[i], &p->jobs[i]);\n\t\tif (ret)\n\t\t\tgoto free_all_kdata;\n\t}\n\tp->gang_leader = p->jobs[p->gang_leader_idx];\n\n\tif (p->ctx->generation != p->gang_leader->generation) {\n\t\tret = -ECANCELED;\n\t\tgoto free_all_kdata;\n\t}\n\n\tif (p->uf_entry.tv.bo)\n\t\tp->gang_leader->uf_addr = uf_offset;\n\tkvfree(chunk_array);\n\n\t/* Use this opportunity to fill in task info for the vm */\n\tamdgpu_vm_set_task_info(vm);\n\n\treturn 0;\n\nfree_all_kdata:\n\ti = p->nchunks - 1;\nfree_partial_kdata:\n\tfor (; i >= 0; i--)\n\t\tkvfree(p->chunks[i].kdata);\n\tkvfree(p->chunks);\n\tp->chunks = NULL;\n\tp->nchunks = 0;\nfree_chunk:\n\tkvfree(chunk_array);\n\n\treturn ret;\n}\n\nstatic int amdgpu_cs_p2_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct amdgpu_cs_chunk *chunk,\n\t\t\t   unsigned int *ce_preempt,\n\t\t\t   unsigned int *de_preempt)\n{\n\tstruct drm_amdgpu_cs_chunk_ib *chunk_ib = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tjob = p->jobs[r];\n\tring = amdgpu_job_ring(job);\n\tib = &job->ibs[job->num_ibs++];\n\n\t/* MM engine doesn't support user fences */\n\tif (p->uf_entry.tv.bo && ring->funcs->no_user_fence)\n\t\treturn -EINVAL;\n\n\tif (chunk_ib->ip_type == AMDGPU_HW_IP_GFX &&\n\t    chunk_ib->flags & AMDGPU_IB_FLAG_PREEMPT) {\n\t\tif (chunk_ib->flags & AMDGPU_IB_FLAG_CE)\n\t\t\t(*ce_preempt)++;\n\t\telse\n\t\t\t(*de_preempt)++;\n\n\t\t/* Each GFX command submit allows only 1 IB max\n\t\t * preemptible for CE & DE */\n\t\tif (*ce_preempt > 1 || *de_preempt > 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (chunk_ib->flags & AMDGPU_IB_FLAG_PREAMBLE)\n\t\tjob->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT;\n\n\tr =  amdgpu_ib_get(p->adev, vm, ring->funcs->parse_cs ?\n\t\t\t   chunk_ib->ib_bytes : 0,\n\t\t\t   AMDGPU_IB_POOL_DELAYED, ib);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to get ib !\\n\");\n\t\treturn r;\n\t}\n\n\tib->gpu_addr = chunk_ib->va_start;\n\tib->length_dw = chunk_ib->ib_bytes / 4;\n\tib->flags = chunk_ib->flags;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_dependencies(struct amdgpu_cs_parser *p,\n\t\t\t\t     struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_dep *deps = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_dep);\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_ctx *ctx;\n\t\tstruct drm_sched_entity *entity;\n\t\tstruct dma_fence *fence;\n\n\t\tctx = amdgpu_ctx_get(fpriv, deps[i].ctx_id);\n\t\tif (ctx == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_ctx_get_entity(ctx, deps[i].ip_type,\n\t\t\t\t\t  deps[i].ip_instance,\n\t\t\t\t\t  deps[i].ring, &entity);\n\t\tif (r) {\n\t\t\tamdgpu_ctx_put(ctx);\n\t\t\treturn r;\n\t\t}\n\n\t\tfence = amdgpu_ctx_get_fence(ctx, entity, deps[i].handle);\n\t\tamdgpu_ctx_put(ctx);\n\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tif (chunk->chunk_id == AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES) {\n\t\t\tstruct drm_sched_fence *s_fence;\n\t\t\tstruct dma_fence *old = fence;\n\n\t\t\ts_fence = to_drm_sched_fence(fence);\n\t\t\tfence = dma_fence_get(&s_fence->scheduled);\n\t\t\tdma_fence_put(old);\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_syncobj_lookup_and_add(struct amdgpu_cs_parser *p,\n\t\t\t\t\t uint32_t handle, u64 point,\n\t\t\t\t\t u64 flags)\n{\n\tstruct dma_fence *fence;\n\tint r;\n\n\tr = drm_syncobj_find_fence(p->filp, handle, point, flags, &fence);\n\tif (r) {\n\t\tDRM_ERROR(\"syncobj %u failed to find fence @ %llu (%d)!\\n\",\n\t\t\t  handle, point, r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_sync_fence(&p->sync, fence);\n\tdma_fence_put(fence);\n\treturn r;\n}\n\nstatic int amdgpu_cs_p2_syncobj_in(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, deps[i].handle, 0, 0);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_wait(struct amdgpu_cs_parser *p,\n\t\t\t\t\t      struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, syncobj_deps[i].handle,\n\t\t\t\t\t\t  syncobj_deps[i].point,\n\t\t\t\t\t\t  syncobj_deps[i].flags);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_out(struct amdgpu_cs_parser *p,\n\t\t\t\t    struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tp->post_deps[i].syncobj =\n\t\t\tdrm_syncobj_find(p->filp, deps[i].handle);\n\t\tif (!p->post_deps[i].syncobj)\n\t\t\treturn -EINVAL;\n\t\tp->post_deps[i].chain = NULL;\n\t\tp->post_deps[i].point = 0;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_signal(struct amdgpu_cs_parser *p,\n\t\t\t\t\t\tstruct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_cs_post_dep *dep = &p->post_deps[i];\n\n\t\tdep->chain = NULL;\n\t\tif (syncobj_deps[i].point) {\n\t\t\tdep->chain = dma_fence_chain_alloc();\n\t\t\tif (!dep->chain)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdep->syncobj = drm_syncobj_find(p->filp,\n\t\t\t\t\t\tsyncobj_deps[i].handle);\n\t\tif (!dep->syncobj) {\n\t\t\tdma_fence_chain_free(dep->chain);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdep->point = syncobj_deps[i].point;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_shadow(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_cp_gfx_shadow *shadow = chunk->kdata;\n\tint i;\n\n\tif (shadow->flags & ~AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tp->jobs[i]->shadow_va = shadow->shadow_va;\n\t\tp->jobs[i]->csa_va = shadow->csa_va;\n\t\tp->jobs[i]->gds_va = shadow->gds_va;\n\t\tp->jobs[i]->init_shadow =\n\t\t\tshadow->flags & AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_pass2(struct amdgpu_cs_parser *p)\n{\n\tunsigned int ce_preempt = 0, de_preempt = 0;\n\tint i, r;\n\n\tfor (i = 0; i < p->nchunks; ++i) {\n\t\tstruct amdgpu_cs_chunk *chunk;\n\n\t\tchunk = &p->chunks[i];\n\n\t\tswitch (chunk->chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tr = amdgpu_cs_p2_ib(p, chunk, &ce_preempt, &de_preempt);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\t\tr = amdgpu_cs_p2_dependencies(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\t\tr = amdgpu_cs_p2_syncobj_in(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\t\tr = amdgpu_cs_p2_syncobj_out(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_wait(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_signal(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tr = amdgpu_cs_p2_shadow(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Convert microseconds to bytes. */\nstatic u64 us_to_bytes(struct amdgpu_device *adev, s64 us)\n{\n\tif (us <= 0 || !adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\t/* Since accum_us is incremented by a million per second, just\n\t * multiply it by the number of MB/s to get the number of bytes.\n\t */\n\treturn us << adev->mm_stats.log2_max_MBps;\n}\n\nstatic s64 bytes_to_us(struct amdgpu_device *adev, u64 bytes)\n{\n\tif (!adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\treturn bytes >> adev->mm_stats.log2_max_MBps;\n}\n\n/* Returns how many bytes TTM can move right now. If no bytes can be moved,\n * it returns 0. If it returns non-zero, it's OK to move at least one buffer,\n * which means it can go over the threshold once. If that happens, the driver\n * will be in debt and no other buffer migrations can be done until that debt\n * is repaid.\n *\n * This approach allows moving a buffer of any size (it's important to allow\n * that).\n *\n * The currency is simply time in microseconds and it increases as the clock\n * ticks. The accumulated microseconds (us) are converted to bytes and\n * returned.\n */\nstatic void amdgpu_cs_get_threshold_for_moves(struct amdgpu_device *adev,\n\t\t\t\t\t      u64 *max_bytes,\n\t\t\t\t\t      u64 *max_vis_bytes)\n{\n\ts64 time_us, increment_us;\n\tu64 free_vram, total_vram, used_vram;\n\t/* Allow a maximum of 200 accumulated ms. This is basically per-IB\n\t * throttling.\n\t *\n\t * It means that in order to get full max MBps, at least 5 IBs per\n\t * second must be submitted and not more than 200ms apart from each\n\t * other.\n\t */\n\tconst s64 us_upper_bound = 200000;\n\n\tif (!adev->mm_stats.log2_max_MBps) {\n\t\t*max_bytes = 0;\n\t\t*max_vis_bytes = 0;\n\t\treturn;\n\t}\n\n\ttotal_vram = adev->gmc.real_vram_size - atomic64_read(&adev->vram_pin_size);\n\tused_vram = ttm_resource_manager_usage(&adev->mman.vram_mgr.manager);\n\tfree_vram = used_vram >= total_vram ? 0 : total_vram - used_vram;\n\n\tspin_lock(&adev->mm_stats.lock);\n\n\t/* Increase the amount of accumulated us. */\n\ttime_us = ktime_to_us(ktime_get());\n\tincrement_us = time_us - adev->mm_stats.last_update_us;\n\tadev->mm_stats.last_update_us = time_us;\n\tadev->mm_stats.accum_us = min(adev->mm_stats.accum_us + increment_us,\n\t\t\t\t      us_upper_bound);\n\n\t/* This prevents the short period of low performance when the VRAM\n\t * usage is low and the driver is in debt or doesn't have enough\n\t * accumulated us to fill VRAM quickly.\n\t *\n\t * The situation can occur in these cases:\n\t * - a lot of VRAM is freed by userspace\n\t * - the presence of a big buffer causes a lot of evictions\n\t *   (solution: split buffers into smaller ones)\n\t *\n\t * If 128 MB or 1/8th of VRAM is free, start filling it now by setting\n\t * accum_us to a positive number.\n\t */\n\tif (free_vram >= 128 * 1024 * 1024 || free_vram >= total_vram / 8) {\n\t\ts64 min_us;\n\n\t\t/* Be more aggressive on dGPUs. Try to fill a portion of free\n\t\t * VRAM now.\n\t\t */\n\t\tif (!(adev->flags & AMD_IS_APU))\n\t\t\tmin_us = bytes_to_us(adev, free_vram / 4);\n\t\telse\n\t\t\tmin_us = 0; /* Reset accum_us on APUs. */\n\n\t\tadev->mm_stats.accum_us = max(min_us, adev->mm_stats.accum_us);\n\t}\n\n\t/* This is set to 0 if the driver is in debt to disallow (optional)\n\t * buffer moves.\n\t */\n\t*max_bytes = us_to_bytes(adev, adev->mm_stats.accum_us);\n\n\t/* Do the same for visible VRAM if half of it is free */\n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc)) {\n\t\tu64 total_vis_vram = adev->gmc.visible_vram_size;\n\t\tu64 used_vis_vram =\n\t\t  amdgpu_vram_mgr_vis_usage(&adev->mman.vram_mgr);\n\n\t\tif (used_vis_vram < total_vis_vram) {\n\t\t\tu64 free_vis_vram = total_vis_vram - used_vis_vram;\n\n\t\t\tadev->mm_stats.accum_us_vis = min(adev->mm_stats.accum_us_vis +\n\t\t\t\t\t\t\t  increment_us, us_upper_bound);\n\n\t\t\tif (free_vis_vram >= total_vis_vram / 2)\n\t\t\t\tadev->mm_stats.accum_us_vis =\n\t\t\t\t\tmax(bytes_to_us(adev, free_vis_vram / 2),\n\t\t\t\t\t    adev->mm_stats.accum_us_vis);\n\t\t}\n\n\t\t*max_vis_bytes = us_to_bytes(adev, adev->mm_stats.accum_us_vis);\n\t} else {\n\t\t*max_vis_bytes = 0;\n\t}\n\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\n/* Report how many bytes have really been moved for the last command\n * submission. This can result in a debt that can stop buffer migrations\n * temporarily.\n */\nvoid amdgpu_cs_report_moved_bytes(struct amdgpu_device *adev, u64 num_bytes,\n\t\t\t\t  u64 num_vis_bytes)\n{\n\tspin_lock(&adev->mm_stats.lock);\n\tadev->mm_stats.accum_us -= bytes_to_us(adev, num_bytes);\n\tadev->mm_stats.accum_us_vis -= bytes_to_us(adev, num_vis_bytes);\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\nstatic int amdgpu_cs_bo_validate(void *param, struct amdgpu_bo *bo)\n{\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct amdgpu_cs_parser *p = param;\n\tstruct ttm_operation_ctx ctx = {\n\t\t.interruptible = true,\n\t\t.no_wait_gpu = false,\n\t\t.resv = bo->tbo.base.resv\n\t};\n\tuint32_t domain;\n\tint r;\n\n\tif (bo->tbo.pin_count)\n\t\treturn 0;\n\n\t/* Don't move this buffer if we have depleted our allowance\n\t * to move it. Don't move anything if the threshold is zero.\n\t */\n\tif (p->bytes_moved < p->bytes_moved_threshold &&\n\t    (!bo->tbo.base.dma_buf ||\n\t    list_empty(&bo->tbo.base.dma_buf->attachments))) {\n\t\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t\t    (bo->flags & AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)) {\n\t\t\t/* And don't move a CPU_ACCESS_REQUIRED BO to limited\n\t\t\t * visible VRAM if we've depleted our allowance to do\n\t\t\t * that.\n\t\t\t */\n\t\t\tif (p->bytes_moved_vis < p->bytes_moved_vis_threshold)\n\t\t\t\tdomain = bo->preferred_domains;\n\t\t\telse\n\t\t\t\tdomain = bo->allowed_domains;\n\t\t} else {\n\t\t\tdomain = bo->preferred_domains;\n\t\t}\n\t} else {\n\t\tdomain = bo->allowed_domains;\n\t}\n\nretry:\n\tamdgpu_bo_placement_from_domain(bo, domain);\n\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\n\tp->bytes_moved += ctx.bytes_moved;\n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t    amdgpu_bo_in_cpu_visible_vram(bo))\n\t\tp->bytes_moved_vis += ctx.bytes_moved;\n\n\tif (unlikely(r == -ENOMEM) && domain != bo->allowed_domains) {\n\t\tdomain = bo->allowed_domains;\n\t\tgoto retry;\n\t}\n\n\treturn r;\n}\n\nstatic int amdgpu_cs_list_validate(struct amdgpu_cs_parser *p,\n\t\t\t    struct list_head *validated)\n{\n\tstruct ttm_operation_ctx ctx = { true, false };\n\tstruct amdgpu_bo_list_entry *lobj;\n\tint r;\n\n\tlist_for_each_entry(lobj, validated, tv.head) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(lobj->tv.bo);\n\t\tstruct mm_struct *usermm;\n\n\t\tusermm = amdgpu_ttm_tt_get_usermm(bo->tbo.ttm);\n\t\tif (usermm && usermm != current->mm)\n\t\t\treturn -EPERM;\n\n\t\tif (amdgpu_ttm_tt_is_userptr(bo->tbo.ttm) &&\n\t\t    lobj->user_invalidated && lobj->user_pages) {\n\t\t\tamdgpu_bo_placement_from_domain(bo,\n\t\t\t\t\t\t\tAMDGPU_GEM_DOMAIN_CPU);\n\t\t\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\n\t\t\tamdgpu_ttm_tt_set_user_pages(bo->tbo.ttm,\n\t\t\t\t\t\t     lobj->user_pages);\n\t\t}\n\n\t\tr = amdgpu_cs_bo_validate(p, bo);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tkvfree(lobj->user_pages);\n\t\tlobj->user_pages = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_cs_parser_bos(struct amdgpu_cs_parser *p,\n\t\t\t\tunion drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct list_head duplicates;\n\tunsigned int i;\n\tint r;\n\n\tINIT_LIST_HEAD(&p->validated);\n\n\t/* p->bo_list could already be assigned if AMDGPU_CHUNK_ID_BO_HANDLES is present */\n\tif (cs->in.bo_list_handle) {\n\t\tif (p->bo_list)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_bo_list_get(fpriv, cs->in.bo_list_handle,\n\t\t\t\t       &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t} else if (!p->bo_list) {\n\t\t/* Create a empty bo_list when no handle is provided */\n\t\tr = amdgpu_bo_list_create(p->adev, p->filp, NULL, 0,\n\t\t\t\t\t  &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tmutex_lock(&p->bo_list->bo_list_mutex);\n\n\t/* One for TTM and one for each CS job */\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list)\n\t\te->tv.num_shared = 1 + p->gang_size;\n\tp->uf_entry.tv.num_shared = 1 + p->gang_size;\n\n\tamdgpu_bo_list_get_list(p->bo_list, &p->validated);\n\n\tINIT_LIST_HEAD(&duplicates);\n\tamdgpu_vm_get_pd_bo(&fpriv->vm, &p->validated, &p->vm_pd);\n\n\t/* Two for VM updates, one for TTM and one for each CS job */\n\tp->vm_pd.tv.num_shared = 3 + p->gang_size;\n\n\tif (p->uf_entry.tv.bo && !ttm_to_amdgpu_bo(p->uf_entry.tv.bo)->parent)\n\t\tlist_add(&p->uf_entry.tv.head, &p->validated);\n\n\t/* Get userptr backing pages. If pages are updated after registered\n\t * in amdgpu_gem_userptr_ioctl(), amdgpu_cs_list_validate() will do\n\t * amdgpu_ttm_backend_bind() to flush and invalidate new pages\n\t */\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tbool userpage_invalidated = false;\n\t\tint i;\n\n\t\te->user_pages = kvmalloc_array(bo->tbo.ttm->num_pages,\n\t\t\t\t\tsizeof(struct page *),\n\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (!e->user_pages) {\n\t\t\tDRM_ERROR(\"kvmalloc_array failure\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tr = amdgpu_ttm_tt_get_user_pages(bo, e->user_pages, &e->range);\n\t\tif (r) {\n\t\t\tkvfree(e->user_pages);\n\t\t\te->user_pages = NULL;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tfor (i = 0; i < bo->tbo.ttm->num_pages; i++) {\n\t\t\tif (bo->tbo.ttm->pages[i] != e->user_pages[i]) {\n\t\t\t\tuserpage_invalidated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\te->user_invalidated = userpage_invalidated;\n\t}\n\n\tr = ttm_eu_reserve_buffers(&p->ticket, &p->validated, true,\n\t\t\t\t   &duplicates);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"ttm_eu_reserve_buffers failed.\\n\");\n\t\tgoto out_free_user_pages;\n\t}\n\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\te->bo_va = amdgpu_vm_bo_find(vm, bo);\n\t}\n\n\tamdgpu_cs_get_threshold_for_moves(p->adev, &p->bytes_moved_threshold,\n\t\t\t\t\t  &p->bytes_moved_vis_threshold);\n\tp->bytes_moved = 0;\n\tp->bytes_moved_vis = 0;\n\n\tr = amdgpu_vm_validate_pt_bos(p->adev, &fpriv->vm,\n\t\t\t\t      amdgpu_cs_bo_validate, p);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_vm_validate_pt_bos() failed.\\n\");\n\t\tgoto error_validate;\n\t}\n\n\tr = amdgpu_cs_list_validate(p, &duplicates);\n\tif (r)\n\t\tgoto error_validate;\n\n\tr = amdgpu_cs_list_validate(p, &p->validated);\n\tif (r)\n\t\tgoto error_validate;\n\n\tif (p->uf_entry.tv.bo) {\n\t\tstruct amdgpu_bo *uf = ttm_to_amdgpu_bo(p->uf_entry.tv.bo);\n\n\t\tr = amdgpu_ttm_alloc_gart(&uf->tbo);\n\t\tif (r)\n\t\t\tgoto error_validate;\n\n\t\tp->gang_leader->uf_addr += amdgpu_bo_gpu_offset(uf);\n\t}\n\n\tamdgpu_cs_report_moved_bytes(p->adev, p->bytes_moved,\n\t\t\t\t     p->bytes_moved_vis);\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tamdgpu_job_set_resources(p->jobs[i], p->bo_list->gds_obj,\n\t\t\t\t\t p->bo_list->gws_obj,\n\t\t\t\t\t p->bo_list->oa_obj);\n\treturn 0;\n\nerror_validate:\n\tttm_eu_backoff_reservation(&p->ticket, &p->validated);\n\nout_free_user_pages:\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\tif (!e->user_pages)\n\t\t\tcontinue;\n\t\tamdgpu_ttm_tt_get_user_pages_done(bo->tbo.ttm, e->range);\n\t\tkvfree(e->user_pages);\n\t\te->user_pages = NULL;\n\t\te->range = NULL;\n\t}\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn r;\n}\n\nstatic void trace_amdgpu_cs_ibs(struct amdgpu_cs_parser *p)\n{\n\tint i, j;\n\n\tif (!trace_amdgpu_cs_enabled())\n\t\treturn;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct amdgpu_job *job = p->jobs[i];\n\n\t\tfor (j = 0; j < job->num_ibs; ++j)\n\t\t\ttrace_amdgpu_cs(p, job, &job->ibs[j]);\n\t}\n}\n\nstatic int amdgpu_cs_patch_ibs(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_job *job)\n{\n\tstruct amdgpu_ring *ring = amdgpu_job_ring(job);\n\tunsigned int i;\n\tint r;\n\n\t/* Only for UVD/VCE VM emulation */\n\tif (!ring->funcs->parse_cs && !ring->funcs->patch_cs_in_place)\n\t\treturn 0;\n\n\tfor (i = 0; i < job->num_ibs; ++i) {\n\t\tstruct amdgpu_ib *ib = &job->ibs[i];\n\t\tstruct amdgpu_bo_va_mapping *m;\n\t\tstruct amdgpu_bo *aobj;\n\t\tuint64_t va_start;\n\t\tuint8_t *kptr;\n\n\t\tva_start = ib->gpu_addr & AMDGPU_GMC_HOLE_MASK;\n\t\tr = amdgpu_cs_find_mapping(p, va_start, &aobj, &m);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"IB va_start is invalid\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif ((va_start + ib->length_dw * 4) >\n\t\t    (m->last + 1) * AMDGPU_GPU_PAGE_SIZE) {\n\t\t\tDRM_ERROR(\"IB va_start+ib_bytes is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* the IB should be reserved at this point */\n\t\tr = amdgpu_bo_kmap(aobj, (void **)&kptr);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tkptr += va_start - (m->start * AMDGPU_GPU_PAGE_SIZE);\n\n\t\tif (ring->funcs->parse_cs) {\n\t\t\tmemcpy(ib->ptr, kptr, ib->length_dw * 4);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\n\t\t\tr = amdgpu_ring_parse_cs(ring, p, job, ib);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\tib->ptr = (uint32_t *)kptr;\n\t\t\tr = amdgpu_ring_patch_cs_in_place(ring, p, job, ib);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_patch_jobs(struct amdgpu_cs_parser *p)\n{\n\tunsigned int i;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_cs_patch_ibs(p, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_cs_vm_handling(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *job = p->gang_leader;\n\tstruct amdgpu_device *adev = p->adev;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct amdgpu_bo_va *bo_va;\n\tstruct amdgpu_bo *bo;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_vm_clear_freed(adev, vm, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_bo_update(adev, fpriv->prt_va, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, fpriv->prt_va->last_pt_update);\n\tif (r)\n\t\treturn r;\n\n\tif (fpriv->csa_va) {\n\t\tbo_va = fpriv->csa_va;\n\t\tBUG_ON(!bo_va);\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t/* ignore duplicates */\n\t\tbo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tif (!bo)\n\t\t\tcontinue;\n\n\t\tbo_va = e->bo_va;\n\t\tif (bo_va == NULL)\n\t\t\tcontinue;\n\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_vm_handle_moved(adev, vm);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_update_pdes(adev, vm, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, vm->last_update);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tjob = p->jobs[i];\n\n\t\tif (!job->vm)\n\t\t\tcontinue;\n\n\t\tjob->vm_pd_addr = amdgpu_gmc_pd_addr(vm->root.bo);\n\t}\n\n\tif (amdgpu_vm_debug) {\n\t\t/* Invalidate all BOs to test for userspace bugs */\n\t\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\t\t/* ignore duplicates */\n\t\t\tif (!bo)\n\t\t\t\tcontinue;\n\n\t\t\tamdgpu_vm_bo_invalidate(adev, bo, false);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_sync_rings(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct drm_gpu_scheduler *sched;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct dma_fence *fence;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_wait_prev_fence(p->ctx, p->entities[p->gang_leader_idx]);\n\tif (r) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"amdgpu_ctx_wait_prev_fence failed.\\n\");\n\t\treturn r;\n\t}\n\n\tlist_for_each_entry(e, &p->validated, tv.head) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tstruct dma_resv *resv = bo->tbo.base.resv;\n\t\tenum amdgpu_sync_mode sync_mode;\n\n\t\tsync_mode = amdgpu_bo_explicit_sync(bo) ?\n\t\t\tAMDGPU_SYNC_EXPLICIT : AMDGPU_SYNC_NE_OWNER;\n\t\tr = amdgpu_sync_resv(p->adev, &p->sync, resv, sync_mode,\n\t\t\t\t     &fpriv->vm);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_sync_push_to_job(&p->sync, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tsched = p->gang_leader->base.entity->rq->sched;\n\twhile ((fence = amdgpu_sync_get_fence(&p->sync))) {\n\t\tstruct drm_sched_fence *s_fence = to_drm_sched_fence(fence);\n\n\t\t/*\n\t\t * When we have an dependency it might be necessary to insert a\n\t\t * pipeline sync to make sure that all caches etc are flushed and the\n\t\t * next job actually sees the results from the previous one\n\t\t * before we start executing on the same scheduler ring.\n\t\t */\n\t\tif (!s_fence || s_fence->sched != sched) {\n\t\t\tdma_fence_put(fence);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->gang_leader->explicit_sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void amdgpu_cs_post_dependencies(struct amdgpu_cs_parser *p)\n{\n\tint i;\n\n\tfor (i = 0; i < p->num_post_deps; ++i) {\n\t\tif (p->post_deps[i].chain && p->post_deps[i].point) {\n\t\t\tdrm_syncobj_add_point(p->post_deps[i].syncobj,\n\t\t\t\t\t      p->post_deps[i].chain,\n\t\t\t\t\t      p->fence, p->post_deps[i].point);\n\t\t\tp->post_deps[i].chain = NULL;\n\t\t} else {\n\t\t\tdrm_syncobj_replace_fence(p->post_deps[i].syncobj,\n\t\t\t\t\t\t  p->fence);\n\t\t}\n\t}\n}\n\nstatic int amdgpu_cs_submit(struct amdgpu_cs_parser *p,\n\t\t\t    union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *leader = p->gang_leader;\n\tstruct amdgpu_bo_list_entry *e;\n\tunsigned int i;\n\tuint64_t seq;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tdrm_sched_job_arm(&p->jobs[i]->base);\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tif (p->jobs[i] == leader)\n\t\t\tcontinue;\n\n\t\tfence = &p->jobs[i]->base.s_fence->scheduled;\n\t\tdma_fence_get(fence);\n\t\tr = drm_sched_job_add_dependency(&leader->base, fence);\n\t\tif (r) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (p->gang_size > 1) {\n\t\tfor (i = 0; i < p->gang_size; ++i)\n\t\t\tamdgpu_job_set_gang_leader(p->jobs[i], leader);\n\t}\n\n\t/* No memory allocation is allowed while holding the notifier lock.\n\t * The lock is held until amdgpu_cs_submit is finished and fence is\n\t * added to BOs.\n\t */\n\tmutex_lock(&p->adev->notifier_lock);\n\n\t/* If userptr are invalidated after amdgpu_cs_parser_bos(), return\n\t * -EAGAIN, drmIoctl in libdrm will restart the amdgpu_cs_ioctl.\n\t */\n\tr = 0;\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\tr |= !amdgpu_ttm_tt_get_user_pages_done(bo->tbo.ttm, e->range);\n\t\te->range = NULL;\n\t}\n\tif (r) {\n\t\tr = -EAGAIN;\n\t\tmutex_unlock(&p->adev->notifier_lock);\n\t\treturn r;\n\t}\n\n\tp->fence = dma_fence_get(&leader->base.s_fence->finished);\n\tlist_for_each_entry(e, &p->validated, tv.head) {\n\n\t\t/* Everybody except for the gang leader uses READ */\n\t\tfor (i = 0; i < p->gang_size; ++i) {\n\t\t\tif (p->jobs[i] == leader)\n\t\t\t\tcontinue;\n\n\t\t\tdma_resv_add_fence(e->tv.bo->base.resv,\n\t\t\t\t\t   &p->jobs[i]->base.s_fence->finished,\n\t\t\t\t\t   DMA_RESV_USAGE_READ);\n\t\t}\n\n\t\t/* The gang leader is remembered as writer */\n\t\te->tv.num_shared = 0;\n\t}\n\n\tseq = amdgpu_ctx_add_fence(p->ctx, p->entities[p->gang_leader_idx],\n\t\t\t\t   p->fence);\n\tamdgpu_cs_post_dependencies(p);\n\n\tif ((leader->preamble_status & AMDGPU_PREAMBLE_IB_PRESENT) &&\n\t    !p->ctx->preamble_presented) {\n\t\tleader->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT_FIRST;\n\t\tp->ctx->preamble_presented = true;\n\t}\n\n\tcs->out.handle = seq;\n\tleader->uf_sequence = seq;\n\n\tamdgpu_vm_bo_trace_cs(&fpriv->vm, &p->ticket);\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tamdgpu_job_free_resources(p->jobs[i]);\n\t\ttrace_amdgpu_cs_ioctl(p->jobs[i]);\n\t\tdrm_sched_entity_push_job(&p->jobs[i]->base);\n\t\tp->jobs[i] = NULL;\n\t}\n\n\tamdgpu_vm_move_to_lru_tail(p->adev, &fpriv->vm);\n\tttm_eu_fence_buffer_objects(&p->ticket, &p->validated, p->fence);\n\n\tmutex_unlock(&p->adev->notifier_lock);\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn 0;\n}\n\n/* Cleanup the parser structure */\nstatic void amdgpu_cs_parser_fini(struct amdgpu_cs_parser *parser)\n{\n\tunsigned int i;\n\n\tamdgpu_sync_free(&parser->sync);\n\tfor (i = 0; i < parser->num_post_deps; i++) {\n\t\tdrm_syncobj_put(parser->post_deps[i].syncobj);\n\t\tkfree(parser->post_deps[i].chain);\n\t}\n\tkfree(parser->post_deps);\n\n\tdma_fence_put(parser->fence);\n\n\tif (parser->ctx)\n\t\tamdgpu_ctx_put(parser->ctx);\n\tif (parser->bo_list)\n\t\tamdgpu_bo_list_put(parser->bo_list);\n\n\tfor (i = 0; i < parser->nchunks; i++)\n\t\tkvfree(parser->chunks[i].kdata);\n\tkvfree(parser->chunks);\n\tfor (i = 0; i < parser->gang_size; ++i) {\n\t\tif (parser->jobs[i])\n\t\t\tamdgpu_job_free(parser->jobs[i]);\n\t}\n\tif (parser->uf_entry.tv.bo) {\n\t\tstruct amdgpu_bo *uf = ttm_to_amdgpu_bo(parser->uf_entry.tv.bo);\n\n\t\tamdgpu_bo_unref(&uf);\n\t}\n}\n\nint amdgpu_cs_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_cs_parser parser;\n\tint r;\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn -EHWPOISON;\n\n\tif (!adev->accel_working)\n\t\treturn -EBUSY;\n\n\tr = amdgpu_cs_parser_init(&parser, adev, filp, data);\n\tif (r) {\n\t\tif (printk_ratelimit())\n\t\t\tDRM_ERROR(\"Failed to initialize parser %d!\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_cs_pass1(&parser, data);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_pass2(&parser);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_parser_bos(&parser, data);\n\tif (r) {\n\t\tif (r == -ENOMEM)\n\t\t\tDRM_ERROR(\"Not enough memory for command submission!\\n\");\n\t\telse if (r != -ERESTARTSYS && r != -EAGAIN)\n\t\t\tDRM_ERROR(\"Failed to process the buffer list %d!\\n\", r);\n\t\tgoto error_fini;\n\t}\n\n\tr = amdgpu_cs_patch_jobs(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_vm_handling(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_sync_rings(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\ttrace_amdgpu_cs_ibs(&parser);\n\n\tr = amdgpu_cs_submit(&parser, data);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tamdgpu_cs_parser_fini(&parser);\n\treturn 0;\n\nerror_backoff:\n\tttm_eu_backoff_reservation(&parser.ticket, &parser.validated);\n\tmutex_unlock(&parser.bo_list->bo_list_mutex);\n\nerror_fini:\n\tamdgpu_cs_parser_fini(&parser);\n\treturn r;\n}\n\n/**\n * amdgpu_cs_wait_ioctl - wait for a command submission to finish\n *\n * @dev: drm device\n * @data: data from userspace\n * @filp: file private\n *\n * Wait for the command submission identified by handle to finish.\n */\nint amdgpu_cs_wait_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *filp)\n{\n\tunion drm_amdgpu_wait_cs *wait = data;\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout);\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tlong r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, wait->in.ctx_id);\n\tif (ctx == NULL)\n\t\treturn -EINVAL;\n\n\tr = amdgpu_ctx_get_entity(ctx, wait->in.ip_type, wait->in.ip_instance,\n\t\t\t\t  wait->in.ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn r;\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, wait->in.handle);\n\tif (IS_ERR(fence))\n\t\tr = PTR_ERR(fence);\n\telse if (fence) {\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tif (r > 0 && fence->error)\n\t\t\tr = fence->error;\n\t\tdma_fence_put(fence);\n\t} else\n\t\tr = 1;\n\n\tamdgpu_ctx_put(ctx);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r == 0);\n\n\treturn 0;\n}\n\n/**\n * amdgpu_cs_get_fence - helper to get fence from drm_amdgpu_fence\n *\n * @adev: amdgpu device\n * @filp: file private\n * @user: drm_amdgpu_fence copied from user space\n */\nstatic struct dma_fence *amdgpu_cs_get_fence(struct amdgpu_device *adev,\n\t\t\t\t\t     struct drm_file *filp,\n\t\t\t\t\t     struct drm_amdgpu_fence *user)\n{\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tint r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, user->ctx_id);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tr = amdgpu_ctx_get_entity(ctx, user->ip_type, user->ip_instance,\n\t\t\t\t  user->ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, user->seq_no);\n\tamdgpu_ctx_put(ctx);\n\n\treturn fence;\n}\n\nint amdgpu_cs_fence_to_handle_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_fence_to_handle *info = data;\n\tstruct dma_fence *fence;\n\tstruct drm_syncobj *syncobj;\n\tstruct sync_file *sync_file;\n\tint fd, r;\n\n\tfence = amdgpu_cs_get_fence(adev, filp, &info->in.fence);\n\tif (IS_ERR(fence))\n\t\treturn PTR_ERR(fence);\n\n\tif (!fence)\n\t\tfence = dma_fence_get_stub();\n\n\tswitch (info->in.what) {\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_handle(filp, syncobj, &info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ_FD:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_fd(syncobj, (int *)&info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNC_FILE_FD:\n\t\tfd = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (fd < 0) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn fd;\n\t\t}\n\n\t\tsync_file = sync_file_create(fence);\n\t\tdma_fence_put(fence);\n\t\tif (!sync_file) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfd_install(fd, sync_file->file);\n\t\tinfo->out.handle = fd;\n\t\treturn 0;\n\n\tdefault:\n\t\tdma_fence_put(fence);\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * amdgpu_cs_wait_all_fences - wait on all fences to signal\n *\n * @adev: amdgpu device\n * @filp: file private\n * @wait: wait parameters\n * @fences: array of drm_amdgpu_fence\n */\nstatic int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (r == 0)\n\t\t\tbreak;\n\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\n\treturn 0;\n}\n\n/**\n * amdgpu_cs_wait_any_fence - wait on any fence to signal\n *\n * @adev: amdgpu device\n * @filp: file private\n * @wait: wait parameters\n * @fences: array of drm_amdgpu_fence\n */\nstatic int amdgpu_cs_wait_any_fence(struct amdgpu_device *adev,\n\t\t\t\t    struct drm_file *filp,\n\t\t\t\t    union drm_amdgpu_wait_fences *wait,\n\t\t\t\t    struct drm_amdgpu_fence *fences)\n{\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\tuint32_t fence_count = wait->in.fence_count;\n\tuint32_t first = ~0;\n\tstruct dma_fence **array;\n\tunsigned int i;\n\tlong r;\n\n\t/* Prepare the fence array */\n\tarray = kcalloc(fence_count, sizeof(struct dma_fence *), GFP_KERNEL);\n\n\tif (array == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence)) {\n\t\t\tr = PTR_ERR(fence);\n\t\t\tgoto err_free_fence_array;\n\t\t} else if (fence) {\n\t\t\tarray[i] = fence;\n\t\t} else { /* NULL, the fence has been already signaled */\n\t\t\tr = 1;\n\t\t\tfirst = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = dma_fence_wait_any_timeout(array, fence_count, true, timeout,\n\t\t\t\t       &first);\n\tif (r < 0)\n\t\tgoto err_free_fence_array;\n\nout:\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\twait->out.first_signaled = first;\n\n\tif (first < fence_count && array[first])\n\t\tr = array[first]->error;\n\telse\n\t\tr = 0;\n\nerr_free_fence_array:\n\tfor (i = 0; i < fence_count; i++)\n\t\tdma_fence_put(array[i]);\n\tkfree(array);\n\n\treturn r;\n}\n\n/**\n * amdgpu_cs_wait_fences_ioctl - wait for multiple command submissions to finish\n *\n * @dev: drm device\n * @data: data from userspace\n * @filp: file private\n */\nint amdgpu_cs_wait_fences_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_wait_fences *wait = data;\n\tuint32_t fence_count = wait->in.fence_count;\n\tstruct drm_amdgpu_fence *fences_user;\n\tstruct drm_amdgpu_fence *fences;\n\tint r;\n\n\t/* Get the fences from userspace */\n\tfences = kmalloc_array(fence_count, sizeof(struct drm_amdgpu_fence),\n\t\t\tGFP_KERNEL);\n\tif (fences == NULL)\n\t\treturn -ENOMEM;\n\n\tfences_user = u64_to_user_ptr(wait->in.fences);\n\tif (copy_from_user(fences, fences_user,\n\t\tsizeof(struct drm_amdgpu_fence) * fence_count)) {\n\t\tr = -EFAULT;\n\t\tgoto err_free_fences;\n\t}\n\n\tif (wait->in.wait_all)\n\t\tr = amdgpu_cs_wait_all_fences(adev, filp, wait, fences);\n\telse\n\t\tr = amdgpu_cs_wait_any_fence(adev, filp, wait, fences);\n\nerr_free_fences:\n\tkfree(fences);\n\n\treturn r;\n}\n\n/**\n * amdgpu_cs_find_mapping - find bo_va for VM address\n *\n * @parser: command submission parser context\n * @addr: VM address\n * @bo: resulting BO of the mapping found\n * @map: Placeholder to return found BO mapping\n *\n * Search the buffer objects in the command submission context for a certain\n * virtual memory address. Returns allocation structure when found, NULL\n * otherwise.\n */\nint amdgpu_cs_find_mapping(struct amdgpu_cs_parser *parser,\n\t\t\t   uint64_t addr, struct amdgpu_bo **bo,\n\t\t\t   struct amdgpu_bo_va_mapping **map)\n{\n\tstruct amdgpu_fpriv *fpriv = parser->filp->driver_priv;\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_va_mapping *mapping;\n\tint r;\n\n\taddr /= AMDGPU_GPU_PAGE_SIZE;\n\n\tmapping = amdgpu_vm_bo_lookup_mapping(vm, addr);\n\tif (!mapping || !mapping->bo_va || !mapping->bo_va->base.bo)\n\t\treturn -EINVAL;\n\n\t*bo = mapping->bo_va->base.bo;\n\t*map = mapping;\n\n\t/* Double check that the BO is reserved by this CS */\n\tif (dma_resv_locking_ctx((*bo)->tbo.base.resv) != &parser->ticket)\n\t\treturn -EINVAL;\n\n\tif (!((*bo)->flags & AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS)) {\n\t\t(*bo)->flags |= AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS;\n\t\tamdgpu_bo_placement_from_domain(*bo, (*bo)->allowed_domains);\n\t\tr = ttm_bo_validate(&(*bo)->tbo, &(*bo)->placement, &ctx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn amdgpu_ttm_alloc_gart(&(*bo)->tbo);\n}\n"], "fixing_code": ["/*\n * Copyright 2008 Jerome Glisse.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *    Jerome Glisse <glisse@freedesktop.org>\n */\n\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/sync_file.h>\n#include <linux/dma-buf.h>\n\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_syncobj.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"amdgpu_cs.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_trace.h\"\n#include \"amdgpu_gmc.h\"\n#include \"amdgpu_gem.h\"\n#include \"amdgpu_ras.h\"\n\nstatic int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p,\n\t\t\t\t struct amdgpu_device *adev,\n\t\t\t\t struct drm_file *filp,\n\t\t\t\t union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = filp->driver_priv;\n\n\tif (cs->in.num_chunks == 0)\n\t\treturn -EINVAL;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->adev = adev;\n\tp->filp = filp;\n\n\tp->ctx = amdgpu_ctx_get(fpriv, cs->in.ctx_id);\n\tif (!p->ctx)\n\t\treturn -EINVAL;\n\n\tif (atomic_read(&p->ctx->guilty)) {\n\t\tamdgpu_ctx_put(p->ctx);\n\t\treturn -ECANCELED;\n\t}\n\n\tamdgpu_sync_create(&p->sync);\n\treturn 0;\n}\n\nstatic int amdgpu_cs_job_idx(struct amdgpu_cs_parser *p,\n\t\t\t     struct drm_amdgpu_cs_chunk_ib *chunk_ib)\n{\n\tstruct drm_sched_entity *entity;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_get_entity(p->ctx, chunk_ib->ip_type,\n\t\t\t\t  chunk_ib->ip_instance,\n\t\t\t\t  chunk_ib->ring, &entity);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Abort if there is no run queue associated with this entity.\n\t * Possibly because of disabled HW IP.\n\t */\n\tif (entity->rq == NULL)\n\t\treturn -EINVAL;\n\n\t/* Check if we can add this IB to some existing job */\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tif (p->entities[i] == entity)\n\t\t\treturn i;\n\n\t/* If not increase the gang size if possible */\n\tif (i == AMDGPU_CS_GANG_SIZE)\n\t\treturn -EINVAL;\n\n\tp->entities[i] = entity;\n\tp->gang_size = i + 1;\n\treturn i;\n}\n\nstatic int amdgpu_cs_p1_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct drm_amdgpu_cs_chunk_ib *chunk_ib,\n\t\t\t   unsigned int *num_ibs)\n{\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (num_ibs[r] >= amdgpu_ring_max_ibs(chunk_ib->ip_type))\n\t\treturn -EINVAL;\n\n\t++(num_ibs[r]);\n\tp->gang_leader_idx = r;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p1_user_fence(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_cs_chunk_fence *data,\n\t\t\t\t   uint32_t *offset)\n{\n\tstruct drm_gem_object *gobj;\n\tstruct amdgpu_bo *bo;\n\tunsigned long size;\n\tint r;\n\n\tgobj = drm_gem_object_lookup(p->filp, data->handle);\n\tif (gobj == NULL)\n\t\treturn -EINVAL;\n\n\tbo = amdgpu_bo_ref(gem_to_amdgpu_bo(gobj));\n\tp->uf_entry.priority = 0;\n\tp->uf_entry.tv.bo = &bo->tbo;\n\tdrm_gem_object_put(gobj);\n\n\tsize = amdgpu_bo_size(bo);\n\tif (size != PAGE_SIZE || (data->offset + 8) > size) {\n\t\tr = -EINVAL;\n\t\tgoto error_unref;\n\t}\n\n\tif (amdgpu_ttm_tt_get_usermm(bo->tbo.ttm)) {\n\t\tr = -EINVAL;\n\t\tgoto error_unref;\n\t}\n\n\t*offset = data->offset;\n\n\treturn 0;\n\nerror_unref:\n\tamdgpu_bo_unref(&bo);\n\treturn r;\n}\n\nstatic int amdgpu_cs_p1_bo_handles(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_bo_list_in *data)\n{\n\tstruct drm_amdgpu_bo_list_entry *info;\n\tint r;\n\n\tr = amdgpu_bo_create_list_entry_array(data, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_bo_list_create(p->adev, p->filp, info, data->bo_number,\n\t\t\t\t  &p->bo_list);\n\tif (r)\n\t\tgoto error_free;\n\n\tkvfree(info);\n\treturn 0;\n\nerror_free:\n\tkvfree(info);\n\n\treturn r;\n}\n\n/* Copy the data from userspace and go over it the first time */\nstatic int amdgpu_cs_pass1(struct amdgpu_cs_parser *p,\n\t\t\t   union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_ibs[AMDGPU_CS_GANG_SIZE] = { };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tuint64_t *chunk_array_user;\n\tuint64_t *chunk_array;\n\tuint32_t uf_offset = 0;\n\tsize_t size;\n\tint ret;\n\tint i;\n\n\tchunk_array = kvmalloc_array(cs->in.num_chunks, sizeof(uint64_t),\n\t\t\t\t     GFP_KERNEL);\n\tif (!chunk_array)\n\t\treturn -ENOMEM;\n\n\t/* get chunks */\n\tchunk_array_user = u64_to_user_ptr(cs->in.chunks);\n\tif (copy_from_user(chunk_array, chunk_array_user,\n\t\t\t   sizeof(uint64_t)*cs->in.num_chunks)) {\n\t\tret = -EFAULT;\n\t\tgoto free_chunk;\n\t}\n\n\tp->nchunks = cs->in.num_chunks;\n\tp->chunks = kvmalloc_array(p->nchunks, sizeof(struct amdgpu_cs_chunk),\n\t\t\t    GFP_KERNEL);\n\tif (!p->chunks) {\n\t\tret = -ENOMEM;\n\t\tgoto free_chunk;\n\t}\n\n\tfor (i = 0; i < p->nchunks; i++) {\n\t\tstruct drm_amdgpu_cs_chunk __user **chunk_ptr = NULL;\n\t\tstruct drm_amdgpu_cs_chunk user_chunk;\n\t\tuint32_t __user *cdata;\n\n\t\tchunk_ptr = u64_to_user_ptr(chunk_array[i]);\n\t\tif (copy_from_user(&user_chunk, chunk_ptr,\n\t\t\t\t       sizeof(struct drm_amdgpu_cs_chunk))) {\n\t\t\tret = -EFAULT;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tp->chunks[i].chunk_id = user_chunk.chunk_id;\n\t\tp->chunks[i].length_dw = user_chunk.length_dw;\n\n\t\tsize = p->chunks[i].length_dw;\n\t\tcdata = u64_to_user_ptr(user_chunk.chunk_data);\n\n\t\tp->chunks[i].kdata = kvmalloc_array(size, sizeof(uint32_t),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (p->chunks[i].kdata == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tsize *= sizeof(uint32_t);\n\t\tif (copy_from_user(p->chunks[i].kdata, cdata, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\n\t\t/* Assume the worst on the following checks */\n\t\tret = -EINVAL;\n\t\tswitch (p->chunks[i].chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_ib))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_ib(p, p->chunks[i].kdata, num_ibs);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_FENCE:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_fence))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_user_fence(p, p->chunks[i].kdata,\n\t\t\t\t\t\t      &uf_offset);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_BO_HANDLES:\n\t\t\tif (size < sizeof(struct drm_amdgpu_bo_list_in))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_bo_handles(p, p->chunks[i].kdata);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t}\n\n\tif (!p->gang_size) {\n\t\tret = -EINVAL;\n\t\tgoto free_partial_kdata;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tret = amdgpu_job_alloc(p->adev, vm, p->entities[i], vm,\n\t\t\t\t       num_ibs[i], &p->jobs[i]);\n\t\tif (ret)\n\t\t\tgoto free_all_kdata;\n\t}\n\tp->gang_leader = p->jobs[p->gang_leader_idx];\n\n\tif (p->ctx->generation != p->gang_leader->generation) {\n\t\tret = -ECANCELED;\n\t\tgoto free_all_kdata;\n\t}\n\n\tif (p->uf_entry.tv.bo)\n\t\tp->gang_leader->uf_addr = uf_offset;\n\tkvfree(chunk_array);\n\n\t/* Use this opportunity to fill in task info for the vm */\n\tamdgpu_vm_set_task_info(vm);\n\n\treturn 0;\n\nfree_all_kdata:\n\ti = p->nchunks - 1;\nfree_partial_kdata:\n\tfor (; i >= 0; i--)\n\t\tkvfree(p->chunks[i].kdata);\n\tkvfree(p->chunks);\n\tp->chunks = NULL;\n\tp->nchunks = 0;\nfree_chunk:\n\tkvfree(chunk_array);\n\n\treturn ret;\n}\n\nstatic int amdgpu_cs_p2_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct amdgpu_cs_chunk *chunk,\n\t\t\t   unsigned int *ce_preempt,\n\t\t\t   unsigned int *de_preempt)\n{\n\tstruct drm_amdgpu_cs_chunk_ib *chunk_ib = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tjob = p->jobs[r];\n\tring = amdgpu_job_ring(job);\n\tib = &job->ibs[job->num_ibs++];\n\n\t/* MM engine doesn't support user fences */\n\tif (p->uf_entry.tv.bo && ring->funcs->no_user_fence)\n\t\treturn -EINVAL;\n\n\tif (chunk_ib->ip_type == AMDGPU_HW_IP_GFX &&\n\t    chunk_ib->flags & AMDGPU_IB_FLAG_PREEMPT) {\n\t\tif (chunk_ib->flags & AMDGPU_IB_FLAG_CE)\n\t\t\t(*ce_preempt)++;\n\t\telse\n\t\t\t(*de_preempt)++;\n\n\t\t/* Each GFX command submit allows only 1 IB max\n\t\t * preemptible for CE & DE */\n\t\tif (*ce_preempt > 1 || *de_preempt > 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (chunk_ib->flags & AMDGPU_IB_FLAG_PREAMBLE)\n\t\tjob->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT;\n\n\tr =  amdgpu_ib_get(p->adev, vm, ring->funcs->parse_cs ?\n\t\t\t   chunk_ib->ib_bytes : 0,\n\t\t\t   AMDGPU_IB_POOL_DELAYED, ib);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to get ib !\\n\");\n\t\treturn r;\n\t}\n\n\tib->gpu_addr = chunk_ib->va_start;\n\tib->length_dw = chunk_ib->ib_bytes / 4;\n\tib->flags = chunk_ib->flags;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_dependencies(struct amdgpu_cs_parser *p,\n\t\t\t\t     struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_dep *deps = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_dep);\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_ctx *ctx;\n\t\tstruct drm_sched_entity *entity;\n\t\tstruct dma_fence *fence;\n\n\t\tctx = amdgpu_ctx_get(fpriv, deps[i].ctx_id);\n\t\tif (ctx == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_ctx_get_entity(ctx, deps[i].ip_type,\n\t\t\t\t\t  deps[i].ip_instance,\n\t\t\t\t\t  deps[i].ring, &entity);\n\t\tif (r) {\n\t\t\tamdgpu_ctx_put(ctx);\n\t\t\treturn r;\n\t\t}\n\n\t\tfence = amdgpu_ctx_get_fence(ctx, entity, deps[i].handle);\n\t\tamdgpu_ctx_put(ctx);\n\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tif (chunk->chunk_id == AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES) {\n\t\t\tstruct drm_sched_fence *s_fence;\n\t\t\tstruct dma_fence *old = fence;\n\n\t\t\ts_fence = to_drm_sched_fence(fence);\n\t\t\tfence = dma_fence_get(&s_fence->scheduled);\n\t\t\tdma_fence_put(old);\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_syncobj_lookup_and_add(struct amdgpu_cs_parser *p,\n\t\t\t\t\t uint32_t handle, u64 point,\n\t\t\t\t\t u64 flags)\n{\n\tstruct dma_fence *fence;\n\tint r;\n\n\tr = drm_syncobj_find_fence(p->filp, handle, point, flags, &fence);\n\tif (r) {\n\t\tDRM_ERROR(\"syncobj %u failed to find fence @ %llu (%d)!\\n\",\n\t\t\t  handle, point, r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_sync_fence(&p->sync, fence);\n\tdma_fence_put(fence);\n\treturn r;\n}\n\nstatic int amdgpu_cs_p2_syncobj_in(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, deps[i].handle, 0, 0);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_wait(struct amdgpu_cs_parser *p,\n\t\t\t\t\t      struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, syncobj_deps[i].handle,\n\t\t\t\t\t\t  syncobj_deps[i].point,\n\t\t\t\t\t\t  syncobj_deps[i].flags);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_out(struct amdgpu_cs_parser *p,\n\t\t\t\t    struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tp->post_deps[i].syncobj =\n\t\t\tdrm_syncobj_find(p->filp, deps[i].handle);\n\t\tif (!p->post_deps[i].syncobj)\n\t\t\treturn -EINVAL;\n\t\tp->post_deps[i].chain = NULL;\n\t\tp->post_deps[i].point = 0;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_signal(struct amdgpu_cs_parser *p,\n\t\t\t\t\t\tstruct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_cs_post_dep *dep = &p->post_deps[i];\n\n\t\tdep->chain = NULL;\n\t\tif (syncobj_deps[i].point) {\n\t\t\tdep->chain = dma_fence_chain_alloc();\n\t\t\tif (!dep->chain)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdep->syncobj = drm_syncobj_find(p->filp,\n\t\t\t\t\t\tsyncobj_deps[i].handle);\n\t\tif (!dep->syncobj) {\n\t\t\tdma_fence_chain_free(dep->chain);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdep->point = syncobj_deps[i].point;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_shadow(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_cp_gfx_shadow *shadow = chunk->kdata;\n\tint i;\n\n\tif (shadow->flags & ~AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tp->jobs[i]->shadow_va = shadow->shadow_va;\n\t\tp->jobs[i]->csa_va = shadow->csa_va;\n\t\tp->jobs[i]->gds_va = shadow->gds_va;\n\t\tp->jobs[i]->init_shadow =\n\t\t\tshadow->flags & AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_pass2(struct amdgpu_cs_parser *p)\n{\n\tunsigned int ce_preempt = 0, de_preempt = 0;\n\tint i, r;\n\n\tfor (i = 0; i < p->nchunks; ++i) {\n\t\tstruct amdgpu_cs_chunk *chunk;\n\n\t\tchunk = &p->chunks[i];\n\n\t\tswitch (chunk->chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tr = amdgpu_cs_p2_ib(p, chunk, &ce_preempt, &de_preempt);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\t\tr = amdgpu_cs_p2_dependencies(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\t\tr = amdgpu_cs_p2_syncobj_in(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\t\tr = amdgpu_cs_p2_syncobj_out(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_wait(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_signal(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tr = amdgpu_cs_p2_shadow(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Convert microseconds to bytes. */\nstatic u64 us_to_bytes(struct amdgpu_device *adev, s64 us)\n{\n\tif (us <= 0 || !adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\t/* Since accum_us is incremented by a million per second, just\n\t * multiply it by the number of MB/s to get the number of bytes.\n\t */\n\treturn us << adev->mm_stats.log2_max_MBps;\n}\n\nstatic s64 bytes_to_us(struct amdgpu_device *adev, u64 bytes)\n{\n\tif (!adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\treturn bytes >> adev->mm_stats.log2_max_MBps;\n}\n\n/* Returns how many bytes TTM can move right now. If no bytes can be moved,\n * it returns 0. If it returns non-zero, it's OK to move at least one buffer,\n * which means it can go over the threshold once. If that happens, the driver\n * will be in debt and no other buffer migrations can be done until that debt\n * is repaid.\n *\n * This approach allows moving a buffer of any size (it's important to allow\n * that).\n *\n * The currency is simply time in microseconds and it increases as the clock\n * ticks. The accumulated microseconds (us) are converted to bytes and\n * returned.\n */\nstatic void amdgpu_cs_get_threshold_for_moves(struct amdgpu_device *adev,\n\t\t\t\t\t      u64 *max_bytes,\n\t\t\t\t\t      u64 *max_vis_bytes)\n{\n\ts64 time_us, increment_us;\n\tu64 free_vram, total_vram, used_vram;\n\t/* Allow a maximum of 200 accumulated ms. This is basically per-IB\n\t * throttling.\n\t *\n\t * It means that in order to get full max MBps, at least 5 IBs per\n\t * second must be submitted and not more than 200ms apart from each\n\t * other.\n\t */\n\tconst s64 us_upper_bound = 200000;\n\n\tif (!adev->mm_stats.log2_max_MBps) {\n\t\t*max_bytes = 0;\n\t\t*max_vis_bytes = 0;\n\t\treturn;\n\t}\n\n\ttotal_vram = adev->gmc.real_vram_size - atomic64_read(&adev->vram_pin_size);\n\tused_vram = ttm_resource_manager_usage(&adev->mman.vram_mgr.manager);\n\tfree_vram = used_vram >= total_vram ? 0 : total_vram - used_vram;\n\n\tspin_lock(&adev->mm_stats.lock);\n\n\t/* Increase the amount of accumulated us. */\n\ttime_us = ktime_to_us(ktime_get());\n\tincrement_us = time_us - adev->mm_stats.last_update_us;\n\tadev->mm_stats.last_update_us = time_us;\n\tadev->mm_stats.accum_us = min(adev->mm_stats.accum_us + increment_us,\n\t\t\t\t      us_upper_bound);\n\n\t/* This prevents the short period of low performance when the VRAM\n\t * usage is low and the driver is in debt or doesn't have enough\n\t * accumulated us to fill VRAM quickly.\n\t *\n\t * The situation can occur in these cases:\n\t * - a lot of VRAM is freed by userspace\n\t * - the presence of a big buffer causes a lot of evictions\n\t *   (solution: split buffers into smaller ones)\n\t *\n\t * If 128 MB or 1/8th of VRAM is free, start filling it now by setting\n\t * accum_us to a positive number.\n\t */\n\tif (free_vram >= 128 * 1024 * 1024 || free_vram >= total_vram / 8) {\n\t\ts64 min_us;\n\n\t\t/* Be more aggressive on dGPUs. Try to fill a portion of free\n\t\t * VRAM now.\n\t\t */\n\t\tif (!(adev->flags & AMD_IS_APU))\n\t\t\tmin_us = bytes_to_us(adev, free_vram / 4);\n\t\telse\n\t\t\tmin_us = 0; /* Reset accum_us on APUs. */\n\n\t\tadev->mm_stats.accum_us = max(min_us, adev->mm_stats.accum_us);\n\t}\n\n\t/* This is set to 0 if the driver is in debt to disallow (optional)\n\t * buffer moves.\n\t */\n\t*max_bytes = us_to_bytes(adev, adev->mm_stats.accum_us);\n\n\t/* Do the same for visible VRAM if half of it is free */\n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc)) {\n\t\tu64 total_vis_vram = adev->gmc.visible_vram_size;\n\t\tu64 used_vis_vram =\n\t\t  amdgpu_vram_mgr_vis_usage(&adev->mman.vram_mgr);\n\n\t\tif (used_vis_vram < total_vis_vram) {\n\t\t\tu64 free_vis_vram = total_vis_vram - used_vis_vram;\n\n\t\t\tadev->mm_stats.accum_us_vis = min(adev->mm_stats.accum_us_vis +\n\t\t\t\t\t\t\t  increment_us, us_upper_bound);\n\n\t\t\tif (free_vis_vram >= total_vis_vram / 2)\n\t\t\t\tadev->mm_stats.accum_us_vis =\n\t\t\t\t\tmax(bytes_to_us(adev, free_vis_vram / 2),\n\t\t\t\t\t    adev->mm_stats.accum_us_vis);\n\t\t}\n\n\t\t*max_vis_bytes = us_to_bytes(adev, adev->mm_stats.accum_us_vis);\n\t} else {\n\t\t*max_vis_bytes = 0;\n\t}\n\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\n/* Report how many bytes have really been moved for the last command\n * submission. This can result in a debt that can stop buffer migrations\n * temporarily.\n */\nvoid amdgpu_cs_report_moved_bytes(struct amdgpu_device *adev, u64 num_bytes,\n\t\t\t\t  u64 num_vis_bytes)\n{\n\tspin_lock(&adev->mm_stats.lock);\n\tadev->mm_stats.accum_us -= bytes_to_us(adev, num_bytes);\n\tadev->mm_stats.accum_us_vis -= bytes_to_us(adev, num_vis_bytes);\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\nstatic int amdgpu_cs_bo_validate(void *param, struct amdgpu_bo *bo)\n{\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct amdgpu_cs_parser *p = param;\n\tstruct ttm_operation_ctx ctx = {\n\t\t.interruptible = true,\n\t\t.no_wait_gpu = false,\n\t\t.resv = bo->tbo.base.resv\n\t};\n\tuint32_t domain;\n\tint r;\n\n\tif (bo->tbo.pin_count)\n\t\treturn 0;\n\n\t/* Don't move this buffer if we have depleted our allowance\n\t * to move it. Don't move anything if the threshold is zero.\n\t */\n\tif (p->bytes_moved < p->bytes_moved_threshold &&\n\t    (!bo->tbo.base.dma_buf ||\n\t    list_empty(&bo->tbo.base.dma_buf->attachments))) {\n\t\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t\t    (bo->flags & AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)) {\n\t\t\t/* And don't move a CPU_ACCESS_REQUIRED BO to limited\n\t\t\t * visible VRAM if we've depleted our allowance to do\n\t\t\t * that.\n\t\t\t */\n\t\t\tif (p->bytes_moved_vis < p->bytes_moved_vis_threshold)\n\t\t\t\tdomain = bo->preferred_domains;\n\t\t\telse\n\t\t\t\tdomain = bo->allowed_domains;\n\t\t} else {\n\t\t\tdomain = bo->preferred_domains;\n\t\t}\n\t} else {\n\t\tdomain = bo->allowed_domains;\n\t}\n\nretry:\n\tamdgpu_bo_placement_from_domain(bo, domain);\n\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\n\tp->bytes_moved += ctx.bytes_moved;\n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t    amdgpu_bo_in_cpu_visible_vram(bo))\n\t\tp->bytes_moved_vis += ctx.bytes_moved;\n\n\tif (unlikely(r == -ENOMEM) && domain != bo->allowed_domains) {\n\t\tdomain = bo->allowed_domains;\n\t\tgoto retry;\n\t}\n\n\treturn r;\n}\n\nstatic int amdgpu_cs_list_validate(struct amdgpu_cs_parser *p,\n\t\t\t    struct list_head *validated)\n{\n\tstruct ttm_operation_ctx ctx = { true, false };\n\tstruct amdgpu_bo_list_entry *lobj;\n\tint r;\n\n\tlist_for_each_entry(lobj, validated, tv.head) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(lobj->tv.bo);\n\t\tstruct mm_struct *usermm;\n\n\t\tusermm = amdgpu_ttm_tt_get_usermm(bo->tbo.ttm);\n\t\tif (usermm && usermm != current->mm)\n\t\t\treturn -EPERM;\n\n\t\tif (amdgpu_ttm_tt_is_userptr(bo->tbo.ttm) &&\n\t\t    lobj->user_invalidated && lobj->user_pages) {\n\t\t\tamdgpu_bo_placement_from_domain(bo,\n\t\t\t\t\t\t\tAMDGPU_GEM_DOMAIN_CPU);\n\t\t\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\n\t\t\tamdgpu_ttm_tt_set_user_pages(bo->tbo.ttm,\n\t\t\t\t\t\t     lobj->user_pages);\n\t\t}\n\n\t\tr = amdgpu_cs_bo_validate(p, bo);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tkvfree(lobj->user_pages);\n\t\tlobj->user_pages = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_cs_parser_bos(struct amdgpu_cs_parser *p,\n\t\t\t\tunion drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct list_head duplicates;\n\tunsigned int i;\n\tint r;\n\n\tINIT_LIST_HEAD(&p->validated);\n\n\t/* p->bo_list could already be assigned if AMDGPU_CHUNK_ID_BO_HANDLES is present */\n\tif (cs->in.bo_list_handle) {\n\t\tif (p->bo_list)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_bo_list_get(fpriv, cs->in.bo_list_handle,\n\t\t\t\t       &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t} else if (!p->bo_list) {\n\t\t/* Create a empty bo_list when no handle is provided */\n\t\tr = amdgpu_bo_list_create(p->adev, p->filp, NULL, 0,\n\t\t\t\t\t  &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tmutex_lock(&p->bo_list->bo_list_mutex);\n\n\t/* One for TTM and one for each CS job */\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list)\n\t\te->tv.num_shared = 1 + p->gang_size;\n\tp->uf_entry.tv.num_shared = 1 + p->gang_size;\n\n\tamdgpu_bo_list_get_list(p->bo_list, &p->validated);\n\n\tINIT_LIST_HEAD(&duplicates);\n\tamdgpu_vm_get_pd_bo(&fpriv->vm, &p->validated, &p->vm_pd);\n\n\t/* Two for VM updates, one for TTM and one for each CS job */\n\tp->vm_pd.tv.num_shared = 3 + p->gang_size;\n\n\tif (p->uf_entry.tv.bo && !ttm_to_amdgpu_bo(p->uf_entry.tv.bo)->parent)\n\t\tlist_add(&p->uf_entry.tv.head, &p->validated);\n\n\t/* Get userptr backing pages. If pages are updated after registered\n\t * in amdgpu_gem_userptr_ioctl(), amdgpu_cs_list_validate() will do\n\t * amdgpu_ttm_backend_bind() to flush and invalidate new pages\n\t */\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tbool userpage_invalidated = false;\n\t\tint i;\n\n\t\te->user_pages = kvmalloc_array(bo->tbo.ttm->num_pages,\n\t\t\t\t\tsizeof(struct page *),\n\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (!e->user_pages) {\n\t\t\tDRM_ERROR(\"kvmalloc_array failure\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tr = amdgpu_ttm_tt_get_user_pages(bo, e->user_pages, &e->range);\n\t\tif (r) {\n\t\t\tkvfree(e->user_pages);\n\t\t\te->user_pages = NULL;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tfor (i = 0; i < bo->tbo.ttm->num_pages; i++) {\n\t\t\tif (bo->tbo.ttm->pages[i] != e->user_pages[i]) {\n\t\t\t\tuserpage_invalidated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\te->user_invalidated = userpage_invalidated;\n\t}\n\n\tr = ttm_eu_reserve_buffers(&p->ticket, &p->validated, true,\n\t\t\t\t   &duplicates);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"ttm_eu_reserve_buffers failed.\\n\");\n\t\tgoto out_free_user_pages;\n\t}\n\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\te->bo_va = amdgpu_vm_bo_find(vm, bo);\n\t}\n\n\tamdgpu_cs_get_threshold_for_moves(p->adev, &p->bytes_moved_threshold,\n\t\t\t\t\t  &p->bytes_moved_vis_threshold);\n\tp->bytes_moved = 0;\n\tp->bytes_moved_vis = 0;\n\n\tr = amdgpu_vm_validate_pt_bos(p->adev, &fpriv->vm,\n\t\t\t\t      amdgpu_cs_bo_validate, p);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_vm_validate_pt_bos() failed.\\n\");\n\t\tgoto error_validate;\n\t}\n\n\tr = amdgpu_cs_list_validate(p, &duplicates);\n\tif (r)\n\t\tgoto error_validate;\n\n\tr = amdgpu_cs_list_validate(p, &p->validated);\n\tif (r)\n\t\tgoto error_validate;\n\n\tif (p->uf_entry.tv.bo) {\n\t\tstruct amdgpu_bo *uf = ttm_to_amdgpu_bo(p->uf_entry.tv.bo);\n\n\t\tr = amdgpu_ttm_alloc_gart(&uf->tbo);\n\t\tif (r)\n\t\t\tgoto error_validate;\n\n\t\tp->gang_leader->uf_addr += amdgpu_bo_gpu_offset(uf);\n\t}\n\n\tamdgpu_cs_report_moved_bytes(p->adev, p->bytes_moved,\n\t\t\t\t     p->bytes_moved_vis);\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tamdgpu_job_set_resources(p->jobs[i], p->bo_list->gds_obj,\n\t\t\t\t\t p->bo_list->gws_obj,\n\t\t\t\t\t p->bo_list->oa_obj);\n\treturn 0;\n\nerror_validate:\n\tttm_eu_backoff_reservation(&p->ticket, &p->validated);\n\nout_free_user_pages:\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\tif (!e->user_pages)\n\t\t\tcontinue;\n\t\tamdgpu_ttm_tt_get_user_pages_done(bo->tbo.ttm, e->range);\n\t\tkvfree(e->user_pages);\n\t\te->user_pages = NULL;\n\t\te->range = NULL;\n\t}\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn r;\n}\n\nstatic void trace_amdgpu_cs_ibs(struct amdgpu_cs_parser *p)\n{\n\tint i, j;\n\n\tif (!trace_amdgpu_cs_enabled())\n\t\treturn;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct amdgpu_job *job = p->jobs[i];\n\n\t\tfor (j = 0; j < job->num_ibs; ++j)\n\t\t\ttrace_amdgpu_cs(p, job, &job->ibs[j]);\n\t}\n}\n\nstatic int amdgpu_cs_patch_ibs(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_job *job)\n{\n\tstruct amdgpu_ring *ring = amdgpu_job_ring(job);\n\tunsigned int i;\n\tint r;\n\n\t/* Only for UVD/VCE VM emulation */\n\tif (!ring->funcs->parse_cs && !ring->funcs->patch_cs_in_place)\n\t\treturn 0;\n\n\tfor (i = 0; i < job->num_ibs; ++i) {\n\t\tstruct amdgpu_ib *ib = &job->ibs[i];\n\t\tstruct amdgpu_bo_va_mapping *m;\n\t\tstruct amdgpu_bo *aobj;\n\t\tuint64_t va_start;\n\t\tuint8_t *kptr;\n\n\t\tva_start = ib->gpu_addr & AMDGPU_GMC_HOLE_MASK;\n\t\tr = amdgpu_cs_find_mapping(p, va_start, &aobj, &m);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"IB va_start is invalid\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif ((va_start + ib->length_dw * 4) >\n\t\t    (m->last + 1) * AMDGPU_GPU_PAGE_SIZE) {\n\t\t\tDRM_ERROR(\"IB va_start+ib_bytes is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* the IB should be reserved at this point */\n\t\tr = amdgpu_bo_kmap(aobj, (void **)&kptr);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tkptr += va_start - (m->start * AMDGPU_GPU_PAGE_SIZE);\n\n\t\tif (ring->funcs->parse_cs) {\n\t\t\tmemcpy(ib->ptr, kptr, ib->length_dw * 4);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\n\t\t\tr = amdgpu_ring_parse_cs(ring, p, job, ib);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\tib->ptr = (uint32_t *)kptr;\n\t\t\tr = amdgpu_ring_patch_cs_in_place(ring, p, job, ib);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_patch_jobs(struct amdgpu_cs_parser *p)\n{\n\tunsigned int i;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_cs_patch_ibs(p, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_cs_vm_handling(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *job = p->gang_leader;\n\tstruct amdgpu_device *adev = p->adev;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct amdgpu_bo_va *bo_va;\n\tstruct amdgpu_bo *bo;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_vm_clear_freed(adev, vm, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_bo_update(adev, fpriv->prt_va, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, fpriv->prt_va->last_pt_update);\n\tif (r)\n\t\treturn r;\n\n\tif (fpriv->csa_va) {\n\t\tbo_va = fpriv->csa_va;\n\t\tBUG_ON(!bo_va);\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t/* ignore duplicates */\n\t\tbo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tif (!bo)\n\t\t\tcontinue;\n\n\t\tbo_va = e->bo_va;\n\t\tif (bo_va == NULL)\n\t\t\tcontinue;\n\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_vm_handle_moved(adev, vm);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_update_pdes(adev, vm, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, vm->last_update);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tjob = p->jobs[i];\n\n\t\tif (!job->vm)\n\t\t\tcontinue;\n\n\t\tjob->vm_pd_addr = amdgpu_gmc_pd_addr(vm->root.bo);\n\t}\n\n\tif (amdgpu_vm_debug) {\n\t\t/* Invalidate all BOs to test for userspace bugs */\n\t\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\t\t/* ignore duplicates */\n\t\t\tif (!bo)\n\t\t\t\tcontinue;\n\n\t\t\tamdgpu_vm_bo_invalidate(adev, bo, false);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_sync_rings(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct drm_gpu_scheduler *sched;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct dma_fence *fence;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_wait_prev_fence(p->ctx, p->entities[p->gang_leader_idx]);\n\tif (r) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"amdgpu_ctx_wait_prev_fence failed.\\n\");\n\t\treturn r;\n\t}\n\n\tlist_for_each_entry(e, &p->validated, tv.head) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\t\tstruct dma_resv *resv = bo->tbo.base.resv;\n\t\tenum amdgpu_sync_mode sync_mode;\n\n\t\tsync_mode = amdgpu_bo_explicit_sync(bo) ?\n\t\t\tAMDGPU_SYNC_EXPLICIT : AMDGPU_SYNC_NE_OWNER;\n\t\tr = amdgpu_sync_resv(p->adev, &p->sync, resv, sync_mode,\n\t\t\t\t     &fpriv->vm);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_sync_push_to_job(&p->sync, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tsched = p->gang_leader->base.entity->rq->sched;\n\twhile ((fence = amdgpu_sync_get_fence(&p->sync))) {\n\t\tstruct drm_sched_fence *s_fence = to_drm_sched_fence(fence);\n\n\t\t/*\n\t\t * When we have an dependency it might be necessary to insert a\n\t\t * pipeline sync to make sure that all caches etc are flushed and the\n\t\t * next job actually sees the results from the previous one\n\t\t * before we start executing on the same scheduler ring.\n\t\t */\n\t\tif (!s_fence || s_fence->sched != sched) {\n\t\t\tdma_fence_put(fence);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->gang_leader->explicit_sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void amdgpu_cs_post_dependencies(struct amdgpu_cs_parser *p)\n{\n\tint i;\n\n\tfor (i = 0; i < p->num_post_deps; ++i) {\n\t\tif (p->post_deps[i].chain && p->post_deps[i].point) {\n\t\t\tdrm_syncobj_add_point(p->post_deps[i].syncobj,\n\t\t\t\t\t      p->post_deps[i].chain,\n\t\t\t\t\t      p->fence, p->post_deps[i].point);\n\t\t\tp->post_deps[i].chain = NULL;\n\t\t} else {\n\t\t\tdrm_syncobj_replace_fence(p->post_deps[i].syncobj,\n\t\t\t\t\t\t  p->fence);\n\t\t}\n\t}\n}\n\nstatic int amdgpu_cs_submit(struct amdgpu_cs_parser *p,\n\t\t\t    union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *leader = p->gang_leader;\n\tstruct amdgpu_bo_list_entry *e;\n\tunsigned int i;\n\tuint64_t seq;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tdrm_sched_job_arm(&p->jobs[i]->base);\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tif (p->jobs[i] == leader)\n\t\t\tcontinue;\n\n\t\tfence = &p->jobs[i]->base.s_fence->scheduled;\n\t\tdma_fence_get(fence);\n\t\tr = drm_sched_job_add_dependency(&leader->base, fence);\n\t\tif (r) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (p->gang_size > 1) {\n\t\tfor (i = 0; i < p->gang_size; ++i)\n\t\t\tamdgpu_job_set_gang_leader(p->jobs[i], leader);\n\t}\n\n\t/* No memory allocation is allowed while holding the notifier lock.\n\t * The lock is held until amdgpu_cs_submit is finished and fence is\n\t * added to BOs.\n\t */\n\tmutex_lock(&p->adev->notifier_lock);\n\n\t/* If userptr are invalidated after amdgpu_cs_parser_bos(), return\n\t * -EAGAIN, drmIoctl in libdrm will restart the amdgpu_cs_ioctl.\n\t */\n\tr = 0;\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = ttm_to_amdgpu_bo(e->tv.bo);\n\n\t\tr |= !amdgpu_ttm_tt_get_user_pages_done(bo->tbo.ttm, e->range);\n\t\te->range = NULL;\n\t}\n\tif (r) {\n\t\tr = -EAGAIN;\n\t\tmutex_unlock(&p->adev->notifier_lock);\n\t\treturn r;\n\t}\n\n\tp->fence = dma_fence_get(&leader->base.s_fence->finished);\n\tlist_for_each_entry(e, &p->validated, tv.head) {\n\n\t\t/* Everybody except for the gang leader uses READ */\n\t\tfor (i = 0; i < p->gang_size; ++i) {\n\t\t\tif (p->jobs[i] == leader)\n\t\t\t\tcontinue;\n\n\t\t\tdma_resv_add_fence(e->tv.bo->base.resv,\n\t\t\t\t\t   &p->jobs[i]->base.s_fence->finished,\n\t\t\t\t\t   DMA_RESV_USAGE_READ);\n\t\t}\n\n\t\t/* The gang leader is remembered as writer */\n\t\te->tv.num_shared = 0;\n\t}\n\n\tseq = amdgpu_ctx_add_fence(p->ctx, p->entities[p->gang_leader_idx],\n\t\t\t\t   p->fence);\n\tamdgpu_cs_post_dependencies(p);\n\n\tif ((leader->preamble_status & AMDGPU_PREAMBLE_IB_PRESENT) &&\n\t    !p->ctx->preamble_presented) {\n\t\tleader->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT_FIRST;\n\t\tp->ctx->preamble_presented = true;\n\t}\n\n\tcs->out.handle = seq;\n\tleader->uf_sequence = seq;\n\n\tamdgpu_vm_bo_trace_cs(&fpriv->vm, &p->ticket);\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tamdgpu_job_free_resources(p->jobs[i]);\n\t\ttrace_amdgpu_cs_ioctl(p->jobs[i]);\n\t\tdrm_sched_entity_push_job(&p->jobs[i]->base);\n\t\tp->jobs[i] = NULL;\n\t}\n\n\tamdgpu_vm_move_to_lru_tail(p->adev, &fpriv->vm);\n\tttm_eu_fence_buffer_objects(&p->ticket, &p->validated, p->fence);\n\n\tmutex_unlock(&p->adev->notifier_lock);\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn 0;\n}\n\n/* Cleanup the parser structure */\nstatic void amdgpu_cs_parser_fini(struct amdgpu_cs_parser *parser)\n{\n\tunsigned int i;\n\n\tamdgpu_sync_free(&parser->sync);\n\tfor (i = 0; i < parser->num_post_deps; i++) {\n\t\tdrm_syncobj_put(parser->post_deps[i].syncobj);\n\t\tkfree(parser->post_deps[i].chain);\n\t}\n\tkfree(parser->post_deps);\n\n\tdma_fence_put(parser->fence);\n\n\tif (parser->ctx)\n\t\tamdgpu_ctx_put(parser->ctx);\n\tif (parser->bo_list)\n\t\tamdgpu_bo_list_put(parser->bo_list);\n\n\tfor (i = 0; i < parser->nchunks; i++)\n\t\tkvfree(parser->chunks[i].kdata);\n\tkvfree(parser->chunks);\n\tfor (i = 0; i < parser->gang_size; ++i) {\n\t\tif (parser->jobs[i])\n\t\t\tamdgpu_job_free(parser->jobs[i]);\n\t}\n\tif (parser->uf_entry.tv.bo) {\n\t\tstruct amdgpu_bo *uf = ttm_to_amdgpu_bo(parser->uf_entry.tv.bo);\n\n\t\tamdgpu_bo_unref(&uf);\n\t}\n}\n\nint amdgpu_cs_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_cs_parser parser;\n\tint r;\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn -EHWPOISON;\n\n\tif (!adev->accel_working)\n\t\treturn -EBUSY;\n\n\tr = amdgpu_cs_parser_init(&parser, adev, filp, data);\n\tif (r) {\n\t\tif (printk_ratelimit())\n\t\t\tDRM_ERROR(\"Failed to initialize parser %d!\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_cs_pass1(&parser, data);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_pass2(&parser);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_parser_bos(&parser, data);\n\tif (r) {\n\t\tif (r == -ENOMEM)\n\t\t\tDRM_ERROR(\"Not enough memory for command submission!\\n\");\n\t\telse if (r != -ERESTARTSYS && r != -EAGAIN)\n\t\t\tDRM_ERROR(\"Failed to process the buffer list %d!\\n\", r);\n\t\tgoto error_fini;\n\t}\n\n\tr = amdgpu_cs_patch_jobs(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_vm_handling(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_sync_rings(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\ttrace_amdgpu_cs_ibs(&parser);\n\n\tr = amdgpu_cs_submit(&parser, data);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tamdgpu_cs_parser_fini(&parser);\n\treturn 0;\n\nerror_backoff:\n\tttm_eu_backoff_reservation(&parser.ticket, &parser.validated);\n\tmutex_unlock(&parser.bo_list->bo_list_mutex);\n\nerror_fini:\n\tamdgpu_cs_parser_fini(&parser);\n\treturn r;\n}\n\n/**\n * amdgpu_cs_wait_ioctl - wait for a command submission to finish\n *\n * @dev: drm device\n * @data: data from userspace\n * @filp: file private\n *\n * Wait for the command submission identified by handle to finish.\n */\nint amdgpu_cs_wait_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *filp)\n{\n\tunion drm_amdgpu_wait_cs *wait = data;\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout);\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tlong r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, wait->in.ctx_id);\n\tif (ctx == NULL)\n\t\treturn -EINVAL;\n\n\tr = amdgpu_ctx_get_entity(ctx, wait->in.ip_type, wait->in.ip_instance,\n\t\t\t\t  wait->in.ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn r;\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, wait->in.handle);\n\tif (IS_ERR(fence))\n\t\tr = PTR_ERR(fence);\n\telse if (fence) {\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tif (r > 0 && fence->error)\n\t\t\tr = fence->error;\n\t\tdma_fence_put(fence);\n\t} else\n\t\tr = 1;\n\n\tamdgpu_ctx_put(ctx);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r == 0);\n\n\treturn 0;\n}\n\n/**\n * amdgpu_cs_get_fence - helper to get fence from drm_amdgpu_fence\n *\n * @adev: amdgpu device\n * @filp: file private\n * @user: drm_amdgpu_fence copied from user space\n */\nstatic struct dma_fence *amdgpu_cs_get_fence(struct amdgpu_device *adev,\n\t\t\t\t\t     struct drm_file *filp,\n\t\t\t\t\t     struct drm_amdgpu_fence *user)\n{\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tint r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, user->ctx_id);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tr = amdgpu_ctx_get_entity(ctx, user->ip_type, user->ip_instance,\n\t\t\t\t  user->ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, user->seq_no);\n\tamdgpu_ctx_put(ctx);\n\n\treturn fence;\n}\n\nint amdgpu_cs_fence_to_handle_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_fence_to_handle *info = data;\n\tstruct dma_fence *fence;\n\tstruct drm_syncobj *syncobj;\n\tstruct sync_file *sync_file;\n\tint fd, r;\n\n\tfence = amdgpu_cs_get_fence(adev, filp, &info->in.fence);\n\tif (IS_ERR(fence))\n\t\treturn PTR_ERR(fence);\n\n\tif (!fence)\n\t\tfence = dma_fence_get_stub();\n\n\tswitch (info->in.what) {\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_handle(filp, syncobj, &info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ_FD:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_fd(syncobj, (int *)&info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNC_FILE_FD:\n\t\tfd = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (fd < 0) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn fd;\n\t\t}\n\n\t\tsync_file = sync_file_create(fence);\n\t\tdma_fence_put(fence);\n\t\tif (!sync_file) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfd_install(fd, sync_file->file);\n\t\tinfo->out.handle = fd;\n\t\treturn 0;\n\n\tdefault:\n\t\tdma_fence_put(fence);\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * amdgpu_cs_wait_all_fences - wait on all fences to signal\n *\n * @adev: amdgpu device\n * @filp: file private\n * @wait: wait parameters\n * @fences: array of drm_amdgpu_fence\n */\nstatic int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tif (r > 0 && fence->error)\n\t\t\tr = fence->error;\n\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (r == 0)\n\t\t\tbreak;\n\t}\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\n\treturn 0;\n}\n\n/**\n * amdgpu_cs_wait_any_fence - wait on any fence to signal\n *\n * @adev: amdgpu device\n * @filp: file private\n * @wait: wait parameters\n * @fences: array of drm_amdgpu_fence\n */\nstatic int amdgpu_cs_wait_any_fence(struct amdgpu_device *adev,\n\t\t\t\t    struct drm_file *filp,\n\t\t\t\t    union drm_amdgpu_wait_fences *wait,\n\t\t\t\t    struct drm_amdgpu_fence *fences)\n{\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\tuint32_t fence_count = wait->in.fence_count;\n\tuint32_t first = ~0;\n\tstruct dma_fence **array;\n\tunsigned int i;\n\tlong r;\n\n\t/* Prepare the fence array */\n\tarray = kcalloc(fence_count, sizeof(struct dma_fence *), GFP_KERNEL);\n\n\tif (array == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence)) {\n\t\t\tr = PTR_ERR(fence);\n\t\t\tgoto err_free_fence_array;\n\t\t} else if (fence) {\n\t\t\tarray[i] = fence;\n\t\t} else { /* NULL, the fence has been already signaled */\n\t\t\tr = 1;\n\t\t\tfirst = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = dma_fence_wait_any_timeout(array, fence_count, true, timeout,\n\t\t\t\t       &first);\n\tif (r < 0)\n\t\tgoto err_free_fence_array;\n\nout:\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\twait->out.first_signaled = first;\n\n\tif (first < fence_count && array[first])\n\t\tr = array[first]->error;\n\telse\n\t\tr = 0;\n\nerr_free_fence_array:\n\tfor (i = 0; i < fence_count; i++)\n\t\tdma_fence_put(array[i]);\n\tkfree(array);\n\n\treturn r;\n}\n\n/**\n * amdgpu_cs_wait_fences_ioctl - wait for multiple command submissions to finish\n *\n * @dev: drm device\n * @data: data from userspace\n * @filp: file private\n */\nint amdgpu_cs_wait_fences_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_wait_fences *wait = data;\n\tuint32_t fence_count = wait->in.fence_count;\n\tstruct drm_amdgpu_fence *fences_user;\n\tstruct drm_amdgpu_fence *fences;\n\tint r;\n\n\t/* Get the fences from userspace */\n\tfences = kmalloc_array(fence_count, sizeof(struct drm_amdgpu_fence),\n\t\t\tGFP_KERNEL);\n\tif (fences == NULL)\n\t\treturn -ENOMEM;\n\n\tfences_user = u64_to_user_ptr(wait->in.fences);\n\tif (copy_from_user(fences, fences_user,\n\t\tsizeof(struct drm_amdgpu_fence) * fence_count)) {\n\t\tr = -EFAULT;\n\t\tgoto err_free_fences;\n\t}\n\n\tif (wait->in.wait_all)\n\t\tr = amdgpu_cs_wait_all_fences(adev, filp, wait, fences);\n\telse\n\t\tr = amdgpu_cs_wait_any_fence(adev, filp, wait, fences);\n\nerr_free_fences:\n\tkfree(fences);\n\n\treturn r;\n}\n\n/**\n * amdgpu_cs_find_mapping - find bo_va for VM address\n *\n * @parser: command submission parser context\n * @addr: VM address\n * @bo: resulting BO of the mapping found\n * @map: Placeholder to return found BO mapping\n *\n * Search the buffer objects in the command submission context for a certain\n * virtual memory address. Returns allocation structure when found, NULL\n * otherwise.\n */\nint amdgpu_cs_find_mapping(struct amdgpu_cs_parser *parser,\n\t\t\t   uint64_t addr, struct amdgpu_bo **bo,\n\t\t\t   struct amdgpu_bo_va_mapping **map)\n{\n\tstruct amdgpu_fpriv *fpriv = parser->filp->driver_priv;\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_va_mapping *mapping;\n\tint r;\n\n\taddr /= AMDGPU_GPU_PAGE_SIZE;\n\n\tmapping = amdgpu_vm_bo_lookup_mapping(vm, addr);\n\tif (!mapping || !mapping->bo_va || !mapping->bo_va->base.bo)\n\t\treturn -EINVAL;\n\n\t*bo = mapping->bo_va->base.bo;\n\t*map = mapping;\n\n\t/* Double check that the BO is reserved by this CS */\n\tif (dma_resv_locking_ctx((*bo)->tbo.base.resv) != &parser->ticket)\n\t\treturn -EINVAL;\n\n\tif (!((*bo)->flags & AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS)) {\n\t\t(*bo)->flags |= AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS;\n\t\tamdgpu_bo_placement_from_domain(*bo, (*bo)->allowed_domains);\n\t\tr = ttm_bo_validate(&(*bo)->tbo, &(*bo)->placement, &ctx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn amdgpu_ttm_alloc_gart(&(*bo)->tbo);\n}\n"], "filenames": ["drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c"], "buggy_code_start_loc": [1656], "buggy_code_end_loc": [1666], "fixing_code_start_loc": [1657], "fixing_code_end_loc": [1665], "type": "CWE-416", "message": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free.", "other": {"cve": {"id": "CVE-2023-51042", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-23T11:15:08.703", "lastModified": "2024-01-29T22:57:08.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free."}, {"lang": "es", "value": "En el kernel de Linux anterior a 6.4.12, amdgpu_cs_wait_all_fences en drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c tiene una barrera de use-after-free."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.12", "matchCriteriaId": "242396F2-761D-4B72-ABF8-090BB852BD40"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.4.12", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/2e54154b9f27262efd0cb4f903cc7d5ad1fe9628", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2e54154b9f27262efd0cb4f903cc7d5ad1fe9628"}}