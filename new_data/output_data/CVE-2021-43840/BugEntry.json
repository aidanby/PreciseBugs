{"buggy_code": ["Unreleased\n\n  - FIX: Prevent simple polling from clobbering the session\n\n31-05-2021\n\n- Version 3.3.6\n\n  - FEATURE: Introduce support for transport codecs\n  - FIX: event subscription leak in JS after start/stop/start sequence\n  - FEATURE: MessageBus.onVisibilityChange() can be used to trigger a visibility change check by hand\n\n28-04-2021\n\n- Version 3.3.5\n\n  - PERF: Optimised CORS preflight handling\n  - FEATURE: Enable CORS preflight caching\n  - FEATURE: Removed trailing cache buster from message bus polls\n  - PERF: Improved delay poll timeout for cases where a tab moves in and out of the background\n\n02-10-2020\n\n- Version 3.3.4\n\n  - FIX: Remove trailing comma incorrectly added in ec60d8865.\n\n18-09-2020\n\n- Version 3.3.3\n\n  - FIX: `queue_in_memory` option not being passed to the backends.\n  - FIX: `MessageBus::DistributedCache#publish` should raise on error.\n\n    On the redis backend, any errors encountered during `MessageBus#publish`\n    will add the message into an in memory queue and silently swallow the\n    error. While this is behavior is OK for normal message_bus usage, it may\n    lead to inconsistency when using `DistributedCache`. If a process\n    doesn't publish successfully to another process, it will still update\n    its in memory cache leaving the other processes unaware. As such, the\n    distributed cache is out of sync and will require another successful\n    write to the cache to resync all the caches.\n\n15-09-2020\n\n- Version 3.3.2\n\n  - FIX: In the JavaScript client throw when when lastId is given but is not a number.\n  - FEATURE: raise when attempting to publish to invalid targets\n  - Log when DistributedCache encounters an error when publishing.\n\n09-06-2020\n\n- Version 3.3.1\n\n  - FIX: Disconnect Redis conn when rescuing errors in global subscribe.\n  - FIX: `MessageBus::Backends::Redis#global_subscribe` not closing Redis connections.\n\n15-05-2020\n\n- Version 3.3.0\n\n   - FEATURE: `MessageBus.base_route=` to alter the route that message bus will listen on.\n\n07-05-2020\n\n- Version 3.2.0\n\n   - FIX: compatibility with Rails 6.0.3, note: apps without ActionDispatch::Flash may stop working after this upgrade\n   to correct this disable middleware injection with `config.skip_message_bus_middleware = true` and configure middleware by hand with `app.middleware.use(MessageBus::Rack::Middleware)`\n\n28-04-2020\n\n- Version 3.1.0\n\n  - FEATURE: `MessageBus#register_client_message_filter` to register a custom filter so that messages can be inspected and filtered away from clients.\n\n27-04-2020\n\n- Version 3.0.0\n\n  - Drop support for Ruby 2.3\n  - FIX: Don't publish message to intersection of `user_ids` and `group_ids` - instead use the union, this is a behavior change, hence a new major release.\n\n26-03-2020\n\n- Version 2.2.4\n\n  - FEATURE: shouldLongPollCallback optional setting which allows overriding decision about long polling\n\n18-10-2019\n\n- Version 2.2.3\n\n  - FIX: Protect redis config from being manipulated in backend\n\n09-08-2019\n\n- Version 2.2.2\n\n  - FEATURE: Support rate limiting by server, 429 status codes are respected and we hold off as needed\n\n  - FIX: In the redis backend make the `is_readonly?` method compatible with the redis gem both pre and post v4.0 when the `client` attribute was removed\n\n\n30-04-2019\n\n- Version 2.2.1\n\n  - FIX: No longer handles exceptions raised in downstream middleware via `on_middleware_error`\n\n28-01-2019\n\n- Version 2.2.0\n\n  - FIX: Ruby HTTP Client not backing off polling on error.\n\n11-12-2018\n\n- Version 2.2.0.pre.2\n\n  - FEATURE: Re-wrote diagnostics UI using React\n  - FEATURE: MessageBus HTTP Ruby Client\n\n30-11-2018\n\n- Version 2.2.0.pre.1\n\n  - FIX: diagnostics stopped working cause a private method was invoked on self\n\n30-11-2018\n\n- Version 2.2.0.pre\n\n- FIX: In redis backend we now expire the key used to track channel id this can cause a redis key leak\n    with large amounts of subscriptions that go away\n- FEATURE: Much extra implementation documentation, and some improvements to usage documentation.\n- FEATURE: Improvements to development workflow:\n  - Fully docker-based development and testing, with no other dependencies.\n  - More stringent Rubocop enforcement and greater compliance.\n  - Testing supported Ruby versions\n  - Better test coverage of some features\n  - Improved testing and assertion of the differences between backends\n  - More stable tests - now pass pretty much every run\n  - Documentation syntax is verified as part of testing\n- FEATURE: Ruby 2.2.0 is no longer supported as it is EOL\n- FEATURE: Better feature parity between backends:\n  - Adds support for backlog expiry to memory backend\n  - Support setting backlog expiry on publication w/ Postgres\n  - Supports setting backlog size on publication for memory/postgres\n- FEATURE: `MessageBus.off` now prevents the server subscription from starting up.\n- FEATURE: Trims unused parts of the public API:\n  - Methods removed:\n    * ConnectionManager#stats (never used and the ConnectionManager is not exposed to application code)\n    * Client#cancel (effectively duplicate of Client#close and the Client is only available via the ConnectionManager, thus not available to application code)\n\n  - Methods made private:\n    * MessageBus::Implementation#encode_channel_name\n    * MessageBus::Implementation#decode_channel_name\n    * Client#in_async?\n    * Client#ensure_closed!\n    * ConnectionManager#subscribe_client\n    * Diagnostics.full_process_path\n    * Diagnostics.hostname\n    * MessageBus::Rack::Diagnostics#js_asset\n    * MessageBus::Rack::Diagnostics#generate_script_tag\n    * MessageBus::Rack::Diagnostics#file_hash\n    * MessageBus::Rack::Diagnostics#asset_contents\n    * MessageBus::Rack::Diagnostics#asset_path\n    * MessageBus::Rack::Diagnostics#index\n    * MessageBus::Rack::Diagnostics#translate_handlebars\n    * MessageBus::Rack::Diagnostics#indent\n    * MessageBus::Rack::Middleware#start_listener\n    * MessageBus::Rack::Middleware#close_db_connection!\n    * MessageBus::Rack::Middleware#add_client_with_timeout\n\n  - Methods switched from protected to private:\n    * MessageBus::Implementation#global?\n    * MessageBus::Implementation#decode_message!\n    * MessageBus::Implementation#replay_backlog\n    * MessageBus::Implementation#subscribe_impl\n    * MessageBus::Implementation#unsubscribe_impl\n    * MessageBus::Implementation#ensure_subscriber_thread\n    * MessageBus::Implementation#new_subscriber_thread\n    * MessageBus::Implementation#global_subscribe_thread\n    * MessageBus::Implementation#multi_each\n    * Client#write_headers\n    * Client#write_chunk\n    * Client#write_and_close\n    * Client#messages_to_json\n\n15-10-2018\n\n- Version 2.1.6\n\n- FEATURE: `MessageBus.publish` accepts option `site_id` to publish to a site\n- FEATURE: Added MessageBus::DistributedCache for cross process caching\n- PERF: Use monotonic times in timer thread\n- FEATURE: min poll interval is now configurable client side\n\n16-05-2018\n\n- Version 2.1.5\n\n- FIX: In some cases a 30 second initial delay could happen cause client lost info about long poller\n\n20-04-2018\n\n- Version 2.1.4\n\n- FIX: Subtle issue where poll timeout may not be cleared causing multiple concurrent polls\n- FIX: Add extra protection for poller to ensure there is never a case where multiple ajax happens concurrently\n\n09-01-2018\n\n- Version 2.1.2\n\n- FEATURE: minHiddenPollInterval set to 1500ms out of the box, ensures we never do hidden tab\n   polls at a high rate if tons of tabs are open\n- FEATURE: added random 500ms to delayed polls to increase tab entropy\n\n18-12-2017\n\n- Version 2.1.1\n\n- FEATURE: allow setting of max_backlog_size and max_backlog_age on publish for redis provider\n\n18-12-2017\n\n- Version 2.1.0\n\n- FEATURE: you can now lookup last N messages on channel on subscribe from JavaScript\n   Subscribe at position (-1 - numberOfMessages) from the client\n\n24-11-2017\n\n- Version 2.0.9\n\n- PERF: faster serialization of messages\n- FEATURE: on backend flush web clients will resume and continue to get all new messages\n\n06-10-2017\n\n- Version 2.0.8\n\n- Fix: Make redis readonly detection more robust\n\n02-10-2017\n\n- Version 2.0.7\n\n- Fix/Feature: use LUA script for publishing to bus, this eliminates a race condition\n   and ensures that we are never stuck in a multi transaction by mistake\n\n\n29-09-2017\n\n- Version 2.0.6\n\n- Fix: correct after_fork so it correctly disconnects redis\n- Fix: correct message_bus #destroy used in tests to clean up spec (deadlock)\n- Fix: deliver backlog unconditionally when polling (and not long polling)\n\n16-08-2017\n\n- Version 2.0.5\n\n- Quick fix, build on earlier version of Ruby cause https://github.com/rubygems/rubygems/issues/1448 is still open\n\n- Version 2.0.3\n- Fix: broken MessageBus.redis_config\n- Perf: publish status message for filtered messages\n- Perf: add frozen strings to save on memory\n- Feature: improved logging when messages are dropped\n- Fix: handle missing actiondispatch flash\n\n25-08-2016\n\n- Version 2.0.2\n- Feature: Add on_middleware_error callback for remapping middleware errors to HTTP results\n\n\n25-07-2016\n\n- Feature: Add JavaScript MessageBus.status() function\n\n\n21-06-2016\n\n- Version 2.0.1\n- Fix: build using old ruby cause new ruby breaks stuff @sam\n\n21-06-2016\n\n- Version 2.0.0\n- Fix: forked process terminates parent more cleanly (does not kill -9 parent if already terminated) @uri\n- Fix: add async true explicitly on ajax reqs to ensure it always works even if disabled by globally @washu\n\n11-05-2016\n\n- Version 2.0.0.beta.11\n- Fix: for https://github.com/rubygems/rubygems/issues/1448 which is still broken, build under Ruby 2.0\n\n11-05-2016\n\n- Version 2.0.0.beta.10\n- Fix: for https://github.com/rubygems/rubygems/issues/1448\n\n11-05-2016\n\n- Version 2.0.0.beta.9\n- Fix: requests without content type were erroring out, breaks CORS\n\n27-04-2016\n\n- Version 2.0.0.beta.8\n- Fix: exception raised sometimes when subscribing at a particular position\n\n26-04-2016\n\n- Version 2.0.0.beta.7\n\n- Feature: Support custom HTTP headers without depending on jQuery @nathanstitt\n- Feature: Allow subscribe at a particular position from server side @sam\n\n29-02-2016\n\n- Version 2.0.0.beta.6\n\n- Feature: Support standalone operation without depending on jQuery @nathanstitt\n- Feature: Support a noconflict mode @nathanstitt\n- Feature: Support JSON POST payload @nathanstitt\n\n29-02-2016\n\n- Version 2.0.0.beta.5\n\n- Fix: JavaScript unsubscribe was not updating publicly visible MessageBus.callbacks @sam\n- Fix: When MessageBus is talking to a readonly redis buffering may cause a infinite loop @tgxworld\n\n- Version 2.0.0.beta.4\n\n- Feature: allow verbose redis logging by specifying `enable_redis_logger` in config, default disabled\n\n- Version 2.0.0.beta.3\n\n- Feature: Postgresql backend @jeremyevans\n- Breaking Change: Configuration API changed see Readme for details @jeremyevans\n- Breaking Change: Remove runtime dependency on Redis @jeremyevans\n- Dev: Convert all specs to minitest @jeremyevans\n- Feature: Support passing channels to Rack middleware via env['message_bus.channels'] via @jeremyevans\n\n03-01-2016\n\n- Version 2.0.0.beta.2\n- Fix: Remove stray console.log\n\n- Version 2.0.0.beta.1\n- Feature: add support for chunked encoding transport, this significnatlly improves long polling performance\n- Feature: strip around_filters and client filters, which were speculative\n- Fix: Message delivery race condition when a message was published just as long poll started. Ben Langfeld\n- Feature: strip support for message_handlers, speculative feature that was not used\n\n09-12-2015\n\n- Version 1.1.1\n- Fix: In multisite config there was no way to specify site for last_id or backlog\n   to resolve overrides were added to #last_id and #backlog, MessageBus::Client now\n   uses the new overrides\n\n07-12-2015\n\n- Version 1.1.0\n- Fix: keep track of client sequence on server, abandon old subscribes\n- Fix: rare concurrency issue when subscribing concurrently\n- Feature: remove most jQuery dependency from message-bus.js\n\n09-07-2015\n- Version 1.0.16\n- Fix: correct edge cases around keepalive checks on bus\n\n09-07-2015\n- Version 1.0.15\n- Feature: MessageBus.reliable_pub_sub.max_backlog_age (in secs) configurable (default to 7 days)\n- Fix: API for MessageBus.backlog(\"/bla\") was returning global backlog by mistake\n- Change: Max global backlog size reduced to 2000 elements\n\n08-06-2015\n- Version 1.0.14\n- Fix: we can not use Thread#kill best keepalive can do is terminate process cleanly\n- Feature: you can opt-out of keepalive with MessageBus.keepalive_timeout = 0\n\n08-06-2015\n- Version 1.0.13\n- Fix: on global subscribe reconnect replay missed messages\n- Feature: keepalive tests for global subscribe, catches hung redis connections\n\n28-05-2015\n- Version 1.0.12\n- Feature: Support client_id targeted message\n\n06-05-2015\n- Version 1.0.11\n- Fix: race condition in TimerThread\n\n01-05-2015\n- Version: 1.0.10\n- Feature: no longer depends on EventMachine (only used for Thin backend)\n- Feature: reliable pub sub will queue messages in memory if redis is readonly, configurable\n- Fix: if redis is flushed we will continue to deliver messages\n\n23-03-2015\n- Version 1.0.9\n- Fix: inherit off StandardError not Exception for all exceptions raised\n\n20-03-2015\n- Version 1.0.8\n- Fix: aggressive short polling in background\n\n16-03-2015\n- Version 1.0.7\n- Feature: added pause and resume methods\n\n03-02-2015\n- Version 1.0.6\n- Fix: global backlog not truncating correctly\n\n23-09-2014\n- Version 1.0.5\n- Fix: missing custom headers from long polls\n\n23-09-2014\n- Version 1.0.4\n- Change: MessageBus.access_control_allow_origin_lookup to extra_response_headers_lookup\n\n23-09-2014\n- Version 1.0.3\n- Change: MessageBus.access_control_allow_origin to MessageBus.access_control_allow_origin_lookup\n\n23-09-2014\n- Version 1.0.2\n- Feature: MessageBus.access_control_allow_origin to control origin header\n\n23-09-2014\n- Version 1.0.1\n- Feature: $.ajax dependency can be passed in.\n- Feature: unsubscribe accepts a second param for the function to unsubscribe.\n\n22-09-2014\n- Version 1.0.0\n- Feature: add backgroundCallbackInterval - interval to send polls when page is in the background\n- Feature: issue a long poll as soon as page moves into the foreground\n\n11-08-2014\n- Version 0.9.5\n- Fix: release db connection a lot earlier for long polling (rails defer closes)\n\n13-01-2014\n- Version 0.9.4\n- Added support for /global/ channel to publish messages across a multisite\n- Cleaned up test harness so it uses local bus as opposed to global\n- Fix bug where we could subscribe to a channel but miss starting messages\n- Added method for destroying a local MessageBus instance\n- ensure_reactor could say the reactor is running, but it was not, on first call\n\n06-12-2013\n- Version 0.9.3.2\n- Fix permissions in gem\n\n05-12-2013\n- Version 0.9.3.1\n- Add MessageBus.diagnostics() for diagnosing bus issues client side\n- Add more robustness to JavaScript, if callbacks used to fail they would halt the chain\n\n03-12-2013\n- Version 0.9.3\n- Remove thin dependency\n- Improve robustness under failure conditions\n\n30-09-2013\n- Fix failures in Ruby 1.9\n- Set up rack hijack by default in light of passengers new setting\n", "# frozen_string_literal: true\n\nmodule MessageBus::Rack; end\n\n# Accepts requests from clients interested in using diagnostics functionality\n# @see MessageBus::Diagnostics\nclass MessageBus::Rack::Diagnostics\n  # @param [Proc] app the rack app\n  # @param [Hash] config\n  # @option config [MessageBus::Instance] :message_bus (`MessageBus`) a specific instance of message_bus\n  def initialize(app, config = {})\n    @app = app\n    @bus = config[:message_bus] || MessageBus\n  end\n\n  # Process an HTTP request from a subscriber client\n  # @param [Rack::Request::Env] env the request environment\n  def call(env)\n    return @app.call(env) unless env['PATH_INFO'].start_with? \"#{@bus.base_route}message-bus/_diagnostics\"\n\n    route = env['PATH_INFO'].split(\"#{@bus.base_route}message-bus/_diagnostics\")[1]\n\n    if @bus.is_admin_lookup.nil? || !@bus.is_admin_lookup.call(env)\n      return [403, {}, ['not allowed']]\n    end\n\n    return index unless route\n\n    if route == '/discover'\n      user_id = @bus.user_id_lookup.call(env)\n      @bus.publish('/_diagnostics/discover', user_id: user_id)\n      return [200, {}, ['ok']]\n    end\n\n    if route =~ /^\\/hup\\//\n      hostname, pid = route.split('/hup/')[1].split('/')\n      @bus.publish('/_diagnostics/hup', hostname: hostname, pid: pid.to_i)\n      return [200, {}, ['ok']]\n    end\n\n    asset = route.split('/assets/')[1]\n    if asset && !asset !~ /\\//\n      content = asset_contents(asset)\n      return [200, { 'Content-Type' => 'application/javascript;charset=UTF-8' }, [content]]\n    end\n\n    [404, {}, ['not found']]\n  end\n\n  private\n\n  def js_asset(name, type = \"text/javascript\")\n    return generate_script_tag(name, type) unless @bus.cache_assets\n\n    @@asset_cache ||= {}\n    @@asset_cache[name] ||= generate_script_tag(name, type)\n    @@asset_cache[name]\n  end\n\n  def generate_script_tag(name, type)\n    \"<script src='/message-bus/_diagnostics/assets/#{name}?#{file_hash(name)}' type='#{type}'></script>\"\n  end\n\n  def file_hash(asset)\n    require 'digest/sha1'\n    Digest::SHA1.hexdigest(asset_contents(asset))\n  end\n\n  def asset_contents(asset)\n    File.open(asset_path(asset)).read\n  end\n\n  def asset_path(asset)\n    File.expand_path(\"../../../../assets/#{asset}\", __FILE__)\n  end\n\n  def index\n    html = <<~HTML\n      <!DOCTYPE html>\n      <html>\n        <head>\n        </head>\n        <body>\n          <div id=\"app\"></div>\n          #{js_asset \"jquery-1.8.2.js\"}\n          #{js_asset \"react.js\"}\n          #{js_asset \"react-dom.js\"}\n          #{js_asset \"babel.min.js\"}\n          #{js_asset \"message-bus.js\"}\n          #{js_asset \"application.jsx\", \"text/jsx\"}\n        </body>\n      </html>\n    HTML\n\n    [200, { \"content-type\" => \"text/html;\" }, [html]]\n  end\nend\n", "# frozen_string_literal: true\n# coding: utf-8\n\nrequire_relative '../../../spec_helper'\nrequire 'message_bus'\nrequire 'rack/test'\n\ndescribe MessageBus::Rack::Middleware do\n  include Rack::Test::Methods\n  let(:extra_middleware) { nil }\n  let(:base_route) { nil }\n\n  before do\n    bus = @bus = MessageBus::Instance.new\n    @bus.configure(test_config_for_backend(CURRENT_BACKEND))\n    @bus.long_polling_enabled = false\n    @bus.base_route = base_route if base_route\n\n    e_m = extra_middleware\n    builder = Rack::Builder.new {\n      use FakeAsyncMiddleware, message_bus: bus\n      use e_m if e_m\n      use MessageBus::Rack::Middleware, message_bus: bus\n      run lambda { |_env| [500, { 'Content-Type' => 'text/html' }, 'should not be called'] }\n    }\n\n    @async_middleware = builder.to_app\n    @message_bus_middleware = @async_middleware.app\n  end\n\n  after do\n    @message_bus_middleware.stop_listener\n    @bus.reset!\n    @bus.destroy\n  end\n\n  def app\n    @async_middleware\n  end\n\n  module LongPolling\n    extend Minitest::Spec::DSL\n\n    before do\n      @bus.long_polling_enabled = true\n    end\n\n    describe \"with altered base_route\" do\n      let(:base_route) { \"/base/route/\" }\n\n      it \"should respond as normal\" do\n        post \"/base/route/message-bus/ABC?dlp=t\", '/foo1' => 0\n        @async_middleware.in_async?.must_equal false\n        last_response.ok?.must_equal true\n      end\n    end\n\n    it \"should respond right away if dlp=t\" do\n      post \"/message-bus/ABC?dlp=t\", '/foo1' => 0\n      @async_middleware.in_async?.must_equal false\n      last_response.ok?.must_equal true\n    end\n\n    it \"should respond with a 404 if the client_id is missing\" do\n      post \"/message-bus/?dlp=t\", '/foo1' => 0\n      last_response.not_found?.must_equal true\n    end\n\n    it \"should respond right away to long polls that are polling on -1 with the last_id\" do\n      post \"/message-bus/ABC\", '/foo' => -1\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n    end\n\n    it \"should respond to long polls when data is available\" do\n      middleware = @async_middleware\n      bus = @bus\n\n      @bus.extra_response_headers_lookup do |_env|\n        { \"FOO\" => \"BAR\" }\n      end\n\n      Thread.new do\n        wait_for(2000) { middleware.in_async? }\n        bus.publish \"/foo\", \"\u05dd\u05d5\u05b9\u05dc\u05e9\u05b8\u05c1\"\n      end\n\n      post \"/message-bus/ABC\", '/foo' => nil\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n      parsed[0][\"data\"].must_equal \"\u05dd\u05d5\u05b9\u05dc\u05e9\u05b8\u05c1\"\n\n      last_response.headers[\"FOO\"].must_equal \"BAR\"\n    end\n\n    it \"should timeout within its alloted slot\" do\n      begin\n        @bus.long_polling_interval = 10\n        s = Time.now.to_f * 1000\n        post \"/message-bus/ABC\", '/foo' => nil\n        # allow for some jitter\n        (Time.now.to_f * 1000 - s).must_be :<, 100\n      ensure\n        @bus.long_polling_interval = 5000\n      end\n    end\n  end\n\n  describe \"thin async\" do\n    before do\n      @async_middleware.simulate_thin_async\n    end\n\n    include LongPolling\n  end\n\n  describe \"hijack\" do\n    before do\n      @async_middleware.simulate_hijack\n      @bus.rack_hijack_enabled = true\n    end\n\n    include LongPolling\n  end\n\n  describe \"start listener\" do\n    let(:app) { ->(_) { [200, {}, []] } }\n\n    it \"never subscribes\" do\n      bus = MessageBus::Instance.new\n      bus.off\n\n      middleware = MessageBus::Rack::Middleware.new(app, message_bus: bus)\n\n      middleware.started_listener.must_equal false\n    end\n  end\n\n  describe \"diagnostics\" do\n    it \"should return a 403 if a user attempts to get at the _diagnostics path\" do\n      get \"/message-bus/_diagnostics\"\n      last_response.status.must_equal 403\n    end\n\n    it \"should get a 200 with html for an authorized user\" do\n\n      def @bus.is_admin_lookup\n        proc { |_| true }\n      end\n\n      get \"/message-bus/_diagnostics\"\n      last_response.status.must_equal 200\n    end\n\n    describe \"with an altered base_route\" do\n      let(:base_route) { \"/base/route/\" }\n\n      it \"should get a 200 with html for an authorized user\" do\n        def @bus.is_admin_lookup\n          proc { |_| true }\n        end\n\n        get \"/base/route/message-bus/_diagnostics\"\n        last_response.status.must_equal 200\n      end\n    end\n\n    it \"should get the script it asks for\" do\n\n      def @bus.is_admin_lookup\n        proc { |_| true }\n      end\n\n      get \"/message-bus/_diagnostics/assets/message-bus.js\"\n      last_response.status.must_equal 200\n      last_response.content_type.must_equal \"application/javascript;charset=UTF-8\"\n    end\n  end\n\n  describe \"polling\" do\n    before do\n      @bus.long_polling_enabled = false\n    end\n\n    it \"should include access control headers\" do\n      @bus.extra_response_headers_lookup do |_env|\n        { \"FOO\" => \"BAR\" }\n      end\n\n      client_id = \"ABCD\"\n\n      # client always keeps a list of channels with last message id they got on each\n      post \"/message-bus/#{client_id}\",\n           '/foo' => nil,\n           '/bar' => nil\n\n      last_response.headers[\"FOO\"].must_equal \"BAR\"\n    end\n\n    it \"should respond with a 200 to a subscribe\" do\n      client_id = \"ABCD\"\n\n      # client always keeps a list of channels with last message id they got on each\n      post \"/message-bus/#{client_id}\",\n           '/foo' => nil,\n           '/bar' => nil\n\n      last_response.ok?.must_equal true\n    end\n\n    # this means we recover from redis reset\n    it \"should understand that larger than position is the same as -1\" do\n      @bus.publish('/foo', 'bar')\n      @bus.publish('/baz', 'test')\n      @bus.publish('/boom', 'bang')\n\n      post \"/message-bus/ABCD\",\n           '/foo' => 1_000_000,\n           '/baz' => @bus.last_id('/baz') + 1,\n           '/boom' => 1_000_000\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n      parsed[0][\"data\"][\"/boom\"].must_equal @bus.last_id(\"/boom\")\n    end\n\n    it \"should correctly understand that -1 means stuff from now onwards\" do\n      # even if allow chunked\n      @bus.chunked_encoding_enabled = true\n\n      @bus.publish('/foo', 'bar')\n      @bus.publish('/baz', 'test')\n      @bus.publish('/boom', 'bang')\n\n      post \"/message-bus/ABCD\",\n           '/foo' => -1,\n           '/baz' => @bus.last_id('/baz') + 1,\n           '/boom' => -1\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n      parsed[0][\"data\"][\"/boom\"].must_equal @bus.last_id(\"/boom\")\n    end\n\n    it \"should respond with the data if messages exist in the backlog\" do\n      id = @bus.last_id('/foo')\n\n      @bus.publish(\"/foo\", \"barbs\")\n      @bus.publish(\"/foo\", \"borbs\")\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id,\n           '/bar' => nil\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal \"barbs\"\n      parsed[1][\"data\"].must_equal \"borbs\"\n    end\n\n    it \"should use the correct client ID\" do\n      id = @bus.last_id('/foo')\n\n      client_id = \"aBc123\"\n      @bus.publish(\"/foo\", \"msg1\", client_ids: [client_id])\n      @bus.publish(\"/foo\", \"msg2\", client_ids: [\"not_me#{client_id}\"])\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal(\"msg1\")\n      parsed[1][\"data\"].wont_equal(\"msg2\")\n    end\n\n    it \"should use the correct client ID with additional path\" do\n      id = @bus.last_id('/foo')\n\n      client_id = \"aBc123\"\n      @bus.publish(\"/foo\", \"msg1\", client_ids: [client_id])\n      @bus.publish(\"/foo\", \"msg2\", client_ids: [\"not_me#{client_id}\"])\n\n      post \"/message-bus/#{client_id}/path/not/needed\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal(\"msg1\")\n      parsed[1][\"data\"].wont_equal(\"msg2\")\n    end\n\n    it \"should have no cross talk\" do\n      seq = 0\n      @bus.site_id_lookup do\n        (seq += 1).to_s\n      end\n\n      # published on channel 1\n      msg = @bus.publish(\"/foo\", \"test\")\n\n      # subscribed on channel 2\n      post \"/message-bus/ABCD\",\n           '/foo' => (msg - 1)\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 0\n    end\n\n    it \"should have global cross talk\" do\n      seq = 0\n      @bus.site_id_lookup do\n        (seq += 1).to_s\n      end\n\n      msg = @bus.publish(\"/global/foo\", \"test\")\n\n      post \"/message-bus/ABCD\",\n           '/global/foo' => (msg - 1)\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"should not get consumed messages\" do\n      @bus.publish(\"/foo\", \"barbs\")\n      id = @bus.last_id('/foo')\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 0\n    end\n\n    it \"should filter by user correctly\" do\n      id = @bus.publish(\"/foo\", \"test\", user_ids: [1])\n      @bus.user_id_lookup do |_env|\n        0\n      end\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n\n      message = parsed.first\n\n      message[\"channel\"].must_equal \"/__status\"\n      message[\"data\"].must_equal(\"/foo\" => 1)\n\n      @bus.user_id_lookup do |_env|\n        1\n      end\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"should filter by group correctly\" do\n      id = @bus.publish(\"/foo\", \"test\", group_ids: [3, 4, 5])\n      @bus.group_ids_lookup do |_env|\n        [0, 1, 2]\n      end\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      message = parsed.first\n\n      message[\"channel\"].must_equal \"/__status\"\n      message[\"data\"].must_equal(\"/foo\" => 1)\n\n      @bus.group_ids_lookup do |_env|\n        [1, 7, 4, 100]\n      end\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"can decode a JSON encoded request\" do\n      id = @bus.last_id('/foo')\n      @bus.publish(\"/foo\", json: true)\n      post(\"/message-bus/1234\",\n           JSON.generate('/foo' => id),\n           \"CONTENT_TYPE\" => \"application/json\")\n      JSON.parse(last_response.body).first[\"data\"].must_equal('json' => true)\n    end\n\n    it \"should tell Rack to skip committing the session\" do\n      post \"/message-bus/1234\", {}, { \"rack.session.options\" => {} }\n      last_request.env[\"rack.session.options\"][:skip].must_equal true\n    end\n\n    describe \"on_middleware_error handling\" do\n      it \"allows error handling of middleware failures\" do\n        @bus.on_middleware_error do |_env, err|\n          if ArgumentError === err\n            [407, {}, []]\n          end\n        end\n\n        @bus.group_ids_lookup do |_env|\n          raise ArgumentError\n        end\n\n        post(\"/message-bus/1234\",\n             JSON.generate('/foo' => 1),\n             \"CONTENT_TYPE\" => \"application/json\")\n\n        last_response.status.must_equal 407\n      end\n\n      it \"does not handle exceptions from downstream middleware\" do\n        @bus.on_middleware_error do |_env, err|\n          [404, {}, []]\n        end\n\n        get(\"/\")\n\n        last_response.status.must_equal 500\n        last_response.body.must_equal 'should not be called'\n      end\n    end\n\n    describe \"messagebus.channels env support\" do\n      let(:extra_middleware) do\n        Class.new do\n          attr_reader :app\n\n          def initialize(app)\n            @app = app\n          end\n\n          def call(env)\n            @app.call(env.merge('message_bus.channels' => { '/foo' => 0 }))\n          end\n        end\n      end\n\n      it \"should respect messagebus.channels in the environment to force channels\" do\n        @message_bus_middleware = @async_middleware.app.app\n        foo_id = @bus.publish(\"/foo\", \"testfoo\")\n        bar_id = @bus.publish(\"/bar\", \"testbar\")\n\n        post \"/message-bus/ABCD\",\n             '/foo' => foo_id - 1\n\n        parsed = JSON.parse(last_response.body)\n        parsed.first['data'].must_equal 'testfoo'\n\n        post \"/message-bus/ABCD\",\n             '/bar' => bar_id - 1\n\n        parsed = JSON.parse(last_response.body)\n        parsed.first['data'].must_equal 'testfoo'\n      end\n    end\n  end\nend\n"], "fixing_code": ["Unreleased\n\n  - FIX: Prevent simple polling from clobbering the session\n  - SECURITY: Fix path traversal on diagnostics route.\n\n31-05-2021\n\n- Version 3.3.6\n\n  - FEATURE: Introduce support for transport codecs\n  - FIX: event subscription leak in JS after start/stop/start sequence\n  - FEATURE: MessageBus.onVisibilityChange() can be used to trigger a visibility change check by hand\n\n28-04-2021\n\n- Version 3.3.5\n\n  - PERF: Optimised CORS preflight handling\n  - FEATURE: Enable CORS preflight caching\n  - FEATURE: Removed trailing cache buster from message bus polls\n  - PERF: Improved delay poll timeout for cases where a tab moves in and out of the background\n\n02-10-2020\n\n- Version 3.3.4\n\n  - FIX: Remove trailing comma incorrectly added in ec60d8865.\n\n18-09-2020\n\n- Version 3.3.3\n\n  - FIX: `queue_in_memory` option not being passed to the backends.\n  - FIX: `MessageBus::DistributedCache#publish` should raise on error.\n\n    On the redis backend, any errors encountered during `MessageBus#publish`\n    will add the message into an in memory queue and silently swallow the\n    error. While this is behavior is OK for normal message_bus usage, it may\n    lead to inconsistency when using `DistributedCache`. If a process\n    doesn't publish successfully to another process, it will still update\n    its in memory cache leaving the other processes unaware. As such, the\n    distributed cache is out of sync and will require another successful\n    write to the cache to resync all the caches.\n\n15-09-2020\n\n- Version 3.3.2\n\n  - FIX: In the JavaScript client throw when when lastId is given but is not a number.\n  - FEATURE: raise when attempting to publish to invalid targets\n  - Log when DistributedCache encounters an error when publishing.\n\n09-06-2020\n\n- Version 3.3.1\n\n  - FIX: Disconnect Redis conn when rescuing errors in global subscribe.\n  - FIX: `MessageBus::Backends::Redis#global_subscribe` not closing Redis connections.\n\n15-05-2020\n\n- Version 3.3.0\n\n   - FEATURE: `MessageBus.base_route=` to alter the route that message bus will listen on.\n\n07-05-2020\n\n- Version 3.2.0\n\n   - FIX: compatibility with Rails 6.0.3, note: apps without ActionDispatch::Flash may stop working after this upgrade\n   to correct this disable middleware injection with `config.skip_message_bus_middleware = true` and configure middleware by hand with `app.middleware.use(MessageBus::Rack::Middleware)`\n\n28-04-2020\n\n- Version 3.1.0\n\n  - FEATURE: `MessageBus#register_client_message_filter` to register a custom filter so that messages can be inspected and filtered away from clients.\n\n27-04-2020\n\n- Version 3.0.0\n\n  - Drop support for Ruby 2.3\n  - FIX: Don't publish message to intersection of `user_ids` and `group_ids` - instead use the union, this is a behavior change, hence a new major release.\n\n26-03-2020\n\n- Version 2.2.4\n\n  - FEATURE: shouldLongPollCallback optional setting which allows overriding decision about long polling\n\n18-10-2019\n\n- Version 2.2.3\n\n  - FIX: Protect redis config from being manipulated in backend\n\n09-08-2019\n\n- Version 2.2.2\n\n  - FEATURE: Support rate limiting by server, 429 status codes are respected and we hold off as needed\n\n  - FIX: In the redis backend make the `is_readonly?` method compatible with the redis gem both pre and post v4.0 when the `client` attribute was removed\n\n\n30-04-2019\n\n- Version 2.2.1\n\n  - FIX: No longer handles exceptions raised in downstream middleware via `on_middleware_error`\n\n28-01-2019\n\n- Version 2.2.0\n\n  - FIX: Ruby HTTP Client not backing off polling on error.\n\n11-12-2018\n\n- Version 2.2.0.pre.2\n\n  - FEATURE: Re-wrote diagnostics UI using React\n  - FEATURE: MessageBus HTTP Ruby Client\n\n30-11-2018\n\n- Version 2.2.0.pre.1\n\n  - FIX: diagnostics stopped working cause a private method was invoked on self\n\n30-11-2018\n\n- Version 2.2.0.pre\n\n- FIX: In redis backend we now expire the key used to track channel id this can cause a redis key leak\n    with large amounts of subscriptions that go away\n- FEATURE: Much extra implementation documentation, and some improvements to usage documentation.\n- FEATURE: Improvements to development workflow:\n  - Fully docker-based development and testing, with no other dependencies.\n  - More stringent Rubocop enforcement and greater compliance.\n  - Testing supported Ruby versions\n  - Better test coverage of some features\n  - Improved testing and assertion of the differences between backends\n  - More stable tests - now pass pretty much every run\n  - Documentation syntax is verified as part of testing\n- FEATURE: Ruby 2.2.0 is no longer supported as it is EOL\n- FEATURE: Better feature parity between backends:\n  - Adds support for backlog expiry to memory backend\n  - Support setting backlog expiry on publication w/ Postgres\n  - Supports setting backlog size on publication for memory/postgres\n- FEATURE: `MessageBus.off` now prevents the server subscription from starting up.\n- FEATURE: Trims unused parts of the public API:\n  - Methods removed:\n    * ConnectionManager#stats (never used and the ConnectionManager is not exposed to application code)\n    * Client#cancel (effectively duplicate of Client#close and the Client is only available via the ConnectionManager, thus not available to application code)\n\n  - Methods made private:\n    * MessageBus::Implementation#encode_channel_name\n    * MessageBus::Implementation#decode_channel_name\n    * Client#in_async?\n    * Client#ensure_closed!\n    * ConnectionManager#subscribe_client\n    * Diagnostics.full_process_path\n    * Diagnostics.hostname\n    * MessageBus::Rack::Diagnostics#js_asset\n    * MessageBus::Rack::Diagnostics#generate_script_tag\n    * MessageBus::Rack::Diagnostics#file_hash\n    * MessageBus::Rack::Diagnostics#asset_contents\n    * MessageBus::Rack::Diagnostics#asset_path\n    * MessageBus::Rack::Diagnostics#index\n    * MessageBus::Rack::Diagnostics#translate_handlebars\n    * MessageBus::Rack::Diagnostics#indent\n    * MessageBus::Rack::Middleware#start_listener\n    * MessageBus::Rack::Middleware#close_db_connection!\n    * MessageBus::Rack::Middleware#add_client_with_timeout\n\n  - Methods switched from protected to private:\n    * MessageBus::Implementation#global?\n    * MessageBus::Implementation#decode_message!\n    * MessageBus::Implementation#replay_backlog\n    * MessageBus::Implementation#subscribe_impl\n    * MessageBus::Implementation#unsubscribe_impl\n    * MessageBus::Implementation#ensure_subscriber_thread\n    * MessageBus::Implementation#new_subscriber_thread\n    * MessageBus::Implementation#global_subscribe_thread\n    * MessageBus::Implementation#multi_each\n    * Client#write_headers\n    * Client#write_chunk\n    * Client#write_and_close\n    * Client#messages_to_json\n\n15-10-2018\n\n- Version 2.1.6\n\n- FEATURE: `MessageBus.publish` accepts option `site_id` to publish to a site\n- FEATURE: Added MessageBus::DistributedCache for cross process caching\n- PERF: Use monotonic times in timer thread\n- FEATURE: min poll interval is now configurable client side\n\n16-05-2018\n\n- Version 2.1.5\n\n- FIX: In some cases a 30 second initial delay could happen cause client lost info about long poller\n\n20-04-2018\n\n- Version 2.1.4\n\n- FIX: Subtle issue where poll timeout may not be cleared causing multiple concurrent polls\n- FIX: Add extra protection for poller to ensure there is never a case where multiple ajax happens concurrently\n\n09-01-2018\n\n- Version 2.1.2\n\n- FEATURE: minHiddenPollInterval set to 1500ms out of the box, ensures we never do hidden tab\n   polls at a high rate if tons of tabs are open\n- FEATURE: added random 500ms to delayed polls to increase tab entropy\n\n18-12-2017\n\n- Version 2.1.1\n\n- FEATURE: allow setting of max_backlog_size and max_backlog_age on publish for redis provider\n\n18-12-2017\n\n- Version 2.1.0\n\n- FEATURE: you can now lookup last N messages on channel on subscribe from JavaScript\n   Subscribe at position (-1 - numberOfMessages) from the client\n\n24-11-2017\n\n- Version 2.0.9\n\n- PERF: faster serialization of messages\n- FEATURE: on backend flush web clients will resume and continue to get all new messages\n\n06-10-2017\n\n- Version 2.0.8\n\n- Fix: Make redis readonly detection more robust\n\n02-10-2017\n\n- Version 2.0.7\n\n- Fix/Feature: use LUA script for publishing to bus, this eliminates a race condition\n   and ensures that we are never stuck in a multi transaction by mistake\n\n\n29-09-2017\n\n- Version 2.0.6\n\n- Fix: correct after_fork so it correctly disconnects redis\n- Fix: correct message_bus #destroy used in tests to clean up spec (deadlock)\n- Fix: deliver backlog unconditionally when polling (and not long polling)\n\n16-08-2017\n\n- Version 2.0.5\n\n- Quick fix, build on earlier version of Ruby cause https://github.com/rubygems/rubygems/issues/1448 is still open\n\n- Version 2.0.3\n- Fix: broken MessageBus.redis_config\n- Perf: publish status message for filtered messages\n- Perf: add frozen strings to save on memory\n- Feature: improved logging when messages are dropped\n- Fix: handle missing actiondispatch flash\n\n25-08-2016\n\n- Version 2.0.2\n- Feature: Add on_middleware_error callback for remapping middleware errors to HTTP results\n\n\n25-07-2016\n\n- Feature: Add JavaScript MessageBus.status() function\n\n\n21-06-2016\n\n- Version 2.0.1\n- Fix: build using old ruby cause new ruby breaks stuff @sam\n\n21-06-2016\n\n- Version 2.0.0\n- Fix: forked process terminates parent more cleanly (does not kill -9 parent if already terminated) @uri\n- Fix: add async true explicitly on ajax reqs to ensure it always works even if disabled by globally @washu\n\n11-05-2016\n\n- Version 2.0.0.beta.11\n- Fix: for https://github.com/rubygems/rubygems/issues/1448 which is still broken, build under Ruby 2.0\n\n11-05-2016\n\n- Version 2.0.0.beta.10\n- Fix: for https://github.com/rubygems/rubygems/issues/1448\n\n11-05-2016\n\n- Version 2.0.0.beta.9\n- Fix: requests without content type were erroring out, breaks CORS\n\n27-04-2016\n\n- Version 2.0.0.beta.8\n- Fix: exception raised sometimes when subscribing at a particular position\n\n26-04-2016\n\n- Version 2.0.0.beta.7\n\n- Feature: Support custom HTTP headers without depending on jQuery @nathanstitt\n- Feature: Allow subscribe at a particular position from server side @sam\n\n29-02-2016\n\n- Version 2.0.0.beta.6\n\n- Feature: Support standalone operation without depending on jQuery @nathanstitt\n- Feature: Support a noconflict mode @nathanstitt\n- Feature: Support JSON POST payload @nathanstitt\n\n29-02-2016\n\n- Version 2.0.0.beta.5\n\n- Fix: JavaScript unsubscribe was not updating publicly visible MessageBus.callbacks @sam\n- Fix: When MessageBus is talking to a readonly redis buffering may cause a infinite loop @tgxworld\n\n- Version 2.0.0.beta.4\n\n- Feature: allow verbose redis logging by specifying `enable_redis_logger` in config, default disabled\n\n- Version 2.0.0.beta.3\n\n- Feature: Postgresql backend @jeremyevans\n- Breaking Change: Configuration API changed see Readme for details @jeremyevans\n- Breaking Change: Remove runtime dependency on Redis @jeremyevans\n- Dev: Convert all specs to minitest @jeremyevans\n- Feature: Support passing channels to Rack middleware via env['message_bus.channels'] via @jeremyevans\n\n03-01-2016\n\n- Version 2.0.0.beta.2\n- Fix: Remove stray console.log\n\n- Version 2.0.0.beta.1\n- Feature: add support for chunked encoding transport, this significnatlly improves long polling performance\n- Feature: strip around_filters and client filters, which were speculative\n- Fix: Message delivery race condition when a message was published just as long poll started. Ben Langfeld\n- Feature: strip support for message_handlers, speculative feature that was not used\n\n09-12-2015\n\n- Version 1.1.1\n- Fix: In multisite config there was no way to specify site for last_id or backlog\n   to resolve overrides were added to #last_id and #backlog, MessageBus::Client now\n   uses the new overrides\n\n07-12-2015\n\n- Version 1.1.0\n- Fix: keep track of client sequence on server, abandon old subscribes\n- Fix: rare concurrency issue when subscribing concurrently\n- Feature: remove most jQuery dependency from message-bus.js\n\n09-07-2015\n- Version 1.0.16\n- Fix: correct edge cases around keepalive checks on bus\n\n09-07-2015\n- Version 1.0.15\n- Feature: MessageBus.reliable_pub_sub.max_backlog_age (in secs) configurable (default to 7 days)\n- Fix: API for MessageBus.backlog(\"/bla\") was returning global backlog by mistake\n- Change: Max global backlog size reduced to 2000 elements\n\n08-06-2015\n- Version 1.0.14\n- Fix: we can not use Thread#kill best keepalive can do is terminate process cleanly\n- Feature: you can opt-out of keepalive with MessageBus.keepalive_timeout = 0\n\n08-06-2015\n- Version 1.0.13\n- Fix: on global subscribe reconnect replay missed messages\n- Feature: keepalive tests for global subscribe, catches hung redis connections\n\n28-05-2015\n- Version 1.0.12\n- Feature: Support client_id targeted message\n\n06-05-2015\n- Version 1.0.11\n- Fix: race condition in TimerThread\n\n01-05-2015\n- Version: 1.0.10\n- Feature: no longer depends on EventMachine (only used for Thin backend)\n- Feature: reliable pub sub will queue messages in memory if redis is readonly, configurable\n- Fix: if redis is flushed we will continue to deliver messages\n\n23-03-2015\n- Version 1.0.9\n- Fix: inherit off StandardError not Exception for all exceptions raised\n\n20-03-2015\n- Version 1.0.8\n- Fix: aggressive short polling in background\n\n16-03-2015\n- Version 1.0.7\n- Feature: added pause and resume methods\n\n03-02-2015\n- Version 1.0.6\n- Fix: global backlog not truncating correctly\n\n23-09-2014\n- Version 1.0.5\n- Fix: missing custom headers from long polls\n\n23-09-2014\n- Version 1.0.4\n- Change: MessageBus.access_control_allow_origin_lookup to extra_response_headers_lookup\n\n23-09-2014\n- Version 1.0.3\n- Change: MessageBus.access_control_allow_origin to MessageBus.access_control_allow_origin_lookup\n\n23-09-2014\n- Version 1.0.2\n- Feature: MessageBus.access_control_allow_origin to control origin header\n\n23-09-2014\n- Version 1.0.1\n- Feature: $.ajax dependency can be passed in.\n- Feature: unsubscribe accepts a second param for the function to unsubscribe.\n\n22-09-2014\n- Version 1.0.0\n- Feature: add backgroundCallbackInterval - interval to send polls when page is in the background\n- Feature: issue a long poll as soon as page moves into the foreground\n\n11-08-2014\n- Version 0.9.5\n- Fix: release db connection a lot earlier for long polling (rails defer closes)\n\n13-01-2014\n- Version 0.9.4\n- Added support for /global/ channel to publish messages across a multisite\n- Cleaned up test harness so it uses local bus as opposed to global\n- Fix bug where we could subscribe to a channel but miss starting messages\n- Added method for destroying a local MessageBus instance\n- ensure_reactor could say the reactor is running, but it was not, on first call\n\n06-12-2013\n- Version 0.9.3.2\n- Fix permissions in gem\n\n05-12-2013\n- Version 0.9.3.1\n- Add MessageBus.diagnostics() for diagnosing bus issues client side\n- Add more robustness to JavaScript, if callbacks used to fail they would halt the chain\n\n03-12-2013\n- Version 0.9.3\n- Remove thin dependency\n- Improve robustness under failure conditions\n\n30-09-2013\n- Fix failures in Ruby 1.9\n- Set up rack hijack by default in light of passengers new setting\n", "# frozen_string_literal: true\n\nmodule MessageBus::Rack; end\n\n# Accepts requests from clients interested in using diagnostics functionality\n# @see MessageBus::Diagnostics\nclass MessageBus::Rack::Diagnostics\n  # @param [Proc] app the rack app\n  # @param [Hash] config\n  # @option config [MessageBus::Instance] :message_bus (`MessageBus`) a specific instance of message_bus\n  def initialize(app, config = {})\n    @app = app\n    @bus = config[:message_bus] || MessageBus\n  end\n\n  JS_ASSETS = %w{\n    jquery-1.8.2.js\n    react.js\n    react-dom.js\n    babel.min.js\n    message-bus.js\n    application.jsx\n  }\n\n  # Process an HTTP request from a subscriber client\n  # @param [Rack::Request::Env] env the request environment\n  def call(env)\n    return @app.call(env) unless env['PATH_INFO'].start_with? \"#{@bus.base_route}message-bus/_diagnostics\"\n\n    route = env['PATH_INFO'].split(\"#{@bus.base_route}message-bus/_diagnostics\")[1]\n\n    if @bus.is_admin_lookup.nil? || !@bus.is_admin_lookup.call(env)\n      return [403, {}, ['not allowed']]\n    end\n\n    return index unless route\n\n    if route == '/discover'\n      user_id = @bus.user_id_lookup.call(env)\n      @bus.publish('/_diagnostics/discover', user_id: user_id)\n      return [200, {}, ['ok']]\n    end\n\n    if route =~ /^\\/hup\\//\n      hostname, pid = route.split('/hup/')[1].split('/')\n      @bus.publish('/_diagnostics/hup', hostname: hostname, pid: pid.to_i)\n      return [200, {}, ['ok']]\n    end\n\n    asset = route.split('/assets/')[1]\n\n    if asset && JS_ASSETS.include?(asset)\n      content = asset_contents(asset)\n      return [200, { 'Content-Type' => 'application/javascript;charset=UTF-8' }, [content]]\n    end\n\n    [404, {}, ['not found']]\n  end\n\n  private\n\n  def js_asset(name, type = \"text/javascript\")\n    return generate_script_tag(name, type) unless @bus.cache_assets\n\n    @@asset_cache ||= {}\n    @@asset_cache[name] ||= generate_script_tag(name, type)\n    @@asset_cache[name]\n  end\n\n  def generate_script_tag(name, type)\n    \"<script src='/message-bus/_diagnostics/assets/#{name}?#{file_hash(name)}' type='#{type}'></script>\"\n  end\n\n  def file_hash(asset)\n    require 'digest/sha1'\n    Digest::SHA1.hexdigest(asset_contents(asset))\n  end\n\n  def asset_contents(asset)\n    File.open(asset_path(asset)).read\n  end\n\n  def asset_path(asset)\n    File.expand_path(\"../../../../assets/#{asset}\", __FILE__)\n  end\n\n  def script_tags\n    tags = []\n\n    JS_ASSETS.each do |asset|\n      type =\n        if asset.end_with?('.js')\n          'text/javascript'\n        elsif asset.end_with?('.jsx')\n          'text/jsx'\n        end\n\n      tags << js_asset(asset, type)\n    end\n\n    tags.join(\"\\n\")\n  end\n\n  def index\n    html = <<~HTML\n      <!DOCTYPE html>\n      <html>\n        <head>\n        </head>\n        <body>\n          <div id=\"app\"></div>\n\n          #{script_tags}\n        </body>\n      </html>\n    HTML\n\n    [200, { \"content-type\" => \"text/html;\" }, [html]]\n  end\nend\n", "# frozen_string_literal: true\n# coding: utf-8\n\nrequire_relative '../../../spec_helper'\nrequire 'message_bus'\nrequire 'rack/test'\n\ndescribe MessageBus::Rack::Middleware do\n  include Rack::Test::Methods\n  let(:extra_middleware) { nil }\n  let(:base_route) { nil }\n\n  before do\n    bus = @bus = MessageBus::Instance.new\n    @bus.configure(test_config_for_backend(CURRENT_BACKEND))\n    @bus.long_polling_enabled = false\n    @bus.base_route = base_route if base_route\n\n    e_m = extra_middleware\n    builder = Rack::Builder.new {\n      use FakeAsyncMiddleware, message_bus: bus\n      use e_m if e_m\n      use MessageBus::Rack::Middleware, message_bus: bus\n      run lambda { |_env| [500, { 'Content-Type' => 'text/html' }, 'should not be called'] }\n    }\n\n    @async_middleware = builder.to_app\n    @message_bus_middleware = @async_middleware.app\n  end\n\n  after do\n    @message_bus_middleware.stop_listener\n    @bus.reset!\n    @bus.destroy\n  end\n\n  def app\n    @async_middleware\n  end\n\n  module LongPolling\n    extend Minitest::Spec::DSL\n\n    before do\n      @bus.long_polling_enabled = true\n    end\n\n    describe \"with altered base_route\" do\n      let(:base_route) { \"/base/route/\" }\n\n      it \"should respond as normal\" do\n        post \"/base/route/message-bus/ABC?dlp=t\", '/foo1' => 0\n        @async_middleware.in_async?.must_equal false\n        last_response.ok?.must_equal true\n      end\n    end\n\n    it \"should respond right away if dlp=t\" do\n      post \"/message-bus/ABC?dlp=t\", '/foo1' => 0\n      @async_middleware.in_async?.must_equal false\n      last_response.ok?.must_equal true\n    end\n\n    it \"should respond with a 404 if the client_id is missing\" do\n      post \"/message-bus/?dlp=t\", '/foo1' => 0\n      last_response.not_found?.must_equal true\n    end\n\n    it \"should respond right away to long polls that are polling on -1 with the last_id\" do\n      post \"/message-bus/ABC\", '/foo' => -1\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n    end\n\n    it \"should respond to long polls when data is available\" do\n      middleware = @async_middleware\n      bus = @bus\n\n      @bus.extra_response_headers_lookup do |_env|\n        { \"FOO\" => \"BAR\" }\n      end\n\n      Thread.new do\n        wait_for(2000) { middleware.in_async? }\n        bus.publish \"/foo\", \"\u05dd\u05d5\u05b9\u05dc\u05e9\u05b8\u05c1\"\n      end\n\n      post \"/message-bus/ABC\", '/foo' => nil\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n      parsed[0][\"data\"].must_equal \"\u05dd\u05d5\u05b9\u05dc\u05e9\u05b8\u05c1\"\n\n      last_response.headers[\"FOO\"].must_equal \"BAR\"\n    end\n\n    it \"should timeout within its alloted slot\" do\n      begin\n        @bus.long_polling_interval = 10\n        s = Time.now.to_f * 1000\n        post \"/message-bus/ABC\", '/foo' => nil\n        # allow for some jitter\n        (Time.now.to_f * 1000 - s).must_be :<, 100\n      ensure\n        @bus.long_polling_interval = 5000\n      end\n    end\n  end\n\n  describe \"thin async\" do\n    before do\n      @async_middleware.simulate_thin_async\n    end\n\n    include LongPolling\n  end\n\n  describe \"hijack\" do\n    before do\n      @async_middleware.simulate_hijack\n      @bus.rack_hijack_enabled = true\n    end\n\n    include LongPolling\n  end\n\n  describe \"start listener\" do\n    let(:app) { ->(_) { [200, {}, []] } }\n\n    it \"never subscribes\" do\n      bus = MessageBus::Instance.new\n      bus.off\n\n      middleware = MessageBus::Rack::Middleware.new(app, message_bus: bus)\n\n      middleware.started_listener.must_equal false\n    end\n  end\n\n  describe \"diagnostics\" do\n    it \"should return a 403 if an unauthorized user attempts to get at the _diagnostics path\" do\n      get \"/message-bus/_diagnostics\"\n      last_response.status.must_equal 403\n    end\n\n    it \"should get a 200 with html for an authorized user\" do\n      def @bus.is_admin_lookup\n        proc { |_| true }\n      end\n\n      get \"/message-bus/_diagnostics\"\n      last_response.status.must_equal 200\n    end\n\n    describe \"with an altered base_route\" do\n      let(:base_route) { \"/base/route/\" }\n\n      it \"should get a 200 with html for an authorized user\" do\n        def @bus.is_admin_lookup\n          proc { |_| true }\n        end\n\n        get \"/base/route/message-bus/_diagnostics\"\n        last_response.status.must_equal 200\n      end\n    end\n\n    it \"should get the script it asks for\" do\n      def @bus.is_admin_lookup\n        proc { |_| true }\n      end\n\n      get \"/message-bus/_diagnostics/assets/message-bus.js\"\n      last_response.status.must_equal 200\n      last_response.content_type.must_equal \"application/javascript;charset=UTF-8\"\n    end\n\n    it \"should return 404 for invalid assets path\" do\n      def @bus.is_admin_lookup\n        proc { |_| true }\n      end\n\n      get \"/message-bus/_diagnostics/assets/../Gemfile\"\n      last_response.status.must_equal 404\n    end\n  end\n\n  describe \"polling\" do\n    before do\n      @bus.long_polling_enabled = false\n    end\n\n    it \"should include access control headers\" do\n      @bus.extra_response_headers_lookup do |_env|\n        { \"FOO\" => \"BAR\" }\n      end\n\n      client_id = \"ABCD\"\n\n      # client always keeps a list of channels with last message id they got on each\n      post \"/message-bus/#{client_id}\",\n           '/foo' => nil,\n           '/bar' => nil\n\n      last_response.headers[\"FOO\"].must_equal \"BAR\"\n    end\n\n    it \"should respond with a 200 to a subscribe\" do\n      client_id = \"ABCD\"\n\n      # client always keeps a list of channels with last message id they got on each\n      post \"/message-bus/#{client_id}\",\n           '/foo' => nil,\n           '/bar' => nil\n\n      last_response.ok?.must_equal true\n    end\n\n    # this means we recover from redis reset\n    it \"should understand that larger than position is the same as -1\" do\n      @bus.publish('/foo', 'bar')\n      @bus.publish('/baz', 'test')\n      @bus.publish('/boom', 'bang')\n\n      post \"/message-bus/ABCD\",\n           '/foo' => 1_000_000,\n           '/baz' => @bus.last_id('/baz') + 1,\n           '/boom' => 1_000_000\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n      parsed[0][\"data\"][\"/boom\"].must_equal @bus.last_id(\"/boom\")\n    end\n\n    it \"should correctly understand that -1 means stuff from now onwards\" do\n      # even if allow chunked\n      @bus.chunked_encoding_enabled = true\n\n      @bus.publish('/foo', 'bar')\n      @bus.publish('/baz', 'test')\n      @bus.publish('/boom', 'bang')\n\n      post \"/message-bus/ABCD\",\n           '/foo' => -1,\n           '/baz' => @bus.last_id('/baz') + 1,\n           '/boom' => -1\n\n      last_response.ok?.must_equal true\n      parsed = JSON.parse(last_response.body)\n\n      parsed.length.must_equal 1\n      parsed[0][\"channel\"].must_equal \"/__status\"\n      parsed[0][\"data\"][\"/foo\"].must_equal @bus.last_id(\"/foo\")\n      parsed[0][\"data\"][\"/boom\"].must_equal @bus.last_id(\"/boom\")\n    end\n\n    it \"should respond with the data if messages exist in the backlog\" do\n      id = @bus.last_id('/foo')\n\n      @bus.publish(\"/foo\", \"barbs\")\n      @bus.publish(\"/foo\", \"borbs\")\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id,\n           '/bar' => nil\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal \"barbs\"\n      parsed[1][\"data\"].must_equal \"borbs\"\n    end\n\n    it \"should use the correct client ID\" do\n      id = @bus.last_id('/foo')\n\n      client_id = \"aBc123\"\n      @bus.publish(\"/foo\", \"msg1\", client_ids: [client_id])\n      @bus.publish(\"/foo\", \"msg2\", client_ids: [\"not_me#{client_id}\"])\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal(\"msg1\")\n      parsed[1][\"data\"].wont_equal(\"msg2\")\n    end\n\n    it \"should use the correct client ID with additional path\" do\n      id = @bus.last_id('/foo')\n\n      client_id = \"aBc123\"\n      @bus.publish(\"/foo\", \"msg1\", client_ids: [client_id])\n      @bus.publish(\"/foo\", \"msg2\", client_ids: [\"not_me#{client_id}\"])\n\n      post \"/message-bus/#{client_id}/path/not/needed\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 2\n      parsed[0][\"data\"].must_equal(\"msg1\")\n      parsed[1][\"data\"].wont_equal(\"msg2\")\n    end\n\n    it \"should have no cross talk\" do\n      seq = 0\n      @bus.site_id_lookup do\n        (seq += 1).to_s\n      end\n\n      # published on channel 1\n      msg = @bus.publish(\"/foo\", \"test\")\n\n      # subscribed on channel 2\n      post \"/message-bus/ABCD\",\n           '/foo' => (msg - 1)\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 0\n    end\n\n    it \"should have global cross talk\" do\n      seq = 0\n      @bus.site_id_lookup do\n        (seq += 1).to_s\n      end\n\n      msg = @bus.publish(\"/global/foo\", \"test\")\n\n      post \"/message-bus/ABCD\",\n           '/global/foo' => (msg - 1)\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"should not get consumed messages\" do\n      @bus.publish(\"/foo\", \"barbs\")\n      id = @bus.last_id('/foo')\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 0\n    end\n\n    it \"should filter by user correctly\" do\n      id = @bus.publish(\"/foo\", \"test\", user_ids: [1])\n      @bus.user_id_lookup do |_env|\n        0\n      end\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n\n      message = parsed.first\n\n      message[\"channel\"].must_equal \"/__status\"\n      message[\"data\"].must_equal(\"/foo\" => 1)\n\n      @bus.user_id_lookup do |_env|\n        1\n      end\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"should filter by group correctly\" do\n      id = @bus.publish(\"/foo\", \"test\", group_ids: [3, 4, 5])\n      @bus.group_ids_lookup do |_env|\n        [0, 1, 2]\n      end\n\n      client_id = \"ABCD\"\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      message = parsed.first\n\n      message[\"channel\"].must_equal \"/__status\"\n      message[\"data\"].must_equal(\"/foo\" => 1)\n\n      @bus.group_ids_lookup do |_env|\n        [1, 7, 4, 100]\n      end\n\n      post \"/message-bus/#{client_id}\",\n           '/foo' => id - 1\n\n      parsed = JSON.parse(last_response.body)\n      parsed.length.must_equal 1\n    end\n\n    it \"can decode a JSON encoded request\" do\n      id = @bus.last_id('/foo')\n      @bus.publish(\"/foo\", json: true)\n      post(\"/message-bus/1234\",\n           JSON.generate('/foo' => id),\n           \"CONTENT_TYPE\" => \"application/json\")\n      JSON.parse(last_response.body).first[\"data\"].must_equal('json' => true)\n    end\n\n    it \"should tell Rack to skip committing the session\" do\n      post \"/message-bus/1234\", {}, { \"rack.session.options\" => {} }\n      last_request.env[\"rack.session.options\"][:skip].must_equal true\n    end\n\n    describe \"on_middleware_error handling\" do\n      it \"allows error handling of middleware failures\" do\n        @bus.on_middleware_error do |_env, err|\n          if ArgumentError === err\n            [407, {}, []]\n          end\n        end\n\n        @bus.group_ids_lookup do |_env|\n          raise ArgumentError\n        end\n\n        post(\"/message-bus/1234\",\n             JSON.generate('/foo' => 1),\n             \"CONTENT_TYPE\" => \"application/json\")\n\n        last_response.status.must_equal 407\n      end\n\n      it \"does not handle exceptions from downstream middleware\" do\n        @bus.on_middleware_error do |_env, err|\n          [404, {}, []]\n        end\n\n        get(\"/\")\n\n        last_response.status.must_equal 500\n        last_response.body.must_equal 'should not be called'\n      end\n    end\n\n    describe \"messagebus.channels env support\" do\n      let(:extra_middleware) do\n        Class.new do\n          attr_reader :app\n\n          def initialize(app)\n            @app = app\n          end\n\n          def call(env)\n            @app.call(env.merge('message_bus.channels' => { '/foo' => 0 }))\n          end\n        end\n      end\n\n      it \"should respect messagebus.channels in the environment to force channels\" do\n        @message_bus_middleware = @async_middleware.app.app\n        foo_id = @bus.publish(\"/foo\", \"testfoo\")\n        bar_id = @bus.publish(\"/bar\", \"testbar\")\n\n        post \"/message-bus/ABCD\",\n             '/foo' => foo_id - 1\n\n        parsed = JSON.parse(last_response.body)\n        parsed.first['data'].must_equal 'testfoo'\n\n        post \"/message-bus/ABCD\",\n             '/bar' => bar_id - 1\n\n        parsed = JSON.parse(last_response.body)\n        parsed.first['data'].must_equal 'testfoo'\n      end\n    end\n  end\nend\n"], "filenames": ["CHANGELOG", "lib/message_bus/rack/diagnostics.rb", "spec/lib/message_bus/rack/middleware_spec.rb"], "buggy_code_start_loc": [3, 14, 145], "buggy_code_end_loc": [3, 91, 181], "fixing_code_start_loc": [4, 15, 145], "fixing_code_end_loc": [5, 114, 189], "type": "CWE-22", "message": "message_bus is a messaging bus for Ruby processes and web clients. In versions prior to 3.3.7 users who deployed message bus with diagnostics features enabled (default off) are vulnerable to a path traversal bug, which could lead to disclosure of secret information on a machine if an unintended user were to gain access to the diagnostic route. The impact is also greater if there is no proxy for your web application as the number of steps up the directories is not bounded. For deployments which uses a proxy, the impact varies. For example, If a request goes through a proxy like Nginx with `merge_slashes` enabled, the number of steps up the directories that can be read is limited to 3 levels. This issue has been patched in version 3.3.7. Users unable to upgrade should ensure that MessageBus::Diagnostics is disabled.", "other": {"cve": {"id": "CVE-2021-43840", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-17T19:15:07.757", "lastModified": "2021-12-29T18:39:41.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "message_bus is a messaging bus for Ruby processes and web clients. In versions prior to 3.3.7 users who deployed message bus with diagnostics features enabled (default off) are vulnerable to a path traversal bug, which could lead to disclosure of secret information on a machine if an unintended user were to gain access to the diagnostic route. The impact is also greater if there is no proxy for your web application as the number of steps up the directories is not bounded. For deployments which uses a proxy, the impact varies. For example, If a request goes through a proxy like Nginx with `merge_slashes` enabled, the number of steps up the directories that can be read is limited to 3 levels. This issue has been patched in version 3.3.7. Users unable to upgrade should ensure that MessageBus::Diagnostics is disabled."}, {"lang": "es", "value": "message_bus es un bus de mensajer\u00eda para procesos Ruby y clientes web. En las versiones anteriores a 3.3.7, los usuarios que desplegaron el bus de mensajes con las caracter\u00edsticas de diagn\u00f3stico habilitadas (por defecto deshabilitadas) son vulnerables a un bug de salto de ruta, que podr\u00eda conllevar a una revelaci\u00f3n de informaci\u00f3n secreta en una m\u00e1quina si un usuario no intencionado accediera a la ruta de diagn\u00f3stico. El impacto tambi\u00e9n es mayor si no se presenta un proxy para su aplicaci\u00f3n web, ya que el n\u00famero de pasos por los directorios no est\u00e1 limitado. Para las implementaciones que usan un proxy, el impacto var\u00eda. Por ejemplo, si una petici\u00f3n pasa por un proxy como Nginx con \"merge_slashes\" habilitado, el n\u00famero de pasos hacia arriba en los directorios que pueden ser le\u00eddos est\u00e1 limitado a 3 niveles. Este problema ha sido parcheado en la versi\u00f3n 3.3.7. Los usuarios que no puedan actualizarse deber\u00e1n asegurarse de que MessageBus::Diagnostics est\u00e1 deshabilitado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:message_bus:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.3.7", "matchCriteriaId": "1BFAB388-520F-4B06-8DC0-2F6821BA0898"}]}]}], "references": [{"url": "https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/message_bus/security/advisories/GHSA-xmgj-5fh3-xjmm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba"}}