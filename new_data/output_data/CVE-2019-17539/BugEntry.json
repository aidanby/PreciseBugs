{"buggy_code": ["/*\n * utils for libavcodec\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * utils.\n */\n\n#include \"config.h\"\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/crc.h\"\n#include \"libavutil/frame.h\"\n#include \"libavutil/hwcontext.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/mem_internal.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/samplefmt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/thread.h\"\n#include \"avcodec.h\"\n#include \"decode.h\"\n#include \"hwaccel.h\"\n#include \"libavutil/opt.h\"\n#include \"mpegvideo.h\"\n#include \"thread.h\"\n#include \"frame_thread_encoder.h\"\n#include \"internal.h\"\n#include \"raw.h\"\n#include \"bytestream.h\"\n#include \"version.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdatomic.h>\n#include <limits.h>\n#include <float.h>\n#if CONFIG_ICONV\n# include <iconv.h>\n#endif\n\n#include \"libavutil/ffversion.h\"\nconst char av_codec_ffversion[] = \"FFmpeg version \" FFMPEG_VERSION;\n\nstatic AVMutex codec_mutex = AV_MUTEX_INITIALIZER;\n\nvoid av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n}\n\nvoid av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + AV_INPUT_BUFFER_PADDING_SIZE);\n}\n\nint av_codec_is_encoder(const AVCodec *codec)\n{\n    return codec && (codec->encode_sub || codec->encode2 ||codec->send_frame);\n}\n\nint av_codec_is_decoder(const AVCodec *codec)\n{\n    return codec && (codec->decode || codec->receive_frame);\n}\n\nint ff_set_dimensions(AVCodecContext *s, int width, int height)\n{\n    int ret = av_image_check_size2(width, height, s->max_pixels, AV_PIX_FMT_NONE, 0, s);\n\n    if (ret < 0)\n        width = height = 0;\n\n    s->coded_width  = width;\n    s->coded_height = height;\n    s->width        = AV_CEIL_RSHIFT(width,  s->lowres);\n    s->height       = AV_CEIL_RSHIFT(height, s->lowres);\n\n    return ret;\n}\n\nint ff_set_sar(AVCodecContext *avctx, AVRational sar)\n{\n    int ret = av_image_check_sar(avctx->width, avctx->height, sar);\n\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %d/%d\\n\",\n               sar.num, sar.den);\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        return ret;\n    } else {\n        avctx->sample_aspect_ratio = sar;\n    }\n    return 0;\n}\n\nint ff_side_data_update_matrix_encoding(AVFrame *frame,\n                                        enum AVMatrixEncoding matrix_encoding)\n{\n    AVFrameSideData *side_data;\n    enum AVMatrixEncoding *data;\n\n    side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_MATRIXENCODING);\n    if (!side_data)\n        side_data = av_frame_new_side_data(frame, AV_FRAME_DATA_MATRIXENCODING,\n                                           sizeof(enum AVMatrixEncoding));\n\n    if (!side_data)\n        return AVERROR(ENOMEM);\n\n    data  = (enum AVMatrixEncoding*)side_data->data;\n    *data = matrix_encoding;\n\n    return 0;\n}\n\nvoid avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P12LE:\n    case AV_PIX_FMT_YUVA422P12BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P12LE:\n    case AV_PIX_FMT_YUVA444P12BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV ||\n            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres ||\n        s->codec_id == AV_CODEC_ID_VP5  || s->codec_id == AV_CODEC_ID_VP6 ||\n        s->codec_id == AV_CODEC_ID_VP6F || s->codec_id == AV_CODEC_ID_VP6A\n    ) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}\n\nvoid avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);\n    int chroma_shift = desc->log2_chroma_w;\n    int linesize_align[AV_NUM_DATA_POINTERS];\n    int align;\n\n    avcodec_align_dimensions2(s, width, height, linesize_align);\n    align               = FFMAX(linesize_align[0], linesize_align[3]);\n    linesize_align[1] <<= chroma_shift;\n    linesize_align[2] <<= chroma_shift;\n    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);\n    *width              = FFALIGN(*width, align);\n}\n\nint avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)\n{\n    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)\n        return AVERROR(EINVAL);\n    pos--;\n\n    *xpos = (pos&1) * 128;\n    *ypos = ((pos>>1)^(pos<4)) * 128;\n\n    return 0;\n}\n\nenum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)\n{\n    int pos, xout, yout;\n\n    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {\n        if (avcodec_enum_to_chroma_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)\n            return pos;\n    }\n    return AVCHROMA_LOC_UNSPECIFIED;\n}\n\nint avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,\n                             enum AVSampleFormat sample_fmt, const uint8_t *buf,\n                             int buf_size, int align)\n{\n    int ch, planar, needed_size, ret = 0;\n\n    needed_size = av_samples_get_buffer_size(NULL, nb_channels,\n                                             frame->nb_samples, sample_fmt,\n                                             align);\n    if (buf_size < needed_size)\n        return AVERROR(EINVAL);\n\n    planar = av_sample_fmt_is_planar(sample_fmt);\n    if (planar && nb_channels > AV_NUM_DATA_POINTERS) {\n        if (!(frame->extended_data = av_mallocz_array(nb_channels,\n                                                sizeof(*frame->extended_data))))\n            return AVERROR(ENOMEM);\n    } else {\n        frame->extended_data = frame->data;\n    }\n\n    if ((ret = av_samples_fill_arrays(frame->extended_data, &frame->linesize[0],\n                                      (uint8_t *)(intptr_t)buf, nb_channels, frame->nb_samples,\n                                      sample_fmt, align)) < 0) {\n        if (frame->extended_data != frame->data)\n            av_freep(&frame->extended_data);\n        return ret;\n    }\n    if (frame->extended_data != frame->data) {\n        for (ch = 0; ch < AV_NUM_DATA_POINTERS; ch++)\n            frame->data[ch] = frame->extended_data[ch];\n    }\n\n    return ret;\n}\n\nvoid ff_color_frame(AVFrame *frame, const int c[4])\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int p, y, x;\n\n    av_assert0(desc->flags & AV_PIX_FMT_FLAG_PLANAR);\n\n    for (p = 0; p<desc->nb_components; p++) {\n        uint8_t *dst = frame->data[p];\n        int is_chroma = p == 1 || p == 2;\n        int bytes  = is_chroma ? AV_CEIL_RSHIFT(frame->width,  desc->log2_chroma_w) : frame->width;\n        int height = is_chroma ? AV_CEIL_RSHIFT(frame->height, desc->log2_chroma_h) : frame->height;\n        for (y = 0; y < height; y++) {\n            if (desc->comp[0].depth >= 9) {\n                for (x = 0; x<bytes; x++)\n                    ((uint16_t*)dst)[x] = c[p];\n            }else\n                memset(dst, c[p], bytes);\n            dst += frame->linesize[p];\n        }\n    }\n}\n\nint avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        int r = func(c, (char *)arg + i * size);\n        if (ret)\n            ret[i] = r;\n    }\n    emms_c();\n    return 0;\n}\n\nint avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        int r = func(c, arg, i, 0);\n        if (ret)\n            ret[i] = r;\n    }\n    emms_c();\n    return 0;\n}\n\nenum AVPixelFormat avpriv_find_pix_fmt(const PixelFormatTag *tags,\n                                       unsigned int fourcc)\n{\n    while (tags->pix_fmt >= 0) {\n        if (tags->fourcc == fourcc)\n            return tags->pix_fmt;\n        tags++;\n    }\n    return AV_PIX_FMT_NONE;\n}\n\n#if FF_API_CODEC_GET_SET\nMAKE_ACCESSORS(AVCodecContext, codec, AVRational, pkt_timebase)\nMAKE_ACCESSORS(AVCodecContext, codec, const AVCodecDescriptor *, codec_descriptor)\nMAKE_ACCESSORS(AVCodecContext, codec, int, lowres)\nMAKE_ACCESSORS(AVCodecContext, codec, int, seek_preroll)\nMAKE_ACCESSORS(AVCodecContext, codec, uint16_t*, chroma_intra_matrix)\n\nunsigned av_codec_get_codec_properties(const AVCodecContext *codec)\n{\n    return codec->properties;\n}\n\nint av_codec_get_max_lowres(const AVCodec *codec)\n{\n    return codec->max_lowres;\n}\n#endif\n\nint avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec){\n    return !!(codec->caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM);\n}\n\nstatic int64_t get_bit_rate(AVCodecContext *ctx)\n{\n    int64_t bit_rate;\n    int bits_per_sample;\n\n    switch (ctx->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n    case AVMEDIA_TYPE_DATA:\n    case AVMEDIA_TYPE_SUBTITLE:\n    case AVMEDIA_TYPE_ATTACHMENT:\n        bit_rate = ctx->bit_rate;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n        bit_rate = bits_per_sample ? ctx->sample_rate * (int64_t)ctx->channels * bits_per_sample : ctx->bit_rate;\n        break;\n    default:\n        bit_rate = 0;\n        break;\n    }\n    return bit_rate;\n}\n\n\nstatic void ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n{\n    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)\n        ff_mutex_lock(&codec_mutex);\n}\n\nstatic void ff_unlock_avcodec(const AVCodec *codec)\n{\n    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)\n        ff_mutex_unlock(&codec_mutex);\n}\n\nint attribute_align_arg ff_codec_open2_recursive(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n\n    ff_unlock_avcodec(codec);\n\n    ret = avcodec_open2(avctx, codec, options);\n\n    ff_lock_avcodec(avctx, codec);\n    return ret;\n}\n\nint attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    if (avctx->codec &&\n        (codec_init_ok ||\n         (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n        avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}\n\nvoid avsubtitle_free(AVSubtitle *sub)\n{\n    int i;\n\n    for (i = 0; i < sub->num_rects; i++) {\n        av_freep(&sub->rects[i]->data[0]);\n        av_freep(&sub->rects[i]->data[1]);\n        av_freep(&sub->rects[i]->data[2]);\n        av_freep(&sub->rects[i]->data[3]);\n        av_freep(&sub->rects[i]->text);\n        av_freep(&sub->rects[i]->ass);\n        av_freep(&sub->rects[i]);\n    }\n\n    av_freep(&sub->rects);\n\n    memset(sub, 0, sizeof(*sub));\n}\n\nav_cold int avcodec_close(AVCodecContext *avctx)\n{\n    int i;\n\n    if (!avctx)\n        return 0;\n\n    if (avcodec_is_open(avctx)) {\n        FramePool *pool = avctx->internal->pool;\n        if (CONFIG_FRAME_THREAD_ENCODER &&\n            avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {\n            ff_frame_thread_encoder_free(avctx);\n        }\n        if (HAVE_THREADS && avctx->internal->thread_ctx)\n            ff_thread_free(avctx);\n        if (avctx->codec && avctx->codec->close)\n            avctx->codec->close(avctx);\n        avctx->internal->byte_buffer_size = 0;\n        av_freep(&avctx->internal->byte_buffer);\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n\n        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)\n            av_buffer_pool_uninit(&pool->pools[i]);\n        av_freep(&avctx->internal->pool);\n\n        if (avctx->hwaccel && avctx->hwaccel->uninit)\n            avctx->hwaccel->uninit(avctx);\n        av_freep(&avctx->internal->hwaccel_priv_data);\n\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal);\n    }\n\n    for (i = 0; i < avctx->nb_coded_side_data; i++)\n        av_freep(&avctx->coded_side_data[i].data);\n    av_freep(&avctx->coded_side_data);\n    avctx->nb_coded_side_data = 0;\n\n    av_buffer_unref(&avctx->hw_frames_ctx);\n    av_buffer_unref(&avctx->hw_device_ctx);\n\n    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n    av_freep(&avctx->priv_data);\n    if (av_codec_is_encoder(avctx->codec)) {\n        av_freep(&avctx->extradata);\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    }\n    avctx->codec = NULL;\n    avctx->active_thread_type = 0;\n\n    return 0;\n}\n\nconst char *avcodec_get_name(enum AVCodecID id)\n{\n    const AVCodecDescriptor *cd;\n    AVCodec *codec;\n\n    if (id == AV_CODEC_ID_NONE)\n        return \"none\";\n    cd = avcodec_descriptor_get(id);\n    if (cd)\n        return cd->name;\n    av_log(NULL, AV_LOG_WARNING, \"Codec 0x%x is not in the full list.\\n\", id);\n    codec = avcodec_find_decoder(id);\n    if (codec)\n        return codec->name;\n    codec = avcodec_find_encoder(id);\n    if (codec)\n        return codec->name;\n    return \"unknown_codec\";\n}\n\nsize_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag)\n{\n    int i, len, ret = 0;\n\n#define TAG_PRINT(x)                                              \\\n    (((x) >= '0' && (x) <= '9') ||                                \\\n     ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') ||  \\\n     ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\n\n    for (i = 0; i < 4; i++) {\n        len = snprintf(buf, buf_size,\n                       TAG_PRINT(codec_tag & 0xFF) ? \"%c\" : \"[%d]\", codec_tag & 0xFF);\n        buf        += len;\n        buf_size    = buf_size > len ? buf_size - len : 0;\n        ret        += len;\n        codec_tag >>= 8;\n    }\n    return ret;\n}\n\nvoid avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n{\n    const char *codec_type;\n    const char *codec_name;\n    const char *profile = NULL;\n    int64_t bitrate;\n    int new_line = 0;\n    AVRational display_aspect_ratio;\n    const char *separator = enc->dump_separator ? (const char *)enc->dump_separator : \", \";\n\n    if (!buf || buf_size <= 0)\n        return;\n    codec_type = av_get_media_type_string(enc->codec_type);\n    codec_name = avcodec_get_name(enc->codec_id);\n    profile = avcodec_profile_name(enc->codec_id, enc->profile);\n\n    snprintf(buf, buf_size, \"%s: %s\", codec_type ? codec_type : \"unknown\",\n             codec_name);\n    buf[0] ^= 'a' ^ 'A'; /* first letter in uppercase */\n\n    if (enc->codec && strcmp(enc->codec->name, codec_name))\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", enc->codec->name);\n\n    if (profile)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", profile);\n    if (   enc->codec_type == AVMEDIA_TYPE_VIDEO\n        && av_log_get_level() >= AV_LOG_VERBOSE\n        && enc->refs)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", %d reference frame%s\",\n                 enc->refs, enc->refs > 1 ? \"s\" : \"\");\n\n    if (enc->codec_tag)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s / 0x%04X)\",\n                 av_fourcc2str(enc->codec_tag), enc->codec_tag);\n\n    switch (enc->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        {\n            char detail[256] = \"(\";\n\n            av_strlcat(buf, separator, buf_size);\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \"%s\", enc->pix_fmt == AV_PIX_FMT_NONE ? \"none\" :\n                     av_get_pix_fmt_name(enc->pix_fmt));\n            if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&\n                enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)\n                av_strlcatf(detail, sizeof(detail), \"%d bpc, \", enc->bits_per_raw_sample);\n            if (enc->color_range != AVCOL_RANGE_UNSPECIFIED)\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n                            av_color_range_name(enc->color_range));\n\n            if (enc->colorspace != AVCOL_SPC_UNSPECIFIED ||\n                enc->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n                enc->color_trc != AVCOL_TRC_UNSPECIFIED) {\n                if (enc->colorspace != (int)enc->color_primaries ||\n                    enc->colorspace != (int)enc->color_trc) {\n                    new_line = 1;\n                    av_strlcatf(detail, sizeof(detail), \"%s/%s/%s, \",\n                                av_color_space_name(enc->colorspace),\n                                av_color_primaries_name(enc->color_primaries),\n                                av_color_transfer_name(enc->color_trc));\n                } else\n                    av_strlcatf(detail, sizeof(detail), \"%s, \",\n                                av_get_colorspace_name(enc->colorspace));\n            }\n\n            if (enc->field_order != AV_FIELD_UNKNOWN) {\n                const char *field_order = \"progressive\";\n                if (enc->field_order == AV_FIELD_TT)\n                    field_order = \"top first\";\n                else if (enc->field_order == AV_FIELD_BB)\n                    field_order = \"bottom first\";\n                else if (enc->field_order == AV_FIELD_TB)\n                    field_order = \"top coded first (swapped)\";\n                else if (enc->field_order == AV_FIELD_BT)\n                    field_order = \"bottom coded first (swapped)\";\n\n                av_strlcatf(detail, sizeof(detail), \"%s, \", field_order);\n            }\n\n            if (av_log_get_level() >= AV_LOG_VERBOSE &&\n                enc->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED)\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n                            av_chroma_location_name(enc->chroma_sample_location));\n\n            if (strlen(detail) > 1) {\n                detail[strlen(detail) - 2] = 0;\n                av_strlcatf(buf, buf_size, \"%s)\", detail);\n            }\n        }\n\n        if (enc->width) {\n            av_strlcat(buf, new_line ? separator : \", \", buf_size);\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \"%dx%d\",\n                     enc->width, enc->height);\n\n            if (av_log_get_level() >= AV_LOG_VERBOSE &&\n                (enc->width != enc->coded_width ||\n                 enc->height != enc->coded_height))\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \" (%dx%d)\", enc->coded_width, enc->coded_height);\n\n            if (enc->sample_aspect_ratio.num) {\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                          enc->width * (int64_t)enc->sample_aspect_ratio.num,\n                          enc->height * (int64_t)enc->sample_aspect_ratio.den,\n                          1024 * 1024);\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \" [SAR %d:%d DAR %d:%d]\",\n                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,\n                         display_aspect_ratio.num, display_aspect_ratio.den);\n            }\n            if (av_log_get_level() >= AV_LOG_DEBUG) {\n                int g = av_gcd(enc->time_base.num, enc->time_base.den);\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", %d/%d\",\n                         enc->time_base.num / g, enc->time_base.den / g);\n            }\n        }\n        if (encode) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", q=%d-%d\", enc->qmin, enc->qmax);\n        } else {\n            if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", Closed Captions\");\n            if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", lossless\");\n        }\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        av_strlcat(buf, separator, buf_size);\n\n        if (enc->sample_rate) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \"%d Hz, \", enc->sample_rate);\n        }\n        av_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n        if (enc->sample_fmt != AV_SAMPLE_FMT_NONE) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", %s\", av_get_sample_fmt_name(enc->sample_fmt));\n        }\n        if (   enc->bits_per_raw_sample > 0\n            && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \" (%d bit)\", enc->bits_per_raw_sample);\n        if (av_log_get_level() >= AV_LOG_VERBOSE) {\n            if (enc->initial_padding)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", delay %d\", enc->initial_padding);\n            if (enc->trailing_padding)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", padding %d\", enc->trailing_padding);\n        }\n        break;\n    case AVMEDIA_TYPE_DATA:\n        if (av_log_get_level() >= AV_LOG_DEBUG) {\n            int g = av_gcd(enc->time_base.num, enc->time_base.den);\n            if (g)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", %d/%d\",\n                         enc->time_base.num / g, enc->time_base.den / g);\n        }\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (enc->width)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", %dx%d\", enc->width, enc->height);\n        break;\n    default:\n        return;\n    }\n    if (encode) {\n        if (enc->flags & AV_CODEC_FLAG_PASS1)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", pass 1\");\n        if (enc->flags & AV_CODEC_FLAG_PASS2)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", pass 2\");\n    }\n    bitrate = get_bit_rate(enc);\n    if (bitrate != 0) {\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", %\"PRId64\" kb/s\", bitrate / 1000);\n    } else if (enc->rc_max_rate > 0) {\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", max. %\"PRId64\" kb/s\", enc->rc_max_rate / 1000);\n    }\n}\n\nconst char *av_get_profile_name(const AVCodec *codec, int profile)\n{\n    const AVProfile *p;\n    if (profile == FF_PROFILE_UNKNOWN || !codec->profiles)\n        return NULL;\n\n    for (p = codec->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)\n        if (p->profile == profile)\n            return p->name;\n\n    return NULL;\n}\n\nconst char *avcodec_profile_name(enum AVCodecID codec_id, int profile)\n{\n    const AVCodecDescriptor *desc = avcodec_descriptor_get(codec_id);\n    const AVProfile *p;\n\n    if (profile == FF_PROFILE_UNKNOWN || !desc || !desc->profiles)\n        return NULL;\n\n    for (p = desc->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)\n        if (p->profile == profile)\n            return p->name;\n\n    return NULL;\n}\n\nunsigned avcodec_version(void)\n{\n    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);\n    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);\n    av_assert0(AV_CODEC_ID_SRT==94216);\n    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);\n\n    return LIBAVCODEC_VERSION_INT;\n}\n\nconst char *avcodec_configuration(void)\n{\n    return FFMPEG_CONFIGURATION;\n}\n\nconst char *avcodec_license(void)\n{\n#define LICENSE_PREFIX \"libavcodec license: \"\n    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;\n}\n\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_8SVX_EXP:\n    case AV_CODEC_ID_8SVX_FIB:\n    case AV_CODEC_ID_ADPCM_CT:\n    case AV_CODEC_ID_ADPCM_IMA_APC:\n    case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\n    case AV_CODEC_ID_ADPCM_IMA_OKI:\n    case AV_CODEC_ID_ADPCM_IMA_WS:\n    case AV_CODEC_ID_ADPCM_G722:\n    case AV_CODEC_ID_ADPCM_YAMAHA:\n    case AV_CODEC_ID_ADPCM_AICA:\n        return 4;\n    case AV_CODEC_ID_DSD_LSBF:\n    case AV_CODEC_ID_DSD_MSBF:\n    case AV_CODEC_ID_DSD_LSBF_PLANAR:\n    case AV_CODEC_ID_DSD_MSBF_PLANAR:\n    case AV_CODEC_ID_PCM_ALAW:\n    case AV_CODEC_ID_PCM_MULAW:\n    case AV_CODEC_ID_PCM_VIDC:\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_S8_PLANAR:\n    case AV_CODEC_ID_PCM_U8:\n    case AV_CODEC_ID_PCM_ZORK:\n    case AV_CODEC_ID_SDX2_DPCM:\n        return 8;\n    case AV_CODEC_ID_PCM_S16BE:\n    case AV_CODEC_ID_PCM_S16BE_PLANAR:\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16LE_PLANAR:\n    case AV_CODEC_ID_PCM_U16BE:\n    case AV_CODEC_ID_PCM_U16LE:\n        return 16;\n    case AV_CODEC_ID_PCM_S24DAUD:\n    case AV_CODEC_ID_PCM_S24BE:\n    case AV_CODEC_ID_PCM_S24LE:\n    case AV_CODEC_ID_PCM_S24LE_PLANAR:\n    case AV_CODEC_ID_PCM_U24BE:\n    case AV_CODEC_ID_PCM_U24LE:\n        return 24;\n    case AV_CODEC_ID_PCM_S32BE:\n    case AV_CODEC_ID_PCM_S32LE:\n    case AV_CODEC_ID_PCM_S32LE_PLANAR:\n    case AV_CODEC_ID_PCM_U32BE:\n    case AV_CODEC_ID_PCM_U32LE:\n    case AV_CODEC_ID_PCM_F32BE:\n    case AV_CODEC_ID_PCM_F32LE:\n    case AV_CODEC_ID_PCM_F24LE:\n    case AV_CODEC_ID_PCM_F16LE:\n        return 32;\n    case AV_CODEC_ID_PCM_F64BE:\n    case AV_CODEC_ID_PCM_F64LE:\n    case AV_CODEC_ID_PCM_S64BE:\n    case AV_CODEC_ID_PCM_S64LE:\n        return 64;\n    default:\n        return 0;\n    }\n}\n\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)\n{\n    static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {\n        [AV_SAMPLE_FMT_U8  ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16 ] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32 ] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_FLT ] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBL ] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n        [AV_SAMPLE_FMT_U8P ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16P] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32P] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_S64P] = { AV_CODEC_ID_PCM_S64LE, AV_CODEC_ID_PCM_S64BE },\n        [AV_SAMPLE_FMT_FLTP] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBLP] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n    };\n    if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB)\n        return AV_CODEC_ID_NONE;\n    if (be < 0 || be > 1)\n        be = AV_NE(1, 0);\n    return map[fmt][be];\n}\n\nint av_get_bits_per_sample(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_ADPCM_SBPRO_2:\n        return 2;\n    case AV_CODEC_ID_ADPCM_SBPRO_3:\n        return 3;\n    case AV_CODEC_ID_ADPCM_SBPRO_4:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_ADPCM_SWF:\n    case AV_CODEC_ID_ADPCM_MS:\n        return 4;\n    default:\n        return av_get_exact_bits_per_sample(codec_id);\n    }\n}\n\nstatic int get_audio_frame_duration(enum AVCodecID id, int sr, int ch, int ba,\n                                    uint32_t tag, int bits_per_coded_sample, int64_t bitrate,\n                                    uint8_t * extradata, int frame_size, int frame_bytes)\n{\n    int bps = av_get_exact_bits_per_sample(id);\n    int framecount = (ba > 0 && frame_bytes / ba > 0) ? frame_bytes / ba : 1;\n\n    /* codecs with an exact constant bits per sample */\n    if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768)\n        return (frame_bytes * 8LL) / (bps * ch);\n    bps = bits_per_coded_sample;\n\n    /* codecs with a fixed packet duration */\n    switch (id) {\n    case AV_CODEC_ID_ADPCM_ADX:    return   32;\n    case AV_CODEC_ID_ADPCM_IMA_QT: return   64;\n    case AV_CODEC_ID_ADPCM_EA_XAS: return  128;\n    case AV_CODEC_ID_AMR_NB:\n    case AV_CODEC_ID_EVRC:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QCELP:\n    case AV_CODEC_ID_RA_288:       return  160;\n    case AV_CODEC_ID_AMR_WB:\n    case AV_CODEC_ID_GSM_MS:       return  320;\n    case AV_CODEC_ID_MP1:          return  384;\n    case AV_CODEC_ID_ATRAC1:       return  512;\n    case AV_CODEC_ID_ATRAC9:\n    case AV_CODEC_ID_ATRAC3:       return 1024 * framecount;\n    case AV_CODEC_ID_ATRAC3P:      return 2048;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MUSEPACK7:    return 1152;\n    case AV_CODEC_ID_AC3:          return 1536;\n    }\n\n    if (sr > 0) {\n        /* calc from sample rate */\n        if (id == AV_CODEC_ID_TTA)\n            return 256 * sr / 245;\n        else if (id == AV_CODEC_ID_DST)\n            return 588 * sr / 44100;\n\n        if (ch > 0) {\n            /* calc from sample rate and channels */\n            if (id == AV_CODEC_ID_BINKAUDIO_DCT)\n                return (480 << (sr / 22050)) / ch;\n        }\n\n        if (id == AV_CODEC_ID_MP3)\n            return sr <= 24000 ? 576 : 1152;\n    }\n\n    if (ba > 0) {\n        /* calc from block_align */\n        if (id == AV_CODEC_ID_SIPR) {\n            switch (ba) {\n            case 20: return 160;\n            case 19: return 144;\n            case 29: return 288;\n            case 37: return 480;\n            }\n        } else if (id == AV_CODEC_ID_ILBC) {\n            switch (ba) {\n            case 38: return 160;\n            case 50: return 240;\n            }\n        }\n    }\n\n    if (frame_bytes > 0) {\n        /* calc from frame_bytes only */\n        if (id == AV_CODEC_ID_TRUESPEECH)\n            return 240 * (frame_bytes / 32);\n        if (id == AV_CODEC_ID_NELLYMOSER)\n            return 256 * (frame_bytes / 64);\n        if (id == AV_CODEC_ID_RA_144)\n            return 160 * (frame_bytes / 20);\n\n        if (bps > 0) {\n            /* calc from frame_bytes and bits_per_coded_sample */\n            if (id == AV_CODEC_ID_ADPCM_G726 || id == AV_CODEC_ID_ADPCM_G726LE)\n                return frame_bytes * 8 / bps;\n        }\n\n        if (ch > 0 && ch < INT_MAX/16) {\n            /* calc from frame_bytes and channels */\n            switch (id) {\n            case AV_CODEC_ID_ADPCM_AFC:\n                return frame_bytes / (9 * ch) * 16;\n            case AV_CODEC_ID_ADPCM_PSX:\n            case AV_CODEC_ID_ADPCM_DTK:\n                return frame_bytes / (16 * ch) * 28;\n            case AV_CODEC_ID_ADPCM_4XM:\n            case AV_CODEC_ID_ADPCM_IMA_DAT4:\n            case AV_CODEC_ID_ADPCM_IMA_ISS:\n                return (frame_bytes - 4 * ch) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\n                return (frame_bytes - 4) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_IMA_AMV:\n                return (frame_bytes - 8) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_THP:\n            case AV_CODEC_ID_ADPCM_THP_LE:\n                if (extradata)\n                    return frame_bytes * 14 / (8 * ch);\n                break;\n            case AV_CODEC_ID_ADPCM_XA:\n                return (frame_bytes / 128) * 224 / ch;\n            case AV_CODEC_ID_INTERPLAY_DPCM:\n                return (frame_bytes - 6 - ch) / ch;\n            case AV_CODEC_ID_ROQ_DPCM:\n                return (frame_bytes - 8) / ch;\n            case AV_CODEC_ID_XAN_DPCM:\n                return (frame_bytes - 2 * ch) / ch;\n            case AV_CODEC_ID_MACE3:\n                return 3 * frame_bytes / ch;\n            case AV_CODEC_ID_MACE6:\n                return 6 * frame_bytes / ch;\n            case AV_CODEC_ID_PCM_LXF:\n                return 2 * (frame_bytes / (5 * ch));\n            case AV_CODEC_ID_IAC:\n            case AV_CODEC_ID_IMC:\n                return 4 * frame_bytes / ch;\n            }\n\n            if (tag) {\n                /* calc from frame_bytes, channels, and codec_tag */\n                if (id == AV_CODEC_ID_SOL_DPCM) {\n                    if (tag == 3)\n                        return frame_bytes / ch;\n                    else\n                        return frame_bytes * 2 / ch;\n                }\n            }\n\n            if (ba > 0) {\n                /* calc from frame_bytes, channels, and block_align */\n                int blocks = frame_bytes / ba;\n                switch (id) {\n                case AV_CODEC_ID_ADPCM_IMA_WAV:\n                    if (bps < 2 || bps > 5)\n                        return 0;\n                    return blocks * (1 + (ba - 4 * ch) / (bps * ch) * 8);\n                case AV_CODEC_ID_ADPCM_IMA_DK3:\n                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);\n                case AV_CODEC_ID_ADPCM_IMA_DK4:\n                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_IMA_RAD:\n                    return blocks * ((ba - 4 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_MS:\n                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_MTAF:\n                    return blocks * (ba - 16) * 2 / ch;\n                }\n            }\n\n            if (bps > 0) {\n                /* calc from frame_bytes, channels, and bits_per_coded_sample */\n                switch (id) {\n                case AV_CODEC_ID_PCM_DVD:\n                    if(bps<4 || frame_bytes<3)\n                        return 0;\n                    return 2 * ((frame_bytes - 3) / ((bps * 2 / 8) * ch));\n                case AV_CODEC_ID_PCM_BLURAY:\n                    if(bps<4 || frame_bytes<4)\n                        return 0;\n                    return (frame_bytes - 4) / ((FFALIGN(ch, 2) * bps) / 8);\n                case AV_CODEC_ID_S302M:\n                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\n                }\n            }\n        }\n    }\n\n    /* Fall back on using frame_size */\n    if (frame_size > 1 && frame_bytes)\n        return frame_size;\n\n    //For WMA we currently have no other means to calculate duration thus we\n    //do it here by assuming CBR, which is true for all known cases.\n    if (bitrate > 0 && frame_bytes > 0 && sr > 0 && ba > 1) {\n        if (id == AV_CODEC_ID_WMAV1 || id == AV_CODEC_ID_WMAV2)\n            return  (frame_bytes * 8LL * sr) / bitrate;\n    }\n\n    return 0;\n}\n\nint av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n{\n    return get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,\n                                    avctx->channels, avctx->block_align,\n                                    avctx->codec_tag, avctx->bits_per_coded_sample,\n                                    avctx->bit_rate, avctx->extradata, avctx->frame_size,\n                                    frame_bytes);\n}\n\nint av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)\n{\n    return get_audio_frame_duration(par->codec_id, par->sample_rate,\n                                    par->channels, par->block_align,\n                                    par->codec_tag, par->bits_per_coded_sample,\n                                    par->bit_rate, par->extradata, par->frame_size,\n                                    frame_bytes);\n}\n\n#if !HAVE_THREADS\nint ff_thread_init(AVCodecContext *s)\n{\n    return -1;\n}\n\n#endif\n\nunsigned int av_xiphlacing(unsigned char *s, unsigned int v)\n{\n    unsigned int n = 0;\n\n    while (v >= 0xff) {\n        *s++ = 0xff;\n        v -= 0xff;\n        n++;\n    }\n    *s = v;\n    n++;\n    return n;\n}\n\nint ff_match_2uint16(const uint16_t(*tab)[2], int size, int a, int b)\n{\n    int i;\n    for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) ;\n    return i;\n}\n\nconst AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)\n{\n    int i;\n    if (!codec->hw_configs || index < 0)\n        return NULL;\n    for (i = 0; i <= index; i++)\n        if (!codec->hw_configs[i])\n            return NULL;\n    return &codec->hw_configs[index]->public;\n}\n\n#if FF_API_USER_VISIBLE_AVHWACCEL\nAVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel)\n{\n    return NULL;\n}\n\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\n{\n}\n#endif\n\n#if FF_API_LOCKMGR\nint av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n{\n    return 0;\n}\n#endif\n\nunsigned int avpriv_toupper4(unsigned int x)\n{\n    return av_toupper(x & 0xFF) +\n          (av_toupper((x >>  8) & 0xFF) << 8)  +\n          (av_toupper((x >> 16) & 0xFF) << 16) +\n((unsigned)av_toupper((x >> 24) & 0xFF) << 24);\n}\n\nint ff_thread_ref_frame(ThreadFrame *dst, ThreadFrame *src)\n{\n    int ret;\n\n    dst->owner[0] = src->owner[0];\n    dst->owner[1] = src->owner[1];\n\n    ret = av_frame_ref(dst->f, src->f);\n    if (ret < 0)\n        return ret;\n\n    av_assert0(!dst->progress);\n\n    if (src->progress &&\n        !(dst->progress = av_buffer_ref(src->progress))) {\n        ff_thread_release_buffer(dst->owner[0], dst);\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\n#if !HAVE_THREADS\n\nenum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)\n{\n    return ff_get_format(avctx, fmt);\n}\n\nint ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)\n{\n    f->owner[0] = f->owner[1] = avctx;\n    return ff_get_buffer(avctx, f->f, flags);\n}\n\nvoid ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n{\n    if (f->f)\n        av_frame_unref(f->f);\n}\n\nvoid ff_thread_finish_setup(AVCodecContext *avctx)\n{\n}\n\nvoid ff_thread_report_progress(ThreadFrame *f, int progress, int field)\n{\n}\n\nvoid ff_thread_await_progress(ThreadFrame *f, int progress, int field)\n{\n}\n\nint ff_thread_can_start_frame(AVCodecContext *avctx)\n{\n    return 1;\n}\n\nint ff_alloc_entries(AVCodecContext *avctx, int count)\n{\n    return 0;\n}\n\nvoid ff_reset_entries(AVCodecContext *avctx)\n{\n}\n\nvoid ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int shift)\n{\n}\n\nvoid ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n)\n{\n}\n\n#endif\n\nint avcodec_is_open(AVCodecContext *s)\n{\n    return !!s->internal;\n}\n\nint avpriv_bprint_to_extradata(AVCodecContext *avctx, struct AVBPrint *buf)\n{\n    int ret;\n    char *str;\n\n    ret = av_bprint_finalize(buf, &str);\n    if (ret < 0)\n        return ret;\n    if (!av_bprint_is_complete(buf)) {\n        av_free(str);\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->extradata = str;\n    /* Note: the string is NUL terminated (so extradata can be read as a\n     * string), but the ending character is not accounted in the size (in\n     * binary formats you are likely not supposed to mux that character). When\n     * extradata is copied, it is also padded with AV_INPUT_BUFFER_PADDING_SIZE\n     * zeros. */\n    avctx->extradata_size = buf->len;\n    return 0;\n}\n\nconst uint8_t *avpriv_find_start_code(const uint8_t *av_restrict p,\n                                      const uint8_t *end,\n                                      uint32_t *av_restrict state)\n{\n    int i;\n\n    av_assert0(p <= end);\n    if (p >= end)\n        return end;\n\n    for (i = 0; i < 3; i++) {\n        uint32_t tmp = *state << 8;\n        *state = tmp + *(p++);\n        if (tmp == 0x100 || p == end)\n            return p;\n    }\n\n    while (p < end) {\n        if      (p[-1] > 1      ) p += 3;\n        else if (p[-2]          ) p += 2;\n        else if (p[-3]|(p[-1]-1)) p++;\n        else {\n            p++;\n            break;\n        }\n    }\n\n    p = FFMIN(p, end) - 4;\n    *state = AV_RB32(p);\n\n    return p + 4;\n}\n\nAVCPBProperties *av_cpb_properties_alloc(size_t *size)\n{\n    AVCPBProperties *props = av_mallocz(sizeof(AVCPBProperties));\n    if (!props)\n        return NULL;\n\n    if (size)\n        *size = sizeof(*props);\n\n    props->vbv_delay = UINT64_MAX;\n\n    return props;\n}\n\nAVCPBProperties *ff_add_cpb_side_data(AVCodecContext *avctx)\n{\n    AVPacketSideData *tmp;\n    AVCPBProperties  *props;\n    size_t size;\n\n    props = av_cpb_properties_alloc(&size);\n    if (!props)\n        return NULL;\n\n    tmp = av_realloc_array(avctx->coded_side_data, avctx->nb_coded_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        av_freep(&props);\n        return NULL;\n    }\n\n    avctx->coded_side_data = tmp;\n    avctx->nb_coded_side_data++;\n\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].type = AV_PKT_DATA_CPB_PROPERTIES;\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].data = (uint8_t*)props;\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].size = size;\n\n    return props;\n}\n\nstatic void codec_parameters_reset(AVCodecParameters *par)\n{\n    av_freep(&par->extradata);\n\n    memset(par, 0, sizeof(*par));\n\n    par->codec_type          = AVMEDIA_TYPE_UNKNOWN;\n    par->codec_id            = AV_CODEC_ID_NONE;\n    par->format              = -1;\n    par->field_order         = AV_FIELD_UNKNOWN;\n    par->color_range         = AVCOL_RANGE_UNSPECIFIED;\n    par->color_primaries     = AVCOL_PRI_UNSPECIFIED;\n    par->color_trc           = AVCOL_TRC_UNSPECIFIED;\n    par->color_space         = AVCOL_SPC_UNSPECIFIED;\n    par->chroma_location     = AVCHROMA_LOC_UNSPECIFIED;\n    par->sample_aspect_ratio = (AVRational){ 0, 1 };\n    par->profile             = FF_PROFILE_UNKNOWN;\n    par->level               = FF_LEVEL_UNKNOWN;\n}\n\nAVCodecParameters *avcodec_parameters_alloc(void)\n{\n    AVCodecParameters *par = av_mallocz(sizeof(*par));\n\n    if (!par)\n        return NULL;\n    codec_parameters_reset(par);\n    return par;\n}\n\nvoid avcodec_parameters_free(AVCodecParameters **ppar)\n{\n    AVCodecParameters *par = *ppar;\n\n    if (!par)\n        return;\n    codec_parameters_reset(par);\n\n    av_freep(ppar);\n}\n\nint avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)\n{\n    codec_parameters_reset(dst);\n    memcpy(dst, src, sizeof(*dst));\n\n    dst->extradata      = NULL;\n    dst->extradata_size = 0;\n    if (src->extradata) {\n        dst->extradata = av_mallocz(src->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!dst->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(dst->extradata, src->extradata, src->extradata_size);\n        dst->extradata_size = src->extradata_size;\n    }\n\n    return 0;\n}\n\nint avcodec_parameters_from_context(AVCodecParameters *par,\n                                    const AVCodecContext *codec)\n{\n    codec_parameters_reset(par);\n\n    par->codec_type = codec->codec_type;\n    par->codec_id   = codec->codec_id;\n    par->codec_tag  = codec->codec_tag;\n\n    par->bit_rate              = codec->bit_rate;\n    par->bits_per_coded_sample = codec->bits_per_coded_sample;\n    par->bits_per_raw_sample   = codec->bits_per_raw_sample;\n    par->profile               = codec->profile;\n    par->level                 = codec->level;\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        par->format              = codec->pix_fmt;\n        par->width               = codec->width;\n        par->height              = codec->height;\n        par->field_order         = codec->field_order;\n        par->color_range         = codec->color_range;\n        par->color_primaries     = codec->color_primaries;\n        par->color_trc           = codec->color_trc;\n        par->color_space         = codec->colorspace;\n        par->chroma_location     = codec->chroma_sample_location;\n        par->sample_aspect_ratio = codec->sample_aspect_ratio;\n        par->video_delay         = codec->has_b_frames;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        par->format           = codec->sample_fmt;\n        par->channel_layout   = codec->channel_layout;\n        par->channels         = codec->channels;\n        par->sample_rate      = codec->sample_rate;\n        par->block_align      = codec->block_align;\n        par->frame_size       = codec->frame_size;\n        par->initial_padding  = codec->initial_padding;\n        par->trailing_padding = codec->trailing_padding;\n        par->seek_preroll     = codec->seek_preroll;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        par->width  = codec->width;\n        par->height = codec->height;\n        break;\n    }\n\n    if (codec->extradata) {\n        par->extradata = av_mallocz(codec->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!par->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(par->extradata, codec->extradata, codec->extradata_size);\n        par->extradata_size = codec->extradata_size;\n    }\n\n    return 0;\n}\n\nint avcodec_parameters_to_context(AVCodecContext *codec,\n                                  const AVCodecParameters *par)\n{\n    codec->codec_type = par->codec_type;\n    codec->codec_id   = par->codec_id;\n    codec->codec_tag  = par->codec_tag;\n\n    codec->bit_rate              = par->bit_rate;\n    codec->bits_per_coded_sample = par->bits_per_coded_sample;\n    codec->bits_per_raw_sample   = par->bits_per_raw_sample;\n    codec->profile               = par->profile;\n    codec->level                 = par->level;\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        codec->pix_fmt                = par->format;\n        codec->width                  = par->width;\n        codec->height                 = par->height;\n        codec->field_order            = par->field_order;\n        codec->color_range            = par->color_range;\n        codec->color_primaries        = par->color_primaries;\n        codec->color_trc              = par->color_trc;\n        codec->colorspace             = par->color_space;\n        codec->chroma_sample_location = par->chroma_location;\n        codec->sample_aspect_ratio    = par->sample_aspect_ratio;\n        codec->has_b_frames           = par->video_delay;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        codec->sample_fmt       = par->format;\n        codec->channel_layout   = par->channel_layout;\n        codec->channels         = par->channels;\n        codec->sample_rate      = par->sample_rate;\n        codec->block_align      = par->block_align;\n        codec->frame_size       = par->frame_size;\n        codec->delay            =\n        codec->initial_padding  = par->initial_padding;\n        codec->trailing_padding = par->trailing_padding;\n        codec->seek_preroll     = par->seek_preroll;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        codec->width  = par->width;\n        codec->height = par->height;\n        break;\n    }\n\n    if (par->extradata) {\n        av_freep(&codec->extradata);\n        codec->extradata = av_mallocz(par->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!codec->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(codec->extradata, par->extradata, par->extradata_size);\n        codec->extradata_size = par->extradata_size;\n    }\n\n    return 0;\n}\n\nint ff_alloc_a53_sei(const AVFrame *frame, size_t prefix_len,\n                     void **data, size_t *sei_size)\n{\n    AVFrameSideData *side_data = NULL;\n    uint8_t *sei_data;\n\n    if (frame)\n        side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_A53_CC);\n\n    if (!side_data) {\n        *data = NULL;\n        return 0;\n    }\n\n    *sei_size = side_data->size + 11;\n    *data = av_mallocz(*sei_size + prefix_len);\n    if (!*data)\n        return AVERROR(ENOMEM);\n    sei_data = (uint8_t*)*data + prefix_len;\n\n    // country code\n    sei_data[0] = 181;\n    sei_data[1] = 0;\n    sei_data[2] = 49;\n\n    /**\n     * 'GA94' is standard in North America for ATSC, but hard coding\n     * this style may not be the right thing to do -- other formats\n     * do exist. This information is not available in the side_data\n     * so we are going with this right now.\n     */\n    AV_WL32(sei_data + 3, MKTAG('G', 'A', '9', '4'));\n    sei_data[7] = 3;\n    sei_data[8] = ((side_data->size/3) & 0x1f) | 0x40;\n    sei_data[9] = 0;\n\n    memcpy(sei_data + 10, side_data->data, side_data->size);\n\n    sei_data[side_data->size+10] = 255;\n\n    return 0;\n}\n\nint64_t ff_guess_coded_bitrate(AVCodecContext *avctx)\n{\n    AVRational framerate = avctx->framerate;\n    int bits_per_coded_sample = avctx->bits_per_coded_sample;\n    int64_t bitrate;\n\n    if (!(framerate.num && framerate.den))\n        framerate = av_inv_q(avctx->time_base);\n    if (!(framerate.num && framerate.den))\n        return 0;\n\n    if (!bits_per_coded_sample) {\n        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n        bits_per_coded_sample = av_get_bits_per_pixel(desc);\n    }\n    bitrate = (int64_t)bits_per_coded_sample * avctx->width * avctx->height *\n              framerate.num / framerate.den;\n\n    return bitrate;\n}\n\nint ff_int_from_list_or_default(void *ctx, const char * val_name, int val,\n                                const int * array_valid_values, int default_value)\n{\n    int i = 0, ref_val;\n\n    while (1) {\n        ref_val = array_valid_values[i];\n        if (ref_val == INT_MAX)\n            break;\n        if (val == ref_val)\n            return val;\n        i++;\n    }\n    /* val is not a valid value */\n    av_log(ctx, AV_LOG_DEBUG,\n           \"%s %d are not supported. Set to default value : %d\\n\", val_name, val, default_value);\n    return default_value;\n}\n"], "fixing_code": ["/*\n * utils for libavcodec\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * utils.\n */\n\n#include \"config.h\"\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/crc.h\"\n#include \"libavutil/frame.h\"\n#include \"libavutil/hwcontext.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/mem_internal.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/samplefmt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/thread.h\"\n#include \"avcodec.h\"\n#include \"decode.h\"\n#include \"hwaccel.h\"\n#include \"libavutil/opt.h\"\n#include \"mpegvideo.h\"\n#include \"thread.h\"\n#include \"frame_thread_encoder.h\"\n#include \"internal.h\"\n#include \"raw.h\"\n#include \"bytestream.h\"\n#include \"version.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdatomic.h>\n#include <limits.h>\n#include <float.h>\n#if CONFIG_ICONV\n# include <iconv.h>\n#endif\n\n#include \"libavutil/ffversion.h\"\nconst char av_codec_ffversion[] = \"FFmpeg version \" FFMPEG_VERSION;\n\nstatic AVMutex codec_mutex = AV_MUTEX_INITIALIZER;\n\nvoid av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n}\n\nvoid av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + AV_INPUT_BUFFER_PADDING_SIZE);\n}\n\nint av_codec_is_encoder(const AVCodec *codec)\n{\n    return codec && (codec->encode_sub || codec->encode2 ||codec->send_frame);\n}\n\nint av_codec_is_decoder(const AVCodec *codec)\n{\n    return codec && (codec->decode || codec->receive_frame);\n}\n\nint ff_set_dimensions(AVCodecContext *s, int width, int height)\n{\n    int ret = av_image_check_size2(width, height, s->max_pixels, AV_PIX_FMT_NONE, 0, s);\n\n    if (ret < 0)\n        width = height = 0;\n\n    s->coded_width  = width;\n    s->coded_height = height;\n    s->width        = AV_CEIL_RSHIFT(width,  s->lowres);\n    s->height       = AV_CEIL_RSHIFT(height, s->lowres);\n\n    return ret;\n}\n\nint ff_set_sar(AVCodecContext *avctx, AVRational sar)\n{\n    int ret = av_image_check_sar(avctx->width, avctx->height, sar);\n\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %d/%d\\n\",\n               sar.num, sar.den);\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        return ret;\n    } else {\n        avctx->sample_aspect_ratio = sar;\n    }\n    return 0;\n}\n\nint ff_side_data_update_matrix_encoding(AVFrame *frame,\n                                        enum AVMatrixEncoding matrix_encoding)\n{\n    AVFrameSideData *side_data;\n    enum AVMatrixEncoding *data;\n\n    side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_MATRIXENCODING);\n    if (!side_data)\n        side_data = av_frame_new_side_data(frame, AV_FRAME_DATA_MATRIXENCODING,\n                                           sizeof(enum AVMatrixEncoding));\n\n    if (!side_data)\n        return AVERROR(ENOMEM);\n\n    data  = (enum AVMatrixEncoding*)side_data->data;\n    *data = matrix_encoding;\n\n    return 0;\n}\n\nvoid avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P12LE:\n    case AV_PIX_FMT_YUVA422P12BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P12LE:\n    case AV_PIX_FMT_YUVA444P12BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV ||\n            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres ||\n        s->codec_id == AV_CODEC_ID_VP5  || s->codec_id == AV_CODEC_ID_VP6 ||\n        s->codec_id == AV_CODEC_ID_VP6F || s->codec_id == AV_CODEC_ID_VP6A\n    ) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}\n\nvoid avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);\n    int chroma_shift = desc->log2_chroma_w;\n    int linesize_align[AV_NUM_DATA_POINTERS];\n    int align;\n\n    avcodec_align_dimensions2(s, width, height, linesize_align);\n    align               = FFMAX(linesize_align[0], linesize_align[3]);\n    linesize_align[1] <<= chroma_shift;\n    linesize_align[2] <<= chroma_shift;\n    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);\n    *width              = FFALIGN(*width, align);\n}\n\nint avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)\n{\n    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)\n        return AVERROR(EINVAL);\n    pos--;\n\n    *xpos = (pos&1) * 128;\n    *ypos = ((pos>>1)^(pos<4)) * 128;\n\n    return 0;\n}\n\nenum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)\n{\n    int pos, xout, yout;\n\n    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {\n        if (avcodec_enum_to_chroma_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)\n            return pos;\n    }\n    return AVCHROMA_LOC_UNSPECIFIED;\n}\n\nint avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,\n                             enum AVSampleFormat sample_fmt, const uint8_t *buf,\n                             int buf_size, int align)\n{\n    int ch, planar, needed_size, ret = 0;\n\n    needed_size = av_samples_get_buffer_size(NULL, nb_channels,\n                                             frame->nb_samples, sample_fmt,\n                                             align);\n    if (buf_size < needed_size)\n        return AVERROR(EINVAL);\n\n    planar = av_sample_fmt_is_planar(sample_fmt);\n    if (planar && nb_channels > AV_NUM_DATA_POINTERS) {\n        if (!(frame->extended_data = av_mallocz_array(nb_channels,\n                                                sizeof(*frame->extended_data))))\n            return AVERROR(ENOMEM);\n    } else {\n        frame->extended_data = frame->data;\n    }\n\n    if ((ret = av_samples_fill_arrays(frame->extended_data, &frame->linesize[0],\n                                      (uint8_t *)(intptr_t)buf, nb_channels, frame->nb_samples,\n                                      sample_fmt, align)) < 0) {\n        if (frame->extended_data != frame->data)\n            av_freep(&frame->extended_data);\n        return ret;\n    }\n    if (frame->extended_data != frame->data) {\n        for (ch = 0; ch < AV_NUM_DATA_POINTERS; ch++)\n            frame->data[ch] = frame->extended_data[ch];\n    }\n\n    return ret;\n}\n\nvoid ff_color_frame(AVFrame *frame, const int c[4])\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int p, y, x;\n\n    av_assert0(desc->flags & AV_PIX_FMT_FLAG_PLANAR);\n\n    for (p = 0; p<desc->nb_components; p++) {\n        uint8_t *dst = frame->data[p];\n        int is_chroma = p == 1 || p == 2;\n        int bytes  = is_chroma ? AV_CEIL_RSHIFT(frame->width,  desc->log2_chroma_w) : frame->width;\n        int height = is_chroma ? AV_CEIL_RSHIFT(frame->height, desc->log2_chroma_h) : frame->height;\n        for (y = 0; y < height; y++) {\n            if (desc->comp[0].depth >= 9) {\n                for (x = 0; x<bytes; x++)\n                    ((uint16_t*)dst)[x] = c[p];\n            }else\n                memset(dst, c[p], bytes);\n            dst += frame->linesize[p];\n        }\n    }\n}\n\nint avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        int r = func(c, (char *)arg + i * size);\n        if (ret)\n            ret[i] = r;\n    }\n    emms_c();\n    return 0;\n}\n\nint avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        int r = func(c, arg, i, 0);\n        if (ret)\n            ret[i] = r;\n    }\n    emms_c();\n    return 0;\n}\n\nenum AVPixelFormat avpriv_find_pix_fmt(const PixelFormatTag *tags,\n                                       unsigned int fourcc)\n{\n    while (tags->pix_fmt >= 0) {\n        if (tags->fourcc == fourcc)\n            return tags->pix_fmt;\n        tags++;\n    }\n    return AV_PIX_FMT_NONE;\n}\n\n#if FF_API_CODEC_GET_SET\nMAKE_ACCESSORS(AVCodecContext, codec, AVRational, pkt_timebase)\nMAKE_ACCESSORS(AVCodecContext, codec, const AVCodecDescriptor *, codec_descriptor)\nMAKE_ACCESSORS(AVCodecContext, codec, int, lowres)\nMAKE_ACCESSORS(AVCodecContext, codec, int, seek_preroll)\nMAKE_ACCESSORS(AVCodecContext, codec, uint16_t*, chroma_intra_matrix)\n\nunsigned av_codec_get_codec_properties(const AVCodecContext *codec)\n{\n    return codec->properties;\n}\n\nint av_codec_get_max_lowres(const AVCodec *codec)\n{\n    return codec->max_lowres;\n}\n#endif\n\nint avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec){\n    return !!(codec->caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM);\n}\n\nstatic int64_t get_bit_rate(AVCodecContext *ctx)\n{\n    int64_t bit_rate;\n    int bits_per_sample;\n\n    switch (ctx->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n    case AVMEDIA_TYPE_DATA:\n    case AVMEDIA_TYPE_SUBTITLE:\n    case AVMEDIA_TYPE_ATTACHMENT:\n        bit_rate = ctx->bit_rate;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n        bit_rate = bits_per_sample ? ctx->sample_rate * (int64_t)ctx->channels * bits_per_sample : ctx->bit_rate;\n        break;\n    default:\n        bit_rate = 0;\n        break;\n    }\n    return bit_rate;\n}\n\n\nstatic void ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n{\n    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)\n        ff_mutex_lock(&codec_mutex);\n}\n\nstatic void ff_unlock_avcodec(const AVCodec *codec)\n{\n    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)\n        ff_mutex_unlock(&codec_mutex);\n}\n\nint attribute_align_arg ff_codec_open2_recursive(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n\n    ff_unlock_avcodec(codec);\n\n    ret = avcodec_open2(avctx, codec, options);\n\n    ff_lock_avcodec(avctx, codec);\n    return ret;\n}\n\nint attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    if (avctx->codec && avctx->codec->close &&\n        (codec_init_ok ||\n         (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n        avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}\n\nvoid avsubtitle_free(AVSubtitle *sub)\n{\n    int i;\n\n    for (i = 0; i < sub->num_rects; i++) {\n        av_freep(&sub->rects[i]->data[0]);\n        av_freep(&sub->rects[i]->data[1]);\n        av_freep(&sub->rects[i]->data[2]);\n        av_freep(&sub->rects[i]->data[3]);\n        av_freep(&sub->rects[i]->text);\n        av_freep(&sub->rects[i]->ass);\n        av_freep(&sub->rects[i]);\n    }\n\n    av_freep(&sub->rects);\n\n    memset(sub, 0, sizeof(*sub));\n}\n\nav_cold int avcodec_close(AVCodecContext *avctx)\n{\n    int i;\n\n    if (!avctx)\n        return 0;\n\n    if (avcodec_is_open(avctx)) {\n        FramePool *pool = avctx->internal->pool;\n        if (CONFIG_FRAME_THREAD_ENCODER &&\n            avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {\n            ff_frame_thread_encoder_free(avctx);\n        }\n        if (HAVE_THREADS && avctx->internal->thread_ctx)\n            ff_thread_free(avctx);\n        if (avctx->codec && avctx->codec->close)\n            avctx->codec->close(avctx);\n        avctx->internal->byte_buffer_size = 0;\n        av_freep(&avctx->internal->byte_buffer);\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n\n        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)\n            av_buffer_pool_uninit(&pool->pools[i]);\n        av_freep(&avctx->internal->pool);\n\n        if (avctx->hwaccel && avctx->hwaccel->uninit)\n            avctx->hwaccel->uninit(avctx);\n        av_freep(&avctx->internal->hwaccel_priv_data);\n\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal);\n    }\n\n    for (i = 0; i < avctx->nb_coded_side_data; i++)\n        av_freep(&avctx->coded_side_data[i].data);\n    av_freep(&avctx->coded_side_data);\n    avctx->nb_coded_side_data = 0;\n\n    av_buffer_unref(&avctx->hw_frames_ctx);\n    av_buffer_unref(&avctx->hw_device_ctx);\n\n    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n    av_freep(&avctx->priv_data);\n    if (av_codec_is_encoder(avctx->codec)) {\n        av_freep(&avctx->extradata);\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    }\n    avctx->codec = NULL;\n    avctx->active_thread_type = 0;\n\n    return 0;\n}\n\nconst char *avcodec_get_name(enum AVCodecID id)\n{\n    const AVCodecDescriptor *cd;\n    AVCodec *codec;\n\n    if (id == AV_CODEC_ID_NONE)\n        return \"none\";\n    cd = avcodec_descriptor_get(id);\n    if (cd)\n        return cd->name;\n    av_log(NULL, AV_LOG_WARNING, \"Codec 0x%x is not in the full list.\\n\", id);\n    codec = avcodec_find_decoder(id);\n    if (codec)\n        return codec->name;\n    codec = avcodec_find_encoder(id);\n    if (codec)\n        return codec->name;\n    return \"unknown_codec\";\n}\n\nsize_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag)\n{\n    int i, len, ret = 0;\n\n#define TAG_PRINT(x)                                              \\\n    (((x) >= '0' && (x) <= '9') ||                                \\\n     ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') ||  \\\n     ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\n\n    for (i = 0; i < 4; i++) {\n        len = snprintf(buf, buf_size,\n                       TAG_PRINT(codec_tag & 0xFF) ? \"%c\" : \"[%d]\", codec_tag & 0xFF);\n        buf        += len;\n        buf_size    = buf_size > len ? buf_size - len : 0;\n        ret        += len;\n        codec_tag >>= 8;\n    }\n    return ret;\n}\n\nvoid avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n{\n    const char *codec_type;\n    const char *codec_name;\n    const char *profile = NULL;\n    int64_t bitrate;\n    int new_line = 0;\n    AVRational display_aspect_ratio;\n    const char *separator = enc->dump_separator ? (const char *)enc->dump_separator : \", \";\n\n    if (!buf || buf_size <= 0)\n        return;\n    codec_type = av_get_media_type_string(enc->codec_type);\n    codec_name = avcodec_get_name(enc->codec_id);\n    profile = avcodec_profile_name(enc->codec_id, enc->profile);\n\n    snprintf(buf, buf_size, \"%s: %s\", codec_type ? codec_type : \"unknown\",\n             codec_name);\n    buf[0] ^= 'a' ^ 'A'; /* first letter in uppercase */\n\n    if (enc->codec && strcmp(enc->codec->name, codec_name))\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", enc->codec->name);\n\n    if (profile)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", profile);\n    if (   enc->codec_type == AVMEDIA_TYPE_VIDEO\n        && av_log_get_level() >= AV_LOG_VERBOSE\n        && enc->refs)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", %d reference frame%s\",\n                 enc->refs, enc->refs > 1 ? \"s\" : \"\");\n\n    if (enc->codec_tag)\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s / 0x%04X)\",\n                 av_fourcc2str(enc->codec_tag), enc->codec_tag);\n\n    switch (enc->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        {\n            char detail[256] = \"(\";\n\n            av_strlcat(buf, separator, buf_size);\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \"%s\", enc->pix_fmt == AV_PIX_FMT_NONE ? \"none\" :\n                     av_get_pix_fmt_name(enc->pix_fmt));\n            if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&\n                enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)\n                av_strlcatf(detail, sizeof(detail), \"%d bpc, \", enc->bits_per_raw_sample);\n            if (enc->color_range != AVCOL_RANGE_UNSPECIFIED)\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n                            av_color_range_name(enc->color_range));\n\n            if (enc->colorspace != AVCOL_SPC_UNSPECIFIED ||\n                enc->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n                enc->color_trc != AVCOL_TRC_UNSPECIFIED) {\n                if (enc->colorspace != (int)enc->color_primaries ||\n                    enc->colorspace != (int)enc->color_trc) {\n                    new_line = 1;\n                    av_strlcatf(detail, sizeof(detail), \"%s/%s/%s, \",\n                                av_color_space_name(enc->colorspace),\n                                av_color_primaries_name(enc->color_primaries),\n                                av_color_transfer_name(enc->color_trc));\n                } else\n                    av_strlcatf(detail, sizeof(detail), \"%s, \",\n                                av_get_colorspace_name(enc->colorspace));\n            }\n\n            if (enc->field_order != AV_FIELD_UNKNOWN) {\n                const char *field_order = \"progressive\";\n                if (enc->field_order == AV_FIELD_TT)\n                    field_order = \"top first\";\n                else if (enc->field_order == AV_FIELD_BB)\n                    field_order = \"bottom first\";\n                else if (enc->field_order == AV_FIELD_TB)\n                    field_order = \"top coded first (swapped)\";\n                else if (enc->field_order == AV_FIELD_BT)\n                    field_order = \"bottom coded first (swapped)\";\n\n                av_strlcatf(detail, sizeof(detail), \"%s, \", field_order);\n            }\n\n            if (av_log_get_level() >= AV_LOG_VERBOSE &&\n                enc->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED)\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n                            av_chroma_location_name(enc->chroma_sample_location));\n\n            if (strlen(detail) > 1) {\n                detail[strlen(detail) - 2] = 0;\n                av_strlcatf(buf, buf_size, \"%s)\", detail);\n            }\n        }\n\n        if (enc->width) {\n            av_strlcat(buf, new_line ? separator : \", \", buf_size);\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \"%dx%d\",\n                     enc->width, enc->height);\n\n            if (av_log_get_level() >= AV_LOG_VERBOSE &&\n                (enc->width != enc->coded_width ||\n                 enc->height != enc->coded_height))\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \" (%dx%d)\", enc->coded_width, enc->coded_height);\n\n            if (enc->sample_aspect_ratio.num) {\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                          enc->width * (int64_t)enc->sample_aspect_ratio.num,\n                          enc->height * (int64_t)enc->sample_aspect_ratio.den,\n                          1024 * 1024);\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \" [SAR %d:%d DAR %d:%d]\",\n                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,\n                         display_aspect_ratio.num, display_aspect_ratio.den);\n            }\n            if (av_log_get_level() >= AV_LOG_DEBUG) {\n                int g = av_gcd(enc->time_base.num, enc->time_base.den);\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", %d/%d\",\n                         enc->time_base.num / g, enc->time_base.den / g);\n            }\n        }\n        if (encode) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", q=%d-%d\", enc->qmin, enc->qmax);\n        } else {\n            if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", Closed Captions\");\n            if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", lossless\");\n        }\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        av_strlcat(buf, separator, buf_size);\n\n        if (enc->sample_rate) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \"%d Hz, \", enc->sample_rate);\n        }\n        av_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n        if (enc->sample_fmt != AV_SAMPLE_FMT_NONE) {\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", %s\", av_get_sample_fmt_name(enc->sample_fmt));\n        }\n        if (   enc->bits_per_raw_sample > 0\n            && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \" (%d bit)\", enc->bits_per_raw_sample);\n        if (av_log_get_level() >= AV_LOG_VERBOSE) {\n            if (enc->initial_padding)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", delay %d\", enc->initial_padding);\n            if (enc->trailing_padding)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", padding %d\", enc->trailing_padding);\n        }\n        break;\n    case AVMEDIA_TYPE_DATA:\n        if (av_log_get_level() >= AV_LOG_DEBUG) {\n            int g = av_gcd(enc->time_base.num, enc->time_base.den);\n            if (g)\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                         \", %d/%d\",\n                         enc->time_base.num / g, enc->time_base.den / g);\n        }\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (enc->width)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", %dx%d\", enc->width, enc->height);\n        break;\n    default:\n        return;\n    }\n    if (encode) {\n        if (enc->flags & AV_CODEC_FLAG_PASS1)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", pass 1\");\n        if (enc->flags & AV_CODEC_FLAG_PASS2)\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                     \", pass 2\");\n    }\n    bitrate = get_bit_rate(enc);\n    if (bitrate != 0) {\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", %\"PRId64\" kb/s\", bitrate / 1000);\n    } else if (enc->rc_max_rate > 0) {\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n                 \", max. %\"PRId64\" kb/s\", enc->rc_max_rate / 1000);\n    }\n}\n\nconst char *av_get_profile_name(const AVCodec *codec, int profile)\n{\n    const AVProfile *p;\n    if (profile == FF_PROFILE_UNKNOWN || !codec->profiles)\n        return NULL;\n\n    for (p = codec->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)\n        if (p->profile == profile)\n            return p->name;\n\n    return NULL;\n}\n\nconst char *avcodec_profile_name(enum AVCodecID codec_id, int profile)\n{\n    const AVCodecDescriptor *desc = avcodec_descriptor_get(codec_id);\n    const AVProfile *p;\n\n    if (profile == FF_PROFILE_UNKNOWN || !desc || !desc->profiles)\n        return NULL;\n\n    for (p = desc->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)\n        if (p->profile == profile)\n            return p->name;\n\n    return NULL;\n}\n\nunsigned avcodec_version(void)\n{\n    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);\n    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);\n    av_assert0(AV_CODEC_ID_SRT==94216);\n    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);\n\n    return LIBAVCODEC_VERSION_INT;\n}\n\nconst char *avcodec_configuration(void)\n{\n    return FFMPEG_CONFIGURATION;\n}\n\nconst char *avcodec_license(void)\n{\n#define LICENSE_PREFIX \"libavcodec license: \"\n    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;\n}\n\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_8SVX_EXP:\n    case AV_CODEC_ID_8SVX_FIB:\n    case AV_CODEC_ID_ADPCM_CT:\n    case AV_CODEC_ID_ADPCM_IMA_APC:\n    case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\n    case AV_CODEC_ID_ADPCM_IMA_OKI:\n    case AV_CODEC_ID_ADPCM_IMA_WS:\n    case AV_CODEC_ID_ADPCM_G722:\n    case AV_CODEC_ID_ADPCM_YAMAHA:\n    case AV_CODEC_ID_ADPCM_AICA:\n        return 4;\n    case AV_CODEC_ID_DSD_LSBF:\n    case AV_CODEC_ID_DSD_MSBF:\n    case AV_CODEC_ID_DSD_LSBF_PLANAR:\n    case AV_CODEC_ID_DSD_MSBF_PLANAR:\n    case AV_CODEC_ID_PCM_ALAW:\n    case AV_CODEC_ID_PCM_MULAW:\n    case AV_CODEC_ID_PCM_VIDC:\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_S8_PLANAR:\n    case AV_CODEC_ID_PCM_U8:\n    case AV_CODEC_ID_PCM_ZORK:\n    case AV_CODEC_ID_SDX2_DPCM:\n        return 8;\n    case AV_CODEC_ID_PCM_S16BE:\n    case AV_CODEC_ID_PCM_S16BE_PLANAR:\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16LE_PLANAR:\n    case AV_CODEC_ID_PCM_U16BE:\n    case AV_CODEC_ID_PCM_U16LE:\n        return 16;\n    case AV_CODEC_ID_PCM_S24DAUD:\n    case AV_CODEC_ID_PCM_S24BE:\n    case AV_CODEC_ID_PCM_S24LE:\n    case AV_CODEC_ID_PCM_S24LE_PLANAR:\n    case AV_CODEC_ID_PCM_U24BE:\n    case AV_CODEC_ID_PCM_U24LE:\n        return 24;\n    case AV_CODEC_ID_PCM_S32BE:\n    case AV_CODEC_ID_PCM_S32LE:\n    case AV_CODEC_ID_PCM_S32LE_PLANAR:\n    case AV_CODEC_ID_PCM_U32BE:\n    case AV_CODEC_ID_PCM_U32LE:\n    case AV_CODEC_ID_PCM_F32BE:\n    case AV_CODEC_ID_PCM_F32LE:\n    case AV_CODEC_ID_PCM_F24LE:\n    case AV_CODEC_ID_PCM_F16LE:\n        return 32;\n    case AV_CODEC_ID_PCM_F64BE:\n    case AV_CODEC_ID_PCM_F64LE:\n    case AV_CODEC_ID_PCM_S64BE:\n    case AV_CODEC_ID_PCM_S64LE:\n        return 64;\n    default:\n        return 0;\n    }\n}\n\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)\n{\n    static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {\n        [AV_SAMPLE_FMT_U8  ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16 ] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32 ] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_FLT ] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBL ] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n        [AV_SAMPLE_FMT_U8P ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16P] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32P] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_S64P] = { AV_CODEC_ID_PCM_S64LE, AV_CODEC_ID_PCM_S64BE },\n        [AV_SAMPLE_FMT_FLTP] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBLP] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n    };\n    if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB)\n        return AV_CODEC_ID_NONE;\n    if (be < 0 || be > 1)\n        be = AV_NE(1, 0);\n    return map[fmt][be];\n}\n\nint av_get_bits_per_sample(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_ADPCM_SBPRO_2:\n        return 2;\n    case AV_CODEC_ID_ADPCM_SBPRO_3:\n        return 3;\n    case AV_CODEC_ID_ADPCM_SBPRO_4:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_ADPCM_SWF:\n    case AV_CODEC_ID_ADPCM_MS:\n        return 4;\n    default:\n        return av_get_exact_bits_per_sample(codec_id);\n    }\n}\n\nstatic int get_audio_frame_duration(enum AVCodecID id, int sr, int ch, int ba,\n                                    uint32_t tag, int bits_per_coded_sample, int64_t bitrate,\n                                    uint8_t * extradata, int frame_size, int frame_bytes)\n{\n    int bps = av_get_exact_bits_per_sample(id);\n    int framecount = (ba > 0 && frame_bytes / ba > 0) ? frame_bytes / ba : 1;\n\n    /* codecs with an exact constant bits per sample */\n    if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768)\n        return (frame_bytes * 8LL) / (bps * ch);\n    bps = bits_per_coded_sample;\n\n    /* codecs with a fixed packet duration */\n    switch (id) {\n    case AV_CODEC_ID_ADPCM_ADX:    return   32;\n    case AV_CODEC_ID_ADPCM_IMA_QT: return   64;\n    case AV_CODEC_ID_ADPCM_EA_XAS: return  128;\n    case AV_CODEC_ID_AMR_NB:\n    case AV_CODEC_ID_EVRC:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QCELP:\n    case AV_CODEC_ID_RA_288:       return  160;\n    case AV_CODEC_ID_AMR_WB:\n    case AV_CODEC_ID_GSM_MS:       return  320;\n    case AV_CODEC_ID_MP1:          return  384;\n    case AV_CODEC_ID_ATRAC1:       return  512;\n    case AV_CODEC_ID_ATRAC9:\n    case AV_CODEC_ID_ATRAC3:       return 1024 * framecount;\n    case AV_CODEC_ID_ATRAC3P:      return 2048;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MUSEPACK7:    return 1152;\n    case AV_CODEC_ID_AC3:          return 1536;\n    }\n\n    if (sr > 0) {\n        /* calc from sample rate */\n        if (id == AV_CODEC_ID_TTA)\n            return 256 * sr / 245;\n        else if (id == AV_CODEC_ID_DST)\n            return 588 * sr / 44100;\n\n        if (ch > 0) {\n            /* calc from sample rate and channels */\n            if (id == AV_CODEC_ID_BINKAUDIO_DCT)\n                return (480 << (sr / 22050)) / ch;\n        }\n\n        if (id == AV_CODEC_ID_MP3)\n            return sr <= 24000 ? 576 : 1152;\n    }\n\n    if (ba > 0) {\n        /* calc from block_align */\n        if (id == AV_CODEC_ID_SIPR) {\n            switch (ba) {\n            case 20: return 160;\n            case 19: return 144;\n            case 29: return 288;\n            case 37: return 480;\n            }\n        } else if (id == AV_CODEC_ID_ILBC) {\n            switch (ba) {\n            case 38: return 160;\n            case 50: return 240;\n            }\n        }\n    }\n\n    if (frame_bytes > 0) {\n        /* calc from frame_bytes only */\n        if (id == AV_CODEC_ID_TRUESPEECH)\n            return 240 * (frame_bytes / 32);\n        if (id == AV_CODEC_ID_NELLYMOSER)\n            return 256 * (frame_bytes / 64);\n        if (id == AV_CODEC_ID_RA_144)\n            return 160 * (frame_bytes / 20);\n\n        if (bps > 0) {\n            /* calc from frame_bytes and bits_per_coded_sample */\n            if (id == AV_CODEC_ID_ADPCM_G726 || id == AV_CODEC_ID_ADPCM_G726LE)\n                return frame_bytes * 8 / bps;\n        }\n\n        if (ch > 0 && ch < INT_MAX/16) {\n            /* calc from frame_bytes and channels */\n            switch (id) {\n            case AV_CODEC_ID_ADPCM_AFC:\n                return frame_bytes / (9 * ch) * 16;\n            case AV_CODEC_ID_ADPCM_PSX:\n            case AV_CODEC_ID_ADPCM_DTK:\n                return frame_bytes / (16 * ch) * 28;\n            case AV_CODEC_ID_ADPCM_4XM:\n            case AV_CODEC_ID_ADPCM_IMA_DAT4:\n            case AV_CODEC_ID_ADPCM_IMA_ISS:\n                return (frame_bytes - 4 * ch) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\n                return (frame_bytes - 4) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_IMA_AMV:\n                return (frame_bytes - 8) * 2 / ch;\n            case AV_CODEC_ID_ADPCM_THP:\n            case AV_CODEC_ID_ADPCM_THP_LE:\n                if (extradata)\n                    return frame_bytes * 14 / (8 * ch);\n                break;\n            case AV_CODEC_ID_ADPCM_XA:\n                return (frame_bytes / 128) * 224 / ch;\n            case AV_CODEC_ID_INTERPLAY_DPCM:\n                return (frame_bytes - 6 - ch) / ch;\n            case AV_CODEC_ID_ROQ_DPCM:\n                return (frame_bytes - 8) / ch;\n            case AV_CODEC_ID_XAN_DPCM:\n                return (frame_bytes - 2 * ch) / ch;\n            case AV_CODEC_ID_MACE3:\n                return 3 * frame_bytes / ch;\n            case AV_CODEC_ID_MACE6:\n                return 6 * frame_bytes / ch;\n            case AV_CODEC_ID_PCM_LXF:\n                return 2 * (frame_bytes / (5 * ch));\n            case AV_CODEC_ID_IAC:\n            case AV_CODEC_ID_IMC:\n                return 4 * frame_bytes / ch;\n            }\n\n            if (tag) {\n                /* calc from frame_bytes, channels, and codec_tag */\n                if (id == AV_CODEC_ID_SOL_DPCM) {\n                    if (tag == 3)\n                        return frame_bytes / ch;\n                    else\n                        return frame_bytes * 2 / ch;\n                }\n            }\n\n            if (ba > 0) {\n                /* calc from frame_bytes, channels, and block_align */\n                int blocks = frame_bytes / ba;\n                switch (id) {\n                case AV_CODEC_ID_ADPCM_IMA_WAV:\n                    if (bps < 2 || bps > 5)\n                        return 0;\n                    return blocks * (1 + (ba - 4 * ch) / (bps * ch) * 8);\n                case AV_CODEC_ID_ADPCM_IMA_DK3:\n                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);\n                case AV_CODEC_ID_ADPCM_IMA_DK4:\n                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_IMA_RAD:\n                    return blocks * ((ba - 4 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_MS:\n                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);\n                case AV_CODEC_ID_ADPCM_MTAF:\n                    return blocks * (ba - 16) * 2 / ch;\n                }\n            }\n\n            if (bps > 0) {\n                /* calc from frame_bytes, channels, and bits_per_coded_sample */\n                switch (id) {\n                case AV_CODEC_ID_PCM_DVD:\n                    if(bps<4 || frame_bytes<3)\n                        return 0;\n                    return 2 * ((frame_bytes - 3) / ((bps * 2 / 8) * ch));\n                case AV_CODEC_ID_PCM_BLURAY:\n                    if(bps<4 || frame_bytes<4)\n                        return 0;\n                    return (frame_bytes - 4) / ((FFALIGN(ch, 2) * bps) / 8);\n                case AV_CODEC_ID_S302M:\n                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\n                }\n            }\n        }\n    }\n\n    /* Fall back on using frame_size */\n    if (frame_size > 1 && frame_bytes)\n        return frame_size;\n\n    //For WMA we currently have no other means to calculate duration thus we\n    //do it here by assuming CBR, which is true for all known cases.\n    if (bitrate > 0 && frame_bytes > 0 && sr > 0 && ba > 1) {\n        if (id == AV_CODEC_ID_WMAV1 || id == AV_CODEC_ID_WMAV2)\n            return  (frame_bytes * 8LL * sr) / bitrate;\n    }\n\n    return 0;\n}\n\nint av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n{\n    return get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,\n                                    avctx->channels, avctx->block_align,\n                                    avctx->codec_tag, avctx->bits_per_coded_sample,\n                                    avctx->bit_rate, avctx->extradata, avctx->frame_size,\n                                    frame_bytes);\n}\n\nint av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)\n{\n    return get_audio_frame_duration(par->codec_id, par->sample_rate,\n                                    par->channels, par->block_align,\n                                    par->codec_tag, par->bits_per_coded_sample,\n                                    par->bit_rate, par->extradata, par->frame_size,\n                                    frame_bytes);\n}\n\n#if !HAVE_THREADS\nint ff_thread_init(AVCodecContext *s)\n{\n    return -1;\n}\n\n#endif\n\nunsigned int av_xiphlacing(unsigned char *s, unsigned int v)\n{\n    unsigned int n = 0;\n\n    while (v >= 0xff) {\n        *s++ = 0xff;\n        v -= 0xff;\n        n++;\n    }\n    *s = v;\n    n++;\n    return n;\n}\n\nint ff_match_2uint16(const uint16_t(*tab)[2], int size, int a, int b)\n{\n    int i;\n    for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) ;\n    return i;\n}\n\nconst AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)\n{\n    int i;\n    if (!codec->hw_configs || index < 0)\n        return NULL;\n    for (i = 0; i <= index; i++)\n        if (!codec->hw_configs[i])\n            return NULL;\n    return &codec->hw_configs[index]->public;\n}\n\n#if FF_API_USER_VISIBLE_AVHWACCEL\nAVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel)\n{\n    return NULL;\n}\n\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\n{\n}\n#endif\n\n#if FF_API_LOCKMGR\nint av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n{\n    return 0;\n}\n#endif\n\nunsigned int avpriv_toupper4(unsigned int x)\n{\n    return av_toupper(x & 0xFF) +\n          (av_toupper((x >>  8) & 0xFF) << 8)  +\n          (av_toupper((x >> 16) & 0xFF) << 16) +\n((unsigned)av_toupper((x >> 24) & 0xFF) << 24);\n}\n\nint ff_thread_ref_frame(ThreadFrame *dst, ThreadFrame *src)\n{\n    int ret;\n\n    dst->owner[0] = src->owner[0];\n    dst->owner[1] = src->owner[1];\n\n    ret = av_frame_ref(dst->f, src->f);\n    if (ret < 0)\n        return ret;\n\n    av_assert0(!dst->progress);\n\n    if (src->progress &&\n        !(dst->progress = av_buffer_ref(src->progress))) {\n        ff_thread_release_buffer(dst->owner[0], dst);\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\n#if !HAVE_THREADS\n\nenum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)\n{\n    return ff_get_format(avctx, fmt);\n}\n\nint ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)\n{\n    f->owner[0] = f->owner[1] = avctx;\n    return ff_get_buffer(avctx, f->f, flags);\n}\n\nvoid ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n{\n    if (f->f)\n        av_frame_unref(f->f);\n}\n\nvoid ff_thread_finish_setup(AVCodecContext *avctx)\n{\n}\n\nvoid ff_thread_report_progress(ThreadFrame *f, int progress, int field)\n{\n}\n\nvoid ff_thread_await_progress(ThreadFrame *f, int progress, int field)\n{\n}\n\nint ff_thread_can_start_frame(AVCodecContext *avctx)\n{\n    return 1;\n}\n\nint ff_alloc_entries(AVCodecContext *avctx, int count)\n{\n    return 0;\n}\n\nvoid ff_reset_entries(AVCodecContext *avctx)\n{\n}\n\nvoid ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int shift)\n{\n}\n\nvoid ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n)\n{\n}\n\n#endif\n\nint avcodec_is_open(AVCodecContext *s)\n{\n    return !!s->internal;\n}\n\nint avpriv_bprint_to_extradata(AVCodecContext *avctx, struct AVBPrint *buf)\n{\n    int ret;\n    char *str;\n\n    ret = av_bprint_finalize(buf, &str);\n    if (ret < 0)\n        return ret;\n    if (!av_bprint_is_complete(buf)) {\n        av_free(str);\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->extradata = str;\n    /* Note: the string is NUL terminated (so extradata can be read as a\n     * string), but the ending character is not accounted in the size (in\n     * binary formats you are likely not supposed to mux that character). When\n     * extradata is copied, it is also padded with AV_INPUT_BUFFER_PADDING_SIZE\n     * zeros. */\n    avctx->extradata_size = buf->len;\n    return 0;\n}\n\nconst uint8_t *avpriv_find_start_code(const uint8_t *av_restrict p,\n                                      const uint8_t *end,\n                                      uint32_t *av_restrict state)\n{\n    int i;\n\n    av_assert0(p <= end);\n    if (p >= end)\n        return end;\n\n    for (i = 0; i < 3; i++) {\n        uint32_t tmp = *state << 8;\n        *state = tmp + *(p++);\n        if (tmp == 0x100 || p == end)\n            return p;\n    }\n\n    while (p < end) {\n        if      (p[-1] > 1      ) p += 3;\n        else if (p[-2]          ) p += 2;\n        else if (p[-3]|(p[-1]-1)) p++;\n        else {\n            p++;\n            break;\n        }\n    }\n\n    p = FFMIN(p, end) - 4;\n    *state = AV_RB32(p);\n\n    return p + 4;\n}\n\nAVCPBProperties *av_cpb_properties_alloc(size_t *size)\n{\n    AVCPBProperties *props = av_mallocz(sizeof(AVCPBProperties));\n    if (!props)\n        return NULL;\n\n    if (size)\n        *size = sizeof(*props);\n\n    props->vbv_delay = UINT64_MAX;\n\n    return props;\n}\n\nAVCPBProperties *ff_add_cpb_side_data(AVCodecContext *avctx)\n{\n    AVPacketSideData *tmp;\n    AVCPBProperties  *props;\n    size_t size;\n\n    props = av_cpb_properties_alloc(&size);\n    if (!props)\n        return NULL;\n\n    tmp = av_realloc_array(avctx->coded_side_data, avctx->nb_coded_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        av_freep(&props);\n        return NULL;\n    }\n\n    avctx->coded_side_data = tmp;\n    avctx->nb_coded_side_data++;\n\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].type = AV_PKT_DATA_CPB_PROPERTIES;\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].data = (uint8_t*)props;\n    avctx->coded_side_data[avctx->nb_coded_side_data - 1].size = size;\n\n    return props;\n}\n\nstatic void codec_parameters_reset(AVCodecParameters *par)\n{\n    av_freep(&par->extradata);\n\n    memset(par, 0, sizeof(*par));\n\n    par->codec_type          = AVMEDIA_TYPE_UNKNOWN;\n    par->codec_id            = AV_CODEC_ID_NONE;\n    par->format              = -1;\n    par->field_order         = AV_FIELD_UNKNOWN;\n    par->color_range         = AVCOL_RANGE_UNSPECIFIED;\n    par->color_primaries     = AVCOL_PRI_UNSPECIFIED;\n    par->color_trc           = AVCOL_TRC_UNSPECIFIED;\n    par->color_space         = AVCOL_SPC_UNSPECIFIED;\n    par->chroma_location     = AVCHROMA_LOC_UNSPECIFIED;\n    par->sample_aspect_ratio = (AVRational){ 0, 1 };\n    par->profile             = FF_PROFILE_UNKNOWN;\n    par->level               = FF_LEVEL_UNKNOWN;\n}\n\nAVCodecParameters *avcodec_parameters_alloc(void)\n{\n    AVCodecParameters *par = av_mallocz(sizeof(*par));\n\n    if (!par)\n        return NULL;\n    codec_parameters_reset(par);\n    return par;\n}\n\nvoid avcodec_parameters_free(AVCodecParameters **ppar)\n{\n    AVCodecParameters *par = *ppar;\n\n    if (!par)\n        return;\n    codec_parameters_reset(par);\n\n    av_freep(ppar);\n}\n\nint avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)\n{\n    codec_parameters_reset(dst);\n    memcpy(dst, src, sizeof(*dst));\n\n    dst->extradata      = NULL;\n    dst->extradata_size = 0;\n    if (src->extradata) {\n        dst->extradata = av_mallocz(src->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!dst->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(dst->extradata, src->extradata, src->extradata_size);\n        dst->extradata_size = src->extradata_size;\n    }\n\n    return 0;\n}\n\nint avcodec_parameters_from_context(AVCodecParameters *par,\n                                    const AVCodecContext *codec)\n{\n    codec_parameters_reset(par);\n\n    par->codec_type = codec->codec_type;\n    par->codec_id   = codec->codec_id;\n    par->codec_tag  = codec->codec_tag;\n\n    par->bit_rate              = codec->bit_rate;\n    par->bits_per_coded_sample = codec->bits_per_coded_sample;\n    par->bits_per_raw_sample   = codec->bits_per_raw_sample;\n    par->profile               = codec->profile;\n    par->level                 = codec->level;\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        par->format              = codec->pix_fmt;\n        par->width               = codec->width;\n        par->height              = codec->height;\n        par->field_order         = codec->field_order;\n        par->color_range         = codec->color_range;\n        par->color_primaries     = codec->color_primaries;\n        par->color_trc           = codec->color_trc;\n        par->color_space         = codec->colorspace;\n        par->chroma_location     = codec->chroma_sample_location;\n        par->sample_aspect_ratio = codec->sample_aspect_ratio;\n        par->video_delay         = codec->has_b_frames;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        par->format           = codec->sample_fmt;\n        par->channel_layout   = codec->channel_layout;\n        par->channels         = codec->channels;\n        par->sample_rate      = codec->sample_rate;\n        par->block_align      = codec->block_align;\n        par->frame_size       = codec->frame_size;\n        par->initial_padding  = codec->initial_padding;\n        par->trailing_padding = codec->trailing_padding;\n        par->seek_preroll     = codec->seek_preroll;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        par->width  = codec->width;\n        par->height = codec->height;\n        break;\n    }\n\n    if (codec->extradata) {\n        par->extradata = av_mallocz(codec->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!par->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(par->extradata, codec->extradata, codec->extradata_size);\n        par->extradata_size = codec->extradata_size;\n    }\n\n    return 0;\n}\n\nint avcodec_parameters_to_context(AVCodecContext *codec,\n                                  const AVCodecParameters *par)\n{\n    codec->codec_type = par->codec_type;\n    codec->codec_id   = par->codec_id;\n    codec->codec_tag  = par->codec_tag;\n\n    codec->bit_rate              = par->bit_rate;\n    codec->bits_per_coded_sample = par->bits_per_coded_sample;\n    codec->bits_per_raw_sample   = par->bits_per_raw_sample;\n    codec->profile               = par->profile;\n    codec->level                 = par->level;\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        codec->pix_fmt                = par->format;\n        codec->width                  = par->width;\n        codec->height                 = par->height;\n        codec->field_order            = par->field_order;\n        codec->color_range            = par->color_range;\n        codec->color_primaries        = par->color_primaries;\n        codec->color_trc              = par->color_trc;\n        codec->colorspace             = par->color_space;\n        codec->chroma_sample_location = par->chroma_location;\n        codec->sample_aspect_ratio    = par->sample_aspect_ratio;\n        codec->has_b_frames           = par->video_delay;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        codec->sample_fmt       = par->format;\n        codec->channel_layout   = par->channel_layout;\n        codec->channels         = par->channels;\n        codec->sample_rate      = par->sample_rate;\n        codec->block_align      = par->block_align;\n        codec->frame_size       = par->frame_size;\n        codec->delay            =\n        codec->initial_padding  = par->initial_padding;\n        codec->trailing_padding = par->trailing_padding;\n        codec->seek_preroll     = par->seek_preroll;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        codec->width  = par->width;\n        codec->height = par->height;\n        break;\n    }\n\n    if (par->extradata) {\n        av_freep(&codec->extradata);\n        codec->extradata = av_mallocz(par->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!codec->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(codec->extradata, par->extradata, par->extradata_size);\n        codec->extradata_size = par->extradata_size;\n    }\n\n    return 0;\n}\n\nint ff_alloc_a53_sei(const AVFrame *frame, size_t prefix_len,\n                     void **data, size_t *sei_size)\n{\n    AVFrameSideData *side_data = NULL;\n    uint8_t *sei_data;\n\n    if (frame)\n        side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_A53_CC);\n\n    if (!side_data) {\n        *data = NULL;\n        return 0;\n    }\n\n    *sei_size = side_data->size + 11;\n    *data = av_mallocz(*sei_size + prefix_len);\n    if (!*data)\n        return AVERROR(ENOMEM);\n    sei_data = (uint8_t*)*data + prefix_len;\n\n    // country code\n    sei_data[0] = 181;\n    sei_data[1] = 0;\n    sei_data[2] = 49;\n\n    /**\n     * 'GA94' is standard in North America for ATSC, but hard coding\n     * this style may not be the right thing to do -- other formats\n     * do exist. This information is not available in the side_data\n     * so we are going with this right now.\n     */\n    AV_WL32(sei_data + 3, MKTAG('G', 'A', '9', '4'));\n    sei_data[7] = 3;\n    sei_data[8] = ((side_data->size/3) & 0x1f) | 0x40;\n    sei_data[9] = 0;\n\n    memcpy(sei_data + 10, side_data->data, side_data->size);\n\n    sei_data[side_data->size+10] = 255;\n\n    return 0;\n}\n\nint64_t ff_guess_coded_bitrate(AVCodecContext *avctx)\n{\n    AVRational framerate = avctx->framerate;\n    int bits_per_coded_sample = avctx->bits_per_coded_sample;\n    int64_t bitrate;\n\n    if (!(framerate.num && framerate.den))\n        framerate = av_inv_q(avctx->time_base);\n    if (!(framerate.num && framerate.den))\n        return 0;\n\n    if (!bits_per_coded_sample) {\n        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n        bits_per_coded_sample = av_get_bits_per_pixel(desc);\n    }\n    bitrate = (int64_t)bits_per_coded_sample * avctx->width * avctx->height *\n              framerate.num / framerate.den;\n\n    return bitrate;\n}\n\nint ff_int_from_list_or_default(void *ctx, const char * val_name, int val,\n                                const int * array_valid_values, int default_value)\n{\n    int i = 0, ref_val;\n\n    while (1) {\n        ref_val = array_valid_values[i];\n        if (ref_val == INT_MAX)\n            break;\n        if (val == ref_val)\n            return val;\n        i++;\n    }\n    /* val is not a valid value */\n    av_log(ctx, AV_LOG_DEBUG,\n           \"%s %d are not supported. Set to default value : %d\\n\", val_name, val, default_value);\n    return default_value;\n}\n"], "filenames": ["libavcodec/utils.c"], "buggy_code_start_loc": [1027], "buggy_code_end_loc": [1028], "fixing_code_start_loc": [1027], "fixing_code_end_loc": [1028], "type": "CWE-476", "message": "In FFmpeg before 4.2, avcodec_open2 in libavcodec/utils.c allows a NULL pointer dereference and possibly unspecified other impact when there is no valid close function pointer.", "other": {"cve": {"id": "CVE-2019-17539", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-14T02:15:10.513", "lastModified": "2021-06-10T13:58:02.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FFmpeg before 4.2, avcodec_open2 in libavcodec/utils.c allows a NULL pointer dereference and possibly unspecified other impact when there is no valid close function pointer."}, {"lang": "es", "value": "En FFmpeg versiones anteriores a 4.2, la funci\u00f3n avcodec_open2 en el archivo libavcodec/utils.c permite una desreferencia del puntero NULL y posiblemente otro impacto no especificado cuando no existe un puntero de funci\u00f3n de cierre v\u00e1lido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.7", "matchCriteriaId": "3F99F882-22B1-4E7C-8FEE-89C4604E5DAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.0.5", "matchCriteriaId": "A8A5D02A-1A59-4AF1-ABBD-52AD5943F61D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1", "versionEndExcluding": "4.1.5", "matchCriteriaId": "7BCF2541-70F2-48DC-83B3-A7EE329F315F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=15733", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/8df6884832ec413cf032dfaa45c23b1c7876670c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-65", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4431-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4722", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/8df6884832ec413cf032dfaa45c23b1c7876670c"}}