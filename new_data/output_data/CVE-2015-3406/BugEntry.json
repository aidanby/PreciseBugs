{"buggy_code": ["use strict;\nuse inc::Module::Install 0.92;\n\n$|++;\n\nname            'Module-Signature';\nlicense         'CC0';\nall_from        'lib/Module/Signature.pm';\nreadme_from     'lib/Module/Signature.pm';\nrepository      'http://github.com/audreyt/module-signature';\ninstall_script  'script/cpansign';\nbuild_requires  'Test::More', 0, 'IPC::Run', 0;\n\n# On Win32 (excluding cygwin) we know that IO::Socket::INET,\n# which is needed for keyserver stuff, doesn't work. In fact\n# it potentially hangs forever. So bail out with a N/A on\n# Win32.\nif ( $^O eq 'MSWin32' and 0 ) {\n\tprint \"Keyserver behaviour is dangerous unreliable on Win32\\n\";\n\tprint \"Not installing on this platform.\\n\";\n\texit(255);\n} else {\n\trequires 'IO::Socket::INET' => 0;\n}\n\n# We will need something to handle SHA1/256\nunless (\n\tcan_use('Digest::SHA')  or\n\tcan_use('Digest::SHA::PurePerl') or\n\t(can_use('Digest::SHA1') and can_use('Digest::SHA256'))\n) {\n\t# Nothing installed, we need to install a digest module\n\tif ( can_cc() ) {\n\t\trequires 'Digest::SHA';\n\t} else {\n\t\trequires 'Digest::SHA::PurePerl';\n\t}\n}\n\n# The list of OpenPGP dependencies (which we use in several places)\nmy @OPEN_PGP = qw{\n     MIME::Base64             0\n     Compress::Zlib           0\n     Crypt::CBC               0\n     Crypt::DES               0\n     Crypt::Blowfish          0\n     Crypt::RIPEMD160         0\n     Tie::EncryptedHash       0\n     Class::Loader            0\n     Convert::ASCII::Armour   0\n     Data::Buffer             0.04\n     Digest::MD2              0\n     Math::Pari               0\n     Crypt::Random            0\n     Crypt::Primes            0\n     Crypt::DES_EDE3          0\n     Crypt::DSA               0\n     Crypt::RSA               0\n     Convert::ASN1            0\n     Convert::PEM             0\n     Crypt::OpenPGP           1.00\n};\n\n# Is openpgp currently installed\nif ( can_use('Crypt::OpenPGP') ) {\n\t# If OpenPGP is already installed, so relist all the\n\t# dependencies so they will upgrade as needed.\n\trequires( @OPEN_PGP );\n\n} elsif ( my $gpg = locate_gpg() ) {\n\t# We SHOULD have gpg, double-check formally\n\trequires_external_bin $gpg;\n} elsif ( can_cc() and $ENV{AUTOMATED_TESTING} ) {\n\t# Dive headlong into a full Crypt::OpenPGP install.\n\trequires( @OPEN_PGP );\n} else {\n\t# Ask the user what to do\n\task_user();\n}\n\nunless ( can_run('diff') ) {\n\t# We know Text::Diff fails on Cygwin (for now)\n\tif ( $^O ne 'Cygwin' ) {\n\t\trequires 'Algorithm::Diff';\n\t\trequires 'Text::Diff';\n\t}\n}\n\nsign; WriteAll;\n\n\n\n\n\n#####################################################################\n# Support Functions\n\nsub locate_gpg {\n\tprint \"Looking for GNU Privacy Guard (gpg), a cryptographic signature tool...\\n\";\n\n  \tmy ($gpg, $gpg_path);\n  \tfor my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n  \t\t$gpg_path = can_run($gpg_bin);\n  \t\tnext unless $gpg_path;\n  \t\tnext unless `$gpg_bin --version` =~ /GnuPG/;\n  \t\tnext unless defined `$gpg_bin --list-public-keys`;\n  \n  \t\t$gpg = $gpg_bin;\n  \t\tlast;\n  \t}\n  \tunless ( $gpg ) {\n\t\tprint \"gpg not found.\\n\";\n\t\treturn;\n\t}\n\n\tprint \"GnuPG found ($gpg_path).\\n\";\n\n\treturn 1 if grep { /^--installdeps/} @ARGV;\n\n\tif ( prompt(\"Import PAUSE and author keys to GnuPG?\", 'y' ) =~ /^y/i) {\n\t\tprint 'Importing... ';\n\t\tsystem $gpg, '--quiet', '--import', glob('*.pub');\n\t\tprint \"done.\\n\";\n\t}\n\n \treturn $gpg;\n}\n\nsub ask_user {\n\n    # Defined the prompt messages\n    my $message1 = <<'END_MESSAGE';\n\nCould not auto-detect a signature utility on your system.\n\nWhat do you want me to do?\n\n1) Let you install GnuPG manually while I'm waiting for your answer;\n   it is available at http://www.gnupg.org/download/ or may be available\n   from your platforms packaging system (for Open Source platforms).\n\nEND_MESSAGE\n\n    my $message2 = <<'END_MESSAGE';\n\n2) Automatically install Crypt::OpenPGP and the 20 modules it requires\n   from CPAN, which will give the same functionality as GnuPG.\n\nEND_MESSAGE\n\n\t# Present the options\n\tprint $message1;\n\n\tmy $option3 = 2;\n\tif ( can_cc() ) {\n\t\t$option3 = 3;\n\t\tprint $message2;\n\t}\n\n\tprint <<\"END_MESSAGE\";\n\n$option3) Forget this cryptographic signature stuff for now.\n\nEND_MESSAGE\n\n\tmy $choice;\n\tforeach ( 1 .. 3 ) {\n\t\t$choice = prompt(\"Your choice:\", 3) || 3;\n\t\tlast if $choice =~ /^[123]$/;\n\t\tprint \"Sorry, I cannot understand '$choice'.\\n\"\n\t}\n\n\tif ( $choice == 1 ) {\n\t\t# They claim to have installed gpg\n\t\trequires_external_bin 'gpg';\n\t} elsif ( $choice == 2 and $option3 == 3 ) {\n\t\t# They want to install Crypt::OpenPGP\n\t\trequires( @OPEN_PGP );\n\t} else {\n\t\t# Forget about it...\n\t\tprint \"Module::Signature is not wanted on this host.\\n\";\n\t\texit(0);\n\t}\n}\n", "NAME\n    Module::Signature - Module signature file manipulation\n\nSYNOPSIS\n    As a shell command:\n\n        % cpansign              # verify an existing SIGNATURE, or\n                                # make a new one if none exists\n\n        % cpansign sign         # make signature; overwrites existing one\n        % cpansign -s           # same thing\n\n        % cpansign verify       # verify a signature\n        % cpansign -v           # same thing\n        % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n        % cpansign help         # display this documentation\n        % cpansign -h           # same thing\n\n    In programs:\n\n        use Module::Signature qw(sign verify SIGNATURE_OK);\n        sign();\n        sign(overwrite => 1);       # overwrites without asking\n\n        # see the CONSTANTS section below\n        (verify() == SIGNATURE_OK) or die \"failed!\";\n\nDESCRIPTION\n    Module::Signature adds cryptographic authentications to CPAN\n    distributions, via the special SIGNATURE file.\n\n    If you are a module user, all you have to do is to remember to run\n    \"cpansign -v\" (or just \"cpansign\") before issuing \"perl Makefile.PL\" or\n    \"perl Build.PL\"; that will ensure the distribution has not been tampered\n    with.\n\n    Module authors can easily add the SIGNATURE file to the distribution\n    tarball; see \"NOTES\" below for how to do it as part of \"make dist\".\n\n    If you *really* want to sign a distribution manually, simply add\n    \"SIGNATURE\" to MANIFEST, then type \"cpansign -s\" immediately before\n    \"make dist\". Be sure to delete the SIGNATURE file afterwards.\n\n    Please also see \"NOTES\" about MANIFEST.SKIP issues, especially if you\n    are using Module::Build or writing your own MANIFEST.SKIP.\n\nVARIABLES\n    No package variables are exported by default.\n\n    $Verbose\n        If true, Module::Signature will give information during processing\n        including gpg output. If false, Module::Signature will be as quiet\n        as possible as long as everything is working ok. Defaults to false.\n\n    $SIGNATURE\n        The filename for a distribution's signature file. Defaults to\n        \"SIGNATURE\".\n\n    $KeyServer\n        The OpenPGP key server for fetching the author's public key\n        (currently only implemented on \"gpg\", not \"Crypt::OpenPGP\"). May be\n        set to a false value to prevent this module from fetching public\n        keys.\n\n    $KeyServerPort\n        The OpenPGP key server port, defaults to 11371.\n\n    $Timeout\n        Maximum time to wait to try to establish a link to the key server.\n        Defaults to 3.\n\n    $AutoKeyRetrieve\n        Whether to automatically fetch unknown keys from the key server.\n        Defaults to 1.\n\n    $Cipher\n        The default cipher used by the \"Digest\" module to make signature\n        files. Defaults to \"SHA1\", but may be changed to other ciphers via\n        the \"MODULE_SIGNATURE_CIPHER\" environment variable if the SHA1\n        cipher is undesirable for the user.\n\n        The cipher specified in the SIGNATURE file's first entry will be\n        used to validate its integrity. For \"SHA1\", the user needs to have\n        any one of these four modules installed: Digest::SHA, Digest::SHA1,\n        Digest::SHA::PurePerl, or (currently nonexistent)\n        Digest::SHA1::PurePerl.\n\n    $Preamble\n        The explanatory text written to newly generated SIGNATURE files\n        before the actual entries.\n\nENVIRONMENT\n    Module::Signature honors these environment variables:\n\n    MODULE_SIGNATURE_CIPHER\n        Works like $Cipher.\n\n    MODULE_SIGNATURE_VERBOSE\n        Works like $Verbose.\n\n    MODULE_SIGNATURE_KEYSERVER\n        Works like $KeyServer.\n\n    MODULE_SIGNATURE_KEYSERVERPORT\n        Works like $KeyServerPort.\n\n    MODULE_SIGNATURE_TIMEOUT\n        Works like $Timeout.\n\nCONSTANTS\n    These constants are not exported by default.\n\n    CANNOT_VERIFY (0E0)\n        Cannot verify the OpenPGP signature, maybe due to the lack of a\n        network connection to the key server, or if neither gnupg nor\n        Crypt::OpenPGP exists on the system.\n\n    SIGNATURE_OK (0)\n        Signature successfully verified.\n\n    SIGNATURE_MISSING (-1)\n        The SIGNATURE file does not exist.\n\n    SIGNATURE_MALFORMED (-2)\n        The signature file does not contains a valid OpenPGP message.\n\n    SIGNATURE_BAD (-3)\n        Invalid signature detected -- it might have been tampered with.\n\n    SIGNATURE_MISMATCH (-4)\n        The signature is valid, but files in the distribution have changed\n        since its creation.\n\n    MANIFEST_MISMATCH (-5)\n        There are extra files in the current directory not specified by the\n        MANIFEST file.\n\n    CIPHER_UNKNOWN (-6)\n        The cipher used by the signature file is not recognized by the\n        \"Digest\" and \"Digest::*\" modules.\n\nNOTES\n  Signing your module as part of \"make dist\"\n    The easiest way is to use Module::Install:\n\n        sign;       # put this before \"WriteAll\"\n        WriteAll;\n\n    For ExtUtils::MakeMaker (version 6.18 or above), you may do this:\n\n        WriteMakefile(\n            (MM->can('signature_target') ? (SIGN => 1) : ()),\n            # ... original arguments ...\n        );\n\n    Users of Module::Build may do this:\n\n        Module::Build->new(\n            (sign => 1),\n            # ... original arguments ...\n        )->create_build_script;\n\n  MANIFEST.SKIP Considerations\n    (The following section is lifted from Iain Truskett's Test::Signature\n    module, under the Perl license. Thanks, Iain!)\n\n    It is imperative that your MANIFEST and MANIFEST.SKIP files be accurate\n    and complete. If you are using \"ExtUtils::MakeMaker\" and you do not have\n    a MANIFEST.SKIP file, then don't worry about the rest of this. If you do\n    have a MANIFEST.SKIP file, or you use \"Module::Build\", you must read\n    this.\n\n    Since the test is run at \"make test\" time, the distribution has been\n    made. Thus your MANIFEST.SKIP file should have the entries listed below.\n\n    If you're using \"ExtUtils::MakeMaker\", you should have, at least:\n\n        #defaults\n        ^Makefile$\n        ^blib/\n        ^pm_to_blib\n        ^blibdirs\n\n    These entries are part of the default set provided by\n    \"ExtUtils::Manifest\", which is ignored if you provide your own\n    MANIFEST.SKIP file.\n\n    If you are using \"Module::Build\", you should have two extra entries:\n\n        ^Build$\n        ^_build/\n\n    If you don't have the correct entries, \"Module::Signature\" will complain\n    that you have:\n\n        ==> MISMATCHED content between MANIFEST and distribution files! <==\n\n    You should note this during normal development testing anyway.\n\n  Testing signatures\n    You may add this code as t/0-signature.t in your distribution tree:\n\n        #!/usr/bin/perl\n\n        use strict;\n        print \"1..1\\n\";\n\n        if (!$ENV{TEST_SIGNATURE}) {\n            print \"ok 1 # skip Set the environment variable\",\n                        \" TEST_SIGNATURE to enable this test\\n\";\n        }\n        elsif (!-s 'SIGNATURE') {\n            print \"ok 1 # skip No signature file found\\n\";\n        }\n        elsif (!eval { require Module::Signature; 1 }) {\n            print \"ok 1 # skip \",\n                    \"Next time around, consider install Module::Signature, \",\n                    \"so you can verify the integrity of this distribution.\\n\";\n        }\n        elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n            print \"ok 1 # skip \",\n                    \"Cannot connect to the keyserver\\n\";\n        }\n        else {\n            (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n                or print \"not \";\n            print \"ok 1 # Valid signature\\n\";\n        }\n\n        __END__\n\n    If you are already using Test::More for testing, a more straightforward\n    version of t/0-signature.t can be found in the Module::Signature\n    distribution.\n\n    Also, if you prefer a more full-fledged testing package, and are willing\n    to inflict the dependency of Module::Build on your users, Iain\n    Truskett's Test::Signature might be a better choice.\n\nSEE ALSO\n    Digest, Digest::SHA, Digest::SHA1, Digest::SHA::PurePerl\n\n    ExtUtils::Manifest, Crypt::OpenPGP, Test::Signature\n\n    Module::Install, ExtUtils::MakeMaker, Module::Build\n\n    Dist::Zilla::Plugin::Signature\n\nAUTHORS\n    \u5510\u9cf3 <cpan@audreyt.org>\n\nCC0 1.0 Universal\n    To the extent possible under law, \u5510\u9cf3 has waived all copyright and\n    related or neighboring rights to Module-Signature.\n\n    This work is published from Taiwan.\n\n    <http://creativecommons.org/publicdomain/zero/1.0>\n\n", "package Module::Signature;\n$Module::Signature::VERSION = '0.73_01';\n\nuse 5.005;\nuse strict;\nuse vars qw($VERSION $SIGNATURE @ISA @EXPORT_OK);\nuse vars qw($Preamble $Cipher $Debug $Verbose $Timeout $AUTHOR);\nuse vars qw($KeyServer $KeyServerPort $AutoKeyRetrieve $CanKeyRetrieve);\n\nuse constant CANNOT_VERIFY       => '0E0';\nuse constant SIGNATURE_OK        => 0;\nuse constant SIGNATURE_MISSING   => -1;\nuse constant SIGNATURE_MALFORMED => -2;\nuse constant SIGNATURE_BAD       => -3;\nuse constant SIGNATURE_MISMATCH  => -4;\nuse constant MANIFEST_MISMATCH   => -5;\nuse constant CIPHER_UNKNOWN      => -6;\n\nuse ExtUtils::Manifest ();\nuse Exporter;\nuse File::Spec;\n\n@EXPORT_OK      = (\n    qw(sign verify),\n    qw($SIGNATURE $KeyServer $Cipher $Preamble),\n    (grep { /^[A-Z_]+_[A-Z_]+$/ } keys %Module::Signature::),\n);\n@ISA            = 'Exporter';\n\n$AUTHOR         = $ENV{MODULE_SIGNATURE_AUTHOR};\n$SIGNATURE      = 'SIGNATURE';\n$Timeout        = $ENV{MODULE_SIGNATURE_TIMEOUT} || 3;\n$Verbose        = $ENV{MODULE_SIGNATURE_VERBOSE} || 0;\n$KeyServer      = $ENV{MODULE_SIGNATURE_KEYSERVER} || 'pool.sks-keyservers.net';\n$KeyServerPort  = $ENV{MODULE_SIGNATURE_KEYSERVERPORT} || '11371';\n$Cipher         = $ENV{MODULE_SIGNATURE_CIPHER} || 'SHA1';\n$Preamble       = << \".\";\nThis file contains message digests of all files listed in MANIFEST,\nsigned via the Module::Signature module, version $VERSION.\n\nTo verify the content in this distribution, first make sure you have\nModule::Signature installed, then type:\n\n    % cpansign -v\n\nIt will check each file's integrity, as well as the signature's\nvalidity.  If \"==> Signature verified OK! <==\" is not displayed,\nthe distribution may already have been compromised, and you should\nnot run its Makefile.PL or Build.PL.\n\n.\n\n$AutoKeyRetrieve    = 1;\n$CanKeyRetrieve     = undef;\n\nsub _cipher_map {\n    my($sigtext) = @_;\n    my @lines = split /\\015?\\012/, $sigtext;\n    my %map;\n    for my $line (@lines) {\n        my($cipher,$digest,$file) = split \" \", $line, 3;\n        return unless defined $file;\n        $map{$file} = [$cipher, $digest];\n    }\n    return \\%map;\n}\n\nsub verify {\n    my %args = ( skip => 1, @_ );\n    my $rv;\n\n    (-r $SIGNATURE) or do {\n        warn \"==> MISSING Signature file! <==\\n\";\n        return SIGNATURE_MISSING;\n    };\n\n    (my $sigtext = _read_sigfile($SIGNATURE)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (my ($cipher_map) = _cipher_map($sigtext)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (defined(my $plaintext = _mkdigest($cipher_map))) or do {\n        warn \"==> UNKNOWN Cipher format! <==\\n\";\n        return CIPHER_UNKNOWN;\n    };\n\n    $rv = _verify($SIGNATURE, $sigtext, $plaintext);\n\n    if ($rv == SIGNATURE_OK) {\n        my ($mani, $file) = _fullcheck($args{skip});\n\n        if (@{$mani} or @{$file}) {\n            warn \"==> MISMATCHED content between MANIFEST and distribution files! <==\\n\";\n            return MANIFEST_MISMATCH;\n        }\n        else {\n            warn \"==> Signature verified OK! <==\\n\" if $Verbose;\n        }\n    }\n    elsif ($rv == SIGNATURE_BAD) {\n        warn \"==> BAD/TAMPERED signature detected! <==\\n\";\n    }\n    elsif ($rv == SIGNATURE_MISMATCH) {\n        warn \"==> MISMATCHED content between SIGNATURE and distribution files! <==\\n\";\n    }\n\n    return $rv;\n}\n\nsub _verify {\n    my $signature = shift || $SIGNATURE;\n    my $sigtext   = shift || '';\n    my $plaintext = shift || '';\n\n    local $SIGNATURE = $signature if $signature ne $SIGNATURE;\n\n    if ($AutoKeyRetrieve and !$CanKeyRetrieve) {\n        if (!defined $CanKeyRetrieve) {\n            require IO::Socket::INET;\n            my $sock = IO::Socket::INET->new(\n                Timeout => $Timeout,\n                PeerAddr => \"$KeyServer:$KeyServerPort\",\n            );\n            $CanKeyRetrieve = ($sock ? 1 : 0);\n            $sock->shutdown(2) if $sock;\n        }\n        $AutoKeyRetrieve = $CanKeyRetrieve;\n    }\n\n    if (my $version = _has_gpg()) {\n        return _verify_gpg($sigtext, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        return _verify_crypt_openpgp($sigtext, $plaintext);\n    }\n    else {\n        warn \"Cannot use GnuPG or Crypt::OpenPGP, please install either one first!\\n\";\n        return _compare($sigtext, $plaintext, CANNOT_VERIFY);\n    }\n}\n\nsub _has_gpg {\n    my $gpg = _which_gpg() or return;\n    `$gpg --version` =~ /GnuPG.*?(\\S+)\\s*$/m or return;\n    return $1;\n}\n\nsub _fullcheck {\n    my $skip = shift;\n    my @extra;\n\n    local $^W;\n    local $ExtUtils::Manifest::Quiet = 1;\n\n    my($mani, $file);\n    if( _legacy_extutils() ) {\n        my $_maniskip;\n        if ( _public_maniskip() ) {\n            $_maniskip = &ExtUtils::Manifest::maniskip;\n        } else {\n            $_maniskip = &ExtUtils::Manifest::_maniskip;\n        }\n\n        local *ExtUtils::Manifest::_maniskip = sub { sub {\n            return unless $skip;\n            my $ok = $_maniskip->(@_);\n            if ($ok ||= (!-e 'MANIFEST.SKIP' and _default_skip(@_))) {\n                print \"Skipping $_\\n\" for @_;\n                push @extra, @_;\n            }\n            return $ok;\n        } };\n\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n    else {\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n\n    foreach my $makefile ('Makefile', 'Build') {\n        warn \"==> SKIPPED CHECKING '$_'!\" .\n                (-e \"$_.PL\" && \" (run $_.PL to ensure its integrity)\") .\n                \" <===\\n\" for grep $_ eq $makefile, @extra;\n    }\n\n    @{$mani} = grep {$_ ne 'SIGNATURE'} @{$mani};\n\n    warn \"Not in MANIFEST: $_\\n\" for @{$file};\n    warn \"No such file: $_\\n\" for @{$mani};\n\n    return ($mani, $file);\n}\n\nsub _legacy_extutils {\n    # ExtUtils::Manifest older than 1.58 does not handle MYMETA.\n    return (ExtUtils::Manifest->VERSION < 1.58);\n}\n\nsub _public_maniskip {\n    # ExtUtils::Manifest 1.54 onwards have public maniskip\n    return (ExtUtils::Manifest->VERSION > 1.53);\n}\n\nsub _default_skip {\n    local $_ = shift;\n    return 1 if /\\bRCS\\b/ or /\\bCVS\\b/ or /\\B\\.svn\\b/ or /,v$/\n             or /^MANIFEST\\.bak/ or /^Makefile$/ or /^blib\\//\n             or /^MakeMaker-\\d/ or /^pm_to_blib/ or /^blibdirs/\n             or /^_build\\// or /^Build$/ or /^pmfiles\\.dat/\n             or /^MYMETA\\./\n             or /~$/ or /\\.old$/ or /\\#$/ or /^\\.#/;\n}\n\nmy $which_gpg;\nsub _which_gpg {\n    # Cache it so we don't need to keep checking.\n    return $which_gpg if $which_gpg;\n\n    for my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n        my $version = `$gpg_bin --version 2>&1`;\n        if( $version && $version =~ /GnuPG/ ) {\n            $which_gpg = $gpg_bin;\n            return $which_gpg;\n        }\n    }\n}\n\nsub _verify_gpg {\n    my ($sigtext, $plaintext, $version) = @_;\n\n    local $SIGNATURE = Win32::GetShortPathName($SIGNATURE)\n        if defined &Win32::GetShortPathName and $SIGNATURE =~ /[^-\\w.:~\\\\\\/]/;\n\n    my $keyserver = _keyserver($version);\n\n    my $gpg = _which_gpg();\n    my @quiet = $Verbose ? () : qw(-q --logger-fd=1);\n    my @cmd = (\n        $gpg, qw(--verify --batch --no-tty), @quiet, ($KeyServer ? (\n            \"--keyserver=$keyserver\",\n            ($AutoKeyRetrieve and $version ge '1.0.7')\n                ? '--keyserver-options=auto-key-retrieve'\n                : ()\n        ) : ()), $SIGNATURE\n    );\n\n    my $output = '';\n    if( $Verbose ) {\n        warn \"Executing @cmd\\n\";\n        system @cmd;\n    }\n    else {\n        my $cmd = join ' ', @cmd;\n        $output = `$cmd`;\n    }\n\n    if( $? ) {\n        print STDERR $output;\n    }\n    elsif ($output =~ /((?: +[\\dA-F]{4}){10,})/) {\n        warn \"WARNING: This key is not certified with a trusted signature!\\n\";\n        warn \"Primary key fingerprint:$1\\n\";\n    }\n\n    return SIGNATURE_BAD if ($? and $AutoKeyRetrieve);\n    return _compare($sigtext, $plaintext, (!$?) ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _keyserver {\n    my $version = shift;\n    my $scheme = 'x-hkp';\n    $scheme = 'hkp' if $version ge '1.2.0';\n\n    return \"$scheme://$KeyServer:$KeyServerPort\";\n}\n\nsub _verify_crypt_openpgp {\n    my ($sigtext, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new(\n        ($KeyServer) ? ( KeyServer => $KeyServer, AutoKeyRetrieve => $AutoKeyRetrieve ) : (),\n    );\n    my $rv = $pgp->handle( Filename => $SIGNATURE )\n        or die $pgp->errstr;\n\n    return SIGNATURE_BAD if (!$rv->{Validity} and $AutoKeyRetrieve);\n\n    if ($rv->{Validity}) {\n        warn 'Signature made ', scalar localtime($rv->{Signature}->timestamp),\n             ' using key ID ', substr(uc(unpack('H*', $rv->{Signature}->key_id)), -8), \"\\n\",\n             \"Good signature from \\\"$rv->{Validity}\\\"\\n\" if $Verbose;\n    }\n    else {\n        warn \"Cannot verify signature; public key not found\\n\";\n    }\n\n    return _compare($sigtext, $plaintext, $rv->{Validity} ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _read_sigfile {\n    my $sigfile = shift;\n    my $signature = '';\n    my $well_formed;\n\n    local *D;\n    open D, $sigfile or die \"Could not open $sigfile: $!\";\n\n    if ($] >= 5.006 and <D> =~ /\\r/) {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n        binmode D, ':crlf';\n    } else {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n    }\n\n    while (<D>) {\n        next if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n        last if /^-----BEGIN PGP SIGNATURE/;\n\n        $signature .= $_;\n    }\n\n    return ((split(/\\n+/, $signature, 2))[1]);\n}\n\nsub _compare {\n    my ($str1, $str2, $ok) = @_;\n\n    # normalize all linebreaks\n    $str1 =~ s/[^\\S ]+/\\n/g; $str2 =~ s/[^\\S ]+/\\n/g;\n\n    return $ok if $str1 eq $str2;\n\n    if (eval { require Text::Diff; 1 }) {\n        warn \"--- $SIGNATURE \".localtime((stat($SIGNATURE))[9]).\"\\n\";\n        warn '+++ (current) '.localtime().\"\\n\";\n        warn Text::Diff::diff( \\$str1, \\$str2, { STYLE => 'Unified' } );\n    }\n    else {\n        local (*D, *S);\n        open S, $SIGNATURE or die \"Could not open $SIGNATURE: $!\";\n        open D, \"| diff -u $SIGNATURE -\" or (warn \"Could not call diff: $!\", return SIGNATURE_MISMATCH);\n        while (<S>) {\n            print D $_ if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n            print D if (/^Hash: / .. /^$/);\n            next if (1 .. /^-----BEGIN PGP SIGNATURE/);\n            print D $str2, \"-----BEGIN PGP SIGNATURE-----\\n\", $_ and last;\n        }\n        print D <S>;\n        close D;\n    }\n\n    return SIGNATURE_MISMATCH;\n}\n\nsub sign {\n    my %args = ( skip => 1, @_ );\n    my $overwrite = $args{overwrite};\n    my $plaintext = _mkdigest();\n\n    my ($mani, $file) = _fullcheck($args{skip});\n\n    if (@{$mani} or @{$file}) {\n        warn \"==> MISMATCHED content between MANIFEST and the distribution! <==\\n\";\n        warn \"==> Please correct your MANIFEST file and/or delete extra files. <==\\n\";\n    }\n\n    if (!$overwrite and -e $SIGNATURE and -t STDIN) {\n        local $/ = \"\\n\";\n        print \"$SIGNATURE already exists; overwrite [y/N]? \";\n        return unless <STDIN> =~ /[Yy]/;\n    }\n\n    if (my $version = _has_gpg()) {\n        _sign_gpg($SIGNATURE, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        _sign_crypt_openpgp($SIGNATURE, $plaintext);\n    }\n    else {\n        die 'Cannot use GnuPG or Crypt::OpenPGP, please install either one first!';\n    }\n\n    warn \"==> SIGNATURE file created successfully. <==\\n\";\n    return SIGNATURE_OK;\n}\n\nsub _sign_gpg {\n    my ($sigfile, $plaintext, $version) = @_;\n\n    die \"Could not write to $sigfile\"\n        if -e $sigfile and (-d $sigfile or not -w $sigfile);\n\n    my $gpg = _which_gpg();\n\n    local *D;\n    my $set_key = '';\n    $set_key = \"--default-key $AUTHOR\" if($AUTHOR);\n    open D, \"| $gpg $set_key --clearsign >> $sigfile.tmp\" or die \"Could not call $gpg: $!\";\n    print D $plaintext;\n    close D;\n\n    (-e \"$sigfile.tmp\" and -s \"$sigfile.tmp\") or do {\n        unlink \"$sigfile.tmp\";\n        die \"Cannot find $sigfile.tmp, signing aborted.\\n\";\n    };\n\n    open D, \"$sigfile.tmp\" or die \"Cannot open $sigfile.tmp: $!\";\n\n    open S, \">$sigfile\" or do {\n        unlink \"$sigfile.tmp\";\n        die \"Could not write to $sigfile: $!\";\n    };\n\n    print S $Preamble;\n    print S <D>;\n\n    close S;\n    close D;\n\n    unlink(\"$sigfile.tmp\");\n\n    my $key_id;\n    my $key_name;\n    # This doesn't work because the output from verify goes to STDERR.\n    # If I try to redirect it using \"--logger-fd 1\" it just hangs.\n    # WTF?\n    my @verify = `$gpg --batch --verify $SIGNATURE`;\n    while (@verify) {\n        if (/key ID ([0-9A-F]+)$/) {\n            $key_id = $1;\n        } elsif (/signature from \"(.+)\"$/) {\n            $key_name = $1;\n        }\n    }\n\n    my $found_name;\n    my $found_key;\n    if (defined $key_id && defined $key_name) {\n        my $keyserver = _keyserver($version);\n        while (`$gpg --batch --keyserver=$keyserver --search-keys '$key_name'`) {\n            if (/^\\(\\d+\\)/) {\n                $found_name = 0;\n            } elsif ($found_name) {\n                if (/key \\Q$key_id\\E/) {\n                    $found_key = 1;\n                    last;\n                }\n            }\n\n            if (/\\Q$key_name\\E/) {\n                $found_name = 1;\n                next;\n            }\n        }\n\n        unless ($found_key) {\n            _warn_non_public_signature($key_name);\n        }\n    }\n\n    return 1;\n}\n\nsub _sign_crypt_openpgp {\n    my ($sigfile, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new;\n    my $ring = Crypt::OpenPGP::KeyRing->new(\n        Filename => $pgp->{cfg}->get('SecRing')\n    ) or die $pgp->error(Crypt::OpenPGP::KeyRing->errstr);\n    my $kb = $ring->find_keyblock_by_index(-1)\n        or die $pgp->error('Can\\'t find last keyblock: ' . $ring->errstr);\n\n    my $cert = $kb->signing_key;\n    my $uid = $cert->uid($kb->primary_uid);\n    warn \"Debug: acquiring signature from $uid\\n\" if $Debug;\n\n    my $signature = $pgp->sign(\n        Data       => $plaintext,\n        Detach     => 0,\n        Clearsign  => 1,\n        Armour     => 1,\n        Key        => $cert,\n        PassphraseCallback => \\&Crypt::OpenPGP::_default_passphrase_cb,\n    ) or die $pgp->errstr;\n\n\n    local *D;\n    open D, \"> $sigfile\" or die \"Could not write to $sigfile: $!\";\n    print D $Preamble;\n    print D $signature;\n    close D;\n\n    require Crypt::OpenPGP::KeyServer;\n    my $server = Crypt::OpenPGP::KeyServer->new(Server => $KeyServer);\n\n    unless ($server->find_keyblock_by_keyid($cert->key_id)) {\n        _warn_non_public_signature($uid);\n    }\n\n    return 1;\n}\n\nsub _warn_non_public_signature {\n    my $uid = shift;\n\n    warn <<\"EOF\"\nYou have signed this distribution with a key ($uid) that cannot be\nfound on the public key server at $KeyServer.\n\nThis will probably cause signature verification to fail if your module\nis distributed on CPAN.\nEOF\n}\n\nsub _mkdigest {\n    my $digest = _mkdigest_files(@_) or return;\n    my $plaintext = '';\n\n    foreach my $file (sort keys %$digest) {\n        next if $file eq $SIGNATURE;\n        $plaintext .= \"@{$digest->{$file}} $file\\n\";\n    }\n\n    return $plaintext;\n}\n\nsub _digest_object {\n    my($algorithm) = @_;\n\n    # Avoid loading Digest::* from relative paths in @INC.\n    local @INC = grep { File::Spec->file_name_is_absolute($_) } @INC;\n\n    # Constrain algorithm name to be of form ABC123.\n    my ($base, $variant) = ($algorithm =~ /^([_a-zA-Z]+)([0-9]+)$/g)\n        or die \"Malformed algorithm name: $algorithm (should match /\\\\w+\\\\d+/)\";\n\n    my $obj = eval { Digest->new($algorithm) } || eval {\n        require \"Digest/$base.pm\"; \"Digest::$base\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm.pm\"; \"Digest::$algorithm\"->new\n    } || eval {\n        require \"Digest/$base/PurePerl.pm\"; \"Digest::$base\\::PurePerl\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm/PurePerl.pm\"; \"Digest::$algorithm\\::PurePerl\"->new\n    } or do { eval {\n        warn \"Unknown cipher: $algorithm, please install Digest::$base, Digest::$base$variant, or Digest::$base\\::PurePerl\\n\";\n    } and return } or do {\n        warn \"Unknown cipher: $algorithm, please install Digest::$algorithm\\n\"; return;\n    };\n    $obj;\n}\n\nsub _mkdigest_files {\n    my $verify_map = shift;\n    my $dosnames = (defined(&Dos::UseLFN) && Dos::UseLFN()==0);\n    my $read = ExtUtils::Manifest::maniread() || {};\n    my $found = ExtUtils::Manifest::manifind();\n    my(%digest) = ();\n    my($default_obj) = _digest_object($Cipher);\n FILE: foreach my $file (sort keys %$read){\n        next FILE if $file eq $SIGNATURE;\n        my($obj,$this_cipher,$this_hexdigest,$verify_digest);\n        if ($verify_map) {\n            if (my $vmf = $verify_map->{$file}) {\n                ($this_cipher,$verify_digest) = @$vmf;\n                if ($this_cipher eq $Cipher) {\n                    $obj = $default_obj;\n                } else {\n                    $obj = _digest_object($this_cipher);\n                }\n            } else {\n                $this_cipher = $Cipher;\n                $obj = $default_obj;\n            }\n        } else {\n            $this_cipher = $Cipher;\n            $obj = $default_obj;\n        }\n        warn \"Debug: collecting digest from $file\\n\" if $Debug;\n        if ($dosnames){\n            $file = lc $file;\n            $file =~ s!(\\.(\\w|-)+)!substr ($1,0,4)!ge;\n            $file =~ s!((\\w|-)+)!substr ($1,0,8)!ge;\n        }\n        unless ( exists $found->{$file} ) {\n            warn \"No such file: $file\\n\" if $Verbose;\n        }\n        else {\n            local *F;\n            open F, $file or die \"Cannot open $file for reading: $!\";\n            if (-B $file) {\n                binmode(F);\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            elsif ($^O eq 'MSWin32') {\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            else {\n                # Normalize by hand...\n                local $/;\n                binmode(F);\n                my $input = <F>;\n            VERIFYLOOP: for my $eol (\"\",\"\\015\\012\",\"\\012\") {\n                    my $lax_input = $input;\n                    if (! length $eol) {\n                        # first try is binary\n                    } else {\n                        my @lines = split /$eol/, $input, -1;\n                        if (grep /[\\015\\012]/, @lines) {\n                            # oops, apparently not a text file, treat as binary, forget @lines\n                        } else {\n                            my $other_eol = $eol eq \"\\012\" ? \"\\015\\012\" : \"\\012\";\n                            $lax_input = join $other_eol, @lines;\n                        }\n                    }\n                    $obj->add($lax_input);\n                    $this_hexdigest = $obj->hexdigest;\n                    if ($verify_digest) {\n                        if ($this_hexdigest eq $verify_digest) {\n                            last VERIFYLOOP;\n                        }\n                        $obj->reset;\n                    } else {\n                        last VERIFYLOOP;\n                    }\n                }\n            }\n            $digest{$file} = [$this_cipher, $this_hexdigest];\n            $obj->reset;\n        }\n    }\n\n    return \\%digest;\n}\n\n1;\n\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nModule::Signature - Module signature file manipulation\n\n=head1 SYNOPSIS\n\nAs a shell command:\n\n    % cpansign              # verify an existing SIGNATURE, or\n                            # make a new one if none exists\n\n    % cpansign sign         # make signature; overwrites existing one\n    % cpansign -s           # same thing\n\n    % cpansign verify       # verify a signature\n    % cpansign -v           # same thing\n    % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n    % cpansign help         # display this documentation\n    % cpansign -h           # same thing\n\nIn programs:\n\n    use Module::Signature qw(sign verify SIGNATURE_OK);\n    sign();\n    sign(overwrite => 1);       # overwrites without asking\n\n    # see the CONSTANTS section below\n    (verify() == SIGNATURE_OK) or die \"failed!\";\n\n=head1 DESCRIPTION\n\nB<Module::Signature> adds cryptographic authentications to CPAN\ndistributions, via the special F<SIGNATURE> file.\n\nIf you are a module user, all you have to do is to remember to run\nC<cpansign -v> (or just C<cpansign>) before issuing C<perl Makefile.PL>\nor C<perl Build.PL>; that will ensure the distribution has not been\ntampered with.\n\nModule authors can easily add the F<SIGNATURE> file to the distribution\ntarball; see L</NOTES> below for how to do it as part of C<make dist>.\n\nIf you I<really> want to sign a distribution manually, simply add\nC<SIGNATURE> to F<MANIFEST>, then type C<cpansign -s> immediately\nbefore C<make dist>.  Be sure to delete the F<SIGNATURE> file afterwards.\n\nPlease also see L</NOTES> about F<MANIFEST.SKIP> issues, especially if\nyou are using B<Module::Build> or writing your own F<MANIFEST.SKIP>.\n\n=head1 VARIABLES\n\nNo package variables are exported by default.\n\n=over 4\n\n=item $Verbose\n\nIf true, Module::Signature will give information during processing including\ngpg output.  If false, Module::Signature will be as quiet as possible as\nlong as everything is working ok.  Defaults to false.\n\n=item $SIGNATURE\n\nThe filename for a distribution's signature file.  Defaults to\nC<SIGNATURE>.\n\n=item $KeyServer\n\nThe OpenPGP key server for fetching the author's public key\n(currently only implemented on C<gpg>, not C<Crypt::OpenPGP>).\nMay be set to a false value to prevent this module from\nfetching public keys.\n\n=item $KeyServerPort\n\nThe OpenPGP key server port, defaults to C<11371>.\n\n=item $Timeout\n\nMaximum time to wait to try to establish a link to the key server.\nDefaults to C<3>.\n\n=item $AutoKeyRetrieve\n\nWhether to automatically fetch unknown keys from the key server.\nDefaults to C<1>.\n\n=item $Cipher\n\nThe default cipher used by the C<Digest> module to make signature\nfiles.  Defaults to C<SHA1>, but may be changed to other ciphers\nvia the C<MODULE_SIGNATURE_CIPHER> environment variable if the SHA1\ncipher is undesirable for the user.\n\nThe cipher specified in the F<SIGNATURE> file's first entry will\nbe used to validate its integrity.  For C<SHA1>, the user needs\nto have any one of these four modules installed: B<Digest::SHA>,\nB<Digest::SHA1>, B<Digest::SHA::PurePerl>, or (currently nonexistent)\nB<Digest::SHA1::PurePerl>.\n\n=item $Preamble\n\nThe explanatory text written to newly generated F<SIGNATURE> files\nbefore the actual entries.\n\n=back\n\n=head1 ENVIRONMENT\n\nB<Module::Signature> honors these environment variables:\n\n=over 4\n\n=item MODULE_SIGNATURE_CIPHER\n\nWorks like C<$Cipher>.\n\n=item MODULE_SIGNATURE_VERBOSE\n\nWorks like C<$Verbose>.\n\n=item MODULE_SIGNATURE_KEYSERVER\n\nWorks like C<$KeyServer>.\n\n=item MODULE_SIGNATURE_KEYSERVERPORT\n\nWorks like C<$KeyServerPort>.\n\n=item MODULE_SIGNATURE_TIMEOUT\n\nWorks like C<$Timeout>.\n\n=back\n\n=head1 CONSTANTS\n\nThese constants are not exported by default.\n\n=over 4\n\n=item CANNOT_VERIFY (C<0E0>)\n\nCannot verify the OpenPGP signature, maybe due to the lack of a network\nconnection to the key server, or if neither gnupg nor Crypt::OpenPGP\nexists on the system.\n\n=item SIGNATURE_OK (C<0>)\n\nSignature successfully verified.\n\n=item SIGNATURE_MISSING (C<-1>)\n\nThe F<SIGNATURE> file does not exist.\n\n=item SIGNATURE_MALFORMED (C<-2>)\n\nThe signature file does not contains a valid OpenPGP message.\n\n=item SIGNATURE_BAD (C<-3>)\n\nInvalid signature detected -- it might have been tampered with.\n\n=item SIGNATURE_MISMATCH (C<-4>)\n\nThe signature is valid, but files in the distribution have changed\nsince its creation.\n\n=item MANIFEST_MISMATCH (C<-5>)\n\nThere are extra files in the current directory not specified by\nthe MANIFEST file.\n\n=item CIPHER_UNKNOWN (C<-6>)\n\nThe cipher used by the signature file is not recognized by the\nC<Digest> and C<Digest::*> modules.\n\n=back\n\n=head1 NOTES\n\n=head2 Signing your module as part of C<make dist>\n\nThe easiest way is to use B<Module::Install>:\n\n    sign;       # put this before \"WriteAll\"\n    WriteAll;\n\nFor B<ExtUtils::MakeMaker> (version 6.18 or above), you may do this:\n\n    WriteMakefile(\n        (MM->can('signature_target') ? (SIGN => 1) : ()),\n        # ... original arguments ...\n    );\n\nUsers of B<Module::Build> may do this:\n\n    Module::Build->new(\n        (sign => 1),\n        # ... original arguments ...\n    )->create_build_script;\n\n=head2 F<MANIFEST.SKIP> Considerations\n\n(The following section is lifted from Iain Truskett's B<Test::Signature>\nmodule, under the Perl license.  Thanks, Iain!)\n\nIt is B<imperative> that your F<MANIFEST> and F<MANIFEST.SKIP> files be\naccurate and complete. If you are using C<ExtUtils::MakeMaker> and you\ndo not have a F<MANIFEST.SKIP> file, then don't worry about the rest of\nthis. If you do have a F<MANIFEST.SKIP> file, or you use\nC<Module::Build>, you must read this.\n\nSince the test is run at C<make test> time, the distribution has been\nmade. Thus your F<MANIFEST.SKIP> file should have the entries listed\nbelow.\n\nIf you're using C<ExtUtils::MakeMaker>, you should have, at least:\n\n    #defaults\n    ^Makefile$\n    ^blib/\n    ^pm_to_blib\n    ^blibdirs\n\nThese entries are part of the default set provided by\nC<ExtUtils::Manifest>, which is ignored if you provide your own\nF<MANIFEST.SKIP> file.\n\nIf you are using C<Module::Build>, you should have two extra entries:\n\n    ^Build$\n    ^_build/\n\nIf you don't have the correct entries, C<Module::Signature> will\ncomplain that you have:\n\n    ==> MISMATCHED content between MANIFEST and distribution files! <==\n\nYou should note this during normal development testing anyway.\n\n=head2 Testing signatures\n\nYou may add this code as F<t/0-signature.t> in your distribution tree:\n\n    #!/usr/bin/perl\n\n    use strict;\n    print \"1..1\\n\";\n\n    if (!$ENV{TEST_SIGNATURE}) {\n        print \"ok 1 # skip Set the environment variable\",\n                    \" TEST_SIGNATURE to enable this test\\n\";\n    }\n    elsif (!-s 'SIGNATURE') {\n        print \"ok 1 # skip No signature file found\\n\";\n    }\n    elsif (!eval { require Module::Signature; 1 }) {\n        print \"ok 1 # skip \",\n                \"Next time around, consider install Module::Signature, \",\n                \"so you can verify the integrity of this distribution.\\n\";\n    }\n    elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n        print \"ok 1 # skip \",\n                \"Cannot connect to the keyserver\\n\";\n    }\n    else {\n        (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n            or print \"not \";\n        print \"ok 1 # Valid signature\\n\";\n    }\n\n    __END__\n\nIf you are already using B<Test::More> for testing, a more\nstraightforward version of F<t/0-signature.t> can be found in the\nB<Module::Signature> distribution.\n\nAlso, if you prefer a more full-fledged testing package, and are\nwilling to inflict the dependency of B<Module::Build> on your users,\nIain Truskett's B<Test::Signature> might be a better choice.\n\n=cut\n\n=head1 SEE ALSO\n\nL<Digest>, L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA::PurePerl>\n\nL<ExtUtils::Manifest>, L<Crypt::OpenPGP>, L<Test::Signature>\n\nL<Module::Install>, L<ExtUtils::MakeMaker>, L<Module::Build>\n\nL<Dist::Zilla::Plugin::Signature>\n\n=head1 AUTHORS\n\n\u5510\u9cf3 E<lt>cpan@audreyt.orgE<gt>\n\n=head1 CC0 1.0 Universal\n\nTo the extent possible under law, \u5510\u9cf3 has waived all copyright and related\nor neighboring rights to Module-Signature.\n\nThis work is published from Taiwan.\n\nL<http://creativecommons.org/publicdomain/zero/1.0>\n\n=cut\n"], "fixing_code": ["use strict;\nuse inc::Module::Install 0.92;\n\n$|++;\n\nname            'Module-Signature';\nlicense         'CC0';\nall_from        'lib/Module/Signature.pm';\nreadme_from     'lib/Module/Signature.pm';\nrepository      'http://github.com/audreyt/module-signature';\ninstall_script  'script/cpansign';\nbuild_requires  'Test::More', 0, 'IPC::Run', 0;\nrequires        'File::Temp';\n\n# On Win32 (excluding cygwin) we know that IO::Socket::INET,\n# which is needed for keyserver stuff, doesn't work. In fact\n# it potentially hangs forever. So bail out with a N/A on\n# Win32.\nif ( $^O eq 'MSWin32' and 0 ) {\n\tprint \"Keyserver behaviour is dangerous unreliable on Win32\\n\";\n\tprint \"Not installing on this platform.\\n\";\n\texit(255);\n} else {\n\trequires 'IO::Socket::INET' => 0;\n}\n\n# We will need something to handle SHA1/256\nunless (\n\tcan_use('Digest::SHA')  or\n\tcan_use('Digest::SHA::PurePerl') or\n\t(can_use('Digest::SHA1') and can_use('Digest::SHA256'))\n) {\n\t# Nothing installed, we need to install a digest module\n\tif ( can_cc() ) {\n\t\trequires 'Digest::SHA';\n\t} else {\n\t\trequires 'Digest::SHA::PurePerl';\n\t}\n}\n\n# The list of OpenPGP dependencies (which we use in several places)\nmy @OPEN_PGP = qw{\n     MIME::Base64             0\n     Compress::Zlib           0\n     Crypt::CBC               0\n     Crypt::DES               0\n     Crypt::Blowfish          0\n     Crypt::RIPEMD160         0\n     Tie::EncryptedHash       0\n     Class::Loader            0\n     Convert::ASCII::Armour   0\n     Data::Buffer             0.04\n     Digest::MD2              0\n     Math::Pari               0\n     Crypt::Random            0\n     Crypt::Primes            0\n     Crypt::DES_EDE3          0\n     Crypt::DSA               0\n     Crypt::RSA               0\n     Convert::ASN1            0\n     Convert::PEM             0\n     Crypt::OpenPGP           1.00\n};\n\n# Is openpgp currently installed\nif ( can_use('Crypt::OpenPGP') ) {\n\t# If OpenPGP is already installed, so relist all the\n\t# dependencies so they will upgrade as needed.\n\trequires( @OPEN_PGP );\n\n} elsif ( my $gpg = locate_gpg() ) {\n\t# We SHOULD have gpg, double-check formally\n\trequires_external_bin $gpg;\n} elsif ( can_cc() and $ENV{AUTOMATED_TESTING} ) {\n\t# Dive headlong into a full Crypt::OpenPGP install.\n\trequires( @OPEN_PGP );\n} else {\n\t# Ask the user what to do\n\task_user();\n}\n\nunless ( can_run('diff') ) {\n\t# We know Text::Diff fails on Cygwin (for now)\n\tif ( $^O ne 'Cygwin' ) {\n\t\trequires 'Algorithm::Diff';\n\t\trequires 'Text::Diff';\n\t}\n}\n\nsign; WriteAll;\n\n\n\n\n\n#####################################################################\n# Support Functions\n\nsub locate_gpg {\n\tprint \"Looking for GNU Privacy Guard (gpg), a cryptographic signature tool...\\n\";\n\n  \tmy ($gpg, $gpg_path);\n  \tfor my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n  \t\t$gpg_path = can_run($gpg_bin);\n  \t\tnext unless $gpg_path;\n  \t\tnext unless `$gpg_bin --version` =~ /GnuPG/;\n  \t\tnext unless defined `$gpg_bin --list-public-keys`;\n  \n  \t\t$gpg = $gpg_bin;\n  \t\tlast;\n  \t}\n  \tunless ( $gpg ) {\n\t\tprint \"gpg not found.\\n\";\n\t\treturn;\n\t}\n\n\tprint \"GnuPG found ($gpg_path).\\n\";\n\n\treturn 1 if grep { /^--installdeps/} @ARGV;\n\n\tif ( prompt(\"Import PAUSE and author keys to GnuPG?\", 'y' ) =~ /^y/i) {\n\t\tprint 'Importing... ';\n\t\tsystem $gpg, '--quiet', '--import', glob('*.pub');\n\t\tprint \"done.\\n\";\n\t}\n\n \treturn $gpg;\n}\n\nsub ask_user {\n\n    # Defined the prompt messages\n    my $message1 = <<'END_MESSAGE';\n\nCould not auto-detect a signature utility on your system.\n\nWhat do you want me to do?\n\n1) Let you install GnuPG manually while I'm waiting for your answer;\n   it is available at http://www.gnupg.org/download/ or may be available\n   from your platforms packaging system (for Open Source platforms).\n\nEND_MESSAGE\n\n    my $message2 = <<'END_MESSAGE';\n\n2) Automatically install Crypt::OpenPGP and the 20 modules it requires\n   from CPAN, which will give the same functionality as GnuPG.\n\nEND_MESSAGE\n\n\t# Present the options\n\tprint $message1;\n\n\tmy $option3 = 2;\n\tif ( can_cc() ) {\n\t\t$option3 = 3;\n\t\tprint $message2;\n\t}\n\n\tprint <<\"END_MESSAGE\";\n\n$option3) Forget this cryptographic signature stuff for now.\n\nEND_MESSAGE\n\n\tmy $choice;\n\tforeach ( 1 .. 3 ) {\n\t\t$choice = prompt(\"Your choice:\", 3) || 3;\n\t\tlast if $choice =~ /^[123]$/;\n\t\tprint \"Sorry, I cannot understand '$choice'.\\n\"\n\t}\n\n\tif ( $choice == 1 ) {\n\t\t# They claim to have installed gpg\n\t\trequires_external_bin 'gpg';\n\t} elsif ( $choice == 2 and $option3 == 3 ) {\n\t\t# They want to install Crypt::OpenPGP\n\t\trequires( @OPEN_PGP );\n\t} else {\n\t\t# Forget about it...\n\t\tprint \"Module::Signature is not wanted on this host.\\n\";\n\t\texit(0);\n\t}\n}\n", "NAME\n    Module::Signature - Module signature file manipulation\n\nSYNOPSIS\n    As a shell command:\n\n        % cpansign              # verify an existing SIGNATURE, or\n                                # make a new one if none exists\n\n        % cpansign sign         # make signature; overwrites existing one\n        % cpansign -s           # same thing\n\n        % cpansign verify       # verify a signature\n        % cpansign -v           # same thing\n        % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n        % cpansign help         # display this documentation\n        % cpansign -h           # same thing\n\n    In programs:\n\n        use Module::Signature qw(sign verify SIGNATURE_OK);\n        sign();\n        sign(overwrite => 1);       # overwrites without asking\n\n        # see the CONSTANTS section below\n        (verify() == SIGNATURE_OK) or die \"failed!\";\n\nDESCRIPTION\n    Module::Signature adds cryptographic authentications to CPAN\n    distributions, via the special SIGNATURE file.\n\n    If you are a module user, all you have to do is to remember to run\n    \"cpansign -v\" (or just \"cpansign\") before issuing \"perl Makefile.PL\" or\n    \"perl Build.PL\"; that will ensure the distribution has not been tampered\n    with.\n\n    Module authors can easily add the SIGNATURE file to the distribution\n    tarball; see \"NOTES\" below for how to do it as part of \"make dist\".\n\n    If you *really* want to sign a distribution manually, simply add\n    \"SIGNATURE\" to MANIFEST, then type \"cpansign -s\" immediately before\n    \"make dist\". Be sure to delete the SIGNATURE file afterwards.\n\n    Please also see \"NOTES\" about MANIFEST.SKIP issues, especially if you\n    are using Module::Build or writing your own MANIFEST.SKIP.\n\nVARIABLES\n    No package variables are exported by default.\n\n    $Verbose\n        If true, Module::Signature will give information during processing\n        including gpg output. If false, Module::Signature will be as quiet\n        as possible as long as everything is working ok. Defaults to false.\n\n    $SIGNATURE\n        The filename for a distribution's signature file. Defaults to\n        \"SIGNATURE\".\n\n    $KeyServer\n        The OpenPGP key server for fetching the author's public key\n        (currently only implemented on \"gpg\", not \"Crypt::OpenPGP\"). May be\n        set to a false value to prevent this module from fetching public\n        keys.\n\n    $KeyServerPort\n        The OpenPGP key server port, defaults to 11371.\n\n    $Timeout\n        Maximum time to wait to try to establish a link to the key server.\n        Defaults to 3.\n\n    $AutoKeyRetrieve\n        Whether to automatically fetch unknown keys from the key server.\n        Defaults to 1.\n\n    $Cipher\n        The default cipher used by the \"Digest\" module to make signature\n        files. Defaults to \"SHA1\", but may be changed to other ciphers via\n        the \"MODULE_SIGNATURE_CIPHER\" environment variable if the SHA1\n        cipher is undesirable for the user.\n\n        The cipher specified in the SIGNATURE file's first entry will be\n        used to validate its integrity. For \"SHA1\", the user needs to have\n        any one of these four modules installed: Digest::SHA, Digest::SHA1,\n        Digest::SHA::PurePerl, or (currently nonexistent)\n        Digest::SHA1::PurePerl.\n\n    $Preamble\n        The explanatory text written to newly generated SIGNATURE files\n        before the actual entries.\n\nENVIRONMENT\n    Module::Signature honors these environment variables:\n\n    MODULE_SIGNATURE_CIPHER\n        Works like $Cipher.\n\n    MODULE_SIGNATURE_VERBOSE\n        Works like $Verbose.\n\n    MODULE_SIGNATURE_KEYSERVER\n        Works like $KeyServer.\n\n    MODULE_SIGNATURE_KEYSERVERPORT\n        Works like $KeyServerPort.\n\n    MODULE_SIGNATURE_TIMEOUT\n        Works like $Timeout.\n\nCONSTANTS\n    These constants are not exported by default.\n\n    CANNOT_VERIFY (0E0)\n        Cannot verify the OpenPGP signature, maybe due to the lack of a\n        network connection to the key server, or if neither gnupg nor\n        Crypt::OpenPGP exists on the system.\n\n    SIGNATURE_OK (0)\n        Signature successfully verified.\n\n    SIGNATURE_MISSING (-1)\n        The SIGNATURE file does not exist.\n\n    SIGNATURE_MALFORMED (-2)\n        The signature file does not contains a valid OpenPGP message.\n\n    SIGNATURE_BAD (-3)\n        Invalid signature detected -- it might have been tampered with.\n\n    SIGNATURE_MISMATCH (-4)\n        The signature is valid, but files in the distribution have changed\n        since its creation.\n\n    MANIFEST_MISMATCH (-5)\n        There are extra files in the current directory not specified by the\n        MANIFEST file.\n\n    CIPHER_UNKNOWN (-6)\n        The cipher used by the signature file is not recognized by the\n        \"Digest\" and \"Digest::*\" modules.\n\nNOTES\n  Signing your module as part of \"make dist\"\n    The easiest way is to use Module::Install:\n\n        sign;       # put this before \"WriteAll\"\n        WriteAll;\n\n    For ExtUtils::MakeMaker (version 6.18 or above), you may do this:\n\n        WriteMakefile(\n            (MM->can('signature_target') ? (SIGN => 1) : ()),\n            # ... original arguments ...\n        );\n\n    Users of Module::Build may do this:\n\n        Module::Build->new(\n            (sign => 1),\n            # ... original arguments ...\n        )->create_build_script;\n\n  MANIFEST.SKIP Considerations\n    (The following section is lifted from Iain Truskett's Test::Signature\n    module, under the Perl license. Thanks, Iain!)\n\n    It is imperative that your MANIFEST and MANIFEST.SKIP files be accurate\n    and complete. If you are using \"ExtUtils::MakeMaker\" and you do not have\n    a MANIFEST.SKIP file, then don't worry about the rest of this. If you do\n    have a MANIFEST.SKIP file, or you use \"Module::Build\", you must read\n    this.\n\n    Since the test is run at \"make test\" time, the distribution has been\n    made. Thus your MANIFEST.SKIP file should have the entries listed below.\n\n    If you're using \"ExtUtils::MakeMaker\", you should have, at least:\n\n        #defaults\n        ^Makefile$\n        ^blib/\n        ^pm_to_blib\n        ^blibdirs\n\n    These entries are part of the default set provided by\n    \"ExtUtils::Manifest\", which is ignored if you provide your own\n    MANIFEST.SKIP file.\n\n    If you are using \"Module::Build\", you should have two extra entries:\n\n        ^Build$\n        ^_build/\n\n    If you don't have the correct entries, \"Module::Signature\" will complain\n    that you have:\n\n        ==> MISMATCHED content between MANIFEST and distribution files! <==\n\n    You should note this during normal development testing anyway.\n\n  Testing signatures\n    You may add this code as t/0-signature.t in your distribution tree:\n\n        #!/usr/bin/perl\n\n        use strict;\n        print \"1..1\\n\";\n\n        if (!$ENV{TEST_SIGNATURE}) {\n            print \"ok 1 # skip Set the environment variable\",\n                        \" TEST_SIGNATURE to enable this test\\n\";\n        }\n        elsif (!-s 'SIGNATURE') {\n            print \"ok 1 # skip No signature file found\\n\";\n        }\n        elsif (!eval { require Module::Signature; 1 }) {\n            print \"ok 1 # skip \",\n                    \"Next time around, consider install Module::Signature, \",\n                    \"so you can verify the integrity of this distribution.\\n\";\n        }\n        elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n            print \"ok 1 # skip \",\n                    \"Cannot connect to the keyserver\\n\";\n        }\n        else {\n            (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n                or print \"not \";\n            print \"ok 1 # Valid signature\\n\";\n        }\n\n        __END__\n\n    If you are already using Test::More for testing, a more straightforward\n    version of t/0-signature.t can be found in the Module::Signature\n    distribution.\n\n    Also, if you prefer a more full-fledged testing package, and are willing\n    to inflict the dependency of Module::Build on your users, Iain\n    Truskett's Test::Signature might be a better choice.\n\nSEE ALSO\n    Digest, Digest::SHA, Digest::SHA1, Digest::SHA::PurePerl\n\n    ExtUtils::Manifest, Crypt::OpenPGP, Test::Signature\n\n    Module::Install, ExtUtils::MakeMaker, Module::Build\n\n    Dist::Zilla::Plugin::Signature\n\nAUTHORS\n    Audrey Tang <cpan@audreyt.org>\n\nCC0 1.0 Universal\n    To the extent possible under law, \u5510\u9cf3 has waived all copyright and\n    related or neighboring rights to Module-Signature.\n\n    This work is published from Taiwan.\n\n    <http://creativecommons.org/publicdomain/zero/1.0>\n\n", "package Module::Signature;\n$Module::Signature::VERSION = '0.74';\n\nuse 5.005;\nuse strict;\nuse vars qw($VERSION $SIGNATURE @ISA @EXPORT_OK);\nuse vars qw($Preamble $Cipher $Debug $Verbose $Timeout $AUTHOR);\nuse vars qw($KeyServer $KeyServerPort $AutoKeyRetrieve $CanKeyRetrieve);\n\nuse constant CANNOT_VERIFY       => '0E0';\nuse constant SIGNATURE_OK        => 0;\nuse constant SIGNATURE_MISSING   => -1;\nuse constant SIGNATURE_MALFORMED => -2;\nuse constant SIGNATURE_BAD       => -3;\nuse constant SIGNATURE_MISMATCH  => -4;\nuse constant MANIFEST_MISMATCH   => -5;\nuse constant CIPHER_UNKNOWN      => -6;\n\nuse ExtUtils::Manifest ();\nuse Exporter;\nuse File::Spec;\n\n@EXPORT_OK      = (\n    qw(sign verify),\n    qw($SIGNATURE $KeyServer $Cipher $Preamble),\n    (grep { /^[A-Z_]+_[A-Z_]+$/ } keys %Module::Signature::),\n);\n@ISA            = 'Exporter';\n\n$AUTHOR         = $ENV{MODULE_SIGNATURE_AUTHOR};\n$SIGNATURE      = 'SIGNATURE';\n$Timeout        = $ENV{MODULE_SIGNATURE_TIMEOUT} || 3;\n$Verbose        = $ENV{MODULE_SIGNATURE_VERBOSE} || 0;\n$KeyServer      = $ENV{MODULE_SIGNATURE_KEYSERVER} || 'pool.sks-keyservers.net';\n$KeyServerPort  = $ENV{MODULE_SIGNATURE_KEYSERVERPORT} || '11371';\n$Cipher         = $ENV{MODULE_SIGNATURE_CIPHER} || 'SHA1';\n$Preamble       = << \".\";\nThis file contains message digests of all files listed in MANIFEST,\nsigned via the Module::Signature module, version $VERSION.\n\nTo verify the content in this distribution, first make sure you have\nModule::Signature installed, then type:\n\n    % cpansign -v\n\nIt will check each file's integrity, as well as the signature's\nvalidity.  If \"==> Signature verified OK! <==\" is not displayed,\nthe distribution may already have been compromised, and you should\nnot run its Makefile.PL or Build.PL.\n\n.\n\n$AutoKeyRetrieve    = 1;\n$CanKeyRetrieve     = undef;\n\nsub _cipher_map {\n    my($sigtext) = @_;\n    my @lines = split /\\015?\\012/, $sigtext;\n    my %map;\n    for my $line (@lines) {\n        last if $line eq '-----BEGIN PGP SIGNATURE-----';\n        next if $line =~ /^---/ .. $line eq '';\n        my($cipher,$digest,$file) = split \" \", $line, 3;\n        return unless defined $file;\n        $map{$file} = [$cipher, $digest];\n    }\n    return \\%map;\n}\n\nsub verify {\n    my %args = ( @_ );\n    my $rv;\n\n    (-r $SIGNATURE) or do {\n        warn \"==> MISSING Signature file! <==\\n\";\n        return SIGNATURE_MISSING;\n    };\n\n    (my $sigtext = _read_sigfile($SIGNATURE)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (my ($cipher_map) = _cipher_map($sigtext)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (defined(my $plaintext = _mkdigest($cipher_map))) or do {\n        warn \"==> UNKNOWN Cipher format! <==\\n\";\n        return CIPHER_UNKNOWN;\n    };\n\n    $rv = _verify($SIGNATURE, $sigtext, $plaintext);\n\n    if ($rv == SIGNATURE_OK) {\n        my ($mani, $file) = _fullcheck($args{skip});\n\n        if (@{$mani} or @{$file}) {\n            warn \"==> MISMATCHED content between MANIFEST and distribution files! <==\\n\";\n            return MANIFEST_MISMATCH;\n        }\n        else {\n            warn \"==> Signature verified OK! <==\\n\" if $Verbose;\n        }\n    }\n    elsif ($rv == SIGNATURE_BAD) {\n        warn \"==> BAD/TAMPERED signature detected! <==\\n\";\n    }\n    elsif ($rv == SIGNATURE_MISMATCH) {\n        warn \"==> MISMATCHED content between SIGNATURE and distribution files! <==\\n\";\n    }\n\n    return $rv;\n}\n\nsub _verify {\n    my $signature = shift || $SIGNATURE;\n    my $sigtext   = shift || '';\n    my $plaintext = shift || '';\n\n    local $SIGNATURE = $signature if $signature ne $SIGNATURE;\n\n    if ($AutoKeyRetrieve and !$CanKeyRetrieve) {\n        if (!defined $CanKeyRetrieve) {\n            require IO::Socket::INET;\n            my $sock = IO::Socket::INET->new(\n                Timeout => $Timeout,\n                PeerAddr => \"$KeyServer:$KeyServerPort\",\n            );\n            $CanKeyRetrieve = ($sock ? 1 : 0);\n            $sock->shutdown(2) if $sock;\n        }\n        $AutoKeyRetrieve = $CanKeyRetrieve;\n    }\n\n    if (my $version = _has_gpg()) {\n        return _verify_gpg($sigtext, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        return _verify_crypt_openpgp($sigtext, $plaintext);\n    }\n    else {\n        warn \"Cannot use GnuPG or Crypt::OpenPGP, please install either one first!\\n\";\n        return _compare($sigtext, $plaintext, CANNOT_VERIFY);\n    }\n}\n\nsub _has_gpg {\n    my $gpg = _which_gpg() or return;\n    `$gpg --version` =~ /GnuPG.*?(\\S+)\\s*$/m or return;\n    return $1;\n}\n\nsub _fullcheck {\n    my $skip = shift;\n    my @extra;\n\n    local $^W;\n    local $ExtUtils::Manifest::Quiet = 1;\n\n    my($mani, $file);\n    if( _legacy_extutils() ) {\n        my $_maniskip;\n        if ( _public_maniskip() ) {\n            $_maniskip = &ExtUtils::Manifest::maniskip;\n        } else {\n            $_maniskip = &ExtUtils::Manifest::_maniskip;\n        }\n\n        local *ExtUtils::Manifest::_maniskip = sub { sub {\n            return unless $skip;\n            my $ok = $_maniskip->(@_);\n            if ($ok ||= (!-e 'MANIFEST.SKIP' and _default_skip(@_))) {\n                print \"Skipping $_\\n\" for @_;\n                push @extra, @_;\n            }\n            return $ok;\n        } };\n\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n    else {\n        my $_maniskip = &ExtUtils::Manifest::maniskip;\n        local *ExtUtils::Manifest::maniskip = sub { sub {\n            return unless $skip;\n            return $_maniskip->(@_);\n        } };\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n\n    foreach my $makefile ('Makefile', 'Build') {\n        warn \"==> SKIPPED CHECKING '$_'!\" .\n                (-e \"$_.PL\" && \" (run $_.PL to ensure its integrity)\") .\n                \" <===\\n\" for grep $_ eq $makefile, @extra;\n    }\n\n    @{$mani} = grep {$_ ne 'SIGNATURE'} @{$mani};\n\n    warn \"Not in MANIFEST: $_\\n\" for @{$file};\n    warn \"No such file: $_\\n\" for @{$mani};\n\n    return ($mani, $file);\n}\n\nsub _legacy_extutils {\n    # ExtUtils::Manifest older than 1.58 does not handle MYMETA.\n    return (ExtUtils::Manifest->VERSION < 1.58);\n}\n\nsub _public_maniskip {\n    # ExtUtils::Manifest 1.54 onwards have public maniskip\n    return (ExtUtils::Manifest->VERSION > 1.53);\n}\n\nsub _default_skip {\n    local $_ = shift;\n    return 1 if /\\bRCS\\b/ or /\\bCVS\\b/ or /\\B\\.svn\\b/ or /,v$/\n             or /^MANIFEST\\.bak/ or /^Makefile$/ or /^blib\\//\n             or /^MakeMaker-\\d/ or /^pm_to_blib/ or /^blibdirs/\n             or /^_build\\// or /^Build$/ or /^pmfiles\\.dat/\n             or /^MYMETA\\./\n             or /~$/ or /\\.old$/ or /\\#$/ or /^\\.#/;\n}\n\nmy $which_gpg;\nsub _which_gpg {\n    # Cache it so we don't need to keep checking.\n    return $which_gpg if $which_gpg;\n\n    for my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n        my $version = `$gpg_bin --version 2>&1`;\n        if( $version && $version =~ /GnuPG/ ) {\n            $which_gpg = $gpg_bin;\n            return $which_gpg;\n        }\n    }\n}\n\nsub _verify_gpg {\n    my ($sigtext, $plaintext, $version) = @_;\n\n    local $SIGNATURE = Win32::GetShortPathName($SIGNATURE)\n        if defined &Win32::GetShortPathName and $SIGNATURE =~ /[^-\\w.:~\\\\\\/]/;\n\n    my $keyserver = _keyserver($version);\n\n    require File::Temp;\n    my $fh = File::Temp->new();\n    print $fh $sigtext;\n    close $fh;\n\n    my $gpg = _which_gpg();\n    my @quiet = $Verbose ? () : qw(-q --logger-fd=1);\n    my @cmd = (\n        $gpg, qw(--verify --batch --no-tty), @quiet, ($KeyServer ? (\n            \"--keyserver=$keyserver\",\n            ($AutoKeyRetrieve and $version ge '1.0.7')\n                ? '--keyserver-options=auto-key-retrieve'\n                : ()\n        ) : ()), $fh->filename\n    );\n\n    my $output = '';\n    if( $Verbose ) {\n        warn \"Executing @cmd\\n\";\n        system @cmd;\n    }\n    else {\n        my $cmd = join ' ', @cmd;\n        $output = `$cmd`;\n    }\n    unlink $fh->filename;\n\n    if( $? ) {\n        print STDERR $output;\n    }\n    elsif ($output =~ /((?: +[\\dA-F]{4}){10,})/) {\n        warn \"WARNING: This key is not certified with a trusted signature!\\n\";\n        warn \"Primary key fingerprint:$1\\n\";\n    }\n\n    return SIGNATURE_BAD if ($? and $AutoKeyRetrieve);\n    return _compare($sigtext, $plaintext, (!$?) ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _keyserver {\n    my $version = shift;\n    my $scheme = 'x-hkp';\n    $scheme = 'hkp' if $version ge '1.2.0';\n\n    return \"$scheme://$KeyServer:$KeyServerPort\";\n}\n\nsub _verify_crypt_openpgp {\n    my ($sigtext, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new(\n        ($KeyServer) ? ( KeyServer => $KeyServer, AutoKeyRetrieve => $AutoKeyRetrieve ) : (),\n    );\n    my $rv = $pgp->handle( Data => $sigtext )\n        or die $pgp->errstr;\n\n    return SIGNATURE_BAD if (!$rv->{Validity} and $AutoKeyRetrieve);\n\n    if ($rv->{Validity}) {\n        warn 'Signature made ', scalar localtime($rv->{Signature}->timestamp),\n             ' using key ID ', substr(uc(unpack('H*', $rv->{Signature}->key_id)), -8), \"\\n\",\n             \"Good signature from \\\"$rv->{Validity}\\\"\\n\" if $Verbose;\n    }\n    else {\n        warn \"Cannot verify signature; public key not found\\n\";\n    }\n\n    return _compare($sigtext, $plaintext, $rv->{Validity} ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _read_sigfile {\n    my $sigfile = shift;\n    my $signature = '';\n    my $well_formed;\n\n    local *D;\n    open D, \"< $sigfile\" or die \"Could not open $sigfile: $!\";\n\n    if ($] >= 5.006 and <D> =~ /\\r/) {\n        close D;\n        open D, '<', $sigfile or die \"Could not open $sigfile: $!\";\n        binmode D, ':crlf';\n    } else {\n        close D;\n        open D, \"< $sigfile\" or die \"Could not open $sigfile: $!\";\n    }\n\n    my $begin = \"-----BEGIN PGP SIGNED MESSAGE-----\\n\";\n    my $end = \"-----END PGP SIGNATURE-----\\n\";\n    while (<D>) {\n        next if (1 .. ($_ eq $begin));\n        $signature .= $_;\n        return \"$begin$signature\" if $_ eq $end;\n    }\n\n    return;\n}\n\nsub _compare {\n    my ($str1, $str2, $ok) = @_;\n\n    # normalize all linebreaks\n    $str1 =~ s/^-----BEGIN PGP SIGNED MESSAGE-----\\n(?:.+\\n)*\\n//;\n    $str1 =~ s/[^\\S ]+/\\n/g; $str2 =~ s/[^\\S ]+/\\n/g;\n    $str1 =~ s/-----BEGIN PGP SIGNATURE-----\\n(?:.+\\n)*$//;\n\n    return $ok if $str1 eq $str2;\n\n    if (eval { require Text::Diff; 1 }) {\n        warn \"--- $SIGNATURE \".localtime((stat($SIGNATURE))[9]).\"\\n\";\n        warn '+++ (current) '.localtime().\"\\n\";\n        warn Text::Diff::diff( \\$str1, \\$str2, { STYLE => 'Unified' } );\n    }\n    else {\n        local (*D, *S);\n        open S, \"< $SIGNATURE\" or die \"Could not open $SIGNATURE: $!\";\n        open D, \"| diff -u $SIGNATURE -\" or (warn \"Could not call diff: $!\", return SIGNATURE_MISMATCH);\n        while (<S>) {\n            print D $_ if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n            print D if (/^Hash: / .. /^$/);\n            next if (1 .. /^-----BEGIN PGP SIGNATURE/);\n            print D $str2, \"-----BEGIN PGP SIGNATURE-----\\n\", $_ and last;\n        }\n        print D <S>;\n        close D;\n    }\n\n    return SIGNATURE_MISMATCH;\n}\n\nsub sign {\n    my %args = ( skip => 1, @_ );\n    my $overwrite = $args{overwrite};\n    my $plaintext = _mkdigest();\n\n    my ($mani, $file) = _fullcheck($args{skip});\n\n    if (@{$mani} or @{$file}) {\n        warn \"==> MISMATCHED content between MANIFEST and the distribution! <==\\n\";\n        warn \"==> Please correct your MANIFEST file and/or delete extra files. <==\\n\";\n    }\n\n    if (!$overwrite and -e $SIGNATURE and -t STDIN) {\n        local $/ = \"\\n\";\n        print \"$SIGNATURE already exists; overwrite [y/N]? \";\n        return unless <STDIN> =~ /[Yy]/;\n    }\n\n    if (my $version = _has_gpg()) {\n        _sign_gpg($SIGNATURE, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        _sign_crypt_openpgp($SIGNATURE, $plaintext);\n    }\n    else {\n        die 'Cannot use GnuPG or Crypt::OpenPGP, please install either one first!';\n    }\n\n    warn \"==> SIGNATURE file created successfully. <==\\n\";\n    return SIGNATURE_OK;\n}\n\nsub _sign_gpg {\n    my ($sigfile, $plaintext, $version) = @_;\n\n    die \"Could not write to $sigfile\"\n        if -e $sigfile and (-d $sigfile or not -w $sigfile);\n\n    my $gpg = _which_gpg();\n\n    local *D;\n    my $set_key = '';\n    $set_key = \"--default-key $AUTHOR\" if($AUTHOR);\n    open D, \"| $gpg $set_key --clearsign >> $sigfile.tmp\" or die \"Could not call $gpg: $!\";\n    print D $plaintext;\n    close D;\n\n    (-e \"$sigfile.tmp\" and -s \"$sigfile.tmp\") or do {\n        unlink \"$sigfile.tmp\";\n        die \"Cannot find $sigfile.tmp, signing aborted.\\n\";\n    };\n\n    open D, \"< $sigfile.tmp\" or die \"Cannot open $sigfile.tmp: $!\";\n\n    open S, \"> $sigfile\" or do {\n        unlink \"$sigfile.tmp\";\n        die \"Could not write to $sigfile: $!\";\n    };\n\n    print S $Preamble;\n    print S <D>;\n\n    close S;\n    close D;\n\n    unlink(\"$sigfile.tmp\");\n\n    my $key_id;\n    my $key_name;\n    # This doesn't work because the output from verify goes to STDERR.\n    # If I try to redirect it using \"--logger-fd 1\" it just hangs.\n    # WTF?\n    my @verify = `$gpg --batch --verify $SIGNATURE`;\n    while (@verify) {\n        if (/key ID ([0-9A-F]+)$/) {\n            $key_id = $1;\n        } elsif (/signature from \"(.+)\"$/) {\n            $key_name = $1;\n        }\n    }\n\n    my $found_name;\n    my $found_key;\n    if (defined $key_id && defined $key_name) {\n        my $keyserver = _keyserver($version);\n        while (`$gpg --batch --keyserver=$keyserver --search-keys '$key_name'`) {\n            if (/^\\(\\d+\\)/) {\n                $found_name = 0;\n            } elsif ($found_name) {\n                if (/key \\Q$key_id\\E/) {\n                    $found_key = 1;\n                    last;\n                }\n            }\n\n            if (/\\Q$key_name\\E/) {\n                $found_name = 1;\n                next;\n            }\n        }\n\n        unless ($found_key) {\n            _warn_non_public_signature($key_name);\n        }\n    }\n\n    return 1;\n}\n\nsub _sign_crypt_openpgp {\n    my ($sigfile, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new;\n    my $ring = Crypt::OpenPGP::KeyRing->new(\n        Filename => $pgp->{cfg}->get('SecRing')\n    ) or die $pgp->error(Crypt::OpenPGP::KeyRing->errstr);\n    my $kb = $ring->find_keyblock_by_index(-1)\n        or die $pgp->error('Can\\'t find last keyblock: ' . $ring->errstr);\n\n    my $cert = $kb->signing_key;\n    my $uid = $cert->uid($kb->primary_uid);\n    warn \"Debug: acquiring signature from $uid\\n\" if $Debug;\n\n    my $signature = $pgp->sign(\n        Data       => $plaintext,\n        Detach     => 0,\n        Clearsign  => 1,\n        Armour     => 1,\n        Key        => $cert,\n        PassphraseCallback => \\&Crypt::OpenPGP::_default_passphrase_cb,\n    ) or die $pgp->errstr;\n\n\n    local *D;\n    open D, \"> $sigfile\" or die \"Could not write to $sigfile: $!\";\n    print D $Preamble;\n    print D $signature;\n    close D;\n\n    require Crypt::OpenPGP::KeyServer;\n    my $server = Crypt::OpenPGP::KeyServer->new(Server => $KeyServer);\n\n    unless ($server->find_keyblock_by_keyid($cert->key_id)) {\n        _warn_non_public_signature($uid);\n    }\n\n    return 1;\n}\n\nsub _warn_non_public_signature {\n    my $uid = shift;\n\n    warn <<\"EOF\"\nYou have signed this distribution with a key ($uid) that cannot be\nfound on the public key server at $KeyServer.\n\nThis will probably cause signature verification to fail if your module\nis distributed on CPAN.\nEOF\n}\n\nsub _mkdigest {\n    my $digest = _mkdigest_files(@_) or return;\n    my $plaintext = '';\n\n    foreach my $file (sort keys %$digest) {\n        next if $file eq $SIGNATURE;\n        $plaintext .= \"@{$digest->{$file}} $file\\n\";\n    }\n\n    return $plaintext;\n}\n\nsub _digest_object {\n    my($algorithm) = @_;\n\n    # Avoid loading Digest::* from relative paths in @INC.\n    local @INC = grep { File::Spec->file_name_is_absolute($_) } @INC;\n\n    # Constrain algorithm name to be of form ABC123.\n    my ($base, $variant) = ($algorithm =~ /^([_a-zA-Z]+)([0-9]+)$/g)\n        or die \"Malformed algorithm name: $algorithm (should match /\\\\w+\\\\d+/)\";\n\n    my $obj = eval { Digest->new($algorithm) } || eval {\n        require \"Digest/$base.pm\"; \"Digest::$base\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm.pm\"; \"Digest::$algorithm\"->new\n    } || eval {\n        require \"Digest/$base/PurePerl.pm\"; \"Digest::$base\\::PurePerl\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm/PurePerl.pm\"; \"Digest::$algorithm\\::PurePerl\"->new\n    } or do { eval {\n        warn \"Unknown cipher: $algorithm, please install Digest::$base, Digest::$base$variant, or Digest::$base\\::PurePerl\\n\";\n    } and return } or do {\n        warn \"Unknown cipher: $algorithm, please install Digest::$algorithm\\n\"; return;\n    };\n    $obj;\n}\n\nsub _mkdigest_files {\n    my $verify_map = shift;\n    my $dosnames = (defined(&Dos::UseLFN) && Dos::UseLFN()==0);\n    my $read = ExtUtils::Manifest::maniread() || {};\n    my $found = ExtUtils::Manifest::manifind();\n    my(%digest) = ();\n    my($default_obj) = _digest_object($Cipher);\n FILE: foreach my $file (sort keys %$read){\n        next FILE if $file eq $SIGNATURE;\n        my($obj,$this_cipher,$this_hexdigest,$verify_digest);\n        if ($verify_map) {\n            if (my $vmf = $verify_map->{$file}) {\n                ($this_cipher,$verify_digest) = @$vmf;\n                if ($this_cipher eq $Cipher) {\n                    $obj = $default_obj;\n                } else {\n                    $obj = _digest_object($this_cipher);\n                }\n            } else {\n                $this_cipher = $Cipher;\n                $obj = $default_obj;\n            }\n        } else {\n            $this_cipher = $Cipher;\n            $obj = $default_obj;\n        }\n        warn \"Debug: collecting digest from $file\\n\" if $Debug;\n        if ($dosnames){\n            $file = lc $file;\n            $file =~ s!(\\.(\\w|-)+)!substr ($1,0,4)!ge;\n            $file =~ s!((\\w|-)+)!substr ($1,0,8)!ge;\n        }\n        unless ( exists $found->{$file} ) {\n            warn \"No such file: $file\\n\" if $Verbose;\n        }\n        else {\n            local *F;\n            open F, \"< $file\" or die \"Cannot open $file for reading: $!\";\n            if (-B $file) {\n                binmode(F);\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            elsif ($^O eq 'MSWin32') {\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            else {\n                # Normalize by hand...\n                local $/;\n                binmode(F);\n                my $input = <F>;\n            VERIFYLOOP: for my $eol (\"\",\"\\015\\012\",\"\\012\") {\n                    my $lax_input = $input;\n                    if (! length $eol) {\n                        # first try is binary\n                    } else {\n                        my @lines = split /$eol/, $input, -1;\n                        if (grep /[\\015\\012]/, @lines) {\n                            # oops, apparently not a text file, treat as binary, forget @lines\n                        } else {\n                            my $other_eol = $eol eq \"\\012\" ? \"\\015\\012\" : \"\\012\";\n                            $lax_input = join $other_eol, @lines;\n                        }\n                    }\n                    $obj->add($lax_input);\n                    $this_hexdigest = $obj->hexdigest;\n                    if ($verify_digest) {\n                        if ($this_hexdigest eq $verify_digest) {\n                            last VERIFYLOOP;\n                        }\n                        $obj->reset;\n                    } else {\n                        last VERIFYLOOP;\n                    }\n                }\n            }\n            $digest{$file} = [$this_cipher, $this_hexdigest];\n            $obj->reset;\n        }\n    }\n\n    return \\%digest;\n}\n\n1;\n\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nModule::Signature - Module signature file manipulation\n\n=head1 SYNOPSIS\n\nAs a shell command:\n\n    % cpansign              # verify an existing SIGNATURE, or\n                            # make a new one if none exists\n\n    % cpansign sign         # make signature; overwrites existing one\n    % cpansign -s           # same thing\n\n    % cpansign verify       # verify a signature\n    % cpansign -v           # same thing\n    % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n    % cpansign help         # display this documentation\n    % cpansign -h           # same thing\n\nIn programs:\n\n    use Module::Signature qw(sign verify SIGNATURE_OK);\n    sign();\n    sign(overwrite => 1);       # overwrites without asking\n\n    # see the CONSTANTS section below\n    (verify() == SIGNATURE_OK) or die \"failed!\";\n\n=head1 DESCRIPTION\n\nB<Module::Signature> adds cryptographic authentications to CPAN\ndistributions, via the special F<SIGNATURE> file.\n\nIf you are a module user, all you have to do is to remember to run\nC<cpansign -v> (or just C<cpansign>) before issuing C<perl Makefile.PL>\nor C<perl Build.PL>; that will ensure the distribution has not been\ntampered with.\n\nModule authors can easily add the F<SIGNATURE> file to the distribution\ntarball; see L</NOTES> below for how to do it as part of C<make dist>.\n\nIf you I<really> want to sign a distribution manually, simply add\nC<SIGNATURE> to F<MANIFEST>, then type C<cpansign -s> immediately\nbefore C<make dist>.  Be sure to delete the F<SIGNATURE> file afterwards.\n\nPlease also see L</NOTES> about F<MANIFEST.SKIP> issues, especially if\nyou are using B<Module::Build> or writing your own F<MANIFEST.SKIP>.\n\n=head1 VARIABLES\n\nNo package variables are exported by default.\n\n=over 4\n\n=item $Verbose\n\nIf true, Module::Signature will give information during processing including\ngpg output.  If false, Module::Signature will be as quiet as possible as\nlong as everything is working ok.  Defaults to false.\n\n=item $SIGNATURE\n\nThe filename for a distribution's signature file.  Defaults to\nC<SIGNATURE>.\n\n=item $KeyServer\n\nThe OpenPGP key server for fetching the author's public key\n(currently only implemented on C<gpg>, not C<Crypt::OpenPGP>).\nMay be set to a false value to prevent this module from\nfetching public keys.\n\n=item $KeyServerPort\n\nThe OpenPGP key server port, defaults to C<11371>.\n\n=item $Timeout\n\nMaximum time to wait to try to establish a link to the key server.\nDefaults to C<3>.\n\n=item $AutoKeyRetrieve\n\nWhether to automatically fetch unknown keys from the key server.\nDefaults to C<1>.\n\n=item $Cipher\n\nThe default cipher used by the C<Digest> module to make signature\nfiles.  Defaults to C<SHA1>, but may be changed to other ciphers\nvia the C<MODULE_SIGNATURE_CIPHER> environment variable if the SHA1\ncipher is undesirable for the user.\n\nThe cipher specified in the F<SIGNATURE> file's first entry will\nbe used to validate its integrity.  For C<SHA1>, the user needs\nto have any one of these four modules installed: B<Digest::SHA>,\nB<Digest::SHA1>, B<Digest::SHA::PurePerl>, or (currently nonexistent)\nB<Digest::SHA1::PurePerl>.\n\n=item $Preamble\n\nThe explanatory text written to newly generated F<SIGNATURE> files\nbefore the actual entries.\n\n=back\n\n=head1 ENVIRONMENT\n\nB<Module::Signature> honors these environment variables:\n\n=over 4\n\n=item MODULE_SIGNATURE_CIPHER\n\nWorks like C<$Cipher>.\n\n=item MODULE_SIGNATURE_VERBOSE\n\nWorks like C<$Verbose>.\n\n=item MODULE_SIGNATURE_KEYSERVER\n\nWorks like C<$KeyServer>.\n\n=item MODULE_SIGNATURE_KEYSERVERPORT\n\nWorks like C<$KeyServerPort>.\n\n=item MODULE_SIGNATURE_TIMEOUT\n\nWorks like C<$Timeout>.\n\n=back\n\n=head1 CONSTANTS\n\nThese constants are not exported by default.\n\n=over 4\n\n=item CANNOT_VERIFY (C<0E0>)\n\nCannot verify the OpenPGP signature, maybe due to the lack of a network\nconnection to the key server, or if neither gnupg nor Crypt::OpenPGP\nexists on the system.\n\n=item SIGNATURE_OK (C<0>)\n\nSignature successfully verified.\n\n=item SIGNATURE_MISSING (C<-1>)\n\nThe F<SIGNATURE> file does not exist.\n\n=item SIGNATURE_MALFORMED (C<-2>)\n\nThe signature file does not contains a valid OpenPGP message.\n\n=item SIGNATURE_BAD (C<-3>)\n\nInvalid signature detected -- it might have been tampered with.\n\n=item SIGNATURE_MISMATCH (C<-4>)\n\nThe signature is valid, but files in the distribution have changed\nsince its creation.\n\n=item MANIFEST_MISMATCH (C<-5>)\n\nThere are extra files in the current directory not specified by\nthe MANIFEST file.\n\n=item CIPHER_UNKNOWN (C<-6>)\n\nThe cipher used by the signature file is not recognized by the\nC<Digest> and C<Digest::*> modules.\n\n=back\n\n=head1 NOTES\n\n=head2 Signing your module as part of C<make dist>\n\nThe easiest way is to use B<Module::Install>:\n\n    sign;       # put this before \"WriteAll\"\n    WriteAll;\n\nFor B<ExtUtils::MakeMaker> (version 6.18 or above), you may do this:\n\n    WriteMakefile(\n        (MM->can('signature_target') ? (SIGN => 1) : ()),\n        # ... original arguments ...\n    );\n\nUsers of B<Module::Build> may do this:\n\n    Module::Build->new(\n        (sign => 1),\n        # ... original arguments ...\n    )->create_build_script;\n\n=head2 F<MANIFEST.SKIP> Considerations\n\n(The following section is lifted from Iain Truskett's B<Test::Signature>\nmodule, under the Perl license.  Thanks, Iain!)\n\nIt is B<imperative> that your F<MANIFEST> and F<MANIFEST.SKIP> files be\naccurate and complete. If you are using C<ExtUtils::MakeMaker> and you\ndo not have a F<MANIFEST.SKIP> file, then don't worry about the rest of\nthis. If you do have a F<MANIFEST.SKIP> file, or you use\nC<Module::Build>, you must read this.\n\nSince the test is run at C<make test> time, the distribution has been\nmade. Thus your F<MANIFEST.SKIP> file should have the entries listed\nbelow.\n\nIf you're using C<ExtUtils::MakeMaker>, you should have, at least:\n\n    #defaults\n    ^Makefile$\n    ^blib/\n    ^pm_to_blib\n    ^blibdirs\n\nThese entries are part of the default set provided by\nC<ExtUtils::Manifest>, which is ignored if you provide your own\nF<MANIFEST.SKIP> file.\n\nIf you are using C<Module::Build>, you should have two extra entries:\n\n    ^Build$\n    ^_build/\n\nIf you don't have the correct entries, C<Module::Signature> will\ncomplain that you have:\n\n    ==> MISMATCHED content between MANIFEST and distribution files! <==\n\nYou should note this during normal development testing anyway.\n\n=head2 Testing signatures\n\nYou may add this code as F<t/0-signature.t> in your distribution tree:\n\n    #!/usr/bin/perl\n\n    use strict;\n    print \"1..1\\n\";\n\n    if (!$ENV{TEST_SIGNATURE}) {\n        print \"ok 1 # skip Set the environment variable\",\n                    \" TEST_SIGNATURE to enable this test\\n\";\n    }\n    elsif (!-s 'SIGNATURE') {\n        print \"ok 1 # skip No signature file found\\n\";\n    }\n    elsif (!eval { require Module::Signature; 1 }) {\n        print \"ok 1 # skip \",\n                \"Next time around, consider install Module::Signature, \",\n                \"so you can verify the integrity of this distribution.\\n\";\n    }\n    elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n        print \"ok 1 # skip \",\n                \"Cannot connect to the keyserver\\n\";\n    }\n    else {\n        (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n            or print \"not \";\n        print \"ok 1 # Valid signature\\n\";\n    }\n\n    __END__\n\nIf you are already using B<Test::More> for testing, a more\nstraightforward version of F<t/0-signature.t> can be found in the\nB<Module::Signature> distribution.\n\nAlso, if you prefer a more full-fledged testing package, and are\nwilling to inflict the dependency of B<Module::Build> on your users,\nIain Truskett's B<Test::Signature> might be a better choice.\n\n=cut\n\n=head1 SEE ALSO\n\nL<Digest>, L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA::PurePerl>\n\nL<ExtUtils::Manifest>, L<Crypt::OpenPGP>, L<Test::Signature>\n\nL<Module::Install>, L<ExtUtils::MakeMaker>, L<Module::Build>\n\nL<Dist::Zilla::Plugin::Signature>\n\n=head1 AUTHORS\n\nAudrey Tang E<lt>cpan@audreyt.orgE<gt>\n\n=head1 CC0 1.0 Universal\n\nTo the extent possible under law, \u5510\u9cf3 has waived all copyright and related\nor neighboring rights to Module-Signature.\n\nThis work is published from Taiwan.\n\nL<http://creativecommons.org/publicdomain/zero/1.0>\n\n=cut\n"], "filenames": ["Makefile.PL", "README", "lib/Module/Signature.pm"], "buggy_code_start_loc": [12, 251, 2], "buggy_code_end_loc": [12, 252, 953], "fixing_code_start_loc": [13, 251, 2], "fixing_code_end_loc": [14, 252, 969], "type": "CWE-681", "message": "The PGP signature parsing in Module::Signature before 0.74 allows remote attackers to cause the unsigned portion of a SIGNATURE file to be treated as the signed portion via unspecified vectors.", "other": {"cve": {"id": "CVE-2015-3406", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-29T21:15:10.980", "lastModified": "2019-12-16T19:48:00.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The PGP signature parsing in Module::Signature before 0.74 allows remote attackers to cause the unsigned portion of a SIGNATURE file to be treated as the signed portion via unspecified vectors."}, {"lang": "es", "value": "El an\u00e1lisis de la firma PGP en Module::Signature versiones anteriores a 0.74, permite a atacantes remotos causar que la parte sin firmar de un archivo SIGNATURE sea tratada como la parte firmada mediante vectores no especificados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-681"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:module-signature_project:module-signature:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.74", "matchCriteriaId": "B259156C-4857-4DAE-A2CF-9C5F34A709AE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}]}]}], "references": [{"url": "http://ubuntu.com/usn/usn-2607-1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/04/07/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/04/23/17", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/audreyt/module-signature/commit/8a9164596fa5952d4fbcde5aa1c7d1c7bc85372f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://metacpan.org/changes/distribution/Module-Signature", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/audreyt/module-signature/commit/8a9164596fa5952d4fbcde5aa1c7d1c7bc85372f"}}