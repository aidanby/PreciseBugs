{"buggy_code": ["2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n  \n        * chmd_read_headers(): again reject files with blank filenames, this\n        time because their 1st or 2nd byte is null, not because their length\n        is zero.  Thanks again to Hanno B\u00f6ck for finding the issue.\n\n2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* Makefile.am: using automake _DEPENDENCIES for chmd_test appears to\n\toverride the default dependencies (e.g. sources), so libchmd.la was no\n\tlonger considered a dependency of chmd_test. This breaks parallel\n\tbuilds like \"make -j4\". Added libchmd.la explicitly to dependencies.\n\tThanks to Thomas Deutschmann for reporting this.\n\n\n2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd.c: add new parameter, MSCABD_PARAM_SALVAGE, which makes CAB file\n\treading and extraction more lenient, to allow damaged or mangled CABs\n\tto be extracted. When enabled:\n\t- cabd->open() won't reject cabinets with files that have invalid\n\t  folder indices or filenames. These files will simply be skipped\n\t- cabd->extract() won't reject files with invalid lengths, but will\n\t  limit them to the maximum possible\n\t- block output sizes over 32768 bytes won't be rejected\n\t- invalid data block checksums won't be rejected\n\t\n\tIt's still possible for corrupted files to fail extraction, but more\n\tdata can be extracted before they do.\n\t\n\tThis new parameter doesn't affect the existing MSCABD_PARAM_FIXMSZIP\n\tparameter, which ignores MSZIP decompression failures. You can enable\n\tboth at once.\n\t\n\tThanks to Micah Snyder from ClamAV for working with me to get this\n\tfeature into libmspack. This also helps ClamAV move towards using a\n\tvanilla copy of libmspack without needing their own patchset.\n\n2018-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* mspack.h: clarify that mspack_system.free() should allow NULL. If your\n\tmspack_system implementation doesn't, it would already have crashed, as\n\tthere are several places where libmspack calls sys->free(NULL). This\n\tchange makes it official, and amends a few \"if (x) sys->free(x)\" cases\n\tto the simpler \"sys->free(x)\" to make it clearer.\n\n2018-08-09  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* Makefile.am: the test file cve-2015-4467-reset-interval-zero.chm is\n\tdetected by ClamAV as BC.Legacy.Exploit.CVE_2012_1458-1 \"infected\".\n\tMy hosting deletes anything that ClamAV calls \"infected\", so has been\n\tcontinually deleting the official libmspack 0.7alpha release.\n\t\n\tCVE-2012-1458 is the same issue as CVE-2015-4467: both libmspack, and\n\tClamAV using libmspack, could get a division-by-zero crash when the LZX\n\treset interval was zero. This was fixed years ago, but ClamAV still has \n\tit as a signature, which today prevents me from releasing libmspack.\n\t\n\tBC.Legacy.Exploit.CVE_2012_1458-1 is a bytecode signature, so I can't\n\tsee the exact trigger conditions, but I can see that it looks for the\n\t\"LZXC\" signature of the LZX control file, so I've changed this to\n\t\"lzxc\" and added a step in the Makefile to change it back to LZXC, so\n\tI can release libmspack whether or not ClamAV keeps the signature.\n\n2018-04-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_chunk(): the test that chunk numbers are in bounds was off\n\tby one, so read_chunk() returned a pointer taken from outside\n\tallocated memory that usually crashes libmspack when accessed.\n\tThanks to Hanno B\u00f6ck for finding the issue and providing a sample.\n\n\t* chmd_read_headers(): reject files with blank filenames. Thanks\n\tagain to Hanno B\u00f6ck for finding the issue and providing a sample file.\n\n2018-02-06  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* chmd.c: fixed an off-by-one error in the TOLOWER() macro, reported\n\tby Dmitry Glavatskikh. Thanks Dmitry!\n\n2017-11-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* kwajd_read_headers(): fix up the logic of reading the filename and\n\textension headers to avoid a one or two byte overwrite. Thanks to\n\tJakub Wilk for finding the issue.\n\n\t* test/kwajd_test.c: add tests for KWAJ filename.ext handling\n\n2017-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* test/cabd_test.c: update the short string tests to expect not only\n\tMSPACK_ERR_DATAFORMAT but also MSPACK_ERR_READ, because of the recent\n\tchange to cabd_read_string(). Thanks to maitreyee43 for spotting this.\n\n\t* test/msdecompile_md5: update the setup instructions for this script,\n\tand also change the script so it works with current Wine. Again, thanks\n\tto maitreyee43 for trying to use it and finding it not working.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* src/chmextract.c: support MinGW one-arg mkdir(). Thanks to AntumDeluge\n\tfor reporting this.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_spaninfo(): a CHM file can have no ResetTable and have a\n\tnegative length in SpanInfo, which then feeds a negative output length\n\tto lzxd_init(), which then sets frame_size to a value of your choosing,\n\tthe lower 32 bits of output length, larger than LZX_FRAME_SIZE. If the\n\tfirst LZX block is uncompressed, this writes data beyond the end of the\n\twindow. This issue was raised by ClamAV as CVE-2017-6419.  Thanks to\n\tSebastian Andrzej Siewior for finding this by chance!\n\n\t* lzxd_init(), lzxd_set_output_length(), mszipd_init(): due to the issue\n\tmentioned above, these functions now reject negative lengths\n\n2017-08-05  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd_read_string(): add missing error check on result of read().\n\tIf an mspack_system implementation returns an error, it's interpreted\n\tas a huge positive integer, which leads to reading past the end of the\n\tstack-based buffer. Thanks to Sebastian Andrzej Siewior for explaining\n\tthe problem. This issue was raised by ClamAV as CVE-2017-11423\n\n2016-04-20  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* configure.ac: change my email address to kyzer@cabextract.org.uk\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_read_string(): correct rejection of empty strings. Thanks to\n\tHanno B\u00f6ck for finding the issue and providing a sample file.\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Add subdir-objects option as suggested by autoreconf.\n\n\t* configure.ac: Add AM_PROG_AR as suggested by autoreconf.\n\n2015-01-29  Stuart Caie <kyzer@4u.net>\n\n\t* system.h: if C99 inttypes.h exists, use its PRI{d,u}{32,64} macros.\n\tThanks to Johnathan Kollasch for the suggestion.\n\n2015-01-18  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): the byte-alignment code for reading uncompressed\n\tblock headers presumed it could wind i_ptr back 2 bytes, but this\n\thasn't been true since READ_BYTES was allowed to read bytes straddling\n\ttwo blocks, leaving just 1 byte in the read buffer. Thanks to Jakub\n\tWilk for finding the issue and providing a sample file.\n\n\t* inflate(): off-by-one error. Distance codes are 0-29, not 0-30.\n\tThanks to Jakub Wilk again.\n\n\t* chmd_read_headers(), search_chunk(): another fix for checking pointer\n\tis within a chunk, thanks again to Jakub Wilk.\n\n2015-01-17  Stuart Caie <kyzer@4u.net>\n\n\t* GET_UTF8_CHAR(): Remove 5/6-byte encoding support and check decoded\n\tchars are no more than U+10FFFF.\n\n\t* chmd_init_decomp(): A reset interval of 0 is invalid. Thanks to\n\tJakub Wilk for finding the issue and providing a sample and patch.\n\n2015-01-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): add a bounds check to prevent over-reading data,\n\twhich caused a segfault on 32-bit architectures. Thanks to Jakub Wilk.\n\n\t* search_chunk(): change the order of pointer arithmetic operations to\n\tavoid overflow during bounds checks, which lead to segfaults on 32-bit\n\tarchitectures. Again, thanks to Jakub Wilk for finding this issue,\n\tproviding sample files and a patch.\n\n2015-01-08  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_extract(): No longer uses broken state data if extracting from\n\tfolder 1, 2, 1 and setting up folder 2 fails. This prevents a jump to\n\tnull and thus segfault. Thanks to Jakub Wilk again.\n\n\t* cabd_read_string: reject empty strings. They are not found in any\n\tvalid CAB files. Thanks to Hanno B\u00f6ck for sending me an example.\n\n2015-01-05  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_can_merge_folders(): disallow folder merging if the combined\n\tfolder would have more than 65535 data blocks.\n\n\t* cabd_decompress(): disallow files if their offset, length or\n\toffset+length is more than 65535*32768, the maximum size of any\n\tfolder. Thanks to Jakub Wilk for identifying the problem and providing\n\ta sample file.\n\n2014-04-20  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: fixed the table overflow check, which allowed one more\n\tcode after capacity had been reached, resulting in a read of\n\tuninitialized data inside the decoding table. Thanks to Denis Kroshin\n\tfor identifying the problem and providing a sample file.\n\n2013-05-27  Stuart Caie <kyzer@4u.net>\n\n\t* test/oabx.c: added new example command for unpacking OAB files.\n\n2013-05-17  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h: Support for decompressing a new file format, the Exchange\n\tOffline Address Book (OAB). Thanks to David Woodhouse for writing\n\tthe implementation. I've bumped the version to 0.4alpha in celebration.\n\n2012-04-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): More thorough validation of CHM header values.\n\tThanks to Sergei Trofimovich for finding sample files.\n\n\t* read_reset_table(): Better test for overflow. Thanks again to\n\tSergei Trofimovich for generating a good example.\n\n\t* test/chminfo.c: this test program reads the reset table by itself\n\tand was also susceptible to the same overflow problems.\n\n2012-03-16  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: make the GCC warning flags conditional\n\ton using the GCC compiler. Thanks to Dagobert Michelsen for letting\n\tme know.\n\n2011-11-25  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): Prevent matches that go beyond the start\n\tof the LZX stream. Thanks to Sergei Trofimovich for testing\n\twith valgrind and finding a corrupt sample file that exercises\n\tthis scenario.\n\n2011-11-23  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_fast_find(): add a simple check against infinite PMGL\n\tloops. Thanks to Sergei Trofimovich for finding sample files.\n\tMulti-step PMGL/PMGI infinite loops remain possible.\n\n2011-06-17  Stuart Caie <kyzer@4u.net>\n\n\t* read_reset_table(): wasn't reading the right offset for getting\n\tthe LZX uncompressed length. Thanks to Sergei Trofimovich for\n\tfinding the bug.\n\n2011-05-31  Stuart Caie <kyzer@4u.net>\n\n\t* kwajd.c, mszipd.c: KWAJ type 4 files (MSZIP) are now supported.\n\tThanks to Clive Turvey for sending me the format details.\n\n\t* doc/szdd_kwaj_format.html: Updated documentation to cover\n\tKWAJ's MSZIP compression.\n\n2011-05-11  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_find(): rethought how large vs small file support is\n\thandled, as users were getting \"library not compiled to support\n\tlarge files\" message on some small files. Now checks for actual\n\toff_t overflow, rather than trying to preempt it.\n\n2011-05-10:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: implemented fast_find()\n\n\t* test/chmx.c: removed the multiple extraction orders, now it just\n\textracts in the fastest order\n\n\t* test/chmd_order.c: new program added to test that different\n\textraction orders don't affect the results of extraction\n\n\t* test/chmd_find.c: new program to test that fast_find() works.\n\tEither supply your own filename to find, or it will try finding\n\tevery file in the CHM.\n\n\t* configure.ac: because CHM fast find requires case-insensitive\n\tcomparisons, tolower() or towlower() are used where possible.\n\tThese functions and their headers are checked for.\n\n\t* mspack.h: exposed struct mschmd_sec_mscompressed's spaninfo\n\tand struct mschmd_header's first_pmgl, last_pmgl and chunk_cache\n\tto the world. Check that the CHM decoder version is v2 or higher\n\tbefore using them.\n\n\t* system.c: set CHM decoder version to v2\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made C++ compilers much happier with libmspack.\n\tChanged char * to const char * where possible.\n\n\t* mspack.h: Changed user-supplied char * to const char *.\n\tUnless you've written your own mspack_system implementation,\n\tyou will likely be unaffected.\n\tIf you have written your own mspack_system implementation:\n\t1: change open()    so it takes a const char *filename\n\t2: change message() so it takes a const char *format\n\tIf you cast your function into the mspack_system struct,\n\tyou can change the cast instead of the function.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: changed CFLAGS from \"-Wsign-compare -Wconversion\n\t-pedantic\" to \"-W -Wno-unused\". This enables more warnings, and\n\tdisables these specific warnings which are now a hinderance.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: used macros from system.h for\n\tprinting offsets and reading 64-bit values, rather than\n\treinvent the wheel.\n\n\t* cabd_can_merge_folders(): declare variables at the start of\n\ta block so older C compilers won't choke.\n\n\t* cabd_find(): avoid compiler complaints about non-initialised\n\tvariables. We know they'll get initialised before use, but the\n\tcompiler can't reverse a state machine to draw the same conclusion.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* configure.ac, mspack/system.h: Added a configure test to get\n\tthe size of off_t. If off_t is 8 bytes or more, we presume this\n\tsystem has large file support. This fixes LFS detection for Fedora\n\tx86_64 and Darwin/Mac OS X, neither of which declare FILESIZEBITS in\n\t<limits.h>. It's not against the POSIX standard to do this: \"A\n\tdefinition of [FILESIZEBITS] shall be omitted from the <limits.h>\n\theader on specific implementations where the corresponding value is\n\tequal to or greater than the stated minimum, but where the value can\n\tvary depending on the file to which it is applied.\"\n\t(http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html)\n\tThanks to Edward Sheldrake for the patch.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: all 64-bit integer reads are now consolidated into\n\tthe read_off64() function\n\n\t* chmd_read_headers(): this function has been made resilient\n\tagainst accessing memory past the end of a chunk. Thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n\t* chmd_init_decomp(): this function now reads the SpanInfo file\n\tif the ResetTable file isn't available, it also checks that each\n\tsystem file it needs is large enough before accessing it, and\n\tsome of its code has been split into several new functions:\n\tfind_sys_file(), read_reset_table() and read_spaninfo()\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h, chmd.c: now reads the SpanInfo system file if the\n\tResetTable file isn't available. This adds a new spaninfo pointer\n\tinto struct mschmd_sec_mscompressed\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* test/chminfo.c: more sanity checks for corrupted CHM files where\n\tentries go past the end of a PMGL/PMGI chunk, thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n2011-04-25:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_merge():  Drew D'Addesio showed me spanning cabinets which\n\tdon't have all the CFFILE entries they should, but otherwise have\n\tall necessary data for extraction. Changed the merging folders\n\ttest to be less strict; if folders don't exactly match, warn which\n\tfiles are missing, but allow merging if at least one necessary\n\tfile is present.\n\n2010-09-24:  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: Don't let build_decode_table() allow empty trees.\n\tIt's meant to be special case just for the LZX length tree, so\n\tmove that logic out to the LZX code. Thanks to Danny Kroshin for\n\tdiscovering the bug.\n\n\t* lzxd.c: Allow empty length trees, but not other trees. If\n\tthe length tree is empty, fail if asked to decode a length symbol.\n\tAgain, thanks to Danny Kroshin for discovering the bug.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Set EXTRA_DIST so it doesn't include .svn\n\tdirectories in the distribution, but does include docs.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: Use modern auto* practises; turn on\n\tautomake silent rules where possible, use \"m4\" directory for libtool\n\tmacros, use LT_INIT instead of AC_PROG_LIBTOOL and use AM_CPPFLAGS\n\tinstead of INCLUDES. Thanks to Sergei Trofimovich for the patch.\n\n2010-09-15:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made the code compile with C++\n\t- Renamed all 'this' variables/parameters to 'self'\n\t- Added casts to all memory allocations.\n\t- Added extern \"C\" to header files with extern declarations.\n\t- Made system.c include system.h.\n\t- Changed the K&R-style headers to ANSI-style headers in md5.c\n\n2010-08-04:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: removed unnecessary <unistd.h> include\n\n2010-07-19:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_md5.c, chmd_md5.c: Replace writing files to disk then\n\tMD5summing them, with an MD5summer built into mspack_system.\n\tMuch, much faster results.\n\n\t* qtmd_decompress(): Robert Riebisch pointed out a Quantum\n\tdata integrity check that could never be tripped, because\n\tframe_todo is unsigned, so it will never be decremented\n\tbelow zero. Replaced the check with one that assumes that\n\tdecrementing past zero wraps frame_todo round to a number\n\tmore than its maximum value (QTM_FRAME_SIZE).\n\n2010-07-18:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd.c: Special logic to pass cabd_sys_read() errors back\n\tto cabd_extract() wasn't compatible with the decompressor\n\tlogic of returning the same error repeatedly once unpacking\n\tfails. This meant that if decompressing failed because of\n\ta read error, then the next file in the same folder would\n\tcome back as \"no error\", but the decompressed wouldn't have\n\teven attempted to decompress the file. Added a new state\n\tvariable, read_error, with the same lifespan as a decompressor,\n\tto pass the underlying reason for MSPACK_ERR_READ errors back.\n\n\t* mszipd.c: improve MS-ZIP recovery by saving all the bytes\n\tdecoded prior to a block failing. This requires remembering\n\thow far we got through the block, so the code has been made\n\tslightly slower (about 0.003 seconds slower per gigabyte\n\tunpacked) by removing the local variable window_posn\n\tand keeping it in the state structure instead.\n\n2010-07-16:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: strange interactions. When -std=c99 is used,\n\tmy Ubuntu's <stdio.h> (libc6-dev 2.11.1-0ubuntu7.2) does NOT\n\tdefine fseeko() unless _LARGEFILE_SOURCE is also defined. But\n\tconfigure always uses -std=gnu99, not -std=c99, so its test\n\tdetermines _LARGEFILE_SOURCE isn't needed but HAVE_FSEEKO is\n\ttrue. The implicit fseeko definition has a 32-bit rather than\n\t64-bit offset, which means the mode parameter is interpreted\n\tas part of the offset, and the mode is taken from the stack,\n\twhich is generally 0 (SEEK_SET). This breaks all SEEK_CURs.\n\tThe code works fine when -std=c99 is not set, so just remove\n\tit for the time being.\n\n2010-07-12:  Stuart Caie <kyzer@4u.net>\n\n\t* system.c: Reject reading/writing a negative number of bytes.\n\n\t* chmd.c: allow zero-length files to be seen. Previously they were\n\tskipped because they were mistaken for directory entries.\n\n2010-07-08:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c: Larry Frieson found an important bug in the Quantum\n\tdecoder. Window wraps flush all unwritten data to disk.\n\tHowever, sometimes less data is needed, which makes\n\tout_bytes negative, which is then passed to write(). Some\n\twrite() implementations treat negative sizes it as a large\n\tpositive integer and segfault trying to write the buffer.\n\n\t* Makefile.am, test/*.c: fixed automake file so that the\n\tpackage passes a \"make distcheck\".\n\n2010-07-07:  Stuart Caie <kyzer@4u.net>\n\n\t* doc/szdd_kwaj_format.html: explain SZDD/KWAJ file format.\n\n\t* lzssd.c: fixed SZDD decompression bugs.\n\n\t* test/chmd_compare: Add scripts for comparing chmd_md5 against\n\tMicrosoft's own code.\n\n\t* test/chmd_md5.c: remove the need to decompress everything\n\ttwice, as this is already in chmx.c if needed.\n\n2010-07-06:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: added SZDD and KWAJ decompression support.\n\n2010-06-18:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: expanded the test for 64-bit largefile support so\n\tit also works on 64-bit native operating systems where you\n\tdon't have to define _FILE_OFFSET_BITS.\n\n2010-06-17:  Stuart Caie <kyzer@4u.net>\n\n\t* libmspack.pc.in: Added pkg-config support. Thanks to\n\tPatrice Dumas for the patch.\n\n2010-06-14:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c, lzxd.c, mszipd.c: created new headers, readbits.h and\n\treadhuff.h, which bundle up the bit-reading and huffman-reading\n\tcode found in the MSZIP, LZX and Quantum decoders.\n\n2010-06-11:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd_static_init(): Removed function in favour of static const\n\ttables, same rationale as for lzxd_static_init().\n\n\t* qtmd_read_input(), zipd_read_input(): After testing against my\n\tset of CABs from the wild, I've found both these functions _need_\n\tan extra EOF flag, like lzxd_read_input() has. So I've added\n\tit. This means CABs get decoded properly AND there's no reading\n\tfictional bytes.\n\n2010-06-03:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabd_md5.c: updated this so it has better output and\n\tdoesn't need to be in the same directory as the files for multi-\n\tpart sets.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* qtmd_read_input(), zipd_read_input(): Both these functions are\n\tessentially copies of lzxd_read_input(), but that has a feature\n\tthey don't have - an extra EOF flag. So if EOF is\n\tencountered (sys->read() returns 0 bytes), these don't pass on the\n\terror. Their respective bit-reading functions that called them\n\tthen go on to access at least one byte of the input buffer, which\n\tdoesn't exist as sys->read() returned 0. Thanks to Michael\n\tVidrevich for spotting this and providing a test case.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: It turns out no configure.ac tests are needed to\n\tdecide between __func__ and __FUNCTION__, so I put the standard\n\tone (__func__) back into the D() macro, along with some\n\tspecial-case ifdefs for old versions of GCC.\n\n\t* lzxd_static_init(): Removed function in favour of static const\n\ttables.  Jorge Lodos thinks it causes multithreading problems, I\n\tdisagree. However, there are speed benefits to declaring the\n\ttables as static const.\n\n\t* cabd_init_decomp(): Fixed code which never runs but would write\n\tto a null pointer if it could. Changed it to an assert() as it\n\twill only trip if someone rewrites the internals of cabd.c. Thanks\n\tto Jorge Lodos for finding it.\n\n\t* inflate(): Fixed an off-by-one error: if the LITERAL table\n\temitted code 286, this would read one byte past the end of\n\tlit_extrabits[]. Thanks to Jorge Lodos for finding it.\n\n2010-05-06:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: add fseeko() support\n\n2009-06-01:  Stuart Caie   <kyzer@4u.net>\n\n\t* README: clarify the extended license terms\n\n\t* doc, Makefile.am: make the doxygen makefile work when using\n\tan alternate build directory\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: I had a choice of adding more to configure.ac to\n\ttest for __func__ and __FUNCTION__, or just removing __FUNCTION__\n\tfrom the D() macro. I chose the latter.\n\n\t* Makefile.am: Now the --enable-debug in configure will actually\n\tapply -DDEBUG to the sources.\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_decompress(): Fixed a major bug in the QTM decoder, as\n\treported by Tomasz Kojm last year. Removed the restriction on\n\twindow sizes as a result. Correctly decodes the XLVIEW cabinets.\n\n2006-08-31:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_decompress(): Two major bugs fixed. Firstly, the R0/R1/R2\n\tlocal variables weren't set to 1 after lzxd_reset_state().\n\tSecondly, the LZX decompression stream can sometimes become\n\todd-aligned (after an uncompressed block) and the next 16 bit\n\tfetch needs to be split across two input buffers, ENSURE_BITS()\n\tdidn't cover this case. Many thanks to Igor Glucksmann for\n\tdiscovering both these bugs.\n\n2005-06-30:  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd_search(): fixed problems with searching files > 4GB for\n\tcabinets.\n\n2005-06-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_init(): The QTM decoder is broken for QTM streams with a\n\twindow size less than the frame size. Until this is fixed, fail\n\tto initialise QTM window sizes less than 15. Thanks to Tomasz Kojm\n\tfor finding the bug.\n\n2005-03-22:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: now undefs \"read\", as the latest glibc defines read()\n\tas a macro which messes everything up. Thanks to Ville Skytt\u00e4 for\n\tthe update.\n\n2005-03-14:  Stuart Caie   <kyzer@4u.net>\n\n\t* test/multifh.c: write an mspack_system implementation that can\n\thandle normal disk files, open file handles, open file descriptors\n\tand raw memory all at the same time.\n\n2005-02-24:  Stuart Caie   <kyzer@4u.net>\n\n\t* chmd_read_headers(): avoid infinite loop when chmhs1_ChunkSize is\n\tzero. Thanks to Serge Semashko for the research and discovery.\n\n2005-02-18:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: renamed the \"interface\" parameter of mspack_version() to\n\t\"entity\", as interface is a reserved word in C++. Thanks to Yuriy Z\n\tfor the discovery.\n\n2004-12-09:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzss.h, szdd.h, szddd.h: more work on the SZDD/LZSS design.\n\t\n2004-06-12:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_static_init(): removed write to lzxd_extra_bits[52], thanks\n\tto Nigel Horne from the ClamAV project.\n\n2004-04-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: changed 'this' parameters to 'self' to allow compiling in\n\tC++ compilers, thanks to Michal Cihar for the suggestion.\n\n\t* mspack.h, system.h, mspack.def, winbuild.sh: integrated some changes\n\tfrom Petr Blahos to let libmspack build as a Win32 DLL.\n\n\t* chmd_fast_find(): added the first part of this code, and comments\n\tsufficient to finish it :)\n\n2004-04-08  Stuart Caie   <kyzer@4u.net>\n\n\t* test/chminfo.c: added a program for dumping useful data from CHM\n\tfiles, e.g. index entries and reset tables. I wrote this a while ago\n\tfor investigating a corrupt cabinet, but I never committed it.\n\n2004-03-26  Stuart Caie   <kyzer@4u.net>\n\n\t* test/cabd_memory.c: added a new test example which shows an\n\tmspack_system implementation that reads and writes from memory only,\n\tno file I/O. Even the source code has a little cab file embedded in it.\n\n2004-03-10  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd.c: updated the location of the CAB SDK.\n\n\t* cabd.c: changed a couple of MSPACK_ERR_READ errors not based on\n\tread() failures into MSPACK_ERR_DATAFORMAT errors.\n\n\t* mszipd_decompress(): repair mode now aborts after writing a\n\trepaired block if the error was a hard error (e.g. read error, out\n\tof blocks, etc)\n\n2004-03-08  Stuart Caie   <kyzer@4u.net>\n\n\t* Makefile.am: now builds and installs a versioned library.\n\n\t* mszipd.c: completed a new MS-ZIP and inflate implementation.\n\n\t* system.c: added mspack_version() and committed to a versioned\n\tABI for the library.\n\n\t* cabd.c: made mszip repair functionality work correctly.\n\n\t* cabd.c: now identifies invalid block headers\n\n\t* doc/: API documentation is now included with the library, not\n\tjust on the web.\n\n\t* chmd.c: fixed error messages and 64-bit debug output.\n\n\t* chmd.c: now also catches NULL files in section 1.\n\n\t* test/chmx.c: now acts more like cabextract.\n\n2003-08-29  Stuart Caie   <kyzer@4u.net>\n\n\t* ChangeLog: started keeping a ChangeLog :)\n", "/* This file is part of libmspack.\n * (C) 2003-2004 Stuart Caie.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n#ifndef MSPACK_CAB_H\n#define MSPACK_CAB_H 1\n\n#include <mszip.h>\n#include <qtm.h>\n#include <lzx.h>\n\n/* generic CAB definitions */\n\n/* structure offsets */\n#define cfhead_Signature         (0x00)\n#define cfhead_CabinetSize       (0x08)\n#define cfhead_FileOffset        (0x10)\n#define cfhead_MinorVersion      (0x18)\n#define cfhead_MajorVersion      (0x19)\n#define cfhead_NumFolders        (0x1A)\n#define cfhead_NumFiles          (0x1C)\n#define cfhead_Flags             (0x1E)\n#define cfhead_SetID             (0x20)\n#define cfhead_CabinetIndex      (0x22)\n#define cfhead_SIZEOF            (0x24)\n#define cfheadext_HeaderReserved (0x00)\n#define cfheadext_FolderReserved (0x02)\n#define cfheadext_DataReserved   (0x03)\n#define cfheadext_SIZEOF         (0x04)\n#define cffold_DataOffset        (0x00)\n#define cffold_NumBlocks         (0x04)\n#define cffold_CompType          (0x06)\n#define cffold_SIZEOF            (0x08)\n#define cffile_UncompressedSize  (0x00)\n#define cffile_FolderOffset      (0x04)\n#define cffile_FolderIndex       (0x08)\n#define cffile_Date              (0x0A)\n#define cffile_Time              (0x0C)\n#define cffile_Attribs           (0x0E)\n#define cffile_SIZEOF            (0x10)\n#define cfdata_CheckSum          (0x00)\n#define cfdata_CompressedSize    (0x04)\n#define cfdata_UncompressedSize  (0x06)\n#define cfdata_SIZEOF            (0x08)\n\n/* flags */\n#define cffoldCOMPTYPE_MASK            (0x000f)\n#define cffoldCOMPTYPE_NONE            (0x0000)\n#define cffoldCOMPTYPE_MSZIP           (0x0001)\n#define cffoldCOMPTYPE_QUANTUM         (0x0002)\n#define cffoldCOMPTYPE_LZX             (0x0003)\n#define cfheadPREV_CABINET             (0x0001)\n#define cfheadNEXT_CABINET             (0x0002)\n#define cfheadRESERVE_PRESENT          (0x0004)\n#define cffileCONTINUED_FROM_PREV      (0xFFFD)\n#define cffileCONTINUED_TO_NEXT        (0xFFFE)\n#define cffileCONTINUED_PREV_AND_NEXT  (0xFFFF)\n\n/* CAB data blocks are <= 32768 bytes in uncompressed form. Uncompressed\n * blocks have zero growth. MSZIP guarantees that it won't grow above\n * uncompressed size by more than 12 bytes. LZX guarantees it won't grow\n * more than 6144 bytes. Quantum has no documentation, but the largest\n * block seen in the wild is 337 bytes above uncompressed size.\n */\n#define CAB_BLOCKMAX (32768)\n#define CAB_INPUTMAX (CAB_BLOCKMAX+6144)\n\n/* There are no more than 65535 data blocks per folder, so a folder cannot\n * be more than 32768*65535 bytes in length. As files cannot span more than\n * one folder, this is also their max offset, length and offset+length limit.\n */\n#define CAB_FOLDERMAX (65535)\n#define CAB_LENGTHMAX (CAB_BLOCKMAX * CAB_FOLDERMAX)\n\n/* CAB compression definitions */\n\nstruct mscab_compressor_p {\n  struct mscab_compressor base;\n  struct mspack_system *system;\n  /* todo */\n};\n\n/* CAB decompression definitions */\n\nstruct mscabd_decompress_state {\n  struct mscabd_folder_p *folder;    /* current folder we're extracting from */\n  struct mscabd_folder_data *data;   /* current folder split we're in        */\n  unsigned int offset;               /* uncompressed offset within folder    */\n  unsigned int block;                /* which block are we decompressing?    */\n  off_t outlen;                      /* cumulative sum of block output sizes */\n  struct mspack_system sys;          /* special I/O code for decompressor    */\n  int comp_type;                     /* type of compression used by folder   */\n  int (*decompress)(void *, off_t);  /* decompressor code                    */\n  void *state;                       /* decompressor state                   */\n  struct mscabd_cabinet_p *incab;    /* cabinet where input data comes from  */\n  struct mspack_file *infh;          /* input file handle                    */\n  struct mspack_file *outfh;         /* output file handle                   */\n  unsigned char *i_ptr, *i_end;      /* input data consumed, end             */\n  unsigned char input[CAB_INPUTMAX]; /* one input block of data              */\n};\n\nstruct mscab_decompressor_p {\n  struct mscab_decompressor base;\n  struct mscabd_decompress_state *d;\n  struct mspack_system *system;\n  int param[4]; /* !!! MATCH THIS TO NUM OF PARAMS IN MSPACK.H !!! */\n  int error, read_error;\n};\n\nstruct mscabd_cabinet_p {\n  struct mscabd_cabinet base;\n  off_t blocks_off;                  /* offset to data blocks                */\n  int block_resv;                    /* reserved space in data blocks        */\n};\n\n/* there is one of these for every cabinet a folder spans */\nstruct mscabd_folder_data {\n  struct mscabd_folder_data *next;\n  struct mscabd_cabinet_p *cab;      /* cabinet file of this folder span     */\n  off_t offset;                      /* cabinet offset of first datablock    */\n};\n\nstruct mscabd_folder_p {\n  struct mscabd_folder base;\n  struct mscabd_folder_data data;    /* where are the data blocks?           */\n  struct mscabd_file *merge_prev;    /* first file needing backwards merge   */\n  struct mscabd_file *merge_next;    /* first file needing forwards merge    */\n};\n\n#endif\n"], "fixing_code": ["2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cab.h: Make the CAB block input buffer one byte larger, to allow\n\ta maximum-allowed-size input block and the special extra byte added\n\tafter the block by cabd_sys_read_block to help Quantum alignment.\n\tThanks to Henri Salo for reporting this.\n\n\n2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n  \n        * chmd_read_headers(): again reject files with blank filenames, this\n        time because their 1st or 2nd byte is null, not because their length\n        is zero.  Thanks again to Hanno B\u00f6ck for finding the issue.\n\n2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* Makefile.am: using automake _DEPENDENCIES for chmd_test appears to\n\toverride the default dependencies (e.g. sources), so libchmd.la was no\n\tlonger considered a dependency of chmd_test. This breaks parallel\n\tbuilds like \"make -j4\". Added libchmd.la explicitly to dependencies.\n\tThanks to Thomas Deutschmann for reporting this.\n\n\n2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd.c: add new parameter, MSCABD_PARAM_SALVAGE, which makes CAB file\n\treading and extraction more lenient, to allow damaged or mangled CABs\n\tto be extracted. When enabled:\n\t- cabd->open() won't reject cabinets with files that have invalid\n\t  folder indices or filenames. These files will simply be skipped\n\t- cabd->extract() won't reject files with invalid lengths, but will\n\t  limit them to the maximum possible\n\t- block output sizes over 32768 bytes won't be rejected\n\t- invalid data block checksums won't be rejected\n\t\n\tIt's still possible for corrupted files to fail extraction, but more\n\tdata can be extracted before they do.\n\t\n\tThis new parameter doesn't affect the existing MSCABD_PARAM_FIXMSZIP\n\tparameter, which ignores MSZIP decompression failures. You can enable\n\tboth at once.\n\t\n\tThanks to Micah Snyder from ClamAV for working with me to get this\n\tfeature into libmspack. This also helps ClamAV move towards using a\n\tvanilla copy of libmspack without needing their own patchset.\n\n2018-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* mspack.h: clarify that mspack_system.free() should allow NULL. If your\n\tmspack_system implementation doesn't, it would already have crashed, as\n\tthere are several places where libmspack calls sys->free(NULL). This\n\tchange makes it official, and amends a few \"if (x) sys->free(x)\" cases\n\tto the simpler \"sys->free(x)\" to make it clearer.\n\n2018-08-09  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* Makefile.am: the test file cve-2015-4467-reset-interval-zero.chm is\n\tdetected by ClamAV as BC.Legacy.Exploit.CVE_2012_1458-1 \"infected\".\n\tMy hosting deletes anything that ClamAV calls \"infected\", so has been\n\tcontinually deleting the official libmspack 0.7alpha release.\n\t\n\tCVE-2012-1458 is the same issue as CVE-2015-4467: both libmspack, and\n\tClamAV using libmspack, could get a division-by-zero crash when the LZX\n\treset interval was zero. This was fixed years ago, but ClamAV still has \n\tit as a signature, which today prevents me from releasing libmspack.\n\t\n\tBC.Legacy.Exploit.CVE_2012_1458-1 is a bytecode signature, so I can't\n\tsee the exact trigger conditions, but I can see that it looks for the\n\t\"LZXC\" signature of the LZX control file, so I've changed this to\n\t\"lzxc\" and added a step in the Makefile to change it back to LZXC, so\n\tI can release libmspack whether or not ClamAV keeps the signature.\n\n2018-04-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_chunk(): the test that chunk numbers are in bounds was off\n\tby one, so read_chunk() returned a pointer taken from outside\n\tallocated memory that usually crashes libmspack when accessed.\n\tThanks to Hanno B\u00f6ck for finding the issue and providing a sample.\n\n\t* chmd_read_headers(): reject files with blank filenames. Thanks\n\tagain to Hanno B\u00f6ck for finding the issue and providing a sample file.\n\n2018-02-06  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* chmd.c: fixed an off-by-one error in the TOLOWER() macro, reported\n\tby Dmitry Glavatskikh. Thanks Dmitry!\n\n2017-11-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* kwajd_read_headers(): fix up the logic of reading the filename and\n\textension headers to avoid a one or two byte overwrite. Thanks to\n\tJakub Wilk for finding the issue.\n\n\t* test/kwajd_test.c: add tests for KWAJ filename.ext handling\n\n2017-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* test/cabd_test.c: update the short string tests to expect not only\n\tMSPACK_ERR_DATAFORMAT but also MSPACK_ERR_READ, because of the recent\n\tchange to cabd_read_string(). Thanks to maitreyee43 for spotting this.\n\n\t* test/msdecompile_md5: update the setup instructions for this script,\n\tand also change the script so it works with current Wine. Again, thanks\n\tto maitreyee43 for trying to use it and finding it not working.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* src/chmextract.c: support MinGW one-arg mkdir(). Thanks to AntumDeluge\n\tfor reporting this.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_spaninfo(): a CHM file can have no ResetTable and have a\n\tnegative length in SpanInfo, which then feeds a negative output length\n\tto lzxd_init(), which then sets frame_size to a value of your choosing,\n\tthe lower 32 bits of output length, larger than LZX_FRAME_SIZE. If the\n\tfirst LZX block is uncompressed, this writes data beyond the end of the\n\twindow. This issue was raised by ClamAV as CVE-2017-6419.  Thanks to\n\tSebastian Andrzej Siewior for finding this by chance!\n\n\t* lzxd_init(), lzxd_set_output_length(), mszipd_init(): due to the issue\n\tmentioned above, these functions now reject negative lengths\n\n2017-08-05  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd_read_string(): add missing error check on result of read().\n\tIf an mspack_system implementation returns an error, it's interpreted\n\tas a huge positive integer, which leads to reading past the end of the\n\tstack-based buffer. Thanks to Sebastian Andrzej Siewior for explaining\n\tthe problem. This issue was raised by ClamAV as CVE-2017-11423\n\n2016-04-20  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* configure.ac: change my email address to kyzer@cabextract.org.uk\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_read_string(): correct rejection of empty strings. Thanks to\n\tHanno B\u00f6ck for finding the issue and providing a sample file.\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Add subdir-objects option as suggested by autoreconf.\n\n\t* configure.ac: Add AM_PROG_AR as suggested by autoreconf.\n\n2015-01-29  Stuart Caie <kyzer@4u.net>\n\n\t* system.h: if C99 inttypes.h exists, use its PRI{d,u}{32,64} macros.\n\tThanks to Johnathan Kollasch for the suggestion.\n\n2015-01-18  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): the byte-alignment code for reading uncompressed\n\tblock headers presumed it could wind i_ptr back 2 bytes, but this\n\thasn't been true since READ_BYTES was allowed to read bytes straddling\n\ttwo blocks, leaving just 1 byte in the read buffer. Thanks to Jakub\n\tWilk for finding the issue and providing a sample file.\n\n\t* inflate(): off-by-one error. Distance codes are 0-29, not 0-30.\n\tThanks to Jakub Wilk again.\n\n\t* chmd_read_headers(), search_chunk(): another fix for checking pointer\n\tis within a chunk, thanks again to Jakub Wilk.\n\n2015-01-17  Stuart Caie <kyzer@4u.net>\n\n\t* GET_UTF8_CHAR(): Remove 5/6-byte encoding support and check decoded\n\tchars are no more than U+10FFFF.\n\n\t* chmd_init_decomp(): A reset interval of 0 is invalid. Thanks to\n\tJakub Wilk for finding the issue and providing a sample and patch.\n\n2015-01-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): add a bounds check to prevent over-reading data,\n\twhich caused a segfault on 32-bit architectures. Thanks to Jakub Wilk.\n\n\t* search_chunk(): change the order of pointer arithmetic operations to\n\tavoid overflow during bounds checks, which lead to segfaults on 32-bit\n\tarchitectures. Again, thanks to Jakub Wilk for finding this issue,\n\tproviding sample files and a patch.\n\n2015-01-08  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_extract(): No longer uses broken state data if extracting from\n\tfolder 1, 2, 1 and setting up folder 2 fails. This prevents a jump to\n\tnull and thus segfault. Thanks to Jakub Wilk again.\n\n\t* cabd_read_string: reject empty strings. They are not found in any\n\tvalid CAB files. Thanks to Hanno B\u00f6ck for sending me an example.\n\n2015-01-05  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_can_merge_folders(): disallow folder merging if the combined\n\tfolder would have more than 65535 data blocks.\n\n\t* cabd_decompress(): disallow files if their offset, length or\n\toffset+length is more than 65535*32768, the maximum size of any\n\tfolder. Thanks to Jakub Wilk for identifying the problem and providing\n\ta sample file.\n\n2014-04-20  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: fixed the table overflow check, which allowed one more\n\tcode after capacity had been reached, resulting in a read of\n\tuninitialized data inside the decoding table. Thanks to Denis Kroshin\n\tfor identifying the problem and providing a sample file.\n\n2013-05-27  Stuart Caie <kyzer@4u.net>\n\n\t* test/oabx.c: added new example command for unpacking OAB files.\n\n2013-05-17  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h: Support for decompressing a new file format, the Exchange\n\tOffline Address Book (OAB). Thanks to David Woodhouse for writing\n\tthe implementation. I've bumped the version to 0.4alpha in celebration.\n\n2012-04-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): More thorough validation of CHM header values.\n\tThanks to Sergei Trofimovich for finding sample files.\n\n\t* read_reset_table(): Better test for overflow. Thanks again to\n\tSergei Trofimovich for generating a good example.\n\n\t* test/chminfo.c: this test program reads the reset table by itself\n\tand was also susceptible to the same overflow problems.\n\n2012-03-16  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: make the GCC warning flags conditional\n\ton using the GCC compiler. Thanks to Dagobert Michelsen for letting\n\tme know.\n\n2011-11-25  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): Prevent matches that go beyond the start\n\tof the LZX stream. Thanks to Sergei Trofimovich for testing\n\twith valgrind and finding a corrupt sample file that exercises\n\tthis scenario.\n\n2011-11-23  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_fast_find(): add a simple check against infinite PMGL\n\tloops. Thanks to Sergei Trofimovich for finding sample files.\n\tMulti-step PMGL/PMGI infinite loops remain possible.\n\n2011-06-17  Stuart Caie <kyzer@4u.net>\n\n\t* read_reset_table(): wasn't reading the right offset for getting\n\tthe LZX uncompressed length. Thanks to Sergei Trofimovich for\n\tfinding the bug.\n\n2011-05-31  Stuart Caie <kyzer@4u.net>\n\n\t* kwajd.c, mszipd.c: KWAJ type 4 files (MSZIP) are now supported.\n\tThanks to Clive Turvey for sending me the format details.\n\n\t* doc/szdd_kwaj_format.html: Updated documentation to cover\n\tKWAJ's MSZIP compression.\n\n2011-05-11  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_find(): rethought how large vs small file support is\n\thandled, as users were getting \"library not compiled to support\n\tlarge files\" message on some small files. Now checks for actual\n\toff_t overflow, rather than trying to preempt it.\n\n2011-05-10:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: implemented fast_find()\n\n\t* test/chmx.c: removed the multiple extraction orders, now it just\n\textracts in the fastest order\n\n\t* test/chmd_order.c: new program added to test that different\n\textraction orders don't affect the results of extraction\n\n\t* test/chmd_find.c: new program to test that fast_find() works.\n\tEither supply your own filename to find, or it will try finding\n\tevery file in the CHM.\n\n\t* configure.ac: because CHM fast find requires case-insensitive\n\tcomparisons, tolower() or towlower() are used where possible.\n\tThese functions and their headers are checked for.\n\n\t* mspack.h: exposed struct mschmd_sec_mscompressed's spaninfo\n\tand struct mschmd_header's first_pmgl, last_pmgl and chunk_cache\n\tto the world. Check that the CHM decoder version is v2 or higher\n\tbefore using them.\n\n\t* system.c: set CHM decoder version to v2\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made C++ compilers much happier with libmspack.\n\tChanged char * to const char * where possible.\n\n\t* mspack.h: Changed user-supplied char * to const char *.\n\tUnless you've written your own mspack_system implementation,\n\tyou will likely be unaffected.\n\tIf you have written your own mspack_system implementation:\n\t1: change open()    so it takes a const char *filename\n\t2: change message() so it takes a const char *format\n\tIf you cast your function into the mspack_system struct,\n\tyou can change the cast instead of the function.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: changed CFLAGS from \"-Wsign-compare -Wconversion\n\t-pedantic\" to \"-W -Wno-unused\". This enables more warnings, and\n\tdisables these specific warnings which are now a hinderance.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: used macros from system.h for\n\tprinting offsets and reading 64-bit values, rather than\n\treinvent the wheel.\n\n\t* cabd_can_merge_folders(): declare variables at the start of\n\ta block so older C compilers won't choke.\n\n\t* cabd_find(): avoid compiler complaints about non-initialised\n\tvariables. We know they'll get initialised before use, but the\n\tcompiler can't reverse a state machine to draw the same conclusion.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* configure.ac, mspack/system.h: Added a configure test to get\n\tthe size of off_t. If off_t is 8 bytes or more, we presume this\n\tsystem has large file support. This fixes LFS detection for Fedora\n\tx86_64 and Darwin/Mac OS X, neither of which declare FILESIZEBITS in\n\t<limits.h>. It's not against the POSIX standard to do this: \"A\n\tdefinition of [FILESIZEBITS] shall be omitted from the <limits.h>\n\theader on specific implementations where the corresponding value is\n\tequal to or greater than the stated minimum, but where the value can\n\tvary depending on the file to which it is applied.\"\n\t(http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html)\n\tThanks to Edward Sheldrake for the patch.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: all 64-bit integer reads are now consolidated into\n\tthe read_off64() function\n\n\t* chmd_read_headers(): this function has been made resilient\n\tagainst accessing memory past the end of a chunk. Thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n\t* chmd_init_decomp(): this function now reads the SpanInfo file\n\tif the ResetTable file isn't available, it also checks that each\n\tsystem file it needs is large enough before accessing it, and\n\tsome of its code has been split into several new functions:\n\tfind_sys_file(), read_reset_table() and read_spaninfo()\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h, chmd.c: now reads the SpanInfo system file if the\n\tResetTable file isn't available. This adds a new spaninfo pointer\n\tinto struct mschmd_sec_mscompressed\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* test/chminfo.c: more sanity checks for corrupted CHM files where\n\tentries go past the end of a PMGL/PMGI chunk, thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n2011-04-25:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_merge():  Drew D'Addesio showed me spanning cabinets which\n\tdon't have all the CFFILE entries they should, but otherwise have\n\tall necessary data for extraction. Changed the merging folders\n\ttest to be less strict; if folders don't exactly match, warn which\n\tfiles are missing, but allow merging if at least one necessary\n\tfile is present.\n\n2010-09-24:  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: Don't let build_decode_table() allow empty trees.\n\tIt's meant to be special case just for the LZX length tree, so\n\tmove that logic out to the LZX code. Thanks to Danny Kroshin for\n\tdiscovering the bug.\n\n\t* lzxd.c: Allow empty length trees, but not other trees. If\n\tthe length tree is empty, fail if asked to decode a length symbol.\n\tAgain, thanks to Danny Kroshin for discovering the bug.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Set EXTRA_DIST so it doesn't include .svn\n\tdirectories in the distribution, but does include docs.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: Use modern auto* practises; turn on\n\tautomake silent rules where possible, use \"m4\" directory for libtool\n\tmacros, use LT_INIT instead of AC_PROG_LIBTOOL and use AM_CPPFLAGS\n\tinstead of INCLUDES. Thanks to Sergei Trofimovich for the patch.\n\n2010-09-15:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made the code compile with C++\n\t- Renamed all 'this' variables/parameters to 'self'\n\t- Added casts to all memory allocations.\n\t- Added extern \"C\" to header files with extern declarations.\n\t- Made system.c include system.h.\n\t- Changed the K&R-style headers to ANSI-style headers in md5.c\n\n2010-08-04:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: removed unnecessary <unistd.h> include\n\n2010-07-19:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_md5.c, chmd_md5.c: Replace writing files to disk then\n\tMD5summing them, with an MD5summer built into mspack_system.\n\tMuch, much faster results.\n\n\t* qtmd_decompress(): Robert Riebisch pointed out a Quantum\n\tdata integrity check that could never be tripped, because\n\tframe_todo is unsigned, so it will never be decremented\n\tbelow zero. Replaced the check with one that assumes that\n\tdecrementing past zero wraps frame_todo round to a number\n\tmore than its maximum value (QTM_FRAME_SIZE).\n\n2010-07-18:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd.c: Special logic to pass cabd_sys_read() errors back\n\tto cabd_extract() wasn't compatible with the decompressor\n\tlogic of returning the same error repeatedly once unpacking\n\tfails. This meant that if decompressing failed because of\n\ta read error, then the next file in the same folder would\n\tcome back as \"no error\", but the decompressed wouldn't have\n\teven attempted to decompress the file. Added a new state\n\tvariable, read_error, with the same lifespan as a decompressor,\n\tto pass the underlying reason for MSPACK_ERR_READ errors back.\n\n\t* mszipd.c: improve MS-ZIP recovery by saving all the bytes\n\tdecoded prior to a block failing. This requires remembering\n\thow far we got through the block, so the code has been made\n\tslightly slower (about 0.003 seconds slower per gigabyte\n\tunpacked) by removing the local variable window_posn\n\tand keeping it in the state structure instead.\n\n2010-07-16:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: strange interactions. When -std=c99 is used,\n\tmy Ubuntu's <stdio.h> (libc6-dev 2.11.1-0ubuntu7.2) does NOT\n\tdefine fseeko() unless _LARGEFILE_SOURCE is also defined. But\n\tconfigure always uses -std=gnu99, not -std=c99, so its test\n\tdetermines _LARGEFILE_SOURCE isn't needed but HAVE_FSEEKO is\n\ttrue. The implicit fseeko definition has a 32-bit rather than\n\t64-bit offset, which means the mode parameter is interpreted\n\tas part of the offset, and the mode is taken from the stack,\n\twhich is generally 0 (SEEK_SET). This breaks all SEEK_CURs.\n\tThe code works fine when -std=c99 is not set, so just remove\n\tit for the time being.\n\n2010-07-12:  Stuart Caie <kyzer@4u.net>\n\n\t* system.c: Reject reading/writing a negative number of bytes.\n\n\t* chmd.c: allow zero-length files to be seen. Previously they were\n\tskipped because they were mistaken for directory entries.\n\n2010-07-08:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c: Larry Frieson found an important bug in the Quantum\n\tdecoder. Window wraps flush all unwritten data to disk.\n\tHowever, sometimes less data is needed, which makes\n\tout_bytes negative, which is then passed to write(). Some\n\twrite() implementations treat negative sizes it as a large\n\tpositive integer and segfault trying to write the buffer.\n\n\t* Makefile.am, test/*.c: fixed automake file so that the\n\tpackage passes a \"make distcheck\".\n\n2010-07-07:  Stuart Caie <kyzer@4u.net>\n\n\t* doc/szdd_kwaj_format.html: explain SZDD/KWAJ file format.\n\n\t* lzssd.c: fixed SZDD decompression bugs.\n\n\t* test/chmd_compare: Add scripts for comparing chmd_md5 against\n\tMicrosoft's own code.\n\n\t* test/chmd_md5.c: remove the need to decompress everything\n\ttwice, as this is already in chmx.c if needed.\n\n2010-07-06:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: added SZDD and KWAJ decompression support.\n\n2010-06-18:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: expanded the test for 64-bit largefile support so\n\tit also works on 64-bit native operating systems where you\n\tdon't have to define _FILE_OFFSET_BITS.\n\n2010-06-17:  Stuart Caie <kyzer@4u.net>\n\n\t* libmspack.pc.in: Added pkg-config support. Thanks to\n\tPatrice Dumas for the patch.\n\n2010-06-14:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c, lzxd.c, mszipd.c: created new headers, readbits.h and\n\treadhuff.h, which bundle up the bit-reading and huffman-reading\n\tcode found in the MSZIP, LZX and Quantum decoders.\n\n2010-06-11:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd_static_init(): Removed function in favour of static const\n\ttables, same rationale as for lzxd_static_init().\n\n\t* qtmd_read_input(), zipd_read_input(): After testing against my\n\tset of CABs from the wild, I've found both these functions _need_\n\tan extra EOF flag, like lzxd_read_input() has. So I've added\n\tit. This means CABs get decoded properly AND there's no reading\n\tfictional bytes.\n\n2010-06-03:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabd_md5.c: updated this so it has better output and\n\tdoesn't need to be in the same directory as the files for multi-\n\tpart sets.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* qtmd_read_input(), zipd_read_input(): Both these functions are\n\tessentially copies of lzxd_read_input(), but that has a feature\n\tthey don't have - an extra EOF flag. So if EOF is\n\tencountered (sys->read() returns 0 bytes), these don't pass on the\n\terror. Their respective bit-reading functions that called them\n\tthen go on to access at least one byte of the input buffer, which\n\tdoesn't exist as sys->read() returned 0. Thanks to Michael\n\tVidrevich for spotting this and providing a test case.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: It turns out no configure.ac tests are needed to\n\tdecide between __func__ and __FUNCTION__, so I put the standard\n\tone (__func__) back into the D() macro, along with some\n\tspecial-case ifdefs for old versions of GCC.\n\n\t* lzxd_static_init(): Removed function in favour of static const\n\ttables.  Jorge Lodos thinks it causes multithreading problems, I\n\tdisagree. However, there are speed benefits to declaring the\n\ttables as static const.\n\n\t* cabd_init_decomp(): Fixed code which never runs but would write\n\tto a null pointer if it could. Changed it to an assert() as it\n\twill only trip if someone rewrites the internals of cabd.c. Thanks\n\tto Jorge Lodos for finding it.\n\n\t* inflate(): Fixed an off-by-one error: if the LITERAL table\n\temitted code 286, this would read one byte past the end of\n\tlit_extrabits[]. Thanks to Jorge Lodos for finding it.\n\n2010-05-06:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: add fseeko() support\n\n2009-06-01:  Stuart Caie   <kyzer@4u.net>\n\n\t* README: clarify the extended license terms\n\n\t* doc, Makefile.am: make the doxygen makefile work when using\n\tan alternate build directory\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: I had a choice of adding more to configure.ac to\n\ttest for __func__ and __FUNCTION__, or just removing __FUNCTION__\n\tfrom the D() macro. I chose the latter.\n\n\t* Makefile.am: Now the --enable-debug in configure will actually\n\tapply -DDEBUG to the sources.\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_decompress(): Fixed a major bug in the QTM decoder, as\n\treported by Tomasz Kojm last year. Removed the restriction on\n\twindow sizes as a result. Correctly decodes the XLVIEW cabinets.\n\n2006-08-31:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_decompress(): Two major bugs fixed. Firstly, the R0/R1/R2\n\tlocal variables weren't set to 1 after lzxd_reset_state().\n\tSecondly, the LZX decompression stream can sometimes become\n\todd-aligned (after an uncompressed block) and the next 16 bit\n\tfetch needs to be split across two input buffers, ENSURE_BITS()\n\tdidn't cover this case. Many thanks to Igor Glucksmann for\n\tdiscovering both these bugs.\n\n2005-06-30:  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd_search(): fixed problems with searching files > 4GB for\n\tcabinets.\n\n2005-06-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_init(): The QTM decoder is broken for QTM streams with a\n\twindow size less than the frame size. Until this is fixed, fail\n\tto initialise QTM window sizes less than 15. Thanks to Tomasz Kojm\n\tfor finding the bug.\n\n2005-03-22:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: now undefs \"read\", as the latest glibc defines read()\n\tas a macro which messes everything up. Thanks to Ville Skytt\u00e4 for\n\tthe update.\n\n2005-03-14:  Stuart Caie   <kyzer@4u.net>\n\n\t* test/multifh.c: write an mspack_system implementation that can\n\thandle normal disk files, open file handles, open file descriptors\n\tand raw memory all at the same time.\n\n2005-02-24:  Stuart Caie   <kyzer@4u.net>\n\n\t* chmd_read_headers(): avoid infinite loop when chmhs1_ChunkSize is\n\tzero. Thanks to Serge Semashko for the research and discovery.\n\n2005-02-18:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: renamed the \"interface\" parameter of mspack_version() to\n\t\"entity\", as interface is a reserved word in C++. Thanks to Yuriy Z\n\tfor the discovery.\n\n2004-12-09:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzss.h, szdd.h, szddd.h: more work on the SZDD/LZSS design.\n\t\n2004-06-12:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_static_init(): removed write to lzxd_extra_bits[52], thanks\n\tto Nigel Horne from the ClamAV project.\n\n2004-04-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: changed 'this' parameters to 'self' to allow compiling in\n\tC++ compilers, thanks to Michal Cihar for the suggestion.\n\n\t* mspack.h, system.h, mspack.def, winbuild.sh: integrated some changes\n\tfrom Petr Blahos to let libmspack build as a Win32 DLL.\n\n\t* chmd_fast_find(): added the first part of this code, and comments\n\tsufficient to finish it :)\n\n2004-04-08  Stuart Caie   <kyzer@4u.net>\n\n\t* test/chminfo.c: added a program for dumping useful data from CHM\n\tfiles, e.g. index entries and reset tables. I wrote this a while ago\n\tfor investigating a corrupt cabinet, but I never committed it.\n\n2004-03-26  Stuart Caie   <kyzer@4u.net>\n\n\t* test/cabd_memory.c: added a new test example which shows an\n\tmspack_system implementation that reads and writes from memory only,\n\tno file I/O. Even the source code has a little cab file embedded in it.\n\n2004-03-10  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd.c: updated the location of the CAB SDK.\n\n\t* cabd.c: changed a couple of MSPACK_ERR_READ errors not based on\n\tread() failures into MSPACK_ERR_DATAFORMAT errors.\n\n\t* mszipd_decompress(): repair mode now aborts after writing a\n\trepaired block if the error was a hard error (e.g. read error, out\n\tof blocks, etc)\n\n2004-03-08  Stuart Caie   <kyzer@4u.net>\n\n\t* Makefile.am: now builds and installs a versioned library.\n\n\t* mszipd.c: completed a new MS-ZIP and inflate implementation.\n\n\t* system.c: added mspack_version() and committed to a versioned\n\tABI for the library.\n\n\t* cabd.c: made mszip repair functionality work correctly.\n\n\t* cabd.c: now identifies invalid block headers\n\n\t* doc/: API documentation is now included with the library, not\n\tjust on the web.\n\n\t* chmd.c: fixed error messages and 64-bit debug output.\n\n\t* chmd.c: now also catches NULL files in section 1.\n\n\t* test/chmx.c: now acts more like cabextract.\n\n2003-08-29  Stuart Caie   <kyzer@4u.net>\n\n\t* ChangeLog: started keeping a ChangeLog :)\n", "/* This file is part of libmspack.\n * (C) 2003-2018 Stuart Caie.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n#ifndef MSPACK_CAB_H\n#define MSPACK_CAB_H 1\n\n#include <mszip.h>\n#include <qtm.h>\n#include <lzx.h>\n\n/* generic CAB definitions */\n\n/* structure offsets */\n#define cfhead_Signature         (0x00)\n#define cfhead_CabinetSize       (0x08)\n#define cfhead_FileOffset        (0x10)\n#define cfhead_MinorVersion      (0x18)\n#define cfhead_MajorVersion      (0x19)\n#define cfhead_NumFolders        (0x1A)\n#define cfhead_NumFiles          (0x1C)\n#define cfhead_Flags             (0x1E)\n#define cfhead_SetID             (0x20)\n#define cfhead_CabinetIndex      (0x22)\n#define cfhead_SIZEOF            (0x24)\n#define cfheadext_HeaderReserved (0x00)\n#define cfheadext_FolderReserved (0x02)\n#define cfheadext_DataReserved   (0x03)\n#define cfheadext_SIZEOF         (0x04)\n#define cffold_DataOffset        (0x00)\n#define cffold_NumBlocks         (0x04)\n#define cffold_CompType          (0x06)\n#define cffold_SIZEOF            (0x08)\n#define cffile_UncompressedSize  (0x00)\n#define cffile_FolderOffset      (0x04)\n#define cffile_FolderIndex       (0x08)\n#define cffile_Date              (0x0A)\n#define cffile_Time              (0x0C)\n#define cffile_Attribs           (0x0E)\n#define cffile_SIZEOF            (0x10)\n#define cfdata_CheckSum          (0x00)\n#define cfdata_CompressedSize    (0x04)\n#define cfdata_UncompressedSize  (0x06)\n#define cfdata_SIZEOF            (0x08)\n\n/* flags */\n#define cffoldCOMPTYPE_MASK            (0x000f)\n#define cffoldCOMPTYPE_NONE            (0x0000)\n#define cffoldCOMPTYPE_MSZIP           (0x0001)\n#define cffoldCOMPTYPE_QUANTUM         (0x0002)\n#define cffoldCOMPTYPE_LZX             (0x0003)\n#define cfheadPREV_CABINET             (0x0001)\n#define cfheadNEXT_CABINET             (0x0002)\n#define cfheadRESERVE_PRESENT          (0x0004)\n#define cffileCONTINUED_FROM_PREV      (0xFFFD)\n#define cffileCONTINUED_TO_NEXT        (0xFFFE)\n#define cffileCONTINUED_PREV_AND_NEXT  (0xFFFF)\n\n/* CAB data blocks are <= 32768 bytes in uncompressed form. Uncompressed\n * blocks have zero growth. MSZIP guarantees that it won't grow above\n * uncompressed size by more than 12 bytes. LZX guarantees it won't grow\n * more than 6144 bytes. Quantum has no documentation, but the largest\n * block seen in the wild is 337 bytes above uncompressed size.\n */\n#define CAB_BLOCKMAX (32768)\n#define CAB_INPUTMAX (CAB_BLOCKMAX+6144)\n\n/* input buffer needs to be CAB_INPUTMAX + 1 byte to allow for max-sized block\n * plus 1 trailer byte added by cabd_sys_read_block() for Quantum alignment.\n *\n * When MSCABD_PARAM_SALVAGE is set, block size is not checked so can be\n * up to 65535 bytes, so max input buffer size needed is 65535 + 1\n */\n#define CAB_INPUTBUF (65535 + 1)\n\n/* There are no more than 65535 data blocks per folder, so a folder cannot\n * be more than 32768*65535 bytes in length. As files cannot span more than\n * one folder, this is also their max offset, length and offset+length limit.\n */\n#define CAB_FOLDERMAX (65535)\n#define CAB_LENGTHMAX (CAB_BLOCKMAX * CAB_FOLDERMAX)\n\n/* CAB compression definitions */\n\nstruct mscab_compressor_p {\n  struct mscab_compressor base;\n  struct mspack_system *system;\n  /* todo */\n};\n\n/* CAB decompression definitions */\n\nstruct mscabd_decompress_state {\n  struct mscabd_folder_p *folder;    /* current folder we're extracting from */\n  struct mscabd_folder_data *data;   /* current folder split we're in        */\n  unsigned int offset;               /* uncompressed offset within folder    */\n  unsigned int block;                /* which block are we decompressing?    */\n  off_t outlen;                      /* cumulative sum of block output sizes */\n  struct mspack_system sys;          /* special I/O code for decompressor    */\n  int comp_type;                     /* type of compression used by folder   */\n  int (*decompress)(void *, off_t);  /* decompressor code                    */\n  void *state;                       /* decompressor state                   */\n  struct mscabd_cabinet_p *incab;    /* cabinet where input data comes from  */\n  struct mspack_file *infh;          /* input file handle                    */\n  struct mspack_file *outfh;         /* output file handle                   */\n  unsigned char *i_ptr, *i_end;      /* input data consumed, end             */\n  unsigned char input[CAB_INPUTBUF]; /* one input block of data              */\n};\n\nstruct mscab_decompressor_p {\n  struct mscab_decompressor base;\n  struct mscabd_decompress_state *d;\n  struct mspack_system *system;\n  int param[4]; /* !!! MATCH THIS TO NUM OF PARAMS IN MSPACK.H !!! */\n  int error, read_error;\n};\n\nstruct mscabd_cabinet_p {\n  struct mscabd_cabinet base;\n  off_t blocks_off;                  /* offset to data blocks                */\n  int block_resv;                    /* reserved space in data blocks        */\n};\n\n/* there is one of these for every cabinet a folder spans */\nstruct mscabd_folder_data {\n  struct mscabd_folder_data *next;\n  struct mscabd_cabinet_p *cab;      /* cabinet file of this folder span     */\n  off_t offset;                      /* cabinet offset of first datablock    */\n};\n\nstruct mscabd_folder_p {\n  struct mscabd_folder base;\n  struct mscabd_folder_data data;    /* where are the data blocks?           */\n  struct mscabd_file *merge_prev;    /* first file needing backwards merge   */\n  struct mscabd_file *merge_next;    /* first file needing forwards merge    */\n};\n\n#endif\n"], "filenames": ["libmspack/ChangeLog", "libmspack/mspack/cab.h"], "buggy_code_start_loc": [0, 2], "buggy_code_end_loc": [0, 105], "fixing_code_start_loc": [1, 2], "fixing_code_end_loc": [9, 113], "type": "CWE-787", "message": "In mspack/cab.h in libmspack before 0.8alpha and cabextract before 1.8, the CAB block input buffer is one byte too small for the maximal Quantum block, leading to an out-of-bounds write.", "other": {"cve": {"id": "CVE-2018-18584", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-23T02:29:00.263", "lastModified": "2022-10-25T16:49:11.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In mspack/cab.h in libmspack before 0.8alpha and cabextract before 1.8, the CAB block input buffer is one byte too small for the maximal Quantum block, leading to an out-of-bounds write."}, {"lang": "es", "value": "En mspack/cab.h en libmspack en versiones anteriores a la 0.8alpha y cabextract en versiones anteriores a la 1.8, el b\u00fafer de entrada de bloques CAB es un byte m\u00e1s peque\u00f1o para el bloque Quantum m\u00e1ximo, lo que conduce a una escritura fuera de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cabextract_project:cabextract:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8", "matchCriteriaId": "7576D674-BC7C-42B0-BC4F-1049B9930750"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.3:alpha:*:*:*:*:*:*", "matchCriteriaId": "05A94589-19EF-47D7-A51F-62E378FA4F94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.4:alpha:*:*:*:*:*:*", "matchCriteriaId": "ABA54273-8C03-4244-83FF-19119BCE6D13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.5:alpha:*:*:*:*:*:*", "matchCriteriaId": "986DA387-2AD7-4B4B-9153-FAAC30954623"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.6:alpha:*:*:*:*:*:*", "matchCriteriaId": "7A82AF14-B94A-40D7-8571-6C52B18FE3DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.7:alpha:*:*:*:*:*:*", "matchCriteriaId": "05D4F4D6-EE6D-4D44-99C0-57CDC6C200E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.7.1:alpha:*:*:*:*:*:*", "matchCriteriaId": "51B46DFD-8EC4-4998-AC7B-B7975E9A79B9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:ltss:*:*:*", "matchCriteriaId": "B12243B2-D726-404C-ABFF-F1AB51BA1783"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:ga:*:*:ltss:*:*:*", "matchCriteriaId": "3DC6D86E-8C71-4836-9F7C-7416E9250C42"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:sp1:*:*:ltss:*:*:*", "matchCriteriaId": "0651347C-AE16-4155-98EF-A0A2C63A37A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "32C12523-2500-44D0-97EE-E740BD3E61B3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starwindsoftware:starwind_virtual_san:-:*:*:*:*:vsphere:*:*", "matchCriteriaId": "B649CB6C-394E-4F87-BB60-CB2C7825AA6D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2049", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/911640", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/kyz/libmspack/commit/40ef1b4093d77ad3a5cfcee1f5cb6108b3a3bcc2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-20", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3814-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3814-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3814-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.cabextract.org.uk/#changes", "source": "cve@mitre.org", "tags": ["Product", "Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2018/10/22/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.starwindsoftware.com/security/sw-20181213-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kyz/libmspack/commit/40ef1b4093d77ad3a5cfcee1f5cb6108b3a3bcc2"}}