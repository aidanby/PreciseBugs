{"buggy_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/* Standard includes. */\r\n#include <stdint.h>\r\n#include <string.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n/* FreeRTOS includes. */\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n#include \"stream_buffer.h\"\r\n\r\n#if ( configUSE_TASK_NOTIFICATIONS != 1 )\r\n    #error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c\r\n#endif\r\n\r\n/* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified\r\n * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\r\n * for the header files above, but not in this file, in order to generate the\r\n * correct privileged Vs unprivileged linkage and placement. */\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\r\n\r\n/* If the user has not provided application specific Rx notification macros,\r\n * or #defined the notification macros away, them provide default implementations\r\n * that uses task notifications. */\r\n/*lint -save -e9026 Function like macros allowed and needed here so they can be overridden. */\r\n#ifndef sbRECEIVE_COMPLETED\r\n    #define sbRECEIVE_COMPLETED( pxStreamBuffer )                         \\\r\n    vTaskSuspendAll();                                                    \\\r\n    {                                                                     \\\r\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )              \\\r\n        {                                                                 \\\r\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, \\\r\n                                  ( uint32_t ) 0,                         \\\r\n                                  eNoAction );                            \\\r\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                \\\r\n        }                                                                 \\\r\n    }                                                                     \\\r\n    ( void ) xTaskResumeAll();\r\n#endif /* sbRECEIVE_COMPLETED */\r\n\r\n#ifndef sbRECEIVE_COMPLETED_FROM_ISR\r\n    #define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                            \\\r\n                                          pxHigherPriorityTaskWoken )                \\\r\n    {                                                                                \\\r\n        UBaseType_t uxSavedInterruptStatus;                                          \\\r\n                                                                                     \\\r\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();  \\\r\n        {                                                                            \\\r\n            if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )                     \\\r\n            {                                                                        \\\r\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, \\\r\n                                             ( uint32_t ) 0,                         \\\r\n                                             eNoAction,                              \\\r\n                                             pxHigherPriorityTaskWoken );            \\\r\n                ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                       \\\r\n            }                                                                        \\\r\n        }                                                                            \\\r\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                 \\\r\n    }\r\n#endif /* sbRECEIVE_COMPLETED_FROM_ISR */\r\n\r\n/* If the user has not provided an application specific Tx notification macro,\r\n * or #defined the notification macro away, them provide a default implementation\r\n * that uses task notifications. */\r\n#ifndef sbSEND_COMPLETED\r\n    #define sbSEND_COMPLETED( pxStreamBuffer )                               \\\r\n    vTaskSuspendAll();                                                       \\\r\n    {                                                                        \\\r\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )              \\\r\n        {                                                                    \\\r\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\r\n                                  ( uint32_t ) 0,                            \\\r\n                                  eNoAction );                               \\\r\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                \\\r\n        }                                                                    \\\r\n    }                                                                        \\\r\n    ( void ) xTaskResumeAll();\r\n#endif /* sbSEND_COMPLETED */\r\n\r\n#ifndef sbSEND_COMPLETE_FROM_ISR\r\n    #define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \\\r\n    {                                                                                   \\\r\n        UBaseType_t uxSavedInterruptStatus;                                             \\\r\n                                                                                        \\\r\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\r\n        {                                                                               \\\r\n            if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \\\r\n            {                                                                           \\\r\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\r\n                                             ( uint32_t ) 0,                            \\\r\n                                             eNoAction,                                 \\\r\n                                             pxHigherPriorityTaskWoken );               \\\r\n                ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \\\r\n            }                                                                           \\\r\n        }                                                                               \\\r\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\r\n    }\r\n#endif /* sbSEND_COMPLETE_FROM_ISR */\r\n/*lint -restore (9026) */\r\n\r\n/* The number of bytes used to hold the length of a message in the buffer. */\r\n#define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\r\n\r\n/* Bits stored in the ucFlags field of the stream buffer. */\r\n#define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */\r\n#define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* Structure that hold state information on the buffer. */\r\ntypedef struct StreamBufferDef_t                 /*lint !e9058 Style convention uses tag. */\r\n{\r\n    volatile size_t xTail;                       /* Index to the next item to read within the buffer. */\r\n    volatile size_t xHead;                       /* Index to the next item to write within the buffer. */\r\n    size_t xLength;                              /* The length of the buffer pointed to by pucBuffer. */\r\n    size_t xTriggerLevelBytes;                   /* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */\r\n    volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */\r\n    volatile TaskHandle_t xTaskWaitingToSend;    /* Holds the handle of a task waiting to send data to a message buffer that is full. */\r\n    uint8_t * pucBuffer;                         /* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */\r\n    uint8_t ucFlags;\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxStreamBufferNumber; /* Used for tracing purposes. */\r\n    #endif\r\n} StreamBuffer_t;\r\n\r\n/*\r\n * The number of bytes available to be read from the buffer.\r\n */\r\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Add xCount bytes from pucData into the pxStreamBuffer message buffer.\r\n * Returns the number of bytes written, which will either equal xCount in the\r\n * success case, or 0 if there was not enough space in the buffer (in which case\r\n * no data is written into the buffer).\r\n */\r\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                     const uint8_t * pucData,\r\n                                     size_t xCount ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * If the stream buffer is being used as a message buffer, then reads an entire\r\n * message out of the buffer.  If the stream buffer is being used as a stream\r\n * buffer then read as many bytes as possible from the buffer.\r\n * prvReadBytesFromBuffer() is called to actually extract the bytes from the\r\n * buffer's data storage area.\r\n */\r\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                        void * pvRxData,\r\n                                        size_t xBufferLengthBytes,\r\n                                        size_t xBytesAvailable,\r\n                                        size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * If the stream buffer is being used as a message buffer, then writes an entire\r\n * message to the buffer.  If the stream buffer is being used as a stream\r\n * buffer then write as many bytes as possible to the buffer.\r\n * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's\r\n * data storage area.\r\n */\r\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                       const void * pvTxData,\r\n                                       size_t xDataLengthBytes,\r\n                                       size_t xSpace,\r\n                                       size_t xRequiredSpace ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them\r\n * to pucData.\r\n */\r\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                      uint8_t * pucData,\r\n                                      size_t xMaxCount,\r\n                                      size_t xBytesAvailable ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to\r\n * initialise the members of the newly created stream buffer structure.\r\n */\r\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                          uint8_t * const pucBuffer,\r\n                                          size_t xBufferSizeBytes,\r\n                                          size_t xTriggerLevelBytes,\r\n                                          uint8_t ucFlags ) PRIVILEGED_FUNCTION;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n\r\n    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\r\n                                                     size_t xTriggerLevelBytes,\r\n                                                     BaseType_t xIsMessageBuffer )\r\n    {\r\n        uint8_t * pucAllocatedMemory;\r\n        uint8_t ucFlags;\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        if( xIsMessageBuffer == pdTRUE )\r\n        {\r\n            /* Is a message buffer but not statically allocated. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\r\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n        }\r\n        else\r\n        {\r\n            /* Not a message buffer and not statically allocated. */\r\n            ucFlags = 0;\r\n            configASSERT( xBufferSizeBytes > 0 );\r\n        }\r\n\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\r\n         * Both are allocated in a single call to pvPortMalloc().  The\r\n         * StreamBuffer_t structure is placed at the start of the allocated memory\r\n         * and the buffer follows immediately after.  The requested size is\r\n         * incremented so the free space is returned as the user would expect -\r\n         * this is a quirk of the implementation that means otherwise the free\r\n         * space would be reported as one byte smaller than would be logically\r\n         * expected. */\r\n        xBufferSizeBytes++;\r\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\r\n\r\n        if( pucAllocatedMemory != NULL )\r\n        {\r\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\r\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\r\n        }\r\n        else\r\n        {\r\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\r\n        }\r\n\r\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\r\n    }\r\n\r\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n\r\n    StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,\r\n                                                           size_t xTriggerLevelBytes,\r\n                                                           BaseType_t xIsMessageBuffer,\r\n                                                           uint8_t * const pucStreamBufferStorageArea,\r\n                                                           StaticStreamBuffer_t * const pxStaticStreamBuffer )\r\n    {\r\n        StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */\r\n        StreamBufferHandle_t xReturn;\r\n        uint8_t ucFlags;\r\n\r\n        configASSERT( pucStreamBufferStorageArea );\r\n        configASSERT( pxStaticStreamBuffer );\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        if( xIsMessageBuffer != pdFALSE )\r\n        {\r\n            /* Statically allocated message buffer. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n        }\r\n        else\r\n        {\r\n            /* Statically allocated stream buffer. */\r\n            ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n        }\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n\r\n        #if ( configASSERT_DEFINED == 1 )\r\n            {\r\n                /* Sanity check that the size of the structure used to declare a\r\n                 * variable of type StaticStreamBuffer_t equals the size of the real\r\n                 * message buffer structure. */\r\n                volatile size_t xSize = sizeof( StaticStreamBuffer_t );\r\n                configASSERT( xSize == sizeof( StreamBuffer_t ) );\r\n            } /*lint !e529 xSize is referenced is configASSERT() is defined. */\r\n        #endif /* configASSERT_DEFINED */\r\n\r\n        if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )\r\n        {\r\n            prvInitialiseNewStreamBuffer( pxStreamBuffer,\r\n                                          pucStreamBufferStorageArea,\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            /* Remember this was statically allocated in case it is ever deleted\r\n             * again. */\r\n            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n\r\n            traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );\r\n\r\n            xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */\r\n        }\r\n        else\r\n        {\r\n            xReturn = NULL;\r\n            traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    traceSTREAM_BUFFER_DELETE( xStreamBuffer );\r\n\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )\r\n    {\r\n        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n            {\r\n                /* Both the structure and the buffer were allocated using a single call\r\n                * to pvPortMalloc(), hence only one call to vPortFree() is required. */\r\n                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */\r\n            }\r\n        #else\r\n            {\r\n                /* Should not be possible to get here, ucFlags must be corrupt.\r\n                 * Force an assert. */\r\n                configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );\r\n            }\r\n        #endif\r\n    }\r\n    else\r\n    {\r\n        /* The structure and buffer were not allocated dynamically and cannot be\r\n         * freed - just scrub the structure so future use will assert. */\r\n        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn = pdFAIL;\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxStreamBufferNumber;\r\n    #endif\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        {\r\n            /* Store the stream buffer number so it can be restored after the\r\n             * reset. */\r\n            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;\r\n        }\r\n    #endif\r\n\r\n    /* Can only reset a message buffer if there are no tasks blocked on it. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )\r\n        {\r\n            if( pxStreamBuffer->xTaskWaitingToSend == NULL )\r\n            {\r\n                prvInitialiseNewStreamBuffer( pxStreamBuffer,\r\n                                              pxStreamBuffer->pucBuffer,\r\n                                              pxStreamBuffer->xLength,\r\n                                              pxStreamBuffer->xTriggerLevelBytes,\r\n                                              pxStreamBuffer->ucFlags );\r\n                xReturn = pdPASS;\r\n\r\n                #if ( configUSE_TRACE_FACILITY == 1 )\r\n                    {\r\n                        pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\r\n                    }\r\n                #endif\r\n\r\n                traceSTREAM_BUFFER_RESET( xStreamBuffer );\r\n            }\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,\r\n                                         size_t xTriggerLevel )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* It is not valid for the trigger level to be 0. */\r\n    if( xTriggerLevel == ( size_t ) 0 )\r\n    {\r\n        xTriggerLevel = ( size_t ) 1;\r\n    }\r\n\r\n    /* The trigger level is the number of bytes that must be in the stream\r\n     * buffer before a task that is waiting for data is unblocked. */\r\n    if( xTriggerLevel <= pxStreamBuffer->xLength )\r\n    {\r\n        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;\r\n        xReturn = pdPASS;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xSpace;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;\r\n    xSpace -= pxStreamBuffer->xHead;\r\n    xSpace -= ( size_t ) 1;\r\n\r\n    if( xSpace >= pxStreamBuffer->xLength )\r\n    {\r\n        xSpace -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xSpace;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    xReturn = prvBytesInBuffer( pxStreamBuffer );\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\r\n                          const void * pvTxData,\r\n                          size_t xDataLengthBytes,\r\n                          TickType_t xTicksToWait )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xSpace = 0;\r\n    size_t xRequiredSpace = xDataLengthBytes;\r\n    TimeOut_t xTimeOut;\r\n\r\n    /* The maximum amount of space a stream buffer will ever report is its length\r\n     * minus 1. */\r\n    const size_t xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;\r\n\r\n    configASSERT( pvTxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This send function is used to write to both message buffers and stream\r\n     * buffers.  If this is a message buffer then the space needed must be\r\n     * increased by the amount of bytes needed to store the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n\r\n        /* Overflow? */\r\n        configASSERT( xRequiredSpace > xDataLengthBytes );\r\n\r\n        /* If this is a message buffer then it must be possible to write the\r\n         * whole message. */\r\n        if( xRequiredSpace > xMaxReportedSpace )\r\n        {\r\n            /* The message would not fit even if the entire buffer was empty,\r\n             * so don't wait for space. */\r\n            xTicksToWait = ( TickType_t ) 0;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* If this is a stream buffer then it is acceptable to write only part\r\n         * of the message to the buffer.  Cap the length to the total length of\r\n         * the buffer. */\r\n        if( xRequiredSpace > xMaxReportedSpace )\r\n        {\r\n            xRequiredSpace = xMaxReportedSpace;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n\r\n    if( xTicksToWait != ( TickType_t ) 0 )\r\n    {\r\n        vTaskSetTimeOutState( &xTimeOut );\r\n\r\n        do\r\n        {\r\n            /* Wait until the required number of bytes are free in the message\r\n             * buffer. */\r\n            taskENTER_CRITICAL();\r\n            {\r\n                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n\r\n                if( xSpace < xRequiredSpace )\r\n                {\r\n                    /* Clear notification state as going to wait for space. */\r\n                    ( void ) xTaskNotifyStateClear( NULL );\r\n\r\n                    /* Should only be one writer. */\r\n                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );\r\n                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();\r\n                }\r\n                else\r\n                {\r\n                    taskEXIT_CRITICAL();\r\n                    break;\r\n                }\r\n            }\r\n            taskEXIT_CRITICAL();\r\n\r\n            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );\r\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\r\n            pxStreamBuffer->xTaskWaitingToSend = NULL;\r\n        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    if( xSpace == ( size_t ) 0 )\r\n    {\r\n        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\r\n\r\n    if( xReturn > ( size_t ) 0 )\r\n    {\r\n        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );\r\n\r\n        /* Was a task waiting for the data? */\r\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\r\n        {\r\n            sbSEND_COMPLETED( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                 const void * pvTxData,\r\n                                 size_t xDataLengthBytes,\r\n                                 BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xSpace;\r\n    size_t xRequiredSpace = xDataLengthBytes;\r\n\r\n    configASSERT( pvTxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This send function is used to write to both message buffers and stream\r\n     * buffers.  If this is a message buffer then the space needed must be\r\n     * increased by the amount of bytes needed to store the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\r\n\r\n    if( xReturn > ( size_t ) 0 )\r\n    {\r\n        /* Was a task waiting for the data? */\r\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\r\n        {\r\n            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                       const void * pvTxData,\r\n                                       size_t xDataLengthBytes,\r\n                                       size_t xSpace,\r\n                                       size_t xRequiredSpace )\r\n{\r\n    BaseType_t xShouldWrite;\r\n    size_t xReturn;\r\n\r\n    if( xSpace == ( size_t ) 0 )\r\n    {\r\n        /* Doesn't matter if this is a stream buffer or a message buffer, there\r\n         * is no space to write. */\r\n        xShouldWrite = pdFALSE;\r\n    }\r\n    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )\r\n    {\r\n        /* This is a stream buffer, as opposed to a message buffer, so writing a\r\n         * stream of bytes rather than discrete messages.  Write as many bytes as\r\n         * possible. */\r\n        xShouldWrite = pdTRUE;\r\n        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );\r\n    }\r\n    else if( xSpace >= xRequiredSpace )\r\n    {\r\n        /* This is a message buffer, as opposed to a stream buffer, and there\r\n         * is enough space to write both the message length and the message itself\r\n         * into the buffer.  Start by writing the length of the data, the data\r\n         * itself will be written later in this function. */\r\n        xShouldWrite = pdTRUE;\r\n        ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n    }\r\n    else\r\n    {\r\n        /* There is space available, but not enough space. */\r\n        xShouldWrite = pdFALSE;\r\n    }\r\n\r\n    if( xShouldWrite != pdFALSE )\r\n    {\r\n        /* Writes the data itself. */\r\n        xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */\r\n    }\r\n    else\r\n    {\r\n        xReturn = 0;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\r\n                             void * pvRxData,\r\n                             size_t xBufferLengthBytes,\r\n                             TickType_t xTicksToWait )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\r\n\r\n    configASSERT( pvRxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This receive function is used by both message buffers, which store\r\n     * discrete messages, and stream buffers, which store a continuous stream of\r\n     * bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    if( xTicksToWait != ( TickType_t ) 0 )\r\n    {\r\n        /* Checking if there is data and clearing the notification state must be\r\n         * performed atomically. */\r\n        taskENTER_CRITICAL();\r\n        {\r\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n            /* If this function was invoked by a message buffer read then\r\n             * xBytesToStoreMessageLength holds the number of bytes used to hold\r\n             * the length of the next discrete message.  If this function was\r\n             * invoked by a stream buffer read then xBytesToStoreMessageLength will\r\n             * be 0. */\r\n            if( xBytesAvailable <= xBytesToStoreMessageLength )\r\n            {\r\n                /* Clear notification state as going to wait for data. */\r\n                ( void ) xTaskNotifyStateClear( NULL );\r\n\r\n                /* Should only be one reader. */\r\n                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );\r\n                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        if( xBytesAvailable <= xBytesToStoreMessageLength )\r\n        {\r\n            /* Wait for data to be available. */\r\n            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );\r\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\r\n            pxStreamBuffer->xTaskWaitingToReceive = NULL;\r\n\r\n            /* Recheck the data available after blocking. */\r\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n    }\r\n\r\n    /* Whether receiving a discrete message (where xBytesToStoreMessageLength\r\n     * holds the number of bytes used to store the message length) or a stream of\r\n     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes\r\n     * available must be greater than xBytesToStoreMessageLength to be able to\r\n     * read bytes from the buffer. */\r\n    if( xBytesAvailable > xBytesToStoreMessageLength )\r\n    {\r\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\r\n\r\n        /* Was a task waiting for space in the buffer? */\r\n        if( xReceivedLength != ( size_t ) 0 )\r\n        {\r\n            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );\r\n            sbRECEIVE_COMPLETED( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xBytesAvailable, xOriginalTail;\r\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* Ensure the stream buffer is being used as a message buffer. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )\r\n        {\r\n            /* The number of bytes available is greater than the number of bytes\r\n             * required to hold the length of the next message, so another message\r\n             * is available.  Return its length without removing the length bytes\r\n             * from the buffer.  A copy of the tail is stored so the buffer can be\r\n             * returned to its prior state as the message is not actually being\r\n             * removed from the buffer. */\r\n            xOriginalTail = pxStreamBuffer->xTail;\r\n            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );\r\n            xReturn = ( size_t ) xTempReturn;\r\n            pxStreamBuffer->xTail = xOriginalTail;\r\n        }\r\n        else\r\n        {\r\n            /* The minimum amount of bytes in a message buffer is\r\n             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is\r\n             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid\r\n             * value is 0. */\r\n            configASSERT( xBytesAvailable == 0 );\r\n            xReturn = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        xReturn = 0;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                    void * pvRxData,\r\n                                    size_t xBufferLengthBytes,\r\n                                    BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\r\n\r\n    configASSERT( pvRxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This receive function is used by both message buffers, which store\r\n     * discrete messages, and stream buffers, which store a continuous stream of\r\n     * bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n    /* Whether receiving a discrete message (where xBytesToStoreMessageLength\r\n     * holds the number of bytes used to store the message length) or a stream of\r\n     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes\r\n     * available must be greater than xBytesToStoreMessageLength to be able to\r\n     * read bytes from the buffer. */\r\n    if( xBytesAvailable > xBytesToStoreMessageLength )\r\n    {\r\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\r\n\r\n        /* Was a task waiting for space in the buffer? */\r\n        if( xReceivedLength != ( size_t ) 0 )\r\n        {\r\n            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                        void * pvRxData,\r\n                                        size_t xBufferLengthBytes,\r\n                                        size_t xBytesAvailable,\r\n                                        size_t xBytesToStoreMessageLength )\r\n{\r\n    size_t xOriginalTail, xReceivedLength, xNextMessageLength;\r\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;\r\n\r\n    if( xBytesToStoreMessageLength != ( size_t ) 0 )\r\n    {\r\n        /* A discrete message is being received.  First receive the length\r\n         * of the message.  A copy of the tail is stored so the buffer can be\r\n         * returned to its prior state if the length of the message is too\r\n         * large for the provided buffer. */\r\n        xOriginalTail = pxStreamBuffer->xTail;\r\n        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );\r\n        xNextMessageLength = ( size_t ) xTempNextMessageLength;\r\n\r\n        /* Reduce the number of bytes available by the number of bytes just\r\n         * read out. */\r\n        xBytesAvailable -= xBytesToStoreMessageLength;\r\n\r\n        /* Check there is enough space in the buffer provided by the\r\n         * user. */\r\n        if( xNextMessageLength > xBufferLengthBytes )\r\n        {\r\n            /* The user has provided insufficient space to read the message\r\n             * so return the buffer to its previous state (so the length of\r\n             * the message is in the buffer again). */\r\n            pxStreamBuffer->xTail = xOriginalTail;\r\n            xNextMessageLength = 0;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* A stream of bytes is being received (as opposed to a discrete\r\n         * message), so read as many bytes as possible. */\r\n        xNextMessageLength = xBufferLengthBytes;\r\n    }\r\n\r\n    /* Read the actual data. */\r\n    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    size_t xTail;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* True if no bytes are available. */\r\n    xTail = pxStreamBuffer->xTail;\r\n\r\n    if( pxStreamBuffer->xHead == xTail )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    BaseType_t xReturn;\r\n    size_t xBytesToStoreMessageLength;\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This generic version of the receive function is used by both message\r\n     * buffers, which store discrete messages, and stream buffers, which store a\r\n     * continuous stream of bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    /* True if the available space equals zero. */\r\n    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                              BaseType_t * pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )\r\n        {\r\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,\r\n                                         ( uint32_t ) 0,\r\n                                         eNoAction,\r\n                                         pxHigherPriorityTaskWoken );\r\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                                 BaseType_t * pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )\r\n        {\r\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,\r\n                                         ( uint32_t ) 0,\r\n                                         eNoAction,\r\n                                         pxHigherPriorityTaskWoken );\r\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                     const uint8_t * pucData,\r\n                                     size_t xCount )\r\n{\r\n    size_t xNextHead, xFirstLength;\r\n\r\n    configASSERT( xCount > ( size_t ) 0 );\r\n\r\n    xNextHead = pxStreamBuffer->xHead;\r\n\r\n    /* Calculate the number of bytes that can be added in the first write -\r\n     * which may be less than the total number of bytes that need to be added if\r\n     * the buffer will wrap back to the beginning. */\r\n    xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );\r\n\r\n    /* Write as many bytes as can be written in the first write. */\r\n    configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );\r\n    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n\r\n    /* If the number of bytes written was less than the number that could be\r\n     * written in the first write... */\r\n    if( xCount > xFirstLength )\r\n    {\r\n        /* ...then write the remaining bytes to the start of the buffer. */\r\n        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );\r\n        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xNextHead += xCount;\r\n\r\n    if( xNextHead >= pxStreamBuffer->xLength )\r\n    {\r\n        xNextHead -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    pxStreamBuffer->xHead = xNextHead;\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                      uint8_t * pucData,\r\n                                      size_t xMaxCount,\r\n                                      size_t xBytesAvailable )\r\n{\r\n    size_t xCount, xFirstLength, xNextTail;\r\n\r\n    /* Use the minimum of the wanted bytes and the available bytes. */\r\n    xCount = configMIN( xBytesAvailable, xMaxCount );\r\n\r\n    if( xCount > ( size_t ) 0 )\r\n    {\r\n        xNextTail = pxStreamBuffer->xTail;\r\n\r\n        /* Calculate the number of bytes that can be read - which may be\r\n         * less than the number wanted if the data wraps around to the start of\r\n         * the buffer. */\r\n        xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );\r\n\r\n        /* Obtain the number of bytes it is possible to obtain in the first\r\n         * read.  Asserts check bounds of read and write. */\r\n        configASSERT( xFirstLength <= xMaxCount );\r\n        configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );\r\n        ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n\r\n        /* If the total number of wanted bytes is greater than the number\r\n         * that could be read in the first read... */\r\n        if( xCount > xFirstLength )\r\n        {\r\n            /*...then read the remaining bytes from the start of the buffer. */\r\n            configASSERT( xCount <= xMaxCount );\r\n            ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        /* Move the tail pointer to effectively remove the data read from\r\n         * the buffer. */\r\n        xNextTail += xCount;\r\n\r\n        if( xNextTail >= pxStreamBuffer->xLength )\r\n        {\r\n            xNextTail -= pxStreamBuffer->xLength;\r\n        }\r\n\r\n        pxStreamBuffer->xTail = xNextTail;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )\r\n{\r\n/* Returns the distance between xTail and xHead. */\r\n    size_t xCount;\r\n\r\n    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;\r\n    xCount -= pxStreamBuffer->xTail;\r\n\r\n    if( xCount >= pxStreamBuffer->xLength )\r\n    {\r\n        xCount -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                          uint8_t * const pucBuffer,\r\n                                          size_t xBufferSizeBytes,\r\n                                          size_t xTriggerLevelBytes,\r\n                                          uint8_t ucFlags )\r\n{\r\n    /* Assert here is deliberately writing to the entire buffer to ensure it can\r\n     * be written to without generating exceptions, and is setting the buffer to a\r\n     * known value to assist in development/debugging. */\r\n    #if ( configASSERT_DEFINED == 1 )\r\n        {\r\n            /* The value written just has to be identifiable when looking at the\r\n             * memory.  Don't use 0xA5 as that is the stack fill value and could\r\n             * result in confusion as to what is actually being observed. */\r\n            const BaseType_t xWriteValue = 0x55;\r\n            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );\r\n        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */\r\n    #endif\r\n\r\n    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */\r\n    pxStreamBuffer->pucBuffer = pucBuffer;\r\n    pxStreamBuffer->xLength = xBufferSizeBytes;\r\n    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;\r\n    pxStreamBuffer->ucFlags = ucFlags;\r\n}\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )\r\n    {\r\n        return xStreamBuffer->uxStreamBufferNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,\r\n                                             UBaseType_t uxStreamBufferNumber )\r\n    {\r\n        xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )\r\n    {\r\n        return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n"], "fixing_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/* Standard includes. */\r\n#include <stdint.h>\r\n#include <string.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n/* FreeRTOS includes. */\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n#include \"stream_buffer.h\"\r\n\r\n#if ( configUSE_TASK_NOTIFICATIONS != 1 )\r\n    #error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c\r\n#endif\r\n\r\n/* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified\r\n * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\r\n * for the header files above, but not in this file, in order to generate the\r\n * correct privileged Vs unprivileged linkage and placement. */\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\r\n\r\n/* If the user has not provided application specific Rx notification macros,\r\n * or #defined the notification macros away, them provide default implementations\r\n * that uses task notifications. */\r\n/*lint -save -e9026 Function like macros allowed and needed here so they can be overridden. */\r\n#ifndef sbRECEIVE_COMPLETED\r\n    #define sbRECEIVE_COMPLETED( pxStreamBuffer )                         \\\r\n    vTaskSuspendAll();                                                    \\\r\n    {                                                                     \\\r\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )              \\\r\n        {                                                                 \\\r\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, \\\r\n                                  ( uint32_t ) 0,                         \\\r\n                                  eNoAction );                            \\\r\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                \\\r\n        }                                                                 \\\r\n    }                                                                     \\\r\n    ( void ) xTaskResumeAll();\r\n#endif /* sbRECEIVE_COMPLETED */\r\n\r\n#ifndef sbRECEIVE_COMPLETED_FROM_ISR\r\n    #define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                            \\\r\n                                          pxHigherPriorityTaskWoken )                \\\r\n    {                                                                                \\\r\n        UBaseType_t uxSavedInterruptStatus;                                          \\\r\n                                                                                     \\\r\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();  \\\r\n        {                                                                            \\\r\n            if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )                     \\\r\n            {                                                                        \\\r\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, \\\r\n                                             ( uint32_t ) 0,                         \\\r\n                                             eNoAction,                              \\\r\n                                             pxHigherPriorityTaskWoken );            \\\r\n                ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                       \\\r\n            }                                                                        \\\r\n        }                                                                            \\\r\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                 \\\r\n    }\r\n#endif /* sbRECEIVE_COMPLETED_FROM_ISR */\r\n\r\n/* If the user has not provided an application specific Tx notification macro,\r\n * or #defined the notification macro away, them provide a default implementation\r\n * that uses task notifications. */\r\n#ifndef sbSEND_COMPLETED\r\n    #define sbSEND_COMPLETED( pxStreamBuffer )                               \\\r\n    vTaskSuspendAll();                                                       \\\r\n    {                                                                        \\\r\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )              \\\r\n        {                                                                    \\\r\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\r\n                                  ( uint32_t ) 0,                            \\\r\n                                  eNoAction );                               \\\r\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                \\\r\n        }                                                                    \\\r\n    }                                                                        \\\r\n    ( void ) xTaskResumeAll();\r\n#endif /* sbSEND_COMPLETED */\r\n\r\n#ifndef sbSEND_COMPLETE_FROM_ISR\r\n    #define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \\\r\n    {                                                                                   \\\r\n        UBaseType_t uxSavedInterruptStatus;                                             \\\r\n                                                                                        \\\r\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\r\n        {                                                                               \\\r\n            if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \\\r\n            {                                                                           \\\r\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\r\n                                             ( uint32_t ) 0,                            \\\r\n                                             eNoAction,                                 \\\r\n                                             pxHigherPriorityTaskWoken );               \\\r\n                ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \\\r\n            }                                                                           \\\r\n        }                                                                               \\\r\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\r\n    }\r\n#endif /* sbSEND_COMPLETE_FROM_ISR */\r\n/*lint -restore (9026) */\r\n\r\n/* The number of bytes used to hold the length of a message in the buffer. */\r\n#define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\r\n\r\n/* Bits stored in the ucFlags field of the stream buffer. */\r\n#define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */\r\n#define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* Structure that hold state information on the buffer. */\r\ntypedef struct StreamBufferDef_t                 /*lint !e9058 Style convention uses tag. */\r\n{\r\n    volatile size_t xTail;                       /* Index to the next item to read within the buffer. */\r\n    volatile size_t xHead;                       /* Index to the next item to write within the buffer. */\r\n    size_t xLength;                              /* The length of the buffer pointed to by pucBuffer. */\r\n    size_t xTriggerLevelBytes;                   /* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */\r\n    volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */\r\n    volatile TaskHandle_t xTaskWaitingToSend;    /* Holds the handle of a task waiting to send data to a message buffer that is full. */\r\n    uint8_t * pucBuffer;                         /* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */\r\n    uint8_t ucFlags;\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxStreamBufferNumber; /* Used for tracing purposes. */\r\n    #endif\r\n} StreamBuffer_t;\r\n\r\n/*\r\n * The number of bytes available to be read from the buffer.\r\n */\r\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Add xCount bytes from pucData into the pxStreamBuffer message buffer.\r\n * Returns the number of bytes written, which will either equal xCount in the\r\n * success case, or 0 if there was not enough space in the buffer (in which case\r\n * no data is written into the buffer).\r\n */\r\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                     const uint8_t * pucData,\r\n                                     size_t xCount ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * If the stream buffer is being used as a message buffer, then reads an entire\r\n * message out of the buffer.  If the stream buffer is being used as a stream\r\n * buffer then read as many bytes as possible from the buffer.\r\n * prvReadBytesFromBuffer() is called to actually extract the bytes from the\r\n * buffer's data storage area.\r\n */\r\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                        void * pvRxData,\r\n                                        size_t xBufferLengthBytes,\r\n                                        size_t xBytesAvailable,\r\n                                        size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * If the stream buffer is being used as a message buffer, then writes an entire\r\n * message to the buffer.  If the stream buffer is being used as a stream\r\n * buffer then write as many bytes as possible to the buffer.\r\n * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's\r\n * data storage area.\r\n */\r\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                       const void * pvTxData,\r\n                                       size_t xDataLengthBytes,\r\n                                       size_t xSpace,\r\n                                       size_t xRequiredSpace ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them\r\n * to pucData.\r\n */\r\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                      uint8_t * pucData,\r\n                                      size_t xMaxCount,\r\n                                      size_t xBytesAvailable ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to\r\n * initialise the members of the newly created stream buffer structure.\r\n */\r\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                          uint8_t * const pucBuffer,\r\n                                          size_t xBufferSizeBytes,\r\n                                          size_t xTriggerLevelBytes,\r\n                                          uint8_t ucFlags ) PRIVILEGED_FUNCTION;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n\r\n    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\r\n                                                     size_t xTriggerLevelBytes,\r\n                                                     BaseType_t xIsMessageBuffer )\r\n    {\r\n        uint8_t * pucAllocatedMemory;\r\n        uint8_t ucFlags;\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        if( xIsMessageBuffer == pdTRUE )\r\n        {\r\n            /* Is a message buffer but not statically allocated. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\r\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n        }\r\n        else\r\n        {\r\n            /* Not a message buffer and not statically allocated. */\r\n            ucFlags = 0;\r\n            configASSERT( xBufferSizeBytes > 0 );\r\n        }\r\n\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\r\n         * Both are allocated in a single call to pvPortMalloc().  The\r\n         * StreamBuffer_t structure is placed at the start of the allocated memory\r\n         * and the buffer follows immediately after.  The requested size is\r\n         * incremented so the free space is returned as the user would expect -\r\n         * this is a quirk of the implementation that means otherwise the free\r\n         * space would be reported as one byte smaller than would be logically\r\n         * expected. */\r\n        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )\r\n        {\r\n            xBufferSizeBytes++;\r\n            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\r\n        }\r\n        else\r\n        {\r\n            pucAllocatedMemory = NULL;\r\n        }\r\n        \r\n\r\n        if( pucAllocatedMemory != NULL )\r\n        {\r\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\r\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\r\n        }\r\n        else\r\n        {\r\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\r\n        }\r\n\r\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\r\n    }\r\n\r\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n\r\n    StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,\r\n                                                           size_t xTriggerLevelBytes,\r\n                                                           BaseType_t xIsMessageBuffer,\r\n                                                           uint8_t * const pucStreamBufferStorageArea,\r\n                                                           StaticStreamBuffer_t * const pxStaticStreamBuffer )\r\n    {\r\n        StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */\r\n        StreamBufferHandle_t xReturn;\r\n        uint8_t ucFlags;\r\n\r\n        configASSERT( pucStreamBufferStorageArea );\r\n        configASSERT( pxStaticStreamBuffer );\r\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\r\n\r\n        /* A trigger level of 0 would cause a waiting task to unblock even when\r\n         * the buffer was empty. */\r\n        if( xTriggerLevelBytes == ( size_t ) 0 )\r\n        {\r\n            xTriggerLevelBytes = ( size_t ) 1;\r\n        }\r\n\r\n        if( xIsMessageBuffer != pdFALSE )\r\n        {\r\n            /* Statically allocated message buffer. */\r\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n        }\r\n        else\r\n        {\r\n            /* Statically allocated stream buffer. */\r\n            ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n        }\r\n\r\n        /* In case the stream buffer is going to be used as a message buffer\r\n         * (that is, it will hold discrete messages with a little meta data that\r\n         * says how big the next message is) check the buffer will be large enough\r\n         * to hold at least one message. */\r\n        configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n\r\n        #if ( configASSERT_DEFINED == 1 )\r\n            {\r\n                /* Sanity check that the size of the structure used to declare a\r\n                 * variable of type StaticStreamBuffer_t equals the size of the real\r\n                 * message buffer structure. */\r\n                volatile size_t xSize = sizeof( StaticStreamBuffer_t );\r\n                configASSERT( xSize == sizeof( StreamBuffer_t ) );\r\n            } /*lint !e529 xSize is referenced is configASSERT() is defined. */\r\n        #endif /* configASSERT_DEFINED */\r\n\r\n        if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )\r\n        {\r\n            prvInitialiseNewStreamBuffer( pxStreamBuffer,\r\n                                          pucStreamBufferStorageArea,\r\n                                          xBufferSizeBytes,\r\n                                          xTriggerLevelBytes,\r\n                                          ucFlags );\r\n\r\n            /* Remember this was statically allocated in case it is ever deleted\r\n             * again. */\r\n            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;\r\n\r\n            traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );\r\n\r\n            xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */\r\n        }\r\n        else\r\n        {\r\n            xReturn = NULL;\r\n            traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    traceSTREAM_BUFFER_DELETE( xStreamBuffer );\r\n\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )\r\n    {\r\n        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n            {\r\n                /* Both the structure and the buffer were allocated using a single call\r\n                * to pvPortMalloc(), hence only one call to vPortFree() is required. */\r\n                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */\r\n            }\r\n        #else\r\n            {\r\n                /* Should not be possible to get here, ucFlags must be corrupt.\r\n                 * Force an assert. */\r\n                configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );\r\n            }\r\n        #endif\r\n    }\r\n    else\r\n    {\r\n        /* The structure and buffer were not allocated dynamically and cannot be\r\n         * freed - just scrub the structure so future use will assert. */\r\n        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn = pdFAIL;\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxStreamBufferNumber;\r\n    #endif\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        {\r\n            /* Store the stream buffer number so it can be restored after the\r\n             * reset. */\r\n            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;\r\n        }\r\n    #endif\r\n\r\n    /* Can only reset a message buffer if there are no tasks blocked on it. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )\r\n        {\r\n            if( pxStreamBuffer->xTaskWaitingToSend == NULL )\r\n            {\r\n                prvInitialiseNewStreamBuffer( pxStreamBuffer,\r\n                                              pxStreamBuffer->pucBuffer,\r\n                                              pxStreamBuffer->xLength,\r\n                                              pxStreamBuffer->xTriggerLevelBytes,\r\n                                              pxStreamBuffer->ucFlags );\r\n                xReturn = pdPASS;\r\n\r\n                #if ( configUSE_TRACE_FACILITY == 1 )\r\n                    {\r\n                        pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\r\n                    }\r\n                #endif\r\n\r\n                traceSTREAM_BUFFER_RESET( xStreamBuffer );\r\n            }\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,\r\n                                         size_t xTriggerLevel )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* It is not valid for the trigger level to be 0. */\r\n    if( xTriggerLevel == ( size_t ) 0 )\r\n    {\r\n        xTriggerLevel = ( size_t ) 1;\r\n    }\r\n\r\n    /* The trigger level is the number of bytes that must be in the stream\r\n     * buffer before a task that is waiting for data is unblocked. */\r\n    if( xTriggerLevel <= pxStreamBuffer->xLength )\r\n    {\r\n        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;\r\n        xReturn = pdPASS;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xSpace;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;\r\n    xSpace -= pxStreamBuffer->xHead;\r\n    xSpace -= ( size_t ) 1;\r\n\r\n    if( xSpace >= pxStreamBuffer->xLength )\r\n    {\r\n        xSpace -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xSpace;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    xReturn = prvBytesInBuffer( pxStreamBuffer );\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\r\n                          const void * pvTxData,\r\n                          size_t xDataLengthBytes,\r\n                          TickType_t xTicksToWait )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xSpace = 0;\r\n    size_t xRequiredSpace = xDataLengthBytes;\r\n    TimeOut_t xTimeOut;\r\n\r\n    /* The maximum amount of space a stream buffer will ever report is its length\r\n     * minus 1. */\r\n    const size_t xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;\r\n\r\n    configASSERT( pvTxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This send function is used to write to both message buffers and stream\r\n     * buffers.  If this is a message buffer then the space needed must be\r\n     * increased by the amount of bytes needed to store the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n\r\n        /* Overflow? */\r\n        configASSERT( xRequiredSpace > xDataLengthBytes );\r\n\r\n        /* If this is a message buffer then it must be possible to write the\r\n         * whole message. */\r\n        if( xRequiredSpace > xMaxReportedSpace )\r\n        {\r\n            /* The message would not fit even if the entire buffer was empty,\r\n             * so don't wait for space. */\r\n            xTicksToWait = ( TickType_t ) 0;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* If this is a stream buffer then it is acceptable to write only part\r\n         * of the message to the buffer.  Cap the length to the total length of\r\n         * the buffer. */\r\n        if( xRequiredSpace > xMaxReportedSpace )\r\n        {\r\n            xRequiredSpace = xMaxReportedSpace;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n\r\n    if( xTicksToWait != ( TickType_t ) 0 )\r\n    {\r\n        vTaskSetTimeOutState( &xTimeOut );\r\n\r\n        do\r\n        {\r\n            /* Wait until the required number of bytes are free in the message\r\n             * buffer. */\r\n            taskENTER_CRITICAL();\r\n            {\r\n                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n\r\n                if( xSpace < xRequiredSpace )\r\n                {\r\n                    /* Clear notification state as going to wait for space. */\r\n                    ( void ) xTaskNotifyStateClear( NULL );\r\n\r\n                    /* Should only be one writer. */\r\n                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );\r\n                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();\r\n                }\r\n                else\r\n                {\r\n                    taskEXIT_CRITICAL();\r\n                    break;\r\n                }\r\n            }\r\n            taskEXIT_CRITICAL();\r\n\r\n            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );\r\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\r\n            pxStreamBuffer->xTaskWaitingToSend = NULL;\r\n        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    if( xSpace == ( size_t ) 0 )\r\n    {\r\n        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\r\n\r\n    if( xReturn > ( size_t ) 0 )\r\n    {\r\n        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );\r\n\r\n        /* Was a task waiting for the data? */\r\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\r\n        {\r\n            sbSEND_COMPLETED( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                 const void * pvTxData,\r\n                                 size_t xDataLengthBytes,\r\n                                 BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xSpace;\r\n    size_t xRequiredSpace = xDataLengthBytes;\r\n\r\n    configASSERT( pvTxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This send function is used to write to both message buffers and stream\r\n     * buffers.  If this is a message buffer then the space needed must be\r\n     * increased by the amount of bytes needed to store the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\r\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\r\n\r\n    if( xReturn > ( size_t ) 0 )\r\n    {\r\n        /* Was a task waiting for the data? */\r\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\r\n        {\r\n            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                       const void * pvTxData,\r\n                                       size_t xDataLengthBytes,\r\n                                       size_t xSpace,\r\n                                       size_t xRequiredSpace )\r\n{\r\n    BaseType_t xShouldWrite;\r\n    size_t xReturn;\r\n\r\n    if( xSpace == ( size_t ) 0 )\r\n    {\r\n        /* Doesn't matter if this is a stream buffer or a message buffer, there\r\n         * is no space to write. */\r\n        xShouldWrite = pdFALSE;\r\n    }\r\n    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )\r\n    {\r\n        /* This is a stream buffer, as opposed to a message buffer, so writing a\r\n         * stream of bytes rather than discrete messages.  Write as many bytes as\r\n         * possible. */\r\n        xShouldWrite = pdTRUE;\r\n        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );\r\n    }\r\n    else if( xSpace >= xRequiredSpace )\r\n    {\r\n        /* This is a message buffer, as opposed to a stream buffer, and there\r\n         * is enough space to write both the message length and the message itself\r\n         * into the buffer.  Start by writing the length of the data, the data\r\n         * itself will be written later in this function. */\r\n        xShouldWrite = pdTRUE;\r\n        ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );\r\n    }\r\n    else\r\n    {\r\n        /* There is space available, but not enough space. */\r\n        xShouldWrite = pdFALSE;\r\n    }\r\n\r\n    if( xShouldWrite != pdFALSE )\r\n    {\r\n        /* Writes the data itself. */\r\n        xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */\r\n    }\r\n    else\r\n    {\r\n        xReturn = 0;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\r\n                             void * pvRxData,\r\n                             size_t xBufferLengthBytes,\r\n                             TickType_t xTicksToWait )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\r\n\r\n    configASSERT( pvRxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This receive function is used by both message buffers, which store\r\n     * discrete messages, and stream buffers, which store a continuous stream of\r\n     * bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    if( xTicksToWait != ( TickType_t ) 0 )\r\n    {\r\n        /* Checking if there is data and clearing the notification state must be\r\n         * performed atomically. */\r\n        taskENTER_CRITICAL();\r\n        {\r\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n            /* If this function was invoked by a message buffer read then\r\n             * xBytesToStoreMessageLength holds the number of bytes used to hold\r\n             * the length of the next discrete message.  If this function was\r\n             * invoked by a stream buffer read then xBytesToStoreMessageLength will\r\n             * be 0. */\r\n            if( xBytesAvailable <= xBytesToStoreMessageLength )\r\n            {\r\n                /* Clear notification state as going to wait for data. */\r\n                ( void ) xTaskNotifyStateClear( NULL );\r\n\r\n                /* Should only be one reader. */\r\n                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );\r\n                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        if( xBytesAvailable <= xBytesToStoreMessageLength )\r\n        {\r\n            /* Wait for data to be available. */\r\n            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );\r\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\r\n            pxStreamBuffer->xTaskWaitingToReceive = NULL;\r\n\r\n            /* Recheck the data available after blocking. */\r\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n    }\r\n\r\n    /* Whether receiving a discrete message (where xBytesToStoreMessageLength\r\n     * holds the number of bytes used to store the message length) or a stream of\r\n     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes\r\n     * available must be greater than xBytesToStoreMessageLength to be able to\r\n     * read bytes from the buffer. */\r\n    if( xBytesAvailable > xBytesToStoreMessageLength )\r\n    {\r\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\r\n\r\n        /* Was a task waiting for space in the buffer? */\r\n        if( xReceivedLength != ( size_t ) 0 )\r\n        {\r\n            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );\r\n            sbRECEIVE_COMPLETED( pxStreamBuffer );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReturn, xBytesAvailable, xOriginalTail;\r\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* Ensure the stream buffer is being used as a message buffer. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )\r\n        {\r\n            /* The number of bytes available is greater than the number of bytes\r\n             * required to hold the length of the next message, so another message\r\n             * is available.  Return its length without removing the length bytes\r\n             * from the buffer.  A copy of the tail is stored so the buffer can be\r\n             * returned to its prior state as the message is not actually being\r\n             * removed from the buffer. */\r\n            xOriginalTail = pxStreamBuffer->xTail;\r\n            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );\r\n            xReturn = ( size_t ) xTempReturn;\r\n            pxStreamBuffer->xTail = xOriginalTail;\r\n        }\r\n        else\r\n        {\r\n            /* The minimum amount of bytes in a message buffer is\r\n             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is\r\n             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid\r\n             * value is 0. */\r\n            configASSERT( xBytesAvailable == 0 );\r\n            xReturn = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        xReturn = 0;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                    void * pvRxData,\r\n                                    size_t xBufferLengthBytes,\r\n                                    BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\r\n\r\n    configASSERT( pvRxData );\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This receive function is used by both message buffers, which store\r\n     * discrete messages, and stream buffers, which store a continuous stream of\r\n     * bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\r\n     * message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\r\n\r\n    /* Whether receiving a discrete message (where xBytesToStoreMessageLength\r\n     * holds the number of bytes used to store the message length) or a stream of\r\n     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes\r\n     * available must be greater than xBytesToStoreMessageLength to be able to\r\n     * read bytes from the buffer. */\r\n    if( xBytesAvailable > xBytesToStoreMessageLength )\r\n    {\r\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\r\n\r\n        /* Was a task waiting for space in the buffer? */\r\n        if( xReceivedLength != ( size_t ) 0 )\r\n        {\r\n            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                        void * pvRxData,\r\n                                        size_t xBufferLengthBytes,\r\n                                        size_t xBytesAvailable,\r\n                                        size_t xBytesToStoreMessageLength )\r\n{\r\n    size_t xOriginalTail, xReceivedLength, xNextMessageLength;\r\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;\r\n\r\n    if( xBytesToStoreMessageLength != ( size_t ) 0 )\r\n    {\r\n        /* A discrete message is being received.  First receive the length\r\n         * of the message.  A copy of the tail is stored so the buffer can be\r\n         * returned to its prior state if the length of the message is too\r\n         * large for the provided buffer. */\r\n        xOriginalTail = pxStreamBuffer->xTail;\r\n        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );\r\n        xNextMessageLength = ( size_t ) xTempNextMessageLength;\r\n\r\n        /* Reduce the number of bytes available by the number of bytes just\r\n         * read out. */\r\n        xBytesAvailable -= xBytesToStoreMessageLength;\r\n\r\n        /* Check there is enough space in the buffer provided by the\r\n         * user. */\r\n        if( xNextMessageLength > xBufferLengthBytes )\r\n        {\r\n            /* The user has provided insufficient space to read the message\r\n             * so return the buffer to its previous state (so the length of\r\n             * the message is in the buffer again). */\r\n            pxStreamBuffer->xTail = xOriginalTail;\r\n            xNextMessageLength = 0;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* A stream of bytes is being received (as opposed to a discrete\r\n         * message), so read as many bytes as possible. */\r\n        xNextMessageLength = xBufferLengthBytes;\r\n    }\r\n\r\n    /* Read the actual data. */\r\n    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */\r\n\r\n    return xReceivedLength;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    size_t xTail;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* True if no bytes are available. */\r\n    xTail = pxStreamBuffer->xTail;\r\n\r\n    if( pxStreamBuffer->xHead == xTail )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )\r\n{\r\n    BaseType_t xReturn;\r\n    size_t xBytesToStoreMessageLength;\r\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    /* This generic version of the receive function is used by both message\r\n     * buffers, which store discrete messages, and stream buffers, which store a\r\n     * continuous stream of bytes.  Discrete messages include an additional\r\n     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */\r\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\r\n    {\r\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\r\n    }\r\n    else\r\n    {\r\n        xBytesToStoreMessageLength = 0;\r\n    }\r\n\r\n    /* True if the available space equals zero. */\r\n    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                              BaseType_t * pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )\r\n        {\r\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,\r\n                                         ( uint32_t ) 0,\r\n                                         eNoAction,\r\n                                         pxHigherPriorityTaskWoken );\r\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\r\n                                                 BaseType_t * pxHigherPriorityTaskWoken )\r\n{\r\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n\r\n    configASSERT( pxStreamBuffer );\r\n\r\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )\r\n        {\r\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,\r\n                                         ( uint32_t ) 0,\r\n                                         eNoAction,\r\n                                         pxHigherPriorityTaskWoken );\r\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                     const uint8_t * pucData,\r\n                                     size_t xCount )\r\n{\r\n    size_t xNextHead, xFirstLength;\r\n\r\n    configASSERT( xCount > ( size_t ) 0 );\r\n\r\n    xNextHead = pxStreamBuffer->xHead;\r\n\r\n    /* Calculate the number of bytes that can be added in the first write -\r\n     * which may be less than the total number of bytes that need to be added if\r\n     * the buffer will wrap back to the beginning. */\r\n    xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );\r\n\r\n    /* Write as many bytes as can be written in the first write. */\r\n    configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );\r\n    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n\r\n    /* If the number of bytes written was less than the number that could be\r\n     * written in the first write... */\r\n    if( xCount > xFirstLength )\r\n    {\r\n        /* ...then write the remaining bytes to the start of the buffer. */\r\n        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );\r\n        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    xNextHead += xCount;\r\n\r\n    if( xNextHead >= pxStreamBuffer->xLength )\r\n    {\r\n        xNextHead -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    pxStreamBuffer->xHead = xNextHead;\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\r\n                                      uint8_t * pucData,\r\n                                      size_t xMaxCount,\r\n                                      size_t xBytesAvailable )\r\n{\r\n    size_t xCount, xFirstLength, xNextTail;\r\n\r\n    /* Use the minimum of the wanted bytes and the available bytes. */\r\n    xCount = configMIN( xBytesAvailable, xMaxCount );\r\n\r\n    if( xCount > ( size_t ) 0 )\r\n    {\r\n        xNextTail = pxStreamBuffer->xTail;\r\n\r\n        /* Calculate the number of bytes that can be read - which may be\r\n         * less than the number wanted if the data wraps around to the start of\r\n         * the buffer. */\r\n        xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );\r\n\r\n        /* Obtain the number of bytes it is possible to obtain in the first\r\n         * read.  Asserts check bounds of read and write. */\r\n        configASSERT( xFirstLength <= xMaxCount );\r\n        configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );\r\n        ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n\r\n        /* If the total number of wanted bytes is greater than the number\r\n         * that could be read in the first read... */\r\n        if( xCount > xFirstLength )\r\n        {\r\n            /*...then read the remaining bytes from the start of the buffer. */\r\n            configASSERT( xCount <= xMaxCount );\r\n            ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        /* Move the tail pointer to effectively remove the data read from\r\n         * the buffer. */\r\n        xNextTail += xCount;\r\n\r\n        if( xNextTail >= pxStreamBuffer->xLength )\r\n        {\r\n            xNextTail -= pxStreamBuffer->xLength;\r\n        }\r\n\r\n        pxStreamBuffer->xTail = xNextTail;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )\r\n{\r\n/* Returns the distance between xTail and xHead. */\r\n    size_t xCount;\r\n\r\n    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;\r\n    xCount -= pxStreamBuffer->xTail;\r\n\r\n    if( xCount >= pxStreamBuffer->xLength )\r\n    {\r\n        xCount -= pxStreamBuffer->xLength;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    return xCount;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\r\n                                          uint8_t * const pucBuffer,\r\n                                          size_t xBufferSizeBytes,\r\n                                          size_t xTriggerLevelBytes,\r\n                                          uint8_t ucFlags )\r\n{\r\n    /* Assert here is deliberately writing to the entire buffer to ensure it can\r\n     * be written to without generating exceptions, and is setting the buffer to a\r\n     * known value to assist in development/debugging. */\r\n    #if ( configASSERT_DEFINED == 1 )\r\n        {\r\n            /* The value written just has to be identifiable when looking at the\r\n             * memory.  Don't use 0xA5 as that is the stack fill value and could\r\n             * result in confusion as to what is actually being observed. */\r\n            const BaseType_t xWriteValue = 0x55;\r\n            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );\r\n        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */\r\n    #endif\r\n\r\n    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */\r\n    pxStreamBuffer->pucBuffer = pucBuffer;\r\n    pxStreamBuffer->xLength = xBufferSizeBytes;\r\n    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;\r\n    pxStreamBuffer->ucFlags = ucFlags;\r\n}\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )\r\n    {\r\n        return xStreamBuffer->uxStreamBufferNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,\r\n                                             UBaseType_t uxStreamBufferNumber )\r\n    {\r\n        xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )\r\n    {\r\n        return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n"], "filenames": ["stream_buffer.c"], "buggy_code_start_loc": [261], "buggy_code_end_loc": [263], "fixing_code_start_loc": [261], "fixing_code_end_loc": [271], "type": "CWE-190", "message": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in stream_buffer.c for a stream buffer.", "other": {"cve": {"id": "CVE-2021-31572", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-22T18:15:08.547", "lastModified": "2021-06-02T18:33:41.203", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in stream_buffer.c for a stream buffer."}, {"lang": "es", "value": "El kernel en Amazon Web Services FreeRTOS versiones anteriores a 10.4.3, presenta un desbordamiento de enteros en el archivo stream_buffer.c para un b\u00fafer de flujo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:amazon:freertos:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.4.3", "matchCriteriaId": "6F5312AF-71BB-4289-BAB4-CE5931098CCD"}]}]}], "references": [{"url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b"}}