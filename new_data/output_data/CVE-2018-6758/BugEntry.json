{"buggy_code": ["#include <uwsgi.h>\n\n\nextern struct uwsgi_server uwsgi;\n\n#ifdef __BIG_ENDIAN__\nuint16_t uwsgi_swap16(uint16_t x) {\n\treturn (uint16_t) ((x & 0xff) << 8 | (x & 0xff00) >> 8);\n}\n\nuint32_t uwsgi_swap32(uint32_t x) {\n\tx = ((x << 8) & 0xFF00FF00) | ((x >> 8) & 0x00FF00FF);\n\treturn (x >> 16) | (x << 16);\n}\n\n// thanks to ffmpeg project for this idea :P\nuint64_t uwsgi_swap64(uint64_t x) {\n\tunion {\n\t\tuint64_t ll;\n\t\tuint32_t l[2];\n\t} w, r;\n\tw.ll = x;\n\tr.l[0] = uwsgi_swap32(w.l[1]);\n\tr.l[1] = uwsgi_swap32(w.l[0]);\n\treturn r.ll;\n}\n\n#endif\n\n// check if a string is a valid hex number\nint check_hex(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((str[i] < '0' && str[i] > '9') && (str[i] < 'a' && str[i] > 'f') && (str[i] < 'A' && str[i] > 'F')\n\t\t\t) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n\n}\n\n// increase worker harakiri\nvoid inc_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (uwsgi.master_process) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri += sec;\n\t}\n\telse {\n\t\talarm(uwsgi.harakiri_options.workers + sec);\n\t}\n}\n\n// set worker harakiri\nvoid set_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (!wsgi_req) return;\n\tif (sec == 0) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set user harakiri\nvoid set_user_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (!uwsgi.master_process) {\n\t\tuwsgi_log(\"!!! unable to set user harakiri without the master process !!!\\n\");\n\t\treturn;\n\t}\n\n\t// a 0 seconds value, reset the timer\n\ttime_t timeout = sec == 0 ? 0 : uwsgi_now() + sec;\n\n\tif (uwsgi.muleid > 0) {\n\t\tuwsgi.mules[uwsgi.muleid - 1].user_harakiri = timeout;\n\t}\n\telse if (uwsgi.i_am_a_spooler) {\n\t\tstruct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;\n\t\tuspool->user_harakiri = timeout;\n\t}\n\telse if (wsgi_req) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = timeout;\n\t}\n}\n\n// set mule harakiri\nvoid set_mule_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set spooler harakiri\nvoid set_spooler_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.i_am_a_spooler->harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.i_am_a_spooler->harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n\n// daemonize to the specified logfile\nvoid daemonize(char *logfile) {\n\tpid_t pid;\n\n\t// do not daemonize under emperor\n\tif (uwsgi.has_emperor) {\n\t\tlogto(logfile);\n\t\treturn;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\t/* refork... */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (!uwsgi.do_not_change_umask) {\n\t\tumask(0);\n\t}\n\n\t/*if (chdir(\"/\") != 0) {\n\t   uwsgi_error(\"chdir()\");\n\t   exit(1);\n\t   } */\n\n\tuwsgi_remap_fd(0, \"/dev/null\");\n\n\tlogto(logfile);\n}\n\n// get current working directory\nchar *uwsgi_get_cwd() {\n#if defined(__GLIBC__)\n\treturn getcwd(NULL, 0);\n#else\n\t// set this to static to avoid useless reallocations in stats mode\n\tstatic size_t newsize = 256;\n\n\tchar *cwd = uwsgi_malloc(newsize);\n\n\tif (getcwd(cwd, newsize) == NULL && errno == ERANGE) {\n\t\tnewsize += 256;\n\t\tuwsgi_log(\"need a bigger buffer (%lu bytes) for getcwd(). doing reallocation.\\n\", (unsigned long) newsize);\n\t\tfree(cwd);\n\t\tcwd = uwsgi_malloc(newsize);\n\t\tif (getcwd(cwd, newsize) == NULL) {\n\t\t\tuwsgi_error(\"getcwd()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn cwd;\n#endif\n\n}\n\n#ifdef __linux__\nvoid uwsgi_set_cgroup() {\n\n\tchar *cgroup_taskfile;\n\tFILE *cgroup;\n\tchar *cgroup_opt;\n\tstruct uwsgi_string_list *usl, *uslo;\n\n\tif (!uwsgi.cgroup)\n\t\treturn;\n\n\tif (getuid())\n\t\treturn;\n\n\tusl = uwsgi.cgroup;\n\n\twhile (usl) {\n\t\tint mode = strtol(uwsgi.cgroup_dir_mode, 0, 8);\n\t\tif (mkdir(usl->value, mode)) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/mkdir()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (chmod(usl->value, mode)) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/chmod()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuwsgi_log(\"using Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"created Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\n\t\tcgroup_taskfile = uwsgi_concat2(usl->value, \"/tasks\");\n\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\tif (!cgroup) {\n\t\t\tuwsgi_error_open(cgroup_taskfile);\n\t\t\texit(1);\n\t\t}\n\t\tif (fprintf(cgroup, \"%d\\n\", (int) getpid()) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\tuwsgi_error(\"could not set cgroup\");\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi_log(\"assigned process %d to cgroup %s\\n\", (int) getpid(), cgroup_taskfile);\n\t\tfree(cgroup_taskfile);\n\n\n\t\tuslo = uwsgi.cgroup_opt;\n\t\twhile (uslo) {\n\t\t\tcgroup_opt = strchr(uslo->value, '=');\n\t\t\tif (!cgroup_opt) {\n\t\t\t\tcgroup_opt = strchr(uslo->value, ':');\n\t\t\t\tif (!cgroup_opt) {\n\t\t\t\t\tuwsgi_log(\"invalid cgroup-opt syntax\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcgroup_opt[0] = 0;\n\t\t\tcgroup_opt++;\n\n\t\t\tcgroup_taskfile = uwsgi_concat3(usl->value, \"/\", uslo->value);\n\t\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\t\tif (cgroup) {\n\t\t\t\tif (fprintf(cgroup, \"%s\\n\", cgroup_opt) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\t\t\tuwsgi_log(\"could not set cgroup option %s to %s\\n\", uslo->value, cgroup_opt);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tuwsgi_log(\"set %s to %s\\n\", cgroup_opt, cgroup_taskfile);\n\t\t\t}\n\t\t\tfree(cgroup_taskfile);\n\n\t\t\tcgroup_opt[-1] = '=';\n\n\t\t\tuslo = uslo->next;\n\t\t}\n\n\t\tusl = usl->next;\n\t}\n\n}\n#endif\n\n#ifdef UWSGI_CAP\nvoid uwsgi_apply_cap(cap_value_t * cap, int caps_count) {\n\tcap_value_t minimal_cap_values[] = { CAP_SYS_CHROOT, CAP_SETUID, CAP_SETGID, CAP_SETPCAP };\n\n\tcap_t caps = cap_init();\n\n\tif (!caps) {\n\t\tuwsgi_error(\"cap_init()\");\n\t\texit(1);\n\t}\n\tcap_clear(caps);\n\n\tcap_set_flag(caps, CAP_EFFECTIVE, 4, minimal_cap_values, CAP_SET);\n\n\tcap_set_flag(caps, CAP_PERMITTED, 4, minimal_cap_values, CAP_SET);\n\tcap_set_flag(caps, CAP_PERMITTED, caps_count, cap, CAP_SET);\n\n\tcap_set_flag(caps, CAP_INHERITABLE, caps_count, cap, CAP_SET);\n\n\tif (cap_set_proc(caps) < 0) {\n\t\tuwsgi_error(\"cap_set_proc()\");\n\t\texit(1);\n\t}\n\tcap_free(caps);\n\n#ifdef __linux__\n#ifdef SECBIT_KEEP_CAPS\n\tif (prctl(SECBIT_KEEP_CAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#else\n\tif (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#endif\n#endif\n}\n#endif\n\n// drop privileges (as root)\n/*\n\n\there we manage jails/namespaces too\n\tit is a pretty huge function... refactory is needed\n\n*/\nvoid uwsgi_as_root() {\n\n\n\tif (getuid() > 0)\n\t\tgoto nonroot;\n\n#ifndef __RUMP__\n\tif (!uwsgi.master_as_root && !uwsgi.uidname) {\n\t\tuwsgi_log_initial(\"uWSGI running as root, you can use --uid/--gid/--chroot options\\n\");\n\t}\n#endif\n\n\tint in_jail = 0;\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare);\n\t\t}\n\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\t\tuwsgi_apply_cap(uwsgi.cap, uwsgi.cap_count);\n\t}\n#endif\n\n\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tif (uwsgi.jail && !uwsgi.reloads) {\n\n\t\tstruct jail ujail;\n\t\tchar *jarg = uwsgi_str(uwsgi.jail);\n\t\tchar *j_hostname = NULL;\n\t\tchar *j_name = NULL;\n\n\t\tchar *space = strchr(jarg, ' ');\n\t\tif (space) {\n\t\t\t*space = 0;\n\t\t\tj_hostname = space + 1;\n\t\t\tspace = strchr(j_hostname, ' ');\n\t\t\tif (space) {\n\t\t\t\t*space = 0;\n\t\t\t\tj_name = space + 1;\n\t\t\t}\n\t\t}\n\t\tujail.version = JAIL_API_VERSION;\n\t\tujail.path = jarg;\n\t\tujail.hostname = j_hostname ? j_hostname : \"\";\n\t\tujail.jailname = j_name;\n\t\tujail.ip4s = 0;\n\t\tujail.ip6s = 0;\n\n\t\tstruct uwsgi_string_list *usl = NULL;\n\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tujail.ip4s++;\n\t\t}\n\t\tstruct in_addr *saddr = uwsgi_calloc(sizeof(struct in_addr) * ujail.ip4s);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tif (!inet_pton(AF_INET, usl->value, &saddr[i].s_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip4 = saddr;\n#ifdef AF_INET6\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tujail.ip6s++;\n\t\t}\n\n\t\tstruct in6_addr *saddr6 = uwsgi_calloc(sizeof(struct in6_addr) * ujail.ip6s);\n\t\ti = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tif (!inet_pton(AF_INET6, usl->value, &saddr6[i].s6_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip6 = saddr6;\n#endif\n\n\t\tint jail_id = jail(&ujail);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jail()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n\tif (uwsgi.jail_attach && !uwsgi.reloads) {\n\t\tstruct jailparam jparam;\n\t\tuwsgi_log(\"attaching to FreeBSD jail %s ...\\n\", uwsgi.jail_attach);\n\t\tif (!is_a_number(uwsgi.jail_attach)) {\n\t\t\tif (jailparam_init(&jparam, \"name\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (jailparam_init(&jparam, \"jid\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tjailparam_import(&jparam, uwsgi.jail_attach);\n\t\tint jail_id = jailparam_set(&jparam, 1, JAIL_UPDATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(&jparam, 1);\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n\tif (uwsgi.jail2 && !uwsgi.reloads) {\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tunsigned nparams = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tnparams++;\n\t\t}\n\t\tstruct jailparam *params = uwsgi_malloc(sizeof(struct jailparam) * nparams);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tuwsgi_log(\"FreeBSD libjail applying %s\\n\", usl->value);\n\t\t\tchar *equal = strchr(usl->value, '=');\n\t\t\tif (equal) {\n\t\t\t\t*equal = 0;\n\t\t\t}\n\t\t\tif (jailparam_init(&params[i], usl->value)) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tjailparam_import(&params[i], equal + 1);\n\t\t\t\t*equal = '=';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjailparam_import(&params[i], \"1\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tint jail_id = jailparam_set(params, nparams, JAIL_CREATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(params, nparams);\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n#endif\n#endif\n\n\tif (in_jail || uwsgi.jailed) {\n\t\tuwsgi_hooks_run(uwsgi.hook_post_jail, \"post-jail\", 1);\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tuwsgi_foreach(usl, uwsgi.mount_post_jail) {\n\t\t\tuwsgi_log(\"mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.umount_post_jail) {\n\t\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.exec_post_jail) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_post_jail) {\n\t\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (uwsgi.refork_post_jail) {\n\t\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\t\tpid_t pid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\tuwsgi_error(\"fork()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (pid > 0) {\n\t\t\t\t// block all signals\n\t\t\t\tsigset_t smask;\n\t\t\t\tsigfillset(&smask);\n\t\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\t\tint status;\n\t\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t\t}\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t}\n\n\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\t\tif (uwsgi.gp[i]->post_jail) {\n\t\t\t\tuwsgi.gp[i]->post_jail();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.chroot && !uwsgi.reloads) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"chroot() to %s\\n\", uwsgi.chroot);\n\t\tif (chroot(uwsgi.chroot)) {\n\t\t\tuwsgi_error(\"chroot()\");\n\t\t\texit(1);\n\t\t}\n#ifdef __linux__\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n#endif\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.pivot_root && !uwsgi.reloads) {\n\t\tchar *arg = uwsgi_str(uwsgi.pivot_root);\n\t\tchar *space = strchr(arg, ' ');\n\t\tif (!space) {\n\t\t\tuwsgi_log(\"invalid pivot_root syntax, new_root and put_old must be separated by a space\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*space = 0;\n#if defined(MS_REC) && defined(MS_PRIVATE)\n\t\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\t\tuwsgi_error(\"mount()\");\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tif (chdir(arg)) {\n\t\t\tuwsgi_error(\"pivot_root()/chdir()\");\n\t\t\texit(1);\n\t\t}\n\t\tspace += 1 + strlen(arg);\n\t\tif (space[0] == '/')\n\t\t\tspace++;\n\t\tif (pivot_root(\".\", space)) {\n\t\t\tuwsgi_error(\"pivot_root()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n\t\tfree(arg);\n\t\tif (chdir(\"/\")) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n#endif\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare2 && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare2)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare2);\n\t\t}\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare2 & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n\tif (uwsgi.refork_as_root) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uwsgi.wait_for_interface) {\n\t\tif (!uwsgi.wait_for_interface_timeout) {\n\t\t\tuwsgi.wait_for_interface_timeout = 60;\n\t\t}\n\t\tuwsgi_log(\"waiting for interface %s (max %d seconds) ...\\n\", usl->value, uwsgi.wait_for_interface_timeout);\n\t\tint counter = 0;\n\t\tfor (;;) {\n\t\t\tif (counter > uwsgi.wait_for_interface_timeout) {\n\t\t\t\tuwsgi_log(\"interface %s unavailable after %d seconds\\n\", usl->value, counter);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tunsigned int index = if_nametoindex(usl->value);\n\t\t\tif (index > 0) {\n\t\t\t\tuwsgi_log(\"interface %s found with index %u\\n\", usl->value, index);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsleep(1);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_fs) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 0)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_file) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 1)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_dir) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 2)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {\n\t\tif (uwsgi_wait_for_mountpoint(usl->value)) exit(1);\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_root, \"as root\", 1);\n\n\tuwsgi_foreach(usl, uwsgi.mount_as_root) {\n\t\tuwsgi_log(\"mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.umount_as_root) {\n\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// now run the scripts needed by root\n\tuwsgi_foreach(usl, uwsgi.exec_as_root) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_root) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t}\n\t}\n\n\n\tif (uwsgi.gidname) {\n\t\tstruct group *ugroup = getgrnam(uwsgi.gidname);\n\t\tif (ugroup) {\n\t\t\tuwsgi.gid = ugroup->gr_gid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"group %s not found.\\n\", uwsgi.gidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (uwsgi.uidname) {\n\t\tstruct passwd *upasswd = getpwnam(uwsgi.uidname);\n\t\tif (upasswd) {\n\t\t\tuwsgi.uid = upasswd->pw_uid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"user %s not found.\\n\", uwsgi.uidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.logfile_chown) {\n\t\tint log_fd = 2;\n\t\tif (uwsgi.log_master && uwsgi.original_log_fd > -1) {\n\t\t\tlog_fd = uwsgi.original_log_fd;\n\t\t}\n\t\tif (fchown(log_fd, uwsgi.uid, uwsgi.gid)) {\n\t\t\tuwsgi_error(\"fchown()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// fix ipcsem owner\n\tif (uwsgi.lock_ops.lock_init == uwsgi_lock_ipcsem_init) {\n\t\tstruct uwsgi_lock_item *uli = uwsgi.registered_locks;\n\n\t\twhile (uli) {\n\t\t\tunion semun {\n\t\t\t\tint val;\n\t\t\t\tstruct semid_ds *buf;\n\t\t\t\tushort *array;\n\t\t\t} semu;\n\n\t\t\tstruct semid_ds sds;\n\t\t\tmemset(&sds, 0, sizeof(sds));\n\t\t\tsemu.buf = &sds;\n\t\t\tint semid = 0;\n\t\t\tmemcpy(&semid, uli->lock_ptr, sizeof(int));\n\n\t\t\tif (semctl(semid, 0, IPC_STAT, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tsemu.buf->sem_perm.uid = uwsgi.uid;\n\t\t\tsemu.buf->sem_perm.gid = uwsgi.gid;\n\n\t\t\tif (semctl(semid, 0, IPC_SET, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuli = uli->next;\n\t\t}\n\n\t}\n\n\t// ok try to call some special hook before finally dropping privileges\n\tint i;\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->before_privileges_drop) {\n\t\t\tuwsgi.gp[i]->before_privileges_drop();\n\t\t}\n\t}\n\n\tif (uwsgi.gid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setgid() to %d\\n\", uwsgi.gid);\n\t\tif (setgid(uwsgi.gid)) {\n\t\t\tuwsgi_error(\"setgid()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.no_initgroups || !uwsgi.uid) {\n\t\t\tif (setgroups(0, NULL)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar *uidname = uwsgi.uidname;\n\t\t\tif (!uidname) {\n\t\t\t\tstruct passwd *pw = getpwuid(uwsgi.uid);\n\t\t\t\tif (pw)\n\t\t\t\t\tuidname = pw->pw_name;\n\n\t\t\t}\n\t\t\tif (!uidname)\n\t\t\t\tuidname = uwsgi_num2str(uwsgi.uid);\n\t\t\tif (initgroups(uidname, uwsgi.gid)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tstruct uwsgi_string_list *usl;\n\t\tsize_t ags = 0;\n\t\tuwsgi_foreach(usl, uwsgi.additional_gids) ags++;\n\t\tif (ags > 0) {\n\t\t\tgid_t *ags_list = uwsgi_calloc(sizeof(gid_t) * ags);\n\t\t\tsize_t g_pos = 0;\n\t\t\tuwsgi_foreach(usl, uwsgi.additional_gids) {\n\t\t\t\tags_list[g_pos] = atoi(usl->value);\n\t\t\t\tif (!ags_list[g_pos]) {\n\t\t\t\t\tstruct group *g = getgrnam(usl->value);\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\tags_list[g_pos] = g->gr_gid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", usl->value);\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg_pos++;\n\t\t\t}\n\t\t\tif (setgroups(ags, ags_list)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tint additional_groups = getgroups(0, NULL);\n\t\tif (additional_groups > 0) {\n\t\t\tgid_t *gids = uwsgi_calloc(sizeof(gid_t) * additional_groups);\n\t\t\tif (getgroups(additional_groups, gids) > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < additional_groups; i++) {\n\t\t\t\t\tif (gids[i] == uwsgi.gid)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tstruct group *gr = getgrgid(gids[i]);\n\t\t\t\t\tif (gr) {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d (%s)\\n\", gids[i], gr->gr_name);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d\\n\", gids[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(gids);\n\t\t}\n\t}\n\tif (uwsgi.uid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setuid() to %d\\n\", uwsgi.uid);\n\t\tif (setuid(uwsgi.uid)) {\n\t\t\tuwsgi_error(\"setuid()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n#ifndef __RUMP__\n\tif (!getuid()) {\n\t\tuwsgi_log_initial(\"*** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** \\n\");\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\n\t\tcap_t caps = cap_init();\n\n\t\tif (!caps) {\n\t\t\tuwsgi_error(\"cap_init()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_clear(caps);\n\n\t\tcap_set_flag(caps, CAP_EFFECTIVE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_PERMITTED, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_INHERITABLE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\n\t\tif (cap_set_proc(caps) < 0) {\n\t\t\tuwsgi_error(\"cap_set_proc()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_free(caps);\n\t}\n#endif\n\n\tif (uwsgi.refork) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_user, \"as user\", 1);\n\n\t// now run the scripts needed by the user\n\tuwsgi_foreach(usl, uwsgi.exec_as_user) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as uid: %d gid: %d) ...\\n\", usl->value, (int) getuid(), (int) getgid());\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_user) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// we could now patch the binary\n\tif (uwsgi.unprivileged_binary_patch) {\n\t\tuwsgi.argv[0] = uwsgi.unprivileged_binary_patch;\n\t\texecvp(uwsgi.unprivileged_binary_patch, uwsgi.argv);\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.unprivileged_binary_patch_arg) {\n\t\tuwsgi_exec_command_with_args(uwsgi.unprivileged_binary_patch_arg);\n\t}\n\treturn;\n\nnonroot:\n\tif (uwsgi.chroot && !uwsgi.is_a_reload) {\n\t\tuwsgi_log(\"cannot chroot() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.gid && getgid() != uwsgi.gid) {\n\t\tuwsgi_log(\"cannot setgid() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.uid && getuid() != uwsgi.uid) {\n\t\tuwsgi_log(\"cannot setuid() as non-root user\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void close_and_free_request(struct wsgi_request *wsgi_req) {\n\n\t// close the connection with the client\n        if (!wsgi_req->fd_closed) {\n                // NOTE, if we close the socket before receiving eventually sent data, socket layer will send a RST\n                wsgi_req->socket->proto_close(wsgi_req);\n        }\n\n        if (wsgi_req->post_file) {\n                fclose(wsgi_req->post_file);\n        }\n\n        if (wsgi_req->post_read_buf) {\n                free(wsgi_req->post_read_buf);\n        }\n\n        if (wsgi_req->post_readline_buf) {\n                free(wsgi_req->post_readline_buf);\n        }\n\n        if (wsgi_req->proto_parser_buf) {\n                free(wsgi_req->proto_parser_buf);\n        }\n\n}\n\n// destroy a request\nvoid uwsgi_destroy_request(struct wsgi_request *wsgi_req) {\n\n\tclose_and_free_request(wsgi_req);\n\n\tint foo;\n        if (uwsgi.threads > 1) {\n                // now the thread can die...\n                pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &foo);\n        }\n\n\t// reset for avoiding following requests to fail on non-uwsgi protocols\n\t// thanks Marko Tiikkaja for catching it\n\twsgi_req->uh->_pktsize = 0;\n\n\t// some plugins expected async_id to be defined before setup\n        int tmp_id = wsgi_req->async_id;\n        memset(wsgi_req, 0, sizeof(struct wsgi_request));\n        wsgi_req->async_id = tmp_id;\n}\n\n// finalize/close/free a request\nvoid uwsgi_close_request(struct wsgi_request *wsgi_req) {\n\n\tint waitpid_status;\n\tint tmp_id;\n\tuint64_t tmp_rt, rss = 0, vsz = 0;\n#ifdef __linux__\n\tuint64_t uss = 0, pss = 0;\n#endif\n\n\t// apply transformations\n\tif (wsgi_req->transformations) {\n\t\tif (uwsgi_apply_final_transformations(wsgi_req) == 0) {\n\t\t\tif (wsgi_req->transformed_chunk && wsgi_req->transformed_chunk_len > 0) {\n\t\t\t\tuwsgi_response_write_body_do(wsgi_req, wsgi_req->transformed_chunk, wsgi_req->transformed_chunk_len);\n\t\t\t}\n\t\t}\n\t\tuwsgi_free_transformations(wsgi_req);\n\t}\n\n\t// check if headers should be sent\n\tif (wsgi_req->headers) {\n\t\tif (!wsgi_req->headers_sent && !wsgi_req->headers_size && !wsgi_req->response_size) {\n\t\t\tuwsgi_response_write_headers_do(wsgi_req);\n\t\t}\n\t\tuwsgi_buffer_destroy(wsgi_req->headers);\n\t}\n\n\tuint64_t end_of_request = uwsgi_micros();\n\twsgi_req->end_of_request = end_of_request;\n\n\tif (!wsgi_req->do_not_account_avg_rt) {\n\t\ttmp_rt = wsgi_req->end_of_request - wsgi_req->start_of_request;\n\t\tuwsgi.workers[uwsgi.mywid].running_time += tmp_rt;\n\t\tuwsgi.workers[uwsgi.mywid].avg_response_time = (uwsgi.workers[uwsgi.mywid].avg_response_time + tmp_rt) / 2;\n\t}\n\n\t// get memory usage\n\tif (uwsgi.logging_options.memory_report || uwsgi.force_get_memusage) {\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.logging_options.memory_report || uwsgi.reload_on_uss || uwsgi.reload_on_pss) {\n\t\tget_memusage_extra(&uss, &pss);\n\t\tuwsgi.workers[uwsgi.mywid].uss_size = uss;\n\t\tuwsgi.workers[uwsgi.mywid].pss_size = pss;\n\t}\n#endif\n\n\tif (!wsgi_req->do_not_account) {\n\t\tuwsgi.workers[0].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].write_errors += wsgi_req->write_errors;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].read_errors += wsgi_req->read_errors;\n\t\t// this is used for MAX_REQUESTS\n\t\tuwsgi.workers[uwsgi.mywid].delta_requests++;\n\t}\n\n#ifdef UWSGI_ROUTING\n\t// apply final routes after accounting\n\tuwsgi_apply_final_routes(wsgi_req);\n#endif\n\n\t// close socket and free parsers-allocated memory\n\tclose_and_free_request(wsgi_req);\n\n\t// after_request hook\n\tif (!wsgi_req->is_raw && uwsgi.p[wsgi_req->uh->modifier1]->after_request)\n\t\tuwsgi.p[wsgi_req->uh->modifier1]->after_request(wsgi_req);\n\n\t// after_request custom hooks\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.after_request_hooks) {\n\t\tvoid (*func) (struct wsgi_request *) = (void (*)(struct wsgi_request *)) usl->custom_ptr;\n\t\tfunc(wsgi_req);\n\t}\n\n\tif (uwsgi.threads > 1) {\n\t\t// now the thread can die...\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &tmp_id);\n\t}\n\n\t// leave harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {\n\t\tset_harakiri(wsgi_req, 0);\n\t}\n\n\t// leave user harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri > 0) {\n\t\tset_user_harakiri(wsgi_req, 0);\n\t}\n\n\tif (!wsgi_req->do_not_account) {\n\t\t// this is racy in multithread mode\n\t\tif (wsgi_req->response_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->response_size;\n\t\t}\n\t\tif (wsgi_req->headers_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->headers_size;\n\t\t}\n\t}\n\n\t// defunct process reaper\n\tif (uwsgi.reaper == 1) {\n\t\twhile (waitpid(WAIT_ANY, &waitpid_status, WNOHANG) > 0);\n\t}\n\n\t// free logvars\n\tstruct uwsgi_logvar *lv = wsgi_req->logvars;\n\twhile (lv) {\n\t\tstruct uwsgi_logvar *ptr = lv;\n\t\tlv = lv->next;\n\t\tfree(ptr);\n\t}\n\n\t// free additional headers\n\tstruct uwsgi_string_list *ah = wsgi_req->additional_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\t// free remove headers\n\tah = wsgi_req->remove_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\n\t// free chunked input\n\tif (wsgi_req->chunked_input_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->chunked_input_buf);\n\t}\n\n\tif (wsgi_req->body_chunked_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->body_chunked_buf);\n\t}\n\n\t// free websocket engine\n\tif (wsgi_req->websocket_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_buf);\n\t}\n\tif (wsgi_req->websocket_send_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_send_buf);\n\t}\n\n\n\t// reset request\n\twsgi_req->uh->_pktsize = 0;\n\ttmp_id = wsgi_req->async_id;\n\tmemset(wsgi_req, 0, sizeof(struct wsgi_request));\n\t// some plugins expected async_id to be defined before setup\n\twsgi_req->async_id = tmp_id;\n\t// yes, this is pretty useless but we cannot ensure all of the plugin have the same behaviour\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\tif (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))\n\t    && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"max requests reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) uwsgi.workers[uwsgi.mywid].delta_requests,\n\t\t\t(unsigned long long) (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_as && (rlim_t) vsz >= uwsgi.reload_on_as && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-as limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) vsz,\n\t\t\t(unsigned long long) uwsgi.reload_on_as\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_rss && (rlim_t) rss >= uwsgi.reload_on_rss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-rss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) rss,\n\t\t\t(unsigned long long) uwsgi.reload_on_rss\n\t\t);\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.reload_on_uss && (rlim_t) uss >= uwsgi.reload_on_uss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-uss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) uss,\n\t\t\t(unsigned long long) uwsgi.reload_on_uss\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_pss && (rlim_t) pss >= uwsgi.reload_on_pss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-pss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) pss,\n\t\t\t(unsigned long long) uwsgi.reload_on_pss\n\t\t);\n\t}\n#endif\n\n\t// after the first request, if i am a vassal, signal Emperor about my loyalty\n\tif (uwsgi.has_emperor && !uwsgi.loyal) {\n\t\tuwsgi_log(\"announcing my loyalty to the Emperor...\\n\");\n\t\tchar byte = 17;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.loyal = 1;\n\t}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\t// run the ksm mapper\n\tif (uwsgi.linux_ksm > 0 && (uwsgi.workers[uwsgi.mywid].requests % uwsgi.linux_ksm) == 0) {\n\t\tuwsgi_linux_ksm_map();\n\t}\n#endif\n#endif\n\n}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\nvoid uwsgi_linux_ksm_map(void) {\n\n\tint dirty = 0;\n\tsize_t i;\n\tunsigned long long start = 0, end = 0;\n\tint errors = 0;\n\tint lines = 0;\n\n\tint fd = open(\"/proc/self/maps\", O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(\"[uwsgi-KSM] /proc/self/maps\");\n\t\treturn;\n\t}\n\n\t// allocate memory if not available;\n\tif (uwsgi.ksm_mappings_current == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_current = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_current_size = 0;\n\t}\n\tif (uwsgi.ksm_mappings_last == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_last = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_last_size = 0;\n\t}\n\n\tuwsgi.ksm_mappings_current_size = read(fd, uwsgi.ksm_mappings_current, uwsgi.ksm_buffer_size);\n\tclose(fd);\n\tif (uwsgi.ksm_mappings_current_size <= 0) {\n\t\tuwsgi_log(\"[uwsgi-KSM] unable to read /proc/self/maps data\\n\");\n\t\treturn;\n\t}\n\n\t// we now have areas\n\tif (uwsgi.ksm_mappings_last_size == 0 || uwsgi.ksm_mappings_current_size != uwsgi.ksm_mappings_last_size) {\n\t\tdirty = 1;\n\t}\n\telse {\n\t\tif (memcmp(uwsgi.ksm_mappings_current, uwsgi.ksm_mappings_last, uwsgi.ksm_mappings_current_size) != 0) {\n\t\t\tdirty = 1;\n\t\t}\n\t}\n\n\t// it is dirty, swap addresses and parse it\n\tif (dirty) {\n\t\tchar *tmp = uwsgi.ksm_mappings_last;\n\t\tuwsgi.ksm_mappings_last = uwsgi.ksm_mappings_current;\n\t\tuwsgi.ksm_mappings_current = tmp;\n\n\t\tsize_t tmp_size = uwsgi.ksm_mappings_last_size;\n\t\tuwsgi.ksm_mappings_last_size = uwsgi.ksm_mappings_current_size;\n\t\tuwsgi.ksm_mappings_current_size = tmp_size;\n\n\t\t// scan each line and call madvise on it\n\t\tchar *ptr = uwsgi.ksm_mappings_last;\n\t\tfor (i = 0; i < uwsgi.ksm_mappings_last_size; i++) {\n\t\t\tif (uwsgi.ksm_mappings_last[i] == '\\n') {\n\t\t\t\tlines++;\n\t\t\t\tuwsgi.ksm_mappings_last[i] = 0;\n\t\t\t\tif (sscanf(ptr, \"%llx-%llx %*s\", &start, &end) == 2) {\n\t\t\t\t\tif (madvise((void *) (long) start, (size_t) (end - start), MADV_MERGEABLE)) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuwsgi.ksm_mappings_last[i] = '\\n';\n\t\t\t\tptr = uwsgi.ksm_mappings_last + i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (errors >= lines) {\n\t\t\tuwsgi_error(\"[uwsgi-KSM] unable to share pages\");\n\t\t}\n\t}\n}\n#endif\n#endif\n\n#ifdef __linux__\nlong uwsgi_num_from_file(char *filename, int quiet) {\n\tchar buf[16];\n\tssize_t len;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_error_open(filename);\n\t\treturn -1L;\n\t}\n\tlen = read(fd, buf, sizeof(buf));\n\tif (len == 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_log(\"read error %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn -1L;\n\t}\n\tclose(fd);\n\treturn strtol(buf, (char **) NULL, 10);\n}\n#endif\n\n// setup for a new request\nvoid wsgi_req_setup(struct wsgi_request *wsgi_req, int async_id, struct uwsgi_socket *uwsgi_sock) {\n\n\twsgi_req->app_id = -1;\n\n\twsgi_req->async_id = async_id;\n\twsgi_req->sendfile_fd = -1;\n\n\twsgi_req->hvec = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].hvec;\n\t// skip the first 4 bytes;\n\twsgi_req->uh = (struct uwsgi_header *) uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer;\n\twsgi_req->buffer = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer + 4;\n\n\tif (uwsgi.post_buffering > 0) {\n\t\twsgi_req->post_buffering_buf = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].post_buf;\n\t}\n\n\tif (uwsgi_sock) {\n\t\twsgi_req->socket = uwsgi_sock;\n\t}\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\t// now check for suspend request\n\tif (uwsgi.workers[uwsgi.mywid].suspended == 1) {\n\t\tuwsgi_log_verbose(\"*** worker %d suspended ***\\n\", uwsgi.mywid);\ncycle:\n\t\t// wait for some signal (normally SIGTSTP) or 10 seconds (as fallback)\n\t\t(void) poll(NULL, 0, 10 * 1000);\n\t\tif (uwsgi.workers[uwsgi.mywid].suspended == 1)\n\t\t\tgoto cycle;\n\t\tuwsgi_log_verbose(\"*** worker %d resumed ***\\n\", uwsgi.mywid);\n\t}\n}\n\nint wsgi_req_async_recv(struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\tif (!wsgi_req->do_not_add_to_async_queue) {\n\t\tif (event_queue_add_fd_read(uwsgi.async_queue, wsgi_req->fd) < 0)\n\t\t\treturn -1;\n\n\t\tasync_add_timeout(wsgi_req, uwsgi.socket_timeout);\n\t\tuwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(wsgi_req, uwsgi.harakiri_options.workers);\n\t}\n\n\treturn 0;\n}\n\n// receive a new request\nint wsgi_req_recv(int queue, struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\t// edge triggered sockets get the whole request during accept() phase\n\tif (!wsgi_req->socket->edge_trigger) {\n\t\tfor (;;) {\n\t\t\tint ret = wsgi_req->socket->proto(wsgi_req);\n\t\t\tif (ret == UWSGI_OK)\n\t\t\t\tbreak;\n\t\t\tif (ret == UWSGI_AGAIN) {\n\t\t\t\tret = uwsgi_wait_read_req(wsgi_req);\n\t\t\t\tif (ret <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(wsgi_req, uwsgi.harakiri_options.workers);\n\t}\n\n#ifdef UWSGI_ROUTING\n\tif (uwsgi_apply_routes(wsgi_req) == UWSGI_ROUTE_BREAK)\n\t\treturn 0;\n#endif\n\n\twsgi_req->async_status = uwsgi.p[wsgi_req->uh->modifier1]->request(wsgi_req);\n\n\treturn 0;\n}\n\nvoid uwsgi_post_accept(struct wsgi_request *wsgi_req) {\n\n\t// set close on exec (if not a new socket)\n\tif (!wsgi_req->socket->edge_trigger && uwsgi.close_on_exec) {\n\t\tif (fcntl(wsgi_req->fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\t\tuwsgi_error(\"fcntl()\");\n\t\t}\n\t}\n\n\t// enable TCP_NODELAY ?\n\tif (uwsgi.tcp_nodelay) {\n\t\tuwsgi_tcp_nodelay(wsgi_req->fd);\n\t}\n}\n\n// accept a new request\nint wsgi_req_simple_accept(struct wsgi_request *wsgi_req, int fd) {\n\n\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, fd);\n\n\tif (wsgi_req->fd < 0) {\n\t\treturn -1;\n\t}\n\n\tuwsgi_post_accept(wsgi_req);\n\n\treturn 0;\n}\n\n// send heartbeat to the emperor\nvoid uwsgi_heartbeat() {\n\n\tif (!uwsgi.has_emperor)\n\t\treturn;\n\n\ttime_t now = uwsgi_now();\n\tif (uwsgi.next_heartbeat <= now) {\n\t\tchar byte = 26;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.next_heartbeat = now + uwsgi.heartbeat;\n\t}\n\n}\n\n// accept a request\nint wsgi_req_accept(int queue, struct wsgi_request *wsgi_req) {\n\n\tint ret;\n\tint interesting_fd = -1;\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint timeout = -1;\n\n\n\tthunder_lock;\n\n\t// Recheck the manage_next_request before going forward.\n\t// This is because the worker might get cheaped while it's\n\t// blocking on the thunder_lock, because thunder_lock is\n\t// not interruptable, it'll slow down the cheaping process\n\t// (the worker will handle the next request before shuts down).\n\tif (!uwsgi.workers[uwsgi.mywid].manage_next_request) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// heartbeat\n\t// in multithreaded mode we are now locked\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\ttime_t now = uwsgi_now();\n\t\t// overengineering ... (reduce skew problems)\n\t\ttimeout = uwsgi.heartbeat;\n\t\tif (!uwsgi.next_heartbeat) {\n\t\t\tuwsgi.next_heartbeat = now;\n\t\t}\n\t\tif (uwsgi.next_heartbeat >= now) {\n\t\t\ttimeout = uwsgi.next_heartbeat - now;\n\t\t}\n\t}\n\n\t// need edge trigger ?\n\tif (uwsgi.is_et) {\n\t\twhile (uwsgi_sock) {\n\t\t\tif (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) {\n\t\t\t\ttimeout = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuwsgi_sock = uwsgi_sock->next;\n\t\t}\n\t\t// reset pointer\n\t\tuwsgi_sock = uwsgi.sockets;\n\t}\n\n\tret = event_queue_wait(queue, timeout, &interesting_fd);\n\tif (ret < 0) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// check for heartbeat\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\tuwsgi_heartbeat();\n\t\t// no need to continue if timed-out\n\t\tif (ret == 0) {\n\t\t\tthunder_unlock;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// kill the thread after the request completion\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &ret);\n\n\tif (uwsgi.signal_socket > -1 && (interesting_fd == uwsgi.signal_socket || interesting_fd == uwsgi.my_signal_socket)) {\n\n\t\tthunder_unlock;\n\n\t\tuwsgi_receive_signal(wsgi_req, interesting_fd, \"worker\", uwsgi.mywid);\n\n\t\tif (uwsgi.threads > 1)\n\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\treturn -1;\n\t}\n\n\n\twhile (uwsgi_sock) {\n\t\tif (interesting_fd == uwsgi_sock->fd || (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) || (uwsgi_sock->fd_threads && interesting_fd == uwsgi_sock->fd_threads[wsgi_req->async_id])) {\n\t\t\twsgi_req->socket = uwsgi_sock;\n\t\t\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, interesting_fd);\n\t\t\tthunder_unlock;\n\t\t\tif (wsgi_req->fd < 0) {\n\t\t\t\tif (uwsgi.threads > 1)\n\t\t\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!uwsgi_sock->edge_trigger) {\n\t\t\t\tuwsgi_post_accept(wsgi_req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\tthunder_unlock;\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\treturn -1;\n}\n\n// translate a OS env to a uWSGI option\nvoid env_to_arg(char *src, char *dst) {\n\tint i;\n\tint val = 0;\n\n\tfor (i = 0; i < (int) strlen(src); i++) {\n\t\tif (src[i] == '=') {\n\t\t\tval = 1;\n\t\t}\n\t\tif (val) {\n\t\t\tdst[i] = src[i];\n\t\t}\n\t\telse {\n\t\t\tdst[i] = tolower((int) src[i]);\n\t\t\tif (dst[i] == '_') {\n\t\t\t\tdst[i] = '-';\n\t\t\t}\n\t\t}\n\t}\n\n\tdst[strlen(src)] = 0;\n}\n\n// parse OS envs\nvoid parse_sys_envs(char **envs) {\n\n\tchar **uenvs = envs;\n\tchar *earg, *eq_pos;\n\n\twhile (*uenvs) {\n\t\tif (!strncmp(*uenvs, \"UWSGI_\", 6) && strncmp(*uenvs, \"UWSGI_RELOADS=\", 14) && strncmp(*uenvs, \"UWSGI_VASSALS_DIR=\", 18) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD=\", 17) && strncmp(*uenvs, \"UWSGI_BROODLORD_NUM=\", 20) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD_CONFIG=\", 24) && strncmp(*uenvs, \"UWSGI_EMPEROR_PROXY=\", 20) && strncmp(*uenvs, \"UWSGI_JAIL_PID=\", 15) && strncmp(*uenvs, \"UWSGI_ORIGINAL_PROC_NAME=\", 25)) {\n\t\t\tearg = uwsgi_malloc(strlen(*uenvs + 6) + 1);\n\t\t\tenv_to_arg(*uenvs + 6, earg);\n\t\t\teq_pos = strchr(earg, '=');\n\t\t\tif (!eq_pos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq_pos[0] = 0;\n\n\t\t\tadd_exported_option(earg, eq_pos + 1, 0);\n\t\t}\n\t\tuenvs++;\n\t}\n\n}\n\n// get the application id\nint uwsgi_get_app_id(struct wsgi_request *wsgi_req, char *key, uint16_t key_len, int modifier1) {\n\n\tint i;\n\tstruct stat st;\n\tint found;\n\n\tchar *app_name = key;\n\tuint16_t app_name_len = key_len;\n\n\tif (app_name_len == 0 && wsgi_req) {\n\t\tapp_name = wsgi_req->appid;\n\t\tapp_name_len = wsgi_req->appid_len;\n\t\tif (app_name_len == 0) {\n\t\t\tif (!uwsgi.ignore_script_name) {\n\t\t\t\tapp_name = wsgi_req->script_name;\n\t\t\t\tapp_name_len = wsgi_req->script_name_len;\n\t\t\t}\n\n\t\t\tif (uwsgi.vhost) {\n\t\t\t\tchar *vhost_name = uwsgi_concat3n(wsgi_req->host, wsgi_req->host_len, \"|\", 1, wsgi_req->script_name, wsgi_req->script_name_len);\n\t\t\t\tapp_name_len = wsgi_req->host_len + 1 + wsgi_req->script_name_len;\n\t\t\t\tapp_name = uwsgi_req_append(wsgi_req, \"UWSGI_APPID\", 11, vhost_name, app_name_len);\n\t\t\t\tfree(vhost_name);\n\t\t\t\tif (!app_name) {\n\t\t\t\t\tuwsgi_log(\"unable to add UWSGI_APPID to the uwsgi buffer, consider increasing it\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_debug(\"VirtualHost KEY=%.*s\\n\", app_name_len, app_name);\n#endif\n\t\t\t}\n\t\t\twsgi_req->appid = app_name;\n\t\t\twsgi_req->appid_len = app_name_len;\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < uwsgi_apps_cnt; i++) {\n\t\t// reset check\n\t\tfound = 0;\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"searching for %.*s in %.*s %p\\n\", app_name_len, app_name, uwsgi_apps[i].mountpoint_len, uwsgi_apps[i].mountpoint, uwsgi_apps[i].callable);\n#endif\n\t\tif (!uwsgi_apps[i].callable) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!uwsgi_strncmp(uwsgi_apps[i].mountpoint, uwsgi_apps[i].mountpoint_len, app_name, app_name_len)) {\n\t\t\tfound = 1;\n\t\t}\n\n\t\tif (found) {\n\t\t\tif (uwsgi_apps[i].touch_reload[0]) {\n\t\t\t\tif (!stat(uwsgi_apps[i].touch_reload, &st)) {\n\t\t\t\t\tif (st.st_mtime != uwsgi_apps[i].touch_reload_mtime) {\n\t\t\t\t\t\t// serve the new request and reload\n\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\t\t\t\t\t\tif (uwsgi.threads > 1) {\n\t\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].destroy = 1;\n\t\t\t\t\t\t}\n\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"mtime %d %d\\n\", st.st_mtime, uwsgi_apps[i].touch_reload_mtime);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (modifier1 == -1)\n\t\t\t\treturn i;\n\t\t\tif (modifier1 == uwsgi_apps[i].modifier1)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nchar *uwsgi_substitute(char *src, char *what, char *with) {\n\n\tint count = 0;\n\tif (!with)\n\t\treturn src;\n\n\tsize_t len = strlen(src);\n\tsize_t wlen = strlen(what);\n\tsize_t with_len = strlen(with);\n\n\tchar *p = strstr(src, what);\n\tif (!p) {\n\t\treturn src;\n\t}\n\n\twhile (p) {\n\t\tcount++;\n\t\tp = strstr(p + wlen, what);\n\t}\n\n\tlen += (count * with_len) + 1;\n\n\tchar *dst = uwsgi_calloc(len);\n\tchar *ptr = src;\n\n\tp = strstr(ptr, what);\n\twhile (p) {\n\t\tstrncat(dst, ptr, (p - ptr));\n\t\tstrncat(dst, with, with_len);\n\t\tptr = p + wlen;\n\t\tp = strstr(ptr, what);\n\t}\n\n\tstrncat(dst, ptr, strlen(ptr));\n\n\treturn dst;\n}\n\nint uwsgi_is_file(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_file2(char *filename, struct stat *st) {\n\tif (stat(filename, st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st->st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nint uwsgi_is_dir(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISDIR(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_link(char *filename) {\n\tstruct stat st;\n\tif (lstat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISLNK(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid *uwsgi_malloc(size_t size) {\n\n\tchar *ptr = malloc(size);\n\tif (ptr == NULL) {\n\t\tuwsgi_error(\"malloc()\");\n\t\tuwsgi_log(\"!!! tried memory allocation of %llu bytes !!!\\n\", (unsigned long long) size);\n\t\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\t\texit(1);\n\t}\n\n\treturn ptr;\n}\n\nvoid *uwsgi_calloc(size_t size) {\n\t// thanks Mathieu Dupuy for pointing out that calloc is faster\n\t// than malloc + memset\n\tchar *ptr = calloc(1, size);\n\tif (ptr == NULL) {\n\t\tuwsgi_error(\"calloc()\");\n\t\tuwsgi_log(\"!!! tried memory allocation of %llu bytes !!!\\n\", (unsigned long long) size);\n\t\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\t\texit(1);\n\t}\n\treturn ptr;\n}\n\n#ifdef AF_INET6\n#define ADDR_AF_INET_FAMILY(addrtype) (addrtype == AF_INET || addrtype == AF_INET6)\n#else\n#define ADDR_AF_INET_FAMILY(addrtype) (addrtype == AF_INET)\n#endif\n\nchar *uwsgi_resolve_ip(char *domain) {\n\n\tstruct hostent *he;\n\n\the = gethostbyname(domain);\n\tif (!he || !*he->h_addr_list || !ADDR_AF_INET_FAMILY(he->h_addrtype)) {\n\t\treturn NULL;\n\t}\n\n\treturn inet_ntoa(*(struct in_addr *) he->h_addr_list[0]);\n}\n\nint uwsgi_file_exists(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK);\n}\n\nint uwsgi_file_executable(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK | X_OK);\n}\n\nchar *magic_sub(char *buffer, size_t len, size_t * size, char *magic_table[]) {\n\n\tsize_t i;\n\tsize_t magic_len = 0;\n\tchar *magic_buf = uwsgi_malloc(len);\n\tchar *magic_ptr = magic_buf;\n\tchar *old_magic_buf;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == '%' && (i + 1) < len && magic_table[(unsigned char) buffer[i + 1]]) {\n\t\t\told_magic_buf = magic_buf;\n\t\t\tmagic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i - 2);\n\t\t\tfree(old_magic_buf);\n\t\t\tmagic_len += strlen(magic_table[(unsigned char) buffer[i + 1]]);\n\t\t\tmagic_ptr = magic_buf + magic_len;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\t*magic_ptr = buffer[i];\n\t\t\tmagic_ptr++;\n\t\t\tmagic_len++;\n\t\t}\n\t}\n\n\t*size = magic_len;\n\n\treturn magic_buf;\n\n}\n\nvoid init_magic_table(char *magic_table[]) {\n\n\tint i;\n\tfor (i = 0; i <= 0xff; i++) {\n\t\tmagic_table[i] = \"\";\n\t}\n\n\tmagic_table['%'] = \"%\";\n\tmagic_table['('] = \"%(\";\n}\n\nchar *uwsgi_num2str(int num) {\n\n\tchar *str = uwsgi_malloc(11);\n\n\tsnprintf(str, 11, \"%d\", num);\n\treturn str;\n}\n\nchar *uwsgi_64bit2str(int64_t num) {\n\tchar *str = uwsgi_malloc(sizeof(MAX64_STR) + 1);\n\tsnprintf(str, sizeof(MAX64_STR) + 1, \"%lld\", (long long) num);\n\treturn str;\n}\n\nint uwsgi_num2str2(int num, char *ptr) {\n\n\treturn snprintf(ptr, 11, \"%d\", num);\n}\n\nint uwsgi_num2str2n(int num, char *ptr, int size) {\n\treturn snprintf(ptr, size, \"%d\", num);\n}\n\nint uwsgi_long2str2n(unsigned long long num, char *ptr, int size) {\n\tint ret = snprintf(ptr, size, \"%llu\", num);\n\tif (ret <= 0 || ret > size)\n\t\treturn 0;\n\treturn ret;\n}\n\nint is_unix(char *socket_name, int len) {\n\treturn !memchr(socket_name, ':', len);\n}\n\nint is_a_number(char *what) {\n\tint i;\n\n\tfor (i = 0; i < (int) strlen(what); i++) {\n\t\tif (!isdigit((int) what[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_unix_signal(int signum, void (*func) (int)) {\n\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\n\tsa.sa_handler = func;\n\n\tsigemptyset(&sa.sa_mask);\n\n\tif (sigaction(signum, &sa, NULL) < 0) {\n\t\tuwsgi_error(\"sigaction()\");\n\t}\n}\n\nint uwsgi_list_has_num(char *list, int num) {\n\n\tchar *list2 = uwsgi_concat2(list, \"\");\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \",\", p, ctx) {\n\t\tif (atoi(p) == num) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nint uwsgi_list_has_str(char *list, char *str) {\n\n\tchar *list2 = uwsgi_str(list);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \" \", p, ctx) {\n\t\tif (!strcasecmp(p, str)) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nstatic char hex2num(char *str) {\n\n\tchar val = 0;\n\n\tval <<= 4;\n\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tval += str[0] & 0x0F;\n\t}\n\telse if (str[0] >= 'A' && str[0] <= 'F') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse if (str[0] >= 'a' && str[0] <= 'f') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\tval <<= 4;\n\n\tif (str[1] >= '0' && str[1] <= '9') {\n\t\tval += str[1] & 0x0F;\n\t}\n\telse if (str[1] >= 'A' && str[1] <= 'F') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse if (str[1] >= 'a' && str[1] <= 'f') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\n\nint uwsgi_str2_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 10 * (str[0] - 48);\n\tnum += str[1] - 48;\n\n\treturn num;\n}\n\nint uwsgi_str3_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 100 * (str[0] - 48);\n\tnum += 10 * (str[1] - 48);\n\tnum += str[2] - 48;\n\n\treturn num;\n}\n\n\nint uwsgi_str4_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 1000 * (str[0] - 48);\n\tnum += 100 * (str[1] - 48);\n\tnum += 10 * (str[2] - 48);\n\tnum += str[3] - 48;\n\n\treturn num;\n}\n\nuint64_t uwsgi_str_num(char *str, int len) {\n\n\tint i;\n\tuint64_t num = 0;\n\n\tuint64_t delta = pow(10, len);\n\n\tfor (i = 0; i < len; i++) {\n\t\tdelta = delta / 10;\n\t\tnum += delta * (str[i] - 48);\n\t}\n\n\treturn num;\n}\n\nchar *uwsgi_split3(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2) {\n\t\tif (*part2 + *part2_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part3 = *part2 + *part2_len + 1;\n\t\t*part3_len = (buf + len) - *part3;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_split4(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len, char **part4, size_t * part4_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\t*part4 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\t// get part3\n\t\t\telse if (status == 2) {\n\t\t\t\t*part3 = *part2 + *part2_len + 1;\n\t\t\t\t*part3_len = (buf + i) - *part3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2 && *part3) {\n\t\tif (*part3 + *part3_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part4 = *part3 + *part3_len + 1;\n\t\t*part4_len = (buf + len) - *part4;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\n\nchar *uwsgi_netstring(char *buf, size_t len, char **netstring, size_t * netstring_len) {\n\n\tchar *ptr = buf;\n\tchar *watermark = buf + len;\n\t*netstring_len = 0;\n\n\twhile (ptr < watermark) {\n\t\t// end of string size ?\n\t\tif (*ptr == ':') {\n\t\t\t*netstring_len = uwsgi_str_num(buf, ptr - buf);\n\n\t\t\tif (ptr + *netstring_len + 2 > watermark) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*netstring = ptr + 1;\n\t\t\treturn ptr + *netstring_len + 2;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_dyn_dict *uwsgi_dyn_dict_new(struct uwsgi_dyn_dict **dd, char *key, int keylen, char *val, int vallen) {\n\n\tstruct uwsgi_dyn_dict *uwsgi_dd = *dd, *old_dd;\n\n\tif (!uwsgi_dd) {\n\t\t*dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\tuwsgi_dd = *dd;\n\t\tuwsgi_dd->prev = NULL;\n\t}\n\telse {\n\t\twhile (uwsgi_dd) {\n\t\t\told_dd = uwsgi_dd;\n\t\t\tuwsgi_dd = uwsgi_dd->next;\n\t\t}\n\n\t\tuwsgi_dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\told_dd->next = uwsgi_dd;\n\t\tuwsgi_dd->prev = old_dd;\n\t}\n\n\tuwsgi_dd->key = key;\n\tuwsgi_dd->keylen = keylen;\n\tuwsgi_dd->value = val;\n\tuwsgi_dd->vallen = vallen;\n\tuwsgi_dd->hits = 0;\n\tuwsgi_dd->status = 0;\n\tuwsgi_dd->next = NULL;\n\n\treturn uwsgi_dd;\n}\n\nvoid uwsgi_dyn_dict_del(struct uwsgi_dyn_dict *item) {\n\n\tstruct uwsgi_dyn_dict *prev = item->prev;\n\tstruct uwsgi_dyn_dict *next = item->next;\n\n\tif (prev) {\n\t\tprev->next = next;\n\t}\n\n\tif (next) {\n\t\tnext->prev = prev;\n\t}\n\n\tfree(item);\n}\n\nvoid uwsgi_dyn_dict_free(struct uwsgi_dyn_dict **dd) {\n\tstruct uwsgi_dyn_dict *attr = *dd;\n\n\twhile(attr) {\n\t\tstruct uwsgi_dyn_dict *tmp = attr;\n\t\tattr = attr->next;\n\t\tif (tmp->value) free(tmp->value);\n\t\tfree(tmp);\n\t}\n\n\t*dd = NULL;\n}\n\nvoid *uwsgi_malloc_shared(size_t size) {\n\n\tvoid *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);\n\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_log(\"unable to allocate %llu bytes (%lluMB)\\n\", (unsigned long long) size, (unsigned long long) (size / (1024 * 1024)));\n\t\tuwsgi_error(\"mmap()\");\n\t\texit(1);\n\t}\n\n\treturn addr;\n}\n\nvoid *uwsgi_calloc_shared(size_t size) {\n\tvoid *ptr = uwsgi_malloc_shared(size);\n\t// NOTE by Mathieu Dupuy:\n\t// OSes guarantee mmap MAP_ANON memory area to be zero-filled (see man pages)\n\n\t// we should trust it, but history has taught us it is better to be paranoid.\n\t// Lucky enough this function is called ony in startup phases, so performance\n\t// tips/tricks are irrelevant (So, le'ts call memset...)\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n\n\nstruct uwsgi_string_list *uwsgi_string_new_list(struct uwsgi_string_list **list, char *value) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string;\n\n\tif (!uwsgi_string) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\tuwsgi_string = *list;\n\t}\n\telse {\n\t\twhile (uwsgi_string) {\n\t\t\told_uwsgi_string = uwsgi_string;\n\t\t\tuwsgi_string = uwsgi_string->next;\n\t\t}\n\n\t\tuwsgi_string = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\told_uwsgi_string->next = uwsgi_string;\n\t}\n\n\tuwsgi_string->value = value;\n\tuwsgi_string->len = 0;\n\tif (value) {\n\t\tuwsgi_string->len = strlen(value);\n\t}\n\tuwsgi_string->next = NULL;\n\tuwsgi_string->custom = 0;\n\tuwsgi_string->custom2 = 0;\n\tuwsgi_string->custom_ptr = NULL;\n\n\treturn uwsgi_string;\n}\n\n#ifdef UWSGI_PCRE\nstruct uwsgi_regexp_list *uwsgi_regexp_custom_new_list(struct uwsgi_regexp_list **list, char *value, char *custom) {\n\n\tstruct uwsgi_regexp_list *url = *list, *old_url;\n\n\tif (!url) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\turl = *list;\n\t}\n\telse {\n\t\twhile (url) {\n\t\t\told_url = url;\n\t\t\turl = url->next;\n\t\t}\n\n\t\turl = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\told_url->next = url;\n\t}\n\n\tif (uwsgi_regexp_build(value, &url->pattern, &url->pattern_extra)) {\n\t\texit(1);\n\t}\n\turl->next = NULL;\n\turl->custom = 0;\n\turl->custom_ptr = NULL;\n\turl->custom_str = custom;\n\n\treturn url;\n}\n\nint uwsgi_regexp_match_pattern(char *pattern, char *str) {\n\n\tpcre *regexp;\n\tpcre_extra *regexp_extra;\n\n\tif (uwsgi_regexp_build(pattern, &regexp, &regexp_extra))\n\t\treturn 1;\n\treturn !uwsgi_regexp_match(regexp, regexp_extra, str, strlen(str));\n}\n\n\n#endif\n\nchar *uwsgi_string_get_list(struct uwsgi_string_list **list, int pos, size_t * len) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list;\n\tint counter = 0;\n\n\twhile (uwsgi_string) {\n\t\tif (counter == pos) {\n\t\t\t*len = uwsgi_string->len;\n\t\t\treturn uwsgi_string->value;\n\t\t}\n\t\tuwsgi_string = uwsgi_string->next;\n\t\tcounter++;\n\t}\n\n\t*len = 0;\n\treturn NULL;\n\n}\n\n\nvoid uwsgi_string_del_list(struct uwsgi_string_list **list, struct uwsgi_string_list *item) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string = NULL;\n\n\twhile (uwsgi_string) {\n\t\tif (uwsgi_string == item) {\n\t\t\t// parent instance ?\n\t\t\tif (old_uwsgi_string == NULL) {\n\t\t\t\t*list = uwsgi_string->next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\told_uwsgi_string->next = uwsgi_string->next;\n\t\t\t}\n\n\t\t\tfree(uwsgi_string);\n\t\t\treturn;\n\t\t}\n\n\t\told_uwsgi_string = uwsgi_string;\n\t\tuwsgi_string = uwsgi_string->next;\n\t}\n\n}\n\nvoid uwsgi_sig_pause() {\n\n\tsigset_t mask;\n\tsigemptyset(&mask);\n\tsigsuspend(&mask);\n}\n\nchar *uwsgi_binsh() {\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.binsh) {\n\t\tif (uwsgi_file_executable(usl->value)) {\n\t\t\treturn usl->value;\n\t\t}\n\t}\n\treturn \"/bin/sh\";\n}\n\nvoid uwsgi_exec_command_with_args(char *cmdline) {\n\tchar *argv[4];\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = cmdline;\n\targv[3] = NULL;\n\texecvp(argv[0], argv);\n\tuwsgi_error(\"execvp()\");\n\texit(1);\n}\n\nstatic int uwsgi_run_command_do(char *command, char *arg) {\n\n\tchar *argv[4];\n\n#ifdef __linux__\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tuwsgi_error(\"prctl()\");\n\t}\n#endif\n\n\tif (command == NULL) {\n\t\targv[0] = uwsgi_binsh();\n\t\targv[1] = \"-c\";\n\t\targv[2] = arg;\n\t\targv[3] = NULL;\n\t\texecvp(argv[0], argv);\n\t}\n\telse {\n\t\targv[0] = command;\n\t\targv[1] = arg;\n\t\targv[2] = NULL;\n\t\texecvp(command, argv);\n\t}\n\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_run_command_and_wait(char *command, char *arg) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\treturn uwsgi_run_command_do(command, arg);\n}\n\nint uwsgi_run_command_putenv_and_wait(char *command, char *arg, char **envs, unsigned int nenvs) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\n\tunsigned int i;\n\tfor (i = 0; i < nenvs; i++) {\n\t\tif (putenv(envs[i])) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_putenv_and_wait()/putenv()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn uwsgi_run_command_do(command, arg);\n}\n\n\npid_t uwsgi_run_command(char *command, int *stdin_fd, int stdout_fd) {\n\n\tchar *argv[4];\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (stdin_fd && stdin_fd[0] > -1) {\n\t\t\tclose(stdin_fd[0]);\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tclose(stdout_fd);\n\t\t}\n\t\tif (waitpid(pid, &waitpid_status, WNOHANG) < 0) {\n\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn pid;\n\t}\n\n\tuwsgi_close_all_sockets();\n\t//uwsgi_close_all_fds();\n\tint i;\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n\t\tif (stdin_fd) {\n\t\t\tif (i == stdin_fd[0] || i == stdin_fd[1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tif (i == stdout_fd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#ifdef __APPLE__\n\t\tfcntl(i, F_SETFD, FD_CLOEXEC);\n#else\n\t\tclose(i);\n#endif\n\t}\n\n\n\n\tif (stdin_fd) {\n\t\tclose(stdin_fd[1]);\n\t}\n\telse {\n\t\tif (!uwsgi_valid_fd(0)) {\n\t\t\tint in_fd = open(\"/dev/null\", O_RDONLY);\n\t\t\tif (in_fd < 0) {\n\t\t\t\tuwsgi_error_open(\"/dev/null\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (in_fd != 0) {\n\t\t\t\t\tif (dup2(in_fd, 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stdout_fd > -1 && stdout_fd != 1) {\n\t\tif (dup2(stdout_fd, 1) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (stdin_fd && stdin_fd[0] > -1 && stdin_fd[0] != 0) {\n\t\tif (dup2(stdin_fd[0], 0) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = command;\n\targv[3] = NULL;\n\n\texecvp(uwsgi_binsh(), argv);\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_endswith(char *str1, char *str2) {\n\n\tsize_t i;\n\tsize_t str1len = strlen(str1);\n\tsize_t str2len = strlen(str2);\n\tchar *ptr;\n\n\tif (str2len > str1len)\n\t\treturn 0;\n\n\tptr = (str1 + str1len) - str2len;\n\n\tfor (i = 0; i < str2len; i++) {\n\t\tif (*ptr != str2[i])\n\t\t\treturn 0;\n\t\tptr++;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_chown(char *filename, char *owner) {\n\n\tuid_t new_uid = -1;\n\tuid_t new_gid = -1;\n\tstruct group *new_group = NULL;\n\tstruct passwd *new_user = NULL;\n\n\tchar *colon = strchr(owner, ':');\n\tif (colon) {\n\t\tcolon[0] = 0;\n\t}\n\n\n\tif (is_a_number(owner)) {\n\t\tnew_uid = atoi(owner);\n\t}\n\telse {\n\t\tnew_user = getpwnam(owner);\n\t\tif (!new_user) {\n\t\t\tuwsgi_log(\"unable to find user %s\\n\", owner);\n\t\t\texit(1);\n\t\t}\n\t\tnew_uid = new_user->pw_uid;\n\t}\n\n\tif (colon) {\n\t\tcolon[0] = ':';\n\t\tif (is_a_number(colon + 1)) {\n\t\t\tnew_gid = atoi(colon + 1);\n\t\t}\n\t\telse {\n\t\t\tnew_group = getgrnam(colon + 1);\n\t\t\tif (!new_group) {\n\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", colon + 1);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnew_gid = new_group->gr_gid;\n\t\t}\n\t}\n\n\tif (chown(filename, new_uid, new_gid)) {\n\t\tuwsgi_error(\"chown()\");\n\t\texit(1);\n\t}\n\n}\n\nchar *uwsgi_get_binary_path(char *argvzero) {\n\n#if defined(__linux__) || defined(__CYGWIN__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/self/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(_WIN32)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tif (GetModuleFileName(NULL, buf, PATH_MAX) > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__NetBSD__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/curproc/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\n\tif (realpath(argvzero, buf)) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__APPLE__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tuint32_t len = uwsgi.page_size;\n\tif (_NSGetExecutablePath(buf, &len) == 0) {\n\t\t// return only absolute path\n#ifndef OLD_REALPATH\n\t\tchar *newbuf = realpath(buf, NULL);\n\t\tif (newbuf) {\n\t\t\tfree(buf);\n\t\t\treturn newbuf;\n\t\t}\n#endif\n\t}\n\tfree(buf);\n#elif defined(__sun__)\n\t// do not free this value !!!\n\tchar *buf = (char *) getexecname();\n\tif (buf) {\n\t\t// return only absolute path\n\t\tif (buf[0] == '/') {\n\t\t\treturn buf;\n\t\t}\n\n\t\tchar *newbuf = uwsgi_malloc(PATH_MAX + 1);\n\t\tif (realpath(buf, newbuf)) {\n\t\t\treturn newbuf;\n\t\t}\n\t}\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tsize_t len = uwsgi.page_size;\n\tint mib[4];\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PATHNAME;\n\tmib[3] = -1;\n\tif (sysctl(mib, 4, buf, &len, NULL, 0) == 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#endif\n\n\n\treturn argvzero;\n\n}\n\nchar *uwsgi_get_line(char *ptr, char *watermark, int *size) {\n\tchar *p = ptr;\n\tint count = 0;\n\n\twhile (p < watermark) {\n\t\tif (*p == '\\n') {\n\t\t\t*size = count;\n\t\t\treturn ptr + count;\n\t\t}\n\t\tcount++;\n\t\tp++;\n\t}\n\n\treturn NULL;\n}\n\nvoid uwsgi_build_mime_dict(char *filename) {\n\n\tsize_t size = 0;\n\tchar *buf = uwsgi_open_and_read(filename, &size, 1, NULL);\n\tchar *watermark = buf + size;\n\n\tint linesize = 0;\n\tchar *line = buf;\n\tint i;\n\tint type_size = 0;\n\tint ext_start = 0;\n\tint found;\n\tint entries = 0;\n\n\tuwsgi_log(\"building mime-types dictionary from file %s...\", filename);\n\n\twhile (uwsgi_get_line(line, watermark, &linesize) != NULL) {\n\t\tfound = 0;\n\t\tif (isalnum((int) line[0])) {\n\t\t\t// get the type size\n\t\t\tfor (i = 0; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n\t\t\t\t\ttype_size = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 0;\n\t\t\tfor (i = type_size; i < linesize; i++) {\n\t\t\t\tif (!isblank((int) line[i])) {\n\t\t\t\t\text_start = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *current = line + ext_start;\n\t\t\tint ext_size = 0;\n\t\t\tfor (i = ext_start; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n#ifdef UWSGI_DEBUG\n\t\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\t\tentries++;\n\t\t\t\t\text_size = 0;\n\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (current == NULL) {\n\t\t\t\t\tcurrent = line + i;\n\t\t\t\t}\n\t\t\t\text_size++;\n\t\t\t}\n\t\t\tif (current && ext_size > 1) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\tentries++;\n\t\t\t}\n\n\t\t}\n\t\tline += linesize + 1;\n\t}\n\n\tuwsgi_log(\"%d entry found\\n\", entries);\n\n}\n\n#ifdef __linux__\nstruct uwsgi_unshare_id {\n\tchar *name;\n\tint value;\n};\n\nstatic struct uwsgi_unshare_id uwsgi_unshare_list[] = {\n#ifdef CLONE_FILES\n\t{\"files\", CLONE_FILES},\n#endif\n#ifdef CLONE_NEWIPC\n\t{\"ipc\", CLONE_NEWIPC},\n#endif\n#ifdef CLONE_NEWNET\n\t{\"net\", CLONE_NEWNET},\n#endif\n#ifdef CLONE_IO\n\t{\"io\", CLONE_IO},\n#endif\n#ifdef CLONE_PARENT\n\t{\"parent\", CLONE_PARENT},\n#endif\n#ifdef CLONE_NEWPID\n\t{\"pid\", CLONE_NEWPID},\n#endif\n#ifdef CLONE_NEWNS\n\t{\"ns\", CLONE_NEWNS},\n\t{\"fs\", CLONE_NEWNS},\n\t{\"mount\", CLONE_NEWNS},\n\t{\"mnt\", CLONE_NEWNS},\n#endif\n#ifdef CLONE_SYSVSEM\n\t{\"sysvsem\", CLONE_SYSVSEM},\n#endif\n#ifdef CLONE_NEWUTS\n\t{\"uts\", CLONE_NEWUTS},\n#endif\n#ifdef CLONE_NEWUSER\n\t{\"user\", CLONE_NEWUSER},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_unshare_id(char *name) {\n\n\tstruct uwsgi_unshare_id *uui = uwsgi_unshare_list;\n\twhile (uui->name) {\n\t\tif (!strcmp(uui->name, name))\n\t\t\treturn uui->value;\n\t\tuui++;\n\t}\n\n\treturn -1;\n}\n\nvoid uwsgi_build_unshare(char *what, int *mask) {\n\n\tchar *list = uwsgi_str(what);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list, \",\", p, ctx) {\n\t\tint u_id = uwsgi_get_unshare_id(p);\n\t\tif (u_id != -1) {\n\t\t\t*mask |= u_id;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unknown namespace subsystem: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(list);\n}\n\n\n#endif\n\n#ifdef UWSGI_CAP\nstruct uwsgi_cap {\n\tchar *name;\n\tcap_value_t value;\n};\n\nstatic struct uwsgi_cap uwsgi_cap_list[] = {\n\t{\"chown\", CAP_CHOWN},\n\t{\"dac_override\", CAP_DAC_OVERRIDE},\n\t{\"dac_read_search\", CAP_DAC_READ_SEARCH},\n\t{\"fowner\", CAP_FOWNER},\n\t{\"fsetid\", CAP_FSETID},\n\t{\"kill\", CAP_KILL},\n\t{\"setgid\", CAP_SETGID},\n\t{\"setuid\", CAP_SETUID},\n\t{\"setpcap\", CAP_SETPCAP},\n\t{\"linux_immutable\", CAP_LINUX_IMMUTABLE},\n\t{\"net_bind_service\", CAP_NET_BIND_SERVICE},\n\t{\"net_broadcast\", CAP_NET_BROADCAST},\n\t{\"net_admin\", CAP_NET_ADMIN},\n\t{\"net_raw\", CAP_NET_RAW},\n\t{\"ipc_lock\", CAP_IPC_LOCK},\n\t{\"ipc_owner\", CAP_IPC_OWNER},\n\t{\"sys_module\", CAP_SYS_MODULE},\n\t{\"sys_rawio\", CAP_SYS_RAWIO},\n\t{\"sys_chroot\", CAP_SYS_CHROOT},\n\t{\"sys_ptrace\", CAP_SYS_PTRACE},\n\t{\"sys_pacct\", CAP_SYS_PACCT},\n\t{\"sys_admin\", CAP_SYS_ADMIN},\n\t{\"sys_boot\", CAP_SYS_BOOT},\n\t{\"sys_nice\", CAP_SYS_NICE},\n\t{\"sys_resource\", CAP_SYS_RESOURCE},\n\t{\"sys_time\", CAP_SYS_TIME},\n\t{\"sys_tty_config\", CAP_SYS_TTY_CONFIG},\n\t{\"mknod\", CAP_MKNOD},\n#ifdef CAP_LEASE\n\t{\"lease\", CAP_LEASE},\n#endif\n#ifdef CAP_AUDIT_WRITE\n\t{\"audit_write\", CAP_AUDIT_WRITE},\n#endif\n#ifdef CAP_AUDIT_CONTROL\n\t{\"audit_control\", CAP_AUDIT_CONTROL},\n#endif\n#ifdef CAP_SETFCAP\n\t{\"setfcap\", CAP_SETFCAP},\n#endif\n#ifdef CAP_MAC_OVERRIDE\n\t{\"mac_override\", CAP_MAC_OVERRIDE},\n#endif\n#ifdef CAP_MAC_ADMIN\n\t{\"mac_admin\", CAP_MAC_ADMIN},\n#endif\n#ifdef CAP_SYSLOG\n\t{\"syslog\", CAP_SYSLOG},\n#endif\n#ifdef CAP_WAKE_ALARM\n\t{\"wake_alarm\", CAP_WAKE_ALARM},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_cap_id(char *name) {\n\n\tstruct uwsgi_cap *ucl = uwsgi_cap_list;\n\twhile (ucl->name) {\n\t\tif (!strcmp(ucl->name, name))\n\t\t\treturn ucl->value;\n\t\tucl++;\n\t}\n\n\treturn -1;\n}\n\nint uwsgi_build_cap(char *what, cap_value_t ** cap) {\n\n\tint cap_id;\n\tchar *caps = uwsgi_str(what);\n\tint pos = 0;\n\tint count = 0;\n\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t\tif (cap_id != -1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t}\n\tfree(caps);\n\n\t*cap = uwsgi_malloc(sizeof(cap_value_t) * count);\n\n\tcaps = uwsgi_str(what);\n\tctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcap_id = atoi(p);\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t}\n\t\tif (cap_id != -1) {\n\t\t\t(*cap)[pos] = cap_id;\n\t\t\tuwsgi_log(\"setting capability %s [%d]\\n\", p, cap_id);\n\t\t\tpos++;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t}\n\t}\n\tfree(caps);\n\n\treturn count;\n}\n\n#endif\n\nvoid uwsgi_apply_config_pass(char symbol, char *(*hook) (char *)) {\n\n\tint i, j;\n\n\tfor (i = 0; i < uwsgi.exported_opts_cnt; i++) {\n\t\tint has_symbol = 0;\n\t\tint depth = 0;\n\t\tchar *magic_key = NULL;\n\t\tchar *magic_val = NULL;\n\t\tif (uwsgi.exported_opts[i]->value && !uwsgi.exported_opts[i]->configured) {\n\t\t\tfor (j = 0; j < (int) strlen(uwsgi.exported_opts[i]->value); j++) {\n\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == symbol) {\n\t\t\t\t\thas_symbol = 1;\n\t\t\t\t}\n\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == '(' && has_symbol == 1) {\n\t\t\t\t\thas_symbol = 2;\n\t\t\t\t\tdepth = 0;\n\t\t\t\t\tmagic_key = uwsgi.exported_opts[i]->value + j + 1;\n\t\t\t\t}\n\t\t\t\telse if (has_symbol > 1) {\n\t\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == '(') {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == ')') {\n\t\t\t\t\t\tif (depth > 0) {\n\t\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (has_symbol <= 2) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"need to interpret the %.*s tag\\n\", has_symbol - 2, magic_key);\n#endif\n\t\t\t\t\t\tchar *tmp_magic_key = uwsgi_concat2n(magic_key, has_symbol - 2, \"\", 0);\n\t\t\t\t\t\tmagic_val = hook(tmp_magic_key);\n\t\t\t\t\t\tfree(tmp_magic_key);\n\t\t\t\t\t\tif (!magic_val) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuwsgi.exported_opts[i]->value = uwsgi_concat4n(uwsgi.exported_opts[i]->value, (magic_key - 2) - uwsgi.exported_opts[i]->value, magic_val, strlen(magic_val), magic_key + (has_symbol - 1), strlen(magic_key + (has_symbol - 1)), \"\", 0);\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"computed new value = %s\\n\", uwsgi.exported_opts[i]->value);\n#endif\n\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thas_symbol = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_set_processname(char *name) {\n\n#if defined(__linux__) || defined(__sun__)\n\tsize_t amount = 0;\n\tsize_t max_procname = uwsgi.argv_len + uwsgi.environ_len;\n\n\t// prepare for strncat\n\t*uwsgi.orig_argv[0] = 0;\n\n\tif (uwsgi.procname_prefix) {\n\t\tamount += strlen(uwsgi.procname_prefix);\n\t\tif (amount >= max_procname)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_prefix, max_procname - (amount + 1));\n\t}\n\n\tamount += strlen(name);\n\tif (amount >= max_procname)\n\t\treturn;\n\tstrncat(uwsgi.orig_argv[0], name, max_procname - (amount + 1));\n\n\tif (uwsgi.procname_append) {\n\t\tamount += strlen(uwsgi.procname_append);\n\t\tif (amount >= max_procname)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_append, max_procname - (amount + 1));\n\t}\n\n\t// if we fit into argv, only fill argv with spaces, otherwise use environ as well\n\tif (amount < uwsgi.argv_len)  {\n\t\tmax_procname = uwsgi.argv_len;\n\t}\n\t// fill with spaces...\n\tmemset(uwsgi.orig_argv[0] + amount + 1, ' ', max_procname - (amount + 1));\n\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__) || defined(__NetBSD__)\n\tif (uwsgi.procname_prefix) {\n\t\tif (!uwsgi.procname_append) {\n\t\t\tsetproctitle(\"-%s%s\", uwsgi.procname_prefix, name);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse if (uwsgi.procname_append) {\n\t\tif (!uwsgi.procname_prefix) {\n\t\t\tsetproctitle(\"-%s%s\", name, uwsgi.procname_append);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse {\n\t\tsetproctitle(\"-%s\", name);\n\t}\n#endif\n}\n\n// this is a wrapper for fork restoring original argv\npid_t uwsgi_fork(char *name) {\n\n\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\n#ifndef __CYGWIN__\n\t\tif (uwsgi.never_swap) {\n\t\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\t\tuwsgi_error(\"mlockall()\");\n\t\t\t}\n\t\t}\n#endif\n\n#if defined(__linux__) || defined(__sun__)\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.argc; i++) {\n\t\t\t// stop fixing original argv if the new one is bigger\n\t\t\tif (!uwsgi.orig_argv[i]) break;\n\t\t\tstrcpy(uwsgi.orig_argv[i], uwsgi.argv[i]);\n\t\t}\n#endif\n\n\t\tif (uwsgi.auto_procname && name) {\n\t\t\tif (uwsgi.procname) {\n\t\t\t\tuwsgi_set_processname(uwsgi.procname);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_set_processname(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pid;\n}\n\nvoid escape_shell_arg(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (strchr(\"&;`'\\\"|*?~<>^()[]{}$\\\\\\n\", src[i])) {\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\t*ptr++ = src[i];\n\t}\n\n\t*ptr++ = 0;\n}\n\nvoid escape_json(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == '\\t') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 't';\n\t\t}\n\t\telse if (src[i] == '\\n') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'n';\n\t\t}\n\t\telse if (src[i] == '\\r') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'r';\n\t\t}\n\t\telse if (src[i] == '\"') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\"';\n\t\t}\n\t\telse if (src[i] == '\\\\') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\t*ptr++ = 0;\n}\n\n/*\n\nbuild PATH_INFO from raw_uri\n\nit manages:\n\n\tpercent encoding\n\tdot_segments removal\n\tstop at the first #\n\n*/\nvoid http_url_decode4(char *buf, uint16_t * len, char *dst, int no_slash_decode) {\n\n\tenum {\n\t\tzero = 0,\n\t\tpercent1,\n\t\tpercent2,\n\t\tslash,\n\t\tdot,\n\t\tdotdot\n\t} status;\n\n\tuint16_t i, current_new_len, new_len = 0;\n\n\tchar value[2];\n\n\tchar *ptr = dst;\n\n\tvalue[0] = '0';\n\tvalue[1] = '0';\n\n\tstatus = zero;\n\tint no_slash = 0;\n\n\tif (*len > 0 && buf[0] != '/') {\n\t\tstatus = slash;\n\t\tno_slash = 1;\n\t}\n\n\tfor (i = 0; i < *len; i++) {\n\t\tchar c = buf[i];\n\t\tif (c == '#')\n\t\t\tbreak;\n\t\tswitch (status) {\n\t\tcase zero:\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\tcase percent1:\n\t\t\tif (c == '%') {\n\t\t\t\t*ptr++ = '%';\n\t\t\t\tnew_len++;\n\t\t\t\tstatus = zero;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[0] = c;\n\t\t\tstatus = percent2;\n\t\t\tbreak;\n\t\tcase percent2:\n\t\t\tvalue[1] = c;\n\t\t\tif (no_slash_decode && value[0] == '2' && (value[1] == 'F' || value[1] == 'f')) {\n\t\t\t\t*ptr++ = '%';\n\t\t\t\t*ptr++ = value[0];\n\t\t\t\t*ptr++ = value[1];\n\t\t\t\tnew_len += 3;\n\t\t\t} else {\n\t\t\t\t*ptr++ = hex2num(value);\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase slash:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// we could be at the first round (in non slash)\n\t\t\tif (i > 0 || !no_slash) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dot:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dotdot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 1) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dotdot:\n\t\t\t// here we need to remove a segment\n\t\t\tif (c == '/') {\n\t\t\t\tcurrent_new_len = new_len;\n\t\t\t\twhile (current_new_len) {\n\t\t\t\t\tcurrent_new_len--;\n\t\t\t\t\tptr--;\n\t\t\t\t\tif (dst[current_new_len] == '/') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnew_len = current_new_len;\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 2) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\t\t// over engineering\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (status) {\n\tcase slash:\n\tcase dot:\n\t\t*ptr++ = '/';\n\t\tnew_len++;\n\t\tbreak;\n\tcase dotdot:\n\t\tcurrent_new_len = new_len;\n\t\twhile (current_new_len) {\n\t\t\tif (dst[current_new_len - 1] == '/') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_new_len--;\n\t\t}\n\t\tnew_len = current_new_len;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*len = new_len;\n\n}\n\n\n/*\n\twe scan the table in reverse, as updated values are at the end\n*/\nchar *uwsgi_get_var(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, uint16_t * len) {\n\n\tint i;\n\n\tfor (i = wsgi_req->var_cnt - 1; i > 0; i -= 2) {\n\t\tif (!uwsgi_strncmp(key, keylen, wsgi_req->hvec[i - 1].iov_base, wsgi_req->hvec[i - 1].iov_len)) {\n\t\t\t*len = wsgi_req->hvec[i].iov_len;\n\t\t\treturn wsgi_req->hvec[i].iov_base;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_app *uwsgi_add_app(int id, uint8_t modifier1, char *mountpoint, int mountpoint_len, void *interpreter, void *callable) {\n\n\tif (id > uwsgi.max_apps) {\n\t\tuwsgi_log(\"FATAL ERROR: you cannot load more than %d apps in a worker\\n\", uwsgi.max_apps);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_app *wi = &uwsgi_apps[id];\n\tmemset(wi, 0, sizeof(struct uwsgi_app));\n\n\twi->modifier1 = modifier1;\n\twi->mountpoint_len = mountpoint_len < 0xff ? mountpoint_len : (0xff - 1);\n\tstrncpy(wi->mountpoint, mountpoint, wi->mountpoint_len);\n\twi->interpreter = interpreter;\n\twi->callable = callable;\n\n\tuwsgi_apps_cnt++;\n\t// check if we need to emulate fork() COW\n\tint i;\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n\n\tif (!uwsgi.no_default_app) {\n\t\tif ((mountpoint_len == 0 || (mountpoint_len == 1 && mountpoint[0] == '/')) && uwsgi.default_app == -1) {\n\t\t\tuwsgi.default_app = id;\n\t\t}\n\t}\n\n\treturn wi;\n}\n\n\nchar *uwsgi_check_touches(struct uwsgi_string_list *touch_list) {\n\n\t// touch->value   - file path\n\t// touch->custom  - file timestamp\n\t// touch->custom2 - 0 if file exists, 1 if it does not exists\n\n\tstruct uwsgi_string_list *touch = touch_list;\n\twhile (touch) {\n\t\tstruct stat tr_st;\n\t\tif (stat(touch->value, &tr_st)) {\n\t\t\tif (touch->custom && !touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File %s was removed\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (!touch->custom && !touch->custom2) {\n\t\t\t\tuwsgi_log(\"unable to stat() %s, events will be triggered as soon as the file is created\\n\", touch->value);\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t}\n\t\t\ttouch->custom = 0;\n\t\t}\n\t\telse {\n\t\t\tif (!touch->custom && touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File was created: %s\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\ttouch->custom2 = 0;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (touch->custom && (uint64_t) tr_st.st_mtime > touch->custom) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] modification detected on %s: %llu -> %llu\\n\", touch->value, (unsigned long long) touch->custom, (unsigned long long) tr_st.st_mtime);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t}\n\t\ttouch = touch->next;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_chomp(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\nchar *uwsgi_chomp2(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n' || str[i] == '\\t' || str[i] == ' ') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n\n\nint uwsgi_tmpfd() {\n\tint fd = -1;\n\tchar *tmpdir = getenv(\"TMPDIR\");\n\tif (!tmpdir) {\n\t\ttmpdir = \"/tmp\";\n\t}\n#ifdef O_TMPFILE\n\tfd = open(tmpdir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\t// fallback to old style\n#endif\n\tchar *template = uwsgi_concat2(tmpdir, \"/uwsgiXXXXXX\");\n\tfd = mkstemp(template);\n\tunlink(template);\n\tfree(template);\n\treturn fd;\n}\n\nFILE *uwsgi_tmpfile() {\n\tint fd = uwsgi_tmpfd();\n\tif (fd < 0)\n\t\treturn NULL;\n\treturn fdopen(fd, \"w+\");\n}\n\nint uwsgi_file_to_string_list(char *filename, struct uwsgi_string_list **list) {\n\n\tchar line[1024];\n\n\tFILE *fh = fopen(filename, \"r\");\n\tif (fh) {\n\t\twhile (fgets(line, 1024, fh)) {\n\t\t\tuwsgi_string_new_list(list, uwsgi_chomp(uwsgi_str(line)));\n\t\t}\n\t\tfclose(fh);\n\t\treturn 1;\n\t}\n\tuwsgi_error_open(filename);\n\treturn 0;\n}\n\nvoid uwsgi_setup_post_buffering() {\n\n\tif (!uwsgi.post_buffering_bufsize)\n\t\tuwsgi.post_buffering_bufsize = 8192;\n\n\tif (uwsgi.post_buffering_bufsize < uwsgi.post_buffering) {\n\t\tuwsgi.post_buffering_bufsize = uwsgi.post_buffering;\n\t\tuwsgi_log(\"setting request body buffering size to %lu bytes\\n\", (unsigned long) uwsgi.post_buffering_bufsize);\n\t}\n\n}\n\nvoid uwsgi_emulate_cow_for_apps(int id) {\n\tint i;\n\t// check if we need to emulate fork() COW\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n}\n\nint uwsgi_write_intfile(char *filename, int n) {\n\tFILE *pidfile = fopen(filename, \"w\");\n\tif (!pidfile) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\tif (fprintf(pidfile, \"%d\\n\", n) <= 0 || ferror(pidfile)) {\n\t\tfclose(pidfile);\n\t\treturn -1;\n\t}\n\tif (fclose(pidfile)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_write_pidfile(char *pidfile_name) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) getpid())) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nvoid uwsgi_write_pidfile_explicit(char *pidfile_name, pid_t pid) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) pid)) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nchar *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}\n\n\nvoid uwsgi_set_cpu_affinity() {\n\tchar buf[4096];\n\tint ret;\n\tint pos = 0;\n\tif (uwsgi.cpu_affinity) {\n\t\tint base_cpu = (uwsgi.mywid - 1) * uwsgi.cpu_affinity;\n\t\tif (base_cpu >= uwsgi.cpus) {\n\t\t\tbase_cpu = base_cpu % uwsgi.cpus;\n\t\t}\n\t\tret = snprintf(buf, 4096, \"mapping worker %d to CPUs:\", uwsgi.mywid);\n\t\tif (ret < 25 || ret >= 4096) {\n\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tpos += ret;\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tcpu_set_t cpuset;\n#elif defined(__FreeBSD__)\n\t\tcpuset_t cpuset;\n#endif\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\t\tCPU_ZERO(&cpuset);\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.cpu_affinity; i++) {\n\t\t\tif (base_cpu >= uwsgi.cpus)\n\t\t\t\tbase_cpu = 0;\n\t\t\tCPU_SET(base_cpu, &cpuset);\n\t\t\tret = snprintf(buf + pos, 4096 - pos, \" %d\", base_cpu);\n\t\t\tif (ret < 2 || ret >= 4096) {\n\t\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpos += ret;\n\t\t\tbase_cpu++;\n\t\t}\n#endif\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tif (sched_setaffinity(0, sizeof(cpu_set_t), &cpuset)) {\n\t\t\tuwsgi_error(\"sched_setaffinity()\");\n\t\t}\n#elif defined(__FreeBSD__)\n\t\tif (cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset), &cpuset)) {\n\t\t\tuwsgi_error(\"cpuset_setaffinity\");\n\t\t}\n#endif\n\t\tuwsgi_log(\"%s\\n\", buf);\n\t}\n\n}\n\n#ifdef UWSGI_ELF\n#if defined(__linux__)\n#include <elf.h>\n#endif\nchar *uwsgi_elf_section(char *filename, char *s, size_t * len) {\n\tstruct stat st;\n\tchar *output = NULL;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st)) {\n\t\tuwsgi_error(\"stat()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (st.st_size < EI_NIDENT) {\n\t\tuwsgi_log(\"invalid elf file: %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tchar *addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_error(\"mmap()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (addr[0] != ELFMAG0)\n\t\tgoto clear;\n\tif (addr[1] != ELFMAG1)\n\t\tgoto clear;\n\tif (addr[2] != ELFMAG2)\n\t\tgoto clear;\n\tif (addr[3] != ELFMAG3)\n\t\tgoto clear;\n\n\tif (addr[4] == ELFCLASS32) {\n\t\t// elf header\n\t\tElf32_Ehdr *elfh = (Elf32_Ehdr *) addr;\n\t\t// first section\n\t\tElf32_Shdr *sections = ((Elf32_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf32_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf32_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\telse if (addr[4] == ELFCLASS64) {\n\t\t// elf header\n\t\tElf64_Ehdr *elfh = (Elf64_Ehdr *) addr;\n\t\t// first section\n\t\tElf64_Shdr *sections = ((Elf64_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf64_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf64_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\n\nclear:\n\tclose(fd);\n\tmunmap(addr, st.st_size);\n\treturn output;\n}\n#endif\n\nstatic void *uwsgi_thread_run(void *arg) {\n\tstruct uwsgi_thread *ut = (struct uwsgi_thread *) arg;\n\t// block all signals\n\tsigset_t smask;\n\tsigfillset(&smask);\n\tpthread_sigmask(SIG_BLOCK, &smask, NULL);\n\n\tut->queue = event_queue_init();\n\tevent_queue_add_fd_read(ut->queue, ut->pipe[1]);\n\n\tut->func(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new_with_data(void (*func) (struct uwsgi_thread *), void *data) {\n\n\tstruct uwsgi_thread *ut = uwsgi_calloc(sizeof(struct uwsgi_thread));\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, ut->pipe)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, ut->pipe)) {\n#endif\n\t\tfree(ut);\n\t\treturn NULL;\n\t}\n\n\tuwsgi_socket_nb(ut->pipe[0]);\n\tuwsgi_socket_nb(ut->pipe[1]);\n\n\tut->func = func;\n\tut->data = data;\n\n\tpthread_attr_init(&ut->tattr);\n\tpthread_attr_setdetachstate(&ut->tattr, PTHREAD_CREATE_DETACHED);\n\t// 512K should be enough...\n\tpthread_attr_setstacksize(&ut->tattr, 512 * 1024);\n\n\tif (pthread_create(&ut->tid, &ut->tattr, uwsgi_thread_run, ut)) {\n\t\tuwsgi_error(\"pthread_create()\");\n\t\tgoto error;\n\t}\n\n\treturn ut;\nerror:\n\tclose(ut->pipe[0]);\n\tclose(ut->pipe[1]);\n\tfree(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new(void (*func) (struct uwsgi_thread *)) {\n\treturn uwsgi_thread_new_with_data(func, NULL);\n}\n\nint uwsgi_kvlist_parse(char *src, size_t len, char list_separator, int kv_separator, ...) {\n\tsize_t i;\n\tva_list ap;\n\tstruct uwsgi_string_list *itemlist = NULL;\n\n\tchar *buf = uwsgi_calloc(len + 1);\n\n\t// ok let's start splitting the string\n\tint escaped = 0;\n\tchar *base = buf;\n\tchar *ptr = buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == list_separator && !escaped) {\n\t\t\t*ptr++ = 0;\n\t\t\tuwsgi_string_new_list(&itemlist, base);\n\t\t\tbase = ptr;\n\t\t}\n\t\telse if (src[i] == '\\\\' && !escaped) {\n\t\t\tescaped = 1;\n\t\t}\n\t\telse if (escaped) {\n\t\t\t*ptr++ = src[i];\n\t\t\tescaped = 0;\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\tif (ptr > base) {\n\t\tuwsgi_string_new_list(&itemlist, base);\n\t}\n\n\tstruct uwsgi_string_list *usl = itemlist;\n\twhile (usl) {\n\t\tlen = strlen(usl->value);\n\t\tchar *item_buf = uwsgi_calloc(len + 1);\n\t\tbase = item_buf;\n\t\tptr = item_buf;\n\t\tescaped = 0;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (usl->value[i] == kv_separator && !escaped) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tva_start(ap, kv_separator);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar *p = va_arg(ap, char *);\n\t\t\t\t\tif (!p)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tchar **pp = va_arg(ap, char **);\n\t\t\t\t\tif (!pp)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!strcmp(p, base)) {\n\t\t\t\t\t\t*pp = uwsgi_str(usl->value + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tva_end(ap);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (usl->value[i] == '\\\\' && !escaped) {\n\t\t\t\tescaped = 1;\n\t\t\t}\n\t\t\telse if (escaped) {\n\t\t\t\tescaped = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*ptr++ = usl->value[i];\n\t\t\t}\n\t\t}\n\t\tfree(item_buf);\n\t\tusl = usl->next;\n\t}\n\n\t// destroy the list (no need to destroy the value as it is a pointer to buf)\n\tusl = itemlist;\n\twhile (usl) {\n\t\tstruct uwsgi_string_list *tmp_usl = usl;\n\t\tusl = usl->next;\n\t\tfree(tmp_usl);\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n\nint uwsgi_send_http_stats(int fd) {\n\n\tchar buf[4096];\n\n\tint ret = uwsgi_waitfd(fd, uwsgi.socket_timeout);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tif (read(fd, buf, 4096) <= 0)\n\t\treturn -1;\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\tif (!ub)\n\t\treturn -1;\n\n\tif (uwsgi_buffer_append(ub, \"HTTP/1.0 200 OK\\r\\n\", 17))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Connection: close\\r\\n\", 19))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Access-Control-Allow-Origin: *\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Content-Type: application/json\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"\\r\\n\", 2))\n\t\tgoto error;\n\n\tif (uwsgi_buffer_send(ub, fd))\n\t\tgoto error;\n\tuwsgi_buffer_destroy(ub);\n\treturn 0;\n\nerror:\n\tuwsgi_buffer_destroy(ub);\n\treturn -1;\n}\n\nint uwsgi_call_symbol(char *symbol) {\n\tvoid (*func) (void) = dlsym(RTLD_DEFAULT, symbol);\n\tif (!func)\n\t\treturn -1;\n\tfunc();\n\treturn 0;\n}\n\nint uwsgi_plugin_modifier1(char *plugin) {\n\tint ret = -1;\n\tchar *symbol_name = uwsgi_concat2(plugin, \"_plugin\");\n\tstruct uwsgi_plugin *up = dlsym(RTLD_DEFAULT, symbol_name);\n\tif (!up)\n\t\tgoto end;\n\tret = up->modifier1;\nend:\n\tfree(symbol_name);\n\treturn ret;\n}\n\nchar *uwsgi_strip(char *src) {\n\tchar *dst = src;\n\tsize_t len = strlen(src);\n\tint i;\n\n\tfor (i = 0; i < (ssize_t) len; i++) {\n\t\tif (src[i] == ' ' || src[i] == '\\t') {\n\t\t\tdst++;\n\t\t}\n\t}\n\n\tlen -= (dst - src);\n\n\tfor (i = len; i >= 0; i--) {\n\t\tif (dst[i] == ' ' || dst[i] == '\\t') {\n\t\t\tdst[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dst;\n}\n\nvoid uwsgi_uuid(char *buf) {\n#ifdef UWSGI_UUID\n\tuuid_t uuid_value;\n\tuuid_generate(uuid_value);\n\tuuid_unparse(uuid_value, buf);\n#else\n\tint i, r[11];\n\tif (!uwsgi_file_exists(\"/dev/urandom\"))\n\t\tgoto fallback;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\tgoto fallback;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (read(fd, &r[i], 4) != 4) {\n\t\t\tclose(fd);\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\tclose(fd);\n\tgoto done;\nfallback:\n\tfor (i = 0; i < 11; i++) {\n\t\tr[i] = rand();\n\t}\ndone:\n\tsnprintf(buf, 37, \"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]);\n#endif\n}\n\nint uwsgi_uuid_cmp(char *x, char *y) {\n\tint i;\n\tfor (i = 0; i < 36; i++) {\n\t\tif (x[i] != y[i]) {\n\t\t\tif (x[i] > y[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_additional_header_add(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\t// will be freed on request's end\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->additional_headers, header);\n}\n\nvoid uwsgi_remove_header(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->remove_headers, header);\n}\n\n// based on nginx implementation\n\nstatic uint8_t b64_table64[] = {\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77, 77, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,\n\t77, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 77,\n\t77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,\n\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77\n};\n\nstatic char b64_table64_2[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar *uwsgi_base64_decode(char *buf, size_t len, size_t * d_len) {\n\n\t// find the real size and check for invalid values\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == '=')\n\t\t\tbreak;\n\n\t\t// check for invalid content\n\t\tif (b64_table64[(uint8_t) buf[i]] == 77) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// check for invalid size\n\tif (i % 4 == 1)\n\t\treturn NULL;\n\n\t// compute the new size\n\t*d_len = (((len + 3) / 4) * 3);\n\tchar *dst = uwsgi_malloc(*d_len + 1);\n\n\tchar *ptr = dst;\n\tuint8_t *src = (uint8_t *) buf;\n\twhile (i > 3) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t\t*ptr++ = (char) (b64_table64[src[2]] << 6 | b64_table64[src[3]]);\n\n\t\tsrc += 4;\n\t\ti -= 4;\n\t}\n\n\tif (i > 1) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t}\n\n\tif (i > 2) {\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t}\n\n\t*d_len = (ptr - dst);\n\t*ptr++ = 0;\n\n\treturn dst;\n\n}\n\nchar *uwsgi_base64_encode(char *buf, size_t len, size_t * d_len) {\n\t*d_len = ((len * 4) / 3) + 5;\n\tuint8_t *src = (uint8_t *) buf;\n\tchar *dst = uwsgi_malloc(*d_len);\n\tchar *ptr = dst;\n\twhile (len >= 3) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\t*ptr++ = b64_table64_2[((src[0] << 4) & 0x30) | (src[1] >> 4)];\n\t\t*ptr++ = b64_table64_2[((src[1] << 2) & 0x3C) | (src[2] >> 6)];\n\t\t*ptr++ = b64_table64_2[src[2] & 0x3F];\n\t\tsrc += 3;\n\t\tlen -= 3;\n\t}\n\n\tif (len > 0) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\tuint8_t tmp = (src[0] << 4) & 0x30;\n\t\tif (len > 1)\n\t\t\ttmp |= src[1] >> 4;\n\t\t*ptr++ = b64_table64_2[tmp];\n\t\tif (len < 2) {\n\t\t\t*ptr++ = '=';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = b64_table64_2[(src[1] << 2) & 0x3C];\n\t\t}\n\t\t*ptr++ = '=';\n\t}\n\n\t*ptr = 0;\n\t*d_len = ((char *) ptr - dst);\n\n\treturn dst;\n}\n\nuint16_t uwsgi_be16(char *buf) {\n\tuint16_t *src = (uint16_t *) buf;\n\tuint16_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[1] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint32_t uwsgi_be32(char *buf) {\n\tuint32_t *src = (uint32_t *) buf;\n\tuint32_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[3] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint64_t uwsgi_be64(char *buf) {\n\tuint64_t *src = (uint64_t *) buf;\n\tuint64_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 56) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 48) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 40) & 0xff);\n\tptr[3] = (uint8_t) ((*src >> 32) & 0xff);\n\tptr[4] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[5] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[6] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[7] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nchar *uwsgi_get_header(struct wsgi_request *wsgi_req, char *hh, uint16_t len, uint16_t * rlen) {\n\tchar *key = uwsgi_malloc(len + 6);\n\tuint16_t key_len = len;\n\tchar *ptr = key;\n\t*rlen = 0;\n\tif (uwsgi_strncmp(hh, len, \"Content-Length\", 14) && uwsgi_strncmp(hh, len, \"Content-Type\", 12)) {\n\t\tmemcpy(ptr, \"HTTP_\", 5);\n\t\tptr += 5;\n\t\tkey_len += 5;\n\t}\n\n\tuint16_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (hh[i] == '-') {\n\t\t\t*ptr++ = '_';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = toupper((int) hh[i]);\n\t\t}\n\t}\n\n\tchar *value = uwsgi_get_var(wsgi_req, key, key_len, rlen);\n\tfree(key);\n\treturn value;\n\n}\n\nstatic char *uwsgi_hex_table[] = {\n\t\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\", \"0C\", \"0D\", \"0E\", \"0F\",\n\t\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\",\n\t\"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\",\n\t\"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\", \"3C\", \"3D\", \"3E\", \"3F\",\n\t\"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\",\n\t\"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\",\n\t\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\", \"6C\", \"6D\", \"6E\", \"6F\",\n\t\"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\",\n\t\"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\",\n\t\"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\", \"9C\", \"9D\", \"9E\", \"9F\",\n\t\"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\", \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\",\n\t\"B0\", \"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\",\n\t\"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\", \"CC\", \"CD\", \"CE\", \"CF\",\n\t\"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\", \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\",\n\t\"E0\", \"E1\", \"E2\", \"E3\", \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\",\n\t\"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\", \"FC\", \"FD\", \"FE\", \"FF\",\n};\n\nchar *uwsgi_str_to_hex(char *src, size_t slen) {\n\tchar *dst = uwsgi_malloc(slen * 2);\n\tchar *ptr = dst;\n\tsize_t i;\n\tfor (i = 0; i < slen; i++) {\n\t\tuint8_t pos = (uint8_t) src[i];\n\t\tmemcpy(ptr, uwsgi_hex_table[pos], 2);\n\t\tptr += 2;\n\t}\n\treturn dst;\n}\n\n// dst has to be 3 times buf size (USE IT ONLY FOR PATH_INFO !!!)\nvoid http_url_encode(char *buf, uint16_t * len, char *dst) {\n\n\tuint16_t i;\n\tchar *ptr = dst;\n\tfor (i = 0; i < *len; i++) {\n\t\tif ((buf[i] >= 'A' && buf[i] <= 'Z') || (buf[i] >= 'a' && buf[i] <= 'z') || (buf[i] >= '0' && buf[i] <= '9') || buf[i] == '-' || buf[i] == '_' || buf[i] == '.' || buf[i] == '~' || buf[i] == '/') {\n\t\t\t*ptr++ = buf[i];\n\t\t}\n\t\telse {\n\t\t\tchar *h = uwsgi_hex_table[(int) buf[i]];\n\t\t\t*ptr++ = '%';\n\t\t\t*ptr++ = h[0];\n\t\t\t*ptr++ = h[1];\n\t\t}\n\t}\n\n\t*len = ptr - dst;\n\n}\n\nvoid uwsgi_takeover() {\n\tif (uwsgi.i_am_a_spooler) {\n\t\tuwsgi_spooler_run();\n\t}\n\telse if (uwsgi.muleid) {\n\t\tuwsgi_mule_run();\n\t}\n\telse {\n\t\tuwsgi_worker_run();\n\t}\n}\n\n// create a message pipe\nvoid create_msg_pipe(int *fd, int bufsize) {\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, fd)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, fd)) {\n#endif\n\t\tuwsgi_error(\"create_msg_pipe()/socketpair()\");\n\t\texit(1);\n\t}\n\n\tuwsgi_socket_nb(fd[0]);\n\tuwsgi_socket_nb(fd[1]);\n\n\tif (bufsize) {\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t}\n}\n\nchar *uwsgi_binary_path() {\n\treturn uwsgi.binary_path ? uwsgi.binary_path : \"uwsgi\";\n}\n\nvoid uwsgi_envdir(char *edir) {\n\tDIR *d = opendir(edir);\n\tif (!d) {\n\t\tuwsgi_error(\"[uwsgi-envdir] opendir()\");\n\t\texit(1);\n\t}\n\tstruct dirent *de;\n\twhile ((de = readdir(d)) != NULL) {\n\t\t// skip hidden files\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\t\tstruct stat st;\n\t\tchar *filename = uwsgi_concat3(edir, \"/\", de->d_name);\n\t\tif (stat(filename, &st)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] error stating %s\\n\", filename);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] stat()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// unsetenv\n\t\tif (st.st_size == 0) {\n#ifdef UNSETENV_VOID\n\t\t\tunsetenv(de->d_name);\n#else\n\t\t\tif (unsetenv(de->d_name)) {\n\t\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to unset %s\\n\", de->d_name);\n\t\t\t\tuwsgi_error(\"[uwsgi-envdir] unsetenv\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read the content of the file\n\t\tsize_t size = 0;\n\t\tchar *content = uwsgi_open_and_read(filename, &size, 1, NULL);\n\t\tif (!content) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to open %s\\n\", filename);\n\t\t\tuwsgi_error_open(filename);\n\t\t\texit(1);\n\t\t}\n\t\tfree(filename);\n\n\t\t// HACK, envdir states we only need to strip the end of the string ....\n\t\tuwsgi_chomp2(content);\n\t\t// ... and substitute 0 with \\n\n\t\tsize_t slen = strlen(content);\n\t\tsize_t i;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (content[i] == 0) {\n\t\t\t\tcontent[i] = '\\n';\n\t\t\t}\n\t\t}\n\n\t\tif (setenv(de->d_name, content, 1)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to set %s\\n\", de->d_name);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] setenv\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfree(content);\n\t}\n\tclosedir(d);\n}\n\nvoid uwsgi_envdirs(struct uwsgi_string_list *envdirs) {\n\tstruct uwsgi_string_list *usl = envdirs;\n\twhile (usl) {\n\t\tuwsgi_envdir(usl->value);\n\t\tusl = usl->next;\n\t}\n}\n\nvoid uwsgi_opt_envdir(char *opt, char *value, void *foobar) {\n\tuwsgi_envdir(value);\n}\n\nvoid uwsgi_exit(int status) {\n\tuwsgi.last_exit_code = status;\n\t// disable macro expansion\n\t(exit) (status);\n}\n\nint uwsgi_base128(struct uwsgi_buffer *ub, uint64_t l, int first) {\n\tif (l > 127) {\n\t\tif (uwsgi_base128(ub, l / 128, 0))\n\t\t\treturn -1;\n\t}\n\tl %= 128;\n\tif (first) {\n\t\tif (uwsgi_buffer_u8(ub, (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\telse {\n\t\tif (uwsgi_buffer_u8(ub, 0x80 | (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#ifdef __linux__\nvoid uwsgi_setns(char *path) {\n\tint (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, \"setns\");\n\tif (!u_setns) {\n\t\tuwsgi_log(\"your system misses setns() syscall !!!\\n\");\n\t\texit(1);\n\t}\n\n\t// count be overwritten\n\tint count = 64;\n\n\tuwsgi_log(\"joining namespaces from %s ...\\n\", path);\n\tfor (;;) {\n\t\tint ns_fd = uwsgi_connect(path, 30, 0);\n\t\tif (ns_fd < 0) {\n\t\t\tuwsgi_error(\"uwsgi_setns()/uwsgi_connect()\");\n\t\t\tsleep(1);\n\t\t\tcontinue;\n\t\t}\n\t\tint *fds = uwsgi_attach_fd(ns_fd, &count, \"uwsgi-setns\", 11);\n\t\tif (fds && count > 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (fds[i] > -1) {\n\t\t\t\t\tif (u_setns(fds[i], 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"uwsgi_setns()/setns()\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tclose(fds[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(fds);\n\t\t\tclose(ns_fd);\n\t\t\tbreak;\n\t\t}\n\t\tif (fds)\n\t\t\tfree(fds);\n\t\tclose(ns_fd);\n\t\tsleep(1);\n\t}\n}\n#endif\n\nmode_t uwsgi_mode_t(char *value, int *error) {\n\tmode_t mode = 0;\n\t*error = 0;\n\n        if (strlen(value) < 3) {\n\t\t*error = 1;\n\t\treturn mode;\n\t}\n\n        if (strlen(value) == 3) {\n                mode = (mode << 3) + (value[0] - '0');\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n        }\n        else {\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n                mode = (mode << 3) + (value[3] - '0');\n        }\n\n\treturn mode;\n}\n\nint uwsgi_wait_for_socket(char *socket_name) {\n        if (!uwsgi.wait_for_socket_timeout) {\n                uwsgi.wait_for_socket_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", socket_name, uwsgi.wait_for_socket_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_socket_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", socket_name, counter);\n                        return -1;\n                }\n\t\t// wait for 1 second to respect uwsgi.wait_for_fs_timeout\n\t\tint fd = uwsgi_connect(socket_name, 1, 0);\n\t\tif (fd < 0) goto retry;\n\t\tclose(fd);\n                uwsgi_log_verbose(\"%s ready\\n\", socket_name);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\nint uwsgi_wait_for_mountpoint(char *mountpoint) {\n        if (!uwsgi.wait_for_fs_timeout) {\n                uwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", mountpoint, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_fs_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", mountpoint, counter);\n                        return -1;\n                }\n\t\tstruct stat st0;\n\t\tstruct stat st1;\n\t\tif (stat(mountpoint, &st0)) goto retry;\n\t\tif (!S_ISDIR(st0.st_mode)) goto retry;\n\t\tchar *relative = uwsgi_concat2(mountpoint, \"/../\");\n\t\tif (stat(relative, &st1)) {\n\t\t\tfree(relative);\n\t\t\tgoto retry;\n\t\t}\n\t\tfree(relative);\n\t\t// useless :P\n                if (!S_ISDIR(st1.st_mode)) goto retry;\n\t\tif (st0.st_dev == st1.st_dev) goto retry;\n                uwsgi_log_verbose(\"%s mounted\\n\", mountpoint);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\n// type -> 1 file, 2 dir, 0 both\nint uwsgi_wait_for_fs(char *filename, int type) {\n\tif (!uwsgi.wait_for_fs_timeout) {\n        \tuwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", filename, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n        \tif (counter > uwsgi.wait_for_fs_timeout) {\n                \tuwsgi_log(\"%s unavailable after %d seconds\\n\", filename, counter);\n\t\t\treturn -1;\n                }\n\t\tstruct stat st;\n\t\tif (stat(filename, &st)) goto retry;\n\t\tif (type == 1 && !S_ISREG(st.st_mode)) goto retry;\n\t\tif (type == 2 && !S_ISDIR(st.st_mode)) goto retry;\n                uwsgi_log_verbose(\"%s found\\n\", filename);\n\t\treturn 0;\nretry:\n                sleep(1);\n                counter++;\n\t}\n\treturn -1;\n}\n\n#if !defined(_GNU_SOURCE) && !defined(__UCLIBC__)\nint uwsgi_versionsort(const struct dirent **da, const struct dirent **db) {\n\n        const char *a = (*da)->d_name;\n        const char *b = (*db)->d_name;\n\n        long la, lb;\n        char *endptr;\n\n        // Check if a and b are valid numbers.\n        la = strtol(a, &endptr, 10);\n        if (strcmp(endptr, \"\\0\") || endptr == a) {\n            a = NULL;\n        }\n\n        lb = strtol(b, &endptr, 10);\n        if (strcmp(endptr, \"\\0\") || endptr == b) {\n            b = NULL;\n        }\n\n        if (a && b) {\n            return (la < lb ? -1 : la > lb);\n        } else if (a) {\n            return -1;\n        } else if (b) {\n            return 1;\n        } else {\n            return strcmp((*da)->d_name, (*db)->d_name);\n        }\n}\n#endif\n\nvoid uwsgi_fix_range_for_size(enum uwsgi_range* parsed, int64_t* from, int64_t* to, int64_t size) {\n        if (*parsed != UWSGI_RANGE_PARSED) {\n                return;\n        }\n        if (*from < 0) {\n                *from = size + *from;\n        }\n        if (*to > size-1) {\n                *to = size-1;\n        }\n        if (*from == 0 && *to == size-1) {\n                /* we have a right to reset to 200 OK answer */\n                *parsed = UWSGI_RANGE_NOT_PARSED;\n        }\n        else if (*to >= *from) {\n                *parsed = UWSGI_RANGE_VALID;\n        }\n        else { /* case *from > size-1 is also handled here */\n                *parsed = UWSGI_RANGE_INVALID;\n                *from = 0;\n                *to = 0;\n        }\n}\n"], "fixing_code": ["#include <uwsgi.h>\n\n\nextern struct uwsgi_server uwsgi;\n\n#ifdef __BIG_ENDIAN__\nuint16_t uwsgi_swap16(uint16_t x) {\n\treturn (uint16_t) ((x & 0xff) << 8 | (x & 0xff00) >> 8);\n}\n\nuint32_t uwsgi_swap32(uint32_t x) {\n\tx = ((x << 8) & 0xFF00FF00) | ((x >> 8) & 0x00FF00FF);\n\treturn (x >> 16) | (x << 16);\n}\n\n// thanks to ffmpeg project for this idea :P\nuint64_t uwsgi_swap64(uint64_t x) {\n\tunion {\n\t\tuint64_t ll;\n\t\tuint32_t l[2];\n\t} w, r;\n\tw.ll = x;\n\tr.l[0] = uwsgi_swap32(w.l[1]);\n\tr.l[1] = uwsgi_swap32(w.l[0]);\n\treturn r.ll;\n}\n\n#endif\n\n// check if a string is a valid hex number\nint check_hex(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((str[i] < '0' && str[i] > '9') && (str[i] < 'a' && str[i] > 'f') && (str[i] < 'A' && str[i] > 'F')\n\t\t\t) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n\n}\n\n// increase worker harakiri\nvoid inc_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (uwsgi.master_process) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri += sec;\n\t}\n\telse {\n\t\talarm(uwsgi.harakiri_options.workers + sec);\n\t}\n}\n\n// set worker harakiri\nvoid set_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (!wsgi_req) return;\n\tif (sec == 0) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set user harakiri\nvoid set_user_harakiri(struct wsgi_request *wsgi_req, int sec) {\n\tif (!uwsgi.master_process) {\n\t\tuwsgi_log(\"!!! unable to set user harakiri without the master process !!!\\n\");\n\t\treturn;\n\t}\n\n\t// a 0 seconds value, reset the timer\n\ttime_t timeout = sec == 0 ? 0 : uwsgi_now() + sec;\n\n\tif (uwsgi.muleid > 0) {\n\t\tuwsgi.mules[uwsgi.muleid - 1].user_harakiri = timeout;\n\t}\n\telse if (uwsgi.i_am_a_spooler) {\n\t\tstruct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;\n\t\tuspool->user_harakiri = timeout;\n\t}\n\telse if (wsgi_req) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = timeout;\n\t}\n}\n\n// set mule harakiri\nvoid set_mule_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set spooler harakiri\nvoid set_spooler_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.i_am_a_spooler->harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.i_am_a_spooler->harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n\n// daemonize to the specified logfile\nvoid daemonize(char *logfile) {\n\tpid_t pid;\n\n\t// do not daemonize under emperor\n\tif (uwsgi.has_emperor) {\n\t\tlogto(logfile);\n\t\treturn;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\t/* refork... */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (!uwsgi.do_not_change_umask) {\n\t\tumask(0);\n\t}\n\n\t/*if (chdir(\"/\") != 0) {\n\t   uwsgi_error(\"chdir()\");\n\t   exit(1);\n\t   } */\n\n\tuwsgi_remap_fd(0, \"/dev/null\");\n\n\tlogto(logfile);\n}\n\n// get current working directory\nchar *uwsgi_get_cwd() {\n#if defined(__GLIBC__)\n\treturn getcwd(NULL, 0);\n#else\n\t// set this to static to avoid useless reallocations in stats mode\n\tstatic size_t newsize = 256;\n\n\tchar *cwd = uwsgi_malloc(newsize);\n\n\tif (getcwd(cwd, newsize) == NULL && errno == ERANGE) {\n\t\tnewsize += 256;\n\t\tuwsgi_log(\"need a bigger buffer (%lu bytes) for getcwd(). doing reallocation.\\n\", (unsigned long) newsize);\n\t\tfree(cwd);\n\t\tcwd = uwsgi_malloc(newsize);\n\t\tif (getcwd(cwd, newsize) == NULL) {\n\t\t\tuwsgi_error(\"getcwd()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn cwd;\n#endif\n\n}\n\n#ifdef __linux__\nvoid uwsgi_set_cgroup() {\n\n\tchar *cgroup_taskfile;\n\tFILE *cgroup;\n\tchar *cgroup_opt;\n\tstruct uwsgi_string_list *usl, *uslo;\n\n\tif (!uwsgi.cgroup)\n\t\treturn;\n\n\tif (getuid())\n\t\treturn;\n\n\tusl = uwsgi.cgroup;\n\n\twhile (usl) {\n\t\tint mode = strtol(uwsgi.cgroup_dir_mode, 0, 8);\n\t\tif (mkdir(usl->value, mode)) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/mkdir()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (chmod(usl->value, mode)) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/chmod()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuwsgi_log(\"using Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"created Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\n\t\tcgroup_taskfile = uwsgi_concat2(usl->value, \"/tasks\");\n\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\tif (!cgroup) {\n\t\t\tuwsgi_error_open(cgroup_taskfile);\n\t\t\texit(1);\n\t\t}\n\t\tif (fprintf(cgroup, \"%d\\n\", (int) getpid()) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\tuwsgi_error(\"could not set cgroup\");\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi_log(\"assigned process %d to cgroup %s\\n\", (int) getpid(), cgroup_taskfile);\n\t\tfree(cgroup_taskfile);\n\n\n\t\tuslo = uwsgi.cgroup_opt;\n\t\twhile (uslo) {\n\t\t\tcgroup_opt = strchr(uslo->value, '=');\n\t\t\tif (!cgroup_opt) {\n\t\t\t\tcgroup_opt = strchr(uslo->value, ':');\n\t\t\t\tif (!cgroup_opt) {\n\t\t\t\t\tuwsgi_log(\"invalid cgroup-opt syntax\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcgroup_opt[0] = 0;\n\t\t\tcgroup_opt++;\n\n\t\t\tcgroup_taskfile = uwsgi_concat3(usl->value, \"/\", uslo->value);\n\t\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\t\tif (cgroup) {\n\t\t\t\tif (fprintf(cgroup, \"%s\\n\", cgroup_opt) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\t\t\tuwsgi_log(\"could not set cgroup option %s to %s\\n\", uslo->value, cgroup_opt);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tuwsgi_log(\"set %s to %s\\n\", cgroup_opt, cgroup_taskfile);\n\t\t\t}\n\t\t\tfree(cgroup_taskfile);\n\n\t\t\tcgroup_opt[-1] = '=';\n\n\t\t\tuslo = uslo->next;\n\t\t}\n\n\t\tusl = usl->next;\n\t}\n\n}\n#endif\n\n#ifdef UWSGI_CAP\nvoid uwsgi_apply_cap(cap_value_t * cap, int caps_count) {\n\tcap_value_t minimal_cap_values[] = { CAP_SYS_CHROOT, CAP_SETUID, CAP_SETGID, CAP_SETPCAP };\n\n\tcap_t caps = cap_init();\n\n\tif (!caps) {\n\t\tuwsgi_error(\"cap_init()\");\n\t\texit(1);\n\t}\n\tcap_clear(caps);\n\n\tcap_set_flag(caps, CAP_EFFECTIVE, 4, minimal_cap_values, CAP_SET);\n\n\tcap_set_flag(caps, CAP_PERMITTED, 4, minimal_cap_values, CAP_SET);\n\tcap_set_flag(caps, CAP_PERMITTED, caps_count, cap, CAP_SET);\n\n\tcap_set_flag(caps, CAP_INHERITABLE, caps_count, cap, CAP_SET);\n\n\tif (cap_set_proc(caps) < 0) {\n\t\tuwsgi_error(\"cap_set_proc()\");\n\t\texit(1);\n\t}\n\tcap_free(caps);\n\n#ifdef __linux__\n#ifdef SECBIT_KEEP_CAPS\n\tif (prctl(SECBIT_KEEP_CAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#else\n\tif (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#endif\n#endif\n}\n#endif\n\n// drop privileges (as root)\n/*\n\n\there we manage jails/namespaces too\n\tit is a pretty huge function... refactory is needed\n\n*/\nvoid uwsgi_as_root() {\n\n\n\tif (getuid() > 0)\n\t\tgoto nonroot;\n\n#ifndef __RUMP__\n\tif (!uwsgi.master_as_root && !uwsgi.uidname) {\n\t\tuwsgi_log_initial(\"uWSGI running as root, you can use --uid/--gid/--chroot options\\n\");\n\t}\n#endif\n\n\tint in_jail = 0;\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare);\n\t\t}\n\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\t\tuwsgi_apply_cap(uwsgi.cap, uwsgi.cap_count);\n\t}\n#endif\n\n\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tif (uwsgi.jail && !uwsgi.reloads) {\n\n\t\tstruct jail ujail;\n\t\tchar *jarg = uwsgi_str(uwsgi.jail);\n\t\tchar *j_hostname = NULL;\n\t\tchar *j_name = NULL;\n\n\t\tchar *space = strchr(jarg, ' ');\n\t\tif (space) {\n\t\t\t*space = 0;\n\t\t\tj_hostname = space + 1;\n\t\t\tspace = strchr(j_hostname, ' ');\n\t\t\tif (space) {\n\t\t\t\t*space = 0;\n\t\t\t\tj_name = space + 1;\n\t\t\t}\n\t\t}\n\t\tujail.version = JAIL_API_VERSION;\n\t\tujail.path = jarg;\n\t\tujail.hostname = j_hostname ? j_hostname : \"\";\n\t\tujail.jailname = j_name;\n\t\tujail.ip4s = 0;\n\t\tujail.ip6s = 0;\n\n\t\tstruct uwsgi_string_list *usl = NULL;\n\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tujail.ip4s++;\n\t\t}\n\t\tstruct in_addr *saddr = uwsgi_calloc(sizeof(struct in_addr) * ujail.ip4s);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tif (!inet_pton(AF_INET, usl->value, &saddr[i].s_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip4 = saddr;\n#ifdef AF_INET6\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tujail.ip6s++;\n\t\t}\n\n\t\tstruct in6_addr *saddr6 = uwsgi_calloc(sizeof(struct in6_addr) * ujail.ip6s);\n\t\ti = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tif (!inet_pton(AF_INET6, usl->value, &saddr6[i].s6_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip6 = saddr6;\n#endif\n\n\t\tint jail_id = jail(&ujail);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jail()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n\tif (uwsgi.jail_attach && !uwsgi.reloads) {\n\t\tstruct jailparam jparam;\n\t\tuwsgi_log(\"attaching to FreeBSD jail %s ...\\n\", uwsgi.jail_attach);\n\t\tif (!is_a_number(uwsgi.jail_attach)) {\n\t\t\tif (jailparam_init(&jparam, \"name\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (jailparam_init(&jparam, \"jid\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tjailparam_import(&jparam, uwsgi.jail_attach);\n\t\tint jail_id = jailparam_set(&jparam, 1, JAIL_UPDATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(&jparam, 1);\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n\tif (uwsgi.jail2 && !uwsgi.reloads) {\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tunsigned nparams = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tnparams++;\n\t\t}\n\t\tstruct jailparam *params = uwsgi_malloc(sizeof(struct jailparam) * nparams);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tuwsgi_log(\"FreeBSD libjail applying %s\\n\", usl->value);\n\t\t\tchar *equal = strchr(usl->value, '=');\n\t\t\tif (equal) {\n\t\t\t\t*equal = 0;\n\t\t\t}\n\t\t\tif (jailparam_init(&params[i], usl->value)) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tjailparam_import(&params[i], equal + 1);\n\t\t\t\t*equal = '=';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjailparam_import(&params[i], \"1\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tint jail_id = jailparam_set(params, nparams, JAIL_CREATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(params, nparams);\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n#endif\n#endif\n\n\tif (in_jail || uwsgi.jailed) {\n\t\tuwsgi_hooks_run(uwsgi.hook_post_jail, \"post-jail\", 1);\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tuwsgi_foreach(usl, uwsgi.mount_post_jail) {\n\t\t\tuwsgi_log(\"mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.umount_post_jail) {\n\t\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.exec_post_jail) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_post_jail) {\n\t\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (uwsgi.refork_post_jail) {\n\t\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\t\tpid_t pid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\tuwsgi_error(\"fork()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (pid > 0) {\n\t\t\t\t// block all signals\n\t\t\t\tsigset_t smask;\n\t\t\t\tsigfillset(&smask);\n\t\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\t\tint status;\n\t\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t\t}\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t}\n\n\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\t\tif (uwsgi.gp[i]->post_jail) {\n\t\t\t\tuwsgi.gp[i]->post_jail();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.chroot && !uwsgi.reloads) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"chroot() to %s\\n\", uwsgi.chroot);\n\t\tif (chroot(uwsgi.chroot)) {\n\t\t\tuwsgi_error(\"chroot()\");\n\t\t\texit(1);\n\t\t}\n#ifdef __linux__\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n#endif\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.pivot_root && !uwsgi.reloads) {\n\t\tchar *arg = uwsgi_str(uwsgi.pivot_root);\n\t\tchar *space = strchr(arg, ' ');\n\t\tif (!space) {\n\t\t\tuwsgi_log(\"invalid pivot_root syntax, new_root and put_old must be separated by a space\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*space = 0;\n#if defined(MS_REC) && defined(MS_PRIVATE)\n\t\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\t\tuwsgi_error(\"mount()\");\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tif (chdir(arg)) {\n\t\t\tuwsgi_error(\"pivot_root()/chdir()\");\n\t\t\texit(1);\n\t\t}\n\t\tspace += 1 + strlen(arg);\n\t\tif (space[0] == '/')\n\t\t\tspace++;\n\t\tif (pivot_root(\".\", space)) {\n\t\t\tuwsgi_error(\"pivot_root()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n\t\tfree(arg);\n\t\tif (chdir(\"/\")) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n#endif\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare2 && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare2)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare2);\n\t\t}\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare2 & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n\tif (uwsgi.refork_as_root) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uwsgi.wait_for_interface) {\n\t\tif (!uwsgi.wait_for_interface_timeout) {\n\t\t\tuwsgi.wait_for_interface_timeout = 60;\n\t\t}\n\t\tuwsgi_log(\"waiting for interface %s (max %d seconds) ...\\n\", usl->value, uwsgi.wait_for_interface_timeout);\n\t\tint counter = 0;\n\t\tfor (;;) {\n\t\t\tif (counter > uwsgi.wait_for_interface_timeout) {\n\t\t\t\tuwsgi_log(\"interface %s unavailable after %d seconds\\n\", usl->value, counter);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tunsigned int index = if_nametoindex(usl->value);\n\t\t\tif (index > 0) {\n\t\t\t\tuwsgi_log(\"interface %s found with index %u\\n\", usl->value, index);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsleep(1);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_fs) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 0)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_file) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 1)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_dir) {\n\t\tif (uwsgi_wait_for_fs(usl->value, 2)) exit(1);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {\n\t\tif (uwsgi_wait_for_mountpoint(usl->value)) exit(1);\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_root, \"as root\", 1);\n\n\tuwsgi_foreach(usl, uwsgi.mount_as_root) {\n\t\tuwsgi_log(\"mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.umount_as_root) {\n\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// now run the scripts needed by root\n\tuwsgi_foreach(usl, uwsgi.exec_as_root) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_root) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t}\n\t}\n\n\n\tif (uwsgi.gidname) {\n\t\tstruct group *ugroup = getgrnam(uwsgi.gidname);\n\t\tif (ugroup) {\n\t\t\tuwsgi.gid = ugroup->gr_gid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"group %s not found.\\n\", uwsgi.gidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (uwsgi.uidname) {\n\t\tstruct passwd *upasswd = getpwnam(uwsgi.uidname);\n\t\tif (upasswd) {\n\t\t\tuwsgi.uid = upasswd->pw_uid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"user %s not found.\\n\", uwsgi.uidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.logfile_chown) {\n\t\tint log_fd = 2;\n\t\tif (uwsgi.log_master && uwsgi.original_log_fd > -1) {\n\t\t\tlog_fd = uwsgi.original_log_fd;\n\t\t}\n\t\tif (fchown(log_fd, uwsgi.uid, uwsgi.gid)) {\n\t\t\tuwsgi_error(\"fchown()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// fix ipcsem owner\n\tif (uwsgi.lock_ops.lock_init == uwsgi_lock_ipcsem_init) {\n\t\tstruct uwsgi_lock_item *uli = uwsgi.registered_locks;\n\n\t\twhile (uli) {\n\t\t\tunion semun {\n\t\t\t\tint val;\n\t\t\t\tstruct semid_ds *buf;\n\t\t\t\tushort *array;\n\t\t\t} semu;\n\n\t\t\tstruct semid_ds sds;\n\t\t\tmemset(&sds, 0, sizeof(sds));\n\t\t\tsemu.buf = &sds;\n\t\t\tint semid = 0;\n\t\t\tmemcpy(&semid, uli->lock_ptr, sizeof(int));\n\n\t\t\tif (semctl(semid, 0, IPC_STAT, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tsemu.buf->sem_perm.uid = uwsgi.uid;\n\t\t\tsemu.buf->sem_perm.gid = uwsgi.gid;\n\n\t\t\tif (semctl(semid, 0, IPC_SET, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuli = uli->next;\n\t\t}\n\n\t}\n\n\t// ok try to call some special hook before finally dropping privileges\n\tint i;\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->before_privileges_drop) {\n\t\t\tuwsgi.gp[i]->before_privileges_drop();\n\t\t}\n\t}\n\n\tif (uwsgi.gid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setgid() to %d\\n\", uwsgi.gid);\n\t\tif (setgid(uwsgi.gid)) {\n\t\t\tuwsgi_error(\"setgid()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.no_initgroups || !uwsgi.uid) {\n\t\t\tif (setgroups(0, NULL)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar *uidname = uwsgi.uidname;\n\t\t\tif (!uidname) {\n\t\t\t\tstruct passwd *pw = getpwuid(uwsgi.uid);\n\t\t\t\tif (pw)\n\t\t\t\t\tuidname = pw->pw_name;\n\n\t\t\t}\n\t\t\tif (!uidname)\n\t\t\t\tuidname = uwsgi_num2str(uwsgi.uid);\n\t\t\tif (initgroups(uidname, uwsgi.gid)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tstruct uwsgi_string_list *usl;\n\t\tsize_t ags = 0;\n\t\tuwsgi_foreach(usl, uwsgi.additional_gids) ags++;\n\t\tif (ags > 0) {\n\t\t\tgid_t *ags_list = uwsgi_calloc(sizeof(gid_t) * ags);\n\t\t\tsize_t g_pos = 0;\n\t\t\tuwsgi_foreach(usl, uwsgi.additional_gids) {\n\t\t\t\tags_list[g_pos] = atoi(usl->value);\n\t\t\t\tif (!ags_list[g_pos]) {\n\t\t\t\t\tstruct group *g = getgrnam(usl->value);\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\tags_list[g_pos] = g->gr_gid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", usl->value);\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg_pos++;\n\t\t\t}\n\t\t\tif (setgroups(ags, ags_list)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tint additional_groups = getgroups(0, NULL);\n\t\tif (additional_groups > 0) {\n\t\t\tgid_t *gids = uwsgi_calloc(sizeof(gid_t) * additional_groups);\n\t\t\tif (getgroups(additional_groups, gids) > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < additional_groups; i++) {\n\t\t\t\t\tif (gids[i] == uwsgi.gid)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tstruct group *gr = getgrgid(gids[i]);\n\t\t\t\t\tif (gr) {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d (%s)\\n\", gids[i], gr->gr_name);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d\\n\", gids[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(gids);\n\t\t}\n\t}\n\tif (uwsgi.uid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setuid() to %d\\n\", uwsgi.uid);\n\t\tif (setuid(uwsgi.uid)) {\n\t\t\tuwsgi_error(\"setuid()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n#ifndef __RUMP__\n\tif (!getuid()) {\n\t\tuwsgi_log_initial(\"*** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** \\n\");\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\n\t\tcap_t caps = cap_init();\n\n\t\tif (!caps) {\n\t\t\tuwsgi_error(\"cap_init()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_clear(caps);\n\n\t\tcap_set_flag(caps, CAP_EFFECTIVE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_PERMITTED, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_INHERITABLE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\n\t\tif (cap_set_proc(caps) < 0) {\n\t\t\tuwsgi_error(\"cap_set_proc()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_free(caps);\n\t}\n#endif\n\n\tif (uwsgi.refork) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_user, \"as user\", 1);\n\n\t// now run the scripts needed by the user\n\tuwsgi_foreach(usl, uwsgi.exec_as_user) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as uid: %d gid: %d) ...\\n\", usl->value, (int) getuid(), (int) getgid());\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_user) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// we could now patch the binary\n\tif (uwsgi.unprivileged_binary_patch) {\n\t\tuwsgi.argv[0] = uwsgi.unprivileged_binary_patch;\n\t\texecvp(uwsgi.unprivileged_binary_patch, uwsgi.argv);\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.unprivileged_binary_patch_arg) {\n\t\tuwsgi_exec_command_with_args(uwsgi.unprivileged_binary_patch_arg);\n\t}\n\treturn;\n\nnonroot:\n\tif (uwsgi.chroot && !uwsgi.is_a_reload) {\n\t\tuwsgi_log(\"cannot chroot() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.gid && getgid() != uwsgi.gid) {\n\t\tuwsgi_log(\"cannot setgid() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.uid && getuid() != uwsgi.uid) {\n\t\tuwsgi_log(\"cannot setuid() as non-root user\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void close_and_free_request(struct wsgi_request *wsgi_req) {\n\n\t// close the connection with the client\n        if (!wsgi_req->fd_closed) {\n                // NOTE, if we close the socket before receiving eventually sent data, socket layer will send a RST\n                wsgi_req->socket->proto_close(wsgi_req);\n        }\n\n        if (wsgi_req->post_file) {\n                fclose(wsgi_req->post_file);\n        }\n\n        if (wsgi_req->post_read_buf) {\n                free(wsgi_req->post_read_buf);\n        }\n\n        if (wsgi_req->post_readline_buf) {\n                free(wsgi_req->post_readline_buf);\n        }\n\n        if (wsgi_req->proto_parser_buf) {\n                free(wsgi_req->proto_parser_buf);\n        }\n\n}\n\n// destroy a request\nvoid uwsgi_destroy_request(struct wsgi_request *wsgi_req) {\n\n\tclose_and_free_request(wsgi_req);\n\n\tint foo;\n        if (uwsgi.threads > 1) {\n                // now the thread can die...\n                pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &foo);\n        }\n\n\t// reset for avoiding following requests to fail on non-uwsgi protocols\n\t// thanks Marko Tiikkaja for catching it\n\twsgi_req->uh->_pktsize = 0;\n\n\t// some plugins expected async_id to be defined before setup\n        int tmp_id = wsgi_req->async_id;\n        memset(wsgi_req, 0, sizeof(struct wsgi_request));\n        wsgi_req->async_id = tmp_id;\n}\n\n// finalize/close/free a request\nvoid uwsgi_close_request(struct wsgi_request *wsgi_req) {\n\n\tint waitpid_status;\n\tint tmp_id;\n\tuint64_t tmp_rt, rss = 0, vsz = 0;\n#ifdef __linux__\n\tuint64_t uss = 0, pss = 0;\n#endif\n\n\t// apply transformations\n\tif (wsgi_req->transformations) {\n\t\tif (uwsgi_apply_final_transformations(wsgi_req) == 0) {\n\t\t\tif (wsgi_req->transformed_chunk && wsgi_req->transformed_chunk_len > 0) {\n\t\t\t\tuwsgi_response_write_body_do(wsgi_req, wsgi_req->transformed_chunk, wsgi_req->transformed_chunk_len);\n\t\t\t}\n\t\t}\n\t\tuwsgi_free_transformations(wsgi_req);\n\t}\n\n\t// check if headers should be sent\n\tif (wsgi_req->headers) {\n\t\tif (!wsgi_req->headers_sent && !wsgi_req->headers_size && !wsgi_req->response_size) {\n\t\t\tuwsgi_response_write_headers_do(wsgi_req);\n\t\t}\n\t\tuwsgi_buffer_destroy(wsgi_req->headers);\n\t}\n\n\tuint64_t end_of_request = uwsgi_micros();\n\twsgi_req->end_of_request = end_of_request;\n\n\tif (!wsgi_req->do_not_account_avg_rt) {\n\t\ttmp_rt = wsgi_req->end_of_request - wsgi_req->start_of_request;\n\t\tuwsgi.workers[uwsgi.mywid].running_time += tmp_rt;\n\t\tuwsgi.workers[uwsgi.mywid].avg_response_time = (uwsgi.workers[uwsgi.mywid].avg_response_time + tmp_rt) / 2;\n\t}\n\n\t// get memory usage\n\tif (uwsgi.logging_options.memory_report || uwsgi.force_get_memusage) {\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.logging_options.memory_report || uwsgi.reload_on_uss || uwsgi.reload_on_pss) {\n\t\tget_memusage_extra(&uss, &pss);\n\t\tuwsgi.workers[uwsgi.mywid].uss_size = uss;\n\t\tuwsgi.workers[uwsgi.mywid].pss_size = pss;\n\t}\n#endif\n\n\tif (!wsgi_req->do_not_account) {\n\t\tuwsgi.workers[0].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].write_errors += wsgi_req->write_errors;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].read_errors += wsgi_req->read_errors;\n\t\t// this is used for MAX_REQUESTS\n\t\tuwsgi.workers[uwsgi.mywid].delta_requests++;\n\t}\n\n#ifdef UWSGI_ROUTING\n\t// apply final routes after accounting\n\tuwsgi_apply_final_routes(wsgi_req);\n#endif\n\n\t// close socket and free parsers-allocated memory\n\tclose_and_free_request(wsgi_req);\n\n\t// after_request hook\n\tif (!wsgi_req->is_raw && uwsgi.p[wsgi_req->uh->modifier1]->after_request)\n\t\tuwsgi.p[wsgi_req->uh->modifier1]->after_request(wsgi_req);\n\n\t// after_request custom hooks\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.after_request_hooks) {\n\t\tvoid (*func) (struct wsgi_request *) = (void (*)(struct wsgi_request *)) usl->custom_ptr;\n\t\tfunc(wsgi_req);\n\t}\n\n\tif (uwsgi.threads > 1) {\n\t\t// now the thread can die...\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &tmp_id);\n\t}\n\n\t// leave harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {\n\t\tset_harakiri(wsgi_req, 0);\n\t}\n\n\t// leave user harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri > 0) {\n\t\tset_user_harakiri(wsgi_req, 0);\n\t}\n\n\tif (!wsgi_req->do_not_account) {\n\t\t// this is racy in multithread mode\n\t\tif (wsgi_req->response_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->response_size;\n\t\t}\n\t\tif (wsgi_req->headers_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->headers_size;\n\t\t}\n\t}\n\n\t// defunct process reaper\n\tif (uwsgi.reaper == 1) {\n\t\twhile (waitpid(WAIT_ANY, &waitpid_status, WNOHANG) > 0);\n\t}\n\n\t// free logvars\n\tstruct uwsgi_logvar *lv = wsgi_req->logvars;\n\twhile (lv) {\n\t\tstruct uwsgi_logvar *ptr = lv;\n\t\tlv = lv->next;\n\t\tfree(ptr);\n\t}\n\n\t// free additional headers\n\tstruct uwsgi_string_list *ah = wsgi_req->additional_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\t// free remove headers\n\tah = wsgi_req->remove_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\n\t// free chunked input\n\tif (wsgi_req->chunked_input_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->chunked_input_buf);\n\t}\n\n\tif (wsgi_req->body_chunked_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->body_chunked_buf);\n\t}\n\n\t// free websocket engine\n\tif (wsgi_req->websocket_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_buf);\n\t}\n\tif (wsgi_req->websocket_send_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_send_buf);\n\t}\n\n\n\t// reset request\n\twsgi_req->uh->_pktsize = 0;\n\ttmp_id = wsgi_req->async_id;\n\tmemset(wsgi_req, 0, sizeof(struct wsgi_request));\n\t// some plugins expected async_id to be defined before setup\n\twsgi_req->async_id = tmp_id;\n\t// yes, this is pretty useless but we cannot ensure all of the plugin have the same behaviour\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\tif (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))\n\t    && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"max requests reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) uwsgi.workers[uwsgi.mywid].delta_requests,\n\t\t\t(unsigned long long) (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_as && (rlim_t) vsz >= uwsgi.reload_on_as && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-as limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) vsz,\n\t\t\t(unsigned long long) uwsgi.reload_on_as\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_rss && (rlim_t) rss >= uwsgi.reload_on_rss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-rss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) rss,\n\t\t\t(unsigned long long) uwsgi.reload_on_rss\n\t\t);\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.reload_on_uss && (rlim_t) uss >= uwsgi.reload_on_uss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-uss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) uss,\n\t\t\t(unsigned long long) uwsgi.reload_on_uss\n\t\t);\n\t}\n\n\tif (uwsgi.reload_on_pss && (rlim_t) pss >= uwsgi.reload_on_pss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world(\"reload-on-pss limit reached (%llu >= %llu)\",\n\t\t\t(unsigned long long) (rlim_t) pss,\n\t\t\t(unsigned long long) uwsgi.reload_on_pss\n\t\t);\n\t}\n#endif\n\n\t// after the first request, if i am a vassal, signal Emperor about my loyalty\n\tif (uwsgi.has_emperor && !uwsgi.loyal) {\n\t\tuwsgi_log(\"announcing my loyalty to the Emperor...\\n\");\n\t\tchar byte = 17;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.loyal = 1;\n\t}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\t// run the ksm mapper\n\tif (uwsgi.linux_ksm > 0 && (uwsgi.workers[uwsgi.mywid].requests % uwsgi.linux_ksm) == 0) {\n\t\tuwsgi_linux_ksm_map();\n\t}\n#endif\n#endif\n\n}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\nvoid uwsgi_linux_ksm_map(void) {\n\n\tint dirty = 0;\n\tsize_t i;\n\tunsigned long long start = 0, end = 0;\n\tint errors = 0;\n\tint lines = 0;\n\n\tint fd = open(\"/proc/self/maps\", O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(\"[uwsgi-KSM] /proc/self/maps\");\n\t\treturn;\n\t}\n\n\t// allocate memory if not available;\n\tif (uwsgi.ksm_mappings_current == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_current = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_current_size = 0;\n\t}\n\tif (uwsgi.ksm_mappings_last == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_last = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_last_size = 0;\n\t}\n\n\tuwsgi.ksm_mappings_current_size = read(fd, uwsgi.ksm_mappings_current, uwsgi.ksm_buffer_size);\n\tclose(fd);\n\tif (uwsgi.ksm_mappings_current_size <= 0) {\n\t\tuwsgi_log(\"[uwsgi-KSM] unable to read /proc/self/maps data\\n\");\n\t\treturn;\n\t}\n\n\t// we now have areas\n\tif (uwsgi.ksm_mappings_last_size == 0 || uwsgi.ksm_mappings_current_size != uwsgi.ksm_mappings_last_size) {\n\t\tdirty = 1;\n\t}\n\telse {\n\t\tif (memcmp(uwsgi.ksm_mappings_current, uwsgi.ksm_mappings_last, uwsgi.ksm_mappings_current_size) != 0) {\n\t\t\tdirty = 1;\n\t\t}\n\t}\n\n\t// it is dirty, swap addresses and parse it\n\tif (dirty) {\n\t\tchar *tmp = uwsgi.ksm_mappings_last;\n\t\tuwsgi.ksm_mappings_last = uwsgi.ksm_mappings_current;\n\t\tuwsgi.ksm_mappings_current = tmp;\n\n\t\tsize_t tmp_size = uwsgi.ksm_mappings_last_size;\n\t\tuwsgi.ksm_mappings_last_size = uwsgi.ksm_mappings_current_size;\n\t\tuwsgi.ksm_mappings_current_size = tmp_size;\n\n\t\t// scan each line and call madvise on it\n\t\tchar *ptr = uwsgi.ksm_mappings_last;\n\t\tfor (i = 0; i < uwsgi.ksm_mappings_last_size; i++) {\n\t\t\tif (uwsgi.ksm_mappings_last[i] == '\\n') {\n\t\t\t\tlines++;\n\t\t\t\tuwsgi.ksm_mappings_last[i] = 0;\n\t\t\t\tif (sscanf(ptr, \"%llx-%llx %*s\", &start, &end) == 2) {\n\t\t\t\t\tif (madvise((void *) (long) start, (size_t) (end - start), MADV_MERGEABLE)) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuwsgi.ksm_mappings_last[i] = '\\n';\n\t\t\t\tptr = uwsgi.ksm_mappings_last + i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (errors >= lines) {\n\t\t\tuwsgi_error(\"[uwsgi-KSM] unable to share pages\");\n\t\t}\n\t}\n}\n#endif\n#endif\n\n#ifdef __linux__\nlong uwsgi_num_from_file(char *filename, int quiet) {\n\tchar buf[16];\n\tssize_t len;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_error_open(filename);\n\t\treturn -1L;\n\t}\n\tlen = read(fd, buf, sizeof(buf));\n\tif (len == 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_log(\"read error %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn -1L;\n\t}\n\tclose(fd);\n\treturn strtol(buf, (char **) NULL, 10);\n}\n#endif\n\n// setup for a new request\nvoid wsgi_req_setup(struct wsgi_request *wsgi_req, int async_id, struct uwsgi_socket *uwsgi_sock) {\n\n\twsgi_req->app_id = -1;\n\n\twsgi_req->async_id = async_id;\n\twsgi_req->sendfile_fd = -1;\n\n\twsgi_req->hvec = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].hvec;\n\t// skip the first 4 bytes;\n\twsgi_req->uh = (struct uwsgi_header *) uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer;\n\twsgi_req->buffer = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer + 4;\n\n\tif (uwsgi.post_buffering > 0) {\n\t\twsgi_req->post_buffering_buf = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].post_buf;\n\t}\n\n\tif (uwsgi_sock) {\n\t\twsgi_req->socket = uwsgi_sock;\n\t}\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\t// now check for suspend request\n\tif (uwsgi.workers[uwsgi.mywid].suspended == 1) {\n\t\tuwsgi_log_verbose(\"*** worker %d suspended ***\\n\", uwsgi.mywid);\ncycle:\n\t\t// wait for some signal (normally SIGTSTP) or 10 seconds (as fallback)\n\t\t(void) poll(NULL, 0, 10 * 1000);\n\t\tif (uwsgi.workers[uwsgi.mywid].suspended == 1)\n\t\t\tgoto cycle;\n\t\tuwsgi_log_verbose(\"*** worker %d resumed ***\\n\", uwsgi.mywid);\n\t}\n}\n\nint wsgi_req_async_recv(struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\tif (!wsgi_req->do_not_add_to_async_queue) {\n\t\tif (event_queue_add_fd_read(uwsgi.async_queue, wsgi_req->fd) < 0)\n\t\t\treturn -1;\n\n\t\tasync_add_timeout(wsgi_req, uwsgi.socket_timeout);\n\t\tuwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(wsgi_req, uwsgi.harakiri_options.workers);\n\t}\n\n\treturn 0;\n}\n\n// receive a new request\nint wsgi_req_recv(int queue, struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\t// edge triggered sockets get the whole request during accept() phase\n\tif (!wsgi_req->socket->edge_trigger) {\n\t\tfor (;;) {\n\t\t\tint ret = wsgi_req->socket->proto(wsgi_req);\n\t\t\tif (ret == UWSGI_OK)\n\t\t\t\tbreak;\n\t\t\tif (ret == UWSGI_AGAIN) {\n\t\t\t\tret = uwsgi_wait_read_req(wsgi_req);\n\t\t\t\tif (ret <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(wsgi_req, uwsgi.harakiri_options.workers);\n\t}\n\n#ifdef UWSGI_ROUTING\n\tif (uwsgi_apply_routes(wsgi_req) == UWSGI_ROUTE_BREAK)\n\t\treturn 0;\n#endif\n\n\twsgi_req->async_status = uwsgi.p[wsgi_req->uh->modifier1]->request(wsgi_req);\n\n\treturn 0;\n}\n\nvoid uwsgi_post_accept(struct wsgi_request *wsgi_req) {\n\n\t// set close on exec (if not a new socket)\n\tif (!wsgi_req->socket->edge_trigger && uwsgi.close_on_exec) {\n\t\tif (fcntl(wsgi_req->fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\t\tuwsgi_error(\"fcntl()\");\n\t\t}\n\t}\n\n\t// enable TCP_NODELAY ?\n\tif (uwsgi.tcp_nodelay) {\n\t\tuwsgi_tcp_nodelay(wsgi_req->fd);\n\t}\n}\n\n// accept a new request\nint wsgi_req_simple_accept(struct wsgi_request *wsgi_req, int fd) {\n\n\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, fd);\n\n\tif (wsgi_req->fd < 0) {\n\t\treturn -1;\n\t}\n\n\tuwsgi_post_accept(wsgi_req);\n\n\treturn 0;\n}\n\n// send heartbeat to the emperor\nvoid uwsgi_heartbeat() {\n\n\tif (!uwsgi.has_emperor)\n\t\treturn;\n\n\ttime_t now = uwsgi_now();\n\tif (uwsgi.next_heartbeat <= now) {\n\t\tchar byte = 26;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.next_heartbeat = now + uwsgi.heartbeat;\n\t}\n\n}\n\n// accept a request\nint wsgi_req_accept(int queue, struct wsgi_request *wsgi_req) {\n\n\tint ret;\n\tint interesting_fd = -1;\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint timeout = -1;\n\n\n\tthunder_lock;\n\n\t// Recheck the manage_next_request before going forward.\n\t// This is because the worker might get cheaped while it's\n\t// blocking on the thunder_lock, because thunder_lock is\n\t// not interruptable, it'll slow down the cheaping process\n\t// (the worker will handle the next request before shuts down).\n\tif (!uwsgi.workers[uwsgi.mywid].manage_next_request) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// heartbeat\n\t// in multithreaded mode we are now locked\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\ttime_t now = uwsgi_now();\n\t\t// overengineering ... (reduce skew problems)\n\t\ttimeout = uwsgi.heartbeat;\n\t\tif (!uwsgi.next_heartbeat) {\n\t\t\tuwsgi.next_heartbeat = now;\n\t\t}\n\t\tif (uwsgi.next_heartbeat >= now) {\n\t\t\ttimeout = uwsgi.next_heartbeat - now;\n\t\t}\n\t}\n\n\t// need edge trigger ?\n\tif (uwsgi.is_et) {\n\t\twhile (uwsgi_sock) {\n\t\t\tif (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) {\n\t\t\t\ttimeout = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuwsgi_sock = uwsgi_sock->next;\n\t\t}\n\t\t// reset pointer\n\t\tuwsgi_sock = uwsgi.sockets;\n\t}\n\n\tret = event_queue_wait(queue, timeout, &interesting_fd);\n\tif (ret < 0) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// check for heartbeat\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\tuwsgi_heartbeat();\n\t\t// no need to continue if timed-out\n\t\tif (ret == 0) {\n\t\t\tthunder_unlock;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// kill the thread after the request completion\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &ret);\n\n\tif (uwsgi.signal_socket > -1 && (interesting_fd == uwsgi.signal_socket || interesting_fd == uwsgi.my_signal_socket)) {\n\n\t\tthunder_unlock;\n\n\t\tuwsgi_receive_signal(wsgi_req, interesting_fd, \"worker\", uwsgi.mywid);\n\n\t\tif (uwsgi.threads > 1)\n\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\treturn -1;\n\t}\n\n\n\twhile (uwsgi_sock) {\n\t\tif (interesting_fd == uwsgi_sock->fd || (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) || (uwsgi_sock->fd_threads && interesting_fd == uwsgi_sock->fd_threads[wsgi_req->async_id])) {\n\t\t\twsgi_req->socket = uwsgi_sock;\n\t\t\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, interesting_fd);\n\t\t\tthunder_unlock;\n\t\t\tif (wsgi_req->fd < 0) {\n\t\t\t\tif (uwsgi.threads > 1)\n\t\t\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!uwsgi_sock->edge_trigger) {\n\t\t\t\tuwsgi_post_accept(wsgi_req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\tthunder_unlock;\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\treturn -1;\n}\n\n// translate a OS env to a uWSGI option\nvoid env_to_arg(char *src, char *dst) {\n\tint i;\n\tint val = 0;\n\n\tfor (i = 0; i < (int) strlen(src); i++) {\n\t\tif (src[i] == '=') {\n\t\t\tval = 1;\n\t\t}\n\t\tif (val) {\n\t\t\tdst[i] = src[i];\n\t\t}\n\t\telse {\n\t\t\tdst[i] = tolower((int) src[i]);\n\t\t\tif (dst[i] == '_') {\n\t\t\t\tdst[i] = '-';\n\t\t\t}\n\t\t}\n\t}\n\n\tdst[strlen(src)] = 0;\n}\n\n// parse OS envs\nvoid parse_sys_envs(char **envs) {\n\n\tchar **uenvs = envs;\n\tchar *earg, *eq_pos;\n\n\twhile (*uenvs) {\n\t\tif (!strncmp(*uenvs, \"UWSGI_\", 6) && strncmp(*uenvs, \"UWSGI_RELOADS=\", 14) && strncmp(*uenvs, \"UWSGI_VASSALS_DIR=\", 18) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD=\", 17) && strncmp(*uenvs, \"UWSGI_BROODLORD_NUM=\", 20) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD_CONFIG=\", 24) && strncmp(*uenvs, \"UWSGI_EMPEROR_PROXY=\", 20) && strncmp(*uenvs, \"UWSGI_JAIL_PID=\", 15) && strncmp(*uenvs, \"UWSGI_ORIGINAL_PROC_NAME=\", 25)) {\n\t\t\tearg = uwsgi_malloc(strlen(*uenvs + 6) + 1);\n\t\t\tenv_to_arg(*uenvs + 6, earg);\n\t\t\teq_pos = strchr(earg, '=');\n\t\t\tif (!eq_pos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq_pos[0] = 0;\n\n\t\t\tadd_exported_option(earg, eq_pos + 1, 0);\n\t\t}\n\t\tuenvs++;\n\t}\n\n}\n\n// get the application id\nint uwsgi_get_app_id(struct wsgi_request *wsgi_req, char *key, uint16_t key_len, int modifier1) {\n\n\tint i;\n\tstruct stat st;\n\tint found;\n\n\tchar *app_name = key;\n\tuint16_t app_name_len = key_len;\n\n\tif (app_name_len == 0 && wsgi_req) {\n\t\tapp_name = wsgi_req->appid;\n\t\tapp_name_len = wsgi_req->appid_len;\n\t\tif (app_name_len == 0) {\n\t\t\tif (!uwsgi.ignore_script_name) {\n\t\t\t\tapp_name = wsgi_req->script_name;\n\t\t\t\tapp_name_len = wsgi_req->script_name_len;\n\t\t\t}\n\n\t\t\tif (uwsgi.vhost) {\n\t\t\t\tchar *vhost_name = uwsgi_concat3n(wsgi_req->host, wsgi_req->host_len, \"|\", 1, wsgi_req->script_name, wsgi_req->script_name_len);\n\t\t\t\tapp_name_len = wsgi_req->host_len + 1 + wsgi_req->script_name_len;\n\t\t\t\tapp_name = uwsgi_req_append(wsgi_req, \"UWSGI_APPID\", 11, vhost_name, app_name_len);\n\t\t\t\tfree(vhost_name);\n\t\t\t\tif (!app_name) {\n\t\t\t\t\tuwsgi_log(\"unable to add UWSGI_APPID to the uwsgi buffer, consider increasing it\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_debug(\"VirtualHost KEY=%.*s\\n\", app_name_len, app_name);\n#endif\n\t\t\t}\n\t\t\twsgi_req->appid = app_name;\n\t\t\twsgi_req->appid_len = app_name_len;\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < uwsgi_apps_cnt; i++) {\n\t\t// reset check\n\t\tfound = 0;\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"searching for %.*s in %.*s %p\\n\", app_name_len, app_name, uwsgi_apps[i].mountpoint_len, uwsgi_apps[i].mountpoint, uwsgi_apps[i].callable);\n#endif\n\t\tif (!uwsgi_apps[i].callable) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!uwsgi_strncmp(uwsgi_apps[i].mountpoint, uwsgi_apps[i].mountpoint_len, app_name, app_name_len)) {\n\t\t\tfound = 1;\n\t\t}\n\n\t\tif (found) {\n\t\t\tif (uwsgi_apps[i].touch_reload[0]) {\n\t\t\t\tif (!stat(uwsgi_apps[i].touch_reload, &st)) {\n\t\t\t\t\tif (st.st_mtime != uwsgi_apps[i].touch_reload_mtime) {\n\t\t\t\t\t\t// serve the new request and reload\n\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\t\t\t\t\t\tif (uwsgi.threads > 1) {\n\t\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].destroy = 1;\n\t\t\t\t\t\t}\n\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"mtime %d %d\\n\", st.st_mtime, uwsgi_apps[i].touch_reload_mtime);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (modifier1 == -1)\n\t\t\t\treturn i;\n\t\t\tif (modifier1 == uwsgi_apps[i].modifier1)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nchar *uwsgi_substitute(char *src, char *what, char *with) {\n\n\tint count = 0;\n\tif (!with)\n\t\treturn src;\n\n\tsize_t len = strlen(src);\n\tsize_t wlen = strlen(what);\n\tsize_t with_len = strlen(with);\n\n\tchar *p = strstr(src, what);\n\tif (!p) {\n\t\treturn src;\n\t}\n\n\twhile (p) {\n\t\tcount++;\n\t\tp = strstr(p + wlen, what);\n\t}\n\n\tlen += (count * with_len) + 1;\n\n\tchar *dst = uwsgi_calloc(len);\n\tchar *ptr = src;\n\n\tp = strstr(ptr, what);\n\twhile (p) {\n\t\tstrncat(dst, ptr, (p - ptr));\n\t\tstrncat(dst, with, with_len);\n\t\tptr = p + wlen;\n\t\tp = strstr(ptr, what);\n\t}\n\n\tstrncat(dst, ptr, strlen(ptr));\n\n\treturn dst;\n}\n\nint uwsgi_is_file(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_file2(char *filename, struct stat *st) {\n\tif (stat(filename, st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st->st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nint uwsgi_is_dir(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISDIR(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_link(char *filename) {\n\tstruct stat st;\n\tif (lstat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISLNK(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid *uwsgi_malloc(size_t size) {\n\n\tchar *ptr = malloc(size);\n\tif (ptr == NULL) {\n\t\tuwsgi_error(\"malloc()\");\n\t\tuwsgi_log(\"!!! tried memory allocation of %llu bytes !!!\\n\", (unsigned long long) size);\n\t\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\t\texit(1);\n\t}\n\n\treturn ptr;\n}\n\nvoid *uwsgi_calloc(size_t size) {\n\t// thanks Mathieu Dupuy for pointing out that calloc is faster\n\t// than malloc + memset\n\tchar *ptr = calloc(1, size);\n\tif (ptr == NULL) {\n\t\tuwsgi_error(\"calloc()\");\n\t\tuwsgi_log(\"!!! tried memory allocation of %llu bytes !!!\\n\", (unsigned long long) size);\n\t\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\t\texit(1);\n\t}\n\treturn ptr;\n}\n\n#ifdef AF_INET6\n#define ADDR_AF_INET_FAMILY(addrtype) (addrtype == AF_INET || addrtype == AF_INET6)\n#else\n#define ADDR_AF_INET_FAMILY(addrtype) (addrtype == AF_INET)\n#endif\n\nchar *uwsgi_resolve_ip(char *domain) {\n\n\tstruct hostent *he;\n\n\the = gethostbyname(domain);\n\tif (!he || !*he->h_addr_list || !ADDR_AF_INET_FAMILY(he->h_addrtype)) {\n\t\treturn NULL;\n\t}\n\n\treturn inet_ntoa(*(struct in_addr *) he->h_addr_list[0]);\n}\n\nint uwsgi_file_exists(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK);\n}\n\nint uwsgi_file_executable(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK | X_OK);\n}\n\nchar *magic_sub(char *buffer, size_t len, size_t * size, char *magic_table[]) {\n\n\tsize_t i;\n\tsize_t magic_len = 0;\n\tchar *magic_buf = uwsgi_malloc(len);\n\tchar *magic_ptr = magic_buf;\n\tchar *old_magic_buf;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == '%' && (i + 1) < len && magic_table[(unsigned char) buffer[i + 1]]) {\n\t\t\told_magic_buf = magic_buf;\n\t\t\tmagic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i - 2);\n\t\t\tfree(old_magic_buf);\n\t\t\tmagic_len += strlen(magic_table[(unsigned char) buffer[i + 1]]);\n\t\t\tmagic_ptr = magic_buf + magic_len;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\t*magic_ptr = buffer[i];\n\t\t\tmagic_ptr++;\n\t\t\tmagic_len++;\n\t\t}\n\t}\n\n\t*size = magic_len;\n\n\treturn magic_buf;\n\n}\n\nvoid init_magic_table(char *magic_table[]) {\n\n\tint i;\n\tfor (i = 0; i <= 0xff; i++) {\n\t\tmagic_table[i] = \"\";\n\t}\n\n\tmagic_table['%'] = \"%\";\n\tmagic_table['('] = \"%(\";\n}\n\nchar *uwsgi_num2str(int num) {\n\n\tchar *str = uwsgi_malloc(11);\n\n\tsnprintf(str, 11, \"%d\", num);\n\treturn str;\n}\n\nchar *uwsgi_64bit2str(int64_t num) {\n\tchar *str = uwsgi_malloc(sizeof(MAX64_STR) + 1);\n\tsnprintf(str, sizeof(MAX64_STR) + 1, \"%lld\", (long long) num);\n\treturn str;\n}\n\nint uwsgi_num2str2(int num, char *ptr) {\n\n\treturn snprintf(ptr, 11, \"%d\", num);\n}\n\nint uwsgi_num2str2n(int num, char *ptr, int size) {\n\treturn snprintf(ptr, size, \"%d\", num);\n}\n\nint uwsgi_long2str2n(unsigned long long num, char *ptr, int size) {\n\tint ret = snprintf(ptr, size, \"%llu\", num);\n\tif (ret <= 0 || ret > size)\n\t\treturn 0;\n\treturn ret;\n}\n\nint is_unix(char *socket_name, int len) {\n\treturn !memchr(socket_name, ':', len);\n}\n\nint is_a_number(char *what) {\n\tint i;\n\n\tfor (i = 0; i < (int) strlen(what); i++) {\n\t\tif (!isdigit((int) what[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_unix_signal(int signum, void (*func) (int)) {\n\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\n\tsa.sa_handler = func;\n\n\tsigemptyset(&sa.sa_mask);\n\n\tif (sigaction(signum, &sa, NULL) < 0) {\n\t\tuwsgi_error(\"sigaction()\");\n\t}\n}\n\nint uwsgi_list_has_num(char *list, int num) {\n\n\tchar *list2 = uwsgi_concat2(list, \"\");\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \",\", p, ctx) {\n\t\tif (atoi(p) == num) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nint uwsgi_list_has_str(char *list, char *str) {\n\n\tchar *list2 = uwsgi_str(list);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \" \", p, ctx) {\n\t\tif (!strcasecmp(p, str)) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nstatic char hex2num(char *str) {\n\n\tchar val = 0;\n\n\tval <<= 4;\n\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tval += str[0] & 0x0F;\n\t}\n\telse if (str[0] >= 'A' && str[0] <= 'F') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse if (str[0] >= 'a' && str[0] <= 'f') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\tval <<= 4;\n\n\tif (str[1] >= '0' && str[1] <= '9') {\n\t\tval += str[1] & 0x0F;\n\t}\n\telse if (str[1] >= 'A' && str[1] <= 'F') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse if (str[1] >= 'a' && str[1] <= 'f') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\n\nint uwsgi_str2_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 10 * (str[0] - 48);\n\tnum += str[1] - 48;\n\n\treturn num;\n}\n\nint uwsgi_str3_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 100 * (str[0] - 48);\n\tnum += 10 * (str[1] - 48);\n\tnum += str[2] - 48;\n\n\treturn num;\n}\n\n\nint uwsgi_str4_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 1000 * (str[0] - 48);\n\tnum += 100 * (str[1] - 48);\n\tnum += 10 * (str[2] - 48);\n\tnum += str[3] - 48;\n\n\treturn num;\n}\n\nuint64_t uwsgi_str_num(char *str, int len) {\n\n\tint i;\n\tuint64_t num = 0;\n\n\tuint64_t delta = pow(10, len);\n\n\tfor (i = 0; i < len; i++) {\n\t\tdelta = delta / 10;\n\t\tnum += delta * (str[i] - 48);\n\t}\n\n\treturn num;\n}\n\nchar *uwsgi_split3(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2) {\n\t\tif (*part2 + *part2_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part3 = *part2 + *part2_len + 1;\n\t\t*part3_len = (buf + len) - *part3;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_split4(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len, char **part4, size_t * part4_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\t*part4 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\t// get part3\n\t\t\telse if (status == 2) {\n\t\t\t\t*part3 = *part2 + *part2_len + 1;\n\t\t\t\t*part3_len = (buf + i) - *part3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2 && *part3) {\n\t\tif (*part3 + *part3_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part4 = *part3 + *part3_len + 1;\n\t\t*part4_len = (buf + len) - *part4;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\n\nchar *uwsgi_netstring(char *buf, size_t len, char **netstring, size_t * netstring_len) {\n\n\tchar *ptr = buf;\n\tchar *watermark = buf + len;\n\t*netstring_len = 0;\n\n\twhile (ptr < watermark) {\n\t\t// end of string size ?\n\t\tif (*ptr == ':') {\n\t\t\t*netstring_len = uwsgi_str_num(buf, ptr - buf);\n\n\t\t\tif (ptr + *netstring_len + 2 > watermark) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*netstring = ptr + 1;\n\t\t\treturn ptr + *netstring_len + 2;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_dyn_dict *uwsgi_dyn_dict_new(struct uwsgi_dyn_dict **dd, char *key, int keylen, char *val, int vallen) {\n\n\tstruct uwsgi_dyn_dict *uwsgi_dd = *dd, *old_dd;\n\n\tif (!uwsgi_dd) {\n\t\t*dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\tuwsgi_dd = *dd;\n\t\tuwsgi_dd->prev = NULL;\n\t}\n\telse {\n\t\twhile (uwsgi_dd) {\n\t\t\told_dd = uwsgi_dd;\n\t\t\tuwsgi_dd = uwsgi_dd->next;\n\t\t}\n\n\t\tuwsgi_dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\told_dd->next = uwsgi_dd;\n\t\tuwsgi_dd->prev = old_dd;\n\t}\n\n\tuwsgi_dd->key = key;\n\tuwsgi_dd->keylen = keylen;\n\tuwsgi_dd->value = val;\n\tuwsgi_dd->vallen = vallen;\n\tuwsgi_dd->hits = 0;\n\tuwsgi_dd->status = 0;\n\tuwsgi_dd->next = NULL;\n\n\treturn uwsgi_dd;\n}\n\nvoid uwsgi_dyn_dict_del(struct uwsgi_dyn_dict *item) {\n\n\tstruct uwsgi_dyn_dict *prev = item->prev;\n\tstruct uwsgi_dyn_dict *next = item->next;\n\n\tif (prev) {\n\t\tprev->next = next;\n\t}\n\n\tif (next) {\n\t\tnext->prev = prev;\n\t}\n\n\tfree(item);\n}\n\nvoid uwsgi_dyn_dict_free(struct uwsgi_dyn_dict **dd) {\n\tstruct uwsgi_dyn_dict *attr = *dd;\n\n\twhile(attr) {\n\t\tstruct uwsgi_dyn_dict *tmp = attr;\n\t\tattr = attr->next;\n\t\tif (tmp->value) free(tmp->value);\n\t\tfree(tmp);\n\t}\n\n\t*dd = NULL;\n}\n\nvoid *uwsgi_malloc_shared(size_t size) {\n\n\tvoid *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);\n\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_log(\"unable to allocate %llu bytes (%lluMB)\\n\", (unsigned long long) size, (unsigned long long) (size / (1024 * 1024)));\n\t\tuwsgi_error(\"mmap()\");\n\t\texit(1);\n\t}\n\n\treturn addr;\n}\n\nvoid *uwsgi_calloc_shared(size_t size) {\n\tvoid *ptr = uwsgi_malloc_shared(size);\n\t// NOTE by Mathieu Dupuy:\n\t// OSes guarantee mmap MAP_ANON memory area to be zero-filled (see man pages)\n\n\t// we should trust it, but history has taught us it is better to be paranoid.\n\t// Lucky enough this function is called ony in startup phases, so performance\n\t// tips/tricks are irrelevant (So, le'ts call memset...)\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n\n\nstruct uwsgi_string_list *uwsgi_string_new_list(struct uwsgi_string_list **list, char *value) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string;\n\n\tif (!uwsgi_string) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\tuwsgi_string = *list;\n\t}\n\telse {\n\t\twhile (uwsgi_string) {\n\t\t\told_uwsgi_string = uwsgi_string;\n\t\t\tuwsgi_string = uwsgi_string->next;\n\t\t}\n\n\t\tuwsgi_string = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\told_uwsgi_string->next = uwsgi_string;\n\t}\n\n\tuwsgi_string->value = value;\n\tuwsgi_string->len = 0;\n\tif (value) {\n\t\tuwsgi_string->len = strlen(value);\n\t}\n\tuwsgi_string->next = NULL;\n\tuwsgi_string->custom = 0;\n\tuwsgi_string->custom2 = 0;\n\tuwsgi_string->custom_ptr = NULL;\n\n\treturn uwsgi_string;\n}\n\n#ifdef UWSGI_PCRE\nstruct uwsgi_regexp_list *uwsgi_regexp_custom_new_list(struct uwsgi_regexp_list **list, char *value, char *custom) {\n\n\tstruct uwsgi_regexp_list *url = *list, *old_url;\n\n\tif (!url) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\turl = *list;\n\t}\n\telse {\n\t\twhile (url) {\n\t\t\told_url = url;\n\t\t\turl = url->next;\n\t\t}\n\n\t\turl = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\told_url->next = url;\n\t}\n\n\tif (uwsgi_regexp_build(value, &url->pattern, &url->pattern_extra)) {\n\t\texit(1);\n\t}\n\turl->next = NULL;\n\turl->custom = 0;\n\turl->custom_ptr = NULL;\n\turl->custom_str = custom;\n\n\treturn url;\n}\n\nint uwsgi_regexp_match_pattern(char *pattern, char *str) {\n\n\tpcre *regexp;\n\tpcre_extra *regexp_extra;\n\n\tif (uwsgi_regexp_build(pattern, &regexp, &regexp_extra))\n\t\treturn 1;\n\treturn !uwsgi_regexp_match(regexp, regexp_extra, str, strlen(str));\n}\n\n\n#endif\n\nchar *uwsgi_string_get_list(struct uwsgi_string_list **list, int pos, size_t * len) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list;\n\tint counter = 0;\n\n\twhile (uwsgi_string) {\n\t\tif (counter == pos) {\n\t\t\t*len = uwsgi_string->len;\n\t\t\treturn uwsgi_string->value;\n\t\t}\n\t\tuwsgi_string = uwsgi_string->next;\n\t\tcounter++;\n\t}\n\n\t*len = 0;\n\treturn NULL;\n\n}\n\n\nvoid uwsgi_string_del_list(struct uwsgi_string_list **list, struct uwsgi_string_list *item) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string = NULL;\n\n\twhile (uwsgi_string) {\n\t\tif (uwsgi_string == item) {\n\t\t\t// parent instance ?\n\t\t\tif (old_uwsgi_string == NULL) {\n\t\t\t\t*list = uwsgi_string->next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\told_uwsgi_string->next = uwsgi_string->next;\n\t\t\t}\n\n\t\t\tfree(uwsgi_string);\n\t\t\treturn;\n\t\t}\n\n\t\told_uwsgi_string = uwsgi_string;\n\t\tuwsgi_string = uwsgi_string->next;\n\t}\n\n}\n\nvoid uwsgi_sig_pause() {\n\n\tsigset_t mask;\n\tsigemptyset(&mask);\n\tsigsuspend(&mask);\n}\n\nchar *uwsgi_binsh() {\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.binsh) {\n\t\tif (uwsgi_file_executable(usl->value)) {\n\t\t\treturn usl->value;\n\t\t}\n\t}\n\treturn \"/bin/sh\";\n}\n\nvoid uwsgi_exec_command_with_args(char *cmdline) {\n\tchar *argv[4];\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = cmdline;\n\targv[3] = NULL;\n\texecvp(argv[0], argv);\n\tuwsgi_error(\"execvp()\");\n\texit(1);\n}\n\nstatic int uwsgi_run_command_do(char *command, char *arg) {\n\n\tchar *argv[4];\n\n#ifdef __linux__\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tuwsgi_error(\"prctl()\");\n\t}\n#endif\n\n\tif (command == NULL) {\n\t\targv[0] = uwsgi_binsh();\n\t\targv[1] = \"-c\";\n\t\targv[2] = arg;\n\t\targv[3] = NULL;\n\t\texecvp(argv[0], argv);\n\t}\n\telse {\n\t\targv[0] = command;\n\t\targv[1] = arg;\n\t\targv[2] = NULL;\n\t\texecvp(command, argv);\n\t}\n\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_run_command_and_wait(char *command, char *arg) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\treturn uwsgi_run_command_do(command, arg);\n}\n\nint uwsgi_run_command_putenv_and_wait(char *command, char *arg, char **envs, unsigned int nenvs) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\n\tunsigned int i;\n\tfor (i = 0; i < nenvs; i++) {\n\t\tif (putenv(envs[i])) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_putenv_and_wait()/putenv()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn uwsgi_run_command_do(command, arg);\n}\n\n\npid_t uwsgi_run_command(char *command, int *stdin_fd, int stdout_fd) {\n\n\tchar *argv[4];\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (stdin_fd && stdin_fd[0] > -1) {\n\t\t\tclose(stdin_fd[0]);\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tclose(stdout_fd);\n\t\t}\n\t\tif (waitpid(pid, &waitpid_status, WNOHANG) < 0) {\n\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn pid;\n\t}\n\n\tuwsgi_close_all_sockets();\n\t//uwsgi_close_all_fds();\n\tint i;\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n\t\tif (stdin_fd) {\n\t\t\tif (i == stdin_fd[0] || i == stdin_fd[1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tif (i == stdout_fd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#ifdef __APPLE__\n\t\tfcntl(i, F_SETFD, FD_CLOEXEC);\n#else\n\t\tclose(i);\n#endif\n\t}\n\n\n\n\tif (stdin_fd) {\n\t\tclose(stdin_fd[1]);\n\t}\n\telse {\n\t\tif (!uwsgi_valid_fd(0)) {\n\t\t\tint in_fd = open(\"/dev/null\", O_RDONLY);\n\t\t\tif (in_fd < 0) {\n\t\t\t\tuwsgi_error_open(\"/dev/null\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (in_fd != 0) {\n\t\t\t\t\tif (dup2(in_fd, 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stdout_fd > -1 && stdout_fd != 1) {\n\t\tif (dup2(stdout_fd, 1) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (stdin_fd && stdin_fd[0] > -1 && stdin_fd[0] != 0) {\n\t\tif (dup2(stdin_fd[0], 0) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = command;\n\targv[3] = NULL;\n\n\texecvp(uwsgi_binsh(), argv);\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_endswith(char *str1, char *str2) {\n\n\tsize_t i;\n\tsize_t str1len = strlen(str1);\n\tsize_t str2len = strlen(str2);\n\tchar *ptr;\n\n\tif (str2len > str1len)\n\t\treturn 0;\n\n\tptr = (str1 + str1len) - str2len;\n\n\tfor (i = 0; i < str2len; i++) {\n\t\tif (*ptr != str2[i])\n\t\t\treturn 0;\n\t\tptr++;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_chown(char *filename, char *owner) {\n\n\tuid_t new_uid = -1;\n\tuid_t new_gid = -1;\n\tstruct group *new_group = NULL;\n\tstruct passwd *new_user = NULL;\n\n\tchar *colon = strchr(owner, ':');\n\tif (colon) {\n\t\tcolon[0] = 0;\n\t}\n\n\n\tif (is_a_number(owner)) {\n\t\tnew_uid = atoi(owner);\n\t}\n\telse {\n\t\tnew_user = getpwnam(owner);\n\t\tif (!new_user) {\n\t\t\tuwsgi_log(\"unable to find user %s\\n\", owner);\n\t\t\texit(1);\n\t\t}\n\t\tnew_uid = new_user->pw_uid;\n\t}\n\n\tif (colon) {\n\t\tcolon[0] = ':';\n\t\tif (is_a_number(colon + 1)) {\n\t\t\tnew_gid = atoi(colon + 1);\n\t\t}\n\t\telse {\n\t\t\tnew_group = getgrnam(colon + 1);\n\t\t\tif (!new_group) {\n\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", colon + 1);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnew_gid = new_group->gr_gid;\n\t\t}\n\t}\n\n\tif (chown(filename, new_uid, new_gid)) {\n\t\tuwsgi_error(\"chown()\");\n\t\texit(1);\n\t}\n\n}\n\nchar *uwsgi_get_binary_path(char *argvzero) {\n\n#if defined(__linux__) || defined(__CYGWIN__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/self/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(_WIN32)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tif (GetModuleFileName(NULL, buf, PATH_MAX) > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__NetBSD__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/curproc/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\n\tif (realpath(argvzero, buf)) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__APPLE__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tuint32_t len = uwsgi.page_size;\n\tif (_NSGetExecutablePath(buf, &len) == 0) {\n\t\t// return only absolute path\n#ifndef OLD_REALPATH\n\t\tchar *newbuf = realpath(buf, NULL);\n\t\tif (newbuf) {\n\t\t\tfree(buf);\n\t\t\treturn newbuf;\n\t\t}\n#endif\n\t}\n\tfree(buf);\n#elif defined(__sun__)\n\t// do not free this value !!!\n\tchar *buf = (char *) getexecname();\n\tif (buf) {\n\t\t// return only absolute path\n\t\tif (buf[0] == '/') {\n\t\t\treturn buf;\n\t\t}\n\n\t\tchar *newbuf = uwsgi_malloc(PATH_MAX + 1);\n\t\tif (realpath(buf, newbuf)) {\n\t\t\treturn newbuf;\n\t\t}\n\t}\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tsize_t len = uwsgi.page_size;\n\tint mib[4];\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PATHNAME;\n\tmib[3] = -1;\n\tif (sysctl(mib, 4, buf, &len, NULL, 0) == 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#endif\n\n\n\treturn argvzero;\n\n}\n\nchar *uwsgi_get_line(char *ptr, char *watermark, int *size) {\n\tchar *p = ptr;\n\tint count = 0;\n\n\twhile (p < watermark) {\n\t\tif (*p == '\\n') {\n\t\t\t*size = count;\n\t\t\treturn ptr + count;\n\t\t}\n\t\tcount++;\n\t\tp++;\n\t}\n\n\treturn NULL;\n}\n\nvoid uwsgi_build_mime_dict(char *filename) {\n\n\tsize_t size = 0;\n\tchar *buf = uwsgi_open_and_read(filename, &size, 1, NULL);\n\tchar *watermark = buf + size;\n\n\tint linesize = 0;\n\tchar *line = buf;\n\tint i;\n\tint type_size = 0;\n\tint ext_start = 0;\n\tint found;\n\tint entries = 0;\n\n\tuwsgi_log(\"building mime-types dictionary from file %s...\", filename);\n\n\twhile (uwsgi_get_line(line, watermark, &linesize) != NULL) {\n\t\tfound = 0;\n\t\tif (isalnum((int) line[0])) {\n\t\t\t// get the type size\n\t\t\tfor (i = 0; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n\t\t\t\t\ttype_size = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 0;\n\t\t\tfor (i = type_size; i < linesize; i++) {\n\t\t\t\tif (!isblank((int) line[i])) {\n\t\t\t\t\text_start = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *current = line + ext_start;\n\t\t\tint ext_size = 0;\n\t\t\tfor (i = ext_start; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n#ifdef UWSGI_DEBUG\n\t\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\t\tentries++;\n\t\t\t\t\text_size = 0;\n\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (current == NULL) {\n\t\t\t\t\tcurrent = line + i;\n\t\t\t\t}\n\t\t\t\text_size++;\n\t\t\t}\n\t\t\tif (current && ext_size > 1) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\tentries++;\n\t\t\t}\n\n\t\t}\n\t\tline += linesize + 1;\n\t}\n\n\tuwsgi_log(\"%d entry found\\n\", entries);\n\n}\n\n#ifdef __linux__\nstruct uwsgi_unshare_id {\n\tchar *name;\n\tint value;\n};\n\nstatic struct uwsgi_unshare_id uwsgi_unshare_list[] = {\n#ifdef CLONE_FILES\n\t{\"files\", CLONE_FILES},\n#endif\n#ifdef CLONE_NEWIPC\n\t{\"ipc\", CLONE_NEWIPC},\n#endif\n#ifdef CLONE_NEWNET\n\t{\"net\", CLONE_NEWNET},\n#endif\n#ifdef CLONE_IO\n\t{\"io\", CLONE_IO},\n#endif\n#ifdef CLONE_PARENT\n\t{\"parent\", CLONE_PARENT},\n#endif\n#ifdef CLONE_NEWPID\n\t{\"pid\", CLONE_NEWPID},\n#endif\n#ifdef CLONE_NEWNS\n\t{\"ns\", CLONE_NEWNS},\n\t{\"fs\", CLONE_NEWNS},\n\t{\"mount\", CLONE_NEWNS},\n\t{\"mnt\", CLONE_NEWNS},\n#endif\n#ifdef CLONE_SYSVSEM\n\t{\"sysvsem\", CLONE_SYSVSEM},\n#endif\n#ifdef CLONE_NEWUTS\n\t{\"uts\", CLONE_NEWUTS},\n#endif\n#ifdef CLONE_NEWUSER\n\t{\"user\", CLONE_NEWUSER},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_unshare_id(char *name) {\n\n\tstruct uwsgi_unshare_id *uui = uwsgi_unshare_list;\n\twhile (uui->name) {\n\t\tif (!strcmp(uui->name, name))\n\t\t\treturn uui->value;\n\t\tuui++;\n\t}\n\n\treturn -1;\n}\n\nvoid uwsgi_build_unshare(char *what, int *mask) {\n\n\tchar *list = uwsgi_str(what);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list, \",\", p, ctx) {\n\t\tint u_id = uwsgi_get_unshare_id(p);\n\t\tif (u_id != -1) {\n\t\t\t*mask |= u_id;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unknown namespace subsystem: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(list);\n}\n\n\n#endif\n\n#ifdef UWSGI_CAP\nstruct uwsgi_cap {\n\tchar *name;\n\tcap_value_t value;\n};\n\nstatic struct uwsgi_cap uwsgi_cap_list[] = {\n\t{\"chown\", CAP_CHOWN},\n\t{\"dac_override\", CAP_DAC_OVERRIDE},\n\t{\"dac_read_search\", CAP_DAC_READ_SEARCH},\n\t{\"fowner\", CAP_FOWNER},\n\t{\"fsetid\", CAP_FSETID},\n\t{\"kill\", CAP_KILL},\n\t{\"setgid\", CAP_SETGID},\n\t{\"setuid\", CAP_SETUID},\n\t{\"setpcap\", CAP_SETPCAP},\n\t{\"linux_immutable\", CAP_LINUX_IMMUTABLE},\n\t{\"net_bind_service\", CAP_NET_BIND_SERVICE},\n\t{\"net_broadcast\", CAP_NET_BROADCAST},\n\t{\"net_admin\", CAP_NET_ADMIN},\n\t{\"net_raw\", CAP_NET_RAW},\n\t{\"ipc_lock\", CAP_IPC_LOCK},\n\t{\"ipc_owner\", CAP_IPC_OWNER},\n\t{\"sys_module\", CAP_SYS_MODULE},\n\t{\"sys_rawio\", CAP_SYS_RAWIO},\n\t{\"sys_chroot\", CAP_SYS_CHROOT},\n\t{\"sys_ptrace\", CAP_SYS_PTRACE},\n\t{\"sys_pacct\", CAP_SYS_PACCT},\n\t{\"sys_admin\", CAP_SYS_ADMIN},\n\t{\"sys_boot\", CAP_SYS_BOOT},\n\t{\"sys_nice\", CAP_SYS_NICE},\n\t{\"sys_resource\", CAP_SYS_RESOURCE},\n\t{\"sys_time\", CAP_SYS_TIME},\n\t{\"sys_tty_config\", CAP_SYS_TTY_CONFIG},\n\t{\"mknod\", CAP_MKNOD},\n#ifdef CAP_LEASE\n\t{\"lease\", CAP_LEASE},\n#endif\n#ifdef CAP_AUDIT_WRITE\n\t{\"audit_write\", CAP_AUDIT_WRITE},\n#endif\n#ifdef CAP_AUDIT_CONTROL\n\t{\"audit_control\", CAP_AUDIT_CONTROL},\n#endif\n#ifdef CAP_SETFCAP\n\t{\"setfcap\", CAP_SETFCAP},\n#endif\n#ifdef CAP_MAC_OVERRIDE\n\t{\"mac_override\", CAP_MAC_OVERRIDE},\n#endif\n#ifdef CAP_MAC_ADMIN\n\t{\"mac_admin\", CAP_MAC_ADMIN},\n#endif\n#ifdef CAP_SYSLOG\n\t{\"syslog\", CAP_SYSLOG},\n#endif\n#ifdef CAP_WAKE_ALARM\n\t{\"wake_alarm\", CAP_WAKE_ALARM},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_cap_id(char *name) {\n\n\tstruct uwsgi_cap *ucl = uwsgi_cap_list;\n\twhile (ucl->name) {\n\t\tif (!strcmp(ucl->name, name))\n\t\t\treturn ucl->value;\n\t\tucl++;\n\t}\n\n\treturn -1;\n}\n\nint uwsgi_build_cap(char *what, cap_value_t ** cap) {\n\n\tint cap_id;\n\tchar *caps = uwsgi_str(what);\n\tint pos = 0;\n\tint count = 0;\n\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t\tif (cap_id != -1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t}\n\tfree(caps);\n\n\t*cap = uwsgi_malloc(sizeof(cap_value_t) * count);\n\n\tcaps = uwsgi_str(what);\n\tctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcap_id = atoi(p);\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t}\n\t\tif (cap_id != -1) {\n\t\t\t(*cap)[pos] = cap_id;\n\t\t\tuwsgi_log(\"setting capability %s [%d]\\n\", p, cap_id);\n\t\t\tpos++;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t}\n\t}\n\tfree(caps);\n\n\treturn count;\n}\n\n#endif\n\nvoid uwsgi_apply_config_pass(char symbol, char *(*hook) (char *)) {\n\n\tint i, j;\n\n\tfor (i = 0; i < uwsgi.exported_opts_cnt; i++) {\n\t\tint has_symbol = 0;\n\t\tint depth = 0;\n\t\tchar *magic_key = NULL;\n\t\tchar *magic_val = NULL;\n\t\tif (uwsgi.exported_opts[i]->value && !uwsgi.exported_opts[i]->configured) {\n\t\t\tfor (j = 0; j < (int) strlen(uwsgi.exported_opts[i]->value); j++) {\n\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == symbol) {\n\t\t\t\t\thas_symbol = 1;\n\t\t\t\t}\n\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == '(' && has_symbol == 1) {\n\t\t\t\t\thas_symbol = 2;\n\t\t\t\t\tdepth = 0;\n\t\t\t\t\tmagic_key = uwsgi.exported_opts[i]->value + j + 1;\n\t\t\t\t}\n\t\t\t\telse if (has_symbol > 1) {\n\t\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == '(') {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == ')') {\n\t\t\t\t\t\tif (depth > 0) {\n\t\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (has_symbol <= 2) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"need to interpret the %.*s tag\\n\", has_symbol - 2, magic_key);\n#endif\n\t\t\t\t\t\tchar *tmp_magic_key = uwsgi_concat2n(magic_key, has_symbol - 2, \"\", 0);\n\t\t\t\t\t\tmagic_val = hook(tmp_magic_key);\n\t\t\t\t\t\tfree(tmp_magic_key);\n\t\t\t\t\t\tif (!magic_val) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuwsgi.exported_opts[i]->value = uwsgi_concat4n(uwsgi.exported_opts[i]->value, (magic_key - 2) - uwsgi.exported_opts[i]->value, magic_val, strlen(magic_val), magic_key + (has_symbol - 1), strlen(magic_key + (has_symbol - 1)), \"\", 0);\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"computed new value = %s\\n\", uwsgi.exported_opts[i]->value);\n#endif\n\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thas_symbol = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_set_processname(char *name) {\n\n#if defined(__linux__) || defined(__sun__)\n\tsize_t amount = 0;\n\tsize_t max_procname = uwsgi.argv_len + uwsgi.environ_len;\n\n\t// prepare for strncat\n\t*uwsgi.orig_argv[0] = 0;\n\n\tif (uwsgi.procname_prefix) {\n\t\tamount += strlen(uwsgi.procname_prefix);\n\t\tif (amount >= max_procname)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_prefix, max_procname - (amount + 1));\n\t}\n\n\tamount += strlen(name);\n\tif (amount >= max_procname)\n\t\treturn;\n\tstrncat(uwsgi.orig_argv[0], name, max_procname - (amount + 1));\n\n\tif (uwsgi.procname_append) {\n\t\tamount += strlen(uwsgi.procname_append);\n\t\tif (amount >= max_procname)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_append, max_procname - (amount + 1));\n\t}\n\n\t// if we fit into argv, only fill argv with spaces, otherwise use environ as well\n\tif (amount < uwsgi.argv_len)  {\n\t\tmax_procname = uwsgi.argv_len;\n\t}\n\t// fill with spaces...\n\tmemset(uwsgi.orig_argv[0] + amount + 1, ' ', max_procname - (amount + 1));\n\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__) || defined(__NetBSD__)\n\tif (uwsgi.procname_prefix) {\n\t\tif (!uwsgi.procname_append) {\n\t\t\tsetproctitle(\"-%s%s\", uwsgi.procname_prefix, name);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse if (uwsgi.procname_append) {\n\t\tif (!uwsgi.procname_prefix) {\n\t\t\tsetproctitle(\"-%s%s\", name, uwsgi.procname_append);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse {\n\t\tsetproctitle(\"-%s\", name);\n\t}\n#endif\n}\n\n// this is a wrapper for fork restoring original argv\npid_t uwsgi_fork(char *name) {\n\n\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\n#ifndef __CYGWIN__\n\t\tif (uwsgi.never_swap) {\n\t\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\t\tuwsgi_error(\"mlockall()\");\n\t\t\t}\n\t\t}\n#endif\n\n#if defined(__linux__) || defined(__sun__)\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.argc; i++) {\n\t\t\t// stop fixing original argv if the new one is bigger\n\t\t\tif (!uwsgi.orig_argv[i]) break;\n\t\t\tstrcpy(uwsgi.orig_argv[i], uwsgi.argv[i]);\n\t\t}\n#endif\n\n\t\tif (uwsgi.auto_procname && name) {\n\t\t\tif (uwsgi.procname) {\n\t\t\t\tuwsgi_set_processname(uwsgi.procname);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_set_processname(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pid;\n}\n\nvoid escape_shell_arg(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (strchr(\"&;`'\\\"|*?~<>^()[]{}$\\\\\\n\", src[i])) {\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\t*ptr++ = src[i];\n\t}\n\n\t*ptr++ = 0;\n}\n\nvoid escape_json(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == '\\t') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 't';\n\t\t}\n\t\telse if (src[i] == '\\n') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'n';\n\t\t}\n\t\telse if (src[i] == '\\r') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'r';\n\t\t}\n\t\telse if (src[i] == '\"') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\"';\n\t\t}\n\t\telse if (src[i] == '\\\\') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\t*ptr++ = 0;\n}\n\n/*\n\nbuild PATH_INFO from raw_uri\n\nit manages:\n\n\tpercent encoding\n\tdot_segments removal\n\tstop at the first #\n\n*/\nvoid http_url_decode4(char *buf, uint16_t * len, char *dst, int no_slash_decode) {\n\n\tenum {\n\t\tzero = 0,\n\t\tpercent1,\n\t\tpercent2,\n\t\tslash,\n\t\tdot,\n\t\tdotdot\n\t} status;\n\n\tuint16_t i, current_new_len, new_len = 0;\n\n\tchar value[2];\n\n\tchar *ptr = dst;\n\n\tvalue[0] = '0';\n\tvalue[1] = '0';\n\n\tstatus = zero;\n\tint no_slash = 0;\n\n\tif (*len > 0 && buf[0] != '/') {\n\t\tstatus = slash;\n\t\tno_slash = 1;\n\t}\n\n\tfor (i = 0; i < *len; i++) {\n\t\tchar c = buf[i];\n\t\tif (c == '#')\n\t\t\tbreak;\n\t\tswitch (status) {\n\t\tcase zero:\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\tcase percent1:\n\t\t\tif (c == '%') {\n\t\t\t\t*ptr++ = '%';\n\t\t\t\tnew_len++;\n\t\t\t\tstatus = zero;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[0] = c;\n\t\t\tstatus = percent2;\n\t\t\tbreak;\n\t\tcase percent2:\n\t\t\tvalue[1] = c;\n\t\t\tif (no_slash_decode && value[0] == '2' && (value[1] == 'F' || value[1] == 'f')) {\n\t\t\t\t*ptr++ = '%';\n\t\t\t\t*ptr++ = value[0];\n\t\t\t\t*ptr++ = value[1];\n\t\t\t\tnew_len += 3;\n\t\t\t} else {\n\t\t\t\t*ptr++ = hex2num(value);\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase slash:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// we could be at the first round (in non slash)\n\t\t\tif (i > 0 || !no_slash) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dot:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dotdot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 1) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dotdot:\n\t\t\t// here we need to remove a segment\n\t\t\tif (c == '/') {\n\t\t\t\tcurrent_new_len = new_len;\n\t\t\t\twhile (current_new_len) {\n\t\t\t\t\tcurrent_new_len--;\n\t\t\t\t\tptr--;\n\t\t\t\t\tif (dst[current_new_len] == '/') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnew_len = current_new_len;\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 2) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\t\t// over engineering\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (status) {\n\tcase slash:\n\tcase dot:\n\t\t*ptr++ = '/';\n\t\tnew_len++;\n\t\tbreak;\n\tcase dotdot:\n\t\tcurrent_new_len = new_len;\n\t\twhile (current_new_len) {\n\t\t\tif (dst[current_new_len - 1] == '/') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_new_len--;\n\t\t}\n\t\tnew_len = current_new_len;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*len = new_len;\n\n}\n\n\n/*\n\twe scan the table in reverse, as updated values are at the end\n*/\nchar *uwsgi_get_var(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, uint16_t * len) {\n\n\tint i;\n\n\tfor (i = wsgi_req->var_cnt - 1; i > 0; i -= 2) {\n\t\tif (!uwsgi_strncmp(key, keylen, wsgi_req->hvec[i - 1].iov_base, wsgi_req->hvec[i - 1].iov_len)) {\n\t\t\t*len = wsgi_req->hvec[i].iov_len;\n\t\t\treturn wsgi_req->hvec[i].iov_base;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_app *uwsgi_add_app(int id, uint8_t modifier1, char *mountpoint, int mountpoint_len, void *interpreter, void *callable) {\n\n\tif (id > uwsgi.max_apps) {\n\t\tuwsgi_log(\"FATAL ERROR: you cannot load more than %d apps in a worker\\n\", uwsgi.max_apps);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_app *wi = &uwsgi_apps[id];\n\tmemset(wi, 0, sizeof(struct uwsgi_app));\n\n\twi->modifier1 = modifier1;\n\twi->mountpoint_len = mountpoint_len < 0xff ? mountpoint_len : (0xff - 1);\n\tstrncpy(wi->mountpoint, mountpoint, wi->mountpoint_len);\n\twi->interpreter = interpreter;\n\twi->callable = callable;\n\n\tuwsgi_apps_cnt++;\n\t// check if we need to emulate fork() COW\n\tint i;\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n\n\tif (!uwsgi.no_default_app) {\n\t\tif ((mountpoint_len == 0 || (mountpoint_len == 1 && mountpoint[0] == '/')) && uwsgi.default_app == -1) {\n\t\t\tuwsgi.default_app = id;\n\t\t}\n\t}\n\n\treturn wi;\n}\n\n\nchar *uwsgi_check_touches(struct uwsgi_string_list *touch_list) {\n\n\t// touch->value   - file path\n\t// touch->custom  - file timestamp\n\t// touch->custom2 - 0 if file exists, 1 if it does not exists\n\n\tstruct uwsgi_string_list *touch = touch_list;\n\twhile (touch) {\n\t\tstruct stat tr_st;\n\t\tif (stat(touch->value, &tr_st)) {\n\t\t\tif (touch->custom && !touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File %s was removed\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (!touch->custom && !touch->custom2) {\n\t\t\t\tuwsgi_log(\"unable to stat() %s, events will be triggered as soon as the file is created\\n\", touch->value);\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t}\n\t\t\ttouch->custom = 0;\n\t\t}\n\t\telse {\n\t\t\tif (!touch->custom && touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File was created: %s\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\ttouch->custom2 = 0;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (touch->custom && (uint64_t) tr_st.st_mtime > touch->custom) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] modification detected on %s: %llu -> %llu\\n\", touch->value, (unsigned long long) touch->custom, (unsigned long long) tr_st.st_mtime);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t}\n\t\ttouch = touch->next;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_chomp(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\nchar *uwsgi_chomp2(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n' || str[i] == '\\t' || str[i] == ' ') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n\n\nint uwsgi_tmpfd() {\n\tint fd = -1;\n\tchar *tmpdir = getenv(\"TMPDIR\");\n\tif (!tmpdir) {\n\t\ttmpdir = \"/tmp\";\n\t}\n#ifdef O_TMPFILE\n\tfd = open(tmpdir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\t// fallback to old style\n#endif\n\tchar *template = uwsgi_concat2(tmpdir, \"/uwsgiXXXXXX\");\n\tfd = mkstemp(template);\n\tunlink(template);\n\tfree(template);\n\treturn fd;\n}\n\nFILE *uwsgi_tmpfile() {\n\tint fd = uwsgi_tmpfd();\n\tif (fd < 0)\n\t\treturn NULL;\n\treturn fdopen(fd, \"w+\");\n}\n\nint uwsgi_file_to_string_list(char *filename, struct uwsgi_string_list **list) {\n\n\tchar line[1024];\n\n\tFILE *fh = fopen(filename, \"r\");\n\tif (fh) {\n\t\twhile (fgets(line, 1024, fh)) {\n\t\t\tuwsgi_string_new_list(list, uwsgi_chomp(uwsgi_str(line)));\n\t\t}\n\t\tfclose(fh);\n\t\treturn 1;\n\t}\n\tuwsgi_error_open(filename);\n\treturn 0;\n}\n\nvoid uwsgi_setup_post_buffering() {\n\n\tif (!uwsgi.post_buffering_bufsize)\n\t\tuwsgi.post_buffering_bufsize = 8192;\n\n\tif (uwsgi.post_buffering_bufsize < uwsgi.post_buffering) {\n\t\tuwsgi.post_buffering_bufsize = uwsgi.post_buffering;\n\t\tuwsgi_log(\"setting request body buffering size to %lu bytes\\n\", (unsigned long) uwsgi.post_buffering_bufsize);\n\t}\n\n}\n\nvoid uwsgi_emulate_cow_for_apps(int id) {\n\tint i;\n\t// check if we need to emulate fork() COW\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n}\n\nint uwsgi_write_intfile(char *filename, int n) {\n\tFILE *pidfile = fopen(filename, \"w\");\n\tif (!pidfile) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\tif (fprintf(pidfile, \"%d\\n\", n) <= 0 || ferror(pidfile)) {\n\t\tfclose(pidfile);\n\t\treturn -1;\n\t}\n\tif (fclose(pidfile)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_write_pidfile(char *pidfile_name) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) getpid())) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nvoid uwsgi_write_pidfile_explicit(char *pidfile_name, pid_t pid) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) pid)) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nchar *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tif (dir_len > PATH_MAX)\n\t{\n\t\tuwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);\n\t\treturn NULL;\n\t}\n\tchar *src = uwsgi_concat2n(dir, dir_len, \"\", 0);\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\tfree(src);\n\t\treturn NULL;\n\t}\n\tfree(src);\n\treturn dst;\n}\n\n\nvoid uwsgi_set_cpu_affinity() {\n\tchar buf[4096];\n\tint ret;\n\tint pos = 0;\n\tif (uwsgi.cpu_affinity) {\n\t\tint base_cpu = (uwsgi.mywid - 1) * uwsgi.cpu_affinity;\n\t\tif (base_cpu >= uwsgi.cpus) {\n\t\t\tbase_cpu = base_cpu % uwsgi.cpus;\n\t\t}\n\t\tret = snprintf(buf, 4096, \"mapping worker %d to CPUs:\", uwsgi.mywid);\n\t\tif (ret < 25 || ret >= 4096) {\n\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tpos += ret;\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tcpu_set_t cpuset;\n#elif defined(__FreeBSD__)\n\t\tcpuset_t cpuset;\n#endif\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\t\tCPU_ZERO(&cpuset);\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.cpu_affinity; i++) {\n\t\t\tif (base_cpu >= uwsgi.cpus)\n\t\t\t\tbase_cpu = 0;\n\t\t\tCPU_SET(base_cpu, &cpuset);\n\t\t\tret = snprintf(buf + pos, 4096 - pos, \" %d\", base_cpu);\n\t\t\tif (ret < 2 || ret >= 4096) {\n\t\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpos += ret;\n\t\t\tbase_cpu++;\n\t\t}\n#endif\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tif (sched_setaffinity(0, sizeof(cpu_set_t), &cpuset)) {\n\t\t\tuwsgi_error(\"sched_setaffinity()\");\n\t\t}\n#elif defined(__FreeBSD__)\n\t\tif (cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset), &cpuset)) {\n\t\t\tuwsgi_error(\"cpuset_setaffinity\");\n\t\t}\n#endif\n\t\tuwsgi_log(\"%s\\n\", buf);\n\t}\n\n}\n\n#ifdef UWSGI_ELF\n#if defined(__linux__)\n#include <elf.h>\n#endif\nchar *uwsgi_elf_section(char *filename, char *s, size_t * len) {\n\tstruct stat st;\n\tchar *output = NULL;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st)) {\n\t\tuwsgi_error(\"stat()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (st.st_size < EI_NIDENT) {\n\t\tuwsgi_log(\"invalid elf file: %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tchar *addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_error(\"mmap()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (addr[0] != ELFMAG0)\n\t\tgoto clear;\n\tif (addr[1] != ELFMAG1)\n\t\tgoto clear;\n\tif (addr[2] != ELFMAG2)\n\t\tgoto clear;\n\tif (addr[3] != ELFMAG3)\n\t\tgoto clear;\n\n\tif (addr[4] == ELFCLASS32) {\n\t\t// elf header\n\t\tElf32_Ehdr *elfh = (Elf32_Ehdr *) addr;\n\t\t// first section\n\t\tElf32_Shdr *sections = ((Elf32_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf32_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf32_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\telse if (addr[4] == ELFCLASS64) {\n\t\t// elf header\n\t\tElf64_Ehdr *elfh = (Elf64_Ehdr *) addr;\n\t\t// first section\n\t\tElf64_Shdr *sections = ((Elf64_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf64_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf64_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\n\nclear:\n\tclose(fd);\n\tmunmap(addr, st.st_size);\n\treturn output;\n}\n#endif\n\nstatic void *uwsgi_thread_run(void *arg) {\n\tstruct uwsgi_thread *ut = (struct uwsgi_thread *) arg;\n\t// block all signals\n\tsigset_t smask;\n\tsigfillset(&smask);\n\tpthread_sigmask(SIG_BLOCK, &smask, NULL);\n\n\tut->queue = event_queue_init();\n\tevent_queue_add_fd_read(ut->queue, ut->pipe[1]);\n\n\tut->func(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new_with_data(void (*func) (struct uwsgi_thread *), void *data) {\n\n\tstruct uwsgi_thread *ut = uwsgi_calloc(sizeof(struct uwsgi_thread));\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, ut->pipe)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, ut->pipe)) {\n#endif\n\t\tfree(ut);\n\t\treturn NULL;\n\t}\n\n\tuwsgi_socket_nb(ut->pipe[0]);\n\tuwsgi_socket_nb(ut->pipe[1]);\n\n\tut->func = func;\n\tut->data = data;\n\n\tpthread_attr_init(&ut->tattr);\n\tpthread_attr_setdetachstate(&ut->tattr, PTHREAD_CREATE_DETACHED);\n\t// 512K should be enough...\n\tpthread_attr_setstacksize(&ut->tattr, 512 * 1024);\n\n\tif (pthread_create(&ut->tid, &ut->tattr, uwsgi_thread_run, ut)) {\n\t\tuwsgi_error(\"pthread_create()\");\n\t\tgoto error;\n\t}\n\n\treturn ut;\nerror:\n\tclose(ut->pipe[0]);\n\tclose(ut->pipe[1]);\n\tfree(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new(void (*func) (struct uwsgi_thread *)) {\n\treturn uwsgi_thread_new_with_data(func, NULL);\n}\n\nint uwsgi_kvlist_parse(char *src, size_t len, char list_separator, int kv_separator, ...) {\n\tsize_t i;\n\tva_list ap;\n\tstruct uwsgi_string_list *itemlist = NULL;\n\n\tchar *buf = uwsgi_calloc(len + 1);\n\n\t// ok let's start splitting the string\n\tint escaped = 0;\n\tchar *base = buf;\n\tchar *ptr = buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == list_separator && !escaped) {\n\t\t\t*ptr++ = 0;\n\t\t\tuwsgi_string_new_list(&itemlist, base);\n\t\t\tbase = ptr;\n\t\t}\n\t\telse if (src[i] == '\\\\' && !escaped) {\n\t\t\tescaped = 1;\n\t\t}\n\t\telse if (escaped) {\n\t\t\t*ptr++ = src[i];\n\t\t\tescaped = 0;\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\tif (ptr > base) {\n\t\tuwsgi_string_new_list(&itemlist, base);\n\t}\n\n\tstruct uwsgi_string_list *usl = itemlist;\n\twhile (usl) {\n\t\tlen = strlen(usl->value);\n\t\tchar *item_buf = uwsgi_calloc(len + 1);\n\t\tbase = item_buf;\n\t\tptr = item_buf;\n\t\tescaped = 0;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (usl->value[i] == kv_separator && !escaped) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tva_start(ap, kv_separator);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar *p = va_arg(ap, char *);\n\t\t\t\t\tif (!p)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tchar **pp = va_arg(ap, char **);\n\t\t\t\t\tif (!pp)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!strcmp(p, base)) {\n\t\t\t\t\t\t*pp = uwsgi_str(usl->value + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tva_end(ap);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (usl->value[i] == '\\\\' && !escaped) {\n\t\t\t\tescaped = 1;\n\t\t\t}\n\t\t\telse if (escaped) {\n\t\t\t\tescaped = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*ptr++ = usl->value[i];\n\t\t\t}\n\t\t}\n\t\tfree(item_buf);\n\t\tusl = usl->next;\n\t}\n\n\t// destroy the list (no need to destroy the value as it is a pointer to buf)\n\tusl = itemlist;\n\twhile (usl) {\n\t\tstruct uwsgi_string_list *tmp_usl = usl;\n\t\tusl = usl->next;\n\t\tfree(tmp_usl);\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n\nint uwsgi_send_http_stats(int fd) {\n\n\tchar buf[4096];\n\n\tint ret = uwsgi_waitfd(fd, uwsgi.socket_timeout);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tif (read(fd, buf, 4096) <= 0)\n\t\treturn -1;\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\tif (!ub)\n\t\treturn -1;\n\n\tif (uwsgi_buffer_append(ub, \"HTTP/1.0 200 OK\\r\\n\", 17))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Connection: close\\r\\n\", 19))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Access-Control-Allow-Origin: *\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Content-Type: application/json\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"\\r\\n\", 2))\n\t\tgoto error;\n\n\tif (uwsgi_buffer_send(ub, fd))\n\t\tgoto error;\n\tuwsgi_buffer_destroy(ub);\n\treturn 0;\n\nerror:\n\tuwsgi_buffer_destroy(ub);\n\treturn -1;\n}\n\nint uwsgi_call_symbol(char *symbol) {\n\tvoid (*func) (void) = dlsym(RTLD_DEFAULT, symbol);\n\tif (!func)\n\t\treturn -1;\n\tfunc();\n\treturn 0;\n}\n\nint uwsgi_plugin_modifier1(char *plugin) {\n\tint ret = -1;\n\tchar *symbol_name = uwsgi_concat2(plugin, \"_plugin\");\n\tstruct uwsgi_plugin *up = dlsym(RTLD_DEFAULT, symbol_name);\n\tif (!up)\n\t\tgoto end;\n\tret = up->modifier1;\nend:\n\tfree(symbol_name);\n\treturn ret;\n}\n\nchar *uwsgi_strip(char *src) {\n\tchar *dst = src;\n\tsize_t len = strlen(src);\n\tint i;\n\n\tfor (i = 0; i < (ssize_t) len; i++) {\n\t\tif (src[i] == ' ' || src[i] == '\\t') {\n\t\t\tdst++;\n\t\t}\n\t}\n\n\tlen -= (dst - src);\n\n\tfor (i = len; i >= 0; i--) {\n\t\tif (dst[i] == ' ' || dst[i] == '\\t') {\n\t\t\tdst[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dst;\n}\n\nvoid uwsgi_uuid(char *buf) {\n#ifdef UWSGI_UUID\n\tuuid_t uuid_value;\n\tuuid_generate(uuid_value);\n\tuuid_unparse(uuid_value, buf);\n#else\n\tint i, r[11];\n\tif (!uwsgi_file_exists(\"/dev/urandom\"))\n\t\tgoto fallback;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\tgoto fallback;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (read(fd, &r[i], 4) != 4) {\n\t\t\tclose(fd);\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\tclose(fd);\n\tgoto done;\nfallback:\n\tfor (i = 0; i < 11; i++) {\n\t\tr[i] = rand();\n\t}\ndone:\n\tsnprintf(buf, 37, \"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]);\n#endif\n}\n\nint uwsgi_uuid_cmp(char *x, char *y) {\n\tint i;\n\tfor (i = 0; i < 36; i++) {\n\t\tif (x[i] != y[i]) {\n\t\t\tif (x[i] > y[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_additional_header_add(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\t// will be freed on request's end\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->additional_headers, header);\n}\n\nvoid uwsgi_remove_header(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->remove_headers, header);\n}\n\n// based on nginx implementation\n\nstatic uint8_t b64_table64[] = {\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77, 77, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,\n\t77, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 77,\n\t77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,\n\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77\n};\n\nstatic char b64_table64_2[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar *uwsgi_base64_decode(char *buf, size_t len, size_t * d_len) {\n\n\t// find the real size and check for invalid values\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == '=')\n\t\t\tbreak;\n\n\t\t// check for invalid content\n\t\tif (b64_table64[(uint8_t) buf[i]] == 77) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// check for invalid size\n\tif (i % 4 == 1)\n\t\treturn NULL;\n\n\t// compute the new size\n\t*d_len = (((len + 3) / 4) * 3);\n\tchar *dst = uwsgi_malloc(*d_len + 1);\n\n\tchar *ptr = dst;\n\tuint8_t *src = (uint8_t *) buf;\n\twhile (i > 3) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t\t*ptr++ = (char) (b64_table64[src[2]] << 6 | b64_table64[src[3]]);\n\n\t\tsrc += 4;\n\t\ti -= 4;\n\t}\n\n\tif (i > 1) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t}\n\n\tif (i > 2) {\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t}\n\n\t*d_len = (ptr - dst);\n\t*ptr++ = 0;\n\n\treturn dst;\n\n}\n\nchar *uwsgi_base64_encode(char *buf, size_t len, size_t * d_len) {\n\t*d_len = ((len * 4) / 3) + 5;\n\tuint8_t *src = (uint8_t *) buf;\n\tchar *dst = uwsgi_malloc(*d_len);\n\tchar *ptr = dst;\n\twhile (len >= 3) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\t*ptr++ = b64_table64_2[((src[0] << 4) & 0x30) | (src[1] >> 4)];\n\t\t*ptr++ = b64_table64_2[((src[1] << 2) & 0x3C) | (src[2] >> 6)];\n\t\t*ptr++ = b64_table64_2[src[2] & 0x3F];\n\t\tsrc += 3;\n\t\tlen -= 3;\n\t}\n\n\tif (len > 0) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\tuint8_t tmp = (src[0] << 4) & 0x30;\n\t\tif (len > 1)\n\t\t\ttmp |= src[1] >> 4;\n\t\t*ptr++ = b64_table64_2[tmp];\n\t\tif (len < 2) {\n\t\t\t*ptr++ = '=';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = b64_table64_2[(src[1] << 2) & 0x3C];\n\t\t}\n\t\t*ptr++ = '=';\n\t}\n\n\t*ptr = 0;\n\t*d_len = ((char *) ptr - dst);\n\n\treturn dst;\n}\n\nuint16_t uwsgi_be16(char *buf) {\n\tuint16_t *src = (uint16_t *) buf;\n\tuint16_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[1] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint32_t uwsgi_be32(char *buf) {\n\tuint32_t *src = (uint32_t *) buf;\n\tuint32_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[3] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint64_t uwsgi_be64(char *buf) {\n\tuint64_t *src = (uint64_t *) buf;\n\tuint64_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 56) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 48) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 40) & 0xff);\n\tptr[3] = (uint8_t) ((*src >> 32) & 0xff);\n\tptr[4] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[5] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[6] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[7] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nchar *uwsgi_get_header(struct wsgi_request *wsgi_req, char *hh, uint16_t len, uint16_t * rlen) {\n\tchar *key = uwsgi_malloc(len + 6);\n\tuint16_t key_len = len;\n\tchar *ptr = key;\n\t*rlen = 0;\n\tif (uwsgi_strncmp(hh, len, \"Content-Length\", 14) && uwsgi_strncmp(hh, len, \"Content-Type\", 12)) {\n\t\tmemcpy(ptr, \"HTTP_\", 5);\n\t\tptr += 5;\n\t\tkey_len += 5;\n\t}\n\n\tuint16_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (hh[i] == '-') {\n\t\t\t*ptr++ = '_';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = toupper((int) hh[i]);\n\t\t}\n\t}\n\n\tchar *value = uwsgi_get_var(wsgi_req, key, key_len, rlen);\n\tfree(key);\n\treturn value;\n\n}\n\nstatic char *uwsgi_hex_table[] = {\n\t\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\", \"0C\", \"0D\", \"0E\", \"0F\",\n\t\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\",\n\t\"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\",\n\t\"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\", \"3C\", \"3D\", \"3E\", \"3F\",\n\t\"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\",\n\t\"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\",\n\t\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\", \"6C\", \"6D\", \"6E\", \"6F\",\n\t\"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\",\n\t\"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\",\n\t\"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\", \"9C\", \"9D\", \"9E\", \"9F\",\n\t\"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\", \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\",\n\t\"B0\", \"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\",\n\t\"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\", \"CC\", \"CD\", \"CE\", \"CF\",\n\t\"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\", \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\",\n\t\"E0\", \"E1\", \"E2\", \"E3\", \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\",\n\t\"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\", \"FC\", \"FD\", \"FE\", \"FF\",\n};\n\nchar *uwsgi_str_to_hex(char *src, size_t slen) {\n\tchar *dst = uwsgi_malloc(slen * 2);\n\tchar *ptr = dst;\n\tsize_t i;\n\tfor (i = 0; i < slen; i++) {\n\t\tuint8_t pos = (uint8_t) src[i];\n\t\tmemcpy(ptr, uwsgi_hex_table[pos], 2);\n\t\tptr += 2;\n\t}\n\treturn dst;\n}\n\n// dst has to be 3 times buf size (USE IT ONLY FOR PATH_INFO !!!)\nvoid http_url_encode(char *buf, uint16_t * len, char *dst) {\n\n\tuint16_t i;\n\tchar *ptr = dst;\n\tfor (i = 0; i < *len; i++) {\n\t\tif ((buf[i] >= 'A' && buf[i] <= 'Z') || (buf[i] >= 'a' && buf[i] <= 'z') || (buf[i] >= '0' && buf[i] <= '9') || buf[i] == '-' || buf[i] == '_' || buf[i] == '.' || buf[i] == '~' || buf[i] == '/') {\n\t\t\t*ptr++ = buf[i];\n\t\t}\n\t\telse {\n\t\t\tchar *h = uwsgi_hex_table[(int) buf[i]];\n\t\t\t*ptr++ = '%';\n\t\t\t*ptr++ = h[0];\n\t\t\t*ptr++ = h[1];\n\t\t}\n\t}\n\n\t*len = ptr - dst;\n\n}\n\nvoid uwsgi_takeover() {\n\tif (uwsgi.i_am_a_spooler) {\n\t\tuwsgi_spooler_run();\n\t}\n\telse if (uwsgi.muleid) {\n\t\tuwsgi_mule_run();\n\t}\n\telse {\n\t\tuwsgi_worker_run();\n\t}\n}\n\n// create a message pipe\nvoid create_msg_pipe(int *fd, int bufsize) {\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, fd)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, fd)) {\n#endif\n\t\tuwsgi_error(\"create_msg_pipe()/socketpair()\");\n\t\texit(1);\n\t}\n\n\tuwsgi_socket_nb(fd[0]);\n\tuwsgi_socket_nb(fd[1]);\n\n\tif (bufsize) {\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t}\n}\n\nchar *uwsgi_binary_path() {\n\treturn uwsgi.binary_path ? uwsgi.binary_path : \"uwsgi\";\n}\n\nvoid uwsgi_envdir(char *edir) {\n\tDIR *d = opendir(edir);\n\tif (!d) {\n\t\tuwsgi_error(\"[uwsgi-envdir] opendir()\");\n\t\texit(1);\n\t}\n\tstruct dirent *de;\n\twhile ((de = readdir(d)) != NULL) {\n\t\t// skip hidden files\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\t\tstruct stat st;\n\t\tchar *filename = uwsgi_concat3(edir, \"/\", de->d_name);\n\t\tif (stat(filename, &st)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] error stating %s\\n\", filename);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] stat()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// unsetenv\n\t\tif (st.st_size == 0) {\n#ifdef UNSETENV_VOID\n\t\t\tunsetenv(de->d_name);\n#else\n\t\t\tif (unsetenv(de->d_name)) {\n\t\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to unset %s\\n\", de->d_name);\n\t\t\t\tuwsgi_error(\"[uwsgi-envdir] unsetenv\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read the content of the file\n\t\tsize_t size = 0;\n\t\tchar *content = uwsgi_open_and_read(filename, &size, 1, NULL);\n\t\tif (!content) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to open %s\\n\", filename);\n\t\t\tuwsgi_error_open(filename);\n\t\t\texit(1);\n\t\t}\n\t\tfree(filename);\n\n\t\t// HACK, envdir states we only need to strip the end of the string ....\n\t\tuwsgi_chomp2(content);\n\t\t// ... and substitute 0 with \\n\n\t\tsize_t slen = strlen(content);\n\t\tsize_t i;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (content[i] == 0) {\n\t\t\t\tcontent[i] = '\\n';\n\t\t\t}\n\t\t}\n\n\t\tif (setenv(de->d_name, content, 1)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to set %s\\n\", de->d_name);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] setenv\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfree(content);\n\t}\n\tclosedir(d);\n}\n\nvoid uwsgi_envdirs(struct uwsgi_string_list *envdirs) {\n\tstruct uwsgi_string_list *usl = envdirs;\n\twhile (usl) {\n\t\tuwsgi_envdir(usl->value);\n\t\tusl = usl->next;\n\t}\n}\n\nvoid uwsgi_opt_envdir(char *opt, char *value, void *foobar) {\n\tuwsgi_envdir(value);\n}\n\nvoid uwsgi_exit(int status) {\n\tuwsgi.last_exit_code = status;\n\t// disable macro expansion\n\t(exit) (status);\n}\n\nint uwsgi_base128(struct uwsgi_buffer *ub, uint64_t l, int first) {\n\tif (l > 127) {\n\t\tif (uwsgi_base128(ub, l / 128, 0))\n\t\t\treturn -1;\n\t}\n\tl %= 128;\n\tif (first) {\n\t\tif (uwsgi_buffer_u8(ub, (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\telse {\n\t\tif (uwsgi_buffer_u8(ub, 0x80 | (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#ifdef __linux__\nvoid uwsgi_setns(char *path) {\n\tint (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, \"setns\");\n\tif (!u_setns) {\n\t\tuwsgi_log(\"your system misses setns() syscall !!!\\n\");\n\t\texit(1);\n\t}\n\n\t// count be overwritten\n\tint count = 64;\n\n\tuwsgi_log(\"joining namespaces from %s ...\\n\", path);\n\tfor (;;) {\n\t\tint ns_fd = uwsgi_connect(path, 30, 0);\n\t\tif (ns_fd < 0) {\n\t\t\tuwsgi_error(\"uwsgi_setns()/uwsgi_connect()\");\n\t\t\tsleep(1);\n\t\t\tcontinue;\n\t\t}\n\t\tint *fds = uwsgi_attach_fd(ns_fd, &count, \"uwsgi-setns\", 11);\n\t\tif (fds && count > 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (fds[i] > -1) {\n\t\t\t\t\tif (u_setns(fds[i], 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"uwsgi_setns()/setns()\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tclose(fds[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(fds);\n\t\t\tclose(ns_fd);\n\t\t\tbreak;\n\t\t}\n\t\tif (fds)\n\t\t\tfree(fds);\n\t\tclose(ns_fd);\n\t\tsleep(1);\n\t}\n}\n#endif\n\nmode_t uwsgi_mode_t(char *value, int *error) {\n\tmode_t mode = 0;\n\t*error = 0;\n\n        if (strlen(value) < 3) {\n\t\t*error = 1;\n\t\treturn mode;\n\t}\n\n        if (strlen(value) == 3) {\n                mode = (mode << 3) + (value[0] - '0');\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n        }\n        else {\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n                mode = (mode << 3) + (value[3] - '0');\n        }\n\n\treturn mode;\n}\n\nint uwsgi_wait_for_socket(char *socket_name) {\n        if (!uwsgi.wait_for_socket_timeout) {\n                uwsgi.wait_for_socket_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", socket_name, uwsgi.wait_for_socket_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_socket_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", socket_name, counter);\n                        return -1;\n                }\n\t\t// wait for 1 second to respect uwsgi.wait_for_fs_timeout\n\t\tint fd = uwsgi_connect(socket_name, 1, 0);\n\t\tif (fd < 0) goto retry;\n\t\tclose(fd);\n                uwsgi_log_verbose(\"%s ready\\n\", socket_name);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\nint uwsgi_wait_for_mountpoint(char *mountpoint) {\n        if (!uwsgi.wait_for_fs_timeout) {\n                uwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", mountpoint, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_fs_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", mountpoint, counter);\n                        return -1;\n                }\n\t\tstruct stat st0;\n\t\tstruct stat st1;\n\t\tif (stat(mountpoint, &st0)) goto retry;\n\t\tif (!S_ISDIR(st0.st_mode)) goto retry;\n\t\tchar *relative = uwsgi_concat2(mountpoint, \"/../\");\n\t\tif (stat(relative, &st1)) {\n\t\t\tfree(relative);\n\t\t\tgoto retry;\n\t\t}\n\t\tfree(relative);\n\t\t// useless :P\n                if (!S_ISDIR(st1.st_mode)) goto retry;\n\t\tif (st0.st_dev == st1.st_dev) goto retry;\n                uwsgi_log_verbose(\"%s mounted\\n\", mountpoint);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\n// type -> 1 file, 2 dir, 0 both\nint uwsgi_wait_for_fs(char *filename, int type) {\n\tif (!uwsgi.wait_for_fs_timeout) {\n        \tuwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", filename, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n        \tif (counter > uwsgi.wait_for_fs_timeout) {\n                \tuwsgi_log(\"%s unavailable after %d seconds\\n\", filename, counter);\n\t\t\treturn -1;\n                }\n\t\tstruct stat st;\n\t\tif (stat(filename, &st)) goto retry;\n\t\tif (type == 1 && !S_ISREG(st.st_mode)) goto retry;\n\t\tif (type == 2 && !S_ISDIR(st.st_mode)) goto retry;\n                uwsgi_log_verbose(\"%s found\\n\", filename);\n\t\treturn 0;\nretry:\n                sleep(1);\n                counter++;\n\t}\n\treturn -1;\n}\n\n#if !defined(_GNU_SOURCE) && !defined(__UCLIBC__)\nint uwsgi_versionsort(const struct dirent **da, const struct dirent **db) {\n\n        const char *a = (*da)->d_name;\n        const char *b = (*db)->d_name;\n\n        long la, lb;\n        char *endptr;\n\n        // Check if a and b are valid numbers.\n        la = strtol(a, &endptr, 10);\n        if (strcmp(endptr, \"\\0\") || endptr == a) {\n            a = NULL;\n        }\n\n        lb = strtol(b, &endptr, 10);\n        if (strcmp(endptr, \"\\0\") || endptr == b) {\n            b = NULL;\n        }\n\n        if (a && b) {\n            return (la < lb ? -1 : la > lb);\n        } else if (a) {\n            return -1;\n        } else if (b) {\n            return 1;\n        } else {\n            return strcmp((*da)->d_name, (*db)->d_name);\n        }\n}\n#endif\n\nvoid uwsgi_fix_range_for_size(enum uwsgi_range* parsed, int64_t* from, int64_t* to, int64_t size) {\n        if (*parsed != UWSGI_RANGE_PARSED) {\n                return;\n        }\n        if (*from < 0) {\n                *from = size + *from;\n        }\n        if (*to > size-1) {\n                *to = size-1;\n        }\n        if (*from == 0 && *to == size-1) {\n                /* we have a right to reset to 200 OK answer */\n                *parsed = UWSGI_RANGE_NOT_PARSED;\n        }\n        else if (*to >= *from) {\n                *parsed = UWSGI_RANGE_VALID;\n        }\n        else { /* case *from > size-1 is also handled here */\n                *parsed = UWSGI_RANGE_INVALID;\n                *from = 0;\n                *to = 0;\n        }\n}\n"], "filenames": ["core/utils.c"], "buggy_code_start_loc": [3677], "buggy_code_end_loc": [3688], "fixing_code_start_loc": [3677], "fixing_code_end_loc": [3694], "type": "CWE-787", "message": "The uwsgi_expand_path function in core/utils.c in Unbit uWSGI through 2.0.15 has a stack-based buffer overflow via a large directory length.", "other": {"cve": {"id": "CVE-2018-6758", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-06T18:29:00.447", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The uwsgi_expand_path function in core/utils.c in Unbit uWSGI through 2.0.15 has a stack-based buffer overflow via a large directory length."}, {"lang": "es", "value": "La funci\u00f3n uwsgi_expand_path en core/utils.c en Unbit uWSGI hasta la versi\u00f3n 2.0.15 tiene un desbordamiento de b\u00fafer basado en pila mediante una longitud de directorio grande."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unbit:uwsgi:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.15", "matchCriteriaId": "2889D392-76ED-42A0-80D3-1D98642E0005"}]}]}], "references": [{"url": "http://lists.unbit.it/pipermail/uwsgi/2018-February/008835.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/unbit/uwsgi/commit/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/02/msg00010.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/unbit/uwsgi/commit/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe"}}