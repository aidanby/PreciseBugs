{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Query\\QueryBuilder as DoctrineQueryBuilder;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Translation;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Translation\\ExportService\\Exporter\\ExporterInterface;\nuse Pimcore\\Translation\\ExportService\\ExportServiceInterface;\nuse Pimcore\\Translation\\ImportDataExtractor\\ImportDataExtractorInterface;\nuse Pimcore\\Translation\\ImporterService\\ImporterServiceInterface;\nuse Pimcore\\Translation\\TranslationItemCollection\\TranslationItemCollection;\nuse Pimcore\\Translation\\Translator;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @Route(\"/translation\")\n *\n * @internal\n */\nclass TranslationController extends AdminController\n{\n    /**\n     * @Route(\"/import\", name=\"pimcore_admin_translation_import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function importAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $dialect = $request->get('csvSettings', null);\n        $session = Session::get('pimcore_importconfig');\n        $tmpFile = $session->get('translation_import_file');\n\n        if ($dialect) {\n            $dialect = json_decode($dialect);\n        }\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $merge = $request->get('merge');\n        $overwrite = !$merge;\n\n        $allowedLanguages = $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations();\n        if ($admin) {\n            $allowedLanguages = Tool\\Admin::getLanguages();\n        }\n\n        $delta = Translation::importTranslationsFromFile(\n            $tmpFile,\n            $domain,\n            $overwrite,\n            $allowedLanguages,\n            $dialect\n        );\n\n        if (is_file($tmpFile)) {\n            @unlink($tmpFile);\n        }\n\n        $result = [\n            'success' => true,\n        ];\n        if ($merge) {\n            $enrichedDelta = [];\n\n            foreach ($delta as $item) {\n                $lg = $item['lg'];\n                $currentLocale = $localeService->findLocale();\n                $item['lgname'] = \\Locale::getDisplayLanguage($lg, $currentLocale);\n                $item['icon'] = $this->generateUrl('pimcore_admin_misc_getlanguageflag', ['language' => $lg]);\n                $item['current'] = $item['text'];\n                $enrichedDelta[] = $item;\n            }\n\n            $result['delta'] = base64_encode(json_encode($enrichedDelta));\n        }\n\n        $response = $this->adminJson($result);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/upload-import\", name=\"pimcore_admin_translation_uploadimportfile\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function uploadImportFileAction(Request $request)\n    {\n        $tmpData = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        //store data for further usage\n        $filename = uniqid('import_translations-');\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $filename;\n        File::put($importFile, $tmpData);\n\n        Session::useSession(function (AttributeBagInterface $session) use ($importFile) {\n            $session->set('translation_import_file', $importFile);\n        }, 'pimcore_importconfig');\n\n        // determine csv settings\n        $dialect = Tool\\Admin::determineCsvDialect($importFile);\n\n        //ignore if line terminator is already hex otherwise generate hex for string\n        if (!empty($dialect->lineterminator) && empty(preg_match('/[a-f0-9]{2}/i', $dialect->lineterminator))) {\n            $dialect->lineterminator = bin2hex($dialect->lineterminator);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'config' => [\n                'csvSettings' => $dialect,\n            ],\n        ]);\n    }\n\n    /**\n     * @Route(\"/export\", name=\"pimcore_admin_translation_export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n\n        $joins = [];\n\n        $list->setOrder('asc');\n        $list->setOrderKey($tableName . '.key', false);\n\n        $condition = $this->getGridFilterCondition($request, $tableName, false, $admin);\n        if ($condition) {\n            $list->setCondition($condition);\n        }\n\n        $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n        if ($filters) {\n            $joins = array_merge($joins, $filters['joins']);\n        }\n\n        $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n        $list->load();\n\n        $translations = [];\n        $translationObjects = $list->getTranslations();\n\n        // fill with one dummy translation if the store is empty\n        if (empty($translationObjects)) {\n            if ($admin) {\n                $t = new Translation();\n                $t->setDomain(Translation::DOMAIN_ADMIN);\n                $languages = Tool\\Admin::getLanguages();\n            } else {\n                $t = new Translation();\n                $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n            }\n\n            foreach ($languages as $language) {\n                $t->addTranslation($language, '');\n            }\n\n            $translationObjects[] = $t;\n        }\n\n        foreach ($translationObjects as $t) {\n            $row = $t->getTranslations();\n            $row = Element\\Service::escapeCsvRecord($row);\n            $translations[] = array_merge(\n                ['key' => $t->getKey(),\n                    'creationDate' => $t->getCreationDate(),\n                    'modificationDate' => $t->getModificationDate(),\n                ],\n                $row\n            );\n        }\n\n        //header column\n        $columns = array_keys($translations[0]);\n\n        if ($admin) {\n            $languages = Tool\\Admin::getLanguages();\n        } else {\n            $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n        }\n\n        //add language columns which have no translations yet\n        foreach ($languages as $l) {\n            if (!in_array($l, $columns)) {\n                $columns[] = $l;\n            }\n        }\n\n        //remove invalid languages\n        foreach ($columns as $key => $column) {\n            if (strtolower(trim($column)) != 'key' && !in_array($column, $languages)) {\n                unset($columns[$key]);\n            }\n        }\n        $columns = array_values($columns);\n\n        $headerRow = [];\n        foreach ($columns as $key => $value) {\n            $headerRow[] = '\"' . $value . '\"';\n        }\n        $csv = implode(';', $headerRow) . \"\\r\\n\";\n\n        foreach ($translations as $t) {\n            $tempRow = [];\n            foreach ($columns as $key) {\n                $value = $t[$key] ?? null;\n                //clean value of evil stuff such as \" and linebreaks\n                if (is_string($value)) {\n                    $value = Tool\\Text::removeLineBreaks($value);\n                    $value = str_replace('\"', '&quot;', $value);\n\n                    $tempRow[$key] = '\"' . $value . '\"';\n                } else {\n                    $tempRow[$key] = $value;\n                }\n            }\n            $csv .= implode(';', $tempRow) . \"\\r\\n\";\n        }\n\n        $response = new Response(\"\\xEF\\xBB\\xBF\" . $csv);\n        $response->headers->set('Content-Encoding', 'UTF-8');\n        $response->headers->set('Content-Type', 'text/csv; charset=UTF-8');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"export_' . $domain . '_translations.csv\"');\n        ini_set('display_errors', '0'); //to prevent warning messages in csv\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/add-admin-translation-keys\", name=\"pimcore_admin_translation_addadmintranslationkeys\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAdminTranslationKeysAction(Request $request)\n    {\n        $keys = $request->get('keys');\n        if ($keys) {\n            $availableLanguages = Tool\\Admin::getLanguages();\n            $data = $this->decodeJson($keys);\n            foreach ($data as $translationData) {\n                $t = null; // reset\n\n                try {\n                    $t = Translation::getByKey($translationData, Translation::DOMAIN_ADMIN);\n                } catch (\\Exception $e) {\n                    Logger::log((string) $e);\n                }\n                if (!$t instanceof Translation) {\n                    $t = new Translation();\n                    $t->setDomain(Translation::DOMAIN_ADMIN);\n                    $t->setKey($translationData);\n                    $t->setCreationDate(time());\n                    $t->setModificationDate(time());\n\n                    foreach ($availableLanguages as $lang) {\n                        $t->addTranslation($lang, '');\n                    }\n\n                    try {\n                        $t->save();\n                    } catch (\\Exception $e) {\n                        Logger::log((string) $e);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(null);\n    }\n\n    /**\n     * @Route(\"/translations\", name=\"pimcore_admin_translation_translations\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Translator $translator\n     *\n     * @return JsonResponse\n     */\n    public function translationsAction(Request $request, TranslatorInterface $translator)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain === Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        if ($request->get('data')) {\n            $data = $this->decodeJson($request->get('data'));\n\n            if ($request->get('xaction') == 'destroy') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t instanceof Translation) {\n                    $t->delete();\n                }\n\n                return $this->adminJson(['success' => true, 'data' => []]);\n            } elseif ($request->get('xaction') == 'update') {\n                $t = Translation::getByKey($data['key'], $domain);\n\n                foreach ($data as $key => $value) {\n                    $key = preg_replace('/^_/', '', $key, 1);\n                    if (!in_array($key, ['key', 'type'])) {\n                        $t->addTranslation($key, $value);\n                    }\n                }\n\n                if ($data['key']) {\n                    $t->setKey($data['key']);\n                }\n\n                if ($data['type']) {\n                    $t->setType($data['type']);\n                }\n                $t->setModificationDate(time());\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            } elseif ($request->get('xaction') == 'create') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t) {\n                    return $this->adminJson([\n                        'message' => 'identifier_already_exists',\n                        'success' => false,\n                    ]);\n                }\n\n                $t = new Translation();\n                $t->setDomain($domain);\n                $t->setKey($data['key']);\n                $t->setCreationDate(time());\n                $t->setModificationDate(time());\n                $t->setType($data['type'] ?? null);\n\n                foreach (Tool::getValidLanguages() as $lang) {\n                    $t->addTranslation($lang, '');\n                }\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            }\n        } else {\n            // get list of types\n            $list = new Translation\\Listing();\n            $list->setDomain($domain);\n\n            $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n            $list->setOrder('asc');\n            $list->setOrderKey($tableName . '.key', false);\n\n            $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings(\n                array_merge($request->request->all(), $request->query->all())\n            );\n\n            $joins = [];\n\n            if ($orderKey = $sortingSettings['orderKey']) {\n                if (in_array(trim($orderKey, '_'), $validLanguages)) {\n                    $orderKey = trim($orderKey, '_');\n                    $joins[] = [\n                        'language' => $orderKey,\n                    ];\n                    $list->setOrderKey($orderKey);\n                } elseif ($list->isValidOrderKey($sortingSettings['orderKey'])) {\n                    $list->setOrderKey($tableName . '.' . $sortingSettings['orderKey'], false);\n                }\n            }\n            if ($sortingSettings['order']) {\n                $list->setOrder($sortingSettings['order']);\n            }\n\n            $list->setLimit($request->get('limit'));\n            $list->setOffset($request->get('start'));\n\n            $condition = $this->getGridFilterCondition($request, $tableName, false, $admin);\n            $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n            if ($filters) {\n                $joins = array_merge($joins, $filters['joins']);\n            }\n            if ($condition) {\n                $list->setCondition($condition);\n            }\n\n            $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n            $list->load();\n\n            $translations = [];\n            $searchString = $request->get('searchString');\n            foreach ($list->getTranslations() as $t) {\n                //Reload translation to get complete data,\n                //if translation fetched based on the text not key\n                if ($searchString && !strpos($searchString, $t->getKey())) {\n                    if (!$t = Translation::getByKey($t->getKey(), $domain)) {\n                        continue;\n                    }\n                }\n\n                $translations[] = array_merge(\n                    $this->prefixTranslations($t->getTranslations()),\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ]\n                );\n            }\n\n            return $this->adminJson(['data' => $translations, 'success' => true, 'total' => $list->getTotalCount()]);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return array\n     */\n    protected function prefixTranslations($translations)\n    {\n        if (!is_array($translations)) {\n            return $translations;\n        }\n\n        $prefixedTranslations = [];\n        foreach ($translations as $lang => $trans) {\n            $prefixedTranslations['_' . $lang] = $trans;\n        }\n\n        return $prefixedTranslations;\n    }\n\n    /**\n     * @param array $joins\n     * @param Translation\\Listing $list\n     * @param string $tableName\n     * @param array $filters\n     */\n    protected function extendTranslationQuery($joins, $list, $tableName, $filters)\n    {\n        if ($joins) {\n            $list->onCreateQueryBuilder(\n                function (DoctrineQueryBuilder $select) use (\n                    $joins,\n                    $tableName,\n                    $filters\n                ) {\n                    $db = \\Pimcore\\Db::get();\n\n                    $alreadyJoined = [];\n\n                    foreach ($joins as $join) {\n                        $fieldname = $join['language'];\n\n                        if (isset($alreadyJoined[$fieldname])) {\n                            continue;\n                        }\n                        $alreadyJoined[$fieldname] = 1;\n\n                        $select->addSelect($fieldname . '.text AS ' . $fieldname);\n                        $select->leftJoin(\n                            $tableName,\n                            $tableName,\n                            $fieldname,\n                            '('\n                            . $fieldname . '.key = ' . $tableName . '.key'\n                            . ' and ' . $fieldname . '.language = ' . $db->quote($fieldname)\n                            . ')'\n                        );\n                    }\n\n                    $havings = $filters['conditions'];\n                    if ($havings) {\n                        $havings = implode(' AND ', $havings);\n                        $select->having($havings);\n                    }\n                }\n            );\n        }\n    }\n\n    /**\n     * @param Request $request\n     * @param string $tableName\n     * @param bool $languageMode\n     *\n     * @return array|null|string\n     */\n    protected function getGridFilterCondition(Request $request, $tableName, $languageMode = false, $admin = false)\n    {\n        $joins = [];\n        $conditions = [];\n        $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n        $db = \\Pimcore\\Db::get();\n        $conditionFilters = [];\n\n        $filterJson = $request->get('filter');\n        if ($filterJson) {\n            $propertyField = 'property';\n            $operatorField = 'operator';\n\n            $filters = $this->decodeJson($filterJson);\n            foreach ($filters as $filter) {\n                $operator = '=';\n                $field = null;\n                $value = null;\n\n                $fieldname = $filter[$propertyField];\n                if (in_array(ltrim($fieldname, '_'), $validLanguages)) {\n                    $fieldname = ltrim($fieldname, '_');\n                }\n\n                if (!$languageMode && in_array($fieldname, $validLanguages)\n                    || $languageMode && !in_array($fieldname, $validLanguages)) {\n                    continue;\n                }\n\n                if (!$languageMode) {\n                    $fieldname = $tableName . '.' . $fieldname;\n                }\n\n                if (!empty($filter['value'])) {\n                    if ($filter['type'] == 'string') {\n                        $operator = 'LIKE';\n                        $field = $fieldname;\n                        $value = '%' . $filter['value'] . '%';\n                    } elseif ($filter['type'] == 'date' ||\n                        (in_array($fieldname, ['modificationDate', 'creationDate']))) {\n                        if ($filter[$operatorField] == 'lt') {\n                            $operator = '<';\n                        } elseif ($filter[$operatorField] == 'gt') {\n                            $operator = '>';\n                        } elseif ($filter[$operatorField] == 'eq') {\n                            $operator = '=';\n                            $fieldname = \"UNIX_TIMESTAMP(DATE(FROM_UNIXTIME({$fieldname})))\";\n                        }\n                        $filter['value'] = strtotime($filter['value']);\n                        $field = $fieldname;\n                        $value = $filter['value'];\n                    }\n                }\n\n                if ($field && $value) {\n                    $condition = $field . ' ' . $operator . ' ' . $db->quote($value);\n\n                    if ($languageMode) {\n                        $conditions[$fieldname] = $condition;\n                        $joins[] = [\n                            'language' => $fieldname,\n                        ];\n                    } else {\n                        $conditionFilters[] = $condition;\n                    }\n                }\n            }\n        }\n\n        if ($request->get('searchString')) {\n            $filterTerm = $db->quote('%' . mb_strtolower($request->get('searchString')) . '%');\n            $conditionFilters[] = '(lower(' . $tableName . '.key) LIKE ' . $filterTerm . ' OR lower(' . $tableName . '.text) LIKE ' . $filterTerm . ')';\n        }\n\n        if ($languageMode) {\n            $result = [\n                'joins' => $joins,\n                'conditions' => $conditions,\n            ];\n\n            return $result;\n        } else {\n            if (!empty($conditionFilters)) {\n                return implode(' AND ', $conditionFilters);\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * @Route(\"/cleanup\", name=\"pimcore_admin_translation_cleanup\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function cleanupAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n        $list->cleanup();\n\n        \\Pimcore\\Cache::clearTags(['translator', 'translate']);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * -----------------------------------------------------------------------------------\n     * THE FOLLOWING ISN'T RELATED TO THE SHARED TRANSLATIONS OR ADMIN-TRANSLATIONS\n     * XLIFF CONTENT-EXPORT & MS WORD CONTENT-EXPORT\n     * -----------------------------------------------------------------------------------\n     */\n\n    /**\n     * @Route(\"/content-export-jobs\", name=\"pimcore_admin_translation_contentexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function contentExportJobsAction(Request $request)\n    {\n        $data = $this->decodeJson($request->get('data'));\n        $elements = [];\n        $jobs = [];\n        $exportId = uniqid();\n        $source = $request->get('source');\n        $target = $request->get('target');\n        $type = $request->get('type');\n\n        $source = str_replace('_', '-', $source);\n        $target = str_replace('_', '-', $target);\n\n        if ($data && is_array($data)) {\n            foreach ($data as $element) {\n                $elements[$element['type'] . '_' . $element['id']] = [\n                    'id' => $element['id'],\n                    'type' => $element['type'],\n                ];\n\n                $el = null;\n\n                if ($element['children']) {\n                    $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    $baseClass = ELement\\Service::getBaseClassNameForElement($element['type']);\n                    $listClass = '\\\\Pimcore\\\\Model\\\\' . $baseClass . '\\\\Listing';\n                    $list = new $listClass();\n                    $list->setUnpublished(true);\n                    if ($el instanceof DataObject\\AbstractObject) {\n                        // inlcude variants\n                        $list->setObjectTypes(\n                            [DataObject::OBJECT_TYPE_VARIANT,\n                                DataObject::OBJECT_TYPE_OBJECT,\n                                DataObject::OBJECT_TYPE_FOLDER, ]\n                        );\n                    }\n                    $list->setCondition(\n                        ($el instanceof DataObject ? 'o_' : '') . 'path LIKE ?',\n                        [$list->escapeLike($el->getRealFullPath() . ($el->getRealFullPath() != '/' ? '/' : '')) . '%']\n                    );\n                    $childs = $list->load();\n\n                    foreach ($childs as $child) {\n                        $childId = $child->getId();\n                        $elements[$element['type'] . '_' . $childId] = [\n                            'id' => $childId,\n                            'type' => $element['type'],\n                        ];\n\n                        if (isset($element['relations']) && $element['relations']) {\n                            $childDependencies = $child->getDependencies()->getRequires();\n                            foreach ($childDependencies as $cd) {\n                                if ($cd['type'] == 'object' || $cd['type'] == 'document') {\n                                    $elements[$cd['type'] . '_' . $cd['id']] = $cd;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (isset($element['relations']) && $element['relations']) {\n                    if (!$el instanceof Element\\ElementInterface) {\n                        $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    }\n\n                    $dependencies = $el->getDependencies()->getRequires();\n                    foreach ($dependencies as $dependency) {\n                        if ($dependency['type'] == 'object' || $dependency['type'] == 'document') {\n                            $elements[$dependency['type'] . '_' . $dependency['id']] = $dependency;\n                        }\n                    }\n                }\n            }\n        }\n\n        $elements = array_values($elements);\n\n        $elementsPerJob = 10;\n        if ($type == 'word') {\n            // the word export can only handle one document per request\n            // the problem is Document\\Service::render(), ... in the action can be a $this->redirect() or exit;\n            // nobody knows what's happening in an action ;-) So we need to isolate them in isolated processes\n            // so that the export doesn't stop completely after a \"redirect\" or any other unexpected behavior of an action\n            $elementsPerJob = 1;\n        }\n\n        // one job = X elements\n        $elements = array_chunk($elements, $elementsPerJob);\n        foreach ($elements as $chunk) {\n            $jobs[] = [[\n                'url' => $request->getBaseUrl() . '/admin/translation/' . $type . '-export',\n                'method' => 'POST',\n                'params' => [\n                    'id' => $exportId,\n                    'source' => $source,\n                    'target' => $target,\n                    'data' => $this->encodeJson($chunk),\n                ],\n            ]];\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n                'jobs' => $jobs,\n                'id' => $exportId,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/xliff-export\", name=\"pimcore_admin_translation_xliffexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ExportServiceInterface $exportService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffExportAction(Request $request, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n        $target = $request->get('target');\n\n        $translationItems = new TranslationItemCollection();\n\n        foreach ($data as $el) {\n            $element = Element\\Service::getElementById($el['type'], $el['id']);\n            $translationItems->addPimcoreElement($element);\n        }\n\n        $exportService->exportTranslationItems($translationItems, $source, [$target], $id);\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/xliff-export-download\", name=\"pimcore_admin_translation_xliffexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ExporterInterface $translationExporter\n     *\n     * @return BinaryFileResponse\n     */\n    public function xliffExportDownloadAction(Request $request, ExporterInterface $translationExporter, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $exportFile = $exportService->getTranslationExporter()->getExportFilePath($id);\n\n        $response = new BinaryFileResponse($exportFile);\n        $response->headers->set('Content-Type', $translationExporter->getContentType());\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, basename($exportFile));\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-upload\", name=\"pimcore_admin_translation_xliffimportupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportUploadAction(Request $request, ImportDataExtractorInterface $importDataExtractor)\n    {\n        $jobs = [];\n        $id = uniqid();\n        $importFile = $importDataExtractor->getImportFilePath($id);\n        copy($_FILES['file']['tmp_name'], $importFile);\n\n        $steps = $importDataExtractor->countSteps($id);\n\n        for ($i = 0; $i < $steps; $i++) {\n            $jobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_translation_xliffimportelement'),\n                'method' => 'POST',\n                'params' => [\n                    'id' => $id,\n                    'step' => $i,\n                ],\n            ]];\n        }\n\n        $response = $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'id' => $id,\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-element\", name=\"pimcore_admin_translation_xliffimportelement\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     * @param ImporterServiceInterface $importerService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportElementAction(Request $request, ImportDataExtractorInterface $importDataExtractor, ImporterServiceInterface $importerService)\n    {\n        $id = $request->get('id');\n        $step = $request->get('step');\n\n        try {\n            $attributeSet = $importDataExtractor->extractElement($id, $step);\n            if ($attributeSet) {\n                $importerService->import($attributeSet);\n            } else {\n                Logger::warning(sprintf('Could not resolve element %s', $id));\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e->getMessage());\n\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/word-export\", name=\"pimcore_admin_translation_wordexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function wordExportAction(Request $request)\n    {\n        ini_set('display_errors', 'off');\n\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, false);\n\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n\n        if (!is_file($exportFile)) {\n            File::put($exportFile, '');\n        }\n\n        foreach ($data as $el) {\n            try {\n                $element = Element\\Service::getElementById($el['type'], $el['id']);\n                $output = '';\n\n                // check supported types (subtypes)\n                if (!in_array($element->getType(), ['page', 'snippet', 'email', 'object'])) {\n                    continue;\n                }\n\n                if ($element instanceof Element\\ElementInterface) {\n                    $output .= '<h1 class=\"element-headline\">' . ucfirst(\n                        $element->getType()\n                    ) . ' - ' . $element->getRealFullPath() . ' (ID: ' . $element->getId() . ')</h1>';\n                }\n\n                if ($element instanceof Document\\PageSnippet) {\n                    if ($element instanceof Document\\Page) {\n                        $structuredDataEmpty = true;\n                        $structuredData = '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Structured Data</span></td>\n                                </tr>\n                        ';\n\n                        if ($element->getTitle()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Title</span></td>\n                                    <td>' . $element->getTitle() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getDescription()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Description</span></td>\n                                    <td>' . $element->getDescription() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getProperty('navigation_name')) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Navigation</span></td>\n                                    <td>' . $element->getProperty('navigation_name') . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        $structuredData .= '</table>';\n\n                        if (!$structuredDataEmpty) {\n                            $output .= $structuredData;\n                        }\n                    }\n\n                    // we need to set the parameter \"pimcore_admin\" here to be able to render unpublished documents\n                    $html = Document\\Service::render($element, [], false, ['pimcore_admin' => true]);\n\n                    $html = preg_replace(\n                        '@</?(img|meta|div|section|aside|article|body|bdi|bdo|canvas|embed|footer|head|header|html)([^>]+)?>@',\n                        '',\n                        $html\n                    );\n                    $html = preg_replace('/<!--(.*)-->/Uis', '', $html);\n\n                    $dom = new Tool\\DomCrawler($html);\n                    // remove containers including their contents\n                    $elements = $dom->filter('form, script, style, noframes, noscript, object, area, mapm, video, audio, iframe, textarea, input, select, button');\n                    foreach ($elements as $element) {\n                        $element->parentNode->removeChild($element);\n                    }\n\n                    $clearText = function ($string) {\n                        $string = str_replace(\"\\r\\n\", '', $string);\n                        $string = str_replace(\"\\n\", '', $string);\n                        $string = str_replace(\"\\r\", '', $string);\n                        $string = str_replace(\"\\t\", '', $string);\n                        $string = preg_replace('/&[a-zA-Z0-9]+;/', '', $string); // remove html entities\n                        $string = preg_replace('#[ ]+#', '', $string);\n\n                        return $string;\n                    };\n\n                    // remove empty tags (where it matters)\n                    // replace links => links get [Linktext]\n                    $elements = $dom->filter('a');\n                    foreach ($elements as $element) {\n                        $string = $clearText($element->textContent);\n                        if (!empty($string)) {\n                            $newNode = $element->ownerDocument->createTextNode('[' . $element->textContent . ']');\n\n                            $element->parentNode->replaceChild($newNode, $element);\n                        } else {\n                            $element->ownerDocument->textContent = '';\n                        }\n                    }\n\n                    if ($dom->count() > 0) {\n                        $html = $dom->html();\n                    }\n\n                    $dom->clear();\n                    unset($dom);\n\n                    // force closing tags\n                    $doc = new \\DOMDocument();\n                    libxml_use_internal_errors(true);\n                    $doc->loadHTML('<?xml encoding=\"UTF-8\"><article>' . $html . '</article>');\n                    libxml_clear_errors();\n                    $html = $doc->saveHTML();\n\n                    $bodyStart = strpos($html, '<body>');\n                    $bodyEnd = strpos($html, '</body>');\n                    if ($bodyStart && $bodyEnd) {\n                        $html = substr($html, $bodyStart + 6, $bodyEnd - $bodyStart);\n                    }\n\n                    $output .= $html;\n                } elseif ($element instanceof DataObject\\Concrete) {\n                    $hasContent = false;\n\n                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields|null $fd */\n                    $fd = $element->getClass()->getFieldDefinition('localizedfields');\n                    if ($fd) {\n                        $definitions = $fd->getFieldDefinitions();\n\n                        $locale = str_replace('-', '_', $source);\n                        if (!Tool::isValidLanguage($locale)) {\n                            $locale = \\Locale::getPrimaryLanguage($locale);\n                        }\n\n                        $output .= '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Localized Data</span></td>\n                                </tr>\n                        ';\n\n                        foreach ($definitions as $definition) {\n                            // check allowed datatypes\n                            if (!in_array($definition->getFieldtype(), ['input', 'textarea', 'wysiwyg'])) {\n                                continue;\n                            }\n\n                            $content = $element->{'get' . ucfirst($definition->getName())}($locale);\n\n                            if (!empty($content)) {\n                                $output .= '\n                                <tr>\n                                    <td><span style=\"color:#cc2929;\">' . $definition->getTitle() . ' (' . $definition->getName() . ')<span></td>\n                                    <td>' . $content . '&nbsp;</td>\n                                </tr>\n                                ';\n\n                                $hasContent = true;\n                            }\n                        }\n\n                        $output .= '</table>';\n                    }\n\n                    if (!$hasContent) {\n                        $output = ''; // there's no content in the object, so reset all contents and do not inclide it in the export\n                    }\n                }\n\n                // append contents\n                if (!empty($output)) {\n                    $f = fopen($exportFile, 'a+');\n                    fwrite($f, $output);\n                    fclose($f);\n                }\n            } catch (\\Exception $e) {\n                Logger::error('Word Export: ' . $e->getMessage());\n                Logger::error((string) $e);\n\n                throw $e;\n            }\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/word-export-download\", name=\"pimcore_admin_translation_wordexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function wordExportDownloadAction(Request $request)\n    {\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, true);\n\n        // no conversion, output html file, works fine with MS Word and LibreOffice\n        $content = file_get_contents($exportFile);\n        @unlink($exportFile);\n\n        // replace <script> and <link>\n        $content = preg_replace('/<link[^>]+>/im', '$1', $content);\n        $content = preg_replace(\"/<script[^>]+>(.*)?<\\/script>/im\", '$1', $content);\n\n        $content =\n            \"<html>\\n\" .\n            \"<head>\\n\" .\n            '<style type=\"text/css\">' . \"\\n\" .\n            file_get_contents(PIMCORE_WEB_ROOT . '/bundles/pimcoreadmin/css/word-export.css') .\n            \"</style>\\n\" .\n            \"</head>\\n\\n\" .\n            \"<body>\\n\" .\n            $content .\n            \"\\n\\n</body>\\n\" .\n            \"</html>\\n\";\n\n        $response = new Response($content);\n        $response->headers->set('Content-Type', 'text/html');\n        $response->headers->set(\n            'Content-Disposition',\n            'attachment; filename=\"word-export-' . date('Ymd') . '_' . uniqid() . '.htm\"'\n        );\n\n        return $response;\n    }\n\n    private function sanitzeExportId(string $id): string\n    {\n        if (empty($id) || !preg_match('/^[a-z0-9]+$/', $id)) {\n            throw new BadRequestHttpException('Invalid export ID format');\n        }\n\n        return $id;\n    }\n\n    private function getExportFilePath(string $id, bool $checkExistence = true): string\n    {\n        // no need to check for path traversals here as sanitizeExportId restricted the ID parameter\n        $exportFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . DIRECTORY_SEPARATOR . $id . '.html';\n\n        if ($checkExistence && !file_exists($exportFile)) {\n            throw $this->createNotFoundException(sprintf('Export file does not exist at path %s', $exportFile));\n        }\n\n        return $exportFile;\n    }\n\n    /**\n     * @Route(\"/merge-item\", name=\"pimcore_admin_translation_mergeitem\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function mergeItemAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n\n        $dataList = json_decode($request->get('data'), true);\n\n        foreach ($dataList as $data) {\n            $t = Translation::getByKey($data['key'], $domain, true);\n            $newValue = htmlspecialchars_decode($data['current']);\n            $t->addTranslation($data['lg'], $newValue);\n            $t->setModificationDate(time());\n            $t->save();\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-website-translation-languages\", name=\"pimcore_admin_translation_getwebsitetranslationlanguages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getWebsiteTranslationLanguagesAction(Request $request)\n    {\n        return $this->adminJson(\n            [\n                'view' => $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations(),\n\n                //when no view language is defined, all languages are editable. if one view language is defined, it\n                //may be possible that no edit language is set intentionally\n                'edit' => $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations(),\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-translation-domains\", name=\"pimcore_admin_translation_gettranslationdomains\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTranslationDomainsAction(Request $request)\n    {\n        $translation = new Translation();\n\n        $domains = array_map(\n            fn ($domain) => ['name' => $domain],\n            $translation->getDao()->getAvailableDomains(),\n        );\n\n        return $this->adminJson(['domains' => $domains]);\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Exception\\SyntaxErrorException;\nuse Doctrine\\DBAL\\Query\\QueryBuilder as DoctrineQueryBuilder;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Translation;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Translation\\ExportService\\Exporter\\ExporterInterface;\nuse Pimcore\\Translation\\ExportService\\ExportServiceInterface;\nuse Pimcore\\Translation\\ImportDataExtractor\\ImportDataExtractorInterface;\nuse Pimcore\\Translation\\ImporterService\\ImporterServiceInterface;\nuse Pimcore\\Translation\\TranslationItemCollection\\TranslationItemCollection;\nuse Pimcore\\Translation\\Translator;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @Route(\"/translation\")\n *\n * @internal\n */\nclass TranslationController extends AdminController\n{\n    protected const PLACEHOLDER_NAME = 'placeHolder';\n\n    /**\n     * @Route(\"/import\", name=\"pimcore_admin_translation_import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function importAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $dialect = $request->get('csvSettings', null);\n        $session = Session::get('pimcore_importconfig');\n        $tmpFile = $session->get('translation_import_file');\n\n        if ($dialect) {\n            $dialect = json_decode($dialect);\n        }\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $merge = $request->get('merge');\n        $overwrite = !$merge;\n\n        $allowedLanguages = $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations();\n        if ($admin) {\n            $allowedLanguages = Tool\\Admin::getLanguages();\n        }\n\n        $delta = Translation::importTranslationsFromFile(\n            $tmpFile,\n            $domain,\n            $overwrite,\n            $allowedLanguages,\n            $dialect\n        );\n\n        if (is_file($tmpFile)) {\n            @unlink($tmpFile);\n        }\n\n        $result = [\n            'success' => true,\n        ];\n        if ($merge) {\n            $enrichedDelta = [];\n\n            foreach ($delta as $item) {\n                $lg = $item['lg'];\n                $currentLocale = $localeService->findLocale();\n                $item['lgname'] = \\Locale::getDisplayLanguage($lg, $currentLocale);\n                $item['icon'] = $this->generateUrl('pimcore_admin_misc_getlanguageflag', ['language' => $lg]);\n                $item['current'] = $item['text'];\n                $enrichedDelta[] = $item;\n            }\n\n            $result['delta'] = base64_encode(json_encode($enrichedDelta));\n        }\n\n        $response = $this->adminJson($result);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/upload-import\", name=\"pimcore_admin_translation_uploadimportfile\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function uploadImportFileAction(Request $request)\n    {\n        $tmpData = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        //store data for further usage\n        $filename = uniqid('import_translations-');\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $filename;\n        File::put($importFile, $tmpData);\n\n        Session::useSession(function (AttributeBagInterface $session) use ($importFile) {\n            $session->set('translation_import_file', $importFile);\n        }, 'pimcore_importconfig');\n\n        // determine csv settings\n        $dialect = Tool\\Admin::determineCsvDialect($importFile);\n\n        //ignore if line terminator is already hex otherwise generate hex for string\n        if (!empty($dialect->lineterminator) && empty(preg_match('/[a-f0-9]{2}/i', $dialect->lineterminator))) {\n            $dialect->lineterminator = bin2hex($dialect->lineterminator);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'config' => [\n                'csvSettings' => $dialect,\n            ],\n        ]);\n    }\n\n    /**\n     * @Route(\"/export\", name=\"pimcore_admin_translation_export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n\n        $joins = [];\n\n        $list->setOrder('asc');\n        $list->setOrderKey($tableName . '.key', false);\n\n        $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n        if (!empty($conditions)) {\n            $list->setCondition($conditions['condition'], $conditions['params']);\n        }\n\n        $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n        if ($filters) {\n            $joins = array_merge($joins, $filters['joins']);\n        }\n\n        $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n        try {\n            $list->load();\n        } catch (SyntaxErrorException $syntaxErrorException) {\n            throw new \\InvalidArgumentException('Check your arguments.');\n        }\n\n        $translations = [];\n        $translationObjects = $list->getTranslations();\n\n        // fill with one dummy translation if the store is empty\n        if (empty($translationObjects)) {\n            if ($admin) {\n                $t = new Translation();\n                $t->setDomain(Translation::DOMAIN_ADMIN);\n                $languages = Tool\\Admin::getLanguages();\n            } else {\n                $t = new Translation();\n                $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n            }\n\n            foreach ($languages as $language) {\n                $t->addTranslation($language, '');\n            }\n\n            $translationObjects[] = $t;\n        }\n\n        foreach ($translationObjects as $t) {\n            $row = $t->getTranslations();\n            $row = Element\\Service::escapeCsvRecord($row);\n            $translations[] = array_merge(\n                ['key' => $t->getKey(),\n                    'creationDate' => $t->getCreationDate(),\n                    'modificationDate' => $t->getModificationDate(),\n                ],\n                $row\n            );\n        }\n\n        //header column\n        $columns = array_keys($translations[0]);\n\n        if ($admin) {\n            $languages = Tool\\Admin::getLanguages();\n        } else {\n            $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n        }\n\n        //add language columns which have no translations yet\n        foreach ($languages as $l) {\n            if (!in_array($l, $columns)) {\n                $columns[] = $l;\n            }\n        }\n\n        //remove invalid languages\n        foreach ($columns as $key => $column) {\n            if (strtolower(trim($column)) != 'key' && !in_array($column, $languages)) {\n                unset($columns[$key]);\n            }\n        }\n        $columns = array_values($columns);\n\n        $headerRow = [];\n        foreach ($columns as $key => $value) {\n            $headerRow[] = '\"' . $value . '\"';\n        }\n        $csv = implode(';', $headerRow) . \"\\r\\n\";\n\n        foreach ($translations as $t) {\n            $tempRow = [];\n            foreach ($columns as $key) {\n                $value = $t[$key] ?? null;\n                //clean value of evil stuff such as \" and linebreaks\n                if (is_string($value)) {\n                    $value = Tool\\Text::removeLineBreaks($value);\n                    $value = str_replace('\"', '&quot;', $value);\n\n                    $tempRow[$key] = '\"' . $value . '\"';\n                } else {\n                    $tempRow[$key] = $value;\n                }\n            }\n            $csv .= implode(';', $tempRow) . \"\\r\\n\";\n        }\n\n        $response = new Response(\"\\xEF\\xBB\\xBF\" . $csv);\n        $response->headers->set('Content-Encoding', 'UTF-8');\n        $response->headers->set('Content-Type', 'text/csv; charset=UTF-8');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"export_' . $domain . '_translations.csv\"');\n        ini_set('display_errors', '0'); //to prevent warning messages in csv\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/add-admin-translation-keys\", name=\"pimcore_admin_translation_addadmintranslationkeys\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAdminTranslationKeysAction(Request $request)\n    {\n        $keys = $request->get('keys');\n        if ($keys) {\n            $availableLanguages = Tool\\Admin::getLanguages();\n            $data = $this->decodeJson($keys);\n            foreach ($data as $translationData) {\n                $t = null; // reset\n\n                try {\n                    $t = Translation::getByKey($translationData, Translation::DOMAIN_ADMIN);\n                } catch (\\Exception $e) {\n                    Logger::log((string) $e);\n                }\n                if (!$t instanceof Translation) {\n                    $t = new Translation();\n                    $t->setDomain(Translation::DOMAIN_ADMIN);\n                    $t->setKey($translationData);\n                    $t->setCreationDate(time());\n                    $t->setModificationDate(time());\n\n                    foreach ($availableLanguages as $lang) {\n                        $t->addTranslation($lang, '');\n                    }\n\n                    try {\n                        $t->save();\n                    } catch (\\Exception $e) {\n                        Logger::log((string) $e);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(null);\n    }\n\n    /**\n     * @Route(\"/translations\", name=\"pimcore_admin_translation_translations\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Translator $translator\n     *\n     * @return JsonResponse\n     */\n    public function translationsAction(Request $request, TranslatorInterface $translator)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain === Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        if ($request->get('data')) {\n            $data = $this->decodeJson($request->get('data'));\n\n            if ($request->get('xaction') == 'destroy') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t instanceof Translation) {\n                    $t->delete();\n                }\n\n                return $this->adminJson(['success' => true, 'data' => []]);\n            } elseif ($request->get('xaction') == 'update') {\n                $t = Translation::getByKey($data['key'], $domain);\n\n                foreach ($data as $key => $value) {\n                    $key = preg_replace('/^_/', '', $key, 1);\n                    if (!in_array($key, ['key', 'type'])) {\n                        $t->addTranslation($key, $value);\n                    }\n                }\n\n                if ($data['key']) {\n                    $t->setKey($data['key']);\n                }\n\n                if ($data['type']) {\n                    $t->setType($data['type']);\n                }\n                $t->setModificationDate(time());\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            } elseif ($request->get('xaction') == 'create') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t) {\n                    return $this->adminJson([\n                        'message' => 'identifier_already_exists',\n                        'success' => false,\n                    ]);\n                }\n\n                $t = new Translation();\n                $t->setDomain($domain);\n                $t->setKey($data['key']);\n                $t->setCreationDate(time());\n                $t->setModificationDate(time());\n                $t->setType($data['type'] ?? null);\n\n                foreach (Tool::getValidLanguages() as $lang) {\n                    $t->addTranslation($lang, '');\n                }\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            }\n        } else {\n            // get list of types\n            $list = new Translation\\Listing();\n            $list->setDomain($domain);\n\n            $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n            $list->setOrder('asc');\n            $list->setOrderKey($tableName . '.key', false);\n\n            $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings(\n                array_merge($request->request->all(), $request->query->all())\n            );\n\n            $joins = [];\n\n            if ($orderKey = $sortingSettings['orderKey']) {\n                if (in_array(trim($orderKey, '_'), $validLanguages)) {\n                    $orderKey = trim($orderKey, '_');\n                    $joins[] = [\n                        'language' => $orderKey,\n                    ];\n                    $list->setOrderKey($orderKey);\n                } elseif ($list->isValidOrderKey($sortingSettings['orderKey'])) {\n                    $list->setOrderKey($tableName . '.' . $sortingSettings['orderKey'], false);\n                }\n            }\n            if ($sortingSettings['order']) {\n                $list->setOrder($sortingSettings['order']);\n            }\n\n            $list->setLimit($request->get('limit'));\n            $list->setOffset($request->get('start'));\n\n            $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n            $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n            if ($filters) {\n                $joins = array_merge($joins, $filters['joins']);\n            }\n\n            if (!empty($conditions)) {\n                $list->setCondition($conditions['condition'], $conditions['params']);\n            }\n\n            $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n            try {\n                $list->load();\n            } catch (SyntaxErrorException $syntaxErrorException) {\n                throw new \\InvalidArgumentException('Check your arguments.');\n            }\n\n            $translations = [];\n            $searchString = $request->get('searchString');\n            foreach ($list->getTranslations() as $t) {\n                //Reload translation to get complete data,\n                //if translation fetched based on the text not key\n                if ($searchString && !strpos($searchString, $t->getKey())) {\n                    if (!$t = Translation::getByKey($t->getKey(), $domain)) {\n                        continue;\n                    }\n                }\n\n                $translations[] = array_merge(\n                    $this->prefixTranslations($t->getTranslations()),\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ]\n                );\n            }\n\n            return $this->adminJson(['data' => $translations, 'success' => true, 'total' => $list->getTotalCount()]);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return array\n     */\n    protected function prefixTranslations($translations)\n    {\n        if (!is_array($translations)) {\n            return $translations;\n        }\n\n        $prefixedTranslations = [];\n        foreach ($translations as $lang => $trans) {\n            $prefixedTranslations['_' . $lang] = $trans;\n        }\n\n        return $prefixedTranslations;\n    }\n\n    /**\n     * @param array $joins\n     * @param Translation\\Listing $list\n     * @param string $tableName\n     * @param array $filters\n     */\n    protected function extendTranslationQuery($joins, $list, $tableName, $filters)\n    {\n        if ($joins) {\n            $list->onCreateQueryBuilder(\n                function (DoctrineQueryBuilder $select) use (\n                    $joins,\n                    $tableName,\n                    $filters\n                ) {\n                    $db = \\Pimcore\\Db::get();\n\n                    $alreadyJoined = [];\n\n                    foreach ($joins as $join) {\n                        $fieldname = $join['language'];\n\n                        if (isset($alreadyJoined[$fieldname])) {\n                            continue;\n                        }\n                        $alreadyJoined[$fieldname] = 1;\n\n                        $select->addSelect($fieldname . '.text AS ' . $fieldname);\n                        $select->leftJoin(\n                            $tableName,\n                            $tableName,\n                            $fieldname,\n                            '('\n                            . $fieldname . '.key = ' . $tableName . '.key'\n                            . ' and ' . $fieldname . '.language = ' . $db->quote($fieldname)\n                            . ')'\n                        );\n                    }\n\n                    $havings = $filters['conditions'];\n                    if ($havings) {\n                        $havings = implode(' AND ', $havings);\n                        $select->having($havings);\n                    }\n                }\n            );\n        }\n    }\n\n    /**\n     * @param Request $request\n     * @param string $tableName\n     * @param bool $languageMode\n     * @param bool $admin\n     * @return array\n     */\n    protected function getGridFilterCondition(Request $request, $tableName, $languageMode = false, $admin = false)\n    {\n        $placeHolderCount = 0;\n        $joins = [];\n        $conditions = [];\n        $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n        $db = \\Pimcore\\Db::get();\n        $conditionFilters = [];\n\n        $filterJson = $request->get('filter');\n        if ($filterJson) {\n            $propertyField = 'property';\n            $operatorField = 'operator';\n\n            $filters = $this->decodeJson($filterJson);\n\n            foreach ($filters as $filter) {\n                $operator = '=';\n                $field = null;\n                $value = null;\n\n                $fieldname = $filter[$propertyField];\n                if (in_array(ltrim($fieldname, '_'), $validLanguages)) {\n                    $fieldname = ltrim($fieldname, '_');\n                }\n                $fieldname = str_replace('--', '', $fieldname);\n\n                if (!$languageMode && in_array($fieldname, $validLanguages)\n                    || $languageMode && !in_array($fieldname, $validLanguages)) {\n                    continue;\n                }\n\n                if (!$languageMode) {\n                    $fieldname = $tableName . '.' . $fieldname;\n                }\n\n                if (!empty($filter['value'])) {\n                    if ($filter['type'] == 'string') {\n                        $operator = 'LIKE';\n                        $field = $fieldname;\n                        $value = '%' . $filter['value'] . '%';\n                    } elseif ($filter['type'] == 'date' ||\n                        (in_array($fieldname, ['modificationDate', 'creationDate']))) {\n                        if ($filter[$operatorField] == 'lt') {\n                            $operator = '<';\n                        } elseif ($filter[$operatorField] == 'gt') {\n                            $operator = '>';\n                        } elseif ($filter[$operatorField] == 'eq') {\n                            $operator = '=';\n                            $fieldname = \"UNIX_TIMESTAMP(DATE(FROM_UNIXTIME({$fieldname})))\";\n                        }\n                        $filter['value'] = strtotime($filter['value']);\n                        $field = $fieldname;\n                        $value = $filter['value'];\n                    }\n                }\n\n                if ($field && $value) {\n                    $condition = $field . ' ' . $operator . ' ' . $db->quote($value);\n\n                    if ($languageMode) {\n                        $conditions[$fieldname] = $condition;\n                        $joins[] = [\n                            'language' => $fieldname,\n                        ];\n                    } else {\n                        $placeHolderName = self::PLACEHOLDER_NAME . $placeHolderCount;\n                        $placeHolderCount++;\n                        $conditionFilters[] = [\n                            'condition' => $field . ' ' . $operator . ' :' . $placeHolderName,\n                            'field' => $placeHolderName,\n                            'value' => $value\n                        ];\n                    }\n                }\n            }\n        }\n\n        if ($request->get('searchString')) {\n            $conditionFilters[] = [\n                'condition' => '(lower(' . $tableName . '.key) LIKE :filterTerm OR lower(' . $tableName . '.text) LIKE :filterTerm)',\n                'field' => 'filterTerm',\n                'value' => '%' . mb_strtolower($request->get('searchString')) . '%'\n            ];\n        }\n\n        if ($languageMode) {\n            return [\n                'joins' => $joins,\n                'conditions' => $conditions,\n            ];\n        }\n\n        if(!empty($conditionFilters)) {\n            $conditions = [];\n            $params = [];\n            foreach($conditionFilters as $conditionFilter) {\n                $conditions[] = $conditionFilter['condition'];\n                $params[$conditionFilter['field']] = $conditionFilter['value'];\n            }\n\n            $conditionFilters = [\n                'condition' => implode(' AND ', $conditions),\n                'params' => $params\n            ];\n        }\n        return $conditionFilters;\n    }\n\n    /**\n     * @Route(\"/cleanup\", name=\"pimcore_admin_translation_cleanup\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function cleanupAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n        $list->cleanup();\n\n        \\Pimcore\\Cache::clearTags(['translator', 'translate']);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * -----------------------------------------------------------------------------------\n     * THE FOLLOWING ISN'T RELATED TO THE SHARED TRANSLATIONS OR ADMIN-TRANSLATIONS\n     * XLIFF CONTENT-EXPORT & MS WORD CONTENT-EXPORT\n     * -----------------------------------------------------------------------------------\n     */\n\n    /**\n     * @Route(\"/content-export-jobs\", name=\"pimcore_admin_translation_contentexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function contentExportJobsAction(Request $request)\n    {\n        $data = $this->decodeJson($request->get('data'));\n        $elements = [];\n        $jobs = [];\n        $exportId = uniqid();\n        $source = $request->get('source');\n        $target = $request->get('target');\n        $type = $request->get('type');\n\n        $source = str_replace('_', '-', $source);\n        $target = str_replace('_', '-', $target);\n\n        if ($data && is_array($data)) {\n            foreach ($data as $element) {\n                $elements[$element['type'] . '_' . $element['id']] = [\n                    'id' => $element['id'],\n                    'type' => $element['type'],\n                ];\n\n                $el = null;\n\n                if ($element['children']) {\n                    $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    $baseClass = ELement\\Service::getBaseClassNameForElement($element['type']);\n                    $listClass = '\\\\Pimcore\\\\Model\\\\' . $baseClass . '\\\\Listing';\n                    $list = new $listClass();\n                    $list->setUnpublished(true);\n                    if ($el instanceof DataObject\\AbstractObject) {\n                        // inlcude variants\n                        $list->setObjectTypes(\n                            [DataObject::OBJECT_TYPE_VARIANT,\n                                DataObject::OBJECT_TYPE_OBJECT,\n                                DataObject::OBJECT_TYPE_FOLDER, ]\n                        );\n                    }\n                    $list->setCondition(\n                        ($el instanceof DataObject ? 'o_' : '') . 'path LIKE ?',\n                        [$list->escapeLike($el->getRealFullPath() . ($el->getRealFullPath() != '/' ? '/' : '')) . '%']\n                    );\n                    $childs = $list->load();\n\n                    foreach ($childs as $child) {\n                        $childId = $child->getId();\n                        $elements[$element['type'] . '_' . $childId] = [\n                            'id' => $childId,\n                            'type' => $element['type'],\n                        ];\n\n                        if (isset($element['relations']) && $element['relations']) {\n                            $childDependencies = $child->getDependencies()->getRequires();\n                            foreach ($childDependencies as $cd) {\n                                if ($cd['type'] == 'object' || $cd['type'] == 'document') {\n                                    $elements[$cd['type'] . '_' . $cd['id']] = $cd;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (isset($element['relations']) && $element['relations']) {\n                    if (!$el instanceof Element\\ElementInterface) {\n                        $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    }\n\n                    $dependencies = $el->getDependencies()->getRequires();\n                    foreach ($dependencies as $dependency) {\n                        if ($dependency['type'] == 'object' || $dependency['type'] == 'document') {\n                            $elements[$dependency['type'] . '_' . $dependency['id']] = $dependency;\n                        }\n                    }\n                }\n            }\n        }\n\n        $elements = array_values($elements);\n\n        $elementsPerJob = 10;\n        if ($type == 'word') {\n            // the word export can only handle one document per request\n            // the problem is Document\\Service::render(), ... in the action can be a $this->redirect() or exit;\n            // nobody knows what's happening in an action ;-) So we need to isolate them in isolated processes\n            // so that the export doesn't stop completely after a \"redirect\" or any other unexpected behavior of an action\n            $elementsPerJob = 1;\n        }\n\n        // one job = X elements\n        $elements = array_chunk($elements, $elementsPerJob);\n        foreach ($elements as $chunk) {\n            $jobs[] = [[\n                'url' => $request->getBaseUrl() . '/admin/translation/' . $type . '-export',\n                'method' => 'POST',\n                'params' => [\n                    'id' => $exportId,\n                    'source' => $source,\n                    'target' => $target,\n                    'data' => $this->encodeJson($chunk),\n                ],\n            ]];\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n                'jobs' => $jobs,\n                'id' => $exportId,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/xliff-export\", name=\"pimcore_admin_translation_xliffexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ExportServiceInterface $exportService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffExportAction(Request $request, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n        $target = $request->get('target');\n\n        $translationItems = new TranslationItemCollection();\n\n        foreach ($data as $el) {\n            $element = Element\\Service::getElementById($el['type'], $el['id']);\n            $translationItems->addPimcoreElement($element);\n        }\n\n        $exportService->exportTranslationItems($translationItems, $source, [$target], $id);\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/xliff-export-download\", name=\"pimcore_admin_translation_xliffexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ExporterInterface $translationExporter\n     *\n     * @return BinaryFileResponse\n     */\n    public function xliffExportDownloadAction(Request $request, ExporterInterface $translationExporter, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $exportFile = $exportService->getTranslationExporter()->getExportFilePath($id);\n\n        $response = new BinaryFileResponse($exportFile);\n        $response->headers->set('Content-Type', $translationExporter->getContentType());\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, basename($exportFile));\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-upload\", name=\"pimcore_admin_translation_xliffimportupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportUploadAction(Request $request, ImportDataExtractorInterface $importDataExtractor)\n    {\n        $jobs = [];\n        $id = uniqid();\n        $importFile = $importDataExtractor->getImportFilePath($id);\n        copy($_FILES['file']['tmp_name'], $importFile);\n\n        $steps = $importDataExtractor->countSteps($id);\n\n        for ($i = 0; $i < $steps; $i++) {\n            $jobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_translation_xliffimportelement'),\n                'method' => 'POST',\n                'params' => [\n                    'id' => $id,\n                    'step' => $i,\n                ],\n            ]];\n        }\n\n        $response = $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'id' => $id,\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-element\", name=\"pimcore_admin_translation_xliffimportelement\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     * @param ImporterServiceInterface $importerService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportElementAction(Request $request, ImportDataExtractorInterface $importDataExtractor, ImporterServiceInterface $importerService)\n    {\n        $id = $request->get('id');\n        $step = $request->get('step');\n\n        try {\n            $attributeSet = $importDataExtractor->extractElement($id, $step);\n            if ($attributeSet) {\n                $importerService->import($attributeSet);\n            } else {\n                Logger::warning(sprintf('Could not resolve element %s', $id));\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e->getMessage());\n\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/word-export\", name=\"pimcore_admin_translation_wordexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function wordExportAction(Request $request)\n    {\n        ini_set('display_errors', 'off');\n\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, false);\n\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n\n        if (!is_file($exportFile)) {\n            File::put($exportFile, '');\n        }\n\n        foreach ($data as $el) {\n            try {\n                $element = Element\\Service::getElementById($el['type'], $el['id']);\n                $output = '';\n\n                // check supported types (subtypes)\n                if (!in_array($element->getType(), ['page', 'snippet', 'email', 'object'])) {\n                    continue;\n                }\n\n                if ($element instanceof Element\\ElementInterface) {\n                    $output .= '<h1 class=\"element-headline\">' . ucfirst(\n                        $element->getType()\n                    ) . ' - ' . $element->getRealFullPath() . ' (ID: ' . $element->getId() . ')</h1>';\n                }\n\n                if ($element instanceof Document\\PageSnippet) {\n                    if ($element instanceof Document\\Page) {\n                        $structuredDataEmpty = true;\n                        $structuredData = '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Structured Data</span></td>\n                                </tr>\n                        ';\n\n                        if ($element->getTitle()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Title</span></td>\n                                    <td>' . $element->getTitle() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getDescription()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Description</span></td>\n                                    <td>' . $element->getDescription() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getProperty('navigation_name')) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Navigation</span></td>\n                                    <td>' . $element->getProperty('navigation_name') . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        $structuredData .= '</table>';\n\n                        if (!$structuredDataEmpty) {\n                            $output .= $structuredData;\n                        }\n                    }\n\n                    // we need to set the parameter \"pimcore_admin\" here to be able to render unpublished documents\n                    $html = Document\\Service::render($element, [], false, ['pimcore_admin' => true]);\n\n                    $html = preg_replace(\n                        '@</?(img|meta|div|section|aside|article|body|bdi|bdo|canvas|embed|footer|head|header|html)([^>]+)?>@',\n                        '',\n                        $html\n                    );\n                    $html = preg_replace('/<!--(.*)-->/Uis', '', $html);\n\n                    $dom = new Tool\\DomCrawler($html);\n                    // remove containers including their contents\n                    $elements = $dom->filter('form, script, style, noframes, noscript, object, area, mapm, video, audio, iframe, textarea, input, select, button');\n                    foreach ($elements as $element) {\n                        $element->parentNode->removeChild($element);\n                    }\n\n                    $clearText = function ($string) {\n                        $string = str_replace(\"\\r\\n\", '', $string);\n                        $string = str_replace(\"\\n\", '', $string);\n                        $string = str_replace(\"\\r\", '', $string);\n                        $string = str_replace(\"\\t\", '', $string);\n                        $string = preg_replace('/&[a-zA-Z0-9]+;/', '', $string); // remove html entities\n                        $string = preg_replace('#[ ]+#', '', $string);\n\n                        return $string;\n                    };\n\n                    // remove empty tags (where it matters)\n                    // replace links => links get [Linktext]\n                    $elements = $dom->filter('a');\n                    foreach ($elements as $element) {\n                        $string = $clearText($element->textContent);\n                        if (!empty($string)) {\n                            $newNode = $element->ownerDocument->createTextNode('[' . $element->textContent . ']');\n\n                            $element->parentNode->replaceChild($newNode, $element);\n                        } else {\n                            $element->ownerDocument->textContent = '';\n                        }\n                    }\n\n                    if ($dom->count() > 0) {\n                        $html = $dom->html();\n                    }\n\n                    $dom->clear();\n                    unset($dom);\n\n                    // force closing tags\n                    $doc = new \\DOMDocument();\n                    libxml_use_internal_errors(true);\n                    $doc->loadHTML('<?xml encoding=\"UTF-8\"><article>' . $html . '</article>');\n                    libxml_clear_errors();\n                    $html = $doc->saveHTML();\n\n                    $bodyStart = strpos($html, '<body>');\n                    $bodyEnd = strpos($html, '</body>');\n                    if ($bodyStart && $bodyEnd) {\n                        $html = substr($html, $bodyStart + 6, $bodyEnd - $bodyStart);\n                    }\n\n                    $output .= $html;\n                } elseif ($element instanceof DataObject\\Concrete) {\n                    $hasContent = false;\n\n                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields|null $fd */\n                    $fd = $element->getClass()->getFieldDefinition('localizedfields');\n                    if ($fd) {\n                        $definitions = $fd->getFieldDefinitions();\n\n                        $locale = str_replace('-', '_', $source);\n                        if (!Tool::isValidLanguage($locale)) {\n                            $locale = \\Locale::getPrimaryLanguage($locale);\n                        }\n\n                        $output .= '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Localized Data</span></td>\n                                </tr>\n                        ';\n\n                        foreach ($definitions as $definition) {\n                            // check allowed datatypes\n                            if (!in_array($definition->getFieldtype(), ['input', 'textarea', 'wysiwyg'])) {\n                                continue;\n                            }\n\n                            $content = $element->{'get' . ucfirst($definition->getName())}($locale);\n\n                            if (!empty($content)) {\n                                $output .= '\n                                <tr>\n                                    <td><span style=\"color:#cc2929;\">' . $definition->getTitle() . ' (' . $definition->getName() . ')<span></td>\n                                    <td>' . $content . '&nbsp;</td>\n                                </tr>\n                                ';\n\n                                $hasContent = true;\n                            }\n                        }\n\n                        $output .= '</table>';\n                    }\n\n                    if (!$hasContent) {\n                        $output = ''; // there's no content in the object, so reset all contents and do not inclide it in the export\n                    }\n                }\n\n                // append contents\n                if (!empty($output)) {\n                    $f = fopen($exportFile, 'a+');\n                    fwrite($f, $output);\n                    fclose($f);\n                }\n            } catch (\\Exception $e) {\n                Logger::error('Word Export: ' . $e->getMessage());\n                Logger::error((string) $e);\n\n                throw $e;\n            }\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/word-export-download\", name=\"pimcore_admin_translation_wordexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function wordExportDownloadAction(Request $request)\n    {\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, true);\n\n        // no conversion, output html file, works fine with MS Word and LibreOffice\n        $content = file_get_contents($exportFile);\n        @unlink($exportFile);\n\n        // replace <script> and <link>\n        $content = preg_replace('/<link[^>]+>/im', '$1', $content);\n        $content = preg_replace(\"/<script[^>]+>(.*)?<\\/script>/im\", '$1', $content);\n\n        $content =\n            \"<html>\\n\" .\n            \"<head>\\n\" .\n            '<style type=\"text/css\">' . \"\\n\" .\n            file_get_contents(PIMCORE_WEB_ROOT . '/bundles/pimcoreadmin/css/word-export.css') .\n            \"</style>\\n\" .\n            \"</head>\\n\\n\" .\n            \"<body>\\n\" .\n            $content .\n            \"\\n\\n</body>\\n\" .\n            \"</html>\\n\";\n\n        $response = new Response($content);\n        $response->headers->set('Content-Type', 'text/html');\n        $response->headers->set(\n            'Content-Disposition',\n            'attachment; filename=\"word-export-' . date('Ymd') . '_' . uniqid() . '.htm\"'\n        );\n\n        return $response;\n    }\n\n    private function sanitzeExportId(string $id): string\n    {\n        if (empty($id) || !preg_match('/^[a-z0-9]+$/', $id)) {\n            throw new BadRequestHttpException('Invalid export ID format');\n        }\n\n        return $id;\n    }\n\n    private function getExportFilePath(string $id, bool $checkExistence = true): string\n    {\n        // no need to check for path traversals here as sanitizeExportId restricted the ID parameter\n        $exportFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . DIRECTORY_SEPARATOR . $id . '.html';\n\n        if ($checkExistence && !file_exists($exportFile)) {\n            throw $this->createNotFoundException(sprintf('Export file does not exist at path %s', $exportFile));\n        }\n\n        return $exportFile;\n    }\n\n    /**\n     * @Route(\"/merge-item\", name=\"pimcore_admin_translation_mergeitem\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function mergeItemAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n\n        $dataList = json_decode($request->get('data'), true);\n\n        foreach ($dataList as $data) {\n            $t = Translation::getByKey($data['key'], $domain, true);\n            $newValue = htmlspecialchars_decode($data['current']);\n            $t->addTranslation($data['lg'], $newValue);\n            $t->setModificationDate(time());\n            $t->save();\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-website-translation-languages\", name=\"pimcore_admin_translation_getwebsitetranslationlanguages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getWebsiteTranslationLanguagesAction(Request $request)\n    {\n        return $this->adminJson(\n            [\n                'view' => $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations(),\n\n                //when no view language is defined, all languages are editable. if one view language is defined, it\n                //may be possible that no edit language is set intentionally\n                'edit' => $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations(),\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-translation-domains\", name=\"pimcore_admin_translation_gettranslationdomains\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTranslationDomainsAction(Request $request)\n    {\n        $translation = new Translation();\n\n        $domains = array_map(\n            fn ($domain) => ['name' => $domain],\n            $translation->getDao()->getAvailableDomains(),\n        );\n\n        return $this->adminJson(['domains' => $domains]);\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/TranslationController.php"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [669], "fixing_code_start_loc": [18], "fixing_code_end_loc": [701], "type": "CWE-89", "message": "Pimcore is an open source data and experience management platform. Prior to version 10.5.21, A SQL injection vulnerability exists in the translation export API. Users should update to version 10.5.21 to receive a patch or, as a workaround, or apply the patch manually.", "other": {"cve": {"id": "CVE-2023-30849", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-27T16:15:11.330", "lastModified": "2023-05-05T17:01:26.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pimcore is an open source data and experience management platform. Prior to version 10.5.21, A SQL injection vulnerability exists in the translation export API. Users should update to version 10.5.21 to receive a patch or, as a workaround, or apply the patch manually."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.21", "matchCriteriaId": "72C537D6-67BA-4562-B853-F99E6C14315C"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/c6c80905e58c7724c776f980570a56df7016c6d1.patch", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pimcore/pimcore/pull/14968", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/pimcore/pimcore/security/advisories/GHSA-xmg8-w465-mr56", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/c6c80905e58c7724c776f980570a56df7016c6d1.patch"}}