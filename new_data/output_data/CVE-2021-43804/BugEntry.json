{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtcp.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/event.h>\n#include <pjmedia/rtcp_fb.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp.c\"\n\n#define RTCP_SR   200\n#define RTCP_RR   201\n#define RTCP_SDES 202\n#define RTCP_BYE  203\n#define RTCP_XR   207\n\n/* RTCP Feedbacks */\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\nenum {\n    RTCP_SDES_NULL  = 0,\n    RTCP_SDES_CNAME = 1,\n    RTCP_SDES_NAME  = 2,\n    RTCP_SDES_EMAIL = 3,\n    RTCP_SDES_PHONE = 4,\n    RTCP_SDES_LOC   = 5,\n    RTCP_SDES_TOOL  = 6,\n    RTCP_SDES_NOTE  = 7\n};\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\n\n/*\n * Get NTP time.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_get_ntp_time(const pjmedia_rtcp_session *sess,\n\t\t\t\t\t      pjmedia_rtcp_ntp_rec *ntp)\n{\n/* Seconds between 1900-01-01 to 1970-01-01 */\n#define JAN_1970  (2208988800UL)\n    pj_timestamp ts;\n    pj_status_t status;\n\n    status = pj_get_timestamp(&ts);\n\n    /* Fill up the high 32bit part */\n    ntp->hi = (pj_uint32_t)((ts.u64 - sess->ts_base.u64) / sess->ts_freq.u64)\n\t      + sess->tv_base.sec + JAN_1970;\n\n    /* Calculate seconds fractions */\n    ts.u64 = (ts.u64 - sess->ts_base.u64) % sess->ts_freq.u64;\n    pj_assert(ts.u64 < sess->ts_freq.u64);\n    ts.u64 = (ts.u64 << 32) / sess->ts_freq.u64;\n\n    /* Fill up the low 32bit part */\n    ntp->lo = ts.u32.lo;\n\n\n#if (defined(PJ_WIN32) && PJ_WIN32!=0) || \\\n    (defined(PJ_WIN64) && PJ_WIN64!=0) || \\\n    (defined(PJ_WIN32_WINCE) && PJ_WIN32_WINCE!=0)\n\n    /* On Win32, since we use QueryPerformanceCounter() as the backend\n     * timestamp API, we need to protect against this bug:\n     *   Performance counter value may unexpectedly leap forward\n     *   http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323\n     */\n    {\n\t/*\n\t * Compare elapsed time reported by timestamp with actual elapsed \n\t * time. If the difference is too excessive, then we use system\n\t * time instead.\n\t */\n\n\t/* MIN_DIFF needs to be large enough so that \"normal\" diff caused\n\t * by system activity or context switch doesn't trigger the time\n\t * correction.\n\t */\n\tenum { MIN_DIFF = 400 };\n\n\tpj_time_val ts_time, elapsed, diff;\n\n\tpj_gettimeofday(&elapsed);\n\n\tts_time.sec = ntp->hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp->lo * 1000.0 / 0xFFFFFFFF);\n\n\tPJ_TIME_VAL_SUB(elapsed, sess->tv_base);\n\n\tif (PJ_TIME_VAL_LT(ts_time, elapsed)) {\n\t    diff = elapsed;\n\t    PJ_TIME_VAL_SUB(diff, ts_time);\n\t} else {\n\t    diff = ts_time;\n\t    PJ_TIME_VAL_SUB(diff, elapsed);\n\t}\n\n\tif (PJ_TIME_VAL_MSEC(diff) >= MIN_DIFF) {\n\n\t    TRACE_((sess->name, \"RTCP NTP timestamp corrected by %d ms\",\n\t\t    PJ_TIME_VAL_MSEC(diff)));\n\n\n\t    ntp->hi = elapsed.sec + sess->tv_base.sec + JAN_1970;\n\t    ntp->lo = (elapsed.msec * 65536 / 1000) << 16;\n\t}\n\n    }\n#endif\n\n    return status;\n}\n\n\n/*\n * Initialize RTCP session setting.\n */\nPJ_DEF(void) pjmedia_rtcp_session_setting_default(\n\t\t\t\t    pjmedia_rtcp_session_setting *settings)\n{\n    pj_bzero(settings, sizeof(*settings));\n}\n\n\n/*\n * Initialize bidirectional RTCP statistics.\n *\n */\nPJ_DEF(void) pjmedia_rtcp_init_stat(pjmedia_rtcp_stat *stat)\n{\n    pj_time_val now;\n\n    pj_assert(stat);\n\n    pj_bzero(stat, sizeof(pjmedia_rtcp_stat));\n\n    pj_math_stat_init(&stat->rtt);\n    pj_math_stat_init(&stat->rx.loss_period);\n    pj_math_stat_init(&stat->rx.jitter);\n    pj_math_stat_init(&stat->tx.loss_period);\n    pj_math_stat_init(&stat->tx.jitter);\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n    pj_math_stat_init(&stat->rx_ipdv);\n#endif\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n    pj_math_stat_init(&stat->rx_raw_jitter);\n#endif\n\n    pj_gettimeofday(&now);\n    stat->start = now;\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init(pjmedia_rtcp_session *sess, \n\t\t\t       char *name,\n\t\t\t       unsigned clock_rate,\n\t\t\t       unsigned samples_per_frame,\n\t\t\t       pj_uint32_t ssrc)\n{\n    pjmedia_rtcp_session_setting settings;\n\n    pjmedia_rtcp_session_setting_default(&settings);\n    settings.name = name;\n    settings.clock_rate = clock_rate;\n    settings.samples_per_frame = samples_per_frame;\n    settings.ssrc = ssrc;\n\n    pjmedia_rtcp_init2(sess, &settings);\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_fini(pjmedia_rtcp_session *sess)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    pjmedia_rtcp_xr_fini(&sess->xr_session);\n#else\n    /* Nothing to do. */\n    PJ_UNUSED_ARG(sess);\n#endif\n}\n\nstatic void rtcp_init_seq(pjmedia_rtcp_session *sess)\n{\n    sess->received = 0;\n    sess->exp_prior = 0;\n    sess->rx_prior = 0;\n    sess->transit = 0;\n    sess->jitter = 0;\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp( pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload)\n{\n    pjmedia_rtcp_rx_rtp2(sess, seq, rtp_ts, payload, PJ_FALSE);\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp2(pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload,\n\t\t\t\t  pj_bool_t discarded)\n{   \n    pj_timestamp ts;\n    pj_uint32_t arrival;\n    pj_int32_t transit;\n    pjmedia_rtp_status seq_st;\n\n#if !defined(PJMEDIA_HAS_RTCP_XR) || (PJMEDIA_HAS_RTCP_XR == 0)\n    PJ_UNUSED_ARG(discarded);\n#endif\n\n    if (sess->stat.rx.pkt == 0) {\n\t/* Init sequence for the first time. */\n\tpjmedia_rtp_seq_init(&sess->seq_ctrl, (pj_uint16_t)seq);\n    } \n\n    sess->stat.rx.pkt++;\n    sess->stat.rx.bytes += payload;\n\n    /* Process the RTP packet. */\n    pjmedia_rtp_seq_update(&sess->seq_ctrl, (pj_uint16_t)seq, &seq_st);\n\n    if (seq_st.status.flag.restart) {\n\trtcp_init_seq(sess);\n    }\n    \n    if (seq_st.status.flag.dup) {\n\tsess->stat.rx.dup++;\n\tTRACE_((sess->name, \"Duplicate packet detected\"));\n    }\n\n    if (seq_st.status.flag.outorder && !seq_st.status.flag.probation) {\n\tsess->stat.rx.reorder++;\n\tTRACE_((sess->name, \"Out-of-order packet detected\"));\n    }\n\n    if (seq_st.status.flag.bad) {\n\tsess->stat.rx.discard++;\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       -1,\t\t\t\t /* lost    */\n\t\t\t       (seq_st.status.flag.dup? 1:0),\t /* dup     */\n\t\t\t       (!seq_st.status.flag.dup? 1:-1),  /* discard */\n\t\t\t       -1,\t\t\t\t /* jitter  */\n\t\t\t       -1, 0);\t\t\t\t /* toh\t    */\n#endif\n\n\tTRACE_((sess->name, \"Bad packet discarded\"));\n\treturn;\n    }\n\n    /* Only mark \"good\" packets */\n    ++sess->received;\n\n    /* Calculate loss periods. */\n    if (seq_st.diff > 1) {\n\tunsigned count = seq_st.diff - 1;\n\tunsigned period;\n\n\tperiod = count * sess->pkt_size * 1000 / sess->clock_rate;\n\tperiod *= 1000;\n\n\t/* Update packet lost. \n\t * The packet lost number will also be updated when we're sending\n\t * outbound RTCP RR.\n\t */\n\tsess->stat.rx.loss += (seq_st.diff - 1);\n\tTRACE_((sess->name, \"%d packet(s) lost\", seq_st.diff - 1));\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.rx.loss_period, period);\n    }\n\n\n    /*\n     * Calculate jitter only when sequence is good (see RFC 3550 section A.8),\n     * AND only when the timestamp is different than the last packet\n     * (see RTP FAQ).\n     */\n    if (seq_st.diff == 1 && rtp_ts != sess->rtp_last_ts) {\n\t/* Get arrival time and convert timestamp to samples */\n\tpj_get_timestamp(&ts);\n\tts.u64 = ts.u64 * sess->clock_rate / sess->ts_freq.u64;\n\tarrival = ts.u32.lo;\n\n\ttransit = arrival - rtp_ts;\n    \n\t/* Ignore the first N packets as they normally have bad jitter\n\t * due to other threads working to establish the call\n\t */\n\tif (sess->transit == 0 || \n\t    sess->received < PJMEDIA_RTCP_IGNORE_FIRST_PACKETS) \n\t{\n\t    sess->transit = transit;\n\t    sess->stat.rx.jitter.min = (unsigned)-1;\n\t} else {\n\t    pj_int32_t d;\n\t    pj_uint32_t jitter;\n\n\t    d = transit - sess->transit;\n\t    if (d < 0) \n\t\td = -d;\n\t    \n\t    sess->jitter += d - ((sess->jitter + 8) >> 4);\n\n\t    /* Update jitter stat */\n\t    jitter = sess->jitter >> 4;\n\t    \n\t    /* Convert jitter unit from samples to usec */\n\t    if (jitter < 4294)\n\t\tjitter = jitter * 1000000 / sess->clock_rate;\n\t    else {\n\t\tjitter = jitter * 1000 / sess->clock_rate;\n\t\tjitter *= 1000;\n\t    }\n\t    pj_math_stat_update(&sess->stat.rx.jitter, jitter);\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n\t    {\n\t\tpj_uint32_t raw_jitter;\n\n\t\t/* Convert raw jitter unit from samples to usec */\n\t\tif (d < 4294)\n\t\t    raw_jitter = d * 1000000 / sess->clock_rate;\n\t\telse {\n\t\t    raw_jitter = d * 1000 / sess->clock_rate;\n\t\t    raw_jitter *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_raw_jitter, raw_jitter);\n\t    }\n#endif\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n\t    {\n\t\tpj_int32_t ipdv;\n\n\t\tipdv = transit - sess->transit;\n\t\t/* Convert IPDV unit from samples to usec */\n\t\tif (ipdv > -2147 && ipdv < 2147)\n\t\t    ipdv = ipdv * 1000000 / (int)sess->clock_rate;\n\t\telse {\n\t\t    ipdv = ipdv * 1000 / (int)sess->clock_rate;\n\t\t    ipdv *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_ipdv, ipdv);\n\t    }\n#endif\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t\t   0,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   discarded,\t\t    /* discard */\n\t\t\t\t   (sess->jitter >> 4),\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n#endif\n\n\t    /* Update session transit */\n\t    sess->transit = transit;\n\t}\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (seq_st.diff > 1) {\n\tint i;\n\n\t/* Report RTCP XR about packet losses */\n\tfor (i=seq_st.diff-1; i>0; --i) {\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq - i, \n\t\t\t\t   1,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   0,\t\t\t    /* discard */\n\t\t\t\t   -1,\t\t\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n\t}\n\n\t/* Report RTCP XR this packet */\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       0,\t\t\t    /* lost    */\n\t\t\t       0,\t\t\t    /* dup     */\n\t\t\t       discarded,\t\t    /* discard */\n\t\t\t       -1,\t\t\t    /* jitter  */\n\t\t\t       -1, 0);\t\t\t    /* toh     */\n#endif\n    }\n\n    /* Update timestamp of last RX RTP packet */\n    sess->rtp_last_ts = rtp_ts;\n}\n\nPJ_DEF(void) pjmedia_rtcp_tx_rtp(pjmedia_rtcp_session *sess, \n\t\t\t\t unsigned bytes_payload_size)\n{\n    /* Update statistics */\n    sess->stat.tx.pkt++;\n    sess->stat.tx.bytes += bytes_payload_size;\n}\n\n\nstatic void parse_rtcp_report( pjmedia_rtcp_session *sess,\n\t\t\t       const void *pkt,\n\t\t\t       pj_size_t size)\n{\n    pjmedia_rtcp_common *common = (pjmedia_rtcp_common*) pkt;\n    const pjmedia_rtcp_rr *rr = NULL;\n    const pjmedia_rtcp_sr *sr = NULL;\n    pj_uint32_t last_loss, jitter_samp, jitter;\n\n    /* Parse RTCP */\n    if (common->pt == RTCP_SR) {\n\tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n\t    rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n\t\t\t\t    + sizeof(pjmedia_rtcp_sr)));\n\t}\n    } else if (common->pt == RTCP_RR && common->count > 0) {\n\trr = (pjmedia_rtcp_rr*)(((char*)pkt) + sizeof(pjmedia_rtcp_common));\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (common->pt == RTCP_XR) {\n\tif (sess->xr_enabled)\n\t    pjmedia_rtcp_xr_rx_rtcp_xr(&sess->xr_session, pkt, size);\n\n\treturn;\n#endif\n    }\n\n\n    if (sr) {\n\t/* Save LSR from NTP timestamp of RTCP packet */\n\tsess->rx_lsr = ((pj_ntohl(sr->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(sr->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate SR arrival time for DLSR */\n\tpj_get_timestamp(&sess->rx_lsr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", \n\t\tsess->rx_lsr,\n\t\t(pj_uint32_t)(sess->rx_lsr_time.u64*65536/sess->ts_freq.u64)));\n    }\n\n\n    /* Nothing more to do if there's no RR packet */\n    if (rr == NULL)\n\treturn;\n\n\n    last_loss = sess->stat.tx.loss;\n\n    /* Get packet loss */\n    sess->stat.tx.loss = (rr->total_lost_2 << 16) +\n\t\t\t (rr->total_lost_1 << 8) +\n\t\t\t  rr->total_lost_0;\n\n    TRACE_((sess->name, \"Rx RTCP RR: total_lost_2=%x, 1=%x, 0=%x, lost=%d\", \n\t    (int)rr->total_lost_2,\n\t    (int)rr->total_lost_1,\n\t    (int)rr->total_lost_0,\n\t    sess->stat.tx.loss));\n    \n    /* We can't calculate the exact loss period for TX, so just give the\n     * best estimation.\n     */\n    if (sess->stat.tx.loss > last_loss) {\n\tunsigned period;\n\n\t/* Loss period in msec */\n\tperiod = (sess->stat.tx.loss - last_loss) * sess->pkt_size *\n\t\t 1000 / sess->clock_rate;\n\n\t/* Loss period in usec */\n\tperiod *= 1000;\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.tx.loss_period, period);\n    }\n\n    /* Get jitter value in usec */\n    jitter_samp = pj_ntohl(rr->jitter);\n    /* Calculate jitter in usec, avoiding overflows */\n    if (jitter_samp <= 4294)\n\tjitter = jitter_samp * 1000000 / sess->clock_rate;\n    else {\n\tjitter = jitter_samp * 1000 / sess->clock_rate;\n\tjitter *= 1000;\n    }\n\n    /* Update jitter statistics */\n    pj_math_stat_update(&sess->stat.tx.jitter, jitter);\n\n    /* Can only calculate if LSR and DLSR is present in RR */\n    if (rr->lsr && rr->dlsr) {\n\tpj_uint32_t lsr, now, dlsr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LSR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlsr = pj_ntohl(rr->lsr);\n\n\t/* DLSR is delay since LSR, also in 1/65536 resolution */\n\tdlsr = pj_ntohl(rr->dlsr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lsr-dlsr) */\n\teedelay = now - lsr - dlsr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP RR: lsr=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlsr, dlsr, dlsr/65536, (dlsr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lsr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlsr >= lsr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay > 30 * 1000 * 1000UL) {\n\n\t\tTRACE_((sess->name, \"RTT not making any sense, ignored..\"));\n\t\tgoto end_rtt_calc;\n\t    }\n\n#if defined(PJMEDIA_RTCP_NORMALIZE_FACTOR) && PJMEDIA_RTCP_NORMALIZE_FACTOR!=0\n\t    /* \"Normalize\" rtt value that is exceptionally high. For such\n\t     * values, \"normalize\" the rtt to be PJMEDIA_RTCP_NORMALIZE_FACTOR\n\t     * times the average value.\n\t     */\n\t    if (rtt > ((unsigned)sess->stat.rtt.mean *\n\t\t       PJMEDIA_RTCP_NORMALIZE_FACTOR) && sess->stat.rtt.n!=0)\n\t    {\n\t\tunsigned orig_rtt = rtt;\n\t\trtt = sess->stat.rtt.mean * PJMEDIA_RTCP_NORMALIZE_FACTOR;\n\t\tPJ_LOG(5,(sess->name,\n\t\t\t  \"RTT value %d usec is normalized to %d usec\",\n\t\t\t  orig_rtt, rtt));\n\t    }\n#endif\n\t    TRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\n\t    /* Update RTT stat */\n\t    pj_math_stat_update(&sess->stat.rtt, rtt);\n\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lsr=%p, now=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lsr, now, dlsr, dlsr/65536,\n\t\t\t\t   (dlsr%65536)*1000/65536,\n\t\t\t\t   dlsr-(now-lsr)));\n\t}\n    }\n\nend_rtt_calc:\n\n    pj_gettimeofday(&sess->stat.tx.update);\n    sess->stat.tx.update_cnt++;\n}\n\n\nstatic void parse_rtcp_sdes(pjmedia_rtcp_session *sess,\n\t\t\t    const void *pkt,\n\t\t\t    pj_size_t size)\n{\n    pjmedia_rtcp_sdes *sdes = &sess->stat.peer_sdes;\n    char *p, *p_end;\n    char *b, *b_end;\n\n    p = (char*)pkt + 8;\n    p_end = (char*)pkt + size;\n\n    pj_bzero(sdes, sizeof(*sdes));\n    b = sess->stat.peer_sdes_buf_;\n    b_end = b + sizeof(sess->stat.peer_sdes_buf_);\n\n    while (p < p_end) {\n\tpj_uint8_t sdes_type, sdes_len;\n\tpj_str_t sdes_value = {NULL, 0};\n\n\tsdes_type = *p++;\n\n\t/* Check for end of SDES item list */\n\tif (sdes_type == RTCP_SDES_NULL || p == p_end)\n\t    break;\n\n\tsdes_len = *p++;\n\n\t/* Check for corrupted SDES packet */\n\tif (p + sdes_len > p_end)\n\t    break;\n\n\t/* Get SDES item */\n\tif (b + sdes_len < b_end) {\n\t    pj_memcpy(b, p, sdes_len);\n\t    sdes_value.ptr = b;\n\t    sdes_value.slen = sdes_len;\n\t    b += sdes_len;\n\t} else {\n\t    /* Insufficient SDES buffer */\n\t    PJ_LOG(5, (sess->name,\n\t\t    \"Unsufficient buffer to save RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_len, p));\n\t    p += sdes_len;\n\t    continue;\n\t}\n\n\tswitch (sdes_type) {\n\tcase RTCP_SDES_CNAME:\n\t    sdes->cname = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NAME:\n\t    sdes->name = sdes_value;\n\t    break;\n\tcase RTCP_SDES_EMAIL:\n\t    sdes->email = sdes_value;\n\t    break;\n\tcase RTCP_SDES_PHONE:\n\t    sdes->phone = sdes_value;\n\t    break;\n\tcase RTCP_SDES_LOC:\n\t    sdes->loc = sdes_value;\n\t    break;\n\tcase RTCP_SDES_TOOL:\n\t    sdes->tool = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NOTE:\n\t    sdes->note = sdes_value;\n\t    break;\n\tdefault:\n\t    TRACE_((sess->name, \"Received unknown RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_value.slen, sdes_value.ptr));\n\t    break;\n\t}\n\n\tp += sdes_len;\n    }\n}\n\n\nstatic void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n\n    /* Check and get BYE reason */\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    /* Just print RTCP BYE log */\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}\n\n\nstatic void parse_rtcp_fb(pjmedia_rtcp_session *sess,\n\t\t\t  const void *pkt,\n\t\t\t  pj_size_t size)\n{\n    unsigned cnt = 1;\n    pjmedia_rtcp_fb_nack nack[1];\n    //pjmedia_rtcp_fb_sli sli[1];\n    //pjmedia_rtcp_fb_rpsi rpsi;\n    pjmedia_event ev;\n    pj_timestamp ts_now;\n\n    pj_get_timestamp(&ts_now);\n\n    if (pjmedia_rtcp_fb_parse_nack(pkt, size, &cnt, nack)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tev.data.rx_rtcp_fb.msg.nack = nack[0];\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n    } else if (pjmedia_rtcp_fb_parse_pli(pkt, size)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tpj_strset2(&ev.data.rx_rtcp_fb.cap.param, (char*)\"pli\");\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n\t/*  For other FB type implementations later\n    } else if (pjmedia_rtcp_fb_parse_sli(pkt, size, &cnt, sli)==PJ_SUCCESS)\n    {\n    } else if (pjmedia_rtcp_fb_parse_rpsi(pkt, size, &rpsi)==PJ_SUCCESS)\n    {\n\t*/\n    } else {\n\t/* Ignore unknown RTCP Feedback */\n\tTRACE_((sess->name, \"Received unknown RTCP feedback\"));\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    /* Ignore unknown RTCP */\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp(pjmedia_rtcp_session *sess, \n\t\t\t\t     void **ret_p_pkt, int *len)\n{\n    pj_uint32_t expected, expected_interval, received_interval, lost_interval;\n    pjmedia_rtcp_sr *sr;\n    pjmedia_rtcp_rr *rr;\n    pj_timestamp ts_now;\n    pjmedia_rtcp_ntp_rec ntp;\n\n    /* Get current NTP time. */\n    pj_get_timestamp(&ts_now);\n    pjmedia_rtcp_get_ntp_time(sess, &ntp);\n\n\n    /* See if we have transmitted RTP packets since last time we\n     * sent RTCP SR.\n     */\n    if (sess->stat.tx.pkt != pj_ntohl(sess->rtcp_sr_pkt.sr.sender_pcount)) {\n\tpj_time_val ts_time;\n\tpj_uint32_t rtp_ts;\n\n\t/* So we should send RTCP SR */\n\t*ret_p_pkt = (void*) &sess->rtcp_sr_pkt;\n\t*len = sizeof(pjmedia_rtcp_sr_pkt);\n\trr = &sess->rtcp_sr_pkt.rr;\n\tsr = &sess->rtcp_sr_pkt.sr;\n\n\t/* Update packet count */\n\tsr->sender_pcount = pj_htonl(sess->stat.tx.pkt);\n\n\t/* Update octets count */\n\tsr->sender_bcount = pj_htonl(sess->stat.tx.bytes);\n\n\t/* Fill in NTP timestamp in SR. */\n\tsr->ntp_sec = pj_htonl(ntp.hi);\n\tsr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Fill in RTP timestamp (corresponds to NTP timestamp) in SR. */\n\tts_time.sec = ntp.hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp.lo * 1000.0 / 0xFFFFFFFF);\n\trtp_ts = sess->rtp_ts_base +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.sec) +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.msec/1000);\n\tsr->rtp_ts = pj_htonl(rtp_ts);\n\n\tTRACE_((sess->name, \"TX RTCP SR: ntp_ts=%p\", \n\t\t\t   ((ntp.hi & 0xFFFF) << 16) + ((ntp.lo & 0xFFFF0000) \n\t\t\t\t>> 16)));\n\n\n    } else {\n\t/* We should send RTCP RR then */\n\t*ret_p_pkt = (void*) &sess->rtcp_rr_pkt;\n\t*len = sizeof(pjmedia_rtcp_rr_pkt);\n\trr = &sess->rtcp_rr_pkt.rr;\n\tsr = NULL;\n    }\n    \n    /* SSRC and last_seq */\n    rr->ssrc = pj_htonl(sess->peer_ssrc);\n    rr->last_seq = (sess->seq_ctrl.cycles & 0xFFFF0000L);\n    /* Since this is an \"+=\" operation, make sure we update last_seq on\n     * both RR and SR.\n     */\n    sess->rtcp_sr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    sess->rtcp_rr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    rr->last_seq = pj_htonl(rr->last_seq);\n\n\n    /* Jitter */\n    rr->jitter = pj_htonl(sess->jitter >> 4);\n    \n    \n    /* Total lost. */\n    expected = pj_ntohl(rr->last_seq) - sess->seq_ctrl.base_seq;\n\n    /* This is bug: total lost already calculated on each incoming RTP!\n    if (expected >= sess->received)\n\tsess->stat.rx.loss = expected - sess->received;\n    else\n\tsess->stat.rx.loss = 0;\n    */\n\n    rr->total_lost_2 = (sess->stat.rx.loss >> 16) & 0xFF;\n    rr->total_lost_1 = (sess->stat.rx.loss >> 8) & 0xFF;\n    rr->total_lost_0 = (sess->stat.rx.loss & 0xFF);\n\n    /* Fraction lost calculation */\n    expected_interval = expected - sess->exp_prior;\n    sess->exp_prior = expected;\n    \n    received_interval = sess->received - sess->rx_prior;\n    sess->rx_prior = sess->received;\n    \n    if (expected_interval >= received_interval)\n\tlost_interval = expected_interval - received_interval;\n    else\n\tlost_interval = 0;\n    \n    if (expected_interval==0 || lost_interval == 0) {\n\trr->fract_lost = 0;\n    } else {\n\trr->fract_lost = (lost_interval << 8) / expected_interval;\n    }\n    \n    if (sess->rx_lsr_time.u64 == 0 || sess->rx_lsr == 0) {\n\trr->lsr = 0;\n\trr->dlsr = 0;\n    } else {\n\tpj_timestamp ts;\n\tpj_uint32_t lsr = sess->rx_lsr;\n\tpj_uint64_t lsr_time = sess->rx_lsr_time.u64;\n\tpj_uint32_t dlsr;\n\t\n\t/* Convert LSR time to 1/65536 seconds resolution */\n\tlsr_time = (lsr_time << 16) / sess->ts_freq.u64;\n\n\t/* Fill in LSR.\n\t   LSR is the middle 32bit of the last SR NTP time received.\n\t */\n\trr->lsr = pj_htonl(lsr);\n\t\n\t/* Fill in DLSR.\n\t   DLSR is Delay since Last SR, in 1/65536 seconds.\n\t */\n\tts.u64 = ts_now.u64;\n\n\t/* Convert interval to 1/65536 seconds value */\n\tts.u64 = (ts.u64 << 16) / sess->ts_freq.u64;\n\n\t/* Get DLSR */\n\tdlsr = (pj_uint32_t)(ts.u64 - lsr_time);\n\trr->dlsr = pj_htonl(dlsr);\n\n\tTRACE_((sess->name,\"Tx RTCP RR: lsr=%p, lsr_time=%p, now=%p, dlsr=%p\"\n\t\t\t   \"(%ds:%03dms)\",\n\t\t\t   lsr, \n\t\t\t   (pj_uint32_t)lsr_time,\n\t\t\t   (pj_uint32_t)ts.u64, \n\t\t\t   dlsr,\n\t\t\t   dlsr/65536,\n\t\t\t   (dlsr%65536)*1000/65536 ));\n    }\n    \n    /* Update counter */\n    pj_gettimeofday(&sess->stat.rx.update);\n    sess->stat.rx.update_cnt++;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_sdes(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_sdes *sdes)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length && sdes, PJ_EINVAL);\n\n    /* Verify SDES item length */\n    if (sdes->cname.slen > 255 || sdes->name.slen  > 255 ||\n\tsdes->email.slen > 255 || sdes->phone.slen > 255 ||\n\tsdes->loc.slen   > 255 || sdes->tool.slen  > 255 ||\n\tsdes->note.slen  > 255)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (sdes->cname.slen) len += sdes->cname.slen + 2;\n    if (sdes->name.slen)  len += sdes->name.slen  + 2;\n    if (sdes->email.slen) len += sdes->email.slen + 2;\n    if (sdes->phone.slen) len += sdes->phone.slen + 2;\n    if (sdes->loc.slen)   len += sdes->loc.slen   + 2;\n    if (sdes->tool.slen)  len += sdes->tool.slen  + 2;\n    if (sdes->note.slen)  len += sdes->note.slen  + 2;\n    len++; /* null termination */\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP SDES header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_SDES;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP SDES items */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n#define BUILD_SDES_ITEM(SDES_NAME, SDES_TYPE) \\\n    if (sdes->SDES_NAME.slen) { \\\n\t*p++ = SDES_TYPE; \\\n\t*p++ = (pj_uint8_t)sdes->SDES_NAME.slen; \\\n\tpj_memcpy(p, sdes->SDES_NAME.ptr, sdes->SDES_NAME.slen); \\\n\tp += sdes->SDES_NAME.slen; \\\n    }\n    BUILD_SDES_ITEM(cname, RTCP_SDES_CNAME);\n    BUILD_SDES_ITEM(name,  RTCP_SDES_NAME);\n    BUILD_SDES_ITEM(email, RTCP_SDES_EMAIL);\n    BUILD_SDES_ITEM(phone, RTCP_SDES_PHONE);\n    BUILD_SDES_ITEM(loc,   RTCP_SDES_LOC);\n    BUILD_SDES_ITEM(tool,  RTCP_SDES_TOOL);\n    BUILD_SDES_ITEM(note,  RTCP_SDES_NOTE);\n#undef BUILD_SDES_ITEM\n\n    /* Null termination */\n    *p++ = 0;\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    /* Finally */\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_bye(pjmedia_rtcp_session *session,\n\t\t\t\t\t\tvoid *buf,\n\t\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\t\tconst pj_str_t *reason)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    /* Verify BYE reason length */\n    if (reason && reason->slen > 255)\n\treturn PJ_EINVAL;\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (reason && reason->slen) len += reason->slen + 1;\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP BYE header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_BYE;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Write RTCP BYE reason */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    if (reason && reason->slen) {\n\t*p++ = (pj_uint8_t)reason->slen;\n\tpj_memcpy(p, reason->ptr, reason->slen);\n\tp += reason->slen;\n    }\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_enable_xr( pjmedia_rtcp_session *sess, \n\t\t\t\t\t    pj_bool_t enable)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n    /* Check if request won't change anything */\n    if (!(enable ^ sess->xr_enabled))\n\treturn PJ_SUCCESS;\n\n    if (!enable) {\n\tsess->xr_enabled = PJ_FALSE;\n\treturn PJ_SUCCESS;\n    }\n\n    pjmedia_rtcp_xr_init(&sess->xr_session, sess, 0, 1);\n    sess->xr_enabled = PJ_TRUE;\n\n    return PJ_SUCCESS;\n\n#else\n\n    PJ_UNUSED_ARG(sess);\n    PJ_UNUSED_ARG(enable);\n    return PJ_ENOTSUP;\n\n#endif\n}\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtcp.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/event.h>\n#include <pjmedia/rtcp_fb.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp.c\"\n\n#define RTCP_SR   200\n#define RTCP_RR   201\n#define RTCP_SDES 202\n#define RTCP_BYE  203\n#define RTCP_XR   207\n\n/* RTCP Feedbacks */\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\nenum {\n    RTCP_SDES_NULL  = 0,\n    RTCP_SDES_CNAME = 1,\n    RTCP_SDES_NAME  = 2,\n    RTCP_SDES_EMAIL = 3,\n    RTCP_SDES_PHONE = 4,\n    RTCP_SDES_LOC   = 5,\n    RTCP_SDES_TOOL  = 6,\n    RTCP_SDES_NOTE  = 7\n};\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\n\n/*\n * Get NTP time.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_get_ntp_time(const pjmedia_rtcp_session *sess,\n\t\t\t\t\t      pjmedia_rtcp_ntp_rec *ntp)\n{\n/* Seconds between 1900-01-01 to 1970-01-01 */\n#define JAN_1970  (2208988800UL)\n    pj_timestamp ts;\n    pj_status_t status;\n\n    status = pj_get_timestamp(&ts);\n\n    /* Fill up the high 32bit part */\n    ntp->hi = (pj_uint32_t)((ts.u64 - sess->ts_base.u64) / sess->ts_freq.u64)\n\t      + sess->tv_base.sec + JAN_1970;\n\n    /* Calculate seconds fractions */\n    ts.u64 = (ts.u64 - sess->ts_base.u64) % sess->ts_freq.u64;\n    pj_assert(ts.u64 < sess->ts_freq.u64);\n    ts.u64 = (ts.u64 << 32) / sess->ts_freq.u64;\n\n    /* Fill up the low 32bit part */\n    ntp->lo = ts.u32.lo;\n\n\n#if (defined(PJ_WIN32) && PJ_WIN32!=0) || \\\n    (defined(PJ_WIN64) && PJ_WIN64!=0) || \\\n    (defined(PJ_WIN32_WINCE) && PJ_WIN32_WINCE!=0)\n\n    /* On Win32, since we use QueryPerformanceCounter() as the backend\n     * timestamp API, we need to protect against this bug:\n     *   Performance counter value may unexpectedly leap forward\n     *   http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323\n     */\n    {\n\t/*\n\t * Compare elapsed time reported by timestamp with actual elapsed \n\t * time. If the difference is too excessive, then we use system\n\t * time instead.\n\t */\n\n\t/* MIN_DIFF needs to be large enough so that \"normal\" diff caused\n\t * by system activity or context switch doesn't trigger the time\n\t * correction.\n\t */\n\tenum { MIN_DIFF = 400 };\n\n\tpj_time_val ts_time, elapsed, diff;\n\n\tpj_gettimeofday(&elapsed);\n\n\tts_time.sec = ntp->hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp->lo * 1000.0 / 0xFFFFFFFF);\n\n\tPJ_TIME_VAL_SUB(elapsed, sess->tv_base);\n\n\tif (PJ_TIME_VAL_LT(ts_time, elapsed)) {\n\t    diff = elapsed;\n\t    PJ_TIME_VAL_SUB(diff, ts_time);\n\t} else {\n\t    diff = ts_time;\n\t    PJ_TIME_VAL_SUB(diff, elapsed);\n\t}\n\n\tif (PJ_TIME_VAL_MSEC(diff) >= MIN_DIFF) {\n\n\t    TRACE_((sess->name, \"RTCP NTP timestamp corrected by %d ms\",\n\t\t    PJ_TIME_VAL_MSEC(diff)));\n\n\n\t    ntp->hi = elapsed.sec + sess->tv_base.sec + JAN_1970;\n\t    ntp->lo = (elapsed.msec * 65536 / 1000) << 16;\n\t}\n\n    }\n#endif\n\n    return status;\n}\n\n\n/*\n * Initialize RTCP session setting.\n */\nPJ_DEF(void) pjmedia_rtcp_session_setting_default(\n\t\t\t\t    pjmedia_rtcp_session_setting *settings)\n{\n    pj_bzero(settings, sizeof(*settings));\n}\n\n\n/*\n * Initialize bidirectional RTCP statistics.\n *\n */\nPJ_DEF(void) pjmedia_rtcp_init_stat(pjmedia_rtcp_stat *stat)\n{\n    pj_time_val now;\n\n    pj_assert(stat);\n\n    pj_bzero(stat, sizeof(pjmedia_rtcp_stat));\n\n    pj_math_stat_init(&stat->rtt);\n    pj_math_stat_init(&stat->rx.loss_period);\n    pj_math_stat_init(&stat->rx.jitter);\n    pj_math_stat_init(&stat->tx.loss_period);\n    pj_math_stat_init(&stat->tx.jitter);\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n    pj_math_stat_init(&stat->rx_ipdv);\n#endif\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n    pj_math_stat_init(&stat->rx_raw_jitter);\n#endif\n\n    pj_gettimeofday(&now);\n    stat->start = now;\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init(pjmedia_rtcp_session *sess, \n\t\t\t       char *name,\n\t\t\t       unsigned clock_rate,\n\t\t\t       unsigned samples_per_frame,\n\t\t\t       pj_uint32_t ssrc)\n{\n    pjmedia_rtcp_session_setting settings;\n\n    pjmedia_rtcp_session_setting_default(&settings);\n    settings.name = name;\n    settings.clock_rate = clock_rate;\n    settings.samples_per_frame = samples_per_frame;\n    settings.ssrc = ssrc;\n\n    pjmedia_rtcp_init2(sess, &settings);\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_fini(pjmedia_rtcp_session *sess)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    pjmedia_rtcp_xr_fini(&sess->xr_session);\n#else\n    /* Nothing to do. */\n    PJ_UNUSED_ARG(sess);\n#endif\n}\n\nstatic void rtcp_init_seq(pjmedia_rtcp_session *sess)\n{\n    sess->received = 0;\n    sess->exp_prior = 0;\n    sess->rx_prior = 0;\n    sess->transit = 0;\n    sess->jitter = 0;\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp( pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload)\n{\n    pjmedia_rtcp_rx_rtp2(sess, seq, rtp_ts, payload, PJ_FALSE);\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp2(pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload,\n\t\t\t\t  pj_bool_t discarded)\n{   \n    pj_timestamp ts;\n    pj_uint32_t arrival;\n    pj_int32_t transit;\n    pjmedia_rtp_status seq_st;\n\n#if !defined(PJMEDIA_HAS_RTCP_XR) || (PJMEDIA_HAS_RTCP_XR == 0)\n    PJ_UNUSED_ARG(discarded);\n#endif\n\n    if (sess->stat.rx.pkt == 0) {\n\t/* Init sequence for the first time. */\n\tpjmedia_rtp_seq_init(&sess->seq_ctrl, (pj_uint16_t)seq);\n    } \n\n    sess->stat.rx.pkt++;\n    sess->stat.rx.bytes += payload;\n\n    /* Process the RTP packet. */\n    pjmedia_rtp_seq_update(&sess->seq_ctrl, (pj_uint16_t)seq, &seq_st);\n\n    if (seq_st.status.flag.restart) {\n\trtcp_init_seq(sess);\n    }\n    \n    if (seq_st.status.flag.dup) {\n\tsess->stat.rx.dup++;\n\tTRACE_((sess->name, \"Duplicate packet detected\"));\n    }\n\n    if (seq_st.status.flag.outorder && !seq_st.status.flag.probation) {\n\tsess->stat.rx.reorder++;\n\tTRACE_((sess->name, \"Out-of-order packet detected\"));\n    }\n\n    if (seq_st.status.flag.bad) {\n\tsess->stat.rx.discard++;\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       -1,\t\t\t\t /* lost    */\n\t\t\t       (seq_st.status.flag.dup? 1:0),\t /* dup     */\n\t\t\t       (!seq_st.status.flag.dup? 1:-1),  /* discard */\n\t\t\t       -1,\t\t\t\t /* jitter  */\n\t\t\t       -1, 0);\t\t\t\t /* toh\t    */\n#endif\n\n\tTRACE_((sess->name, \"Bad packet discarded\"));\n\treturn;\n    }\n\n    /* Only mark \"good\" packets */\n    ++sess->received;\n\n    /* Calculate loss periods. */\n    if (seq_st.diff > 1) {\n\tunsigned count = seq_st.diff - 1;\n\tunsigned period;\n\n\tperiod = count * sess->pkt_size * 1000 / sess->clock_rate;\n\tperiod *= 1000;\n\n\t/* Update packet lost. \n\t * The packet lost number will also be updated when we're sending\n\t * outbound RTCP RR.\n\t */\n\tsess->stat.rx.loss += (seq_st.diff - 1);\n\tTRACE_((sess->name, \"%d packet(s) lost\", seq_st.diff - 1));\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.rx.loss_period, period);\n    }\n\n\n    /*\n     * Calculate jitter only when sequence is good (see RFC 3550 section A.8),\n     * AND only when the timestamp is different than the last packet\n     * (see RTP FAQ).\n     */\n    if (seq_st.diff == 1 && rtp_ts != sess->rtp_last_ts) {\n\t/* Get arrival time and convert timestamp to samples */\n\tpj_get_timestamp(&ts);\n\tts.u64 = ts.u64 * sess->clock_rate / sess->ts_freq.u64;\n\tarrival = ts.u32.lo;\n\n\ttransit = arrival - rtp_ts;\n    \n\t/* Ignore the first N packets as they normally have bad jitter\n\t * due to other threads working to establish the call\n\t */\n\tif (sess->transit == 0 || \n\t    sess->received < PJMEDIA_RTCP_IGNORE_FIRST_PACKETS) \n\t{\n\t    sess->transit = transit;\n\t    sess->stat.rx.jitter.min = (unsigned)-1;\n\t} else {\n\t    pj_int32_t d;\n\t    pj_uint32_t jitter;\n\n\t    d = transit - sess->transit;\n\t    if (d < 0) \n\t\td = -d;\n\t    \n\t    sess->jitter += d - ((sess->jitter + 8) >> 4);\n\n\t    /* Update jitter stat */\n\t    jitter = sess->jitter >> 4;\n\t    \n\t    /* Convert jitter unit from samples to usec */\n\t    if (jitter < 4294)\n\t\tjitter = jitter * 1000000 / sess->clock_rate;\n\t    else {\n\t\tjitter = jitter * 1000 / sess->clock_rate;\n\t\tjitter *= 1000;\n\t    }\n\t    pj_math_stat_update(&sess->stat.rx.jitter, jitter);\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n\t    {\n\t\tpj_uint32_t raw_jitter;\n\n\t\t/* Convert raw jitter unit from samples to usec */\n\t\tif (d < 4294)\n\t\t    raw_jitter = d * 1000000 / sess->clock_rate;\n\t\telse {\n\t\t    raw_jitter = d * 1000 / sess->clock_rate;\n\t\t    raw_jitter *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_raw_jitter, raw_jitter);\n\t    }\n#endif\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n\t    {\n\t\tpj_int32_t ipdv;\n\n\t\tipdv = transit - sess->transit;\n\t\t/* Convert IPDV unit from samples to usec */\n\t\tif (ipdv > -2147 && ipdv < 2147)\n\t\t    ipdv = ipdv * 1000000 / (int)sess->clock_rate;\n\t\telse {\n\t\t    ipdv = ipdv * 1000 / (int)sess->clock_rate;\n\t\t    ipdv *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_ipdv, ipdv);\n\t    }\n#endif\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t\t   0,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   discarded,\t\t    /* discard */\n\t\t\t\t   (sess->jitter >> 4),\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n#endif\n\n\t    /* Update session transit */\n\t    sess->transit = transit;\n\t}\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (seq_st.diff > 1) {\n\tint i;\n\n\t/* Report RTCP XR about packet losses */\n\tfor (i=seq_st.diff-1; i>0; --i) {\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq - i, \n\t\t\t\t   1,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   0,\t\t\t    /* discard */\n\t\t\t\t   -1,\t\t\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n\t}\n\n\t/* Report RTCP XR this packet */\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       0,\t\t\t    /* lost    */\n\t\t\t       0,\t\t\t    /* dup     */\n\t\t\t       discarded,\t\t    /* discard */\n\t\t\t       -1,\t\t\t    /* jitter  */\n\t\t\t       -1, 0);\t\t\t    /* toh     */\n#endif\n    }\n\n    /* Update timestamp of last RX RTP packet */\n    sess->rtp_last_ts = rtp_ts;\n}\n\nPJ_DEF(void) pjmedia_rtcp_tx_rtp(pjmedia_rtcp_session *sess, \n\t\t\t\t unsigned bytes_payload_size)\n{\n    /* Update statistics */\n    sess->stat.tx.pkt++;\n    sess->stat.tx.bytes += bytes_payload_size;\n}\n\n\nstatic void parse_rtcp_report( pjmedia_rtcp_session *sess,\n\t\t\t       const void *pkt,\n\t\t\t       pj_size_t size)\n{\n    pjmedia_rtcp_common *common = (pjmedia_rtcp_common*) pkt;\n    const pjmedia_rtcp_rr *rr = NULL;\n    const pjmedia_rtcp_sr *sr = NULL;\n    pj_uint32_t last_loss, jitter_samp, jitter;\n\n    /* Parse RTCP */\n    if (common->pt == RTCP_SR) {\n\tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n\t    rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n\t\t\t\t    + sizeof(pjmedia_rtcp_sr)));\n\t}\n    } else if (common->pt == RTCP_RR && common->count > 0) {\n\trr = (pjmedia_rtcp_rr*)(((char*)pkt) + sizeof(pjmedia_rtcp_common));\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (common->pt == RTCP_XR) {\n\tif (sess->xr_enabled)\n\t    pjmedia_rtcp_xr_rx_rtcp_xr(&sess->xr_session, pkt, size);\n\n\treturn;\n#endif\n    }\n\n\n    if (sr) {\n\t/* Save LSR from NTP timestamp of RTCP packet */\n\tsess->rx_lsr = ((pj_ntohl(sr->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(sr->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate SR arrival time for DLSR */\n\tpj_get_timestamp(&sess->rx_lsr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", \n\t\tsess->rx_lsr,\n\t\t(pj_uint32_t)(sess->rx_lsr_time.u64*65536/sess->ts_freq.u64)));\n    }\n\n\n    /* Nothing more to do if there's no RR packet */\n    if (rr == NULL)\n\treturn;\n\n\n    last_loss = sess->stat.tx.loss;\n\n    /* Get packet loss */\n    sess->stat.tx.loss = (rr->total_lost_2 << 16) +\n\t\t\t (rr->total_lost_1 << 8) +\n\t\t\t  rr->total_lost_0;\n\n    TRACE_((sess->name, \"Rx RTCP RR: total_lost_2=%x, 1=%x, 0=%x, lost=%d\", \n\t    (int)rr->total_lost_2,\n\t    (int)rr->total_lost_1,\n\t    (int)rr->total_lost_0,\n\t    sess->stat.tx.loss));\n    \n    /* We can't calculate the exact loss period for TX, so just give the\n     * best estimation.\n     */\n    if (sess->stat.tx.loss > last_loss) {\n\tunsigned period;\n\n\t/* Loss period in msec */\n\tperiod = (sess->stat.tx.loss - last_loss) * sess->pkt_size *\n\t\t 1000 / sess->clock_rate;\n\n\t/* Loss period in usec */\n\tperiod *= 1000;\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.tx.loss_period, period);\n    }\n\n    /* Get jitter value in usec */\n    jitter_samp = pj_ntohl(rr->jitter);\n    /* Calculate jitter in usec, avoiding overflows */\n    if (jitter_samp <= 4294)\n\tjitter = jitter_samp * 1000000 / sess->clock_rate;\n    else {\n\tjitter = jitter_samp * 1000 / sess->clock_rate;\n\tjitter *= 1000;\n    }\n\n    /* Update jitter statistics */\n    pj_math_stat_update(&sess->stat.tx.jitter, jitter);\n\n    /* Can only calculate if LSR and DLSR is present in RR */\n    if (rr->lsr && rr->dlsr) {\n\tpj_uint32_t lsr, now, dlsr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LSR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlsr = pj_ntohl(rr->lsr);\n\n\t/* DLSR is delay since LSR, also in 1/65536 resolution */\n\tdlsr = pj_ntohl(rr->dlsr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lsr-dlsr) */\n\teedelay = now - lsr - dlsr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP RR: lsr=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlsr, dlsr, dlsr/65536, (dlsr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lsr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlsr >= lsr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay > 30 * 1000 * 1000UL) {\n\n\t\tTRACE_((sess->name, \"RTT not making any sense, ignored..\"));\n\t\tgoto end_rtt_calc;\n\t    }\n\n#if defined(PJMEDIA_RTCP_NORMALIZE_FACTOR) && PJMEDIA_RTCP_NORMALIZE_FACTOR!=0\n\t    /* \"Normalize\" rtt value that is exceptionally high. For such\n\t     * values, \"normalize\" the rtt to be PJMEDIA_RTCP_NORMALIZE_FACTOR\n\t     * times the average value.\n\t     */\n\t    if (rtt > ((unsigned)sess->stat.rtt.mean *\n\t\t       PJMEDIA_RTCP_NORMALIZE_FACTOR) && sess->stat.rtt.n!=0)\n\t    {\n\t\tunsigned orig_rtt = rtt;\n\t\trtt = sess->stat.rtt.mean * PJMEDIA_RTCP_NORMALIZE_FACTOR;\n\t\tPJ_LOG(5,(sess->name,\n\t\t\t  \"RTT value %d usec is normalized to %d usec\",\n\t\t\t  orig_rtt, rtt));\n\t    }\n#endif\n\t    TRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\n\t    /* Update RTT stat */\n\t    pj_math_stat_update(&sess->stat.rtt, rtt);\n\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lsr=%p, now=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lsr, now, dlsr, dlsr/65536,\n\t\t\t\t   (dlsr%65536)*1000/65536,\n\t\t\t\t   dlsr-(now-lsr)));\n\t}\n    }\n\nend_rtt_calc:\n\n    pj_gettimeofday(&sess->stat.tx.update);\n    sess->stat.tx.update_cnt++;\n}\n\n\nstatic void parse_rtcp_sdes(pjmedia_rtcp_session *sess,\n\t\t\t    const void *pkt,\n\t\t\t    pj_size_t size)\n{\n    pjmedia_rtcp_sdes *sdes = &sess->stat.peer_sdes;\n    char *p, *p_end;\n    char *b, *b_end;\n\n    p = (char*)pkt + 8;\n    p_end = (char*)pkt + size;\n\n    pj_bzero(sdes, sizeof(*sdes));\n    b = sess->stat.peer_sdes_buf_;\n    b_end = b + sizeof(sess->stat.peer_sdes_buf_);\n\n    while (p < p_end) {\n\tpj_uint8_t sdes_type, sdes_len;\n\tpj_str_t sdes_value = {NULL, 0};\n\n\tsdes_type = *p++;\n\n\t/* Check for end of SDES item list */\n\tif (sdes_type == RTCP_SDES_NULL || p == p_end)\n\t    break;\n\n\tsdes_len = *p++;\n\n\t/* Check for corrupted SDES packet */\n\tif (p + sdes_len > p_end)\n\t    break;\n\n\t/* Get SDES item */\n\tif (b + sdes_len < b_end) {\n\t    pj_memcpy(b, p, sdes_len);\n\t    sdes_value.ptr = b;\n\t    sdes_value.slen = sdes_len;\n\t    b += sdes_len;\n\t} else {\n\t    /* Insufficient SDES buffer */\n\t    PJ_LOG(5, (sess->name,\n\t\t    \"Unsufficient buffer to save RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_len, p));\n\t    p += sdes_len;\n\t    continue;\n\t}\n\n\tswitch (sdes_type) {\n\tcase RTCP_SDES_CNAME:\n\t    sdes->cname = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NAME:\n\t    sdes->name = sdes_value;\n\t    break;\n\tcase RTCP_SDES_EMAIL:\n\t    sdes->email = sdes_value;\n\t    break;\n\tcase RTCP_SDES_PHONE:\n\t    sdes->phone = sdes_value;\n\t    break;\n\tcase RTCP_SDES_LOC:\n\t    sdes->loc = sdes_value;\n\t    break;\n\tcase RTCP_SDES_TOOL:\n\t    sdes->tool = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NOTE:\n\t    sdes->note = sdes_value;\n\t    break;\n\tdefault:\n\t    TRACE_((sess->name, \"Received unknown RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_value.slen, sdes_value.ptr));\n\t    break;\n\t}\n\n\tp += sdes_len;\n    }\n}\n\n\nstatic void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n\n    /* Check and get BYE reason */\n    if (size > 8) {\n    \t/* Make sure the BYE reason does not exceed:\n    \t * - the size of the available buffer\n    \t * - the declared reason's length\n    \t * - the actual packet size\n    \t */\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n        reason.slen = PJ_MIN(reason.slen, size-9);\n\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    /* Just print RTCP BYE log */\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}\n\n\nstatic void parse_rtcp_fb(pjmedia_rtcp_session *sess,\n\t\t\t  const void *pkt,\n\t\t\t  pj_size_t size)\n{\n    unsigned cnt = 1;\n    pjmedia_rtcp_fb_nack nack[1];\n    //pjmedia_rtcp_fb_sli sli[1];\n    //pjmedia_rtcp_fb_rpsi rpsi;\n    pjmedia_event ev;\n    pj_timestamp ts_now;\n\n    pj_get_timestamp(&ts_now);\n\n    if (pjmedia_rtcp_fb_parse_nack(pkt, size, &cnt, nack)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tev.data.rx_rtcp_fb.msg.nack = nack[0];\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n    } else if (pjmedia_rtcp_fb_parse_pli(pkt, size)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tpj_strset2(&ev.data.rx_rtcp_fb.cap.param, (char*)\"pli\");\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n\t/*  For other FB type implementations later\n    } else if (pjmedia_rtcp_fb_parse_sli(pkt, size, &cnt, sli)==PJ_SUCCESS)\n    {\n    } else if (pjmedia_rtcp_fb_parse_rpsi(pkt, size, &rpsi)==PJ_SUCCESS)\n    {\n\t*/\n    } else {\n\t/* Ignore unknown RTCP Feedback */\n\tTRACE_((sess->name, \"Received unknown RTCP feedback\"));\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    /* Ignore unknown RTCP */\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp(pjmedia_rtcp_session *sess, \n\t\t\t\t     void **ret_p_pkt, int *len)\n{\n    pj_uint32_t expected, expected_interval, received_interval, lost_interval;\n    pjmedia_rtcp_sr *sr;\n    pjmedia_rtcp_rr *rr;\n    pj_timestamp ts_now;\n    pjmedia_rtcp_ntp_rec ntp;\n\n    /* Get current NTP time. */\n    pj_get_timestamp(&ts_now);\n    pjmedia_rtcp_get_ntp_time(sess, &ntp);\n\n\n    /* See if we have transmitted RTP packets since last time we\n     * sent RTCP SR.\n     */\n    if (sess->stat.tx.pkt != pj_ntohl(sess->rtcp_sr_pkt.sr.sender_pcount)) {\n\tpj_time_val ts_time;\n\tpj_uint32_t rtp_ts;\n\n\t/* So we should send RTCP SR */\n\t*ret_p_pkt = (void*) &sess->rtcp_sr_pkt;\n\t*len = sizeof(pjmedia_rtcp_sr_pkt);\n\trr = &sess->rtcp_sr_pkt.rr;\n\tsr = &sess->rtcp_sr_pkt.sr;\n\n\t/* Update packet count */\n\tsr->sender_pcount = pj_htonl(sess->stat.tx.pkt);\n\n\t/* Update octets count */\n\tsr->sender_bcount = pj_htonl(sess->stat.tx.bytes);\n\n\t/* Fill in NTP timestamp in SR. */\n\tsr->ntp_sec = pj_htonl(ntp.hi);\n\tsr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Fill in RTP timestamp (corresponds to NTP timestamp) in SR. */\n\tts_time.sec = ntp.hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp.lo * 1000.0 / 0xFFFFFFFF);\n\trtp_ts = sess->rtp_ts_base +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.sec) +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.msec/1000);\n\tsr->rtp_ts = pj_htonl(rtp_ts);\n\n\tTRACE_((sess->name, \"TX RTCP SR: ntp_ts=%p\", \n\t\t\t   ((ntp.hi & 0xFFFF) << 16) + ((ntp.lo & 0xFFFF0000) \n\t\t\t\t>> 16)));\n\n\n    } else {\n\t/* We should send RTCP RR then */\n\t*ret_p_pkt = (void*) &sess->rtcp_rr_pkt;\n\t*len = sizeof(pjmedia_rtcp_rr_pkt);\n\trr = &sess->rtcp_rr_pkt.rr;\n\tsr = NULL;\n    }\n    \n    /* SSRC and last_seq */\n    rr->ssrc = pj_htonl(sess->peer_ssrc);\n    rr->last_seq = (sess->seq_ctrl.cycles & 0xFFFF0000L);\n    /* Since this is an \"+=\" operation, make sure we update last_seq on\n     * both RR and SR.\n     */\n    sess->rtcp_sr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    sess->rtcp_rr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    rr->last_seq = pj_htonl(rr->last_seq);\n\n\n    /* Jitter */\n    rr->jitter = pj_htonl(sess->jitter >> 4);\n    \n    \n    /* Total lost. */\n    expected = pj_ntohl(rr->last_seq) - sess->seq_ctrl.base_seq;\n\n    /* This is bug: total lost already calculated on each incoming RTP!\n    if (expected >= sess->received)\n\tsess->stat.rx.loss = expected - sess->received;\n    else\n\tsess->stat.rx.loss = 0;\n    */\n\n    rr->total_lost_2 = (sess->stat.rx.loss >> 16) & 0xFF;\n    rr->total_lost_1 = (sess->stat.rx.loss >> 8) & 0xFF;\n    rr->total_lost_0 = (sess->stat.rx.loss & 0xFF);\n\n    /* Fraction lost calculation */\n    expected_interval = expected - sess->exp_prior;\n    sess->exp_prior = expected;\n    \n    received_interval = sess->received - sess->rx_prior;\n    sess->rx_prior = sess->received;\n    \n    if (expected_interval >= received_interval)\n\tlost_interval = expected_interval - received_interval;\n    else\n\tlost_interval = 0;\n    \n    if (expected_interval==0 || lost_interval == 0) {\n\trr->fract_lost = 0;\n    } else {\n\trr->fract_lost = (lost_interval << 8) / expected_interval;\n    }\n    \n    if (sess->rx_lsr_time.u64 == 0 || sess->rx_lsr == 0) {\n\trr->lsr = 0;\n\trr->dlsr = 0;\n    } else {\n\tpj_timestamp ts;\n\tpj_uint32_t lsr = sess->rx_lsr;\n\tpj_uint64_t lsr_time = sess->rx_lsr_time.u64;\n\tpj_uint32_t dlsr;\n\t\n\t/* Convert LSR time to 1/65536 seconds resolution */\n\tlsr_time = (lsr_time << 16) / sess->ts_freq.u64;\n\n\t/* Fill in LSR.\n\t   LSR is the middle 32bit of the last SR NTP time received.\n\t */\n\trr->lsr = pj_htonl(lsr);\n\t\n\t/* Fill in DLSR.\n\t   DLSR is Delay since Last SR, in 1/65536 seconds.\n\t */\n\tts.u64 = ts_now.u64;\n\n\t/* Convert interval to 1/65536 seconds value */\n\tts.u64 = (ts.u64 << 16) / sess->ts_freq.u64;\n\n\t/* Get DLSR */\n\tdlsr = (pj_uint32_t)(ts.u64 - lsr_time);\n\trr->dlsr = pj_htonl(dlsr);\n\n\tTRACE_((sess->name,\"Tx RTCP RR: lsr=%p, lsr_time=%p, now=%p, dlsr=%p\"\n\t\t\t   \"(%ds:%03dms)\",\n\t\t\t   lsr, \n\t\t\t   (pj_uint32_t)lsr_time,\n\t\t\t   (pj_uint32_t)ts.u64, \n\t\t\t   dlsr,\n\t\t\t   dlsr/65536,\n\t\t\t   (dlsr%65536)*1000/65536 ));\n    }\n    \n    /* Update counter */\n    pj_gettimeofday(&sess->stat.rx.update);\n    sess->stat.rx.update_cnt++;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_sdes(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_sdes *sdes)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length && sdes, PJ_EINVAL);\n\n    /* Verify SDES item length */\n    if (sdes->cname.slen > 255 || sdes->name.slen  > 255 ||\n\tsdes->email.slen > 255 || sdes->phone.slen > 255 ||\n\tsdes->loc.slen   > 255 || sdes->tool.slen  > 255 ||\n\tsdes->note.slen  > 255)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (sdes->cname.slen) len += sdes->cname.slen + 2;\n    if (sdes->name.slen)  len += sdes->name.slen  + 2;\n    if (sdes->email.slen) len += sdes->email.slen + 2;\n    if (sdes->phone.slen) len += sdes->phone.slen + 2;\n    if (sdes->loc.slen)   len += sdes->loc.slen   + 2;\n    if (sdes->tool.slen)  len += sdes->tool.slen  + 2;\n    if (sdes->note.slen)  len += sdes->note.slen  + 2;\n    len++; /* null termination */\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP SDES header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_SDES;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP SDES items */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n#define BUILD_SDES_ITEM(SDES_NAME, SDES_TYPE) \\\n    if (sdes->SDES_NAME.slen) { \\\n\t*p++ = SDES_TYPE; \\\n\t*p++ = (pj_uint8_t)sdes->SDES_NAME.slen; \\\n\tpj_memcpy(p, sdes->SDES_NAME.ptr, sdes->SDES_NAME.slen); \\\n\tp += sdes->SDES_NAME.slen; \\\n    }\n    BUILD_SDES_ITEM(cname, RTCP_SDES_CNAME);\n    BUILD_SDES_ITEM(name,  RTCP_SDES_NAME);\n    BUILD_SDES_ITEM(email, RTCP_SDES_EMAIL);\n    BUILD_SDES_ITEM(phone, RTCP_SDES_PHONE);\n    BUILD_SDES_ITEM(loc,   RTCP_SDES_LOC);\n    BUILD_SDES_ITEM(tool,  RTCP_SDES_TOOL);\n    BUILD_SDES_ITEM(note,  RTCP_SDES_NOTE);\n#undef BUILD_SDES_ITEM\n\n    /* Null termination */\n    *p++ = 0;\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    /* Finally */\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_bye(pjmedia_rtcp_session *session,\n\t\t\t\t\t\tvoid *buf,\n\t\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\t\tconst pj_str_t *reason)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    /* Verify BYE reason length */\n    if (reason && reason->slen > 255)\n\treturn PJ_EINVAL;\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (reason && reason->slen) len += reason->slen + 1;\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP BYE header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_BYE;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Write RTCP BYE reason */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    if (reason && reason->slen) {\n\t*p++ = (pj_uint8_t)reason->slen;\n\tpj_memcpy(p, reason->ptr, reason->slen);\n\tp += reason->slen;\n    }\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_enable_xr( pjmedia_rtcp_session *sess, \n\t\t\t\t\t    pj_bool_t enable)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n    /* Check if request won't change anything */\n    if (!(enable ^ sess->xr_enabled))\n\treturn PJ_SUCCESS;\n\n    if (!enable) {\n\tsess->xr_enabled = PJ_FALSE;\n\treturn PJ_SUCCESS;\n    }\n\n    pjmedia_rtcp_xr_init(&sess->xr_session, sess, 0, 1);\n    sess->xr_enabled = PJ_TRUE;\n\n    return PJ_SUCCESS;\n\n#else\n\n    PJ_UNUSED_ARG(sess);\n    PJ_UNUSED_ARG(enable);\n    return PJ_ENOTSUP;\n\n#endif\n}\n"], "filenames": ["pjmedia/src/pjmedia/rtcp.c"], "buggy_code_start_loc": [759], "buggy_code_end_loc": [761], "fixing_code_start_loc": [760], "fixing_code_end_loc": [769], "type": "CWE-125", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming RTCP BYE message contains a reason's length, this declared length is not checked against the actual received packet size, potentially resulting in an out-of-bound read access. This issue affects all users that use PJMEDIA and RTCP. A malicious actor can send a RTCP BYE message with an invalid reason length. Users are advised to upgrade as soon as possible. There are no known workarounds.", "other": {"cve": {"id": "CVE-2021-43804", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-22T18:15:07.900", "lastModified": "2023-02-02T18:08:18.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming RTCP BYE message contains a reason's length, this declared length is not checked against the actual received packet size, potentially resulting in an out-of-bound read access. This issue affects all users that use PJMEDIA and RTCP. A malicious actor can send a RTCP BYE message with an invalid reason length. Users are advised to upgrade as soon as possible. There are no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En las versiones afectadas, si el mensaje RTCP BYE entrante contiene la longitud de un motivo, esta longitud declarada no es comprobado con el tama\u00f1o real del paquete recibido, resultando potencialmente en un acceso de lectura fuera de l\u00edmites. Este problema afecta a todos los usuarios que usan PJMEDIA y RTCP. Un actor malicioso puede enviar un mensaje RTCP BYE con una longitud de raz\u00f3n no v\u00e1lida. Se aconseja a usuarios que actualicen lo antes posible. No se presentan soluciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/8b621f192cae14456ee0b0ade52ce6c6f258af1e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-3qx3-cg72-wrh9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/8b621f192cae14456ee0b0ade52ce6c6f258af1e"}}