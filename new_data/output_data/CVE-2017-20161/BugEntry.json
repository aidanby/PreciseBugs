{"buggy_code": ["/*\n    MacGeiger WIFI AP detector\n    Copyright (C) 2014 rofl0r\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <pcap/pcap.h>\n#include <stdio.h>\n#include <signal.h>\n#include <assert.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n\n#define GUI_FPS 40\n\n//RcB: DEP \"audio-backend.c\"\n#include \"audio-backend.c\"\n\n#define LIBRARY_CODE\n#include \"channel-switch.c\"\n\n#ifndef MIN\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#endif\n\n#ifndef MAX\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#endif\n\n//RcB: LINK \"-lpcap\"\n//RcB: LINK \"-lpthread\"\n\n#include \"../concol/console.h\"\n#include \"../concol/console_keys.h\"\n#include \"../concol/fonts/allfonts.h\"\n\n#ifdef NO_COLOR\n#define console_setcolor(A, B, C) do {} while(0)\n#endif\n\nstatic int outfd;\n\nstatic int usage(const char *argv0) {\n\tdprintf(2, \"%s network-interface\\n\"\n\t\t   \"i.e.: %s wlan0\\n\", argv0, argv0\n\t\t);\n\treturn 1;\n}\n\nstatic struct wlaninfo {\n\tchar essid[32];\n\tunsigned char mac[6];\n\tunsigned char channel;\n\tlong long total_rssi;\n\tlong long last_seen;\n\tunsigned long count;\n\tint last_rssi;\n} wlans[128];\nstatic unsigned wlan_count;\n\nstatic pthread_mutex_t wlan_lock = PTHREAD_MUTEX_INITIALIZER;\n#define lock() pthread_mutex_lock(&wlan_lock)\n#define unlock() pthread_mutex_unlock(&wlan_lock)\n\nstatic signed char min, max;\nstatic unsigned char selection, selected;\nstatic Console co, *t = &co;\n\nstatic int get_wlan_by_essid(char* essid) {\n\tunsigned i;\n\tfor(i=0;i<wlan_count;i++)\n\t\tif(!strcmp(essid, wlans[i].essid)) return i;\n\treturn -1;\n}\n\nstatic int get_wlan_by_mac(unsigned char mac[6]) {\n\tunsigned i;\n\tfor(i=0;i<wlan_count;i++)\n\t\tif(!memcmp(mac, wlans[i].mac, 6)) return i;\n\treturn -1;\n}\n\nstatic int get_new_wlan(void) {\n\tif(wlan_count+1<sizeof(wlans)/sizeof(wlans[0]))\n\t\treturn wlan_count++;\n\treturn -1;\n}\n\nstatic int set_rssi(struct wlaninfo *w) {\n\tint i = -1;\n//\tif(w->essid[0]) i = get_wlan_by_essid(w->essid);\n\tlock();\n\tif(i == -1) i = get_wlan_by_mac(w->mac);\n\tif(i == -1) i = get_new_wlan();\n\tif(i != -1) {\n\t\tstruct wlaninfo *d = &wlans[i];\n\t\tif(w->essid[0]) strcpy(d->essid, w->essid);\n\t\tmemcpy(d->mac, w->mac, 6);\n\t\td->total_rssi += w->last_rssi;\n\t\td->count++;\n\t\td->last_rssi = w->last_rssi;\n\t\td->channel = w->channel;\n\t}\n\tunlock();\n\treturn i;\n}\n\nvolatile int stop;\nvoid sigh(int x) {\n\tstop = 1;\n}\n\nstruct ieee80211_radiotap_header {\n\tuint8_t it_version;\n\tuint8_t it_pad;\n\tuint16_t it_len;\n\tuint32_t it_present;\n};\n\nenum ieee80211_radiotap_type {\n\tIEEE80211_RADIOTAP_TSFT = 0,\n\tIEEE80211_RADIOTAP_FLAGS = 1,\n\tIEEE80211_RADIOTAP_RATE = 2,\n\tIEEE80211_RADIOTAP_CHANNEL = 3,\n\tIEEE80211_RADIOTAP_FHSS = 4,\n\tIEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,\n\tIEEE80211_RADIOTAP_DBM_ANTNOISE = 6,\n\tIEEE80211_RADIOTAP_LOCK_QUALITY = 7,\n\tIEEE80211_RADIOTAP_TX_ATTENUATION = 8,\n\tIEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,\n\tIEEE80211_RADIOTAP_DBM_TX_POWER = 10,\n\tIEEE80211_RADIOTAP_ANTENNA = 11,\n\tIEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,\n\tIEEE80211_RADIOTAP_DB_ANTNOISE = 13,\n\tIEEE80211_RADIOTAP_RX_FLAGS = 14,\n\tIEEE80211_RADIOTAP_TX_FLAGS = 15,\n\tIEEE80211_RADIOTAP_RTS_RETRIES = 16,\n\tIEEE80211_RADIOTAP_DATA_RETRIES = 17,\n\tIEEE80211_RADIOTAP_XCHANNEL = 18,\n\tIEEE80211_RADIOTAP_MCS = 19,\n\tIEEE80211_RADIOTAP_AMPDU_STATUS = 20,\n\tIEEE80211_RADIOTAP_VHT = 21,\n\tIEEE80211_RADIOTAP_TIMESTAMP = 22,\n\tIEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,\n\tIEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,\n\tIEEE80211_RADIOTAP_EXT = 31\n};\n\nstatic const unsigned char ieee80211_radiotap_type_size[] = {\n\t[IEEE80211_RADIOTAP_TSFT] = 8,\n\t[IEEE80211_RADIOTAP_FLAGS] = 1,\n\t[IEEE80211_RADIOTAP_RATE] = 1,\n\t[IEEE80211_RADIOTAP_CHANNEL] = 2*2,\n\t[IEEE80211_RADIOTAP_FHSS] = 2,\n\t[IEEE80211_RADIOTAP_DBM_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DBM_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_LOCK_QUALITY] = 2,\n\t[IEEE80211_RADIOTAP_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DB_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DBM_TX_POWER] = 1,\n\t[IEEE80211_RADIOTAP_ANTENNA] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_RX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_TX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_RTS_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_DATA_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_MCS] = 1+1+1,\n\t[IEEE80211_RADIOTAP_AMPDU_STATUS] = 4+2+1+1,\n\t[IEEE80211_RADIOTAP_VHT] = 12,\n\t[IEEE80211_RADIOTAP_TIMESTAMP] = 12,\n};\n\nstatic const unsigned char ieee80211_radiotap_type_align[] = {\n\t[IEEE80211_RADIOTAP_TSFT] = 8,\n\t[IEEE80211_RADIOTAP_FLAGS] = 1,\n\t[IEEE80211_RADIOTAP_RATE] = 1,\n\t[IEEE80211_RADIOTAP_CHANNEL] = 2,\n\t[IEEE80211_RADIOTAP_FHSS] = 2,\n\t[IEEE80211_RADIOTAP_DBM_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DBM_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_LOCK_QUALITY] = 2,\n\t[IEEE80211_RADIOTAP_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DB_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DBM_TX_POWER] = 1,\n\t[IEEE80211_RADIOTAP_ANTENNA] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_RX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_TX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_RTS_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_DATA_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_MCS] = 1,\n\t[IEEE80211_RADIOTAP_AMPDU_STATUS] = 4,\n\t[IEEE80211_RADIOTAP_VHT] = 2,\n\t[IEEE80211_RADIOTAP_TIMESTAMP] = 8,\n};\n\nstatic unsigned get_flag_off(unsigned flags, unsigned which, unsigned start_off) {\n\tunsigned i,c=start_off;\n\tfor(i=0;i<which;i++) if(flags & (1U << i)) {\n\t\tc+= c & (ieee80211_radiotap_type_align[i]-1);\n\t\tc+= ieee80211_radiotap_type_size[i];\n\t}\n\treturn c;\n}\n\nstatic unsigned get_dbm_off(unsigned flags, unsigned start_off) {\n\treturn get_flag_off(flags, IEEE80211_RADIOTAP_DBM_ANTSIGNAL, start_off);\n}\n\nstatic unsigned get_chan_off(unsigned flags, unsigned start_off) {\n\treturn get_flag_off(flags, IEEE80211_RADIOTAP_CHANNEL, start_off);\n}\n\nstatic unsigned channel_from_freq(unsigned freq) {\n\treturn freq==2484?14:(freq-2407)/5;\n}\n\nstruct beaconframe {\n\tuint16_t framecontrol;\n\tuint16_t duration;\n\tunsigned char receiver[6];\n\tunsigned char source[6];\n\tunsigned char bssid[6];\n\tuint16_t sequence_no;\n};\n\nstatic unsigned char* find_tag(unsigned const char *tagdata, unsigned tag, unsigned bytes_left) {\n\twhile(bytes_left) {\n\t\tif(*tagdata == tag) return (unsigned char*)tagdata;\n\t\tunsigned tagsize = tagdata[1];\n\t\ttagdata+=2+tagsize;\n\t\tif(bytes_left < 2+tagsize) return 0;\n\t\tbytes_left-=2+tagsize;\n\t}\n\treturn 0;\n}\n\nstatic long long timeval2utime(struct timeval*t) {\n\treturn (t->tv_sec * 1000LL * 1000LL) + t->tv_usec;\n}\n\nstatic long long getutime64(void) {\n\tstruct timeval t;\n\tgettimeofday(&t, NULL);\n\treturn timeval2utime(&t);\n}\n\n\nstatic int filebased;\n\nstatic const unsigned char* pcap_next_wrapper(pcap_t *foo, struct pcap_pkthdr *h_out) {\n\tif(!filebased) {\n\t\tconst unsigned char* ret = 0;\n\t\tstruct pcap_pkthdr *hdr_temp;\n\t\tint err = pcap_next_ex(foo, &hdr_temp, &ret);\n\t\tif(err == 1) {\n\t\t\t*h_out = *hdr_temp;\n\t\t} else ret = 0;\n\t\tif(ret && outfd != -1){\n\t\t\tstruct pcap_file_pkthdr {\n\t\t\t\tunsigned sec_epoch;\n\t\t\t\tunsigned ms_sec;\n\t\t\t\tunsigned caplen;\n\t\t\t\tunsigned len;\n\t\t\t} hdr_out = {\n\t\t\t\t.sec_epoch = h_out->ts.tv_sec,\n\t\t\t\t.ms_sec = h_out->ts.tv_usec,\n\t\t\t\t.caplen = h_out->caplen,\n\t\t\t\t.len = h_out->len,\n\t\t\t};\n\t\t\twrite(outfd, &hdr_out, sizeof hdr_out);\n\t\t\twrite(outfd, ret, h_out->len);\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long long pcap_file_start_time, start_time;\n\tstatic unsigned char buf[2][2048];\n\tstatic struct pcap_pkthdr h[2];\n\tstatic int actbuf;\n\tconst unsigned char* ret;\n\tif(start_time == 0 || getutime64() - start_time >= timeval2utime(&h[!actbuf].ts) - pcap_file_start_time) {\n\t\tret = pcap_next(foo, h_out);\n\t\tif(ret) {\n\t\t\th[actbuf] = *h_out;\n\t\t\tassert(h[actbuf].len <= sizeof buf[actbuf]);\n\t\t\tmemcpy(buf[actbuf], ret, h[actbuf].len);\n\t\t\tactbuf = !actbuf;\n\t\t}\n\t\tif(!start_time) {\n\t\t\tstart_time = getutime64();\n\t\t\tassert(ret);\n\t\t\tpcap_file_start_time = timeval2utime(&h_out->ts);\n\t\t\treturn 0;\n\t\t}\n\t\tif(ret) {\n\t\t\t*h_out = h[actbuf];\n\t\t\treturn buf[actbuf];\n\t\t} else return 0;\n\t} else\n\t\treturn 0;\n}\n\nstatic inline int myisascii(int x) {\n\treturn x >= ' ' && x < 127;\n}\n\nstatic void dump_packet(const unsigned char* data, size_t len) {\n\tstatic const char atab[] = \"0123456789abcdef\";\n\tchar hex[24*2+1], ascii[24+1];\n\tunsigned h = 0, a = 0;\n\tint fill = ' ';\n\n\twhile(len) {\n\t\tlen--;\n\t\thex[h++] = atab[*data >> 4];\n\t\thex[h++] = atab[*data & 0xf];\n\t\tascii[a++] = myisascii(*data) ? *data : '.';\n\t\tif(a == 24) {\n\tdump:\n\t\t\thex[h] = 0;\n\t\t\tascii[a] = 0;\n\t\t\tprintf(\"%s\\t%s\\n\", hex, ascii);\n\n\t\t\tif(fill == '_') return; /* jump from filler */\n\n\t\t\ta = 0;\n\t\t\th = 0;\n\t\t}\n\t\tdata++;\n\t}\n\tif(a) {\n\tfiller:\n\t\twhile(a<24) {\n\t\t\thex[h++] = fill;\n\t\t\thex[h++] = fill;\n\t\t\tascii[a++] = fill;\n\t\t}\n\t\tgoto dump;\n\t}\n\ta = 0;\n\tfill = '_';\n\tgoto filler;\n}\n\nvoid setminmax(int val) {\n\tmin = MIN(min, val);\n\tmax = MAX(max, val);\n\tchar mmbuf[128];\n\tsnprintf(mmbuf, sizeof mmbuf, \"min: %d, max: %d\", min, max);\n\tconsole_settitle(t, mmbuf);\n}\n\nstatic int process_frame(pcap_t *foo) {\n\tstruct pcap_pkthdr h;\n\tconst unsigned char* data = pcap_next_wrapper(foo, &h);\n\tif(data) {\n\t\tif(console_getbackendtype(t) == cb_sdl && getenv(\"DEBUG\")) dump_packet(data, h.len);\n\t\tstruct ieee80211_radiotap_header *rh = (void*) data;\n\t\t//size_t next_chunk = sizeof(*rh);\n\t\tuint32_t flags = rh->it_present, flags_copy = flags;\n\t\tunsigned ext_bytes = 0;\n\t\twhile(flags_copy & (1U << IEEE80211_RADIOTAP_EXT)) {\n\t\t\tmemcpy(&flags_copy, data+sizeof(*rh)+ext_bytes, 4);\n\t\t\text_bytes += 4;\n\t\t}\n\t\tunsigned rtap_data = sizeof(*rh) + ext_bytes;\n\n\t\tstruct wlaninfo temp = {0};\n\t\t{\n\t\t\tif(!(flags & (1U << IEEE80211_RADIOTAP_DBM_ANTSIGNAL))) return -1;\n\t\t\tunsigned dbmoff = get_dbm_off(flags, rtap_data);\n\t\t\ttemp.last_rssi = ((signed char*)data)[dbmoff];\n\t\t}\n\t\t{\n//\t\t\tif(!(flags & (1U << IEEE80211_RADIOTAP_CHANNEL))) return -1;\n\t\t\tshort freq;\n\t\t\tunsigned chanoff = get_chan_off(flags, rtap_data);\n\t\t\tmemcpy(&freq, data+ chanoff, 2);\n\t\t\ttemp.channel = channel_from_freq(freq);\n\t\t}\n\t\tuint16_t framectl;\n\t\tmemcpy(&framectl, data+rh->it_len, 2);\n\t\tstruct beaconframe* beacon;\n\t\tunsigned const char* tagdata, *curr_tag;\n\t\tunsigned pos;\n\t\tswitch(htons(framectl)) {\n\t\t\t/* IEEE 802.11 packet type */\n\t\t\tcase 0xd400: /*ack*/\n\t\t\t\t//memcpy(&temp.mac,data+rh->it_len+4, 6);\n\t\t\t\t//set_rssi(&temp, dbm);\n\t\t\t\t//break;\n\t\t\t\treturn -1;\n\t\t\tcase 0x8000: /*beacon */\n\t\t\t\tbeacon = (void*)(data+rh->it_len);\n\t\t\t\tmemcpy(&temp.mac,beacon->source,6);\n\t\t\t\tpos = rh->it_len+sizeof(*beacon)+12;\n\t\t\t\ttagdata = data+pos;\n\t\t\t\tcurr_tag = find_tag(tagdata, 0, h.len-pos); /* find essid tag */\n\t\t\t\tif(curr_tag) {\n\t\t\t\t\tmemcpy(temp.essid, curr_tag+2, curr_tag[1]);\n\t\t\t\t\ttemp.essid[curr_tag[1]] = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* dubious beacon without essid */\n\t\t\t\t\tdprintf(2, \"XXX\\n\");\n\t\t\t\t\tif(console_getbackendtype(t) == cb_sdl && getenv(\"DEBUG\")) dump_packet(data, h.len);\n\t\t\t\t}\n\t\t\t\tcurr_tag = find_tag(tagdata, 3, h.len-pos); /* find channel nr tag */\n\t\t\t\tif(curr_tag) {\n\t\t\t\t\tassert(curr_tag[1] == 1);\n\t\t\t\t\ttemp.channel = curr_tag[2];\n\t\t\t\t}\n\t\t\t\tsetminmax(temp.last_rssi);\n\n\t\t\t\treturn set_rssi(&temp);\n\n\t\t\t\tbreak;\n\t\t\tcase 0x8842: /*QOS */\n\t\t\tcase 0x4000: /* probe request */\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\t//while(htonl(*(flags++)) & (1U << IEEE80211_RADIOTAP_EXT)) next_chunk+=4;\n\t\t//dprintf(2, \"got data\\n\");\n\t\t//dump();\n\t} else usleep(1);\n\treturn -1;\n}\n\n#if 0\nstatic int next_chan(int chan) {\n\tif(++chan > 11) chan = 1;\n\treturn chan;\n}\n#elif 1\nstatic int next_chan(int chan) {\n\tstatic char chanlist[]={1,5,9,13,2,6,10,14,3,7,11,4,8,12};\n\tint i = 0;\n\tfor(i = 0; i < sizeof chanlist && chanlist[i] != chan; i++);\n\tif(i >=13) return chanlist[0];\n\treturn chanlist[++i];\n}\n#else\nstatic int next_chan(int chan) {\n\tswitch (chan) {\n\t\tcase 1: case 2: case 3: case 4: case 5:\n\t\t\treturn 6;\n\t\tcase 6: case 7: case 8: case 9: case 10:\n\t\t\treturn 11;\n\t\tcase 11: case 12: case 13:\n\t\t\t/* uncomment next line if you leave in a country using chan 14 */\n\t\t\t//return 14;\n\t\tcase 14:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn 0;\n\t}\n}\n#endif\n\nstatic struct {int w, h;} dim;\n\n#define BGCOL RGB(33, 66, 133)\nstatic void draw_bg() {\n\tunsigned x, y;\n\tconsole_setcolor(t, 0, BGCOL);\n\tfor(y=0; y < dim.h; y++) {\n\t\tconsole_goto(t, 0, y);\n\t\tfor(x = 0; x < dim.w; x++)\n\t\t\tconsole_printchar(t, ' ', 0);\n\t}\n}\n\n#if 0\nstatic void dump_wlan(unsigned idx) {\n\tstruct wlaninfo *w = &wlans[idx];\n\tdprintf(1, \"%.2d %-24s %02x:%02x:%02x:%02x:%02x:%02x %.2f - %d\\n\", w->channel, w->essid,\n\t            w->mac[0], w->mac[1],\n\t            w->mac[2], w->mac[3], w->mac[4], w->mac[5],\n\t            (double)w->total_rssi/(double)w->count, w->last_rssi);\n}\n#else\nstatic int get_r(unsigned percent) {\n\treturn (50 - percent/2) * 5;\n}\nstatic int get_g(unsigned percent) {\n\treturn percent/2 * 5;\n}\nstatic int get_a(unsigned age) {\n\treturn 5+((50 - age)*5);\n}\n#define LINES_PER_NET 1\nstatic void selection_move(int dir) {\n\tif((int)selection+dir < 0) dir=0;\n\tif((int)selection+dir >= wlan_count ||\n\t   ((int)selection+dir)*LINES_PER_NET+1 >= dim.h) dir=0;\n\tselection += dir;\n}\n\nstatic volatile unsigned bms;\nstatic void set_bms(float percent) {\n\tfloat max = 800, min=50;\n\tfloat range=max-min;\n\tfloat rpercent = range/100.f;\n\tbms = min + (100 - percent) * rpercent;\n}\n\nchar *mac2str(unsigned char mac[static 6], char buf[static 18]) {\n\tunsigned m, x;\n\tchar hextab[16] = \"0123456789abcdef\";\n\tfor(m = 0, x=0 ; m<6; m++, x+=3) {\n\t\tbuf[x] = hextab[mac[m]>>4];\n\t\tbuf[x+1] = hextab[mac[m]&15];\n\t\tbuf[x+2] = ':';\n\t}\n\tbuf[17]=0;\n\treturn buf;\n}\n\n#define ESSID_PRINT_START 1\n#define ESSID_PRINT_END 32+ESSID_PRINT_START\n#define ESSID_PRINT_LEN (ESSID_PRINT_END - ESSID_PRINT_START)\n\nstatic void dump_wlan_info(unsigned wlanidx) {\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\tlock();\n\tunsigned line = 3;\n\tconsole_setcolor(t, 0, BGCOL);\n\tconsole_setcolor(t, 1, RGB(0xff,0xff,0xff));\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\tchar macbuf[18];\n\tconsole_printf(t, \"MAC %s\", mac2str(w->mac, macbuf));\n\n\tconsole_goto(t, ESSID_PRINT_END +1+25, line);\n\tconsole_printf(t, \"CHAN %d\", (int) w->channel);\n\n\tline++;\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\tconsole_printf(t, \"AVG %.2f dBm\", (double)w->total_rssi/(double)w->count);\n\n\tconsole_goto(t, ESSID_PRINT_END +1+25, line);\n\tconsole_printf(t, \"CURR %d dBm\", w->last_rssi);\n\tunlock();\n}\n\nstatic void dump_wlan_at(unsigned wlanidx, unsigned line) {\n\tconsole_goto(t, 0, line);\n\tconsole_setcolor(t, 0, BGCOL);\n\n\tconsole_setcolor(t, 1, RGB(255,255,0));\n\tif(wlanidx == selection) {\n\t\tconsole_printchar(t, '>', 0);\n\t} else {\n\t\tconsole_printchar(t, ' ', 0);\n\t}\n\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\n\tlock();\n\n\tlong long now = getutime64();\n\tlong long age_ms = (now - w->last_seen)/1000;\n\tage_ms=MIN(5000, age_ms)/100; /* seems we end up with a range 0-50 */\n\tunsigned a = get_a(age_ms);\n\n\tconsole_setcolor(t, 1, RGB(a,a,a));\n\tconsole_goto(t, ESSID_PRINT_START, line);\n\n\tchar macbuf[18];\n\n\tif(*w->essid)\n\t\tconsole_printf(t, \"%*s\", ESSID_PRINT_LEN, w->essid);\n\telse\n\t\tconsole_printf(t, \"<hidden> %*s\", ESSID_PRINT_LEN-9, mac2str(w->mac, macbuf));\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\n\tint scale = max - min;\n\tint width = dim.w - (ESSID_PRINT_LEN+2);\n\tunsigned x;\n\tfloat widthpercent = (float)width/100.f;\n\tfloat scalepercent = (float)scale/100.f;\n\tfloat scaleup = (float)width / (float)scale;\n\tdouble avg = (double)w->total_rssi/(double)w->count;\n\tfloat avg_percent = (avg - (float)min) / scalepercent;\n\tfloat curr_percent = ((float)w->last_rssi - (float)min) / scalepercent;\n\tint avg_marker = (avg - (float)min) * scaleup;\n\tint curr_marker = ((float)w->last_rssi - (float)min) * scaleup;\n\n\tunlock();\n\n\tfor(x = 0; x < width; x++) {\n\t\trgb_t step_color;\n\t\tif(wlanidx == selection) step_color = RGB(get_r(x/widthpercent),get_g(x/widthpercent),0);\n\t\telse step_color = RGB(get_r(x/widthpercent),get_r(x/widthpercent),get_r(x/widthpercent));\n\t\tconsole_setcolor(t, 0, step_color);\n\t\tif(x != curr_marker) console_setcolor(t, 1, RGB(0,0,0));\n\t\telse console_setcolor(t, 1, RGB(255,255,255));\n\t\tif(x == avg_marker) console_printchar(t, 'I', 0);\n\t\telse if (x == curr_marker) console_printchar(t, '|', 0);\n\t\telse if(x == 0) console_printchar(t, '[', 0);\n\t\telse if(x == width-1) console_printchar(t, ']', 0);\n\t\telse console_printchar(t, ' ', 0);\n\t}\n}\n\nstatic void dump_wlan(unsigned idx) {\n\tif(idx * LINES_PER_NET + 1 > dim.h || (selected && selection != idx)) return;\n\tdump_wlan_at(idx, selected ? 1 : idx * LINES_PER_NET);\n\tif(selected) dump_wlan_info(idx);\n}\n#endif\n\nstatic void calc_bms(unsigned wlanidx) {\n\tlong long now = getutime64();\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\tlock();\n\tlong long age_ms = (now - w->last_seen)/1000;\n\tunlock();\n\tage_ms=MIN(5000, age_ms)/100; /* seems we end up with a range 0-50 */\n\tint scale = max - min;\n\tfloat scalepercent = (float)scale/100.f;\n\tfloat curr_percent = ((float)w->last_rssi - (float)min) / scalepercent;\n\tif(age_ms < 15) set_bms(curr_percent);\n\telse bms = 0;\n}\n\nstatic void dump(void) {\n\tunsigned i;\n\t//dprintf(1, \"********************\\n\");\n\t//draw_bg();\n\tfor(i=0;i<wlan_count;i++)\n\t\tdump_wlan(i);\n\tconsole_refresh(t);\n}\n\nstatic void initconcol() {\n\tconsole_init(t);\n\tchar *p;\n\tint rw=1024,rh=768;\n\tif((p = getenv(\"RES\"))) {\n\t\tchar *q = strchr(p, 'x');\n\t\tif(q) {\n\t\t\tunsigned l = q-p;\n\t\t\tchar b[64];\n\t\t\tmemcpy(b,p,l);\n\t\t\tb[l] = 0;\n\t\t\trw=atoi(b);\n\t\t\tstrcpy(b,++q);\n\t\t\trh=atoi(b);\n\t\t}\n\t}\n\tpoint reso = {rw, rh};\n\tconsole_init_graphics(&co, reso, FONT);\n        console_getbounds(t, &dim.w, &dim.h);\n#ifdef NO_COLOR\n\t(*console_setcolor)(t, 0, RGB(255,255,255));\n\t(*console_setcolor)(t, 1, RGB(0,0,0));\n#endif\n\tdraw_bg();\n}\n\nstatic unsigned char blip[] = {0x52, 0x51, 0x51, 0x51, 0xC4, 0x4C, 0xF4, 0xF4, 0xF3,0xEF};\nstatic unsigned blip_frame(int idx) {\n\tidx = idx % (2*sizeof(blip));\n\tif(idx>=sizeof(blip)) idx=(2*sizeof(blip))-idx;\n\treturn blip[idx];\n}\n\nstatic volatile float volume = .5;\n\nstatic void generate_blip(unsigned char* data, size_t bufsize) {\n        int i;\n        for(i=0;i<bufsize;i++) {\n\t\tfloat f = blip_frame(i) * volume;\n\t\tdata[i] = f;\n\t}\n}\n\nstatic void volume_change(int dir) {\n\tvolume += dir * 0.1;\n\tif(volume < 0) volume = 0;\n\tif(volume > 1) volume = 1;\n}\n\nstatic void* blip_thread(void* arg) {\n\tstruct AudioCTX ao;\n\taudio_init(&ao);\n\tunsigned char buf[100], silence[1000];\n\tgenerate_blip(buf, sizeof(buf));\n\tmemset(silence, buf[99], sizeof silence);\n\tlong long t = getutime64();\n\tunsigned passed = 0;\n\tfloat myvol = volume;\n\twhile(selected) {\n\t\tif(myvol != volume) {\n\t\t\tgenerate_blip(buf, sizeof(buf));\n\t\t\tmyvol = volume;\n\t\t}\n\t\tif(bms && (getutime64() - t)/1000 >= bms) {\n\t\t\taudio_write(&ao, buf, sizeof buf);\n\t\t\tt = getutime64();\n\t\t}\n\t\taudio_write(&ao, silence, sizeof silence);\n\t\tusleep(1);\n\t}\n\taudio_close(&ao);\n\treturn 0;\n}\n\nstatic void* chanwalker_thread(void* arg) {\n\tchar* itf = arg;\n\tint channel = 1, delay = 800;\n\tlong long tm = 0;\n\tif(filebased) return 0;\n\twhile(!selected) {\n\t\tif((getutime64() - tm)/1000 >= delay) {\n\t\t\tint ret = set_channel(itf, channel = next_chan(channel));\n\t\t\tif(ret == -1) {\n\t\t\t\tif(console_getbackendtype(t) == cb_sdl)\n\t\t\t\t\tdprintf(2, \"oops couldnt switch to chan %d\\n\", channel);\n\t\t\t}\n\t\t\ttm = getutime64();\n\t\t}\n\t\tusleep(1000);\n\t}\n\treturn 0;\n}\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n/* set an interface up or down, depending on whether up is set.\n   if checkonly is true, no change will be made and the result\n   of the function can be interpreted as \"isdownup\".\n   if the interface was already up/down, 2 is returned.\n   if the interface was successfully upped/downed, 1 is returned.\n   0 is only returned if checkonly is set and the interface was not\n   in the queried state.\n   -1 is returned on error. */\nstatic int ifdownup(const char *dev, int up, int checkonly) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct ifreq ifr = {0};\n\tstrcpy(ifr.ifr_name, dev);\n\tif(ioctl(fd, SIOCGIFFLAGS, &ifr) <0) goto done;\n\tint isup = ifr.ifr_flags & IFF_UP;\n\tif((up && isup) || (!up && !isup)) ret = 2;\n\telse if (checkonly) ret = 0;\n\telse {\n\t\tif(up) ifr.ifr_flags |= IFF_UP;\n\t\telse   ifr.ifr_flags &= ~(IFF_UP);\n\t\tret = (ioctl(fd, SIOCSIFFLAGS, &ifr) >= 0);\n\t}\n\tdone:\n\tclose(fd);\n\treturn ret;\n}\n\n#include \"wireless-lite.h\"\nstatic int getiwmode(const char *dev) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct iwreq iwr = {0};\n\tstrcpy(iwr.ifr_name, dev);\n\tif(ioctl(fd, SIOCGIWMODE, &iwr) >=0) ret = iwr.u.mode;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int setiwmode(const char *dev, int mode) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct iwreq iwr = {.u.mode = mode};\n\tstrcpy(iwr.ifr_name, dev);\n\tret = ioctl(fd, SIOCSIWMODE, &iwr);\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void* capture_thread(void*arg) {\n\tpcap_t *foo = arg;\n\twhile(!stop) {\n\t\tint ret = process_frame(foo);\n\t\tlong long tmp = getutime64();\n\t\tif(ret >= 0) {\n\t\t\tlock();\n\t\t\twlans[ret].last_seen = tmp;\n\t\t\tunlock();\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(int argc,char**argv) {\n\tif(argc == 1) return usage(argv[0]);\n\tmin = 127;\n\tmax = -60;\n\toutfd = -1;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tpcap_t *foo;\n\tif(strchr(argv[1], '.') && access(argv[1], R_OK) == 0) {\n\t\tfilebased = 1;\n\t\tfoo = pcap_open_offline(argv[1], errbuf);\n\t} else {\n\t\tfoo = pcap_create(argv[1], errbuf);\n\t\toutfd= open(\"tmp.pcap\", O_WRONLY|O_CREAT|O_TRUNC,0660);\n\t\tif(outfd != -1)\n\t\t\twrite(outfd, \"\\xD4\\xC3\\xB2\\xA1\" \"\\x02\\x00\\x04\\x00\"\n\t\t\t             \"\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x00\"\n\t\t\t             \"\\x00\\x00\\x04\\x00\" \"\\x7F\\x00\\x00\\x00\", 24);\n\t}\n\tif(!foo) { dprintf(2, \"%s\\n\", errbuf); return 1; }\n\n\tint ret, wasdown, orgmode;\n\n\tif(filebased) goto skip;\n\n\tif((orgmode = getiwmode(argv[1])) != IW_MODE_MONITOR) {\n\t\tif((ret = ifdownup(argv[1], 0, 0)) == -1) {\n\t\t\tiferr:;\n\t\t\tperror(\"error setting up interface - maybe need to run as root.\");\n\t\t}\n\t\twasdown = (ret == 2);\n\t\tif(setiwmode(argv[1], IW_MODE_MONITOR) == -1) goto iferr;\n\t} else {\n\t\twasdown = (ifdownup(argv[1], 0, 1) == 2);\n\t}\n\tif(ifdownup(argv[1], 1, 0) == -1) goto iferr;\n\n\tif(pcap_activate(foo)) {\n\t\tdprintf(2, \"pcap_activate failed: %s\\n\", pcap_geterr(foo));\n\t\treturn 1;\n\t}\n\n\tskip:;\n\n\tinitconcol();\n\n\tsignal(SIGINT, sigh);\n\n\tint channel = 1;\n\tlong long tm = 0;\n\tpthread_t bt, wt, ct;\n\tpthread_create(&wt, 0, chanwalker_thread, argv[1]);\n\tpthread_create(&ct, 0, capture_thread, foo);\n\n\twhile(!stop) {\n\t\tlong long tmp = getutime64();\n\t\tif((tmp-tm) >= (1000000 / GUI_FPS)) {\n\t\t\ttm = tmp;\n\t\t\tdump();\n\t\t}\n\n\t\tif(selected) calc_bms(selection);\n\t\tint k = console_getkey_nb(t);\n\n\t\tswitch(k) {\n\t\t\tcase '+': case '0': volume_change(+1); break;\n\t\t\tcase '-': case '9': volume_change(-1); break;\n\t\t\tcase CK_CURSOR_DOWN: selection_move(1);break;\n\t\t\tcase CK_CURSOR_UP: selection_move(-1);break;\n\t\t\tcase CK_RETURN:\n\t\t\t\tselected = !selected;\n\t\t\t\tif(selected) {\n\t\t\t\t\tpthread_join(wt, 0);\n\t\t\t\t\tdraw_bg();\n\t\t\t\t\tpthread_create(&bt, 0, blip_thread, 0);\n\t\t\t\t\tif(!filebased) set_channel(argv[1], wlans[selection].channel);\n\t\t\t\t} else {\n\t\t\t\t\tpthread_create(&wt, 0, chanwalker_thread, argv[1]);\n\t\t\t\t\tpthread_join(bt, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CK_QUIT:\n\t\t\tcase CK_ESCAPE: stop = 1; break;\n\t\t}\n\t\tusleep(1000);\n\t}\n\n\tpcap_breakloop(foo); // this doesn't actually seem to work\n\n\tif(selected) {\n\t\tselected = 0;\n\t\tpthread_join(bt, 0);\n\t} else {\n\t\tselected = 1;\n\t\tpthread_join(wt, 0);\n\t}\n\n\t// since our capture_thread uses blocking reads in order to keep CPU usage\n\t// minimal, we need to get the current read cancelled - and if no packets\n\t// arrive, this can take a *long* time. since pcap_breakloop() doesn't actually\n\t// seem to work, the only way i found to break out of the read is to actually\n\t// bring down the interface - so this must happen before we join the thread\n\t// and close the pcap handle.\n\tif(!filebased) {\n\t\tif(wasdown || orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 0, 0);\n\t\tif(orgmode != IW_MODE_MONITOR) setiwmode(argv[1], orgmode);\n\t\tif(!wasdown && orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 1, 0);\n\t}\n\n\tpthread_join(ct, 0);\n\n\tpcap_close(foo);\n\tconsole_cleanup(t);\n\tif(outfd != -1) close(outfd);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n    MacGeiger WIFI AP detector\n    Copyright (C) 2014 rofl0r\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <pcap/pcap.h>\n#include <stdio.h>\n#include <signal.h>\n#include <assert.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n\n#define GUI_FPS 40\n\n//RcB: DEP \"audio-backend.c\"\n#include \"audio-backend.c\"\n\n#define LIBRARY_CODE\n#include \"channel-switch.c\"\n\n#ifndef MIN\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#endif\n\n#ifndef MAX\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#endif\n\n//RcB: LINK \"-lpcap\"\n//RcB: LINK \"-lpthread\"\n\n#include \"../concol/console.h\"\n#include \"../concol/console_keys.h\"\n#include \"../concol/fonts/allfonts.h\"\n\n#ifdef NO_COLOR\n#define console_setcolor(A, B, C) do {} while(0)\n#endif\n\nstatic int outfd;\n\nstatic int usage(const char *argv0) {\n\tdprintf(2, \"%s network-interface\\n\"\n\t\t   \"i.e.: %s wlan0\\n\", argv0, argv0\n\t\t);\n\treturn 1;\n}\n\nstatic struct wlaninfo {\n\tchar essid[32];\n\tunsigned char mac[6];\n\tunsigned char channel;\n\tlong long total_rssi;\n\tlong long last_seen;\n\tunsigned long count;\n\tint last_rssi;\n} wlans[128];\nstatic unsigned wlan_count;\n\nstatic pthread_mutex_t wlan_lock = PTHREAD_MUTEX_INITIALIZER;\n#define lock() pthread_mutex_lock(&wlan_lock)\n#define unlock() pthread_mutex_unlock(&wlan_lock)\n\nstatic signed char min, max;\nstatic unsigned char selection, selected;\nstatic Console co, *t = &co;\n\nstatic int get_wlan_by_essid(char* essid) {\n\tunsigned i;\n\tfor(i=0;i<wlan_count;i++)\n\t\tif(!strcmp(essid, wlans[i].essid)) return i;\n\treturn -1;\n}\n\nstatic int get_wlan_by_mac(unsigned char mac[6]) {\n\tunsigned i;\n\tfor(i=0;i<wlan_count;i++)\n\t\tif(!memcmp(mac, wlans[i].mac, 6)) return i;\n\treturn -1;\n}\n\nstatic int get_new_wlan(void) {\n\tif(wlan_count+1<sizeof(wlans)/sizeof(wlans[0]))\n\t\treturn wlan_count++;\n\treturn -1;\n}\n\nstatic int set_rssi(struct wlaninfo *w) {\n\tint i = -1;\n//\tif(w->essid[0]) i = get_wlan_by_essid(w->essid);\n\tlock();\n\tif(i == -1) i = get_wlan_by_mac(w->mac);\n\tif(i == -1) i = get_new_wlan();\n\tif(i != -1) {\n\t\tstruct wlaninfo *d = &wlans[i];\n\t\tif(w->essid[0]) strcpy(d->essid, w->essid);\n\t\tmemcpy(d->mac, w->mac, 6);\n\t\td->total_rssi += w->last_rssi;\n\t\td->count++;\n\t\td->last_rssi = w->last_rssi;\n\t\td->channel = w->channel;\n\t}\n\tunlock();\n\treturn i;\n}\n\nvolatile int stop;\nvoid sigh(int x) {\n\tstop = 1;\n}\n\nstruct ieee80211_radiotap_header {\n\tuint8_t it_version;\n\tuint8_t it_pad;\n\tuint16_t it_len;\n\tuint32_t it_present;\n};\n\nenum ieee80211_radiotap_type {\n\tIEEE80211_RADIOTAP_TSFT = 0,\n\tIEEE80211_RADIOTAP_FLAGS = 1,\n\tIEEE80211_RADIOTAP_RATE = 2,\n\tIEEE80211_RADIOTAP_CHANNEL = 3,\n\tIEEE80211_RADIOTAP_FHSS = 4,\n\tIEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,\n\tIEEE80211_RADIOTAP_DBM_ANTNOISE = 6,\n\tIEEE80211_RADIOTAP_LOCK_QUALITY = 7,\n\tIEEE80211_RADIOTAP_TX_ATTENUATION = 8,\n\tIEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,\n\tIEEE80211_RADIOTAP_DBM_TX_POWER = 10,\n\tIEEE80211_RADIOTAP_ANTENNA = 11,\n\tIEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,\n\tIEEE80211_RADIOTAP_DB_ANTNOISE = 13,\n\tIEEE80211_RADIOTAP_RX_FLAGS = 14,\n\tIEEE80211_RADIOTAP_TX_FLAGS = 15,\n\tIEEE80211_RADIOTAP_RTS_RETRIES = 16,\n\tIEEE80211_RADIOTAP_DATA_RETRIES = 17,\n\tIEEE80211_RADIOTAP_XCHANNEL = 18,\n\tIEEE80211_RADIOTAP_MCS = 19,\n\tIEEE80211_RADIOTAP_AMPDU_STATUS = 20,\n\tIEEE80211_RADIOTAP_VHT = 21,\n\tIEEE80211_RADIOTAP_TIMESTAMP = 22,\n\tIEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,\n\tIEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,\n\tIEEE80211_RADIOTAP_EXT = 31\n};\n\nstatic const unsigned char ieee80211_radiotap_type_size[] = {\n\t[IEEE80211_RADIOTAP_TSFT] = 8,\n\t[IEEE80211_RADIOTAP_FLAGS] = 1,\n\t[IEEE80211_RADIOTAP_RATE] = 1,\n\t[IEEE80211_RADIOTAP_CHANNEL] = 2*2,\n\t[IEEE80211_RADIOTAP_FHSS] = 2,\n\t[IEEE80211_RADIOTAP_DBM_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DBM_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_LOCK_QUALITY] = 2,\n\t[IEEE80211_RADIOTAP_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DB_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DBM_TX_POWER] = 1,\n\t[IEEE80211_RADIOTAP_ANTENNA] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_RX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_TX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_RTS_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_DATA_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_MCS] = 1+1+1,\n\t[IEEE80211_RADIOTAP_AMPDU_STATUS] = 4+2+1+1,\n\t[IEEE80211_RADIOTAP_VHT] = 12,\n\t[IEEE80211_RADIOTAP_TIMESTAMP] = 12,\n};\n\nstatic const unsigned char ieee80211_radiotap_type_align[] = {\n\t[IEEE80211_RADIOTAP_TSFT] = 8,\n\t[IEEE80211_RADIOTAP_FLAGS] = 1,\n\t[IEEE80211_RADIOTAP_RATE] = 1,\n\t[IEEE80211_RADIOTAP_CHANNEL] = 2,\n\t[IEEE80211_RADIOTAP_FHSS] = 2,\n\t[IEEE80211_RADIOTAP_DBM_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DBM_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_LOCK_QUALITY] = 2,\n\t[IEEE80211_RADIOTAP_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DB_TX_ATTENUATION] = 2,\n\t[IEEE80211_RADIOTAP_DBM_TX_POWER] = 1,\n\t[IEEE80211_RADIOTAP_ANTENNA] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTSIGNAL] = 1,\n\t[IEEE80211_RADIOTAP_DB_ANTNOISE] = 1,\n\t[IEEE80211_RADIOTAP_RX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_TX_FLAGS] = 2,\n\t[IEEE80211_RADIOTAP_RTS_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_DATA_RETRIES] = 1,\n\t[IEEE80211_RADIOTAP_MCS] = 1,\n\t[IEEE80211_RADIOTAP_AMPDU_STATUS] = 4,\n\t[IEEE80211_RADIOTAP_VHT] = 2,\n\t[IEEE80211_RADIOTAP_TIMESTAMP] = 8,\n};\n\nstatic unsigned get_flag_off(unsigned flags, unsigned which, unsigned start_off) {\n\tunsigned i,c=start_off;\n\tfor(i=0;i<which;i++) if(flags & (1U << i)) {\n\t\tc+= c & (ieee80211_radiotap_type_align[i]-1);\n\t\tc+= ieee80211_radiotap_type_size[i];\n\t}\n\treturn c;\n}\n\nstatic unsigned get_dbm_off(unsigned flags, unsigned start_off) {\n\treturn get_flag_off(flags, IEEE80211_RADIOTAP_DBM_ANTSIGNAL, start_off);\n}\n\nstatic unsigned get_chan_off(unsigned flags, unsigned start_off) {\n\treturn get_flag_off(flags, IEEE80211_RADIOTAP_CHANNEL, start_off);\n}\n\nstatic unsigned channel_from_freq(unsigned freq) {\n\treturn freq==2484?14:(freq-2407)/5;\n}\n\nstruct beaconframe {\n\tuint16_t framecontrol;\n\tuint16_t duration;\n\tunsigned char receiver[6];\n\tunsigned char source[6];\n\tunsigned char bssid[6];\n\tuint16_t sequence_no;\n};\n\nstatic unsigned char* find_tag(unsigned const char *tagdata, unsigned tag, unsigned bytes_left) {\n\twhile(bytes_left) {\n\t\tif(*tagdata == tag) return (unsigned char*)tagdata;\n\t\tunsigned tagsize = tagdata[1];\n\t\ttagdata+=2+tagsize;\n\t\tif(bytes_left < 2+tagsize) return 0;\n\t\tbytes_left-=2+tagsize;\n\t}\n\treturn 0;\n}\n\nstatic long long timeval2utime(struct timeval*t) {\n\treturn (t->tv_sec * 1000LL * 1000LL) + t->tv_usec;\n}\n\nstatic long long getutime64(void) {\n\tstruct timeval t;\n\tgettimeofday(&t, NULL);\n\treturn timeval2utime(&t);\n}\n\n\nstatic int filebased;\n\nstatic const unsigned char* pcap_next_wrapper(pcap_t *foo, struct pcap_pkthdr *h_out) {\n\tif(!filebased) {\n\t\tconst unsigned char* ret = 0;\n\t\tstruct pcap_pkthdr *hdr_temp;\n\t\tint err = pcap_next_ex(foo, &hdr_temp, &ret);\n\t\tif(err == 1) {\n\t\t\t*h_out = *hdr_temp;\n\t\t} else ret = 0;\n\t\tif(ret && outfd != -1){\n\t\t\tstruct pcap_file_pkthdr {\n\t\t\t\tunsigned sec_epoch;\n\t\t\t\tunsigned ms_sec;\n\t\t\t\tunsigned caplen;\n\t\t\t\tunsigned len;\n\t\t\t} hdr_out = {\n\t\t\t\t.sec_epoch = h_out->ts.tv_sec,\n\t\t\t\t.ms_sec = h_out->ts.tv_usec,\n\t\t\t\t.caplen = h_out->caplen,\n\t\t\t\t.len = h_out->len,\n\t\t\t};\n\t\t\twrite(outfd, &hdr_out, sizeof hdr_out);\n\t\t\twrite(outfd, ret, h_out->len);\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long long pcap_file_start_time, start_time;\n\tstatic unsigned char buf[2][2048];\n\tstatic struct pcap_pkthdr h[2];\n\tstatic int actbuf;\n\tconst unsigned char* ret;\n\tif(start_time == 0 || getutime64() - start_time >= timeval2utime(&h[!actbuf].ts) - pcap_file_start_time) {\n\t\tret = pcap_next(foo, h_out);\n\t\tif(ret) {\n\t\t\th[actbuf] = *h_out;\n\t\t\tassert(h[actbuf].len <= sizeof buf[actbuf]);\n\t\t\tmemcpy(buf[actbuf], ret, h[actbuf].len);\n\t\t\tactbuf = !actbuf;\n\t\t}\n\t\tif(!start_time) {\n\t\t\tstart_time = getutime64();\n\t\t\tassert(ret);\n\t\t\tpcap_file_start_time = timeval2utime(&h_out->ts);\n\t\t\treturn 0;\n\t\t}\n\t\tif(ret) {\n\t\t\t*h_out = h[actbuf];\n\t\t\treturn buf[actbuf];\n\t\t} else return 0;\n\t} else\n\t\treturn 0;\n}\n\nstatic inline int myisascii(int x) {\n\treturn x >= ' ' && x < 127;\n}\n\nstatic void dump_packet(const unsigned char* data, size_t len) {\n\tstatic const char atab[] = \"0123456789abcdef\";\n\tchar hex[24*2+1], ascii[24+1];\n\tunsigned h = 0, a = 0;\n\tint fill = ' ';\n\n\twhile(len) {\n\t\tlen--;\n\t\thex[h++] = atab[*data >> 4];\n\t\thex[h++] = atab[*data & 0xf];\n\t\tascii[a++] = myisascii(*data) ? *data : '.';\n\t\tif(a == 24) {\n\tdump:\n\t\t\thex[h] = 0;\n\t\t\tascii[a] = 0;\n\t\t\tprintf(\"%s\\t%s\\n\", hex, ascii);\n\n\t\t\tif(fill == '_') return; /* jump from filler */\n\n\t\t\ta = 0;\n\t\t\th = 0;\n\t\t}\n\t\tdata++;\n\t}\n\tif(a) {\n\tfiller:\n\t\twhile(a<24) {\n\t\t\thex[h++] = fill;\n\t\t\thex[h++] = fill;\n\t\t\tascii[a++] = fill;\n\t\t}\n\t\tgoto dump;\n\t}\n\ta = 0;\n\tfill = '_';\n\tgoto filler;\n}\n\nvoid setminmax(int val) {\n\tmin = MIN(min, val);\n\tmax = MAX(max, val);\n\tchar mmbuf[128];\n\tsnprintf(mmbuf, sizeof mmbuf, \"min: %d, max: %d\", min, max);\n\tconsole_settitle(t, mmbuf);\n}\n\nstatic int process_frame(pcap_t *foo) {\n\tstruct pcap_pkthdr h;\n\tconst unsigned char* data = pcap_next_wrapper(foo, &h);\n\tif(data) {\n\t\tif(console_getbackendtype(t) == cb_sdl && getenv(\"DEBUG\")) dump_packet(data, h.len);\n\t\tstruct ieee80211_radiotap_header *rh = (void*) data;\n\t\t//size_t next_chunk = sizeof(*rh);\n\t\tuint32_t flags = rh->it_present, flags_copy = flags;\n\t\tunsigned ext_bytes = 0;\n\t\twhile(flags_copy & (1U << IEEE80211_RADIOTAP_EXT)) {\n\t\t\tmemcpy(&flags_copy, data+sizeof(*rh)+ext_bytes, 4);\n\t\t\text_bytes += 4;\n\t\t}\n\t\tunsigned rtap_data = sizeof(*rh) + ext_bytes;\n\n\t\tstruct wlaninfo temp = {0};\n\t\t{\n\t\t\tif(!(flags & (1U << IEEE80211_RADIOTAP_DBM_ANTSIGNAL))) return -1;\n\t\t\tunsigned dbmoff = get_dbm_off(flags, rtap_data);\n\t\t\ttemp.last_rssi = ((signed char*)data)[dbmoff];\n\t\t}\n\t\t{\n//\t\t\tif(!(flags & (1U << IEEE80211_RADIOTAP_CHANNEL))) return -1;\n\t\t\tshort freq;\n\t\t\tunsigned chanoff = get_chan_off(flags, rtap_data);\n\t\t\tmemcpy(&freq, data+ chanoff, 2);\n\t\t\ttemp.channel = channel_from_freq(freq);\n\t\t}\n\t\tuint16_t framectl;\n\t\tmemcpy(&framectl, data+rh->it_len, 2);\n\t\tstruct beaconframe* beacon;\n\t\tunsigned const char* tagdata, *curr_tag;\n\t\tunsigned pos;\n\t\tswitch(htons(framectl)) {\n\t\t\t/* IEEE 802.11 packet type */\n\t\t\tcase 0xd400: /*ack*/\n\t\t\t\t//memcpy(&temp.mac,data+rh->it_len+4, 6);\n\t\t\t\t//set_rssi(&temp, dbm);\n\t\t\t\t//break;\n\t\t\t\treturn -1;\n\t\t\tcase 0x8000: /*beacon */\n\t\t\t\tbeacon = (void*)(data+rh->it_len);\n\t\t\t\tmemcpy(&temp.mac,beacon->source,6);\n\t\t\t\tpos = rh->it_len+sizeof(*beacon)+12;\n\t\t\t\ttagdata = data+pos;\n\t\t\t\tcurr_tag = find_tag(tagdata, 0, h.len-pos); /* find essid tag */\n\t\t\t\tif(curr_tag) {\n\t\t\t\t\tmemcpy(temp.essid, curr_tag+2, curr_tag[1]);\n\t\t\t\t\ttemp.essid[curr_tag[1]] = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* dubious beacon without essid */\n\t\t\t\t\tdprintf(2, \"XXX\\n\");\n\t\t\t\t\tif(console_getbackendtype(t) == cb_sdl && getenv(\"DEBUG\")) dump_packet(data, h.len);\n\t\t\t\t}\n\t\t\t\tcurr_tag = find_tag(tagdata, 3, h.len-pos); /* find channel nr tag */\n\t\t\t\tif(curr_tag) {\n\t\t\t\t\tassert(curr_tag[1] == 1);\n\t\t\t\t\ttemp.channel = curr_tag[2];\n\t\t\t\t}\n\t\t\t\tsetminmax(temp.last_rssi);\n\n\t\t\t\treturn set_rssi(&temp);\n\n\t\t\t\tbreak;\n\t\t\tcase 0x8842: /*QOS */\n\t\t\tcase 0x4000: /* probe request */\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\t//while(htonl(*(flags++)) & (1U << IEEE80211_RADIOTAP_EXT)) next_chunk+=4;\n\t\t//dprintf(2, \"got data\\n\");\n\t\t//dump();\n\t} else usleep(1);\n\treturn -1;\n}\n\n#if 0\nstatic int next_chan(int chan) {\n\tif(++chan > 11) chan = 1;\n\treturn chan;\n}\n#elif 1\nstatic int next_chan(int chan) {\n\tstatic char chanlist[]={1,5,9,13,2,6,10,14,3,7,11,4,8,12};\n\tint i = 0;\n\tfor(i = 0; i < sizeof chanlist && chanlist[i] != chan; i++);\n\tif(i >=13) return chanlist[0];\n\treturn chanlist[++i];\n}\n#else\nstatic int next_chan(int chan) {\n\tswitch (chan) {\n\t\tcase 1: case 2: case 3: case 4: case 5:\n\t\t\treturn 6;\n\t\tcase 6: case 7: case 8: case 9: case 10:\n\t\t\treturn 11;\n\t\tcase 11: case 12: case 13:\n\t\t\t/* uncomment next line if you leave in a country using chan 14 */\n\t\t\t//return 14;\n\t\tcase 14:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn 0;\n\t}\n}\n#endif\n\nstatic struct {int w, h;} dim;\n\n#define BGCOL RGB(33, 66, 133)\nstatic void draw_bg() {\n\tunsigned x, y;\n\tconsole_setcolor(t, 0, BGCOL);\n\tfor(y=0; y < dim.h; y++) {\n\t\tconsole_goto(t, 0, y);\n\t\tfor(x = 0; x < dim.w; x++)\n\t\t\tconsole_printchar(t, ' ', 0);\n\t}\n}\n\n#if 0\nstatic void dump_wlan(unsigned idx) {\n\tstruct wlaninfo *w = &wlans[idx];\n\tdprintf(1, \"%.2d %-24s %02x:%02x:%02x:%02x:%02x:%02x %.2f - %d\\n\", w->channel, w->essid,\n\t            w->mac[0], w->mac[1],\n\t            w->mac[2], w->mac[3], w->mac[4], w->mac[5],\n\t            (double)w->total_rssi/(double)w->count, w->last_rssi);\n}\n#else\nstatic int get_r(unsigned percent) {\n\treturn (50 - percent/2) * 5;\n}\nstatic int get_g(unsigned percent) {\n\treturn percent/2 * 5;\n}\nstatic int get_a(unsigned age) {\n\treturn 5+((50 - age)*5);\n}\n#define LINES_PER_NET 1\nstatic void selection_move(int dir) {\n\tif((int)selection+dir < 0) dir=0;\n\tif((int)selection+dir >= wlan_count ||\n\t   ((int)selection+dir)*LINES_PER_NET+1 >= dim.h) dir=0;\n\tselection += dir;\n}\n\nstatic volatile unsigned bms;\nstatic void set_bms(float percent) {\n\tfloat max = 800, min=50;\n\tfloat range=max-min;\n\tfloat rpercent = range/100.f;\n\tbms = min + (100 - percent) * rpercent;\n}\n\nchar *mac2str(unsigned char mac[static 6], char buf[static 18]) {\n\tunsigned m, x;\n\tchar hextab[16] = \"0123456789abcdef\";\n\tfor(m = 0, x=0 ; m<6; m++, x+=3) {\n\t\tbuf[x] = hextab[mac[m]>>4];\n\t\tbuf[x+1] = hextab[mac[m]&15];\n\t\tbuf[x+2] = ':';\n\t}\n\tbuf[17]=0;\n\treturn buf;\n}\n\n#define ESSID_PRINT_START 1\n#define ESSID_PRINT_END 32+ESSID_PRINT_START\n#define ESSID_PRINT_LEN (ESSID_PRINT_END - ESSID_PRINT_START)\n\nstatic void dump_wlan_info(unsigned wlanidx) {\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\tlock();\n\tunsigned line = 3;\n\tconsole_setcolor(t, 0, BGCOL);\n\tconsole_setcolor(t, 1, RGB(0xff,0xff,0xff));\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\tchar macbuf[18];\n\tconsole_printf(t, \"MAC %s\", mac2str(w->mac, macbuf));\n\n\tconsole_goto(t, ESSID_PRINT_END +1+25, line);\n\tconsole_printf(t, \"CHAN %d\", (int) w->channel);\n\n\tline++;\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\tconsole_printf(t, \"AVG %.2f dBm\", (double)w->total_rssi/(double)w->count);\n\n\tconsole_goto(t, ESSID_PRINT_END +1+25, line);\n\tconsole_printf(t, \"CURR %d dBm\", w->last_rssi);\n\tunlock();\n}\n\nstatic void sanitize_string(char *s, char *new) {\n\tsize_t i,j, l = strlen(s), ls=l;\n\tfor(i=0,j=0;i<ls;i++) {\n\t\tif(s[i] < ' ' || s[i] > 127) {\n\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i] & 0xff);\n\t\t\tj  += 3;\n\t\t} else new[j] = s[i];\n\t\tj++;\n\t}\n\tnew[j] = 0;\n}\n\n\nstatic void dump_wlan_at(unsigned wlanidx, unsigned line) {\n\tconsole_goto(t, 0, line);\n\tconsole_setcolor(t, 0, BGCOL);\n\n\tconsole_setcolor(t, 1, RGB(255,255,0));\n\tif(wlanidx == selection) {\n\t\tconsole_printchar(t, '>', 0);\n\t} else {\n\t\tconsole_printchar(t, ' ', 0);\n\t}\n\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\n\tlock();\n\n\tlong long now = getutime64();\n\tlong long age_ms = (now - w->last_seen)/1000;\n\tage_ms=MIN(5000, age_ms)/100; /* seems we end up with a range 0-50 */\n\tunsigned a = get_a(age_ms);\n\n\tconsole_setcolor(t, 1, RGB(a,a,a));\n\tconsole_goto(t, ESSID_PRINT_START, line);\n\n\tchar macbuf[18];\n\n\tif(*w->essid) {\n\t\tchar essid_san[32*4+1];\n\t\tsanitize_string(w->essid, essid_san);\n\t\tconsole_printf(t, \"%*s\", ESSID_PRINT_LEN, essid_san);\n\t} else\n\t\tconsole_printf(t, \"<hidden> %*s\", ESSID_PRINT_LEN-9, mac2str(w->mac, macbuf));\n\n\tconsole_goto(t, ESSID_PRINT_END +1, line);\n\n\tint scale = max - min;\n\tint width = dim.w - (ESSID_PRINT_LEN+2);\n\tunsigned x;\n\tfloat widthpercent = (float)width/100.f;\n\tfloat scalepercent = (float)scale/100.f;\n\tfloat scaleup = (float)width / (float)scale;\n\tdouble avg = (double)w->total_rssi/(double)w->count;\n\tfloat avg_percent = (avg - (float)min) / scalepercent;\n\tfloat curr_percent = ((float)w->last_rssi - (float)min) / scalepercent;\n\tint avg_marker = (avg - (float)min) * scaleup;\n\tint curr_marker = ((float)w->last_rssi - (float)min) * scaleup;\n\n\tunlock();\n\n\tfor(x = 0; x < width; x++) {\n\t\trgb_t step_color;\n\t\tif(wlanidx == selection) step_color = RGB(get_r(x/widthpercent),get_g(x/widthpercent),0);\n\t\telse step_color = RGB(get_r(x/widthpercent),get_r(x/widthpercent),get_r(x/widthpercent));\n\t\tconsole_setcolor(t, 0, step_color);\n\t\tif(x != curr_marker) console_setcolor(t, 1, RGB(0,0,0));\n\t\telse console_setcolor(t, 1, RGB(255,255,255));\n\t\tif(x == avg_marker) console_printchar(t, 'I', 0);\n\t\telse if (x == curr_marker) console_printchar(t, '|', 0);\n\t\telse if(x == 0) console_printchar(t, '[', 0);\n\t\telse if(x == width-1) console_printchar(t, ']', 0);\n\t\telse console_printchar(t, ' ', 0);\n\t}\n}\n\nstatic void dump_wlan(unsigned idx) {\n\tif(idx * LINES_PER_NET + 1 > dim.h || (selected && selection != idx)) return;\n\tdump_wlan_at(idx, selected ? 1 : idx * LINES_PER_NET);\n\tif(selected) dump_wlan_info(idx);\n}\n#endif\n\nstatic void calc_bms(unsigned wlanidx) {\n\tlong long now = getutime64();\n\tstruct wlaninfo *w = &wlans[wlanidx];\n\tlock();\n\tlong long age_ms = (now - w->last_seen)/1000;\n\tunlock();\n\tage_ms=MIN(5000, age_ms)/100; /* seems we end up with a range 0-50 */\n\tint scale = max - min;\n\tfloat scalepercent = (float)scale/100.f;\n\tfloat curr_percent = ((float)w->last_rssi - (float)min) / scalepercent;\n\tif(age_ms < 15) set_bms(curr_percent);\n\telse bms = 0;\n}\n\nstatic void dump(void) {\n\tunsigned i;\n\t//dprintf(1, \"********************\\n\");\n\t//draw_bg();\n\tfor(i=0;i<wlan_count;i++)\n\t\tdump_wlan(i);\n\tconsole_refresh(t);\n}\n\nstatic void initconcol() {\n\tconsole_init(t);\n\tchar *p;\n\tint rw=1024,rh=768;\n\tif((p = getenv(\"RES\"))) {\n\t\tchar *q = strchr(p, 'x');\n\t\tif(q) {\n\t\t\tunsigned l = q-p;\n\t\t\tchar b[64];\n\t\t\tmemcpy(b,p,l);\n\t\t\tb[l] = 0;\n\t\t\trw=atoi(b);\n\t\t\tstrcpy(b,++q);\n\t\t\trh=atoi(b);\n\t\t}\n\t}\n\tpoint reso = {rw, rh};\n\tconsole_init_graphics(&co, reso, FONT);\n        console_getbounds(t, &dim.w, &dim.h);\n#ifdef NO_COLOR\n\t(*console_setcolor)(t, 0, RGB(255,255,255));\n\t(*console_setcolor)(t, 1, RGB(0,0,0));\n#endif\n\tdraw_bg();\n}\n\nstatic unsigned char blip[] = {0x52, 0x51, 0x51, 0x51, 0xC4, 0x4C, 0xF4, 0xF4, 0xF3,0xEF};\nstatic unsigned blip_frame(int idx) {\n\tidx = idx % (2*sizeof(blip));\n\tif(idx>=sizeof(blip)) idx=(2*sizeof(blip))-idx;\n\treturn blip[idx];\n}\n\nstatic volatile float volume = .5;\n\nstatic void generate_blip(unsigned char* data, size_t bufsize) {\n        int i;\n        for(i=0;i<bufsize;i++) {\n\t\tfloat f = blip_frame(i) * volume;\n\t\tdata[i] = f;\n\t}\n}\n\nstatic void volume_change(int dir) {\n\tvolume += dir * 0.1;\n\tif(volume < 0) volume = 0;\n\tif(volume > 1) volume = 1;\n}\n\nstatic void* blip_thread(void* arg) {\n\tstruct AudioCTX ao;\n\taudio_init(&ao);\n\tunsigned char buf[100], silence[1000];\n\tgenerate_blip(buf, sizeof(buf));\n\tmemset(silence, buf[99], sizeof silence);\n\tlong long t = getutime64();\n\tunsigned passed = 0;\n\tfloat myvol = volume;\n\twhile(selected) {\n\t\tif(myvol != volume) {\n\t\t\tgenerate_blip(buf, sizeof(buf));\n\t\t\tmyvol = volume;\n\t\t}\n\t\tif(bms && (getutime64() - t)/1000 >= bms) {\n\t\t\taudio_write(&ao, buf, sizeof buf);\n\t\t\tt = getutime64();\n\t\t}\n\t\taudio_write(&ao, silence, sizeof silence);\n\t\tusleep(1);\n\t}\n\taudio_close(&ao);\n\treturn 0;\n}\n\nstatic void* chanwalker_thread(void* arg) {\n\tchar* itf = arg;\n\tint channel = 1, delay = 800;\n\tlong long tm = 0;\n\tif(filebased) return 0;\n\twhile(!selected) {\n\t\tif((getutime64() - tm)/1000 >= delay) {\n\t\t\tint ret = set_channel(itf, channel = next_chan(channel));\n\t\t\tif(ret == -1) {\n\t\t\t\tif(console_getbackendtype(t) == cb_sdl)\n\t\t\t\t\tdprintf(2, \"oops couldnt switch to chan %d\\n\", channel);\n\t\t\t}\n\t\t\ttm = getutime64();\n\t\t}\n\t\tusleep(1000);\n\t}\n\treturn 0;\n}\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n/* set an interface up or down, depending on whether up is set.\n   if checkonly is true, no change will be made and the result\n   of the function can be interpreted as \"isdownup\".\n   if the interface was already up/down, 2 is returned.\n   if the interface was successfully upped/downed, 1 is returned.\n   0 is only returned if checkonly is set and the interface was not\n   in the queried state.\n   -1 is returned on error. */\nstatic int ifdownup(const char *dev, int up, int checkonly) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct ifreq ifr = {0};\n\tstrcpy(ifr.ifr_name, dev);\n\tif(ioctl(fd, SIOCGIFFLAGS, &ifr) <0) goto done;\n\tint isup = ifr.ifr_flags & IFF_UP;\n\tif((up && isup) || (!up && !isup)) ret = 2;\n\telse if (checkonly) ret = 0;\n\telse {\n\t\tif(up) ifr.ifr_flags |= IFF_UP;\n\t\telse   ifr.ifr_flags &= ~(IFF_UP);\n\t\tret = (ioctl(fd, SIOCSIFFLAGS, &ifr) >= 0);\n\t}\n\tdone:\n\tclose(fd);\n\treturn ret;\n}\n\n#include \"wireless-lite.h\"\nstatic int getiwmode(const char *dev) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct iwreq iwr = {0};\n\tstrcpy(iwr.ifr_name, dev);\n\tif(ioctl(fd, SIOCGIWMODE, &iwr) >=0) ret = iwr.u.mode;\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int setiwmode(const char *dev, int mode) {\n\tint fd, ret = -1;\n\tif((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;\n\tstruct iwreq iwr = {.u.mode = mode};\n\tstrcpy(iwr.ifr_name, dev);\n\tret = ioctl(fd, SIOCSIWMODE, &iwr);\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void* capture_thread(void*arg) {\n\tpcap_t *foo = arg;\n\twhile(!stop) {\n\t\tint ret = process_frame(foo);\n\t\tlong long tmp = getutime64();\n\t\tif(ret >= 0) {\n\t\t\tlock();\n\t\t\twlans[ret].last_seen = tmp;\n\t\t\tunlock();\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(int argc,char**argv) {\n\tif(argc == 1) return usage(argv[0]);\n\tmin = 127;\n\tmax = -60;\n\toutfd = -1;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tpcap_t *foo;\n\tif(strchr(argv[1], '.') && access(argv[1], R_OK) == 0) {\n\t\tfilebased = 1;\n\t\tfoo = pcap_open_offline(argv[1], errbuf);\n\t} else {\n\t\tfoo = pcap_create(argv[1], errbuf);\n\t\toutfd= open(\"tmp.pcap\", O_WRONLY|O_CREAT|O_TRUNC,0660);\n\t\tif(outfd != -1)\n\t\t\twrite(outfd, \"\\xD4\\xC3\\xB2\\xA1\" \"\\x02\\x00\\x04\\x00\"\n\t\t\t             \"\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x00\"\n\t\t\t             \"\\x00\\x00\\x04\\x00\" \"\\x7F\\x00\\x00\\x00\", 24);\n\t}\n\tif(!foo) { dprintf(2, \"%s\\n\", errbuf); return 1; }\n\n\tint ret, wasdown, orgmode;\n\n\tif(filebased) goto skip;\n\n\tif((orgmode = getiwmode(argv[1])) != IW_MODE_MONITOR) {\n\t\tif((ret = ifdownup(argv[1], 0, 0)) == -1) {\n\t\t\tiferr:;\n\t\t\tperror(\"error setting up interface - maybe need to run as root.\");\n\t\t}\n\t\twasdown = (ret == 2);\n\t\tif(setiwmode(argv[1], IW_MODE_MONITOR) == -1) goto iferr;\n\t} else {\n\t\twasdown = (ifdownup(argv[1], 0, 1) == 2);\n\t}\n\tif(ifdownup(argv[1], 1, 0) == -1) goto iferr;\n\n\tif(pcap_activate(foo)) {\n\t\tdprintf(2, \"pcap_activate failed: %s\\n\", pcap_geterr(foo));\n\t\treturn 1;\n\t}\n\n\tskip:;\n\n\tinitconcol();\n\n\tsignal(SIGINT, sigh);\n\n\tint channel = 1;\n\tlong long tm = 0;\n\tpthread_t bt, wt, ct;\n\tpthread_create(&wt, 0, chanwalker_thread, argv[1]);\n\tpthread_create(&ct, 0, capture_thread, foo);\n\n\twhile(!stop) {\n\t\tlong long tmp = getutime64();\n\t\tif((tmp-tm) >= (1000000 / GUI_FPS)) {\n\t\t\ttm = tmp;\n\t\t\tdump();\n\t\t}\n\n\t\tif(selected) calc_bms(selection);\n\t\tint k = console_getkey_nb(t);\n\n\t\tswitch(k) {\n\t\t\tcase '+': case '0': volume_change(+1); break;\n\t\t\tcase '-': case '9': volume_change(-1); break;\n\t\t\tcase CK_CURSOR_DOWN: selection_move(1);break;\n\t\t\tcase CK_CURSOR_UP: selection_move(-1);break;\n\t\t\tcase CK_RETURN:\n\t\t\t\tselected = !selected;\n\t\t\t\tif(selected) {\n\t\t\t\t\tpthread_join(wt, 0);\n\t\t\t\t\tdraw_bg();\n\t\t\t\t\tpthread_create(&bt, 0, blip_thread, 0);\n\t\t\t\t\tif(!filebased) set_channel(argv[1], wlans[selection].channel);\n\t\t\t\t} else {\n\t\t\t\t\tpthread_create(&wt, 0, chanwalker_thread, argv[1]);\n\t\t\t\t\tpthread_join(bt, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CK_QUIT:\n\t\t\tcase CK_ESCAPE: stop = 1; break;\n\t\t}\n\t\tusleep(1000);\n\t}\n\n\tpcap_breakloop(foo); // this doesn't actually seem to work\n\n\tif(selected) {\n\t\tselected = 0;\n\t\tpthread_join(bt, 0);\n\t} else {\n\t\tselected = 1;\n\t\tpthread_join(wt, 0);\n\t}\n\n\t// since our capture_thread uses blocking reads in order to keep CPU usage\n\t// minimal, we need to get the current read cancelled - and if no packets\n\t// arrive, this can take a *long* time. since pcap_breakloop() doesn't actually\n\t// seem to work, the only way i found to break out of the read is to actually\n\t// bring down the interface - so this must happen before we join the thread\n\t// and close the pcap handle.\n\tif(!filebased) {\n\t\tif(wasdown || orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 0, 0);\n\t\tif(orgmode != IW_MODE_MONITOR) setiwmode(argv[1], orgmode);\n\t\tif(!wasdown && orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 1, 0);\n\t}\n\n\tpthread_join(ct, 0);\n\n\tpcap_close(foo);\n\tconsole_cleanup(t);\n\tif(outfd != -1) close(outfd);\n\treturn 0;\n}\n"], "filenames": ["macgeiger.c"], "buggy_code_start_loc": [565], "buggy_code_end_loc": [594], "fixing_code_start_loc": [566], "fixing_code_end_loc": [609], "type": "CWE-74", "message": "A vulnerability classified as problematic has been found in rofl0r MacGeiger. Affected is the function dump_wlan_at of the file macgeiger.c of the component ESSID Handler. The manipulation leads to injection. Access to the local network is required for this attack to succeed. The name of the patch is 57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217188.", "other": {"cve": {"id": "CVE-2017-20161", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-02T16:15:10.530", "lastModified": "2023-01-09T18:40:45.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in rofl0r MacGeiger. Affected is the function dump_wlan_at of the file macgeiger.c of the component ESSID Handler. The manipulation leads to injection. Access to the local network is required for this attack to succeed. The name of the patch is 57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217188."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.2, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:macgeiger_project:macgeiger:*:*:*:*:*:*:*:*", "versionEndExcluding": "2017-12-02", "matchCriteriaId": "96142933-882B-4C84-B2C9-B0E74DCE99F7"}]}]}], "references": [{"url": "https://github.com/rofl0r/MacGeiger/commit/57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217188", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217188", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rofl0r/MacGeiger/commit/57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb"}}