{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\DataObject\\ClassDefinition;\n\nuse Pimcore\\Loader\\ImplementationLoader\\LoaderInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Tool;\n\nclass Service\n{\n    /**\n     * @var bool\n     */\n    private static $doRemoveDynamicOptions = false;\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function doRemoveDynamicOptions(): bool\n    {\n        return self::$doRemoveDynamicOptions;\n    }\n\n    /**\n     * @internal\n     *\n     * @param bool $doRemoveDynamicOptions\n     */\n    public static function setDoRemoveDynamicOptions(bool $doRemoveDynamicOptions): void\n    {\n        self::$doRemoveDynamicOptions = $doRemoveDynamicOptions;\n    }\n\n    /**\n     *\n     * @param  DataObject\\ClassDefinition $class\n     *\n     * @return string\n     */\n    public static function generateClassDefinitionJson($class)\n    {\n        $class = clone $class;\n        if ($class->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($class->layoutDefinitions);\n        }\n\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($class));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->name, $data->creationDate, $data->userOwner, $data->userModification, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    private static function removeDynamicOptionsFromLayoutDefinition(&$layout)\n    {\n        if (method_exists($layout, 'resolveBlockedVars')) {\n            $blockedVars = $layout->resolveBlockedVars();\n            foreach ($blockedVars as $blockedVar) {\n                if (isset($layout->{$blockedVar})) {\n                    unset($layout->{$blockedVar});\n                }\n            }\n\n            if (isset($layout->blockedVarsForExport)) {\n                unset($layout->blockedVarsForExport);\n            }\n        }\n\n        if (method_exists($layout, 'getChildren')) {\n            $children = $layout->getChildren();\n            if (is_array($children)) {\n                foreach ($children as $child) {\n                    if ($child instanceof DataObject\\ClassDefinition\\Data\\Select) {\n                        if ($child->getOptionsProviderClass()) {\n                            $child->options = null;\n                        }\n                    }\n                    self::removeDynamicOptionsFromLayoutDefinition($child);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition $class\n     * @param string $json\n     * @param bool $throwException\n     * @param bool $ignoreId\n     *\n     * @return bool\n     */\n    public static function importClassDefinitionFromJson($class, $json, $throwException = false, $ignoreId = false)\n    {\n        $userId = 0;\n        $user = \\Pimcore\\Tool\\Admin::getCurrentUser();\n        if ($user) {\n            $userId = $user->getId();\n        }\n\n        $importData = json_decode($json, true);\n\n        if ($importData['layoutDefinitions'] !== null) {\n            // set layout-definition\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            if ($layout === false) {\n                return false;\n            }\n            $class->setLayoutDefinitions($layout);\n        }\n\n        // set properties of class\n        if (isset($importData['id']) && $importData['id'] && !$ignoreId) {\n            $class->setId($importData['id']);\n        }\n        $class->setModificationDate(time());\n        $class->setUserModification($userId);\n        $importPropertyNames = [\n            'description',\n            'icon',\n            'group',\n            'allowInherit',\n            'allowVariants',\n            'showVariants',\n            'parentClass',\n            'implementsInterfaces',\n            'listingParentClass',\n            'useTraits',\n            'listingUseTraits',\n            'previewUrl',\n            'propertyVisibility',\n            'linkGeneratorReference',\n            'previewGeneratorReference',\n            'compositeIndices',\n            'generateTypeDeclarations',\n            'showFieldLookup',\n            'enableGridLocking',\n            'showAppLoggerTab',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $class->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $class->save();\n\n        return true;\n    }\n\n    /**\n     * @param DataObject\\Fieldcollection\\Definition $fieldCollection\n     *\n     * @return string\n     */\n    public static function generateFieldCollectionJson($fieldCollection)\n    {\n        $fieldCollection = clone $fieldCollection;\n        if ($fieldCollection->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($fieldCollection->layoutDefinitions);\n        }\n\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($fieldCollection));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->key, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    /**\n     * @param DataObject\\Fieldcollection\\Definition $fieldCollection\n     * @param string $json\n     * @param bool $throwException\n     *\n     * @return bool\n     */\n    public static function importFieldCollectionFromJson($fieldCollection, $json, $throwException = false)\n    {\n        $importData = json_decode($json, true);\n\n        if (!is_null($importData['layoutDefinitions'])) {\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            $fieldCollection->setLayoutDefinitions($layout);\n        }\n\n        $importPropertyNames = [\n            'parentClass',\n            'implementsInterfaces',\n            'title',\n            'group',\n            'generateTypeDeclarations',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $fieldCollection->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $fieldCollection->save();\n\n        return true;\n    }\n\n    /**\n     * @param DataObject\\Objectbrick\\Definition $objectBrick\n     *\n     * @return string\n     */\n    public static function generateObjectBrickJson($objectBrick)\n    {\n        $objectBrick = clone $objectBrick;\n\n        // set classname attribute to the real class name not to the class ID\n        // this will allow to import the brick on a different instance with identical class names but different class IDs\n        if (is_array($objectBrick->getClassDefinitions())) {\n            foreach ($objectBrick->getClassDefinitions() as &$cd) {\n                // for compatibility (upgraded pimcore4s that may deliver class ids in $cd['classname'] we need to\n                // get the class by id in order to be able to correctly set the classname for the generated json\n                if (!$class = DataObject\\ClassDefinition::getByName($cd['classname'])) {\n                    $class = DataObject\\ClassDefinition::getById($cd['classname']);\n                }\n\n                if ($class) {\n                    $cd['classname'] = $class->getName();\n                }\n            }\n        }\n\n        if ($objectBrick->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($objectBrick->layoutDefinitions);\n        }\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($objectBrick));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->key, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    public static function generateCustomLayoutJson(CustomLayout $customLayout): string\n    {\n        if ($layoutDefinitions = $customLayout->getLayoutDefinitions()) {\n            self::removeDynamicOptionsFromLayoutDefinition($layoutDefinitions);\n        }\n        self::setDoRemoveDynamicOptions(true);\n        $data = [\n            'description' => $customLayout->getDescription(),\n            'layoutDefinitions' => json_decode(json_encode($layoutDefinitions)),\n            'default' => $customLayout->getDefault() ?: 0,\n        ];\n        self::setDoRemoveDynamicOptions(false);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    /**\n     * @param DataObject\\Objectbrick\\Definition $objectBrick\n     * @param string $json\n     * @param bool $throwException\n     *\n     * @return bool\n     */\n    public static function importObjectBrickFromJson($objectBrick, $json, $throwException = false)\n    {\n        $importData = json_decode($json, true);\n\n        // reverse map the class name to the class ID, see: self::generateObjectBrickJson()\n        $toAssignClassDefinitions = [];\n        if (is_array($importData['classDefinitions'])) {\n            foreach ($importData['classDefinitions'] as &$cd) {\n                if (is_numeric($cd['classname'])) {\n                    $class = DataObject\\ClassDefinition::getById($cd['classname']);\n                    if ($class) {\n                        $cd['classname'] = $class->getName();\n                        $toAssignClassDefinitions[] = $cd;\n                    }\n                } else {\n                    $class = DataObject\\ClassDefinition::getByName($cd['classname']);\n                    if ($class) {\n                        $toAssignClassDefinitions[] = $cd;\n                    }\n                }\n            }\n        }\n\n        if ($importData['layoutDefinitions'] !== null) {\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            $objectBrick->setLayoutDefinitions($layout);\n        }\n\n        $objectBrick->setClassDefinitions($toAssignClassDefinitions);\n        $importPropertyNames = [\n            'parentClass',\n            'implementsInterfaces',\n            'title',\n            'group',\n            'generateTypeDeclarations',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $objectBrick->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $objectBrick->save();\n\n        return true;\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $array\n     * @param bool $throwException\n     * @param bool $insideLocalizedField\n     *\n     * @return Data|Layout|false\n     *\n     * @throws \\Exception\n     */\n    public static function generateLayoutTreeFromArray($array, $throwException = false, $insideLocalizedField = false)\n    {\n        if (is_array($array) && count($array) > 0) {\n            if ($name = $array['name'] ?? false) {\n                if (preg_match('/<.+?>/', $name)) {\n                    throw new \\Exception('not a valid name:' . htmlentities($name));\n                }\n            }\n\n            /** @var LoaderInterface $loader */\n            $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.object.' . $array['datatype']);\n\n            if ($loader->supports($array['fieldtype'])) {\n                /** @var Data|Layout $item */\n                $item = $loader->build($array['fieldtype']);\n\n                $insideLocalizedField = $insideLocalizedField || $item instanceof DataObject\\ClassDefinition\\Data\\Localizedfields;\n\n                if (method_exists($item, 'addChild')) { // allows children\n                    $item->setValues($array, ['children', 'childs']);\n                    $children = $array['children'] ?? $array['childs'] ?? [];\n\n                    if (!empty($children['datatype'])) {\n                        $childO = self::generateLayoutTreeFromArray($children, $throwException, $insideLocalizedField);\n                        $item->addChild($childO);\n                    } elseif (is_array($children) && count($children) > 0) {\n                        foreach ($children as $child) {\n                            $childO = self::generateLayoutTreeFromArray($child, $throwException, $insideLocalizedField);\n                            if ($childO !== false) {\n                                $item->addChild($childO);\n                            } else {\n                                if ($throwException) {\n                                    throw new \\Exception('Could not add child ' . var_export($child, true));\n                                }\n\n                                Logger::err('Could not add child ' . var_export($child, true));\n\n                                return false;\n                            }\n                        }\n                    }\n                } else {\n                    //for BC reasons\n                    $blockedVars = [];\n                    if (method_exists($item, 'resolveBlockedVars')) {\n                        $blockedVars = $item->resolveBlockedVars();\n                    }\n                    self::removeDynamicOptionsFromArray($array, $blockedVars);\n                    $item->setValues($array);\n\n                    if ($item instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                        $item->setupDelegate($array);\n                    }\n                }\n\n                return $item;\n            }\n        }\n        if ($throwException) {\n            throw new \\Exception('Could not add child ' . var_export($array, true));\n        }\n\n        return false;\n    }\n\n    /**\n     * @param mixed $data\n     * @param array $blockedVars\n     */\n    private static function removeDynamicOptionsFromArray(&$data, $blockedVars)\n    {\n        foreach ($blockedVars as $blockedVar) {\n            if (isset($data[$blockedVar])) {\n                unset($data[$blockedVar]);\n            }\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $tableDefinitions\n     * @param array $tableNames\n     */\n    public static function updateTableDefinitions(&$tableDefinitions, $tableNames)\n    {\n        if (!is_array($tableDefinitions)) {\n            $tableDefinitions = [];\n        }\n\n        $db = \\Pimcore\\Db::get();\n        $tmp = [];\n        foreach ($tableNames as $tableName) {\n            $tmp[$tableName] = $db->fetchAllAssociative('show columns from ' . $tableName);\n        }\n\n        foreach ($tmp as $tableName => $columns) {\n            foreach ($columns as $column) {\n                $column['Type'] = strtolower($column['Type']);\n                if (strtolower($column['Null']) === 'yes') {\n                    $column['Null'] = 'null';\n                }\n                //                $fieldName = strtolower($column[\"Field\"]);\n                $fieldName = $column['Field'];\n                $tableDefinitions[$tableName][$fieldName] = $column;\n            }\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $tableDefinitions\n     * @param string $table\n     * @param string $colName\n     * @param string $type\n     * @param string $default\n     * @param string $null\n     *\n     * @return bool\n     */\n    public static function skipColumn($tableDefinitions, $table, $colName, $type, $default, $null)\n    {\n        $tableDefinition = $tableDefinitions[$table] ?? false;\n        if ($tableDefinition) {\n            $colDefinition = $tableDefinition[$colName] ?? false;\n            if ($colDefinition) {\n                if (!strlen($default) && strtolower($null) === 'null') {\n                    $default = null;\n                }\n\n                if (str_replace(' ', '', strtolower($colDefinition['Type'])) === str_replace(' ', '', strtolower($type)) &&\n                        strtolower($colDefinition['Null']) == strtolower($null) &&\n                        $colDefinition['Default'] == $default) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $implementsParts\n     * @param string|null $newInterfaces A comma separated list of interfaces\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildImplementsInterfacesCode($implementsParts, ?string $newInterfaces)\n    {\n        if ($newInterfaces) {\n            $customParts = explode(',', $newInterfaces);\n            foreach ($customParts as $interface) {\n                $interface = trim($interface);\n                if (Tool::interfaceExists($interface)) {\n                    $implementsParts[] = $interface;\n                } else {\n                    throw new \\Exception(\"interface '\" . $interface . \"' does not exist\");\n                }\n            }\n        }\n\n        if ($implementsParts) {\n            return ' implements ' . implode(', ', $implementsParts);\n        }\n\n        return '';\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $useParts\n     * @param string|null $newTraits\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildUseTraitsCode($useParts, ?string $newTraits)\n    {\n        if (!is_array($useParts)) {\n            $useParts = [];\n        }\n\n        if ($newTraits) {\n            $customParts = explode(',', $newTraits);\n            foreach ($customParts as $trait) {\n                $trait = trim($trait);\n                if (Tool::traitExists($trait)) {\n                    $useParts[] = $trait;\n                } else {\n                    throw new \\Exception(\"trait '\" . $trait . \"' does not exist\");\n                }\n            }\n        }\n\n        return self::buildUseCode($useParts);\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $useParts\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildUseCode($useParts)\n    {\n        if ($useParts) {\n            $result = '';\n            foreach ($useParts as $part) {\n                $result .= 'use ' . $part . \";\\r\\n\";\n            }\n            $result .= \"\\n\";\n\n            return $result;\n        }\n\n        return '';\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\DataObject\\ClassDefinition;\n\nuse Pimcore\\Loader\\ImplementationLoader\\LoaderInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Tool;\n\nclass Service\n{\n    /**\n     * @var bool\n     */\n    private static $doRemoveDynamicOptions = false;\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function doRemoveDynamicOptions(): bool\n    {\n        return self::$doRemoveDynamicOptions;\n    }\n\n    /**\n     * @internal\n     *\n     * @param bool $doRemoveDynamicOptions\n     */\n    public static function setDoRemoveDynamicOptions(bool $doRemoveDynamicOptions): void\n    {\n        self::$doRemoveDynamicOptions = $doRemoveDynamicOptions;\n    }\n\n    /**\n     *\n     * @param  DataObject\\ClassDefinition $class\n     *\n     * @return string\n     */\n    public static function generateClassDefinitionJson($class)\n    {\n        $class = clone $class;\n        if ($class->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($class->layoutDefinitions);\n        }\n\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($class));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->name, $data->creationDate, $data->userOwner, $data->userModification, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    private static function removeDynamicOptionsFromLayoutDefinition(&$layout)\n    {\n        if (method_exists($layout, 'resolveBlockedVars')) {\n            $blockedVars = $layout->resolveBlockedVars();\n            foreach ($blockedVars as $blockedVar) {\n                if (isset($layout->{$blockedVar})) {\n                    unset($layout->{$blockedVar});\n                }\n            }\n\n            if (isset($layout->blockedVarsForExport)) {\n                unset($layout->blockedVarsForExport);\n            }\n        }\n\n        if (method_exists($layout, 'getChildren')) {\n            $children = $layout->getChildren();\n            if (is_array($children)) {\n                foreach ($children as $child) {\n                    if ($child instanceof DataObject\\ClassDefinition\\Data\\Select) {\n                        if ($child->getOptionsProviderClass()) {\n                            $child->options = null;\n                        }\n                    }\n                    self::removeDynamicOptionsFromLayoutDefinition($child);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition $class\n     * @param string $json\n     * @param bool $throwException\n     * @param bool $ignoreId\n     *\n     * @return bool\n     */\n    public static function importClassDefinitionFromJson($class, $json, $throwException = false, $ignoreId = false)\n    {\n        $userId = 0;\n        $user = \\Pimcore\\Tool\\Admin::getCurrentUser();\n        if ($user) {\n            $userId = $user->getId();\n        }\n\n        $importData = json_decode($json, true);\n\n        if ($importData['layoutDefinitions'] !== null) {\n            // set layout-definition\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            if ($layout === false) {\n                return false;\n            }\n            $class->setLayoutDefinitions($layout);\n        }\n\n        // set properties of class\n        if (isset($importData['id']) && $importData['id'] && !$ignoreId) {\n            $class->setId($importData['id']);\n        }\n        $class->setModificationDate(time());\n        $class->setUserModification($userId);\n        $importPropertyNames = [\n            'description',\n            'icon',\n            'group',\n            'allowInherit',\n            'allowVariants',\n            'showVariants',\n            'parentClass',\n            'implementsInterfaces',\n            'listingParentClass',\n            'useTraits',\n            'listingUseTraits',\n            'previewUrl',\n            'propertyVisibility',\n            'linkGeneratorReference',\n            'previewGeneratorReference',\n            'compositeIndices',\n            'generateTypeDeclarations',\n            'showFieldLookup',\n            'enableGridLocking',\n            'showAppLoggerTab',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $class->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $class->save();\n\n        return true;\n    }\n\n    /**\n     * @param DataObject\\Fieldcollection\\Definition $fieldCollection\n     *\n     * @return string\n     */\n    public static function generateFieldCollectionJson($fieldCollection)\n    {\n        $fieldCollection = clone $fieldCollection;\n        if ($fieldCollection->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($fieldCollection->layoutDefinitions);\n        }\n\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($fieldCollection));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->key, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    /**\n     * @param DataObject\\Fieldcollection\\Definition $fieldCollection\n     * @param string $json\n     * @param bool $throwException\n     *\n     * @return bool\n     */\n    public static function importFieldCollectionFromJson($fieldCollection, $json, $throwException = false)\n    {\n        $importData = json_decode($json, true);\n\n        if (!is_null($importData['layoutDefinitions'])) {\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            $fieldCollection->setLayoutDefinitions($layout);\n        }\n\n        $importPropertyNames = [\n            'parentClass',\n            'implementsInterfaces',\n            'title',\n            'group',\n            'generateTypeDeclarations',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $fieldCollection->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $fieldCollection->save();\n\n        return true;\n    }\n\n    /**\n     * @param DataObject\\Objectbrick\\Definition $objectBrick\n     *\n     * @return string\n     */\n    public static function generateObjectBrickJson($objectBrick)\n    {\n        $objectBrick = clone $objectBrick;\n\n        // set classname attribute to the real class name not to the class ID\n        // this will allow to import the brick on a different instance with identical class names but different class IDs\n        if (is_array($objectBrick->getClassDefinitions())) {\n            foreach ($objectBrick->getClassDefinitions() as &$cd) {\n                // for compatibility (upgraded pimcore4s that may deliver class ids in $cd['classname'] we need to\n                // get the class by id in order to be able to correctly set the classname for the generated json\n                if (!$class = DataObject\\ClassDefinition::getByName($cd['classname'])) {\n                    $class = DataObject\\ClassDefinition::getById($cd['classname']);\n                }\n\n                if ($class) {\n                    $cd['classname'] = $class->getName();\n                }\n            }\n        }\n\n        if ($objectBrick->layoutDefinitions instanceof Layout) {\n            self::removeDynamicOptionsFromLayoutDefinition($objectBrick->layoutDefinitions);\n        }\n        self::setDoRemoveDynamicOptions(true);\n        $data = json_decode(json_encode($objectBrick));\n        self::setDoRemoveDynamicOptions(false);\n        unset($data->key, $data->fieldDefinitions);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    public static function generateCustomLayoutJson(CustomLayout $customLayout): string\n    {\n        if ($layoutDefinitions = $customLayout->getLayoutDefinitions()) {\n            self::removeDynamicOptionsFromLayoutDefinition($layoutDefinitions);\n        }\n        self::setDoRemoveDynamicOptions(true);\n        $data = [\n            'description' => $customLayout->getDescription(),\n            'layoutDefinitions' => json_decode(json_encode($layoutDefinitions)),\n            'default' => $customLayout->getDefault() ?: 0,\n        ];\n        self::setDoRemoveDynamicOptions(false);\n\n        return json_encode($data, JSON_PRETTY_PRINT);\n    }\n\n    /**\n     * @param DataObject\\Objectbrick\\Definition $objectBrick\n     * @param string $json\n     * @param bool $throwException\n     *\n     * @return bool\n     */\n    public static function importObjectBrickFromJson($objectBrick, $json, $throwException = false)\n    {\n        $importData = json_decode($json, true);\n\n        // reverse map the class name to the class ID, see: self::generateObjectBrickJson()\n        $toAssignClassDefinitions = [];\n        if (is_array($importData['classDefinitions'])) {\n            foreach ($importData['classDefinitions'] as &$cd) {\n                if (is_numeric($cd['classname'])) {\n                    $class = DataObject\\ClassDefinition::getById($cd['classname']);\n                    if ($class) {\n                        $cd['classname'] = $class->getName();\n                        $toAssignClassDefinitions[] = $cd;\n                    }\n                } else {\n                    $class = DataObject\\ClassDefinition::getByName($cd['classname']);\n                    if ($class) {\n                        $toAssignClassDefinitions[] = $cd;\n                    }\n                }\n            }\n        }\n\n        if ($importData['layoutDefinitions'] !== null) {\n            $layout = self::generateLayoutTreeFromArray($importData['layoutDefinitions'], $throwException);\n            $objectBrick->setLayoutDefinitions($layout);\n        }\n\n        $objectBrick->setClassDefinitions($toAssignClassDefinitions);\n        $importPropertyNames = [\n            'parentClass',\n            'implementsInterfaces',\n            'title',\n            'group',\n            'generateTypeDeclarations',\n        ];\n\n        foreach ($importPropertyNames as $importPropertyName) {\n            if (isset($importData[$importPropertyName])) {\n                $objectBrick->{'set' . ucfirst($importPropertyName)}($importData[$importPropertyName]);\n            }\n        }\n\n        $objectBrick->save();\n\n        return true;\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $array\n     * @param bool $throwException\n     * @param bool $insideLocalizedField\n     *\n     * @return Data|Layout|false\n     *\n     * @throws \\Exception\n     */\n    public static function generateLayoutTreeFromArray($array, $throwException = false, $insideLocalizedField = false)\n    {\n        if (is_array($array) && count($array) > 0) {\n            if ($title = $array['title'] ?? false) {\n                if (preg_match('/<.+?>/', $title)) {\n                    throw new \\Exception('not a valid title:' . htmlentities($title));\n                }\n            }\n            if ($name = $array['name'] ?? false) {\n                if (preg_match('/<.+?>/', $name)) {\n                    throw new \\Exception('not a valid name:' . htmlentities($name));\n                }\n            }\n\n            /** @var LoaderInterface $loader */\n            $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.object.' . $array['datatype']);\n\n            if ($loader->supports($array['fieldtype'])) {\n                /** @var Data|Layout $item */\n                $item = $loader->build($array['fieldtype']);\n\n                $insideLocalizedField = $insideLocalizedField || $item instanceof DataObject\\ClassDefinition\\Data\\Localizedfields;\n\n                if (method_exists($item, 'addChild')) { // allows children\n                    $item->setValues($array, ['children', 'childs']);\n                    $children = $array['children'] ?? $array['childs'] ?? [];\n\n                    if (!empty($children['datatype'])) {\n                        $childO = self::generateLayoutTreeFromArray($children, $throwException, $insideLocalizedField);\n                        $item->addChild($childO);\n                    } elseif (is_array($children) && count($children) > 0) {\n                        foreach ($children as $child) {\n                            $childO = self::generateLayoutTreeFromArray($child, $throwException, $insideLocalizedField);\n                            if ($childO !== false) {\n                                $item->addChild($childO);\n                            } else {\n                                if ($throwException) {\n                                    throw new \\Exception('Could not add child ' . var_export($child, true));\n                                }\n\n                                Logger::err('Could not add child ' . var_export($child, true));\n\n                                return false;\n                            }\n                        }\n                    }\n                } else {\n                    //for BC reasons\n                    $blockedVars = [];\n                    if (method_exists($item, 'resolveBlockedVars')) {\n                        $blockedVars = $item->resolveBlockedVars();\n                    }\n                    self::removeDynamicOptionsFromArray($array, $blockedVars);\n                    $item->setValues($array);\n\n                    if ($item instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                        $item->setupDelegate($array);\n                    }\n                }\n\n                return $item;\n            }\n        }\n        if ($throwException) {\n            throw new \\Exception('Could not add child ' . var_export($array, true));\n        }\n\n        return false;\n    }\n\n    /**\n     * @param mixed $data\n     * @param array $blockedVars\n     */\n    private static function removeDynamicOptionsFromArray(&$data, $blockedVars)\n    {\n        foreach ($blockedVars as $blockedVar) {\n            if (isset($data[$blockedVar])) {\n                unset($data[$blockedVar]);\n            }\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $tableDefinitions\n     * @param array $tableNames\n     */\n    public static function updateTableDefinitions(&$tableDefinitions, $tableNames)\n    {\n        if (!is_array($tableDefinitions)) {\n            $tableDefinitions = [];\n        }\n\n        $db = \\Pimcore\\Db::get();\n        $tmp = [];\n        foreach ($tableNames as $tableName) {\n            $tmp[$tableName] = $db->fetchAllAssociative('show columns from ' . $tableName);\n        }\n\n        foreach ($tmp as $tableName => $columns) {\n            foreach ($columns as $column) {\n                $column['Type'] = strtolower($column['Type']);\n                if (strtolower($column['Null']) === 'yes') {\n                    $column['Null'] = 'null';\n                }\n                //                $fieldName = strtolower($column[\"Field\"]);\n                $fieldName = $column['Field'];\n                $tableDefinitions[$tableName][$fieldName] = $column;\n            }\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $tableDefinitions\n     * @param string $table\n     * @param string $colName\n     * @param string $type\n     * @param string $default\n     * @param string $null\n     *\n     * @return bool\n     */\n    public static function skipColumn($tableDefinitions, $table, $colName, $type, $default, $null)\n    {\n        $tableDefinition = $tableDefinitions[$table] ?? false;\n        if ($tableDefinition) {\n            $colDefinition = $tableDefinition[$colName] ?? false;\n            if ($colDefinition) {\n                if (!strlen($default) && strtolower($null) === 'null') {\n                    $default = null;\n                }\n\n                if (str_replace(' ', '', strtolower($colDefinition['Type'])) === str_replace(' ', '', strtolower($type)) &&\n                        strtolower($colDefinition['Null']) == strtolower($null) &&\n                        $colDefinition['Default'] == $default) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $implementsParts\n     * @param string|null $newInterfaces A comma separated list of interfaces\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildImplementsInterfacesCode($implementsParts, ?string $newInterfaces)\n    {\n        if ($newInterfaces) {\n            $customParts = explode(',', $newInterfaces);\n            foreach ($customParts as $interface) {\n                $interface = trim($interface);\n                if (Tool::interfaceExists($interface)) {\n                    $implementsParts[] = $interface;\n                } else {\n                    throw new \\Exception(\"interface '\" . $interface . \"' does not exist\");\n                }\n            }\n        }\n\n        if ($implementsParts) {\n            return ' implements ' . implode(', ', $implementsParts);\n        }\n\n        return '';\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $useParts\n     * @param string|null $newTraits\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildUseTraitsCode($useParts, ?string $newTraits)\n    {\n        if (!is_array($useParts)) {\n            $useParts = [];\n        }\n\n        if ($newTraits) {\n            $customParts = explode(',', $newTraits);\n            foreach ($customParts as $trait) {\n                $trait = trim($trait);\n                if (Tool::traitExists($trait)) {\n                    $useParts[] = $trait;\n                } else {\n                    throw new \\Exception(\"trait '\" . $trait . \"' does not exist\");\n                }\n            }\n        }\n\n        return self::buildUseCode($useParts);\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $useParts\n     *\n     * @return string\n     *\n     * @throws \\Exception\n     */\n    public static function buildUseCode($useParts)\n    {\n        if ($useParts) {\n            $result = '';\n            foreach ($useParts as $part) {\n                $result .= 'use ' . $part . \";\\r\\n\";\n            }\n            $result .= \"\\n\";\n\n            return $result;\n        }\n\n        return '';\n    }\n}\n"], "filenames": ["models/DataObject/ClassDefinition/Service.php"], "buggy_code_start_loc": [343], "buggy_code_end_loc": [343], "fixing_code_start_loc": [344], "fixing_code_end_loc": [349], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.5.14.", "other": {"cve": {"id": "CVE-2023-0323", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-16T15:15:10.390", "lastModified": "2023-01-24T16:22:22.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.5.14."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.14", "matchCriteriaId": "CF3F351E-9D60-4F89-A0BF-5BEC56B34DED"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/746fac1a342841624f63ab13edcd340358e1bc04", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/129d6a4b-0504-4de1-a72c-3f12c4552343", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/746fac1a342841624f63ab13edcd340358e1bc04"}}